<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"702fcecca84c2434b5bae2a8f43292e8922c3de42b1a54ec3977c4d496a6adcd713687992f01adb513bc63c79988849591decf1f9775f8950ed9388a080d2bc46d6d7687cb05a6aa6de6c4cde68958305c9d38bbb8014922ae4d70e27d938d4334f5490935b91b59053fb938c6585e01b910709bfe51033b1d97675140eed110558e0e64ac1402028a1c75e602b7fbdc64064deb69fa5c9dd6e46c0a8bcad59ea2ebfb8f5ed01797a2ae82591e1a852d364a99193e14d563ab706434d0f02cb784ba54a098bdc678401e7235aa92cddc9c51b4cb10181ca5ec27f6291a0ee2c73aef8bf3446506c1eb9171ab06412f6b6bff35b798f0baea1ca7df9a713683a32f122e7d8a39812025a2747d2a807e2bd8faf9e8ca71bdf41e316481f46a26cbec27efeee6fd74ada98ea7b73e50da58da9c9381f2d54026b92d980134baffae695eb86570b06ef5ff428db2472f41dbb1ae8b61b489f1efa763947af80bc20bb330baf8b049bf007b8773831307a85543b0b41291a7a1ba3fd95e91e976700e2490792af3f9d64ab27e8ffc1d9e5fea8a93fad39f76b6d72e86d63f8f85924479a38a6cdfbe1a1d1ff4974b3e78ad3927352f23ce9828abcff7ad82f9600c4cca8a3fa59261bb754e2e86c5ae9ee33057b49570f3db3ab1f06c58802ac0a56e415e5f30df39c2411dfc022b22aa26073c6492b7f26d511e21294be2d1d75aff7a7bb763132d5c8cab8c29c3ffe91c4fd02c71f993bcdda2c0f29ba3c52ea87c9b7d727ce3db2397cb1630cd6c07c6bcdcef0442c9e733aafc4c27fa833ab250e7fafc78a188935445dea86b9b3daa5393e868e1d5181968beea9811f0324c1f6d3f83bac86c381e7016b0b3201a64a892b0307198f848e9e52c5e2c08503b8f9074d0ead89f0725025a947cf59d6d2b2116bb8ee349f84d1573f5103a552814146f9deca4bbb23eecd7bda3df3fc4159570850d03dfbd3f7a1a3d183bf2d1011e335c403d9a9012f5b19b192fd9f2785923926a42707dcd81511dc00e3bc0f37229e85e64f0b2d2633af8df2ffeeb7fd85cfb3ee1fd1cf82bf78c2ff6032bc510f664174d27602ebaad787a39982046687422b96ca94cbf7c22d393f98ce59194e24d657790d20d1e75838439008e3cdae1b41d35ad8ede17e00d39757cdd8a0c0a5aada695adf39cb975a614640c3e8f67aa4d5496c96d4be4b1ec0a838295b9036204d07490c175433fc7a57bf7381131c62479935e8951ed68534a2b005efa93f3ea26d70db6c0c5ba2e62784b05bf421675388045ab7e8a59113a3f3b05217dc144e74269cd5fcac3f113ad37b134f40638db9119381297c5c768f28796d5968dddd7140c058d8fbd68784ffc9b24afc88fa91c70f3cb8ecbdb0236da44eab18930683d3c6f8a347e94d2cb661619bbd9dea143e64754b9a9b63b211448de02f427cd8029b8e4bfcd40e46766e2eb200b55808952ef27ad015e866d799af3f78b70bfe6ff342f51c6faad651373680bcad3792fe086344c222b1b2db8968ae609be5a08564c82e51dfe9e15cca31ccd98d8044256cefc467fbc9adffdce4e0dbca4b594e3aa641b76ac51bb9299a5788cb4531eea36091e6627906d327b2e1b845ec3affa590a8d216f01385893aaadd45374d6219d5a35d6839120775bce57dc2b1e3bb72265d0bb5b85ac7937b1e8607872c47a0ae5962cb1628d4fd6f0dfffe854925a0156a9dbdc8a21c625467593907ffa7816a850a372326ec091921db8d55b65b3a42f8ff1164b4f2f237e155c027e0ee4105e1d8c072771fb8b8ac1ee847f444378469200d6af31e9f5796773c56b82341b13c5667942fbe48b1d1c8d7cbeac5d5607f4e6dcb035ac10a41ba285219a290426572d2f8afbf4cacc7bb27e48a1b00ae5042dc949e1923fdfd3f4842f8f6a8b444d91c878f531025755f3b7bad1325e0ad5311a7afff058fbd10c72bde7164df4636a566213b4d4d838b955dbeeff8b4f30854b61766e31e9cdf8e179407e763f8801e34c05e5a4e615e5995f731cf078e2539c30b7b58aba502cf8f519f8b40a5ea529a78252a4e3cee4494e96edf9ee93249f7c53a02180e387498586687c3569baf84d9838ea62e2c23e5424373916b3222f1f682f453e3532eb8d809cf764dccb67dfd0b172028fa7c0ccdef796158608bf93d8b8f439e0c1b64b600d529130a45eb4718b655aa749be6ea77f16ca2a2a575926a1f1dfb3591cddc4510d9166082b4e8824b212ef6bd876c1b97d26c975b255e8930094ac72be6eed2e9ae26b6917c873d167c83ed5f1b310d6d55a7fefb7bce994ed2ac07ba5a9795a50f2e4906f5e3a750a1f50fb0dfd9535b30e173d0f3b016ba741e55ccbc4bb17d0051b8f580c7c007645927d6fd80942bcb7d1356328109322157d7806fa428522d23d7fcf4007f7bd86721ec0ecd6cdd2469d58e5f6a4d91f0f2e9c2b1aa122b688c34b69312acbc80a7173bd8d5e901e9f0a0fbe9206e7f518f04ac65fee12d3dff1a31fb05fbe3c517c67564ee7912d6197088be1cac1fca22dca23da0de8decc165fb9bdb6dab2290a8e17e60f3570ae206c09360db0e9e379d3bd8731e3a903ab68522e16b531f0e9db5328922cc23f52669ca1d3c7232916db2f00165f6241b8aa756d4a50c99b2dd13d572024f4d824be666434509e599d7ab35e1694a86eaff2b15f3d9f12684b9ae99ee9155de5614bdf1f7cb2c4d4d749bb3620579dad73b59c8883c3c5ddf4e8bcc256c54e99d764a6b6df20ab9ab67a6294fed15850a0a5d342edcf4ffaed7178efc6488891348f7ffd0b48d8423ae2f10713e6bcf446486b3f7056f74a682133d16dfa531edc2006ff3f501a54457de138a5c17bd5e42b06014d07fa6a402e1012eb6b4a5ee7bfb99ac635806672c50659c3d0ffd273667b8a7655bdf0c2cb6fcf04872f3a63166c17ccbedb6ded0245b29a6090ef3f0cc37f4da75e045ffc514c37ba339f222338ee798bd2794c38548d366f3d7abe99d475d74d4d5a7593468b4ef81f78e2491883ef5f87b7e41906d015585431f04cb60b119489971349b62ef73c18f2cd72bfd91688a894f0a1d05729ca5ac582b9d1ef14e7f2d0c3dc0f38f5c7656477d7cd5d8627c17e713f7e2fa402105de1043896d42832fbbc48e28ec72fb572b0552b0dd56c9183bb5deff24a25e194b55d3e5c6c2ecd3cbe1e9ded47d47ab530f6b9540d6a856f8b275cf6fe2b46d57ba2939d36d52940a57bb5bc54747d950b793d8a5ea1ab66f68991a822626dc2653fd75d8b325b76ba2543bfccd1dfc7fe7559b8ad1bc756852c1525f3cb298b13aa852b258f6757681b7fab7a3f1f7e21b9c66c86a75ac5fa834f80bfbf1c9072660b9722c89aad13bcd71a5e268495e0a5450b59a80931289aca06ed60c09f083323ad71fdb4ca2241bb4da3c29ae550cc986c3227fee1dda7d629c20693a2f924a205ad70c4dd7ca11956f9f4474a88d0543482fe968c520c3446ef5c331c7ad6c98db6bbb4c985d7ad0a4f41579c60f2cc6d029d198e753b161ad03818fcc5e72d254dfd37dc19f8d34a9e64a4dba0ed600a300de987d046ae33618d7ad4ae7752954c2d5e918b7bc65b948954d5a9590903910ac93c4e4f696ffd27246d4b4eb2fb2a18bf47e46bfc6dd71755082126e6e80d921ff817566b1ebb3085c0b2fd7160e85339e11dbc3372354b7c0decb094f316d4cce1f296ce9bd32e6e66825fc1d83bdc44f8038e0cae5f5beee4193818c9943d542f1b0638af94c150714914ceeebafc216e008b65145a011fb678450879a5e929e505d9bdebc261c110fedd52669d0f4ae93038ecc814deec446eb2c86d5e6c28076a716a30b6689d318930302c8255a04017b89f3663f90ff89aa7468a5a5fe1b0d785411aaee7033b28bd266a9d17355bb9ccb564c91bb5a19aa376ea56cfa9eec4a725bcddd49ff76267674d7a0a430a3c8269e54223951a02ad981fb27b909e706721d3afd514eba4188de5c69f672c49677a7f296c88fd5179747f860cc0cf7a0d7971472f2b7aca869dce3da3eba4875805ba271f589fb81676c119e3fdb7bfc601990fc4c65cd6bb30fdef643dc1cbe2756cff78c28e1add878a0f974e31d41aff94e2e36eab9a3904388d3c32d5f231cb28808d79c56a63e8b6e13411d9b6b63eefe06c7312a556d3406f2f7e11d5d3cd4482e5262c4ba48506c8645c1c4f84ac158209c360322c928cc977ccdc4d79b845d426ac43fcacea8e7eb64bd958404088df0c8bb80516fb56f1c3b693232b87146ce170b385e08c43cba44413ab107355a9d107f17234f2e9242855c09d39f5183dd3bbffc69e3f861aa10db8736fe64f3f7435d70629861f8a149b186dd3f508a1db6316e6d9fb8b2adb32b3bec9774cd8d8ff0d4ce4c39748e6187bbf46c61de3252881c79a5df34490931044fe9e5ce2078414dd62df8ad7673477f7881b8f5bb9ad1e58cbebf5ef90539978042bb507e48fa7192e6e4eb05698c36a17b59b155670e5975bc8edfa90ddb60f2dd3ed535cae8b51ec292b40370c4fd75a3c8e9f026d6a222226be3b754ad848d5221579770b121e3e7b77843593c05ae59fae4b0010975a7ab86bed981f590a5c7552efd96fc0cfc45fa6c8e787eac26303a9ad5b30a5d00a713cd55f8b3634c2b3a0c5610d902512e5c8f91f4cc0ff70e5dc86b45dc9016fa671b1a86972350e2fc5158730d3c37074769e938dbab6706e2bb544dbba9e7bf15810e61a0c27d850164fa2a09f65b40858ad57a6f3b5554975cd743d76b9b9104c8b7485dd98ed0b74312da27bf88b7a97d0b0ef51cd509c91e13fd869e6a3b67b1b7266a34ecfa43e856f95895fa4f5c40dac1700693f9c923e68181b11d948ed4861859e18bfdc99eb242df368dc840ee92b204d1d7bcf384c1017bba68e901daa14be41df5cf4d482ec8930ebf00bd83810fdad21de6c45c8d974de38467ac9a0e532fc8e6f02f58d4bba5b2838e3fc016d8f0680aff0ae51051d0e6ecfbe673ba25a9b6d72efb55daaad09a95e747897712fb1c8a8daa083927e47faf7d44e9181523ed58dad1824db885d97ff7349bfe2576939b15aa11d29c4a6cbcd2ba15a3629a22e28f515cabe4bfd8582e4a99e4886ae41d851932fc78f93d0594b5557fbf99eb356cad7cd94c6f9c2952e4947426e799557367042755c3a442e289157c3c5962a8d1eb8a647ab844dde3c077c1867a609ed91e170342504c94cf6a721f9d50b82082eea74a4609bb3265377fa458349a106c8303dc74c9d75fca31e8a5970db5685c90b5ca30f14f7b2cdfe8178ab3fc3b64e4b776356c1d0ade76f23d3abc422ee482c12e447fd002c1ecf192d8d7880168a6d7466a898b30c36b5a40ba49b20b2ea186bb7019da730d6663df21e4cf6451c99d3d70d9563add37d122ad67ff7a77654cda8f8a1d7425a31a55c3d37d924d033d02fd5c6ad905f75c6a4f9ef1caa366f46eafa42fd9245e6a218cded21b94787571139a161d02ca779287f07a43f0f2194668d5cb1f7e0d9ca4e2cde20a2b067857cfe420d320341f09d48550e941a33c9d3dc47057823966a62e584889fc97f1e5bd641df800f373f3b3c8692ae8e2376694cb57c63a159499e1563c743108693b2e51d6a36439c4a82b7dda148c387a86e8d65d396d543089aa631fb18bfe973be7365f45f837a1842894953dce38bffbb75ffc00d7c05098559f8c26e9c849c32e51100646779a152c809108b32b5b2b68675dbdb34de907b33d9f6ad1093b2e7f57ffa4a46cb1b7928ac760c4b59d46357a0390f49e763c297bf06bb945b82ae15aa1f0fd957733fa31df5c42fe3d1fa07218a9133ef329bb382bf21b7c7c7c979af5b79c3aefe11801e0fd4fe74c4ba0817ff0dbc838618afe2e553f574e3f4fbae6de48367fd4835c74fbb6691fc57879310533494365571e794aa0488019ef574f4522c684f8c2f357d9a555d810f25ff8187277d64ea0c75c0540cb1585554551cf39001ec16b548315ddc94b4b68df6a45a8f44d1cac42bee76ccbda757b67323c62f6d4208fcd50c3e2d2e96f33d40e63f2ce07b5281a6f0ac3dc3232d51f8db54df0e0284a9a9a3a0ba6613c069b24108c73f8f18889da17096eb3648864d8146fa132de7edbd8c840515322f9158d7446c5183af35584ac2d236365954c85a17ba61357f6493cf76b9238db00fe7f5c376a83e402072ed6f4dafac9fb5fa6c7d0cc76d734431a8160f3d6b77a3b74ec24d2f503c68feb48b1caf74c877167c55f09dc9ba370aac5dff39ad0d2f61c3d3ca0430a4f53d7f375d959261f458e8052380401c39e8af37ccb0aba19c3bdb29ca3ef108a489ad12ebdbb2f0683759818b3b94a11cebc7d713a0d19ebcc715d2351a096eb8f575fa54a0b907725359e023ab17190a023ba6cc74123430bf0d20fbbd13477872792da0963bc714f1099d2d4b2ec82ac4544321c4882e0979a34bc3c854586065c409c80cbe6b27ca17baa073e0791f41eb50b6f5462b138eb20685cd5f5232b5b795fb4d19e568609a2389b81d8068e403e94ebc10fc87bfee03979282d0195da0bc3121240aa222a31644618bf44c04a4dc1e5fa01f99c05123976358dfcdac3e69d8d7ec12518d13c1b14371783c2d00569f6df9ea578e2e47846111ef97fb9d761fd365e052c3098f0656520d299238671c606bb4582617ffe5299be923cc2830841f5db2f34e91341ed5dda7ee62d1dd11913864891363097560224afa1457fb6e8712a131db4c8504d82c70dc0ca9e13b6fbabed4f4e4f823974cf029d70ca1b19d016ee1c6a39eab576e6d8db264e6d847d37b132c69d8c0d4d41f8d543bbda3db0e88c5ff9dec7831666e4ed5ca87088e52eb386b82f22bbfd4bac708ad903af21d3899e4ba5af105175d294d12482a9a4726f373523a6809cadf0b3aedf3cf3ad9f0704b1be30cf24a4dc1de30a382418685c4edca40964cfaf69333fe9d4240c74f1b781b3f084549ed0fd178b657de74ba960bc73a8e86e57565b98fc3378c2d9792cdcae20f2a3b8eadaf2cad7cd71f024d7cb432c6d365e0bf8ec5906a73440203c28a4ea07be1933e5793358b21e291ff3b2af4b18a189db893fa04f8c87e96823dec65968a445cfb0909676e9ddf1ec4696f4cb29e0449b54d68531b2e195474a0381719788d8a78c9d13a6adfb28e1d38f40ae842664e65edaf8124d216f797a9da7e3eaa89b4435e9d00ee25a8805a47f4cfaad30b77307ff61349920f52518f0f5e8aa9b076cbd6413822e3891fac1039b5dca012919a95b743d99124ef3f1d4149b26ad9ac3d14da2c65669b1cc95aa047af4868e09c7126507493948623da1b11b8ff0b307c3393481984e80b07f6793ce749424e4f8bca597336c1072d02b5ffc33e3647501a678178eb5363a0dd643821550b2da086a7c48cc3e432abb461bd7ac4c1eefbcfea23036e66fe55d79fed102606ce0da7f886a9fa0d682739ac45fd23235cd624902c19fd60d7e2121657bf0a122e03f1cba82fc606e9beac9906d6964a9b2c6bbeb6a8f704836d0864c22872962914b0d1db29770d1d194fb1d08aad86d83386442f0b0e92fa60dd608fd6637257b07bd016280f787427153d188f04d1468757e8d235cf131e9b888e90c80408022464b81aaf97947cb32ad9a83d978b6e01c307826a913a99421bdd493c16b6e132da255afff48c93affaa06123539a5570df814a50213f6c078891d479ba3bcdb7b0d45ed59b78ee893970e454e14aa0e09f2ff6d972688e9d90e497742ddc4b43070ec27d3dcaecb73d552ad3b4118ec0646c48003d77c42682481e28135718cd0538a23d88cddb359d23e352a987aa6cedfcadc668afd895523d9b50ed5b0b103923f7f1f3b9988926944026556063e397ab227978da487b0d949a7d985abd52d9fe408556ceb774bea0ab76b5a2fe36a48b7c8d4fe94d38b94de8491c21264041c38415b74d139409138e8f0a1e57a8ff6c98eceef3f1cd72e11d7ab115fe870b93e8022ec7b2e92d7caa2995b00003c1ea56cbb37c57051e32e1150a081722f3962ecd6d37d2441b2a4d512bb83ef9edef495ca8f9107a419c3317adc0696d644d0bd062ded3a3f2fb1d5ed99f552e9d850fca4cde42d3d88e4842c5ce9275d9815f158b0a139c11b87a08c5eec56e85cb0a05fd0efe7895608489e2e95cd44a0fd9492e3bb9d85142fae6971adfea2ffde86d0ad0345fd9df8d299e9f3206d32abd04d44f7a48a6c7fdfb2ad88cd6b921e0cd8eb91e370dac852c14c6d1aa2bf07d6e110bde7033c660643fca789d840a7817a86070263659dcf920d34a43fdcec46f45727dff0c4262254d5f093d3f4ad830f231a4f93075c8d834b86b3b718cf3f03625b8c867a426a3be676bf6211efe08ee7267bf0318bb03da579e4d53b481d1d0fc3cc61ceb9a91d48b97357363fe64ed8e13128c3bbcd055ccb18e6e7be81f6e03f1d61bbd87b9b2e3ac46799d9dd064181c8027fa2fb8523b74c705c7aea2a583d91bbe20602e450820beecf6930252ba732fd006423e37ec51c9958ceb36d483f62b23998a09bbc241b81e76540660934d1bee2739b13be06c9ce0f6ba78e87539d9684f21e41208c8d00206baedaca0799f2fa20d9ce3c157ae1d6483119cc4831249ae536efa41218d7b1002bee9822d7c097164f9cef8d76cd0516caba231efef3958a10cbf73977b926cb546e3623ac37f672d52817f6d837ca48754e60632ae28f1dd4b1231a4ee1b52290216be1f0cf9a97994e840f8dc3481e2247d3a4d64e404a3d533199a183e6981d3589cff819630499b9c67f09ff76cc16127ee42d9dc1cbfd0e5a752d78d1516c12461b239ca716e5ec7485c5254f57d4882dc160756a002fe44a64c2a62b58bf24ac060aaccd99831c1c0d2180a2881a6000c807c9892e9d475e0643c5225ca6bfe7fa32aea7a8b6afa6508f5f8cb07d3253de0e3e47f4af634001437bc078647d729898d0864cccb0d0991dbd780420982256d14342443ea97a77abd0897f0694c49a9070a00a62d6ed4b49857bbef0968dbd30630e3c5b9f2145cb1b8c81b87395e5590fb96b6ccb928f33e15b35251046ef8b62ee4b0a5c8b77ea03e4e4b1bdd6e3d87012fdab27e1721c7f07e9b06352afc7719bdd8bf100726ae59e749ac3e7cd36daf0ebb7e1c34f611d9634ce74a0f282e42aff8cc4589f45dd97383e4fef69ab12ad0d506c27b9ef0f1522b986a3ae2e2cc4acb2c1492d8649ac34f698c55b7e4268b5dc54f9134cd6e2f4188ea8e23201e63494d186cfbf932dd74d8c7fe1fed44808cf98ef12a41d570389876ee8207a5b2f4aa475df8efc5c08a0538e3c9a82299fe37d43539b1c73999bb2ebf0a8d8dfacae3520245a6fdb03b7f529ce0f1a0ac126e23d32fbd267e031054957cd0259bb5bf66499ec741792c784acd6ab3d35109b1220412e2f787d5092b2ba2bd12e28d3bd842b113d01d685c1ce527c4f8a25535711c72d8b3d1311ad5cd92604773c19c8176a35a6711f69204847297e02942d8e76dc1049d06073719bdfaed967883242a4c84f73000c6175259f2ac3b7ffb308a5082d65ed7c3de60db19331c1f356acd208e895403fc6938259615aaed8d34e1446394c97f6309830c1f9a005b97c7f0552e0c9a7a55d12e3e33964b6f2df4fb73deaf5233f1ee0ef4d5e6dd1202d6b0ac8861b13b01b1d3584b6d88dfdf3f6191d1f17ddc548fc06e40607de0ccecb958ecfc3b374ee2385d613f2a9b1395beb606acb9f0331586e6aa53dee1c67816cf53a1b65e5cb17d848206cac326204417484df76abcda857d1b47d19b3e5b1fd87b5d0b7139881db24e7c1690c616d32635817f57229803496622badaf3d3a1dd0149c532e79d9544d16ea46d8ceeacb4f32405ed487c0ac8ffe35022a43b71f8bddeb13e350578e6f64b4570e6f7ff244a5c69e98c1c7c08af76108194f0a151c7e32b3e8c37dec2423b7bd7743a3f247fd17651e259413df19c713a8bc49b6d9f27e8406805a231c82ad167f6e99c44e87f9f3859cded33b67fab38228d283a85e5642ef9f0e12559e918963fe06aec1c6c4881159085b3df9bbf99ed432110ce05702b733681bdc45fe36e7188398ad11c424e65e57fd80a431af4e567176d387db11a034f59d49583b7db7243423e6a148fb89c578da3971d35e3b5f60886b73d3906a5703caeda2cbb3bd240477630668b8ba77af2880f47ebea1528b51a4284010d9f8c8937c5528f0aab236df22d77ba1cd9467b58282d81d920022152ff5847fee655fca4c975696bce22d817dde13bf00c978a5885320c176d70c1a0d2f7c4aac762926e8b002f4ae0fa578e0069428ff209fb0ac12250356462dd6f8686403531457ea31bb98e0394bc26d0e88abb5b6c55aa6db4fd5579cb27dd50ea5f93dd98f1659e30896ffce97e1c826d88fc53a7370fdbe1cb2795b5010717ae5e71b2f98047ff1f929974adfa46d4bcb1d3e71cedf04fa5de9d72e3c66f421e7e3bfea1c79742a9c07314003ff6e937960ba01af6b2abc48f308b15bc1121602082d8c73f27d6eeac6d8e82c0657292118eef5370331fdaab9253a1a49d8afdade489a079a2f0062a0b460361ca7007f5e2696e42b7b810896b438c58217738cf41b7f230fd9c4237d1251acb559e18da873d8ce13600da03a3a80ee829b6b7d5183f45ec708764f66be4ef85003843f64c2afd558d585c70e63b01ebb0a41f2dc78cf4dd364feb4d6d9720ce6856841a934070bdf0383222a03f060fc0786e2a701ebf2cd3bc465d3378f36d543b22c1f48aa5fcc43de59910d0b7d551eb03bd09c5b014c84ab9d90904ec8a5fc8e40474c1e1fb5c7692e59ff52b25429626d3bba8ade9698f35b9c2f11ac46b1445b5558822967ad7176985a041cb33697c6a56e1bd941b63131e8438a4301d7658ff700d615def7856f845d2e1771f74355a91fad7a77026e908637df4c4260f80dc9341607b2717ba67c63cb142f051d625b0011c459c9eff09fbb1c88094302e7c230994f3f0fbe1ca9115848358191feb73f67ec252dd68283fcd8d4c53f867603899e1cf0ef197c1899a89b4c3790a11f667635c81dc029d307a60720b04e3b67b3167df76a56d738f3dd2770d7e5dd52676447411bf27627699e4cd7178d07a4d35aa11b203e533049ee55329c16c54dd638980081ca156b35b3713ed389d279f6cc01776d065557a129076cb9941fb9960756e16a04282480ab596691bd9f989d88d8964949f1720fbc25ac3f1d7edffed4fa39e533554799d5595bc39611cd4aeb3cee9470ebf53e213ec32b7ca0c1c3249d0aaeccb000bf804ea429b2ba12309bf969f287abf7a8b370ba2f70a243846aae47ef841a06ccdac0990c41c569b461b43c0dc3c2b6e23a9774c5638877402bf61939139e2633fe4ae8709a73cb628a76281ab8171668372cbaf6033af5afaaa3717b1444190d3586f29d6e72fc8c47c06751a85c4c5676ab967f207ca84db2c93e4e2b8938b6792085e40dc16295a129ec2aae5d7292fc6d40915f83eaf2dc701b4add07102e3784528dc02eb8461d78a17fe632c85a8dcfaa8ddf06beffefe7aa8018aa887b422d658a5f753e063793c40e88e3cd27f6cd0f075091c7e9d142c061706c1fc3ad4b69efe75a131877bfed85db903463fe10c21476cf977e184df6acaf384fe39ec7e5a0f7e8287888cca3772b384ec34c928c226246a9ca54835db61aa3104e547aa4daa2771fd8b8ac8886a15c746b8ee27dce34ff67c3d1451e0f2fe8302a46b5042b1909e44effff18baac9f4ac14e82bf3bc80b91b74b060ee553aeb5972d8f632c951c0370df5a731cb70166ac7835e64ce2c63d4a157ad19f400117bf61ddf98277eb3696a3575c324c4dd6fe78c8b07306509c46f8829d93dbbc0325fa912231419c80701267e9037f48fe96999c4b26c186e2ae6a65dcedfe6286f38ee2aab767c9cc077025ea6e95773bbb18af11201f7c67dbbc0fcaf80d83a5153cb80edf76605992200f51191eeea8edf3d09d8bc899ce0a160a7a99318f8f9227b4e791649f8a8b3f20ddf1a3bee752f801fb4fa3a52211b094e6a780bb0bbdf01bbdd7d85096f407b6f8dc7966c8d971768f49cfcac71fc9060c0d6197258a7bdcd41fc4e04dd1dd5220b102f7abef06590be9e5162d2de09e63f8b02fa76e00c2cf11857ed0260b1afbabc60b93c9c0edb7654a633ae04b4813083f3c4e977814c6c4dd5aaea87b9db3e9d603ebd728b2455bf81709de92d8648f572aaf9a471fd2f09106b6c8ba8270eb4ee1414b0d669a3a5e069a8b3e74651726e3220099eeef678354c083273ab70f6be09c5f2b91d7df8b55ad461bd15f8dd032cfcd85be52a937a93cce0122a0e0ffaa34906f78cabf9c199dbfc0cff5b352a43c2386f480fc77d39ea51d14b7fbbe20600f1fbf41925ea0beea8f5092c29b05de72e74963b5fee7a57262e46f528663adad353529c03107ddf2f44c3187665570016c3d501763e3b423c5a256faa1277f94dcb1433effbe10e496219a372021036d82d03121c8e449017f2844f0f4304cdec4eaa259d51c8065ab4603748dfb61cedd742038d375707a6256309906b2bb15b8800b063d8e4833def7537834050c4c616ea310595466f3d146d7c0f7cdc189fa01ac553e0384e254593a7fe2113ce959e4dad37f3625a241d1824ec46225ca119c0034940ea712fefe4892f09b2136992a98e3c5cfb84b85dcfe1bed4f243ade0efa53d1d0323d58a9bf9ea4592e7c81b68f2d862f60cf438d3e22e252a351aba590e70f56685eecff3ba501f1c43068128b7c2ed328fdefa1c34cbd3c2d0c23836e657632fc86f5f97f0b37c74875a1fae8f9596c7511b4d35de859fbe544088fc82b482178be923c18240080be8ff1820181dadbb37503829a5d4bd498c7110b28ed29e857604000112a7a34a166755be4d98853c40b5d248d52f3346bfe1af759e19341f49f1680b41f848eb99f50251451f92c1f03e7a42d3255d95865d3e5baa98fca3141e31d5bfea479bcaba2390c9f20938db198e129a3b65b21c1abb2ca66354da700b333be54cc8bafd7daac3eda08351a2cf6cb0ee1d244f00b99b99ff93d7894c0ca07b4966a66b4ba775222f58674d4332f9cf74873181a064710810cd001930eb14e8fdfaaab82c657c9cba12636a06b05315601c1003de85fbe2b220752d4d779656546c38899e07bf7f6668ebf12105c4d8d9d2af10b1855541cd1595139a72920e1168e7e27b558845c02f2e9a4702b7e17507ccd560fa46264bad33329d4f0e351384c46c6827f3a9e30a8f3a0996df16fef8c1628440625d2ee336dae9640ecddbb938ca82ae9294cfabeaa972acd2ce43bd7c58e540076b006f8d5b805dcc53bc763622a8b82fe77f851804280ba069f956d1addc0d382ce185e62590e4f2f4d55f4b4cd8e833564ff8aefa147c4a4b70c7a55aa8bbe91c17d48a20b0328f7eb5848daed331cb9436b389e73fb0455812e166da8066333ec83c7decd29ebb1b7d94fd6f2ea07e21615b59f68a63f090b8e04841c05ecf9eee51efb30166ee344160326fa6aec70c6f1f7ba065b2ae36b1ad7648e4469dfb0b77d0be7c970cdf10bdfd927fe867db4de3efe5850ae968e148c2187a3efc5ae76066ea481b9c585566a9909b53f1db622b1461429d3f034322adeaf16dc42e54561f5ec35bda6c2ce11204ac3a669eefba4f740af93de2d5b1d9b912e981360575e1897ef9ff55007c79cb4377cae49fdce24a828295f5db7639864ee3ae6c205b6e649c672360203f69ed1b4cedef28750e3a8aeb50afb3b7fddec2b0d3084a9704cb1d57d632c0a99b6ce589ea426dfaf7e8895e91fd4e1815834f8be26af58843944c2804a584c895278b21b5e0a646741db0acc9db3463b1a7b4ba256403d043aa6495d19557ba16e793eab9d3380cdd4e98d6ada3fb57c799f6050614501c54b4005bbc27b466479d519067d9bce3b5e921c1e4979780e05501f338c513d1a2de1709a0260de9ceb6846422ec894c9c3e823f2fab77f6c3cb61f514dc6ff2deb86276d0c0a02f36e0cab8ba4177bf8a1d996e21223eab270b981ae0aac7231c6a3d72c4f9c2c5b4389ad5aee6892f49c817b27a2c67143ff36cb76871c006ed32320d09cb8866bda11dea7fe59acf3bf66e13562783e3341089572e158823f20d2348c64cec97870a876497bda93d03582d4f9e2fbbb23d935f5c37b8c3b66bf061a5c509e53488017ff85d5e193cab54d188a6c376613941c9e6b0bc0d7d7c15e8ba178337c5d45dd8ed68de4557b1c271c846c07fb334e34280ba8999c9dd975659e0276579bef8114366878219a887ae59a796a565655cb344cfdaa01bd5d14937fd0e7b2f9bffdb4d6a95fd6447a1f005a916da78c26eb153d15c7589212f58a837f77a3458e450c90f29d5748a1115309d1b0659788b3f3c93c59c329d184d0ae60f2ec158c0fcdcbc7a10468396dd32234d0d41176569e05ec98ac942b0b8050bd9d64db27d5b5b53b8f146b85cfff648ec80451de4bf1b65593e755245b4c49fbd20f3a9ad0dfcf63d28fa15c2a74e8bee59d87170ab3df417b61c18cba33cf49fe0d57ea6abcb4742630b30df5616c29120ba2f75664811d18287490eb138b7d654cf51682855b4208be68fc4647a1c8304cb757eadb1d1fa3c6371e347215b846339e7293d77bc211f49bbaee8101f37af3d646f22c5211d54627c4b308e9214be26316530bb4d47d0d40f01036e1e3ffe9b0691c14360568f482f5c607d3f171138d2a6952d06294ae89e3ff597a3824f8c61cf7dc16a8c84954c67c1310ea9fa01eb9838b227eea9350af8d78dede51c10d4996efd59885cc9b453bf984f9b28922ebdb088d5e15563b88bb0ed1ecfdcdb07a1dfbbda623db42a6903cf76835754f77354a66877adc4d21145c4e47613c8cb6d4d3763a166215532dccc7c3de8d0719d6696fb3421fb55c83d83e25d58b350d240f65ae8c39f207763436dd5978c1f88e0d09d014a625d9a1265b31f2bc854c1e682fbdda30ffdfe1875ea052fdbbe690061e5133caa66d26075234685358b49e5ba3c28ea2a760a93e447f8135dc7feaf5611055a8e4109ffc092036bd9e92c2dfa338cf2efa41ae3b4015170f496faaba45ac4ae0df52bb46403a0854388b09c88b7e32209537e0cc0fa7adea0457dba16dd1a6d6274dd07236e6d5e17f4b30825f9a8d0efa953a851a14ec5f3ee8083f31a02e9b699c9124b447430021a738db7d575eb2474d2e0d3cc0a961b9a9424b22fcd4b7f0fed733065c4e83627eb2b4dbe5626199de6ac4966fb7c1d75a3a37b84bc21744d7b83ef31c917152179718a171ab377670b1cbdc46c5357bfdf8420d62f4c1f74350a6e908a6a10ac740b46a06895e51451d6350e70120700f54729b719f101a7a558e04e2cae4ade1ff1901dadffb6d435eaf706d49261c3f0a61a5d135ffa31976f0b0df41587e2aa04ee9499d4cb01788b765732aad14e38e1618c83df7b9dd94af64c3a6834bf95caf8413eefea1bb077416c8ffdd64690c9e8cefd941443b2a6c860a018691cde83ca304311ebf67fe636ab463c69ea31500f47dc3caab20b3414381cd6bba9a020140bb304ee31cdcc734a62ac0b5251641240826a1d36a35efdafd0ee26d1d38423201b7bf34d9d3f340221e634f407f699c37d3570f3ec4b9115bd2d590ac3b81518fd83e6d5c67f08e73f5761988bbe589deac45b0e03d6aa33a21a1b66e47991a1dabbaf64a61abaeeadf636a0eede5550055c7bd4529a00182d368bddfe072ae247703ff399b968f953143381596cb5de35bfd9350f1faa6ffb556b3a4fd8947a2d901a422db1ff0f26f8fd284d8ada201f7aa0566079710605b37e78ef26346511e9956598218e1b1fb225fae5b92d4beadc5d231bc6a8a6ca5c19b787627285e1ac18329c904326a686975b68907bd32c707eb49fa5f2bf020a60a62aee70f2aa89040c6d7e28d0cf2e89086e049467fc058428626db1a9be4c5866fc704a8a148cc0449a159f302134eb12d55d29af01d64e6e8f24fdc7d8b7e78cac8d1acd7c7f81c804a1c733ff233d57bb84c82dc7f6d49c17ac42108e162dda87918cc8a4281002eee17084890ee931dd7ae3b6238133f75d8e1c501875aadb8b88d6692f5fd16d17ff9da0ed1848a8c85177d34a8d8018845ee27720a5efdacc0b2f90111e4f6e6323d00d0399f5366c1c061658418e01424aa0101031575d7707ce02feaa7454d4817519ec4df55e30b6079bb192ab6a8e29e0702b89be68e66edcb129f1d9b0f423e983a5bbceb42202cf2c58f7395dae920cae2e555bf8a5368f04676fec9864ca51775050b6c06624bffddb6114490666352d1a4b555eb60bbf9da4e66bf96c99b0511da2e9e68f4c5b3b4685d4a7ad3e3d0795759e4c16fbc3c9413d9b439c2913a4575ab155f1d5c0235465785529478f29f45eed138d818dffe96eeee8adaa1414c032c58614410caebb2112867cfc707e4737127b09d8761066dcf4e120cdf8352d1c7e5de4605eb166730038e2c25fbd1c6b43890164e8d4a5ca861003f0ea2aff950695d4beb2da9c5aa8da7b27e8eac55df3099a1481cc66cfbd0fab9300eaf7d951f788239b7d07deb8af84bd0dcb07552bede180e3b61832d53a6f1d02803feec7d36672f19b89449cb403e66f892c4b6f24537c2a5e03aa67168645e685b288283c91f3513169775b812a2a65ed163a2a021176ee3b095c8cf45f9a53714d30aeb59adfd14bebd2d7fa55def4e462fea5164a26762806532930ae5c4a0218f3d7d4f7a4d98b5a730e2c15bf091e9706d3532754ea429b49df2037e0fd5fb14092a9fce5fd3c9627d8b83a49951f2d7e8c22d4c4186b4a051faf37a93aa60cfbd3f0edf464785fcb99f4942d71f3749c6703e6fe4f610a686b83e52414359fe1e439cd804e2e6363e975e217b54b316129da71dd5acdb25dad76bfc442c3d2b33a868374d6b16ec66e9f29713a0a775bf6faa2c3e08deb9910dc300d2e3b046fdfb64d8f1383123ba35d8375371fe965c178b1281b2ce35db651ee02938b64ee5033b58ee79cc1924af8b77da195686e071893b95d63a617c37134ddba30f331fe3a85aef5f906cd519a3a4685f0ef3f655d98faff3dd111440df688a0512d740d773de140d0b7e63c84d019c7edc93c3c1b01de3ce0595a1feff2c44e0d62fc57979a4b527446d479e3e4d6dbb0987272031dadc19cf0b0dcde83a5f8cebbb0313b3bcbf8095c42453b26fcbe55aab1813a779efabb157276cfb7a874b7f6ce6fbd68a33a70045592e1d909be8e112d41b32351c97ed1f0521dc5ff99b5862a473428ba90f61589c5fb2b5ea94b7c4cce083b70936452e4150811833a6a986dc3026cb3acedc67e2890c094005c9553cbd4583b2e5480b19de77c2c90c45892bfc4837bd8ee0aff4b0dbbf0741e10130bd3dd3f8dbd725977f53005fb5e3c3fd07c45a430d038d61e6a67033cb8c06c38e103f4aeecb091d7b9255569d25ea62c904692807020184ae0f42c345b231240f8f0bd8328419d2956994ea69554d5cae74fa3cb7e08b959f2c7c000904dc2de3bf4b644a6d89f54315f5445f7ab82d7bc245d658d93f50d0325c1e8122963d16e03f5b35f453124bf5246a24557c46c5e7ddbbb2dbfda47f99862bccea08e24bb395426f067c7685ef6cb305f03ede3bd4b9b709a161495fdda9d935abaecb4446cd386442471bb8607a7216ae05c4b6e13f31224ff02c27b35b8a1b6178be75e0e31633da9d5a91aeca38aa14ef334ad8a06d1b223dcf66c95d8e55f5dee289e43887e658525f5fa63057547dda3eb0e0a6ac094ed6827587dd9f9b8bcfca49bc6eea80a5bcaff37367cda5b3fb3016d54cefe971cee9e3e6f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
