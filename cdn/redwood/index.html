<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9b9e7330c9fc94673003ffb26403eee93589f336b03e1848613673b4b1c2fe104d80bc748c00d7ea692b1fae1420bbac5420ac1be18b2622a4e39ca948d3ad0ad488593234de10b8aa44182aa7e71000b933da14ae897c03e131e66f39a4f25b3b90a27d396d2fdff53ae4c0009eb958cbe33e147702fab6da4f68c95a19c2e7574d8f2e6f76fad64713603817cd71ec984b7eb3c97e8cf6db80792163c9f34faa179ac0b96c33723ed650ee435fd7736acbe8eefe6ba3b14d41491d6033d82eac4ea43b3a42e8e931f3c4668a391da02d8924ec3f04ecbb6ef97661f9003727b1ab02521ca90efb857a20d588e0750168bbcb7dad2c0dc4e5add3084c55b21959061588b26c698a7aaaebfc2d8d16103d28b83da4b0a22558ef87e6286898b926d5c924811bb370c8208ff4d2c05b2712bd238a75568f3006c6f994a17e2ec995bfbd61544830a2fc0d5a3c018ce5af5ae70e6bd9dddcfa52bf284b1d44bcd0c8f446ecea54518e181d827335819a791e15ea9057294926dbd18e206a79b7fc3ab2390832aba9daeeed066904f67879ec2e3cbb0b394c94829f5dc92cf1f0da6b02d30cb2888a134ccf195af93e48737b49ef85d176ec89d038d501bf434008531ab745fa3b6927051a9471e41ec5bc7ac190a8cd99bca0da4129e8645740e41cf6270deba5828660fd825410089b5264fff1f482ea8e928f0ae668b598c980e1641044d36ab790f47fe00434ddd531c2b76f2050909cf7a93c532331193d226c32d124e4abad503559f73fc6870c097ec0781308444c70400dbe2f65bae859072e8e090554740053e66dff7582986ec04ceed5e485aa8a647fdb4c252d2f3a12cdac27938b36ad5fbc10550941c3692bd61480634e7f08002f8d21aeeedcbe5fbfdaba8fb7a9198cef5df25ad0b69dc10b22744d16646f523608471843b0f36a3f3756343fb9e5939785c0330388b7972c9cf0058b47397c0b5a3695bd9335d322a9e303f300b8344aecb3e21e79ab3db6e14635e007d81f7c53e8b76a9c55164a5f7f49c5004e88e526eed20fd38154fa82c2091b565720e2c1cb6e48d1c28c19dd0ca19a3f0d8d677b349cfc5fecdd0bbc4558a4b16303645cb5094b8cff34a7459636dbf2176c42a3d7c57a1fbccafbf5978ab0ee5d5a55b5784c29fb86e41a2186ae6370ab591f43e40b9dc8dd9affd61868d522e233bb56f9f7d7638d5af4f7067d6db946d26082ab6af0ae77704bd4b6fe9e46908c20a7caf525f6f4229e989c14886d853ea8dcec109e37667aaa7a6cf7edbf0c8718b2e690ff77b7e03061102b7b6917489e793d12fb4be459e48772b4f9bdad8bb3573d6f9f8bed1050b4525d8d96060af9f7569317ed62b415e0afd3159d8fa7f4dfc30a161ff98799c0c95eaba0e199dfa8a7e0f5616f0c1835616eba79d4b3c0528fc2a8cfd975ef215f4f95a227217ec8bf3b0a41bfafa88d57e0952e60a5880d25e25ca34c1db9f6c594176213362c25d759bff9e8a1710ac7caf6261efe937711ece40d5b90e6a6445565a919bb325fcf82235a3c6e4faef496a84f0b55f7a051261a70317b5bda72eecfa2aeba08a16e94e9ff01067de635772583d08cba20b550bbba0ed5f9063a7ad02661afef8d40eb05a1bfd129eed7532e7bffa0c0442dd38578af4190e1094a156f1ffab0e813e808f0c571a1cb3bed2ce5e42d3d4cb17ad0969122e8b91c85ce8cb664b8fd57347ed18fce85a6c9c5b1d6fdffa0df2500a7d167a2e7732581851eccf472e60c051ed1942211b8553bc79ed8be9b306764359f91dcf8252a639ad746d80245285b0610777e100f0674b4dd96fcadd0922e54b35bf0a0eb1c3353a456983cbe4c8fd98dc2effc6266730b1458f431817c569041ee2cfd81c09f819be34726d79dd1eab0dbcbe6585b741f08b7d569db6927f2bc7addd183b06d48ac20bc6afac04ed9da0f0489c341ab92d6a9c401c7cdca8c21116d87d3ccf7fb72016ee9d0e5e210178c3ff80292018d06b2767ba38a74a48cbbd994857330ccfcdb15fb708721cbf9ecd10d27f97e4eea3287a8d47b54ed681ec0c278eaa99168739c048cce29fd240dd1da511bfa515ea480a0411a8d8e5cdbc24be7b3f0e0833f7ad2fa24758f9926e8c28fb729c2f7ea8fd083ec4153543edcf895ce81e36c72cf6e1c52a877c589c8ad8e1941a28589329204bfd94c60bb1aa5781715408e3077b1894bc74fa1422a7714a80af4dd59a90045aa91f0ed2d4acbea8fa092e4be8389a3854977a6c9e284261782804c5283105d23ba6872ed47f3c503194f430657d75deb7475ef9b47997382e5fab0be91532277e5ec5d723f7022cb2a2bace20a213c94a83a76f0d4aad528e06790eb152157b704f8f4931c8d831bfc720aecd81c2ff1c77390101a4e197a6772e5c323c6b2ab31d6a110c006682df06460b63dd56b66a4057aa92fa3eac14a7bebae9e58d88f57ed8ced53c04351404599572b71c8769a62502c4dd2b69d631b6716f689e55ccc0106872d3475bd4821ed5dbeb8592a271fec010dff76983c9295692a42849e47771d96ff54fad789681f11fdef96951993dd2e54587142250991812b9a423a3fb36de6a50428b96b80c6bf68aa9aa6ac7633108cbed9a1e274870b1ecceb38a9850520cbdb74baa32be48e54aaa6401c07b8fa08d8ceac6342efffa83d77594f99923adc55d84eb8bcd8c56cc03a8f9f5373e8fe52634c82f66bac5a8d893dcec72750ce13bbd809367c1e001417b5f0d52455e5883b0f54c7797c78e8c41cbfce66c2091f33ecb5a5eeb7e5612d9e86d680a0c4d9e58bdddc159e6aa212dbb6e5695a0d5ed7ac20a42721fced0c31144a20010a0c8a4f90b612462dab4b1fe4a51ebfa35aec327b33931d00cd42a5a2e862afee9e7ae428f30ae26818e23fa54a28f359b2518e646dc75f27c79a6836ae6e01b97d8a30959b2bed2d572b97ca99ae6a6234b7618714739cb6cef2ba7319f7dccb32777e5cb1cea0cd10a76899cd621a81e01942a750e7ec6c53955f436331b21a5c8321f49d1814092c82667e78d126e6eb0b99d18198824d235ef3e865d6efcffb88c46894c196a1f535a209dccc266bf9e7cd9f2cc29c85ffd0f1a346cc8b9cf2a9431f1d332725c9a224f2167929d93f6363841a04e0d3ddb2ed5588f8bb95564432341365e83312c09035ff0ccfe153e328cf38f1fa6c1b600e518e65d2118f01347714bbd673e40a2d53df01c7bfc9975c0370e40969b9f10d8d5ff9f290f3d3d7d5a40d690ad27a9acef3521064eef01dae506ecb585fd45590f6433f6edca601887d6876860b63f613bf26618d12914868c9b912c4313f83d67f8757961e7ce6eaaeae30fd71cc281628e72c808c8647de50d346d336a8d349d1d927cb78bf745fa42b38840fdefeccb337150ff644ab843e7feb25a08f0836a898c039e8b447790b2923243dac15af02c8b720148c696b3848aac428e704aa745757e6adc66e68d220e0e981648f7da39e18314556a4f7c0b427fd977877e4497bb25e29215abb73832c5099aef4632d0d580a77dbc746aabd49b24112230e33d8e17241e4f05833a5fa80b3b79ed5297eee8bb6da2766b6f36655517069b4c77282d3f26f4e70cdc0ff2cd9b9ad3b48e67bf9abb0b20385b82cdc1c26ebed59ecdf43b62b0b7a805426b8e03e67bdd1e36a803dd6aa6f0863bbfbc328ac0057f183937a7d29a16d102e94cb8960361e2a1ab470aaafa8e77a09b3767f090acf1d3e44270aa6b248294f5b174618d6502eb019580fa05b3b1fa0ce50560fc585f317bcd22998394a1346b18b12c920d4704fa37e0d842f3678c8f6cf44f300260f79d2baa2c10f6a88960e23b6efc16be76f8684f31d50d61cd65100333519e6f23c67976de7fad10401c076ecf7a7b3b90d77cad2f860e3d5e9de0a08bde5bd61e7ae3a98dbf3087c0dfda8e955ef598ae0fe6ccf844d594e199bbe2a3946ed76cf7d94fb69057a1ef54b70d68aa5d0f9213a89468723d95098495bb62a86ec4f0f98988fcda0db4e9b76c1e28c8cd3225a7c8786491cef00cbdcd0c96f1618f65f25de7ca7c7c889d71c047258083af949fa69b3f9c8ce7d752189d975f151ebdd676294f42c08ddeeb7a4a89f86429b6afe1d86b537da88e0890b2476852f264c014531754c737d7244d40c36ab1fe8d3ceb286321ea80c2c936d3242a046cdef44c9763098f71b1dcf9e429c16e760b1985e6d37880bdbe732fe4e38969219cf5de581d96b05c7c91703e9738d882c4747a0d71bec145dcfea4d928a3bf6e875aa6b12847862f525c5bdb55b840e19ad980d968d4aa2c07ef6c560124a872b1ddd8b73973a9ec0ffcc96446029619857d0ee6b51bdb38644d22e34f2a9b7dc4b4520dba0cc1ad5cc2ad2b92b35f75dfc0701cc06bfdfadf40e647bd3af869d06b077aa61b6bfe8bd137f3d65ab103f585e9883ce46db527d01b2e1d5ed24659feab4bbad323a8b9290bf9166d983000117b128ef237a0269491b24a7a076c18826d6d6e92c69c69cbf15a5a19e578d15bf340417cd6f517bbcb54bfb68c2338bd191df8a5a72d32c8c4ffc8d32c803fc396876326008dfa47f529724f82adff32763f1c4c37e4b9c9cf391e18980538138ca25a9fc9648fb8a12fcbc2e8d309360abe83446794c8fe376708d97f4371cb770fb5ed3c553bfad801c16126a565b55a6cccc8a8b902de08afd73bceaa09bfa0339676412315515fcdb570ead0733a2f176efb6e83ccc770abebbe64e73b00b5f1710dcf9cff1b5742e3d66d3913bd260c5597eb1bf5ff8ffe470757a46bb5c290d3ed45b4972801817b41f3057721ab2a9dce6d5076a3529fc557b0eae1e5e71969e4109a225b81703f953411623c050c52475c011049afb5c8af5230bcfc1ce95e4dd00fc57412f6163fe22df70223fbcd47ce8e237a322d790951905b9058bb8299a4fb68dfa029b27ddde5ec8980104cd3f918fff47ebf7bd16126d1d89d766bbb57dd0edb731a6dde87ff44f0a97343657f1fed15f436ed55666520376842063d515106dcce4083b841db9b4417350ea5b1dad2ac755054abff46b24de64c2df1d3bd1796c8efd444108feaec7234cb3ef3849a011ce24c9ee86437d37bb5645445054f36cbc8f25e6d3b5a8a2c8c9ca0db6e4f529a0df117eeeedee92e71f7e247457179b3c893475a1787fac142bb9b48287fece14fd69390b6d9eeb5ed0b98f75f2cba4b2f3c188992f0a572f02f63700564d74468cc26f6bb18e2da9f0819b917812514dfc420ce770bbc90b707356e106c362f6ecd7cd55a450a3c98a3fe7ca4ac9e12e350ff2377bb9c2c2f583a7abfe8da7471fa7518ea28e309e0904db92d1256da45c60d02f07bea810f8c2c5ee1fe482ca4f1c4cbd8d441f4c8d734af2b54478e8b888502e9db7a891f2dffee26998d19f7220d34fa77c32f8046f5f15317c0c5afe4fcf21b8f08d4f8f7d863eb56d3239e1f1dd4324b06d7d24f1bca8c768669a1d0c2067f4662908ad88dd06925cc46579ce896c14bd5f04c59cc400cdf77ba581414332cc95fc8ac984c40bba62e6077226e2bce328f9c3c444b40f73ae85b91bec2b099bcc6d6faddec40db3356233ceb0925e7a217a0de845da6c75487627ee95f19185bb3d0dfcd7615fcf3799c6c63af453e3d44dcb2509c868cc1b2de4f0b00140ea24317c19ea41516f1133d65f0a8b4fe8bf094f3f95c288a768e77abb229c57fdb3407e612c468c66f75add29e22e9b54446e8311eca47e3ea68dc38c4c95b01c824e79147b2edc7ab1d9e27525e95f3daf589c715402b5f6052c619a50baa345473ba68877838cf68e10d2825020b1f727c87f4617885b38fb8c9cb8f527f98a813c2007a460ce5d1ee0906ade2a4efcb92fa61f7638796aed3ce7fc2646bb31204b5a5f79d5b83da4e8972ba2294ecba60fc12e921acf2a8d067709e1cc74c5008ec251074beef9f4879cd21700657ce03015a1af782ae3d6ff943f921df2a742c3e11dd4bee49d2e6975e2c5a30653b2b42148095d459542f877c7c4cf7368b956ef1e681c16ad4abeead6c74af0506f70c48093a9ce6683873d949ae04941fb1abde0c696c4de8aca7beb9445708bd51226565a8726fa2d27b588be7f339e91210dd9265230c65ea6e9782b2f2eda505a1ef1acf382dd392bb1b9fb4a570ec83ba7925c0c2747b5343e2ed8709d9762953962c8a266de7bf88c41d7ce8d014048309b7e174b3e1ee7b5bab6a6e3c8e99e98e74a1a1b53faaca57d0235f138b7f2cde7a0e9579b6d93a1bb8cd531022d69c7a0c60dd81629a1d70ebba04b137d88d3a88069229fa58f5097bcc55dfc292b2b25b95cfd925f979abc1f9101410e9d6bf57074752833518815cf7f15e36b25312a6c77dc1ad818119decedac184c2b23703bcccde45f2588fb912848068700916d3c2f28e04ded04b866159325e160e6f41b414effc5a1aa524a4011a4a88f009e2936c9d1eb9616a1227f42b43737b18cb3612a4329fe67976965819e79b92f96749f5f032223616f62b22c49c445bdb9718e590fdb3d3818774a8779857b2554ae8a56cce288d748ab6ff0de71bc3225014a50be5f41b29f6c474190ff688857bcbf3d5ef7c9818c74719cbeead94de528e518a6a935d504af35cf60af53eb05f6e0674047fe51c71998c00075e74df38a0a7766417db1d41d0936fcc1608e877d5d7e853a899a6429afdf161db263e297f0b5343c2ee598ee4d167c032599e244779ba190fee87a733299ec1f75bc9a3da45842db856a1e70ce83bd4f11150e4f0c1f5f856753077e00d394ce2870a7798a14cecba3d94b6d8b56d091eea1d34516cc0ae3b7c48d179decdc65bf5973d50b06eb4079583ef76e75bd16b307f02547478c5002d5c02436189c27150ee368ce4c28c873225eb856261c72aa829f476328302ed2f21c29c5eb721c4e39793646c62087b510982198c4909da2b6065664990348478d24c8c090a2c2aa19e8f1289cc71f5f6b96477e88e8d2f32e1fb7658dbc19c85a4e21ddeb4c0f76787ddffb758c690d5d97904a55e6790f3d99fd7ec829255b8f66e9ac6cc265424c1eb86585990da76fc2acbffa69a409ee506d5f26abf72b99f5059317840e4e237aa266bd7243a8795096c2980902de9d1c53b0a8cb18bad1fb20506a38d3a6e99c802309407319942c8698aaf6d6c0e2de12d5bf3cba9cc474006df48c679b117038dedf8552580c4821ce2b902082275a236d9fe3c0304cf8b764ec4be262515454788e8ae667b0568c762e868dd1132c3bf2231e0af319272e0e4e2b8f723ddfdbced3de850176f5f93b0f6697e9a0ac62a3cdb2463a62cdde60eacf851c93e1fc24f8a03cec31771bddba7a75a335543e21d081e8f6458b68ea3b455730d1a4ba7292146e45ab1f53ed047aafd5ab254ac369f7920850aa1f2b477c79d23b023779b4e542a826f564f49882927b249adc4bc2bad74226d6d2bfb2e9a8cf3694b2a15b74bbb155136e96cc98d476d29e3c76ecb9a6ce5c61e5502a37d1705a6a60d9d2dde2e57fc50fdb82322b3464d05a7c8a50153f30cd8978190a8ee3348b3a192a5b495a039ec4919b7a28c46a3ffb6355e8e2b55f7b136ccafea1aec9806e16dbbbe57dad94bb4b1e73d25742fe7b198af8328856da2adf0707588700bdb4e5af794a0e947e996a9d0535a63055932203b996cd0fe804aa314b33e3ba01553241bdfb4a019da44997d066528866fb7b09d452187f812eca9d14bb6b608241691c7e655983755e1aed7e4121bd46f55226ea1ec4c48b57310d6a0fd1f7487831f3420bd9ffcf4a6eeaecf370530b62b219affe5cc23dca92dfcc50f8f3907bd0ec9ab900b3c323c80cbe684d7ba63b5873866345dcc2b40d08c565f4a77e93aacc7bf5b394caad9496d968c15e5f575ab804fa25c14f02178cea68cc8e16cedc99ce13e8853bded3837e42cf9861c81a0c328b8f781eabc5d5994b072a1159fe2af3dc535800fc2ffe8b6410ab4256bc4eee82be8383825cbfd6601aaa4e371d22405653b73a90def0202062bc88d103660657c9eb06c55a43d8e33fc037213c3796cac94a1806a6e819303b6525e2b8e4c1af6b3230470b8f2e4f7eaf1da202ff9552bb8fed03fe26885fa85e0378e05cdd27e3d02a8a8c481640cc11cd6b5b58113b88adad938bf3026f79ed53997760975edef31af036e6eb77a89966f5d04f358a25a30d6840b4f3b71b7283fee5bdd0b1827d954e36373097b2acc1cd504e058e84ca34c91c5fb1d9dc4f639926ed2bb99318db0e2c992b4a20d161bc249db5faf545d1c3c6fa12eb5138e3f8fa3a0dc8224bbc61c0080694412f92fbf10da609633e3fc88963aaf856ac310c0902c6de631b0606415f4fd47a7d45bc7bd896999270e31a509b8f5da3691fd893c27fefe77aaa597010ef6e503f4fdb46de7fc6a0eaf8c30cd22de26e477ac0cbaba0c1a2cf132701c781c3fc47ad84274a6665b7ba687948f22499d217ff91f72109b6d539eddd374962d901f5e94e0cc4e33c8eb06589d00b69c185b30e624929ac7f84c04dfe16d3fc7c00b0b4e73ff530f05c265a6544099bf3e8cfb0357ecbe120336f2edec78d6b27a4b26c0dd4df39ad44d66c70a215c64f09c669728d47ba3db4337c2e275f33c996a6a8a228c858c05ab5d49f38d03be193fe7e67bc7fbb73125cbade09818884527a1f3a6d5fb85be59f267edd88a01c3ec406e69c21d7ad17d850c2aa977fcdf1a127b4b828fe70e3c364ae7528d8c9dc5c42f161517da12066e11c338681786f4dead8017901367bf412956bc1fc9e3f8d9391e6b64c121cd1a93fe654c9924bcdca4df4d5b7eac962f07c6f99c165f7a0d1f92e57af24c7cece7e31391562547eefc1809fe5a8cb50818cafae636ab0e8ba1ed132aa3ba414476141bd4e177ae30e3232d3691b3473d576de124e53e43573e8510c4cbba410cd65f769a84379812e09ebe94fa9c86bd380df0bf9471745490880be0aebeeb8367f84223058cdd3243aa8f328e7d692c2f9b36d7ab66def79f130799d86288bed61579e5310b5d1a3f0b034138b4cacfba591654ed171493385783019f0ddebd63f97c34a2853c6c2efbc773581d9ae1f82cf80972069a5a36f90ab0378c516f7846287d8a98d21613582fcf9a7c7fa43595ed701ba9b19a555e351f0a2cd4ae88cc3bd519b7e1bd49acd6191996ce54bf655a2fa3c6608b549a8c19cc89ffb55e1a483d2c8e40036d54b0277404b8f27eed665f35c73865484c17359ad4ccabb4666c56636d0616d16f3737917149148bab1eae8c0f01863012c6b20bb99b193c6c3adb9a9663d4579b7747356942b202990830f29687b272dd43195b49f83890947f52087cf082913086f222fd59ab548bf46299c9ea492a86161df79c21c2e76d9d1a0a16761a239a786eff1ab1b4602a40dd1e136e446a96a14078c81bbdb26f5bd1f7dedc18c0d4f10d30ab1c6da26d9d04ed4a57b550e30b2e4cc6aeeb2a535212d4b5b9c7d85b038df71b035bd0531df032c1010965a1b8493abe9c1f00fed0cedc79385b41ce05b4a6dc2f0b95dbbcb5d0acacb508b205726e0eb7703f49d004ea00faed28fa28099023cc67b1733def9d5daf14a3d51993e0f6e7b0099d0b1a8a49c3bbb87e2a3a7da1039d5d3fe4775c51bc14ad3e231974a74f9946d57f81f5c6d02149756713d87c3775237bd0a8c5df3c2066fbb4dbf4ded4b18bde84900aaa95527361471315c5c1cc2731be9d39fc1a06cbd3cb797875f5bb7beab62bbfe03b12acee748ab0db8e1d923bb03cdf9f693d1d76e1eed72c567474287c703409c19455e77c26d754d1ce38cafb71f564f7edd1161cf73564ee16161c275005776366f1557eacce017bd854733eafa66c39ef87c08cb4e3d202bdbf2fefc1d77a7b860413461e937e2bd674259332a3c59f420d73dd1eab2ac464ee38f1e3b3531730636aa9d2b976c29071f644b72d339ad98d614d4d1339855503815b36094dfb02196bdebaaaa015792ba07c59bee32ce602c18959a20921beb3f9cd258f0bd415bf5fdfe54efb7f414fd41c75e1c5d2ec6e1676d1844158c55f4180ed60d5b1746d3dee2ae5cca68e90659e36f0b0b09f14ae2a9d63b6e469e907d4ba20a525f4915029e502ff8a6c431a9152eb55dc2f991761de2de236a144fc376182e8fe678a202c8b0f5d23511cc43c1ed3380b791e7be81e3ad45f896a056334e710572e5d46de0ab24d1d10dd83a693668f73266e84f74836a995519bb797f6db63d83e0165d56093c08830b94ed2cddf8b27a7834330810a5e1abbf51c85c26d5aa918f019a77ae06ae7d427a2da1ddf3ae2d9994cc5c3fb50a2a48a88ae407ea06e72b29e84aad3e3ae940f3eb984e3a9b56e46220db5b0ca0d93ebad9ac62667517417ed5b3f368f237259acb6be78b273b9c2d52527b0d3ad210a095631a951a1e561a9d8f8236933660615ebd0c731b5e72c263fd9131d3a066cf1d772657d48f06c5e3d187d5bb7b67e2b7721096df47c3d2ec5e380fc158ebe5c20f054d9ac1faf69e7d2f24218c11ad85aee63f81ab3367ab9cf2652169ff3a1db6453e748752a0e13c6e9ba19063e57b7774206fb18c8d46db3adb7e99eeadaeb1050d8d179a30b373c6468a6bd46f8a5a837fa50bfdb38b27c049d8791b01aef33ea95686d008e6b88019d3069111700aafbb33e0221ef9861827a30c52b16f774b4da47a58fbfe558c39eacae811ff5a5f8e1ec3e1b4e8e4f3de7d199f7433a2bfca06b5d93a7c30f8199f7c2927d9f3ffa81685ab0930756f1543489e902f98a689f240f94062dd7937653a605f13e491d699a8a2f424de357c9105f5879e100b20c0dac5877fa17574e61a35f9f2edd223638a44c4680b97785d843b8168e812dd8479fc9f1b0829ad3b3af1c4c61d168fe46d1e600400c97948ec58a4174e04de228d937b852c408225ea3a30768aec645aea968f2c59b9e5ebb202293e207e82f45c929e0923828009212728621de1c91e70921a290c17a15a2941a181dd510e7e8287001bfa1c53b41d14aef90870cd3e06cfe5f7311c786d798b8862f87cb1ca770211e5f19a5cc9861621570b949fff5b81af46738dca50892beb4aff06a3172262fc3ddfdbd2a2cc26f6261a31a46e3ce9b7145c931df4cf56d06a56ee4211ba6f5e666cdb79b45941e0cbd8299e754aa4079dc4e25c8d9771ae2f4198eb4f2c0671e9acf4fad701cd1e13daf51f043ff7e47f945eb4d82cec2892f69c5df77332ecf5c840a1fdc37dc16491bc112db8825568d3a43515fa721aed205122ea5712d66815e611184e6db458014d0ddd700fefed420c087a57cfefb482d189de1600cefb3bc0d10da40521e4d79df25c3d82fbcce91f4e1174f5aa1246249fc1132b3999ea1b587ac75696cf29bbf1fb4d38b509556b5c8f6f2d8fc8b96cdaf29b828e2d09eacc9aa2e58c9cda1e402d6a0071f6c32244a395f7485a1e5acb8596c6c66ff32e1070018f719f2aa2a3ee1f8afbe1f79fd6b799f5d1cb616a91efbbe0c476b7501d590796909e495b0d846cf7dad502ac7da22137112a500ebc8f4fbd0c5f4c6b5d7d882ab914e0e6fc125d634f937559a807efe8bfeb0c7c59f2f4bf65c5f8baaf050320e3e375f5dd7814439a3a767539422ea037dc87fdb8bf76e9d575ef67927e8c3ec6e072734cd241a346acc271b7530778af8139008f6f0928115047bfee4f883061acfdd32f0ea4093e62e8144d9570c962d8411f19ff97ce33e2f6cd2670984a1e40c3fd6aa55291821a8435cc144ea58311878905a1e4e7f444a47b2cff374efaa65507afd51e09f33e12925913570e94fa0606f037e33c4a925cc9d5298fd78989b276755acb22c6381ae17a5d9ee5c80daa026f3934ac902688d6a8e8c23c53f8a988aff35ab21fdc9746f2d28c288355c6688d7f0971f9409624252feb210c106c3dba0864d91e40383b27bb959e7ebacee58611631b2392c1a860d31fcf2f9c146cc85237e9904d18ec7c60f21fbb905477f8cf4aedce6df23e73e39e38b604100e0e4acdd30b4ad7220a28af7c9bc8c6391a4a63927a53959a8f95bdd1fbac8573aae917bc142717eaaab97676258f855290ab080550cd17c1a3dded2dff763e2b9be1a5a9ce5538e7fe015cd76878a0bebb2f9d2a040c4a5d9031a083127ce3b5e750d31731c278c620ec20cad5c370313913ba743aeb17e234f8d8043db9656924cb40742a5218cca743a5a62670ce8b1a8132f319d9fb6e546779048eeec50d623f060d41a84b4d1d282a41040f638982650e52ab31fe4b796fe03c31ebc14096135290e381e168d0bcb119abf8fbf89d042399992ef174a8350f196968a10f93fb0ca8a48c7bc98a2b0a9b6d76050908c5a0a46580130f2d31eae55bf4a0a891187fcf0c1d1be18d510875b6dbb0aadf43a916c44ccbf0141af4c622fa832da54b1014979677ed29788de91138ec65fb5e3fee1a475a26b6eca078ebd8a43b0f9753e55f0d4225f4d578da2fb67d28c55c0611b620c585654ebb5419e893e9b0fce0927337c23dbbea5da22cfb4c7700ada81ed4bb22b34b8bdea2c4733a34b0a760601ffc873053b4d65b95572fa9ae83c22b94905ac1d0a481f02ace97feca3ef1cdbfb2f41dafb5ccb9ede9b7644d4407988a1688c1ab4c3e7a1375680fb60d7c7c728191728bed23103a1292c5e22cbe76d28159aabb1826b5ebf109551237823a314e4de347efaecd621a7d9e853e27a2387b1598cc95bd20c3d5f6f5108a2bb7b2113dbb7fc7a29821b3fc190d6747eb64ac7e242eda57e3ba601834d52f25b451d5621f0593aed083627d042a5bcf774e1550d06675e696c24ae4aded05c5b84be4002f45a128c84b3b2aead25187685b80c23696b4602ea7385822b180e1b76fb6cc039b94b797b7ab5a0716804e0c8abebf491e2765e2e1b272f3c512073d5009814576f63eda6e197e4b809140cdf21c27dc0cd5446257e0f0279979379aed131d82e27f58050c12a0970c63e576af7c5b01ed75d53003cb77d74de4e32e7e992368c71dbfcb0b4eaccec65db293b633e4853af3bfc100fe48f42ef6a8a351f3ed03cd079ae3b5ca91d783179ab2ea1f9d9c2dbba25c7493b7763e12aca2f30b2e9ce9d6ab3ca30cdefad9b8443e175173e9bede9e3e3bf93bb8aefa8b91fd87304bca40520915208907334fd7753ba521d74ac5fa2fa357b794f940a38068f644fc34fb4230404464afb109d1b77c733a531675f06153058bd60172f2e46faa02f9100b06b102c6ab71afe2ff9a0617cf6893586e5ff8b44529434a7c60dc3c6923f530eb5682a443cda2ba36902fd78ed78ddbd736eb4319521ce24f31b8089af55af5a1573cd81c1c999050885c8dc6af58f7d4d0248ad1f4b97e46ee0ffe9109b91528dfd67a4fa04929df5e30d1a761803bd503d55c6512e906cd193a45cc7c547158a382ab200038ef8f5e3a463f31cf31011b0a2c56a789971d42a17712680580091e5c9f2f01341812459ef8a2854ac7e23f24f87184e22d06b42e408f73db71b5517b3cb101385b8238d35d5ca4144037b543acbf43c19555d825700bb6fea75b47e17c0ea6d8f3feac21bb2a26fe3fad6ff254fabca61abcd3ab5beca5884ee1b7c2166f8e09f1d3352b0f2a0f568bce9ce3581c2e1f784232c8045d12021ab54139eb684ea8afc25eaf74d70e0ccfb355b19ced821d212633465965851349d9a09ce6060bdf2b1798239e65ab5c44cd8624bb5c161abc76b7685946c4197d2cb7594e4b98a48371ade0668cad7ec4185a68f136636ae3066d95cbb11c75e40b4b6a197af0fa57405765e5b5ba7dde2a3a7942419a0c52603a20c1b68cc5faace17af832c0c20dc47d9dbb87a65330a63981cac786450b58d20d2ab2cdc5f6828b279e12e5a2ae8e78af207e6c3725a38722f7c634bc5bfd27ac48262bae9f1b5f4062bf6e6a480f6b58afa4eec2a9a47aa925124fd71f85b3a6615f9380c21ab1fdedc766a99b36aee43b98d104f70353d7df5c061766185752a9b8fee026158409bc14796410d83e6fb39b300d54509e1ab351926300fbfbe77c828498496ce3417bf706db34f6a8c16dec95c157ac5f29a12fb5283e27c9e788bbfe75283e3c26ffbe60d96de68a8fd17ffc7c7eb14b0033c47abfb2f2d75a95590a2a050890db4267d81e677f36f51787a0676920be4c8e3e1bf9ce958aca915dcda90343cec2d4234ed76e04c35ce5a40d77e3fc8ebb8514b67fb7a99a123679ce2259b156ea0250e6dbecaeb218ad5e60d51e9486258bea4ae6598f8000fa28c175e1ad79b4e471a9afacae735b55e3d9230aa674838ef530cbe79b9be4d44b18518aa3c5480aa9457c83b18d699848367c123d8f96233fda2191375628aabd6c710472bd1a40fe5cd609abf842fe2f40358b308279d302c9ea37a52c88355295884e42227c1fc01ece5c9128c8cce576d61ca26cd01fbc3bbf65b65ae930f72db8775a3148794064a57ed5fc77249c4621d1261655117b5b6996350832c8ddbebfed2373dbf6150ac5b967f2eae6382b30cbaa9ad7424606ff4dae95843b1feffe5996352599ef46d7d9829dbeafd8aab7b8179284d0c5b0f83d3e6d0a6aa6765e7193486338611a0cbeff7454acd82349c0f24b6810cc0168da1488813c31c062d2c4892fe74d53a31a72bc31c3600519a456f2f0f1639b7aebd7e04efcc20bdef3afe49507adee5a5224f7a907198915a62abc01dabc239006440f7c497c6551ce736fd986dc42d921e8674840669b64aadda9addecaa3647d717fe64190ae4cf8b3b3e4a77285b7b0852604921ae71093817d3a972debc03c929da20b0e903d753d4f5b174c03b8059569c648769414f685bf0625acd459c5e1eca3c93e4ce5dd9efd9f6c34bacda21e23e1cf0191fe5159a1c9ca8975b203d3c717918cd91ceff17143f06420a8779be3314517372aea5c60422db7a543d20b50f3732a61083984765f249db35102cb2dfbb5808b0d184b543755e8c424775da1f92e5696e8af2c6f710ed584d1bb457ca9b8a1bf84c032786c46f2bd8cee24807ae98a880275dfef25c32af7000465f0f26f5d92a2a9e528c2803bb3b3f78e9ff1102e33dc24a11295554b81183cebbec9631381dd3281e9f0b624fb135c8840aed2b2f87d4593a9dd71db5ff3707705cbe79d38f49ed6b7ea0e03c33de406b9e95317a0f8f712e5bf9a894087c25e29514cf1aa33d8d580890fbe9352ff433135923d25da5802bbac72b232a400188b6be41c088ee9a53cb70f746a2b48e4184733e9c2f683c882fbf546574686c0c368456049b7cccf11d1b96ea33bb7a343434f4dd5b6e842e2b079e15bb8ed945d08593c6ee10021017c2011c27677029bbdfa0b231d46dafe1ce894417258edc7e0b18eba8cbbf826dce06db87e8807d3b70451aa091053fabfc89ecf5d4f345b8a60898a5aff5bb2ebe578681e27f317498acdc3ec417a08b79c027f7c65641a600fb8fc7437d3f7cb9cdce303f9d7836e64b47d9b1599a2b536334b2778baa0111594bde22b4ce92cb53354168f6788332c2d832cd0fc97827e1936255014841b2824ac5cf3979ec6c6a671cdb89c50189f4931666bfa5f88e0859522c956346449c9475a32156efb299e45ebeb178d840c8e3a872af33a1e291a65435f657efa1c547986d383b913453b4c3e49ec8edff2c1489b7a90760f9c53c14286e5143b745af021ddb3b9609469f50de30ad8fa75399a37cbdc8b0e73c39224b9ec8520f458581656b933435e8be9617e6c371321c9b26e8bc9b79598580108ffe7ddf5a0408c8ba7a022131947494d66c6ac4eda2bd06d67e4703fb22eb36b6cce5eb08262988e0c3e35009a017202931e5edad3a55b838614583cfb4a696eab5849e6b37d59a59e643a95142d610a48ef5e648672b6b142a06491c7cfcab1b6857b4bc04b08b3bd05a68164061209db2de7c466c3a87e1ee4b0ab4df2518c4b1253f6fdc6f7594877a652466f1d9d8405cae6e7ffa03018f66e608aac290f1c1bdacf93f247e630a2e83724c366b2d19a1c523155120c9df78d624e7cc5a655189977f6fbb44d7a4c7569a0e82e4776db858a6c7088f38e0aa89108f2947fbe5c0d012bc03018ea3743e5f213e32e17d9e5088551fcad4e210f6583d494eb3605c68e07d778e4dad24187bc3a6a718ea2f7a1ffe3ebc9aaa46afbb830ee5bba5d29d5445e7bb199cdd284f1d75344a2c5169cae395d270c93c0a31fae04321273bbeed592d3347e1365e94443b2049f1512826847eae1e00d6ff024c794db9e280ba8c312bb6d4391e8883e08e9ce2be72261497492a93897d1b78d2f84d5086f8bc6a799f7172c2f3db67871b879819e5f867d934b0e84d09a53719041b4431b31d76dfc3c0e5b360db8c3d46db1072c1f5e1a63081a4faa6de18a7c1b62ea3d5e53a6223aafa7ca6fa11cbe16fe3e55bb60a377cbf90410a96337cb78a25e9903ec0b21dafa69e06fa441151767d9829b30206ac830fd748e84af043128aeafeb895b803d91ce417017e926c9e9dfc31f0a7b2a97777b2099a6ef78d20776bf8096c9f34cdc41dec34bd2b4972e989ec2f8d6cc877c8d59266360d62260571ac09740fcc1a6b0c32759c0afe07af45d19221004b08560dd90eb96190cc44ab8322e9b257cddd5b4ad27f832e4c3cd80f7e0943cf559700e03630518c831ac317211f423092c4c5a7266f338a45e15aadeb9af437e989fd7882b6f8d68cdaed3c9b2c7195cf2a967c865cbf5bd0c053c55de7b5bff08413c41b745e2238faea3e637c9b9470f1e64e4094ad4a144472ea20c7af3a56211494f28f27b86207d1498ed976a76a1760075cfad537e3945fde14c913d25c1ba8b38d2dcadf8d8e23e774b48df300c4e02eaf78ebdf4c628bbc8d62c6f9a32f40917081b94792b5e7484c03570b9c8cfccef0620820aa0748d612c8ea03a27b8210baf14179ea23aa01adabfaf7adf6219d6caa67a49e71f7ad038832676cb3b0a1b7f7843056d7c8a30a20b1df16652259e02872f905a7aa64903b95189db99767cc9507b531c724e15fa1ffa3c4070bbac0f709d5615ce9a42d96c8f190dcf135e8244b14b723686f85624fdaa332cb02411859c145baa5eced64edb4a94496d35254e324dc502cdd9ad2250003ceb9a970740875f1f55431132ae89e5ef213f7ea1d953a3330cd1ba965250931935b8257cbb0ffbd5ccbef818ac2318db3522ac5c35978dc1f6c9f47e14abb218a03a4a74863e4074cd3e48efb56f07e5dd8758b36081948d67b56a44cd18af93df584b668ba28d965f2eab32d0ee78bd6433bf21e3ba091246861ffceb5f4788e7679fb7c83332f04bf251723e5a03e340df539e260a89e8e6f7c95ae50e46b880b97f963073ff8a7d0e92ea54769af735421dbdee640187450319b83ef5bc37aded75c6a64e4bb423a93042bc3b2bc902b11bf846b2ebc7caeffa5c0a1b1a3db945251f61756ec43b04aaac09b4b5f1a6d5ed1a32cbcd018a43d9b22d41bd5071beffc217d390a4b3c6e160a49375c61ebbf4b670e498389797357c6ed697be40ce1e2553517cdaae327f497a66e785de48beda68300c154d1bed8481decfa0c08db7dbc5498783ef39004b83fbd7286c137c6830c4e81a998722e7540bd51f36d2e238f2bb647764b992d1ab431da2895e43b6c09bc9269cc009cbc03807825a999c052d32baf8aa7b4d475d7176bc82749e215c777c589b48b69bfc1cf92d296c34c2230301bc2065a1d907a5f004f7406d8f7c91133cb0e5686260eb04e898018de8c589ff085f47b38f7d3d76524aa92c10931e57769c7eb487a78fe6145128d57769695ce36a2a06f9285a69525047ada19f30754a3f7d9ed847aff4f6f5d90131bd98010","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
