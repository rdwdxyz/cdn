<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5437c987e76457993d38a71463441c7f704a05514b09fa6b3d97ef082c5b3a2a4f9992bca2a08cbb5dabff7e17304d194a3a3af8cc9bfdb5a03cabbb150b99ddaf92603031b8dbadda1359aa6e7e714c6ddf5897f62f754e86fb09e1289d9881030b4bb60b5f255689ce5373bb457bbfecabdd90727f8b385e554cb7400b7f6bea8eb3de653096feaafa8c38affe018cec8b1160d1509b8bb587db976c10e74b471f03cde880be72f0b3ce920b9099229eca8838ef52fcb38ae854dcd001da1188305f829984863ceeaa61c176e0851751b6c49ea37d648fd23af16cdd7bd00971043302905865d61ed5ae7f5ae60baff89604ead01f71ff0652db0e34d3b96084d9eca3f77d9f8fdb2116eb5d7bff98dcc0640604912b83922925fc7822448faf3dfa14573d23d44f3276ad52a5ffb32fb7b7fb0947f55d58255e7435a09d83a948f6a6c6aa6c3b7e86db7f3bfa38df3a28f1ad417d2c96aa54560d8193a20842203bc294fc2baa33201cf4fa8fab206919f005d66dee7f0664edd656acf6b7cba642d7d4fd82b4fd3e4b69788c5a5a252bbfca3248eeb42ff000a11ae42c4753ee1151a3918b5a9a576a5ebf8b744d719ef2a6a00e176952fd40fa4d319b1f880895d7124acd6cd938de252ed759f6ffdd325cae39dbad250e619451cdff93abd8f0dd429c4ff86e0958f7cd712e67238f1b5b92df498b00b95b081bf95ea92636e696e8c595fe5d51403c110867cb61939dfa72c32b47180faee882869f5cf6da6035109cbe601d16c86c825e5c5c414d521962ee632877d0007767e07e34ed3c43ba78e2420bada108934d4882497b576fd951f218dea3851afdbb18519330bbe0078f16702d88549733aa05ba3fc59f27f663130f370e4cf9bfc411ebd19e61c9bf92d30f9e0cc01043c548438930f4eb448c5de3b6742d4ea3a9e36e1dc5ff71fb13a53efbff1b43fb8f0983f6d032ca72946bf28639fa4699da1fe001199fed15ae9a2900342ce05fdb175e5ef7aadf3d76186815d67aa79c91a6ad80e9f80264879b93a6fd0ab35725afb782c9aa981ddf4d584e7a8bf732f8e778b2553de78631a7fd6a7b812e4a22751166a334312f390e9da52f3897bb0a8e8690b5d4423eb0b097ad7836622ca4db71be97ee8f48a898706631b1cc89181fee1d98d1b33b2eb9547b5ea3c7463295122b15b995ed6f8cb9a288ad6ae5bf672a76909d23dcbe43b3a0bf3b1e2d397461032a99bbd85745bf5d649d59939107ecdcdf9b9e98488ddb9d0abf6387ddec6b49f2021440a6610fdc6dc42bea277aeeb1320bc898198c5d7e40690a9ddca44e7da9e5008eaa41d91d66b42f3c2bd3c726a91d2cd88aecf264d78d92540b85e5a82c2a57e7757c547173e5a1ddcc8bb34541aa9a437ae30ff229569bd09bb33505daf23e541a8b83cc00ade9eb1e034672e8e1aabfb1adb8a833b876f4e088cc6310e52abbe3de504672d29628046e9dbfe6f08fce7dd1bf65484c6a4fb660053a2b0add6c1884a18d923236cde43acb08d2430ab75bc7765d8423900cc78cebaaecaba07e759d5ad175af951dbda528e12364c113813653bcb9149cfa827a88ceb0ed4530322a2e0b0ad2c52f1143a0b272b0f95f342f491a55f74e5c6c4abad4166551f2ba90dc997999fb3b59be2c91c475c06144b02640580b01b714416d86de51bad2232235a7d399fdae5f35eeba26fdd012871003a9c3014896c45609646284f7017456f3ee5f37e98163f906b8d10147a19d09c8c681cda02d9c18e8abfd6c25ca3be785d069a168016c6a17ddd2354be55ab84576affaeb4b4af6ed62a9b09644a201da360dca36cdec9feeee3a699dba6966b9b885cc82b9c21e2d464f3f77424c028a705e5c695a40f2d9732ab9c873b76862a00cce63860cc6b8598995c5b997d1ec65658ce8caace80a1519c7ba6191179c55767bc78e864369cd0fa802b61503928eab71bb034e20cb622425220f48b9dcf6314ce131f51463379b8ea01bbe4bbac5245f2fd28fb28b661b957d1b0204b6ddaae99422fb00f5c0e0a114c75742cdb085c6adcdc21014fd5d2007b059877fa0897ddbdd67d674bf0f307b82c0b3686183f43931a919c6a5631761673c790535757c2edca428a3913d6d22b2074fe64985bc193214bb8cfb956ebef19dc0e1798f7414a22744ecd203706bae2c511e3f0a7568b0b482c9fec6070d945fd051bb5fb8c2a9cbfa1a550c93b31064ce346eef9278f849604ca58fb919611d9c7d7c5b6211b998d7242f5eece68279e8fe3038bd884ccce72c929d222f1d4929ecdcc673298b2c926fee624bd65844f020a5d685c72820e550adc4a4a0ee764a47bf7ecf5850df0e36af049113303ebb5c94e43e316aaf8290dcc8fd4aaacabc78b6fa09e2b59e6e9ff884d0d468bab2513c4c23323b42c7ea894c54939261744b59c83dae9cd0297c18addc20878f2f1c41a4afbd87fe85af7b95d69168c7a0779b0a57d41a1f446e770cbef8ee74511bbedb46d2021f051d5516f434b6c6cb1cee84c3b93afa5cc2fe3eefb9c46def2eb55fa11ad16fafa5d39622a5a94cf9cdbd466e4c0ce65c5b5ef6f4566dabc97c61baf4d577a0428ca199653aa3258608bbbb1396e5129b3a8703d889980768db8f08bd9e35657551e0058f98ff486c630c577d77ae5955c8ce4e08e277de99a40f5f93cdaa62ef593eb10b6885a73d3b18ec4beea91df623633635d0ca882a3bd7efd8a675a85efa33cd5f2e9d4d5933abdab911c5bb3feab865531bd2617a8f094bd2e57cb162ccd30efd7d2775cc6e54c326dc45d5fa3cd00bdd2d3ebcea58e81a892961be3efe3c0adfb32c04e11ee35598067e8c557ca08b54c62151e730f6d9a2b2fdc4a7f698c45a6deaa0f36fd6d4d4a565a0282f856e8d247ed4000f0b96267b74d64e1f10446b9389ef47a4e7b7bf75a3ca1ac2bf1e8a467cba4ac7df5ecc1967d75c92b68ba25cab513c3027db61da4f6806f9efb15cf09bdb4f534dc4e5c4137393dee54ad783d294c9292777714e2807ac3c7bffff7e28f69e7b336614e11d2ccdaa13729259914b2045e94efb3a18121b5920b0852ec4e06a78372fde201b2899fe252646a5d81bd2bd03ca60e02c3f7f23a96cf4001b82544fc0850b2116c0d2d9df66e136b5c7fa9f3f30da2dd145c50458ad05532390ac70c2ff5f9fd27fa79747ec0d779a8dda818c47e252836e0520008db2e6b6b0fadca07c8bb4ba00b4d1cb6820b450658e7a22fd445cc504b956b46cc3940529c400e01f8b7463dc19a72ffeee32bd005b188d9c9dcd71f30222bcf8bceea30a38b2a631cf4ecdd9551967a6e9e49ad1b88d2673cd57a4ad6428c2e280fdd7aa05a68b9eaa3d169190c5fb9f8f65716f502b08e9af2d898ef2fb2444fd44742ca919a91666435d292cc446913234ba50aff764c0ce66d8f601d55b57db3b5b69fb905a83d726d1b47e619cb4b65875334f6eb6ae5f725baffe9cc9cce1cb11e18b1538f989c208ce737bff0c3abea7b6e1020d021c8758d479c580bebe01de5217359e425ccba2c636fbb8bb09ec73716fdb391bf501b67eb995ab204e8f5ffe9a9531d427d7dda8a9605fa654f0eb036e92cfffe6bad9a03dffcf275a3112a013ff6abe88900437859498b133ef9e130dacb77533e757c03a653a8f708bb50a32d2ff0701aadd0d3063dec2694bfe367ea1c94194b43412a5e979325482f6e7238e5364793e6e798b96ee5b0bf342896dc86a77f731cef04ddd8ed4bca2ba2ebde319866cc305fee506cc638c250e31b45aca9a75e6e282950d0412447875ce806844cc076f393308a93ba172e22ebeea94fb82aad089db7e10fb3b5ba55a59c3675be216933ed18236159aab6a3eeb19233c596dbe514289f135fbb08e1b2785c2f5c003e9edf6410d1a3a5b99f6dc9e70d9d0c81feafc708db16638bba8e33e7346a4993a32e96cee4ecdf7012da51adce6faec4264b6112d36904cc08b5689245e499a73f722ac202184acf784b52c8c2277d4bc642480a9d26ecf28e28ba50d8ca26b93bb8622885b0bd2770bbdd0cdad9a71f4a6c2af5fb95d056f13c266ebae563e59152a7ff7e47d2a9cccedce5b1868ddf6a52a51511d77aa6af821e38480e4d694af49cf36f0b956df7323a42753be5fa2763115d57be520150ca048693e9c66698bfe22f537fe533c1e26c6e92f61d78719db26daa87701ad5c7aa221ee1172bcc6349a3e690cc05529e83bbcc2fa43091879fd56803f5655c6752b1b435bedb13d1fe118f6fce9a47858272f8225dc0cc6ed9d3455a899ba53dc0a5e35f67ba28bc0c1cbc9ad056c4a066c83df4fed94ee1cbf1818df1f3865504aa58e4d20b06295466955822b86939849da4d5c40aaef692c32f50bf6c2f1c3aac02c9927891ad781dd9826c0b2e6ab49bbbb422da9953f947db8859da991000528468091f952b4e44801c06f41dd003673da9fec4be38663cf96b094edd8954d4c2dfb7536e66ec8376ceb60128ce12d7c145ccee6cef638509e68020394952488099d582e2713e2867ea5a6c7619aaae4c1841977ef6d0f0b1dd3ac3e243ce4a861216d6b1b15fc9fda2e97567d6838e75b0659980235ef5ef683b07283041d5707e666663e9275745fc2f32617635c1c49f9b74a8b05261f0db2f4cd9a0b57bcd2fdcfa2084fa3cf0295ddd4ffdabff35fe4447db3f3711b8bd7323684534ebef08f2f2b1bc1b7d6ec10b0ad23dcb25b357059b339b6059cce8e6cc452eddd815424b811111146038161bf2b619a25273b975fadc14e10a91e318ecd440cbe019b99d146f3dfb43f6ffd5cc606f2986251549e0f1cdc51288c166685b82e30b83f4ab58e9e5ec019f551aa3a54a47faf9ce3e70880377bb2dbb43f541fa3aa450dcbc0f6182d646c0dd1eb55a7ae13eb276decae6ba9ae22b99311b429e85925501bb107bd9dea2c6bb6b15ab576ca1a2068fa7f009180dd1b3aa0d18f3a77aaf9775f4dc53ba9cb104b4f2ceb5765393129a841081ce1008f6274cedf8e4b417030188a1625a7f115d308986a683a6c4ffb7a76c4df17cea796e891de5e1133e7f7aef13fff3f0bebae52c01a290b917763e3dcdf40892cfcdd4e957951de571e1c07a857d41c9f1f7e8d12a1a53b6d9be6eb25a657d2d4421cfeca1a87289cfb45b2fb7aded055d12aaee7d477d36e3cfd5cbe96d479d51edfa2bdb456e796f42ec8516449b48dfec79f7c5b70f682637ef693ccb6b2fb091b356c8dcaa426faccc0a4d8a062f732e5d38f1ce3ffac6609ec8743abb7443d56fd8b94b717e7168fd6de4747ece76f01c8fd5eff1d409d5e5c3719e05d2bbe0ad0363ba3aaf3f1e88a62aab145e30dadcbdc2eb15955d40c241c091859e1cec714b6f6225c3f054914a6e3837bf5b046fe49eb4eebe2032ef710fcbe15e6d841d5a24193702669e387b9169bccb7e6c9462183dc00092ef5094a6b3bbb9793c47b4812ae16db1f33f9182473e5b0bd865c4cc7bb9beebd8c89a2c1c3de54c75e31e0d6d3c445fe8cdee43b31f3284c9dd841962adcb892c3acb0defc76f8ab036f1912b5442bb60694cafa709ff449ace8d9e1ae2be646e7283a5ab78de092aa8ab73a5a08a16777dc7db0074d33d28c93de99dcf134bc5b8735bacbfbf4f4ec7d41eb439db982c29f4a6e11735b0a2e730b510d43917eb50e110c9efd63a63b7efadc8b2ec7dc52f4121908ae8377aa290020b68e4a82a7cc2b57380d4060f8d714b5e666c6a6ca990237012f93ffc63adf42743fdd2cfce8d9f8ce4d1d9cd624e386dfabd381e2b17364be173c67ec66f0b5afc5358c4e7c78b173f63c3b98bf1691e64f71ba2d9c9e1874528b993ed57beaa20acd889c2e5ed5bcfeae92305953de56cfbfdf10d65c15d5f563c13fadb481d6a59a56e81a7ac07dd92fb78dc2e0aa9f4cefb04c1446b969966aeb72e184367d5557040a0958e920a113d2a5c8c7fe59534e0a38f12e0d0b587bc8627554cc4bd515cdaf0a0d3a41c918cdda831b394b6118beacc02f315ce6e89802d1450d86a4d5be7ed3a52d303e08dfb3a18e6da2e2ea954726387e5bc0cfd7f28f786690d7c512584a0ad44b7981894e64c4a85e3e41a7e2ccae763e533d76ab8f9bc18e47d68c325a7d11dd31cdde33843ab5e7e1b87573767544596572dd380fbf3127e107f18570fe45dac36b9022e059e8cd4fa40556272688b502793fc3e412bbc738caea2da7546053000b0e3316246a14d798cf7246411521ec80c41e1e9b0158793cbe1dbe09194861d24e8e87aa35507913d671742d4c51ff71fe70a7e59c6e33b9901421e4106eb8fd333a785073ed2a3a6cac475e9e2641e65e683032ad622dc6671a48cd68f63079ef05c819427c72dd10354b055854aca737813fb6f7255a33e4510a76df8cdb9ee9d37a92870c0a38928dd161ee7f746e4a310cadb8f419b12ca739ca660410064fdc58bf9c274b7855576149c2844a218ebbfbbf09124b3c4b4841e88b75ba3339562c940c43538947bafcc091ceccdef3a428f618db33428a8849fb49c26d61466548e3c1ed3b0adf0ffe1ba195ce689796761006c0916931fb7edb91ad6e28f70ad1e06674adb9474d2b691ac144abc87f5cc44f84249cdf61b0618f05ce5d948ff24704cb2b39eeab92545b42557da699efebaf10ebfc1d5eddf8c9d00757d622ec3753e39008a89a8bb441ca0053b953e2cdf3f048c721a36c05850583febb6d6d2e16920ea37ef39ac67b8173127b4c8d1af2937a8d920339058e3c94d8d68f24fb19aaa5051f2aef6ebbb4266c53940afbc9aeb539b0b1925c49a2d9476e830a422f49128dfb5bcc4feae51b50a0e93980142e486c373078b50f1573ad9fed08047461ec0bdfe542b8ed53af29127736487dee6092cb7bba0628cc8c76d77e73d7445e17e79964689321091a8dbc8357936ba988e360337e12276f3535a7b1882ba9fa515e1129d8c2075dccf5842e506d7b37ed3b389c4b960a1f4f6416320737741c849d8ffdf63e003dcf2e603334758c2b63e46b7304ecec3b5b2417dfe60508b1bb6d27ffaa97b38feb484448e781fa459db69d0e12a008a9444ca20078b3983af4f9760fede881f915f51d9e80f9ea3a9d09c827394a03319d4223b9215baa4e09b99362145eadcfb8cb192bed94f9b3f71ed10e1137648bce2cfe9ab0f4711c3c6b5cac0e421a42c674a9518a8970db01f9b8e805d02bbb8f9c805c8c2b0df9a5efdf18c951a68e15858e7223017ce489fab81becf376567703d787c9dd6bd73e3de2b2c91203d152afe745fe2ed8a98f19625f65e12a32f035809f4402169d41e331563838b605695f3909276a973938bdf73a2fd0a19bfaffedeaddec386db8f58e467ec7f38b6be8e0bd5155f3f8e75f6fc1b85d5b601c923c076cacbccdc2af3d70319df666350ab8d670027031b9bc477eca06c882bddade72c3b45bfc9c2e9b0f05e5411d2dad7b4f07bd1ef5f0e3a1a52ccfba149eeb02100ae6871bdafd243c0d0b8ef87228cc0bddb0c823c9aff62fdd3bd08e1c595e512af4bc1d66016c11450a286f40398336390713ed2081a748b9bf470d645090ee4e982c6e0975dd0f1ee28191dcff87210f71ebb0a568e8fa754fa1acaac50dc9653e6b46b2b45753e76a79e70348b340659a333a13aef176c6fcfcd89908b836678539ec0c60f5078db8bf590b316b15fb30e52f28a4293cefeef7c271426abc58633e23b3198e8e2036fe47b1bf3f8ce9e0c9f9383617d9ff25d40c7f8c4aaefce7b9340957484cc47de172129226cc8d6be6139aaff52d11108a436e0532ed0baa0431696bfb71ece8ca8a641dbc269e7eb08eebe86cdbc559d9cc20eaa112aec724ee24802c9806df59f55ada628f7abc970d61654c72bde65234953606c2a57f26e7c118a69485035c6c23861bbf1c10565d4e326187714077f880711f8d12d2a953c1c4366f1e6485b43c82b36e732d5aaa522ec8bdfdcffe6bc39e7debacea65a85e364bf30f99498ae506a2511af585571a9b9d448fb2171c02d6bb1651523ee6ad4254f65b573011ac406b64690c6408bc3b0d5555dc5e89e2fe25661d5d67303142bc3b2a05084038e20f1e4db0823d20bc4a01aea92b69b247d0ad8027186f52e6cfc907db59a579e9e8f7f0dd7e9a3725d8e94c9a3fc187cad0f98e523d5212887fd26c78299380d9f11851db98124c2aa5ad799a38f00e86be801525eff73c5e62b1aff2246080435747af775a7243ce2540f4b8c4f3d654464ba1ff7bf813f42b28320c0c4b7b59e3dddb187d55b2c211518005a08b38ae92493e58d720adbcd4e868c9d26d069b419babc019ce5d1c844cc28b4b5223e6b3f3e121fcd738ff407aa5312dfca3d6775de420e68c0e5030d98ba52d425366b3ed5690c9abc49ed7c416ae9b4edba05046f5e8f9679de30bd6d607da56749bc736d532600ce7b5d16d5a73e3e09e6c22d3a1d43460fe22cfedb8da47ab80cb3f02b67cb7bf2ac94c75da9ec8dc4c65efa07370b7662bdde0ea0948feacaffc7c0c0d8768cd68ebca67c674cee90d322062c426c19dd2bb394427dcac12bff2111b903d4841e611979f8c47b00e32eed1c2f47ead4cc9f32e92781552b9cc49b78d962b41a5d9cf1b9529649ac334a48fc4f9dc098181d66d944f7239871a9945f512247e86efc6ddeb51a43b852573bdc8897040368c2cdf987da4ff76fc1c98abced94738457dd73b2fd67204035f01f256ee844a325e7fc9337e050de9d68eb71fed345659424cd6b040e60aa38fd6697c057c5fcf8fe95a7c9b0e426ca98fadf7eb607bdcf0f89b75cb71f54573d189479b9a5bffa17920c3cfe1f580b662296120c2029b93dce29a6d5d39710f2885034e85c1e3e07ff3dbbcab771f2a9a5c8df07a4633cde3533ba213fbb93e146baf7fc503d18312c8a379b6bfa2dff1e17ba5d1f955505002f5d6585539c5e30d49bd32dd4c5c11c3746fdb2ef64490e011d374a2efcff377f95b3557e6e1ef5ab940c99d85c17b074af0b31e632f196df04832eb21673e3dfc31ad1dfd9e8c292096d3a5d6c47617ba77632356b8186bb77ece402d850d0564c7faab2df9b7c35b6865ada6e871505f3e42c75e177b764f2cb8741500e6aef3639cf53d248233fcdbd9919c949431f37ee2980818cf5ce6a088dec5f06afca770cb5087cd1b135d1f0a8c55fd6070709e13f88793910d6f59bd8a361b5dcbf375d10f9a04e1db49a489c10af171bbf03d286fcb2bb696ac0b626873c446d5d6360001754ccea70138a742d1e519f10ea2b435a33593559228180bd5e8c816fabeeca9187986ac6fc2f40e31b3caff931510ec92f96dbef85be1826e6b69e40b827c24855fbb293d964ee1f2519ab0948a1d1a1ec8e589ad38dbdc435b29a1b6403c4142371a1517dfd54840aa28d223b1419249db667f4a11160aaf7882a48f050072679d5f23df7adf9efee648532de66a89647bad0d078210f40f7078c4ba9013e31f4fb7af40a27ffce78ba0e1880be232d5c0b9ebf5fa5a2c59dcc32380df8b3c0f50ee2d2337dccb3bf08cfa49ca974cdf1acf0223448493668ecb87be12eb9cdd98b5fcf250b03d0bf2f8b105fdaa32f6e5cb743d84bbb84e84570dbe9a9ac98c748818ffdb2151fbb7e58744d196d9b4c1139f2e2ec2d63e222089f3710ea0bcb79c2630ec7c4298b12b2df23de5dfe228c858466952509fbf443ff571516b67f02dfce8c783b3156c708a2e415e03dd1596a128a3a694b96f22d4b6e6be752894729750ab41b821a952fc4992a9ca0802214b98f835ad6e7110726180faa4697d4c32e89c8982704d58b7c555050aca343cec05cf9c89100ab6331ed9b9b252f61727fa81483a935e13a9b9a4f5a6977a85645f51be4dba51869c717a48dcd0e7d90800083dd296f822ac45d3e31f365e46d1e4c1015e1bdd0cc32369b33c51faab52752ddb61799cbe16d90b69c44dff0d9f14c2d89275638a4fbeb3cfa82d1c0e1ff8b598b556fa27473b773b3b1365a7212f8551d85d02e7190cf40dcf9c32a6bce76151ad130ecb04cdd458b772b2d6962b7e4410735cf6041c55f2c91fd2465e00bd52e24d2cc8dcfd07fdb0d7aad2c3be0eca79a42a865651cc2df06c18a04c08028d552544d6797100f7c77bf58240e5574043a205db93aeadf55e1623e2cd778a243ba620254070db9e27e542425405d10b4c83194121268537807fac9a0bfe97e41f3d22af8a35e63f25b5d99886b79b671dd61ab918c53b93d148c146dff7384447f04ad10b3c201670ac213c93ba0e9c65fa6237886511ae01fe5db2a29b4aba19d1dcfee47fa0d8fc247250779f9c2f2a80bd085496004bda245286444076496cf7f9f73dbe849c24dbc32d8d75430d82e4f93617e46d96ccc357e4c09e73b509a2fa0d924e444f94f0d5ee90f7eabd6e0540fd762bf8886cabb7d6ab9dc4af7a2c22e5435105962c73ac318579e0bd95195902eb906581900c77365f16e96345a931c3e805cb1ed7d84d78588a4fc0409592e62193cb1615917d3d54642e8f040b490e2b723fff5efeb1f1ed8164a13f0a67227212af8a8818b61e8f1cbe9a23f57edcdba1b30a2a3c84491c8a8572f48a206a6009d6cfd52789dd3f3f9e775650ea66935663fef88471e605ba066eb47ecf10c61196dd6fb826924b3a7d858bb2b79c89c83e6a847eae9608cdcec8b94420cd0675e90e241f547219d95abe437ef12b0b987d11275598e3f05f94176fdf26daea288135966711b1557869a5a7244f6b39c301add5e9e9b17509c3ec287dfa92020698f7a2fd46b8b37007856af6ebcbb4ffd55df05ff5823d726883e0fc1e905b833d2ce5af5b88a919253b0341acac2376c72a873009438f1862d89777f1d4d26664f1f77820fc6679b5aa059a851c94dd20110528c1b701607be34e4d73b2df74a697daf1d4ccf23b5cf61a255abee6faee5a3d5d3fc7b2812433c82e75e5ebf7cf6de3eb3433695fd7ffb0eac8f011fa5db49a35e2986c76139b0db2fda7bfcd3329e6b54e72f922389133df6be62b8be722bc8c681f53bea379b8fbf4618650b24e9c4433cb51eec3e90352e695af1b4e6daac5a7a8f92f99cc8e92ed9e9d4f86cc39b091fce083b6d56588295114f6948bb9add3252e1314e58faf0b04ea754beb895517aad37461eea596d36ebb970d542d44551ab64daf0c03f52d38a81005329fbe28a3373a90bda5efd57505f3525795b10b9a0d94f8d90460fd967d97006848680235a23711bf3ecc001070da52af581c98c5a66294d297c8dd56442cc2b16a9c6238aacc59a0c31dd7d8acda8e77bc6361950fa04a49387a360a6b4e2b42617dd35c339f073f160d42fcbc91b464be3ef8dea42acf4f752d61ab8c40a655a8c8cb0aec19e46d283936a2ac93747c7b3b78fe1f1021a5400df95faeff7358c009e01dc0c42d0eab24148bf6f9f80bc19b9b83a7c6be2fa54d93e1621d2c63ee4bdd2af5e998c294f987e21d3203a82360a2a56e494721541872147693d4e02ea1e74472b1f99f34586a8cccb6fd412684f76d7b06b1776069ab75b61854d0986c7ebd7d54f11601d013c18a3b5ee5b2e18fcef2fabb0ce77b4e3855418c3bb3ad17694797ec387a530e7c9bebea73ad17ce8b62bf0ccca116e4b8d52456b6e87312c6eaa803f957754133d242a7a1204ff52630e1b21ce4e2f92e3cd6f74d5e88644549c6b2be9ac0c04a35ee0cb953898cc9fd9113fcc7d939d0a78cfd56aefb3c9e178f9a85ccc6d1d0cdabb59ce84a491bbbd088db2e2b6b53358bc42ffe721e1e4f7913bde388464e1fa4cdaea05efb600cbe3cf1b418e8dfb8b5d6911b5d9df32112d57d129b45736158d4c34f89a596c0ae865afb95eb619237d84755ad56db911e65c5a79e5e343f14b8d265e5515e1ad851cde5040d96af94862461e2b87a4b9a98770d7caa5abf9ff13eca020ae52b610c1253757c039865196a1760ee63a351f7fd4208f3311e0933c499483a556ec0821eeb9e3aadf99d3f1c72feb6d2ce8535e8b87794e1ed04f3034a8bb0728e597d2dad5406fc385426ac65eecafd981f8783cab8aa71fe53f313afadc1b076236766e82efe88a2b566b5b77dede78f85ec7d92717b2f8b6ec8b571d2d7f09530f72a5d53f0ea35bd0d795ec09f178f1f8f57fce5c389958f6bec3893aef102c95ddae267b83f0eb5f7453da8971a35de34156bb8824b0d18599932c3cbf1df20c38663d6dc763399f5805436ad57d54c84536921e2fa898daa4f3e853ff0f26ef33d8197adb728e7af2894b33e3c695c33ea19169e5cf801c58de15bf85d39403fee5c2219c2ef640a442c1c941e0c71dc9f78e4602a66e6ead779ae21b4752c3823c59f8c76d3c4c4cdbb5a9ceb689bb91a0144817aa21f1583fd08955e4aac149ae58c6e8952d46a5b76615dd5e176d61c48ac9d541b619ce1009283cf40f2470ce9fafde4c5c3c1d50bfa25cf96a44695e170e8c6285dc14ea75e5861938611b7408118cd8b1b409ba8f29efd890aeeb992871972328c36be6967c9b818fd112714bb4814fd931d6e8d81b0b60ef60eb0bfcbab258729f1b871ee319c895fb042db7b966f1ffde032447d18858d8f3108d176a43c9cf3789b641a61256d9cb41df6c44413998dc1d5628b6b705fbeaa9232581077b8117a325cc883a4d491e08ace7c00ea5726894bf85d364f221bfe4678481214fade7db6ffb73dc8252ba5b062e1ebaf06262fc1307618fbd877a5b692f8132ebc51d386ca3940789f7f6ca40499c61e608396c2283ea11c40d95f48ded103771434b269c0702f1dfa23a0eac0963afe9c12ab190de9762fd293956ef5a4eb5a91dab3b76de4ef8a8f1328a188e77ae378e7a37a7606c3a2546de3270d856f458a37a90c25e3eaf7fe04175adcb9286bcd789b4482bf9020cd587c19c9ac932598690e58a868d123e77dd6df73f7774a0024f25ee94e38681bb2d94bf55c96a8058b77a2a7f356245203c7e628f4f268a0528b7b5bdb6402055e6b3c213b22df3aeced70a98e711026b93edbcdd0a06e1e46773c711fc51b638d78fb560bb52f991336fa4a7b0504981a1495d7fef86ca0681dbf562493de5da425c1ac930a0ffd2ee29f3cac574670af83bc83f6cd08ae4fcf338666b7e65ab9f75b320e52d6ffd5df1247eb632cd36c2f983d9ec619e049239065cc8d8ed33555ad91483a5e01c029d22603b15f8927c05c2c87fc717dbcdc04b1da7ec86bd9864316d12a63158cf3e7dcae95775ed9f2d038d7c5678664e0f8e8243d825f34c2bf8fe2233d1283bc571b6751644435830b816c50dd3c556e49224ff411b9705eea1955e567c0e3ca4bc858e708e6f4333dbc73fd390e9f0077175bfd35f6596abae06b404d0e673ee0e9a054e145cfbcbdddb626712b0688c12398769c7e0120ff932b8884196cff71909efc3314ce3af050530a3bb5f20cf63eaa930cd6593f74a8145aecadc19272d7ec4aa9e575f0dc01a183d4645ecf4c2c834449f0503316a60837e372dc780ab46de216de866e0bfa5acd85e2b352f615d02638e95bb8b3446414d87e34844434d7f7af4295c4af1ab5ea3d567739e93577ba6e7b21c23770d6280497adecb0c3b5457d703121f3e11f3f1a31dd8656f242be748be3cda5d1cacd7d19ca0791d7ab5c213a3d33f1dc30a5a3b7741a60feec4515353aabf5e96d849050e3553b06870a5089c533e4a71ce3b981ace826c56cd713daef340c0bbacc292575d7e2d9933b8ddf0ca26ff80ca15ff0b441c86cf97d3c3ee47244b4a66d6316528d6b7da29ad94dbb1bcd2706fac9b2a94151a7c2b63cebfa2bd8cb88db0cdd1b7f7fa5c507072310bb953424c80bae45b7d85b6505d463a22e62b9b64fd3a149571da19037365fa7cb862e81f35a9ed9f249dc05fbbee208bfba917e228001220f6f92152ec72f7818c36aa52b2b1cf413029ec9d64e66d0acfa409a1c6ea392325e6702e20a529dc5a9c815641af85fa5fb8358f1be5ed9f6ab5e538180ce0a1e4922cb0f7bf03f9f9c66bc8682565dabd5359b269a7f97b1b008776f8b9d8746f74fde9561b6e3bfd45fa951da5bf4f9661508e3e149a68c1a4f141cc421c1c317e0d121df402a334a6aea6b0a994ab6e4ebd5d312a6cb5c887421ed339adba494844bcf5b05199053ed7e82ff8b704303bd1881b0f2a775cfbf7c044afa8ed93626a3d08dd38143ef431e89bfeae87c80b08aecda6e0eb168a9a45420ce44e7751aec239c7059bbd4794d35e63b89641a9afb5dbbfc38f4efd8f23a8f81c9b847547d6568b117614ea711f067b08bb04517d27aad287eea91b19bec3243acb854a34c921340df182c472f5cff727471c064adac67422787dfab7d5cd840e8df539bb484b2896dac45b232e87c7262c21a60737ea7d0d7ffadc2ddc7c1b53d1c97d21e34da06244617d1d866e22adb1a308de135852d18b04e5f49fd72c06e51e279274fbe3b50d72dc5fc7cdc121931cfa55478a616f396b571f06c07bc63828547c9f74a37a71021f78194f28dc4bad92fa76965c4d34345053e05aadac9ea9da3d70e6648b2e6c89500b025aede0eb2ba75020492aa4c87572ab8b7caa861a8b3bee9dcaf0f0ee19fa65fa64d74b05c926cf826857cc5ccf5d431455f7ae8b60df2812ac3780fd1dbdfd798b6394d5e95d28a083ad9ac393da2eab8c8a0793d69ceb4cdaf6c83b5db89198e6cdf404deba7c20a7b9886ad0206f371a8cacdb5f067d1213b5bb04970f16b84efd09ffca19543d0640144cb386ba1751c0415e1ae5c5abf4cefff226ea139ab2085eb10b3fc34a8b2adec22c8b696de18635b7d3209033e90130946a632f0ae2c4930665ba3974ceb16021f28536bd664eb0f766c8cefc44a30953ce02fe5c4ca13d7b5e59a596b3cf96a1466013a8763b8574dff3b35e9e7d4a06e8184860c79e5b1c0dd3948385a236f21e9c92a2eb9dc5ff95beb88c998a522d7807fe64aea5a5819f990fe11509d4aeabc7543efee338f8ed5e231f42aa2104ca04f502556281c39f92ffe4af5590ab2e8151cf7b08e69f11c32b063f7733bc21392dedcf39ab11692d4896962b004e97ab0ca7b0e4f82b0dad9b716c5dcaccbc3255340eb0bd01c6ba8af19daea3a1967ab817dbb93a8a2618d0bcf47dfe07ad9c920a285066e436cac1751de60ea22a58846a569314af16ff0e6dec2f63dabaf80ed5144ed46bd5a4c860f88eb52ff716b4808e23f9e5d89797bfc0fe002b4d4e0bd603f2b98a655e7ae8bf83551c5057b56d8aa6857df797ca2650a06401ecaaf0ca3a41d42a47cc2cc2e9913e205abb6ce1ebb5ca2f062cca533f852288f32ea0995966e79451a35043ed67fecffece724ee4c420c6d5843994dfcb40cf2c348b3ab2c3cc3d49679e2e77fa9a54657672581d7145c7957e67ba8223c1f38c1b0d9ad2dd80f5b55ca4d58791f7d2726bd7fd511d2e476889fbc7a1538550b1e2e92c2fe878ded5612748fd74ed5159676117c225c319f3b792350f4115a641f80cde3046d4c9f6375a719d406ccb3199f19c7fd1081e4f5d66d6b052fb47155ea94645e3cdc9f93a94cb611cb52a16742926c8dae743e5addddab6272ec3120c714bea9ea656ac9b51eafbd09628a2d5b0bea82d029dc2c1d32dca2a741ccbda2481a2d2405f20dd123d6dd775889b4e7a1911760e7dadaaf0dd3653fc7c529fe0d108956735214c84e7f596e56413c13b024206baed867d114dc14e3f0916e755d88a70e85aef9ec86dc11b18eb23923f95ef88cf45e66c79bd23451e65f04d762878a85baf0147be81872a06372f10d85ca94b2f77da21a6a218bb0a431655e69a25707868271e1a66af0cbed4ed68d905fa4b4674bf4c9b5cf0284913cf2ae88f3853c5314ab83ddcb66f4cd156c96542bb8e673d1dc476b6600d5d97f10b98f3389b7fef73c0c0d01c2cf30bc1d193a21cc8ff28c9a83f6d94e113bd9a45aa3da5834d9dc38f202c2ac6c7e70e600841fcb69e63b8692d6b5ba4c870f47c22367c2bbf6ac0e80055a8b73958b6903c64a5cda8703e7a1c15e415975380d81e477b85398de1cefbd7f9d9aa69d5d482204306b1697b86323e8edf1feae470611b8299ace5120a98b24fad9e5475e35956d2da4d1b0868631581dfe9efb0e19c2c10dcdffcf21e552182d023d3051076520ee1bcdc4cf1a30696606330ffa2d56d986eecf91dbb155b5c5f6fc36177ae04980ef94bf70d07531177ee8abee3de43630421b724227e9bb20012971c7b9c06234c580f6af3e1688ddaf59854ebb8473b0dbf3b9f3da2a8fc5605908a07fff7df4f479c1d1d9002263751f7e428e57e2dcd4c50cde5ceacf73829dcf92f4993b6890e4cc5c85159e0f261993253404f4bdb54b237ff6ea6f48b3e655e97912ab14fa6de555c05eb479c20e181ebe732350e212637be57c8229b3e3b781b9b878a8a3f47de2f78379a10f73dfd41adec08e5e889378f6cf431c4b708a970a2a04401f103a2949b1e7adc64559a7b55804eeded96a083159df647e3684ba8f2b830e62809aa2fa33dc3dbb4f6c12579195ccf8a1b035c98f2c05cfa9aeb4e68288d5d22cf4008cad3386f164c9cbc8e4755f1ef467335e123ff9284e12b8ff09e46787c252f6d7aa2665fd6f1a8d5b022f68688a1650e073f785df44aeb3248d6bde2f25a90b30ea80bc00630d9d3353e55a27ec50a76efec6700023c3a5a49dcbc27ed7497280a72302f4c47fe502356d7f9ca40b1e6e3821bc0315cdcd605d2b121da1fe1d8e437180939817c4740606d648c76e72e442e079212bb0af04c9c78969f21fd5aed3f295887682bd8161cf1a74a63b3033bcd3387c3c7a544a7f1e758d45d242b5b23fa9ff48fe8ccafc17b754f9ae08e05926fd6842b265f69acf724f7a6fb88613cce304216e7c6a4c75ae17c2e27b3b35b64533697ad9614d7ede062a7468db5e85a88ac7501b948e2f0422bb16f5015e283fb00dddbbea751634d2aa176cb87f568a45930d5579105753b04195d697f4c4b5ef44a8409b63d19314c8ce60b3a641d8bf962d888be68b63154e0dd91d55a66074db38fa9af3e12a4a3e63ecb33d064eaff43079e879ffe95737657fda44e39372fe7caae349b2c3a56c1ab8fe76a364da0866352c03771ffccf68f5906962e77e18b9ed11f5e9f4f71fb225aa79c4c9392eafe104846fcb7da21ecdc47196f914000c7c100c8646dc3253779ac415276f51c156442ac64127833ced5be7eaa813c5290d79802aca6bbdf3f68f86a6ba3364764d143ee89f5585946cb81bf66dc08bb8785c76339313fba62870c35ad9ec08d69d87312e0ceeecbe5130039c372a279ab2ebf0ced39eddbaa9906adf2aeeb2af45044480eecca48c298eb9714651272ea9141bcc7a05fd698aadedee87cc912cdbe31f0e2ee657f499dd9b34ecc146f492a230bb744689fb669e552ca0f3e7b39c91f79ee5282bb48451e7aa1bca432a5b11388f204e3fca75462c7a46c508ed415c2a2a465b1369ecea8d581ae641e0fc27acb7e488d2b94fa43e41519252c59fb83b7561e08b6ce44cae05e96a4e1a7082995444006e0842915b7b880e9ecf3720dec01e924c607e9fc0fd08a2cee185ee90bfa3178f70c33ffd2e6f0f187c6378bcd7a873fb7ac03d3590e49f5d39b5296adaea865ccbff2e0a716d46541fc993a4a33e88996613b37e6df269a6fd129eb17df50a4a978a9927179dc26d8d38ac82385b0e291e92718aecfc252b0745faac10dd198e25dac3d8eef57a9ead2311a01ed01e57e8bae1ed03d459ed61c29ae1770e09472668ba1ee11bbc644937126bdfa66379bdb34d3da7b8207169868a4ef3f740358705b6e9b5bb9eea8eff4cf1ad5bf3c9e5394103608e49b5f183caccf3177500c83e295368aa8ed47cb114c7d4968b3ddcf52ae5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
