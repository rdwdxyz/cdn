<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f2a682d68db1a2ef70adf7b37c082149e665dc8606203e8cf021ffb3416365797efd9d17adaa55b040ce3f4a56670763f1a66b6993e95e72994f1b5f75e1ef20312c04b5887561e9e58a0ed59c46c281ea002eaa84fc6a33f891afa008d1f5b469985a9e25ada6d26cf16ee2af1c6817b731872ba14ad4544fd51a5e731805a7835864c7a5e75132cb78a3e34ef147642383d0866381a39680ff0c6d4f56d1cf6fa30a11c191d51939d3ec48cd50e7a96007100b50fd42ac959852f4844357ef124f37ff4b631ac064b703444b107caedfa447d5425ae3fdebe726429b57ac8775bd8439bb3106ce9892df3c5a833d0f145f91c230888be56955136373d6a7ceedebb77594c6126ebac16b7ec02be41337de5178bfea628e760c2719139ea3338da1f6f3a855ede7f636c15a2f7f6cad3648353eb4d259501a9915b0fe64ab6be5bfac6d235f38a514ae20c25b2e5a9c6146959a94fdc866dc6893ee9b25467bc71fd041d4173227524b55f56d64bd0a4af44a4d7b9806550f84aad9328f2e865eacad886a5540bd1ef79badb61d9b09c043676772282a77a9e014ebf74856e614db3825e32386df92721e462dfe7dadd9d7f3cafe15675e698aaad3ca6643ca2b3e8bf3c6012ffd7169b189aa787f5d6c948f309af94e2cba21bcee3b279252f357a2097b1c5ee640bf2f7d70798fe06d20dcd2533b1302d1858ee99699885a0fb77dd03763f3d4fc8770bb84813d2fe9769171896eb95e57c938fd1ef599da94eb838a7c66d1d99bcc8ce261f2b44fb8b289bab199776235bb38376599982f8040dee6ad241b7afee93a2aec3a7320c4af5880aab4e7cb31584318721de8a266784cc7c4536a730ad1c78c1d56ad80d600e91eef7c52df974678c3d0058d848668fc28628697898b4db7a8636b7b3e545c65d96409ce67bd43039757afd25b7bdc966d60456ec0820600b948171e54d8e89c73c93e79f9513793035bee18d79533f284c80dd9c11619e098d6f09f5d6075a7aa536809c0d734d25a4fe4b3ba1b32bba34e04e4a37780f593bfb10284d573e0bf39204f63a890f71bca61e542f1be72a5ad2ed50e21745a51469dcee94438e5afe0f5232098c062ccef15c1a11779d988c05c6f29459caffe22cacebedffc44c0c0060e51e5fdc1b37e711a224492efcf231abe53dae455f49d3fcfcbff10a3a73b4d9f5fba4ac932c60314876e5db3bc42c6a4d0da7963b5158273dd85dc24e3e0348191704252a88328cfdc9f6b6d28b2b149d4785d7c5057d2b0c2d14b592d986bbd3f83118f2b600fc86baffd33400fcadd559fdb084e12e3155d77d5ec550da68b9afc3960308ea897587775beb1bc7b681f6fad4ea9b11f63d8cd91e925b299dd0803a613fbb76d3a30984f3b1289483b918d0a4dce17c3ceaa1918cd5c4033a73304566c37c2f1abd9c1cdd877da930b61eb03537ed274afe96cc1e556033b24d655c664b322cc7e8248b3f4388c949f5a0d48acd48633d77a4501ebcca77fbd0610dd556f2c9e9d09a647ed2a4610b04946fc07b635304d8df1a0a25d0c5fa9bfe796e9fc2dc14642b63a147c28a3b425f96fed03fc0f3afb7c9da5ca5015c06d413451f440bcdc0b4664e3b566996f9df113e316c14a81008a9f84271aac03b9a364bd302c959f9dbe206acd0228f7200fe7aa0628e60bd955862b320668338d03bf993942de11a6424ec049e5985fb1eab80f6a610c90a2409b7f63851a7cc46e347f9973c917f6852cea96ae0b41814687a72f37eeaea3d7dadb19b3f865380b7c1a42fc414da2186428e87f8459ff70402a9e6c3674dbdd4ddf8b54d241285a88a43f9e7556c763d1a56906ce2501609f6854320235d23d950b374452dc903cacab4a02e9497fd6ded37e14f094667b92f0f653627ce56ec95296c87ed5372118b021037b04ac7e00f104d4eda656aaa0efc617cac65ff30ecabc534d9f7052daa9dd1a0270e78107dd9becdafc93db63c5b737a6ef6a7bad64f1238423ffedabd4fb833379e834f35d6ed1485be142eb403cc221e4bb5887841e959d307700f06d2736741a2e0977fe41b22fdd30eb17311b773137569e1ff180df5b67918b8677432662c149d001f6f02fc254ecc93e01d6c66819e237edbea9ecdfc990c1aa72a8d8909b4ee5bd0259301277fc216efc45811ff683c7818e0900a76ecad5a0df6e7299170a6c6cb0e026573d1c9a108fa9420e4ce26fb3ed6b4d906367b8f10457531b0d3314e818244effd7cc6d2d0bf29da9e7d64bb546b8f72e9318fd60a0c0b7cda8389fe945ac81cd70da860834e369b8b2f09a02895585403c3afd657b4be67b08cbd8b12ae441e907a98b762853afe36803b0c099581e42ec6c089002f007b64d099c1929088ac3803f0c4991864bf2bb5462dc630acff0b21cbda492fb65567eb5571ee81bbaf4d704ec1c01ae3aecf21a807378f126db0a65bf9088ce04093669709d1ef09d081dfc951967fa57d02d41ac8e50942f86560c53b2a1cb66f1bbdc68953e7644bb868dd8337a7915b4c0941aecdeccc4c41a8849b7c5824a9eeeff85656c724e7adadf946297f82c4917802bf78a6c651a148b82b6fabcdd137d466c89e0676fdfc3c43f06e116504ecd625b31df2d957d0d73710a36616711e91518dacf23299cfb870ad74244bacfb8a6e7234f38e36e1b195b499d8cef315960ea6beba8ebf50c3f89262716a5b6574419d635f52e7a78a7ba0024b5623605efd7e4e405f6a1c77d5237176a3ddc066bc74227e8ff91104618616cbdd24b4ff56fe787c78b8e555094e66cc71f782bf4d7671c05d2ae67698db8b97d293f3172f2cc68f19875817e2e1980aa16cd39014e83bd94e7336399e99c5b1f09e5cf6ef223ce94dca75783bf6fd5b6dd8cc179ec27bf8b4efbddc1642e0eef02e112e169019aa50d9092390e1dc2ad7447374f3a42eaaa0e51b51b821b6a18e1733819c66d7be418a5bcc478293a5de46ddcd6d97d8e85c8927ed4eb435f08215e45906e56af204030d070b111afbccf3e6c1772dbe6afbc565a052d891a2093b71cb68256773702e956376256c7446f87f0db072c9deb688544503ae9d31c3657f35a0e3099ede1f690985c11a779c4ff3e6f65fd6bcabd3d5de8aca289a6cb522cbfd6953f0f9d983cc99030c28d154e10087da6b7b1177c73fa112780b2442d0ab3c5b4c580cbf1dc649e3db54643a81fd79e5236ef9c5c558889e4a0e792bdfe4a703989b90a7b647aecc5c3f8db2e29bd34a4255f4078f7eaa39466a7104904472ff7d5d6c8de280b1045a37487961023127671a3421148aca9ea3bb4fc000bb00fc36dcf1ecd9e81f9d734589e91c421a0d0e5ef133170c0bb37f73650c5b3f764b5fc8133d93fb6a7650399f3c55c08fc89f1241617ed910b527087e5c7076ed46a06b0a68aa14fdcd02a5a2443ac0fe1091ade25e7cb7c77b821dac6df771e379dc5911c160d8d5709ee7590e4cbd06e2e1e99807f7f8e8d942f01c4dc62bb999472ea7080816332e3ccedbe1b6a341ec9eb24570f8496dea87abad75ad6c88be492b044450564eb5799c55b15070949744109ff98218b7b676ce3f587dedbb68e0da9542a1d0eaca6aabe16ffa23e39c5991b7a939a9fc8869544dae44fcb702fe0b1c8dad1d3623a87d51bb3664a4a3deeb59f30c7d65ea845c6f88190563537d38030a5e0142e693e67d78a56574b629a6d0a77d37bdda1085d65f8760eb2349fbf555d15db884f006a5d48ba9526b9ebbf0cc74651d1aa13833f6598c93244cfdfa9926c7dad9fb761d758268158c2531e219e3fe96f397b1cf54189bd06f04f2051efa95f425a1ff5df78e8d9441f2686c3d62f283adf8f887c719a9dcb1a0bfcdba1ce381a63e6772ef128e997660698a2329a75c7ec76afa50521249be06387649a77d6e89bf4a080ba888386f22ad4bbcd9867796c48e58d2ceadac8da2998cf9ba2870667962a3c60926862647d2784ed8ce73711a4ad608a6ee7b6d170d5a15970127cbe1afb2a87dfcf86c723341682da3c29cf9ed9cee0079f4fa8ba14fca04e2bb0a053454c76240223d0b0f9d7c44e4621904c7c46bedaeb7c4baafc6a3918844204278bd28b382178f25787cbf462f9b8c8572303008eb626060f03bc57ff2ffa56ff80e18e06499aaa4a0931f0c8c91cfaff03c9648bbda36265ca9e31d862cfb3e5cbdca0d81e2f720e5b008b84dcb9ff7645a917df55b8757b411cf03d4f9140d4d986b7988346fdb156d05d1d6de8c25f4dd415f80d75496a37b035ba15c48cae10d4e97f6da9fd481ff10cb32d2e831caedf7f5e44217510638a3c2f2e3cbf873dc7df939d9d050ef44a30872d14a1b427ebf073e00fc4ca1dae8b127d3e1558ad353679bac31fe9039c009e76bde2f3f1d99cc959599f36aa6c371008ac070fc1179dad5a06ca71f95e14ef120b73bf1a7a1c9ca5e73604e958c13958f5230a545c436839ec792a1c612e8b2eb560b8d08d6a81f712b5b5f0768617284fe14868242d17ed5ed36090369c2adf9fe843ae546010d542dd3fccde81ed4b526cfc2c5593981a00400793fe00b5b0c7abf2263bc5cb7f1bb3788585d8a3a21092f672f5b5912029021613b6cd56dea051c41ecf149d2943d760af4cbcc52a3949fe2553d8d0606d7a7d32162b85e2d92cc8b608eb208a906a0e71d0cb8950901be0b6027412af6c1af8c8f5b997078d9bdceb167859cef3761f8df1dd71e8f186ba37a51b6c91e8b475eba918f401aae475bf0041aba5707acb94d056c06bcb8ed5f155f34546fa73e62a06f38aa8857fda9622f591edb1c0edf301966d7353587227f331dc389401ee39e0aecee909010610031cbf1d7d47caef4489c9f118ec03da3865e98d471e962c1d00ebee2c853efe3818e21b9455ec3efa6687431100bd55a6ef448ee11740817d07c1e07c380f4616d634dca7df2a69f256d896b300025719828c8fc1814304a9703032beb22171ec75f31f74c12948c32415cadd76e28f22d7c515f24f65acf5e88bb2a674671980f18b2f91babcde055c24c83d689efbb030073b5cf47b105c8d9ec95287ac139db664a75f2a853a0aeea8783bd970595ebc2272b7a9155222de986a7a9f2ad95b03f14f7609309f5b87d60f171378110014a41e0d6be08fc7c092413fdd8b1cd8180135e4c4040b102c7554eb7d1873b1c23a3e8dff73335fd92510089a76f0509d5c37f2ede1fe20c17440190d6e678c7b0da9b2d37ea1712c33db39b63957dc659fe9caa5ee3edf22238789188d87f6d058e8381ca8eac108e0c17d5884289431159d35c6d4e839ba09e20cda5ecea702b8e704c53067f059d753493d27fc0b95cbe3853eb8c79dac09bb9e87f9778cbee5a52b5786d61042dbd6d0a98d22c2152b6a50a2f1fe874a43b5269223cc3810c1496eb8b3b32cebe20b007a0c91b763fa885da3a3bdc2b4047e16a25c09fc1b3508abbc627a12925d8fb7686b8e05f57bce5892c3481619c41f45ce23ebea7bc81fcd005e1d07dad892092dffec6a2c7f3c95beaf7a09b46c7112e33019caf41a873fdb38918e42fbaa4c358b586547daeaeaad40163106036e7310447e46d4cf87873e21babdda09aaa5eadddfb13cd70a90825a8f06a99e5d06bb5489b4d053c3f6cf324bc6398a9004e48275d73b9c7597002a1c0dd1a80d885a3b2b576068b62e811aba16d60452db92da5bb9da7ee23271de637a752811290f65acdb1afe78ce5d268fd1be096d6637a18b73517de32ca6a917939f30c3e9c5532e37eb6041eaa9ce1199a4600507fe96ab3d36e5c91404e578b2a01dc646c70cd8464647422b8f7f6acc4fa11563f8cc1a55093eb77d2266e0fdf4a11b1bf2e23a7e4069231c0851555cec29cdbb962ce41b1c47b8eabbf553a4855772748ccee1f6f4403a299191ef2a05316d371516501ad6c5a4d4732a2d90fcfa6ddb0862caf3b7a98405aff87225eb9d1f1f843499657a5a7600940e8fbcaa9f1fa6b92d9db71277d260b20d192dbaaef0ee19350914fac9507831023151e32ff1ba64544b3120b4d1db7d2dd778e168aefa4db31b8d4f88e1f66b0ac6708aa0e6c1768a07eec2e9843fda3378b5cfbc51b1f668b27fc0bbef535e0694511d7af4950072fb9169c4d091b9bf7500e71f03e9d8cc1379dc2321b6e93b0764f88793ab00d67966361b8944bd6227482fa170cc8bf21ec433fab7e51814dcfbd07e97d9e9c42079a9345935613dfbc2b08124e40fb25bf360cf36158208418e925aa2d8bba9d7b5c8aef45a0069bf9f79f5962a0e83b85793a826717e50cfd051f64a9db949ae57f53eab5559a140ca626f93d046fd7392476e38add643f485d0f90c08cd1501f9fc5d85d3140e7fd3de874f1577649109fd061142717fcd1a218c9ad4efee817e99eb39510f89dbc40cf9709c781445a1abb227e208748ff320d6a3f81c3eab76739a9b4f1388213bd04dd67863a15ccd5800d1861391b653c684031240b97b6b11f4a3be287bfbef20cb6e68d2d866931ad741243804b8577d67a92954f1483aa970566efa1f79d43573e86c19e36a6fb28d3b08735a5435d08a586f4506da7687eb3d32d4b16c6d77cc7aa3565a98a611f4609b68e291712d84d098cced8f777a54608b6a68d276d864816d321c1a31f5c8b59080736c56ffaf026da47f7a960d6b83567b2b01efc708606a7db92076d2f1700dfd6b39cb4edcb6e55fa21622f20a659e404dd510601a35bf0d45435d1ff9871c01d2fa6e71454edca4b79d64fbaaf482f2564ef8fe67ffc6af9d26c22c163d2a696b0bee2dee2511134ed2ddcd90ac4cf9704fdbf0909675d9274b363adb85a2bc5be73f71a0b2d75ff8f80ce9d90836f57a74e6ce7583108aa24e060069e1560b4b31ba8586398b0d96e504a00e3affd783a79817fc960e607a410eba3590355e83d689980f98d36986c3779440f6bcccf0b7c81b4c9c90e683475328c96e1fd8eac3d77badcc12f08e7c30b1cf914a6f6cab840cf9da723a446cdf09cbdc147be2e5cae8db640a3a3665e83592a3e5b9c5766d9493c4d148372c275cfa2710e695c9121db353b640fd352d365cf19854f2138895c540632a9f28cf542f0d20ca1aaf8239fd5b90f839619a225e7b707af6cdb134273723b7d9c79eec0b1fbe36903fe8043171f34b907aa1d8ca59e3f0cbd838c305781c63f2cf62075525e1a5a7211301b5447dca703f03395ab691f07cc0111a2982d5ff327786fc92442b512df130dbf703854b0ddb46e02712ee5369c3a1504024aa8b4d0af6851a2a6f9134dbb3ecf6b38fac4ffacec2572a5b093df6a2fa84dfd66eb0ff8b11edabf767a113c73f7a9de38035d588b292e852c057feeba438fadfcf4b8c686d33d7f2adb9a8e9402b39183f9b7d18da62ac56d37a2f7ee51177591be40f3fc03f002d2d43a12b885883dfe584584f65b7d67f2e49e614681eec97eef99a7ffc46713c23de9c5ba240dc62609767d40bfde4e0e950e8bffe9e28dd4b6218c3a74771b76c4f86c06825c7d47578b32287d022b957a12c094366b32da4d464ad11c04a1835a34435607c4e29384895d314817b4a0fcf5a255da6f047970c0834fcd85786aa2819fc063b4b9fb5ffbfde05ba64027ca77043af6f9365bb4b4e311c5ac8a8b3750c2fa6bdbe5d2f22c95aad9446e1d752f9d63fb91ded3a929b4c410293a7de77a0324b410bdaab0326b232680823ad4b0f7eb491ef3d9c7ab277e6ca06fee28ae9bfb130a15d8de3b033065ed5cd9766a352ede71294ccf281d0a754df6b9f836d122542f9371be4a0d3fb1c25d917d64b2f1012e32fc15891f0c0755b72e69cd5e992bc581dbb58aab892834150c0d3e2213ec400362c12a3f0ec29a0a06477294cb97ad3d5650ff809413bf3c2d31f3b395046897d8d5f8c9c1a408d175e7394f57c1f931f954ed171631543f1163e983a6abf1ece38959e5fab94c9878e386494cf08a34802f95e24017b3245a577ed2a8f48b7fd65286c23e78f54a928c81fc4b33cbaccd1ed60acd36e02e97921edfce4a46f125234fca4e3e84c9878eb9412243e6aea48f1bd4d73b09197b77202cde3043cd95851e7e410c2167f321da94edf2d327a05f6519a3d5d56d1db644dbab52263eac39d551720f7764582ec3063df519c864aecd525fbe6ee2cd0b08a74c72c51c4753da872cbdb4f9092a08a3f4dfafdae1afe5b1eeef79576f3b1c99c7f255607d1cb9f64307c8a39bfc7908605f6d8bd8c4bb0216b5001d7a289158a92da6e4654f1c75a0ac6e268c6b4d701260dceffd25df4a7953fe20363ef218570bd843623eb60b12d20fc5ed9ce304613ad1bbe98b10510ddb4f0b303dad8ea6bdb721cd096426f620b1aa2f6ac11e7ec748e7cf11678b17a46acd88dcd8020176f20367ec98d4fc0bb5596a0869422d938aa849971e39261cc8352d3b30f73c5e43f384838ff5d1f2df13b18348dac21defaeb5908f5b7d0af9200475e3036c7364b5e7e015881b8ac0be1ecb761868ce73e8f01fde72494b04d42f5c398f10648327183a102b9205d028a039cda1f0660c158396d129d27181591054c69e7c369004f9174f39cd3dfdccb33327da3f3b73c63e9817a438ad0a95544df7d7d59c068b720197ff3ff77ea402b9fa7ce31a43a7e6d9a9d647817863ddb3e2983e7bfdd9c11c271c33b99e61c6bd0414aa2b1f68d09d403e79afd50b72ee2525d657fcd81dbb68998a5d45dbf148ad9c7440d42532faf2322ac2e964b492b2311e9ab113fdc0b91dfb5bc7e179bad02c64b0cfa4d0659843c5bbbcb0a9d790b57561debfbe8340afd20d8030ae26a649a40069fa4cdf7db36aeec6736640889d6417d2a951b5b1aa88fc5f105653cfa53efb312cbf1313e9e75a6d79a4d0323038776d18e84a0c5646f63571130203e876efcf811199e710f9ccc923614f6cfbc836de3499cadb0fb1adedec7f266149049481be1fff04fba137492a0adb6aa58e8b38750871d57f7ae451baecd378f52f38019e8694c3d43b70543d85bb71ffe996b1394ae1ba4d0c73c31312674eb770de1782fabd6e09db71c1aed3227f9da6925db481ea9ae8f8013e28e1c443a128e04f71796a3f499cd9c5bb000e068f90c9f063b99fa3e9f8d41ea94e566f66f3cb4db530e17630033798c0390e1b74de806e03cc7a8535b4c087c26641526ab04ddc3e326dd2edf9851ccbcbff43b4aab510d84f84012bc0f5656b0a798b83f4c576caf13ab878f6f13aa1539b35af7341adbe3618ff7c8a60e885065358e3e4120ac66fdfe9daf752c13add0e7515cc7d0a6f3a9ae83ce1c512cc65c044c59a288807f70f976312be46fd95d52fc34afd7a547084f8c1f382c4212d9298a64aabb760574388cc5b6c7defa2ef1a38cafcc032407ff445d8b41fb5ecf13191b388446e29dd789520603f20ca296745df17d7f8014c72101e778d8497b70c3f7705e30cf6f3d18279f81255ce8e9870670f8cc9f54c2f0dee4d3dfe66ee079d84025c0cac75ef29a8f32c2404978c717dd3c61c8cc000e5e5f04114dfa5f91d4beeef0932cb5d397de870f7cff35ccfed17e376b441d6bcc8a1a4a4c69da42cf89f1f7453e3c392f9346501f07fb4b051fbfc7411c0171f707ee403ed416e07a255419f66539195d44dbf98b50e73593bb302f49007269d6815764e9f9932afb04ddb1a9bcac5ff8c7b1a10deb66b861166e06b95e18dc9b1679ab98087e3bb574a643e07564ee5fe9ab955c7925512918e25806b34e4ce891f8f62ba2b21df5638e0d32c17b2c62e00dd482e6e9a659ed84c19f6371a93bc112667e8472d2265acf9291c6b32dc3b843b6977481c180e26fa6efc972efb4b1d2ca586c2eb5c3bfe49a8e11d7499e2a9db9ea9c76845f72f88925f3ca89a9ca58ee51ba99b7f02c625a82ca57603b80f5c763a468e69629db64b47da9ebd113e0b64dad40abd52434ab8c005ad8464ac80c09f6d1bd1c9fe0b7d6e41235be3c531421e334fa731c606a541fbdaef70bdebab4efa6e7a14110a7c0458cc7006812cb2125756a0d5a14bebcf9d202d3d7359c64054a1248bdbd9af632c63cc51ee3f44d20c2a87e808634c6024df2e94e634e4f44c6f20e4d9519c489ebc63ae7fdac06294b058ff80e84aaa5722bed53e79bd3253490e51de568e97a06eb6ee0a1395eaf90787856bf7d24cc23530cefa0ca33b096c5fd77421da26d3ff40b5e3538c69adbc42fc7a4c149284accd7a0d2646e8b1b456ef307f4bbbb79cab4c64c2722d793298f1226b2909bdd2a76eb0199cf0068840156259857621a85f6b1ae044d384a0eb6aa2f161b69387df0cafd39af2a4e201ea43134f48199e5e2a4b6f6fdbed0e48ec9876adc93a2779d641d23e6a895a3b0c892cbe0fb5651a502ccaed068368cbb4b4a265f140741083213f952a04ee37891889c2c02965e10816b3498e8e91f0e9bee10c27f5efc23c27339b226142ef24a33a8b1600bfbb34ba9a9fbad8719bb4bf0e7c1b03f8f135c5e1b132d8927c44edf0ca6bcf22c3316cd13cd372b85b5a045208d5d60299d026492f7cc4cac1ce06efd1b62dd9efb2885e08ed6878d8c1cbb349bdf70faea6802a6881cd3055429ad4f87fcd243471f5e99dbe83de7ae89be5abc04831fbcbbe22e69b0767dba39bb0d1570f4e4e853d4e1c3afd9e3ed308872e7c542b798d87879fe966f530bd4b9c7aeed26c66d872b2f78f4328b2fc970482b2141ae5714de6f3aff7ae22a41313de47ec47eb0e9258c18c6c995b0046c8bce161aca17276910bfd6981c0e9786bf328c52431c814553bf79538030b3f060c0a5b2bb70fdcff4a21f92595738438e68578cc6e7009a867b449d18ddb4a3d4acfa64a8443d06d017b85c50dc8285339b1c2a9051dd909d32e2a0c745ccee82bfedf69dd75bf31c41813a0f89241ed51b80a479cbbbf5c8ad126fb2f6e37d55d5627cefba4c8c1b6f869de0432fb3339569dc132fda891fc333e4e428241ed78c595d43811a3f5f6c6567eff9d0500d317030b74e74cfc81a5248855325a62b8a1c91f33a293ef1187c876f4015e77f75329880fa67bbc53e35d7bb9f5728cae8993d7bf44b87849fd71e8a7db64931f09bc16b9e35bb778f897290b06bca84fac42dc1ddd81d6d8423b307dc3a54e063625266dc8f1425c7a4f22e685f628628f59a9fd6baa6966f68588e91141a07f1cb1d1d9571bc40762d5f7648405a4d93ce7eb8fbe450841695b9dfb712fc676df1f6abb3dc3b76b243cdc0e9591cd6aabce714d3e9491c9fe87155fb7d3e8f8f31f222eb0b9904bb35f142e2f3028d5d2e244d383cfc4ec59c8a1aeb184e87c60829f51c6c88dea4a938b61f8c8a6353eb19928979c61733a991f6b765eb4d2dd4e64728a3451e3beffe61faf0f5988aac47d98ca94d52b631e64e1494d9208edad21060af5037905e23845289fcef7998149ac9e2f732243568d856198a342c89e541c31ead3fc16f7902fa73e8673de0440957e234e49a6e650bcd3403dcb6abd666485c8e7f892f28f5aa61140cf9c5b0161bce83d08de256ca8348e5bdec283d224a2f9f93775f4d26531fb8e2db360b0999d1a02b24c323e08dac58b415351a308bedfaa8574aec9f0ef13599423036e7033420b72a109f36ea9b932244cce877b02df9346313719f972ecb56086bc4750de8d1fb5f528b55b12e24e39608f29ab39d19e2f12e60bce3f7eab37346caa031fe3b6f06d426480cefdb341ce55667200b0148df25150732984337b724cd6a6784810fdc3615027b77f4cd68b6004ae65364d8c00feecd655e5b8d7457a888c241d7fb8380b3e7b7594317547ef00749726a47ff7165a9702908ef6a91e6685388ba6def263e9c0e58e9a78cf000e0a57bdb62b3f65c0d454bb3ac8fd8aebfe1fb3d8b1596e4c50d133e4a04d6146a5f7b6cad6b7f47a8d08147c8dece98ce902f4b740496d6cac8da7f7d2beae21f483c565a06d6c4e83319c537e8e7ff5512afbe29247435e915afed03352324f0ad30e3a45d01b36cb5a9deb0e5ee1f9d4259e6efa5b902925d90a69343d1b79b42386b78e6fe1dbb3b4aa7aa5ca20937635a87f73814a4642d781e5ecfdf4a437e96cf79d6d66f84e771928103302375e6a97475529b410dc63d6603468f3883e313b03619e6428ae393e2130db684b9cf6629bd6f22fa0321901a1dc5804f8907c97ab2aeb139b27b5ee296db8f1f84fbb7dde98ce32970ed75415736f3437b111453763c55ef76465fcc876527bf084242a7d5c83ecfa403971f63c1159f863e57adbbc50896deeddb3e2b05e28735b112c541896596b948c510004e94ab6a1ea88a09e1d8edd37e0f85f1c51031ab6537a395df6ae7d335f6d8bbb49ce9738a1684709aab86895137d3cab194f151ba61c9efec77d49fff510bc66428ca5d88fedc3484a323b16381e3d8ba3eb6717227fb1936f2d980a0f2620d601fccb20d22a2c99ed57bceae2b6ae1811eedc3cac49438995f538940001c723c4c5bc7d9acaf64103d085be608553768c15d1473b2cce6bf0239f7f4ac4c6ad6e50c0e0c9fd3cfa4584776c9561f75fb21bb4d9d9619f0e61738aaacc7a77234853402a6534ee876b7df8b4b42a5cb9dbf9911f948a1c7762b3e82a69524bd569ba044bb822ed3e985184649cf2c8b62cb7892b416431f71bd2b838981e65a0e3dad25756165f655081941407af5a724eddb6557647a876cffe1a14a94bbe5e59b149cd44cd89a343ffcd96b6d3a659594afa2f375d8cb1db6888307446d83ba3b5d2e4cde8a1c19b9905f0bfd99ef70ec3fd5d8432a33b0e469dbac334962c60108ff8206195154a1cc3ff30ed5e3fb6c5f413efe30836b2de7e906567b62c1973ae2f65c5260f31b275645e57aa015b85e89cb465bc61510d72102fcbeb40ebbd556a5bcf953dfdcb6309659dc8831517367c193112b9f97de0cf61a70dca7b7090a1b0a322facefd1b099a5523a833da98dbfdfa7604f1a9dbb755f3dd112ba1d6a6b334be277a782e42fdb9e3f3cf1e037f3b99b48f9337bf0ad1f1718d8a99dfdeb2090a1a7531fdd5aedb090ff64dc73044279b06ccba3f90f0bee895f8034b29ec80f2b8999cd14092eac7385144c5ab5f49d337e5e946c1cf9bb9cbb8ee50862e8b76477df32da531a68cf5200fd65d352e723d3030701b68c82c7ebef0abfcf054d045ed15c3e533dd80b20389b70c4da9f03f8d031a5d08f886c84fe9517440b5b49a220aa0154efbee293a525760fcb2f8c99bf5e22eb3af1e3dd11c0601f92bbd10ed43ac47f776f55fc305f26f7b7f93be0478fc9545a421a7bd8f84a09af8f5ac6875146c3362dc3a61421cf360176e53951dcac1da9edecdcbf800c0ddb0ec4d569543777a5d2bbf70327643643ce61ba0fe7f7c3bf46445552cd2c8414f78654e702f45f017ea8465a8081dc53fa7cea8f978a5cc62fcbfe630d96171f8c491b732a30dd59f1edcc3e03e3c4e1c091b557d6aa0504d1ea914715ac24d58c2c39f91dc865ff177a66aa186fa9a9adba94aa6799082882de2980304f9937bbddbcd74a0f1986106119655cfa4e30511cdd46017c70505e03f6df48c161bf2c71df08a7aed390098b2fc1f5f57b609e670ea60caefcf6bf72f4c3796665d0df43daa4ff6499310e6f84c6e3594bb46ff7a71498e138c3c374b93bf459862643d9a472d7dde98f5cc6887be7c568adc52daaf23536a1c701934c1bb80b243e25e262cbcfbac25e79fed196bec638f15e37e50deca88d61635c768d9a69003a3b04d4b5ecee626d6943c38d9783e2f4e5873725c0e4013fbd1943fce64772bfe63fa6063a7653da93eccb092184a86ad8925393a415b3facbb220cda21117e11bd2e2c1f6efd5ba36e4d7b2f1c4e9d4fb31bf1ebb4f12adda39279b49f3a21959c83a4f7a80716c7fa7eecff6dae61d61de76a155615d82b6e5719496cb1a2175efbc061e5bc959405d8608aaf85d2886e33de55c1e79423e070c607ca35df08b8d0a9b370d56aa69797e44e53bc7d179e46bede69e61d4a03355707b827fc4ddf78483b2590a8ad8b6b0bb674df83fd986eb13660df85f4936c499b3ba6f035c90a4cac9afbb90c1aa470b6d2faae4291305d2219960ec673eacd0b96d3adfdbff45b25904fbfc873a1bea24b4cae04fd3eac191955cf990c4b4b8bf96b5dfe2ce887fbcadb7ce7f1f9b7cf60d145097b8aaf429891e5872d12d0033da5301c9f15dd8c7e8af1e13ed3e0b52693d56aefb9cf7cbf35526d3c679ca223d4c601cd9a388725f2c180415fb44cc80a381d9e6ad111e828934e1aef9cb055f269a0d8b517947fa554de2e18729847e82c9f46778d34d257c669cbad37dd9a63336738bc661aad3021e2775be9f26188e4281752ab5bf89187cadff4ac1498e5aa26bf85c65c9d4b10beb4918666b0fe9ca31f925c488e0317c8f1b135d6989af98be56706d3553abb1e4af776ec2f69af2c4bee569798c34284b8e8b220af92787378b4c8375ba61787ef9891f9fa921324d26adfb9d55acc3facec4c87830517f3cb6b44fac59d84c3994e501fddaef6d51b171b8f64a33ea4e944f1d9755c43c541ebab3c05e48a211473a636fb82cee787c29738539b694e586fc10a3326653bdbd69abdf25ced0f8fe71f009bdd40a0cd07df712373129e0fbe5b8873ddc3ca0493dc1106c56946a8279c88b9feea96b2cbc30d29faf6a9d4fb6e79e52499f89f8d99fa42f985254ab571518572851c0b370d32a35a073aaf36121d00f8e7ec9530f0b1cc9a5a1a635c35a2b0fd937946326c92d1a99a042b574f74a88a1e5771fe06cb1114cf01a3200cbe8c71201f32f9209a0d767d8c02a4cc40d3926111784735b4d8ffd5b9dbe5c082517efa505f9da184bb994e6479eb234fbc9d0cb09ce8ce708522fe922867d21df2f706979d80abe97945bf3d3c06316f25bdff47158fb342867d9cf9b8c99d55afe129fcc008e676ad096b012994dabc333183e4a756c6893022f15dc0cf3fb16062675e4829682d6d7c6479aa238fce09491ed16e111426dcc9acbe747a4678d455726b28972c25bbe01ff8cff9b1166ea574416b7100d130fea34e3e0b6db50702aab115f32f363662948070525fe6e3610db5fd7511a28d22f3901ab4198ed34188275bd9b7d7bd211613d517d0802350a2a45e0b783571d711cfe663bef93fa55d8a8901e72d0a6b6723d52036adc16ffbf36c6dd7f07a6b1ad238c09de1ab6efcc513aff0d8e881bce712489d4c2ff19385e36474717d16a990e66fdcd83a861b89844456758944a1a031418708b7c354503adb019e8bf8f652e0aa3a279b70c6486586d01961535359fd8805cbfd855f368ccc2145d3476e142500b8a6122d9efb0f156e831e9ecad81d718cc7515b01e0223e6113081f559fcc032a0f3d2042a397c8ca2398d94975999148f222dc8c051291ea79b3a94dd892b76a797345ddbba4ff164cbac9bf1a02d66b85efb1ffb3139e6efd799bd9c15595f98d6cf71fcc7b472391720e238f9f1cc86feefc0d9e62bca4340a661c1e5bcc7f5b28d1c5a0a2942f4c5e798bb133ad5e8bf2cbd464626e46dd0664a00a5b4a7c3d7a72dfdc453b2f91fc794dab46cb0bfda38dd235788d49ed42fab901d89fc36f23b6df3f1ec21f42db99a7c1a311185c01a51705380d807ca65fa7d672051dd85245716e199ea73c3be5fd517a5a1decd3cdd9aefd9cf954b74fa9b7b9f79de79e4433642c34eb14a34be39ff47604038ef2e1f4d4dc6081f6cf765bf5dba96d48c60780f06834efb0d683df2e4a251a32916038ebf750e53c7f328c81ad1f7a62fa4c29a0c9e1cbd493ab1d8f56172773b496a3a43e8865e2c7084929f2106be95271865d2bb0daea64fd5352239f7913e77563fb09e1268ff95590ffe44ba0139be90279ecc7666a64f0bfc5791a18cfda1ebcb23bedea2cf5921e683dc848ace87baca0ca223a469c401ef2515ec159943e7846c933a2e1096b877cac146631d1c7a45f0fe6204af2b972f9423e7cb70f34825beab327afe1854b9ba1764ac5daf5145f6217ef02e712360d1397a95fe74b9787fc0c71b382ed4e151ca47d50fc9268371909b1a15024a729731f81e745ba8b83eb228c67c29fb8c6a073d0ed58391c0eed886d548efd2cbf6086a4f856a024fbe736568781b2d89f4505a9c94407477c72f229e2bbc8bf788f55617b2dfeb85068dc40b9ef9110dd43dcf9e15a10b9eb4daa13e92f073597bd4af22cf021efbc4bc832bbd686897fa38da9a9115f44b4960683cc43876ba3c36563d37e8f2490ac7aa03c8f2e41f3082c0e44a1deba1923aedd3a782238203478582c84f75c3e57f9ab82379de65b2daffd4042f37987d875674453479fdf5e2cf04f971f35e24afbe23ca7f3555b1e53ac4364d003d4803d88d967421142d142a1592d22865567b5b3cd8cf72dae588b034c5803b0469ff6f930fd0e5025ba68e75997adeee44691c5c4492354d4ee1af1f114f71c39e63ae3790daa02279fdcd06128044a08e56cc8f28cb46992eb47c9a9e951890f56d8808d2a4daacf7bf004ef417351ebbaab5c02cb27fbe3fc408bd1a9a423624a7e38d4f96e0d8ded2c33526956a66bb6ae1c6abfa9111d056db56d588206ddead928881054c01836bc5da47ea7123ffdd7d7d90a9af99604f1892eac386e7b68e2444e44405d92319c3e79dc2dc1aecb2fb4b023065cb4e987ac5af583b9eebd42068fa68f96404a92f206ad7c303ac370240edc6ad186e4ee9d52d94a3cd138ff38b6afb6ad0587140d7826d5de5065c24b46a2175a4013cc42c93342ea1d02a500b26da966d323f903afaecc5765aeaa0473bdd063c6431caa90086d44f1fe6448607f062e8d1c92895fb84da248dcadb69e22448c7f332cb31f0389961ccde530fa98ae89ddc57d3f17a0decfb6bddbd965d334f3f51aa07fef69a406c9ddb4d50d9f6f33b634082776e1218371c59ec4ce607c44dfd6abf2dc5b4e547fca39a2008fb190ac5d4f38d628de50dde26f8c291df35e5ac98d49b8eda1b44b7374340dd0ba0ee5ff198848cda71a6a39b18f180fab76a3da9a48f4583875096f1bd51037b6ca49b2f44c8a19e5daed311a704a08562da8e2bb5bee43553621fb0aa48b81460de8a10b01a58d4c7c6d3c4b983f94d594b75629b524cd25d25265ea1b89e2d54a8048f95fbe1d08a7efbfe88cee7150a99c8371dc9c0c1925e040ef378eef525d0adb251359d9536e2f1e45a104ce64048dbd58d4eca4f756f27576d396c7a29a73d603d5cf591183f16832002dc6f63810a2c977874f03393fbc2d758bf1bd5fcba981de8ab30e462923496e7cbcdd192dd4424c7c2ae2caacd3f1376f0900c5d411f3b1cfac944ef9f434be4118c7fdc1283673c4b0e1f4a78f0825b310bf9df44feaae10e38318bbc405e1e12136158e3a3e7e00443bfafd9035fe264f45c4ba2338d0dab3b833809f2ebe1bd5c68029a2029a1575989f85d23e468d6b1a5fa8c60aeb653f18654a9697952cdbd0e9f85c9516acc4f4753cc1d115074ca249556a9a9190277ff9fcf5edf8ee08fdcf18a72154445dc9fe924a5c6b17474fe5ec6060f11e77d73d92b246c23a7178ad401b17b04d497384ffe043fb2e7421c9e6c5e2dcbd5d663e29cdf1a6b5d41d3f95fd198daf05396514b387b44bbd4a83003a9cdf2bfcaa62ce4439475ba43bbbf3866aedfdef9f1e9e17d71edb207f518934204fcea19ad73f70a3d346eff7f4615d1273a829bbabeff9b8ca1324eb217055544badcb8e8b446f0b691570c4c0607e980c509cb611d0db51cf5bfa74dc3649bee56943b1db393b1f81ca0500f2c83180810f1485a8da91ffa10d3b048521c1d747ac1893f273d07080525a399f4b4aea4e16d30fd92585f542771e8273616a9a8a8214c889fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
