<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"afbe7b7030946ea79e1d7b56909932a1f3d5de2857068746a3078cbb43de1c4c1fde75e1e124140a90f979c7ea7b2acf6ae97acdd809d11db454144ba17719c24dea644facf9237ea9fd181f373ac67b179d4a28ee0525e9a074905c78cdd92822e3ba68edf1849135a269edc18926351f65c35f04f3cd29ac3cccffe07b9b060d85ce008638fb6ec52e32947104358a3803da36e396d10198d223b58f86e9cef70eb76c7f0746aa439a7307c3eba20025daac0f9627b7a7fb06d65c639aaf89edeaaff8029a3976595cfad014735283907412bf9e7174dda7413d0621518f8282825fd6aeb99884c5434f395a50e065fc5707681ec6bce8297c150542a74f7d1fbf2f109acf52d017efe9cfe853e080b6352538ceedec2f3371c241cae5839fe6c51d75e6ab9dc52b993205d22732f689c4b254bec99bacc834917d30cefb472883044a3b9a1a0f5c7dad05f1957421b617bea25746ee9f0e33179d09dc730874b9f2b11487f74b7aaca22c2fbf28dd7e65699b7e25d306bf8d7e213bb5edec52cb43e83d47b30d7227b4b09a39d2a1f789fe8591c01d0bef0c06e2685e23035ed84356624ad6f2cfd226f4863b32a51f832711ebe48db8e3a8a575b98fac8a3c97bd48308d82c128788e09a2f3a5680a8798dacdc276ea27b3f047559791d8aa8f3979c75a696d247366c703701602cfed2250fc44769869bf38072eba59b5bc8f904f2c3dfdc36bc880545489b3e471c52ed4bb4d938da9f0c74e55fb78f28b8e279384005a384c55451b043e6336535a2bbadf9a09b869214e7a971f026c955a79348b1586b227840f28c8242582d023b2cd533c4538b0ef3e7d4d13f97867d1cf416afabe74c6d85b14f9eb2204b0a22112c6e74e01ba533cdfe49e3d6ce97980e5748786851202ff9357e3d5dbe3830bda4cabc5e2351634610b96be9959ee455b0f97c78b74e571eac67b5efdd548e28ed090822cdb008811719f8a1a4912b9c87e89e4dee3d715550b5e51cdf5514c206534c8093cabd3884977ad19af09b2c210aae2f1def1624e83bb3aae5dac80280843e8cd571fd452b7d12e9fdf8a83b5c54e312b2015a1b4671d3e13c9549381f5851bc25805874737043bee1e0d58233c2aea785bd86ed9a653c396b700f041597b7b7c8ceacd23bcde420201ee5e604b89ecd935ef2077aa1497534887ff673b076cef69122f61d6db050a5a9952dcc33c4b9d93b860235f544a2d27bac83b17e453de7b91e7865c929fbf04defc4b7a1d73a2f3d476db8334b31a80b5f85b5a1429474a6af656b4f04d19f28481c973462d47ba613bbb2d90dd40ec754d5b76f31148e07018d768940c4b5a6737dac3b9eab52350af7d7348c9b24019a5772c63544a802686621cf40c115174c9c4d34c7b3d550ce5063f11036c6ba4ddeb6e400f83617d0decc012e6761a3659e3a03899682678d628b654098c6f0de1129f20bead0675a400766c80dcaa8e0921b5f5d0cd0eaa842c2d26d715c3e7f8bcade93925d74455b12a6da92f7b78e0598d322c3522aa8191befcc95737a9c59a97374f7dba2746f377ad8c7a8965fa3de3af14ab848c9df757a4241d0aaf4f9cf7b0ecae217910cc07ad8de169a4a08cc3e05798bbd2fd7896fcf6a5e194e5305a8132b16753dd42ff201470fc92a898424fd40594e9ab06dd30363d4132b140d2c274a56af24c4f37512144c82f41d2007fa186ddcb137b63dd309c52e9da440edd3b065d5b95f556d9b8f79803bd663e1a36f663537428e1706159bd470da20f51c390363332c2be19b8793f07e8a7af06b2e85167bbe07831d6fea97edd36b8b613a0b9b72f7616b5bc3bfb856b3a76b4f703444522bc297121cb88f9458538cab2b46af326ce4edd3b278af33dcf0802986c23c75723ddf3825f8e97949fe03ddebbe929faa203f2f503af087d812353be654b950fd086ca904cda6f4124d8142a73e27d93eef3fe012f4a2b3353fec6ea594085fa39597cf4142e1469bbc6fc91700875a7f83de9a23eb33d0f3d6061db10528565ed9d58287c5e088f2ccc8b6b71f59c59fdb7b4efacae9b4448b86b4917c782c7b1155de21501f871f9067e7f1ab761a5712b8ce7226b02e8a0bc0755d0c57e439497f0d207ec11ca83a57da000204961b7da376f1d5e2e8db0fd4e5fb41415b84fed7ff9078dbf25293431b7bb0401e9950cd7ae154a87ba1b8a584ce297487621b5f4a0083679ac7456cb9834d3f0c3ccdcce772507dffb581bf71b248d361b180fabb26697fd6753019cb527cb9dd0b7955d95128b72a570c75307e749dc6039effca312144ff2e75f301c82d85c79d4e6f1e9650a83f1bd45a25f457aea04d8432fe1707ed02eb70380ad4c515df1a8dfffb1354d4109fd06d9f645a76f0179588e25777266726be6ffaa0b4f98282eee274c9a1aef849d9ddf9d61fcb7897c256d026d6e825dffedd22142f94e84d5166ed004d31db624bb6d4773ec5c4e97f5aafa6f3188e11defe7663172c67372580af672a56ea822bc7af842dcd47f6c569e3d03b5dfaf65dd116e80a6a81d67c0645720bc29ee86e030a2e96a6cf30df9a2bcb80ecd1c2b31d44cd69c22b0d77b25e4f59cf95c52595dcdaa2ea5c1d96164ba9e958bdf6e88336793d1ea9909b17406a97fa8a3ae30fee7ab59751ebaca5cd9d3e65b0a4afedba8d251428cb48d6d0694a1a202d9ca581b0a6f918cea83f82cfa882af19a28dd9c064753f32dbd07e438f4f78733b0508d656b67620eccdbbac98de3b6cf19c08bf51ec538fac692403b62098dc2cf4ac29db890548d60fc626bd8a5b3926b64efb86ca849d1eec1b9bcd229c53250f744cf2a32fc184f83f354b1edf0086291f06e835d0f4b6aec3e2f307d7303b6aa2b063518aea4ce9c52550489d695b8bd777c9c090eaf13a592cc577272030d2dfc0b4d3a435776bfe25681f47d7854359c0aa9bdfa4a13ecfd419cb52dd5f08179320ff276b8198aa6334b9259a6f027cd8e1cc1a56412521b166280749379fadc6d24d98e3bc6d69354d84258b403f33dfc4f6ba4a1da738fe94f374cf944dd3c0f6eff3552e7a779935700b4b7f248de8c19bcafe2912506ab6ff91052b7fe8732e206b657f171a9d1fcff58eae12fc412f768dd570303bacac667a975c288c234fa38f5f01db75fb38cece473a531fd9f4560754f89788ba4fde615f81a2db8b2c1f327266336e82c95872e999ace1dde2bb7f429524587e7add7100e2afac2dc35e67807be5c8539103333804f174a536c4891a471ba0fe3945b98ba338813b9b2493cc21be14485b29b7959e7644f4fa82c16e56d166922942c2d50a7a3da0919114fe69b3ebd9290bf37fcb4709e587c7532b21de5d096927dcc303e142ff44be6731572ee2438212ca4bcb5ccd04d8d7bd37d14372317b8fcd21d595f276823ffeca081038a8ce93ce17277e599a12de47e2070d485cc21fc8b6d594e981d4f4050137924451e9d13f3bf11e7d5b5d36709d5cd2db641ff7dbf33e0d1cc05b7324a06bad64f0b1575ce1da5a8802cbaeea6853a6c71cd0c6b28b23bcd8ca5ace9cd2da053447bbae888318791b509afb81bfa0e1e8766aac8478d956d043bb84ce7d138cc46a4f719c15c9fa1dbbfcceb1f4e4ba11217e206547f489112040a6a1ee4c67d0f13112df193a3f815d1b034498425bc35b5c2966d0d4286011d6d2b3f136430c15f5376fada1c578193c686d5dcba64bfc572d6b3a005ddae8775f1de555d986b8ba1ed4ff967e0319d31e7259b1f99fce8e271e73340ec7f8ee017f390aefc79cf6f60e7332a3b7ad17fba2d23a3ffa47abcabc2ff4cd696c3e42bddbfc433e484693db7e6e1bcdd8e10ef17f4fb3c47e917b05ba5606d71ee61a92dd66965bed4a70c8ee581880b8ea92ca3737c0fa6acb4e25a89fff30771ad2067fa9d2fcd2d59b1a2c67072726d1c7b9eedddd1f7bbb44674dcc7478d694d370855ddbf21de0a9daf0cb0d2a597326ccaa9dc408c6598e729c77a7eb903f686f4d9ee630d27eeff77699323e46ca31c605370dcaed03f1742503abb637c4e06fd6499dd47f92ce4c569bc62213168f32904dd7928616204e4a8a23879b44c0a3835eec245f0b2e5a59735cb80f5181d22f0cc8c321b2ede5347a15a8a204cdfe07320603d294507cb387967bf400a4a08d547cf368de97785eb763f1ebce11c0c0efadf638c7e1e89640d9280c67f5f5ec155846b42521e2a72c9955dd8162950a214d2616b3df84f0ae9965869c689194eed1b31aa7266064628115cc84207c08f2d01215b0c0fdf1955a669182bbf6bfa8083afebfb7cfac7cf10dcbf11f92cb00505e7c0175bd253eab2c697f566b20c488175ab927fd27e0304b48e5a03cc5ab77efe1763179e347b1b03e00649e751368c3493e237b5f4d5895517ebf90f60a66a1c661192536a30f91b4356df6c48450b620055a4eec88a41171c4260cc357949592e6c1b70cbef771aed6d1701bd98c55839a2cb3fe15a06d4bf408e1ea0039b689f576802d9e256732ab852c7561183501cd9d07b4e3c4632f7a7df3da7d678c16efa0eb7491791b8f49d5479653ab19f086428006a04b7636b487d410bb47d9c2a07fad2c1dd237267a5c1a167664893198bb51d4ab92d0cdf02378cd27b4bc722b0ef088e9e2eeb173dfab2d21e8d933011bfea228f2ca900ccedc49751b7517befb35d2de059057947513a3f146c87eb0539f4989dd83d891da4452fb6b04c967a2863e2427c685d3680b4388c5d7f62782be1fc9251f464940a46e4a8a313a598b12e81974adf650354a8b46a62da1aef52f0b8e57447935b120aa3a442d69320d355e382ca8c6f8691c50a45089875305815086853d61c0e17dfe19cc96497d27784eab3df8df415d8ee06e2a0394b08a772dd75e37f39ef636aff4b0cf543bdf33982732859ab64691518882fbad0c2afa154fedf327cb2b8386e566a556113ea50fd7b32de255b9d007107c43eadc63abfbda64d36f4868676854487889c335fc48ebac05b6ff965255e006aa38def66cc6de5bb1e1ccdde43d907774c35f3c4c8ed4b2827416c7fb481bd15f79f063c89881ac117a71bea050f1f22435421a48da0ddf18ea116ffbc349e4917852238807d7b100e37eb1150cd00f56796d763b4578f05e52acade19aa7841bf16d738a8844a5c41743f5f4ef5bf736a3ac078aaa32e09a37a71491e149b7b1afbc26bf8d5676cf347d171ffae754c8a45b6e6b34e9c4353fad40f9816cfbd5ef6b3b524263568d91d14482c920acdd9f21585d992d74cf647049239984458271a7b0f76041a01af8baf7e9f43f8e075de9e2aac67908614833c30e47129a539f65f3d23ff7746d8e2ae54ede0e7d05ac278badc3b3c499a02e94b11584171fd54c1de6e013152f9fcd105a0d36a24e12cf39a7a59afa6bb4ec0d18a35c97982cb2f311d2f465509db978a7ec9e9d5c130a7def2cbee72e6930c85c46428f96a2135f3ac3b5be4214ac75d4152512c53c200b75ef589cc71661f3808ae157547bd16c6690f1977b5a035f3548004c67dfeb13ac1a51b1391e13c5b1e302a127faeb4b0198fc5e2db4aefa7fd99af0096c28d2fea98966b4f84d402f5f70abb6c6b5ec5abdeb2f09eda153670d7b420ab4a305eccb9dc8bcfaa73962fdde8abb99880c4d6f9cd69034fe2a100ec40ea4aaf160faa0eb52b5f44e1a4b825da35a07b951f9e6e310bd30d7a7b575b2e2e73c6e72c1f7a143bc3e1dd5677969ba485efa4062bb1a8c641b495ba6928ab56560678c1d6969a1cd8a5925736be17fb6c1d3db5efaba83d6f93a4ff988c532110686461a708a8704e76a04700e56213e4d2739c18d5aac9e4c6764ef198411801158c1f3bb08294d90f7666d9df7e58ee296febfb9560ffa68fa3ef70509e2cc4aaf26edc7ed132f1a1aa85f5d2ab8416a16775fa864b3c8c4e3ad9e2f929fc274cfa324aabfff420a2f775e9531961f8ec6612edcbdc3d52b9a4b0f02eec8d0e1f2c4f3c1dd564df1f99505232b9ec892a7fea26b995101d3f76e71686394c43b7567f272688c543ff46c3434ddd80df900f6ba6a2b5d8e829fdd19d609c2c4bed0b4f13169cf619109f32109ae7fb23e115cb3d5dc74ecf15e04652d650ef7b90fb1cd03df272700515b6c9a793ae1e8eb7e6914e1cfad007ff312d693068fa3d0449d396aab1e2efafbb2660af91fdd7f3a01b10c99f8808fdfed20efc741c7591a7c5731ff8b7aa0a1f6c10a86d306d72767073d4135956497814dea5c96545487b16ced1aeb75022a81efae80ff38a1237af0511957e9214bd5aa7cc363ca6453cd4deb772844b86c7c41a2194349513343113372fcfaeaa9d8163f38377ace04f6096da44e4f991d60fed092f5c02ac7a20e931d53e0d019b15c6024b2058075f298e0a61621d5fb68e1a8eb442fb2f8778cb6014905df465b6a684ebc8b3e3384c9bd7c78de442313d95891dc69d1218cf2b956b19084d27f99fc9e563f700960694fc2739e3f1bb013f676b2657c7be9fd5aead571f03df976695129ac83023c62d390c5d0ad75454b3921cb65d2b3cea545720e43927993b695a572c75edd1e27c7f919fa6f1d8989d3adcb2a0afa15f52c0a10c34cc12110b3fbf40875d3dcbeff77de78e711317eff869443aa8acafbd2c64513be63527b71f52239bcb53904582ce7fbeaa7b5ccbc4302abc2083f6c8329f248daefed50a90c99e87de0bf39bdf2bd6a3ff5ddb164324a1de4403562f2e80e6a7013572ef2990263c05d54a01d4cd0f9e8dbabea7f3a2dd50066cc27e329bf2091edda84bf17481e57b21273f64b2c89baf26d3a39d323f3e937adc859ba0901f6c3dfd6ad58007600fc6b309903ff037f70854b998a6540e389fab4b8f7bd5b963ee1c38d353628c1d1ecdcd265b5598c1421c92c1216ca5695c7b2e666c698290c89d0948b1f1cfec17627fbecc158dd127dc768f2beac29a03447de093343e96fffcc1afe7e4628c3f54c21924ea2be28a6fddadab64708f2db9bb806a168ffbf17617cbc5957537d590d72c6373a9bdac931c064a877e8295d87d5de146083af765ca0ad111692919308aa47e82d6fc2abaffe04b414916ec25a3dd6722e00674f000cede171e26ca41012cf275fee30d7d6995567d0808453e81dd48617bce739dd3b2161b2b8f84b724438e7cb09f3e8bfca9daea83c693ecc6ea084ac01b134bb49680a1cf7ff85e05601ff64b3f298ffd8ff256bd885516b3edae913f637bc3a8bc249eaf29e4b5af5ab336e765444bcb64e7bff7a94ab4ac69dc5c9e47b9e0e79c24ad886ffe156e1e39488c038c8c8d20f48c5e24758cca11e324ee932ee51ffbb0611531be3f838134245c1c97fc16d4d96c508fd35ba1abe4b832ce5ad110057d3d35a1fe76b0eb338e602aa4ecd45f9b7e8a7e2dd6afbe39a1a9880223bba9ae9592280c70718cf244d02d5b09fdcaf930b291df57aa3dac4792ff294177ff1534aa114598355349566f7f0e90013a8305c36fb609832b6bf13e68adf0129155d15bcdc65794bc4c38e844739ef7f5941adfa19805465f230e0853aae38e859f2b88965ec2f452dbb90af73931d4debabe1620fe6b750311c11ced76f56022a18336e1afd693e8ca3c5b65012597d78870e0d588efbb5a8c09d84e2b86a07692fcc84d66e8dc2f3d671809e88d3b5c7855707434976b0e2a65a275d54636a54ebd868f4abc28f4a0d0dc37c121a5e392bc28f7d2ee1828d054a8f3c3ff3e8b9ca0753e4c306bdde092289b587da5757c243b5953d0747512d5e7681e4561e5bd99acc0058b604c93320eaf887f8dbae302ce7bf695b05a9dec67b759804457cf1b5a87a663461bf3e635b28b8fd4640730ddcba7ab6cb6a1b16c6a9b084f0f818e09ba37316621fdd900628af3d9acec1e6c38bed28202c53abd57dd3810e57b4a78506cd927bf16822195bdff4c1aa2f984fd97ffba2a8d51ab0fc026217fa94fed7bcdcb4879f31b58f84a23a5670e8c31f6a9bd9e7b18a71d622f88fd211c7b644e90938adfc927c671eb94e0472c83e48e6c862e2122f8886a67c95c675bd1631e4528ae45dc032dedfd644d49c6fe6922e9ea53bbd7d3816edb682e39ab9b4a5425b9193b2244c6546c762a24f744599e50728b2621d9a2db518c5dd6d823913f65fc6b72f45dad752724254e35c6bf212eb8702de64a3fe0acc5105b5b8dcea628abb86af6293d1f125fac84439a6fdb22fb69817618ea1e757322e3a134fc056a96e7887bad42611046cf2d6793e7f34782598a486b5733d71766c25449feb5bce07e47f9f163ae945497005ef4801da20e3668827d028361a95545d2390afd40ada014cbb33653dbe3f671c66c045aba809baace23ef71ba62e5d8ea3f05b587b04d9813c8d1c09c9748d7e1cb108a609bbd79ad90aafc122bd63490572a7ec5c92602c08a447678f02a38f95ab8c8449cffea217ee632c5910d71b62881f64dbaefaacbed864453b24fd177c8b07c9328d32b05098e43fe507cc624614e397082f81471258244e118dfd707ed266e334a331bde7d2202eefad705e387412e3fd0f14dcff603ef481cb054300cee6aabfeaa2081563c2e838e73017745ea6d01bb25dbe38056d60840c21d4bbba67468a6494bb619fcf7129db170450b52c93145789be867f17facd4354777a1c6cefe5dad26b6373fe967b3b785b3c698b5b05f1b8b7ae7c18ba7f29e19b6f040960c671bc008a435cc4cf75e710627d3a915d25cc74b922bb1115195aeb6773e558870c97ab5c04c8a6f6bcad67eb8ea849e9caea464712787e5df6531c3ace40e181144d994c46fa5b959ba430d65d1b9a29e972f9c1b48c7ef07054241fe1d9562912ceb147023f32790cfbb9241701be302e9c4ef463abd09faf8553083fe3171d5d0f682558bc3dd4d7711b6babacaffb035b41b2f0ab5076336b6ebd050e383d0b5a5b2d0a878bff23e3e433788d70a32cd10a2a01b191e2991321735c77a5ae24740702892ce342357ccb56830930fc7193a8adc57d88534ca537f27f4d8eaf30313b938a60ab19356d4edaef59ad888ce6a185cf1c5477d035353d9fa68cd8b9784a947d390f5e43fd0447aea45791aee1167df6f0d361669ce705ad7af4319b3eaa9fec0b503a9232b7b8e1f68eb6a4121c7c06e1a2dcb3a883bb6ac2b5c5d71274a9f1ddeda301a88bc9e3d812cfcfa3f265e59d457fda495d4d131f067afd63c8964ef5093023565bb750ffa5b6c7615e2f010478603df1c7ab5ceaf312bc36bafa51b649d432d84b817c5f4720b49c3b5d4098ad65392baa7aef1adde2afc0e6644141d8db7c0e5be7b16c98d00c2931a57c2760e8f6e0be3fcd5fe4d6114f0f35906a578c556403a735e0fe8334afcb8a7b479e0c98d1e17c39ec68e5e3fac6d78d86621ac55ea41b44d9166bcd5282fb3fdc2384ca10e6324d3421bccc1c5c1d2ae3b5f8aad69bff3dc7184337439e3bc9e19a3e862b7035d914f946216adc68c303d7cfefbfbdb16501022437a19dc1e681f5c2f2bfeb70507c2b4b62a035f801d6cc95ef5e6104c01a687d3d5d7026b7165d8bbbaad3ad60adb071507764e77b951882bb120298b329da31c9874b5d19bfedde1ada2c68cca9204f8c20806d1b9d6387599698702f661e087fb584cee9119fbcb0bed8572b4469d8442a1d45620afad97e23f0934ea74d2bc1d67ca4da46450972fc2d57f575459e1b8b25233d0353f805a3e4526840172b218a257f0b5a91786746c6a8e3bb2cf6cae94201675ad0dcbcbdf6fca4e036d29816305237c211643b3603597cf98957b3e25ea6d1809d3bf22a1c0101e3483f723f67c03e6f18aa6eda3e7760d6811d50237522966968c1f16c1df4e4ed9605418f1d98e9d3948f115d4dc62b1c9b8af789a7c2a6580f04088dd354c4b2e8752954a5d734226ae69136bd91cae8cd7f618d62e4ca57eb0543eb304392d6c8342e36be4bd7bbf3f8e6c6c08f182cecadd5b11591fa29ea44466d0ed9d58e9b8512632c4818b9c680fa05be25930583433f2e965e206246e996814905ff816f6cce2a07d2f7bebc85bd59b63b119aa946db24996156e3ca398161db1b9036148a0cba771ede087cfd781f260ab42319ca94e3d9b41c69b2a4e5b82dd8ec1eb7d202eeda1975d37ebb582caf4f15fe50cf87890a672cd7688e4e0c03270d0184b60069d83ac8df85cecbf8bd48f69b4229abf6c2ddc3cb8b9eedd5d8cc3c6f0b9755fc05c5f12cd1436323da263444cebb427a706bb0465d186a237748bbb4416ec00449b756433dd1b10872e8b1f91ee6257b9841a92fded6414d281846a7e9348cbd1e1c917c9a0500c323b7eb31719fe274e97d8d36250b2176468949eb96c5de15160bac8916d7892f90276fc2edbf06f1e7edb1b7c7f67f5540fcdcdd09c20564845bf3d34444e9c48cf70e653ee0314cc13a2117a6b8c52b681f1c540a732b1fd44410a44ad7090d53a0b57984e16626c86350a4dfc74be32a17777c2dbb47c5eebd0ef7ec8483409bf01fa2595ae685852561f8969612ec7877b142392c2c3dd47ff01771db7c852052c74a9114b2af69cc2f86f9618119e08af4d7f88f6f0404b489e032c9da0acaa4941f139fb4b7e9b23ba7e26252fc6898ba87ea1a0be4a86470a574525aaa8e665dafe6d6d1ec6bf6b86207b56c5d9242a652ff3ebf30b995fb6adec30ba7bb6d66746e8f37ff089749d11100cc8db0da179ad4f1f317c1f79bf4d03a0e6044b2f1251c5f6b186e0c1633437f53a991d4f2e320c3642b87c2a3129d5fad515fd48590d8e951c39b533fa8edde245ecc3201e56dde5b8eeac3d6d9e2cddaf744f22025fd41e88956a972a7db8b6cd619c71e5768fc1cccbaa1ec31b8710b76fec99835d6d60acf5377e9ba6ef5d3a7c494fcdc56ed61295d0f87efac381bcf64312b46df2684cfcbb430716cc6a887beb720de5b62859820ee783fc12a6efdca11b3f56f923c6d781e7ddb297bfe295d9d8bb474c2111dc6802ed4c5a8b2ce464ee2ef41237645848c185971f9a824df0cb12d7c85481f45d738e9dbb630493ee0eb0e7c7c447fd3a273a7662db90bfd10e3056cd44b7e39714fd238ddcaa791d5b0f16fec0adfb8c8feb7404ac946a81c0a3bf2080d25a9d1c92b7eca6807b85c6311680e8ae327118671c65bc8ae5771bcee4fd2c43a3e6e3e31af247c9bdda70727ec870226270a5efdd1f2358d0ccc59115d8e6dcda2b4eecb82e2941a492b1df707213913cef517ac913c53790d7bde057eb6de3da5a571ed77c736ef0621bd08592110a1d4bf81f36846017c6a4f3662a55ea4031d93c52e86121da3b5bfe0ef1519088d87face66e04723f9f87e01cddd7700811a92c264d803fb4badca02b5bac19633397fbbdb0f23fdfdc8ee84532ff393c5cf033ed246d54af32218c795a86721b5abd99075d3c35ad8325aeec7a142ea0ce2b12f70583da178848db4d70765183a041f490be9b3b62ced34e5545b3c6f22afadc8929f13092fbe5c1f15c90dc79e8fe7321ad991b58595ddbbc3b341428a9e09641cb8d1c57a2e16d324c5c8a6e06d6e3711c922e9145368d72cb924487b127c584a7589f636b905528788f5881bd96d6929dfcdda222193c4173f162e6bdebfe4b641a1aebe06cf6bf64c957a5dec91636d2128dd5996b3d908b3275e7886db9031f670777afe7516853c1c19c828d4dee3bf90129dcb7769142604d285e4104ca1979bf018f0bf2ab697267c254156c6a1b629b3851baab7a0430cd0932f85dc27a0999b0394b04e94fddbc362fab662ae53f4d3f9511d6cb99438b379d6f4d9bb2347cd51eb58a65d4ca34fa662482734728b3695226a8cd71c65ea9673dc40801c44176a0f1f4efe1b3f48b6c50879ec89be191537d49c5ff62dc5a6e55a74ddce6de574db589a21c5e976ea860fe710fa8d5d8c51d6e6e0d74d72679572fd45fd75d00c3ce2311cd987d996c90515a3b6e28355bbb8b60a8bacfddca469177d1f771e68341ead86bc7c3f0c06ac859c9135e22f4ae744e8b36df1a43585e0b6a41b5e9ae6f6e92b9e358bfaf12086ce7b01d910ae3684767376e8dd3667a2ef4f717168bf253df3b820df9fee759520f869229e3d06333adb96e02930f70b724bdadccb07d869dbbd553b159e25ceeef6b2f817099e42ca52a8c03049eb95a9d28d2a358be1ddd469231f1c822ead25fcc84ccbd7ce09a3ad4d94bcc7a46343faab163b36b44c563d5b04e5023c5f914cee120f6eae960ce831fe05b0fbb5a5665464be5ba2345e1c7a127cc01c2baa969c90c6ea23fcee01611c08e51f9b4d1e4d978ed5550fba1e9f9daa47a2a9265fdcfca4c9825b02452f2d6f182d2ff7e23754d0c4f32f916767e4d4200017d4dfb46d0bd92e6d98d7e9a1331380d2f4466094e2f190f693a882a44a57ae4b606f149e51800e6b689909a3a2e6882af8b06921d6785556a8de21eb1ec5052979e480cfd47720d446b17357b7ade8f11619ccc1762126911bbb7c5ddab481178aa937e0a4248293efa0bafc1e3dd516eb0a5cd0414ffd645afa6f7861b3eb6232052c4f58b368ac5327e641abffc5d8e755d16a2fc97cc2ec155d254751accaeef40ed3d6e5acb87f3a211d7abe5633566c44932aba88812e1f386a4878ab60b952d8b5aa5de19e84ae3f8f46755865ab2eb7b9fffac377adbabc3efd95a34348c702b5b0ac8eb46b615081d4b374812a61a5452e2768bd18bc61eaa9a4ef3c92bf790661c7b783ce9194c31bfc7300f19c35f09042cb68ec66f615f571fedbddb53c3aea36a6d5c20236afdb7f0443387627e7e2b480261b1153e580418430bf26380552dbb79f3fa13662a21587b9272bba85c582fdfbe7b7e8ea525284b56cbb7fa65640e7175873fa4606aa800c85e497efe740985ff7f21246ccc0657b9edfb28157af63b1b0d4d556315ad1b6a0f99dd27ed7dbc7f5aa228017a9fa9d32142fe03bbf118bb3d28df232c82dc812fdc61b2a84c9bb72e6981469366397dca5496c3b7ba332fb3780ab62668621aeb41fcf0326ef50ac1c77b4a69e649859c4aedb1b7f72307ab9e290a22d8eb827ac4b8a68fbaee98bc74422134fe3e2025f824216f5fdc1e07a79f6af9d336645ab754aae9a0cec3a4a9506476b32f61c3e703eca5691d9a8060d608a9ef1db31a53e9feaf9e6fb22b756d2ee853298df24fcf69676665bcef0fc940536b8e64e015c5df3b310d1947dd54f2eb7f8329c1ce37e5ed43a1a78bb6cb6074c79624d92ca86f3199ebbd3bf69808698c37da5ae259d8fbb6e9df9deb3287da60c680b83904a6cf61908d28fe61d3bbd4bebe7ffe1a234a2cce2fdf90ae287a070ea085be9361b364d578148e98d38bc340c618c2d429a41108427fdc9d113c110b46d12ad259fd304a19410b58f045988c35b5f5531e772060089f0c5f49393f7b1a797ac6298d788e567fcbc25517c98115cf8622842d08cc2815fc7630c99f2ea44c97ed513581d7fd3a4cd16a8ef28f657daa3767a24b041a5fe6589b7fa5f8fde554875d2dfa42628d3400394dd1e5e6a17308bdf50ca531520c7b6a103d2ca3455cdc7374f14ff71dbaffd970b253ba6267891fae92e42d03fef31459f8688e29eff3fb2ffb93eb457346547da0a9f98ec1e104b9f50e7a3871e52bbf3a6959308c1ec5a80201b117f488de13377d158421f32d0c314abefc354127e878b3dd48b0a8236ccb8f831b967c01ef27b84cddd8f20d4aef79d092691d73250efee75144dae29441f095cc7d8d3bc45edbe4a9376b7b5a0100517ebfbe8cd67f7d5517a831ea834c3050959a70e0893fb9ad9e0806786fb982f2cf3585201b0a03c695ffe06d4ac64cfe94bd1039770ab5cb3cc306eb8c2ca48ff8d3ce9fb3b551d34728f68f63e0d36cc894aa65f4b7a56f1ae4307089349145f58229f04eda9ac25684e5804a07cde69c61e88cb30d85f68303ce63a14982b22b2e9af55274ec93ef1f01aa6f5d62e30dbb71b5b01e44e5c904091423b64f56dcd4a5f1cf40780fe746055af43268228633b3e7b2bfe1b4f46548dc28d9b269372b28d480d2e7649bee6eaa3a0b5db73d0264e1fcbccdf7996d719e7e5f9f1c9024b5fd0f5d17eb58a4b71f984051546b9be815cb0b492f283ba9dbef8684e323f2e6ba17eff199cdbfd555a6226cbb8689f922f3de91b68e2144a52221682257d59cd580b0b9d3d1e9e69120ee171ebae3edc4767636cc3aff0010e97f16cfd412504967a459def96c272b1b7029a2c65a4ccb8d2430c7082be558e55437b6eafea2fde15dc2d856231f439a2c368b7b3679531dea856ea8f547dad5e740de93b07bed39f2d74dc056e75e2ae2c295636d81ec9d29336edfb00409f478769fb446a0842668da6a5872fa71914d5b28a3d666f3a1ffc199424b94593906fa5bd4ba28e1bc3a2e5455d1a026a987b93bdc8c4f607bbc574008a0f6600a1b4053e9d2b435ba0f8ded9313fb5b743981ec54c30eeb4f9b6d1043b7f86746b17d11b7287271ea02016e51eb453c8fc6405635696675e6a3d8ad91c6cfe99b84f833382ee74332d24b2af02a88836ced0b6ea7ab4aeb5635ebc930f0003b72eec49c72cc33afd812f407c47373d5f9a901a8f2306df886085f3f2b526e7724897b849bb52128392fcecfba9783ab784a6becc8c7451a1b0809c328431c8af32afaf11d3e9ff6bb45e7bcab5eb4fa1abb4c1a2d3126c07eb32baff6b4863244f5cb0dcb5bc2e171a69923c9d2a63650dff2b16d56121ee59b90f769cd3b9438fd324effaf6d79f6709025bc061c8b1da3fea9ff4a7f11a13fc12f3c138c7708150a7d8305e46eed8a5ce448a6b1e1f9a4076225d426873f408c9eed201ce5fea16e4b484b77e72b9731b2d341b18fe35d46cc0415417624cfcc7fdf63425978afc7a85eb408bc32a67bd4a304e383d02f6f292bd526ca0e0886acdc8a580a05ecb67b9df2f4192d0eb8f330c207615f92049b939beb455f7842e215b6a102535f8b59c67ccfa29a57618f9b73d08c1e238a949d673adec6c355faf082586a6063567c4e273b05c72cd19bcd4982e413cdb7c29d6f37c14e242eb3e9eae978827183f98368827fb332846ea63e3916f4c7d21bae8278e3efe019db0423655e8b838356d876a8cf97e400b817c47f41a3dae097b0732e126edb7ad7921f49a754ed3979dcbd834d26de8dea2c405f60a7544b567c8a5938a5654a0fea46a027acfc38f84b7df79df2bacf1fc5363868451b4fa56b4fbdbe82b17252e150205838145c9513c6d7c2f9f413add09c5c91200b0cc3dc231cee692e71e7705f583bc0d9d15f670e78d2ba42792dbd3bc482bfd4eb0a797cc34e189b238f01146d91f6c424446b0be43a00d122fce2a9e94dd2ef3f13d96c6237d2435109a4c60e56502cf112043c078e7356008ffcc0211950443f61ed45efc4cd1c40a4aa97fcf7158024f7690dce3801966979612af134933658e2a4967f7b1e2c35b36ed3105bb57a6de7a6b4a78582079c85b2f07dbabf22e69adde0655f0c5920dbae6cbc9fd946fc56e234cdba2e95860b48d37d925fd2546e3092abc0420d7b25cb3f1b79344e1bf22255fe1f11110fbc7ac270d8f7fefd35efcd121d8aff6b182b8b5972d64bab75a104e97d48725ed3cf275ba8e2f707faaf539f053cf07d80d6964683e8d2d1b1f923e4ea55018285da3ae02c137329bcb08327ec1926afc084bfe057c05415d4d5eba8c5b9abd453d014e3e4a2300e534273632855d83c2213415f6c440fab34455141579d9f02d9965f0966176efecdb6a802cc8212c298215d9555e426348e8995e158268a459f44166e68839eee6d90d932e1ff3f08a85c186daefcc4b1e6c14bb71f8589317438c4e24466ad42c297e01a5165bf01ca1736eaff4e3c5f71b307b2e129f99cb0b0a94cbbe66146989ab4e28bfac455fb17b01353317a481b6a811e5a2086e5345e4ac1ba97fdaf1dda785a9afdb2c0b387b41677a7a413268235a3dde5fb8b7d6d504ecf69df70686ad19b668359babf14c75c83ccbbc5ba0164e657155e0245f6a8e637c0a191717f36a72ab6c511d955bd15026693d7d6ef8706eac446102493d72cc7cf535fffd2a2271ae041d38d3da93096274141e9a31bd82a6ade94e68b97bc0e43463d1c16bffcf53b865402060ee50af13a23b089d2a209564da15fc29bea27b75e38a3cb331466a6d04aff4143d2b99899c2bdba70b9e0ceafe5778b3079806cbeaad04b482edaf318b70ac809891732a62b961ff4a2d7968acc4c04b21b14d59d76d6284aa9ef1d11d4a1eea1543385e3418555fbd67ebca847cfa1121091a96e8d438b79f9729d3d2c47712203523a72b046d8227d3c5a9c8bb36fbdd16a8f9176003a829f8db4ff615ac31d9601490de89b7a1b7750a6edccce2dcb4c310f69f4daa449b88e4954ce0b3e2d101c4740f9f35b29bf5a952e98f062e88a5a8c525739d69d00dada826d92347e4403fd3b417b31106f108c771032aa26d4559b8225bc06d5fb1540b0828646c0b59b781dd0701e4c1b18d9c8863c70d97493ffc447c92c10fab2904fb0f642eabb3c77f6e864a20ef2fa5679f97d5064fa3ce35c62d47cae0ced7ded8e651bf2b146d5e1b78ea5bea58372ec3da6be4d013dd3c2c2c85ef4c4c9f336a57d52ae52b67a0fbc17c7c4e039048f0bae4dd8f9961b305389a75f2219882714a272951afbf6514563538905712cf15cf43ddc79ed5a541996a9578ec40481a59f343ce3c3560a6c9e5cc88011bf6336a2be446264cb8dc0175ebb986ceb802ae68694b4b329bc23bb16e5aee8dbb5b7ab5fa64190d175daecc2af8bd696ca119f16533ca72a1b364dab36712620e9d2587f44e8b38683d8316b57d07b0d4c61a3c364b45a8dc396a70f3a0194668e6323ec0c82d06f7cc3bc8c0d0d1ee426aaf34f28b53c1f02ad7827596516e54f9a286fd35cd0ffabce32e79c83be58f36d3ae659e7daa11264b1e7f7d2d504f0b9c7a510946bddcf0154ab20e4fe8651f4f6080318950e7d0c62691bae6273431cab383d2f9c8d7d4af4a0a64be10d476c3fc729a2d0830e578fcde3856c3551e8886fcf0ba63f8655b8851296e9e375ed33e4ec5e7080ad5b7a9a4f6f8a95405db5d21f02b70bbbd1c126de533ab062e4111a605018a8f5f92021412fc273c5dae1d4bee5970735fed0748e714bed1a67434850791bc18e017c7bfe23900c4fa02a83e192a1057157168f6792eb6a15dbe8f9842396499a7f2a22248ccc81d661fa1a0b096146352497cf67cb39504892a2b3d9ee82e033b284eec3d312b4151c49590c7fd9efaa21c11dce67f44f83d68fcd6d659811c13794a0fe4c06364da213931aa6c99f92c1901772b302715446ed918a83f0ee9344ffb59435a31c9f2fd63897f587a43adfea69ffff2563a0f7205b057fa9ea7f5af0f9a92a123146fb54c8945a235764adf7eefe7a14a4f3a32400448bdaf3e4009f3fa6cbce7bd18d77b64b678a0748de6f8d83e2fbbecd83c7d8e340144d7b8d3bb774e8594d58598cd3dc6bf0e7c9e462f1abf9f9bbab1e160caea749ff6c5e9bbbdc1fc253c109a24661710b19803e0b65fabd7f988fd2827d24a17777e5a3d1d94fcca98d616f9b77509b05879989139c63e7862bb6c7275a76399a997f30a48c67415accaef4fbfe9976957f2cac53bb8d180ddf013192fd63eeb6341c9981c066b0c6a23e18caeaf72d5ac57cc01b0a3f1a9b55e00eff58b6d231a1beb1d8b939ed767eff50d633c994507caf65c33bab1aaae49615fda986780039d51b301730162a5034b601b693de3825e8566485ebc9fbc0237c43d38ae294c679d707883a314b9c18c98b3b800eb835f389ec967af944cc97185922426c60edf38c3387f88b065fabed22152d57a0e3c45311","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
