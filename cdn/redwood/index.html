<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb498e215c678c0281c512e190b677ef7c63f0a742a7c4658532cf6cd8ef5bee328dd56c272d9e54e052e3a8e78d901e90ab2b03f89462eda11538d920ddf0c770e649ad70820ffc94a3695ecacdecd5339d8eb3dbf6644fd9462137062b43cf7a4bf26438793c99d4000138b9660cb3dde0b525b248ef54712be492257e52a801ecf67b47dc1f049868aa6458d464406b1b3d69aabb1899d23d0d5b10703eaf5bb501e9a9907f545658dac8c08331d92eb20a9ed651719d63f2d8979e4b81d087a49c9075c06713a8544c736da5ed939e9c06d2d773a7e5e6d620b32db8b609f8228cea6c2c82762ef505265de78b214a7345629273ffb14909f4fffbe8ce29cf043428d6b55af474e9398385f438284e8cd00952da622f4ab4f3639d84ee8da9fa46c76917107e0df783ea99d0a86595cdadbb62754b006a73abc1164827d2160b918a85b5505768fe2a2043838a6c501e96e463c5620b41bc4dbc0c1074a9e0e5eadc162382e59dc61adcd591982a54054625be8b1788f48bbef50b6c428dc122f957683e6b49179637d44e53641b02ec8fd68461d62336f6d7ce87c3bc13a5d80fcae1350e971649ed5686e7b25f23444cef2b6267fea5aff36504468c1e01d6d3d5b63b6f249539a01015e19337cd1b75bc101f82b0b740992cc126e99ca728abad694ef4651c6a85262a9e6995922e3ee4e7da13564caf1f53399eaca24beeabf1c5fd070ce4c492318fe0eb8e5b7820b25dad9b906809f43c8c99159ac9260509c7f678917e546fe5fd036e3ad90d491c4bc58d1a1fd12d5a32fbc9479bb0fd7e72993462ce5b6f2bc25783d0b3eebf3ec61e279547ad27b2500d18bb4a2f31ecceffa6e0ede955adea7e3d66237f1e35d7488e20f01ea23a936a9977587b4abb18e5271f140f95516adf0525a845f0ee9f659c6eda758f7a05d04801688b27726e6bc0aa15630f84c9cfb26d2a2dc2fa5532e9a0fa54528d1d71323dcbd47f78a0b18c0c9bbdcf328d122602382c19828c5de4b3c7586715e4b88566c4a2c5139e9738ae0f5265da1a59558b72dc206b3686b305e286fc52a46a085c970e4a22c2c1b214a7076ffebab7698ac4fc4def7121578bc0f11fb1427101ff1118e5bfbebe6e08681fa8d25db3a24b9d137c6dcba4704ea408d30630f9c6467cb3e6298a8b7ed98cc4266dfac385bac1bc15343c64982b89aef35fa8f516e8025a56b09a14f6898c49be7896faf03ec71d480982dc0307e7a135d287fb3a85df3a4e310bf1856512671f9f6f304f32d806925b2d962df9a0c1ecdc4718781fef4469859aa3a4956790daf935f920978ee066de336500f250aaaee859b60d94daa13126220d4e8afab6b386e99fd53e40f36ecf77ec0a7f06bfc29d025512c6e83b969695d5b8287ecf77fe812c7e0750a97f8c2819cf97a5e4b521bd5330c5f3249344fbe780a31af24d45fb27571a4d2598bcf3739106099147c9ba13b9af5f59408ff0eeab908d8806e3740efe90acd37f86f6e5de726def9eedf86acd415e67b1e3980ff23d1a013161d4ec30f2d9232fedca4fdd716bd8a982601c1c307d56295fc3d93c633adb9fb307dfeef8a11e6c0c6ff01346b5b9d891ac023b54efcbf3606bf6acef93f58491853e0e1cb285d807079e423beca0718da30bf6ceb4146ca68985af33d03095bbdc545f254887dacd8ddc688d38d221d691d8068be236068904aba0f0b9f6c481e42d8c58e206bee946b486bfc73c78d829bb5de322b3d9ed24a57e1304f1f14ecdff6b6088347630781e7fd97c91d5054fb79cf5f854698346655ac9bef9ad7994840cd76e7b239c3fb74384264726ee11af0deac28a58126f8e011358c2b2df5ff607b69d172cec8ee5f0519c9ec64346f7e049a95ab898b5cb560208feafb6c883287850d2f47a1d5f2132f5b42228d45551cb0fe189a7b9e74ba66260b6a7d606c4a6e6f3d2e1b4be9893407dbfff3acfd2e3446f017f97b6c708d46071ae62f7e5be05d7d7e5ed43fae427acbc6884981e46a20df89f6277c3ad1111d1107382fb777bdcde9568329ae0427b851c206234472ac466a9d04fd085a42c56c6cdbef3a4f8807c6c11386d837c0dc746533879d47be524306b4b5ab9f9060ffa5571b312eb3d19d9e1a66a792045c98bd34eee3f9c48cec52b372e10052e03929e45acbfae0aca6cad6c4767d8b2f15414b08e157068ff6137154126b98e2078e55adbaae5c355bfded34207ffa276041bb526eb62ecb34c435147aff27fa2c2120991bc3e0d1aaaf6aa59b0f7d9f164618db398360bbb650f30a072855b6f2cae098716a384124afa5fc5233800bd8cacb210bdfe0bc8bba970192efab7d97dec97e7f063f60a28078592d180d8110e220013718cb7999097f11f718aa8728ef2e8ca542d35a5ee3363ceb5fa011f9bbe74150e2502dcd11425282760c15b0279dd06fadf386176bee7a45b71f4dce631ce0b2bf628a3914533e1cae68c09e1a941acc93d88cbd4063885e08c349edd121cb2bcababc8373ce64088b6961215984cf0eba20274666ee33066411bc849bddd85bb8890f42ddd768756c0fc71be74e0dda3aa56c1e8570cd9b129ba8b9f38b6fe57b39ae1b785b37194f9e7469403474960fd115e3a7a6b10dd7fab203ae80cf0f0841eaffad4ea0ee6767027e1bad81b4143aad22aa141a607ef8be2513b59f391a93b56cbd96ec1f0c32dd6f8b9aa21699c623955e8007a0c7e7328c730921df2735364fb0e4f9e048b0af231a7eafe0e2a9d2403668d30ca4cee6ebc0a27a184875a780cb753c74caf5c3f6a54137d5da0962ebdae723e18c3f9f9d5dd08ff4dafcc738ad009ae418110e9ae6dd63fc325cacc9af64d10fd4b4914cec218f5a7bbefc744b6f813f3e8c6b29a51696a2601da3441e9a682e1cc0ab947b9809784490434e976e2c4454c1c47e7508022d97946af32f297e65bfe13c6a86b10eaced7a263bc976befa32cf83a42652cac39a56df7a22d8cc16963794d1ed90466e3d84827c0487f059228556484d6845b2b71d8288199611ad541b33325eb81f36289969b6456598e877aa84ba3789ec2931c6523920fde3a310f472c84f363f3f25609cdcb83b1f93ca9979e6d001ccf057d92070fe1744bdca7c544348f45f6ce148fe7bfe661068077390d678a71e62df8f8b2d1fc50dbc0da7defc019ac04b40d8f9e320041becdde85e274c2dbaee651f8a0a6f2c90a188e04052013c6d2e2c9876ab58e4bf96005ef649fcae99f184f4fbe121f73a2b8009e2d8fe7f63d9e843f52810f943a32dbdd664375697dcc50b4b41e47ad630d2ef54218908846636a063f45bc5c8cce02c2295b963a05359be0ef427bcc8c8abb368a7ec5ecc92b1e0c1e061d97c1ae88502327984a86166bd95ac7b0bf25523b26fc00303ae7b8da2110b545c7fc7b2854b2d9d9600e6d3cacf66f365f6a0e3e220669a482809a0e1082672da32ca720b3c1360f1dd1497c876d2e3ed07c8d31416f9a18b5c3cacc2bad06f2e67a1dac29b4b9a291d108ed81cf449cfcf8d5ce0e2ca52d3dce88489d5a9398f6debcd4e1c3d89b32878c757b77ebd8017988238cdff87688058f80d19b474d436adb19224f0d967130654faa6ff67d6fa3729f5b167cc6a7bf5431722fd31640ad89cc84f3294ea98c051f1ecaf9b06657ef1b13e3ae9d23029381981e1234afeb544be3536e8c4a506fce81f18be83bf860368c9d46937497b05eacc6ac5091a28f5e5bc0c70e94565de72169486ebab33c5c29d839a9077e4ee25fc3fdb3e7d0207c7845af1563d10b5411bf7077beb2b9bffba5873915012071c87a0c1b38084567d15201c02766f0d02a40a8808a82265fa4ced6678dac9e9598493bd8963df00f2af302907e656baff4f21390bad7c4f1530c6a48191df983a5c5f861c2ca58a5c410be90f198278dd6321725bb45b2e2b1ccf80141af25ec9864764b5891eb0f4865d393ca722b4739b1f5574b527091ca75c8ea7269f72671c1c4427c3b91651d52bbf16caae517198f12cb840bf40b35e8093964a5e3472743fc5ec4de0b2065bf75dabdcb96b898be84c907cf3b41e8151c9d2e66b3116d5690b9f5f5d9abc37a101cec597c1a8dc230ff17c384946188ae80d92d8d278d289c5133665c7afaa7c1955e55a1052b5427dcd240de919fdd1916660a7353feb767df4da9e32601da2e47b0a4203b8277fd36886b24c7572cc219c7a762cdac64483a2f202d4fe363580a0c15383fa053320ea51e43d5814b1340d7a59d326c5464da0443544408e7274f7207845dc9c69ae8a4ec65f86e43a723af022d3caf9a2511cc3809d67b72da5ccfd545ae8db13de590f8c3174a09908203c740beb76b4b500fd6a81b14d987bf0e4910c7170a51e3ba95df2ad6e49de83d4df86a758a4da267f3eaf5b0cb41f12d4fc5268fa17b63773c01347ffb05a584b73a0652a77d58d6493b38f59132e3e7c17115c838dcb2a5745d13e86501648f830e0165ae99f849611cc5bab8525dbbde4903da2b91f58ff1a106e6fdc7a691c09bf53f01638ab26c06a29fbdf870bb8089fb418f1e7e95f8266a0ef9496db97534c2cf0334be2189754105ff9e92eb92bce234315ef56b149d469987f545785ef29e24bda60c523f3b5d3d980f88e94e4ac0fd266634250392d643027349405023207e9e82935ff8cc6bb5009a72e07bc893c81e478cd1d055c2484b5f6c0a833b6664a75308516651ff12744b5567bcfb15bdae3f8e69103bd0e371ee2587675bda5fa4d3b77dbce04f0a318e379e2a329d1dc658f3a9a6caec462639ab5c857db4d97b247e8d9353b43d3ead3cda98daf6a0c296bbeb07fb3382a1b9bf83931859c87dfc8d6b18279a4cc14a3b411fbd973f289cdd12d97c49cea9e2b3ae59ba627e5690a80b9d64825e447c598984346d5b7692b83d20c51e4af43bfdbcfdabd933f5c3a5afabc2121c6b987bd7b46b3efe40d4c046fe01d7c0c4e11f138c82a4e69ef6cdfd801711f38289f09e23db0e98baea717272a8a867ae32d0b592be0f664b2426dfec0c0eaaf2f3a99d74ddb89c6f5b6a838aa0bff7d7cac210c92bbf199953fa29c91327fb7e72b2dbc456ce51980080a74b6d6712ffb535baa9490f9f445411c427ac26f98c44e404bff96f035b00d5c9870ea2c251f11a1309b0fa4c5e6c438d3214854f57032506b0d780a8a2fbf1feaef9eeb703d5375d5d1fe22232f40dde30ce647032cc9aa77d4211315bfdd75e94b8534161106827fc8272522061532d7a292ff31d6829757a260295f1bfee2a5b9b4f6b239c98a8635752b44f52031c7c40ba473d0132a6549afecf07d63147981bfa811977780790219a23c7f13ad6e1e58db6ec931d8b96f08dc3a01edd0af8ad1e267c01a3c503170d426169056cc737116895a3f16a8ac006abd914ca4260233eeef3f01378b0c8fe61f6b514c2293c7ec13dbf7fc576a97d30146cc604ca816af14f572329aeb47ff9a432036a453a62d92e97986bb2a5496d7557a56f17e06190be90f89f24a979c3e6da68204eff7d30f3f4e6d1bfee6b10181faec913921a3b0f50bd611d8d7615a1aadf22abd6bed925b8e8dabb7b955d23a974318cba63d04d3d902a3202c943633d25bd123f2c3a304ffc262b1fd326ae2f3270547fb3ec3a7c76f14f2d8535e632f31a6d74bd5d876608c266347ecc9f61f3b55174b7ca9d13dd01899239bdcf296b44358866b11fe50668077445035e388c5ff102fb0d0c49f2daf4483deca7da8af4e3d6c0a5b442353dfd8461ce033df26ddd54237392b608e203be3cfdf926a97639ddafa8d31db5682fb7285d7c1691d8e6a692f46b8714e9c01111096545c4c690599734d1aa7ae159b84bbfb6148fcabf0d791b860f01565c2510d156ffb284b5030090aa85efc1e601dbe15b19ee59022b4be5a41c857a946e301576b83d661c20a2b65f4636faa5985a2aacda2f56a165ba746e49f43889396d2a3c06091565ef89f6864205411fde19196aaebf28b1fa6da51e6675a999195a5b1f0cafd536e97b426a98e2c98bb7ca746a30dc32cb3ec2a26c6a87a37a6d2d1fa4dc50dc9e133ea45181be735e18fec8cb75e62e9d5cda67a1215eb4ad43944e64be98cb4c7325996b39a615a5a5c47fd70e7dc2ceb0b5c1f91a1811f3fa96130be6683c73189c1a9108af1f532cb5c3491afa7df6cf621914b6212639bd1b71eacfbe172872cdc6a915baed18ae5f39ca410439eab0f621e7f46d81509f8a244fc237db920dc37ec4a50d43453a66b6f7e8f325572c995deaa18809b6015f6ba54bb75df6da8fdd285faff1adf38b38b2953da65ca1d363a20b990421123317ad647e9ec67da76e8db8b8de7f3a3e57a201bee764118aad6677ce8d607f623ac778f0a9c8bee1858aaf9d253469e08a0cbb7e75b8564b7ddea2e9dc0d6b8a2eb869468987a278b2846a642a0a020f3be90ad93a642123995e5a8b3e27d3a4de946a3a40b3824a401d36c4a3ec88cae42f9ce2a7712f41e253d1399b08d4660db4c2b3cb12ea2af88370f5c3534c5bdffc9690a0d8166bfe34d3831877008592ed691b02ad351b4645ec47a7cca7d98c6754fd89af86192f4d93d7805bc3c3455c951e30c82f5c5c291d3c649552c56291ba9d235e21722dbac3f84cac7a19a72cab5910b1ab94c076f07b8e91340082178f05bcf4cb00a55450a166180bc52f7a9747d2a788aba6a47b450432a6ccb85c6621365159bba37d717d475f61c2b7e38d2ab5bc68974d54928398510fe0da6e47138789047a153ce7d8088607ab1929b5f9e226b2f508b038ed37adebce9769d4911b5733577adb6612792c9f720cfa12e0b6b3029c9faaaf17555de24c424e0f99ba560f78e2b6d05a5fbb8f107dbe3d8e7bdb1e04e29d47b4509f3f9a5f9d6ecbbfd6e2f6f87f7592b9b963325c5e1d8b0d61352be127d0d6b3f6a3cadbf650ea6b1e134aae668a99443703b9e44415c83dc88e6101e0d8cb329dd06b5f3a98add6d92c60c507105b08c9c7441418c0d389fb2f6653142b28a2d56ce145b9d25166ec228328b7d2c710089577afba2da66cdcf308128422cad4cf2d3992addf2e941039f7a9ad5829670d41f018134c4378c0c60f0f33dedc2e250289a9bb415d6bfd34cd945127d4745b4f18b6e988afb4391f3ec513a01c9fb3fce66d0caf9d17073bf2ef275918a59569ea8e17d452671802c5e95e8c847a2b681671fdadd8482a3692bc2b3e5939dc467dc7704df7bc8b83998ca31d506c3ad9c90aa285b80884fa586bd8cc2851a9913778a9615a104b669488e819de08cb3dc2f84bb3838e9340209e68be1c20a16c790c47aa16eb6cac10e65caa6b803c921ecd8c54e821246f48888552e8b01f4f5c013306be86e5f75eed84072c5bf1caa07b1ac6b1418498a76c77ec88dab88c308e159f07e665ade67e0ad6d8f6ece55b624cdc1833ce66feff37bed12a1230fef7c16bc81bf9c6c991747a93ac4a01e247d8c00796a304893127580946330ce406270d5f91bfb90bb611717d9f1e8977f6c25b0a19d21d8147f01b384a99469e676e76f2a73e1ba8a136a6f97dfa883039025801321b32a9552e39cc95fb88eba5bc256bb92e092834bcf3a92316dc6d2c8e72b24545ace4de629dbed57a4925c2cf447c2c3dbcd1a915daee225c4f1ed48219fde4d832808380f647ff372857b3926e15a3143e7a38b83eebad157bf49e681c3df4ad7dce92ef4ec62932c36e4dd4b518237678dc15ef23541177a10d4c19335ee37328a977f98b8308b3c0635c77bca3ffee321a14ca799fe61439d26022af5b88152c8782009e61b3fdcc1747adb64aebf8d5a6e3665b50cf0058c02617002848efdf561ca433ccca204df75ac28f233b334d2b9b1ac7daa802608ac1838d0a726226cc6dddd813b5c50e0b1e23bae3b24b029149ec6045daea661bb0f3cfada0022ce3680421c508b5b5ea5bd3d6c71479269d3642e0aeb149f506d6aa07226668c02cafbcff114b8d8b5ee4ad631d8c98772bd1747768aa06851ecba97173793cc51790a307f4a77bd975521d4bdbdd46789e91cae3d080179d2dabb5af26ba8fa8fa6f95a42b84004c9aa06cde8853252a0e82b34e6a7b34f7793c5f9020d109d3471766755df500de7d4cb2695f4b13790a7edb8c9f27099fda7c682d1416550fe2294719b795a26fd4b6c688d1ebf5ff7429b333fa5d8546ada4c57f13fda12e2f535ba8f47183bdce279abda403172c92be4fd83e9eb66eadadcdfb201245c8fa0454f646b0cba92c78b34eb1200d00d8c63590cea0db75aed5b5cbc5f68e150506cd8b70d6eea9d2963eb0927b662b72bf6430a0f83d3d61541f4e33f452c948c9c133d0d5638ba81ea1986a248ae1c277c1d408792153d640f5975dee630b6d9db2accacabd8af996df637c10795f23d49d8782cd6b7c5fb926b923760c82c47ab4830dd0e7d4486b93deac3733c6974623d7e7a519dcad7584a9a20ab3ae55e180af18b7a7da00cf79c4de616ff7856f386f4bb2a266eee259eed21077d4b3afe3b98437defe2cd1d9b4cbb58e8fc92f94dd8f2dcabc4ebd022f71253b1437abf34efd923f55c8cdce6e0f05bb0d301717b718dfb80aecc3e97f336657a446ddfc2e132dc18627c8a79c9fd5fae88172ff4ea7c0180c7810e64945df639fa98b5af98668053912fb8b4427b486785777f2f595532dd001b019f7c9b4a922db56a65462aaf002480e16c0844dfc58e1424e6cc0cafb29b415fbd3d8a38749b541e6c36da55ddcf924b6d339e998fd417b83f601316a6d976c750c421c3b8340849b2a5e8e296776d26ef1a7169b777efc534e112d6a786ce13ea2fc0d09569ac6484b7e2348ffbef9c0ef9f0d4c0421af1d50793377ad92ec8d0655776d7d4684ba3f29a0ade4cc5ff24e0e9b90c9d987287901503b2aefea5a8ac22e48a5b90176c1bf50a03440d8f846a4d14c485b353270cd0b60b4046231b54c172422598c11d6c5bae4c2761339838168af12205dc13972d0f357bd5f184af42b5155851b854306e94e32fc03b03f5e6de3c8d81bfd1d4f14739f7b27b9c52ab732317d574c56a6416633f31a4e32fb4ec17c5159a3d611800dd43878877c260da85cc47e1032a5fe43ab0d96f5ad33d4fb067e696a22a7395f767faf4264f5e8decd63eb6c5ebb122ec9659ccbd0d63f84adeb4e315b1826b457cc5389773081183eafe137ebd5f361eac8526a9e4a4455acdcb8ea2ef70a8aef60dccf9c46bfc6998e0bd9dd5b3b36dcf8b7a3b8416166196fdca8f90a0777219f42070a43b663c9f80c13495350431278fe264a57cd5fbc822c3f0ef78f0083bd7e12e68d690382d7607674241eec40c2d4a035edd24754ba08991eb73492b627c75f2537f672e9a347e391f9e65b17ea8fe44d902bf3a2e57079b0e0c7ddb7a89206363bd66919eb2ac0171445329f18e436939e1f2f1ba48277f7374f4a8c7c3ffe5e8d3d3891e5870debb30c1f020a6ad31f9693a3c7887893bf8b348f303d79b25a076719de8faa0e1869b5c835fd4f647c4a145c7a69d733d07a53d3038743195a6ea79a530c1f720e049d54f2e92a46ac2fab9b423de541e6372f3f3c32d65a23332d631e72c8114357bcd24ab2a5973de02e13e3c9169381f2309a5424c7232d73cf833335454da6fa3f4706e95e1169e398ac6303f0f186bd98c8e228fc65b99734709034386d971dc58df3bcbfedbe29cab4d9609c3ebd3409236b5bdd318e305dde6b0d106448038c18f1b47f230bfa398db167b7ab33fddce8fd2e28f1c4b8d0a0a6499151899f6e60b2a8ef9f03154700572f2c85628811a69d2c6107db24c61a8fda26490f93639b44bc68166352fb28fe0533dd529c3945c448cdb52049115e8eda4ebab3f40b9aee4902b20d9ccafa8e91e29bd06fa06951c3fda1af065340ff07b706bb4de135d9e7e47b840e7c9ca59894b0554ced711d9b45ecf465780a6d5fd54fd5c682903b2594e37f094582bf269f23c320a5e7855d27956dce7c96c5fbf39aa71077bffdd5687cdd9570f5e35cf31fd79dc0bccc8f1855cbb7b12c490125a18f27055def7384689e005072d271b3c935d0b47981496db2994f6618aca9df99000bb702140ef0817c8e3ea38c97758e2093c0e93d0250dfa032ab6287458936a5d69671dca97829333c6653fbb05564e32eae3d8996eb34ffdfdc05d1d9d64d6f7a8620415b20e144ac289f288bdba0f88dd08cdf716a9f3938c2af50fa755dd47fb4f0ebb4a91f9d41b8951ae8a007229ac8bc00e6fef5c41b52168ff45d53053bcac8cab1b0acfaec83920e8ac9e10d57e7b0c6b359c233d5032332b6526a3541d1fc43ab2701ce44a37d5c04e2311a4b6a2789cd92bc5819d901a7ea77e2fb3cf8f05fa16b8ce61a7804514d0d6ce6a64e2d7048779788cf31a7a360e04ecc10a31e92a5a4999463882a306c4d5b5d767dfd6086d3dcf2a7c99e3add09596102d0e61340c3edcf0eadfbf30b72741890f9711f6faa77402ca478a9160432476b1da95765aef2203b993800b0b5fc7211e83bef56bd29d881fb96a4f067da072894852c660e14a91bf1b8c9a9af79e1f45164ed0774e740b4fe11f88b1e93ccdcda1a9c5d25252460d1af089f040fbf4422c08fda1eb8c886e6691915377fff808fdca01c0ab1a93987e31915091b84a450d82740131dd50c16675e001ad73f48538333746b7d62e8558139bc2310a77decd5c1ce227d6aecb6ebb4342723c59f755e087c4f95378f85e70c4d02491803674d53d54094be69982225e2fb962c181f78df77116070f77fd11ccc715cfaaf1751c21ea72e3ac9decf5aa66c45a9d1191295206ae839f5e3b2199de102870a9d01c40e27efa3874acb96275d1f7ecfc6ba275c37da2f9bd85e55505619208ebe73325984b06c25743920f1620fe29ea9a32625925e14fe0c6b9c699ff4bb8c68481367bb27a8c24d2edfcfe589e4bf64d39ec617f2d3b5dee441b04e40e7393d40b7d250f201ad7313ea14ad0a43ab6283e810510a435c2a4c7a815603016616cda6ed2f166ad234771df5a2cad7ea424ba395271c2fc56115e7847f4f37f31f864947869639d20c4283ed8cea7c2fcc9b4331a2e616aab23b8a0b2481c2b178f35e0bd5b53f21c1f8ff06fba1567507b082c006f1399c1799c8fe75d0420c98daa0090cbfc2bf561850294b9468b0d0c11ddded4668ff48791aaab0805719c49fadc2d8b1b7fc35e369797f7feea4a568ca66fdc80aa135a913ada4138c013b3b05e1215fcd340a3450dc662d376a7b5455368db1084f49b636ebeb8dadf58d94e9a2276f030e416c05fdc3b3f42fdbbdbf5588706cc7160e990037409cb93bbb6f2bcb636f57e5c09d821aafd965cf45850241c42d03fd8394f51306f6ba24bc37e5ca36225d0567d91df908f63b65fce9669a5d89a96a39c2fb8c55b7d2c46a9be7eeeeb15f53031d622d50c8a844b215c1b9f771bed64805aa343be0efd49be993c9cea583c73a04b4c22f777dd5f4c757e0eaa638f461ef97985a94768e71689dde658e8d73e69273fcf666f80a8569426a2735280bb0f486723fceda8ae0312ecf4f2f38323a62886bff3249df219e43c2a743b19c246a2ad7c94bfe4261f0b1d122d7ec2015f45ea188598c728c70ea74564f6e88c607eea8ff3e2e4aa4c747bf51f70da89b2bd37fd1a966e1239303657763cf565d4c7fa2dc2d79eb9b268c1b785e3829e3ad8fdb2c08d5b98874f5005b7bfd30be7534dc7d7cee5f4d5fb004fd779fbf2913a00764b513d57407fa7230dd866fc79286a57415d66d477c4400cce03c387b1929fa873330d67a2ea34cb3e8f5a430f80e5173f7da12bcd04429e57e3dd9b41bd961431dc4d0ffcd41a4cf62dacf005e79a741a937cf78d783bc0d2aeca44f237881da49f1c147c1c2a83d8ec98ba0f10995c898ff7860feef1b58eb25c7ba95c31f86f4f378c989fd6654c1df819b39574a86d9ca193fb69869a527978850be41d33286efc0d60491d740957132f61442a5d19a24125be34c12d96d33698007d7b8b5e5f6676938413149238ffe1cb58214bae14f20043092fe1bbb710515492fcad184e398e24c71af1e62657fdcb7750748a327ae1813ed67c7f30f0f6257410eaa8ce376072664c58fb45fe3c5f458e9483c68f3d6d86e3a054f55aff93a9b80b786a3e9a1da52f7e175a439649b16effaa453e721295e4068aa4ac6c30545da135106384359462e36edca82d835b7a52c7a0c852a6af05488add424305b8b159ce82d2eb0fdfbe8912a51ef0ec51bb0cd82befff58bd41d64cd3598208abdefc6bb794dfbee9de2987f223cc170d552b17096c6001aaf8e6a444417db31108d3356e9d1f9151fd583438854175fe85dff8b58d58b8aaf5930c77344bd3fc165b225bb31be41b66d2f8d94b2b53257354c91ab35943824fa2d99dbae21ebe10044e28def8267bda40e6500236690cfa38367e4ad73a75a14116f0bbfa412bc81d2d8b562cf6744d7792f45acebfac2dcdb3fd248d0b7609273f7dcee249ff8f02e426162fc8e151beafffff9d62f9112815820156fc34817dc1c1018b782d75655ecbf5a306fab7758b208171fb0431a0ab3b5ef1bc954528a6b4bb59e53b1d711aafb91a25971684ceb7f320fa208f106631aabea3ce6c17a930be30d7184f87dc551c11d59649182679da0f0d57ec582ec9ebd0e712debfc58deb9942563c0532cda339ea36c456270a9af13ef110cf5bc13235fe4f4ee858b6170553f24580de73b54f77543f211f1a21e3b4fe2cb894dbcdba8144b2a7d6a5f0bf90f806ddb717c23af5cb7ded3d3acaa9f0bd728b62a37195ac174f76dd973e2b1712cc355f7afcf6950d581a1028664a928331d9c7d8a24d18546f8212aae59c165e52133ca8db4d77e17ea307df7605e29a069c00928f5e98ec78ce32011f39b8ce278e44f5a6584cc46f491495ab46414696c1cd0dcc790b390b0d900acb168833ebe2053d7e60653cdf235da924188438247f7c8ece87c6ee87fd8433f67335e629974648117e7ee3c817709f0942a6c7433f075b79d07893b2439bd0023dc108b75ac60d772b9b13764bbcec74fe5e368afecac870b3a9e39066a71d0e3f5e3ac22802959ba972239ae43a63a85145f8aff02a108b5c25c3e514d76ac0dbd62d6bfeb947670cee27074cb01f0c64c2733ddf30eb1b12b69a944d236bb07e6b0dbf46accd70c07d6c5711a0cf0e3d2911ed2c73ff5bdf36377f0f6021aa2d7060916123b5346b3a27c05e46e46759af0a91f25dff7a40d7ffd549c68e4e9592e14d83803715fe209e6bcb240c14b6a20e7117cb9d6f0f717f5f88bd52ff72020e0ad405a07426dc6834ee0db063a666e1fe3202f5bc866a9facdf02b5f810984b67eb8722477c9712ffa375b30b390c87a5e04e7cba53f27aa7d019e3bedc577ff12213c20a913f7077ed26373799b8eeddf70c68e8f205680dfdb8c23f53a03ae516aa350526e70d164d8ec6ebf897f0a0d41e4537de94dd3237640e05af026ab68ee9fdd8f3db29c7e698ac9011e6a92c0713890a914ca9667b3f8d682d81ddc1ef8c5efa8ed444ab10835d22133da1b6a7da2072bac61dbfdb105d631a8d8631a5df8a797dcf66cc7df948d6791a56d1b864c396db2f461bea2a0367866f430fa131821b42eb24624fc80e3a402ac8357c5d7da35dd327b2062cc159f8e2408165b34f40548042c47ccdeded24e38cfa8eb9f080ff4ec16945dba9cbbb657e1b9a334cc9012af65ec901897b5cf740d1e4bf01f2273435e5a5ebc0f9699e2cf586a9ae55d0d112599de0b788a591db6b0814b43fe5fb46f716ebf60eb4d6b674ef5be70fde44733107c894be3040c31e073db33697fd32e2afe2caf7ef57ff955a36f6e9bb70ff8218b302072f50f1c85ba58322143d26a253ad518629a0b78cfc49ec318511ce39050c6f5f707ee50ae14dda04d50380ce49569a63d574da3c0893d282565ba01c75a0ef25d2a53364a9e63b901bf6626d4685f0b284b46f45298e85a9d43bf1e781c7e1e70b70cf6af76fbe1b609921039aac05563755295b7925415c462a2d7e4c53945c2d285c16504faba0a129f8c844b3836752a680b094d95f02de0f35a87969ae0e9a4966664a6aee910e16590a305178a6f43b063f9e2f31e37d6c731fddd4a2303860296d7a95e5ecdec17402a381910865d9dc96c640c17d2045fa8964658cd4d372da2630fd35516024a78c2833e9da8f6432f3c53e6c95eb7ec8cad1fe81b456dd527d4be565decf9f21bec4b922d9283cffe59debb89f2978e38eac668bab0fc4d719bc0f6715c672e6afc8f57fd809b608ec3c37eb137597939928717d557faac9f360c0bd69899f467671ba24662993b6eb9baaa802b77db49a7f04d2be54aecf365e28977c4bdb044719a9db78ab72ababe99a2c1c8adda7280baca054a5500d8953ce0639b36a14e34bced2914b0991883617cb24771316fcbe2d5d6aa8554b3593317a775b312fd01422ef42e6722bc69614265f9c86e3a350bc439d151f08738de57be4d56cb6a96ad4eb87e1841c8076e2b2cf36b25b18057ce63565961ab5fc91030ac3b3843ee244914f43f979a71f5eccfe7c3af6e758244e762141f8ba9b052c4f6673e5f3f9dccf82f8816370b0017b5717a56d99ef326f66eb69d4fb63fa539826993ffaac3159572cc7eb0091fb35392bbce5b45432ad084d824a9eca14a08022a5b7626b9f5382a9379eb2a518082d5a42de2823d28e03be7819a8d6f281391a041a0390be59562fdbdcd6203f5df781263e24b1c5a0bf763425de14c6df3be31ab6ec5defeef9c558898ff77adda2d2ac8cbd5b87f4c5f851cec31b58d2a8136f34502e92e8e1ec0045381e6cdcd988e010f1abbd9b9b2bcd65c587185d6b07cb490f15a0bf29ba9ecbe349c8649199f422bc7edc54d57d31141326ba45c3bdf5d737f9b90b6f8d5d9c44a1e28905bfa45cbc60d1a7703b8a960fc32e4e55119b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
