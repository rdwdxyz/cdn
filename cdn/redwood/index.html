<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e0c9097f41b68543ad74f54d55d166a458cc8576fb3b01cfd2092553e865d6990128de0d6cf1c654331dd4b1ce5e86c097e4645fbe79ddb6ce885094cf9b0b7d5c2263dbe11da8125af83da576df3b252631f86131913468c76553eb5cf910fd2e7153e61e1270728fc1b25179bb03e3a96a7a1e313e4acb9e4e1fde06985f824a4cfa55821c9a2115a710e1c2ab40b6304a782a767e8c027e5ad2d96b457c0130df2a0b9d99c7a72e52e87aa72890a8871d605ce5f3c935e2c79fd1406fce7c89ce8c1bb51682fd6628004680cc18befb435be26fac17216f97f0d832d25af2627efdc09169b40da497e6e54ff7756943f95d017cd203f801dfc9c97f687b2c94d19f560b27cac037c97698498e8daf4019646d28d26dfe521659d56ba365d845d1ddfbaff6396548204f2bd3edf0086f6c5b2eabab8c5f5f65fa029afc7909fd0160025644b9911e091b7502fefbff1d317bceedc3779cd39fa68561e95e9fdd9ec213d302925799633968d0d82a8594de321d6dca17a85b36933dc82c8cda7f06c7d9eb22b0e714b9f61d4da7a45901bfee19e3f7854159bd8a93ad467ea2ee00fb7b0ba92dd0c3128c144c3b995a850e6b6ff405e0979aa035dfda524cec37509eac75a1808d21ea143b6777b821651798defa2f0d59e0ff26e3ca749aec62ae038856249eefdbb8cef4eb7f0b344a4272eed728590a8a951e6492422084e9d66793d8066f16fe834920b7c63942ce8879c6630242e5fb52c86a4a58e48371f1139e4d8d3a1b580f742684a8d819a36efe0e848f726cd92150ae1e0c2d48aefe44f622baa7577204c4e9007ed3afeb7d3d02fb974b7a93ad035d7382b44f2b2ea533f210c40eb44ba39de0dd2cda535e79ae3b1913c1145454398059556c356c3a9c9c3a94f966f035b74c40071f4e1f0dd007ead7f8a3ea8e8af31e8caa5aebe880cc410955489f8ce654fee3d6e5c5a1e148981d1c756bde4afd02bbf96cf3fff01861e35425e3e270cc3363a3a04a4a4b2569a1b27e431524a53a318285f79b8eeb9bf55f03718de278708e6a67e8bf3f4ce0b6488941d965713c9c6a00045900fb09402b11d021bdbb54f004a3662ad35678f3cab3d625df987bfe9cd7a2bffad5e899eecd9c7cb5efb006a5ddd67244f1d9a5408fbc14f21017d7b9d225001bab53de47fb909c1409757b5e0a85fb5699869b848ac302bba18ec1318e0bd535ba495d7c0e7cb841f20b863cfbae58ca94131e94e50ecf08982a5e471362af6a38bf4dc2cd9e700b6ac1fe3015a76fc33efb6afdcf342b50450db370aa6581d0ee82b42aa5f33a9c9d2049448e68c9191ef38e6b3e3d1ecd28197a0762951b745fe9c5e83d07c27a4fab0cff71cb4556c9ebb904747ebea9735126bdd2cd8eaddef171df3761093f19504716c4b06ea38cc484d69f59e839d937ab66def7b2e33219917329aeac57980219882e93b8dfa63df62dc0741639cb81bede7109cae14bef8af4d474a077072134764b1485911a2a8ef1757008686edb5ee5627224963ef5427f353e530067744ae22edbd3abf696d16d4207646ba7f76911db9a2c4331c84c729d7eeaca65a60e0b84b02eb54d412f8ec79e447349be2a906512146be4c3fa513b37a5c5a6a2b5d02f47ed57b9988f83eb0f9e53e19a8e9dfac93f67d2630deb5237a316557e1fd15ecb0663cf60de38b8c80f12d89455b19754eb4375fe0de9dcfc143ac8e6549ee5e809dec95e44bf366046f175d9826697f4cbc79c7d1d368235e36988bab247228791bd95168b1b5a52bcd08f0778bd2c86533e885fb18ec1d4fec1c45e39f800504b04a86601c83363ec1be9f75fb18bea8f2f03109fb4082c048fc11ccab95676347703c96271c735b39f8bc5517e3e0b97f90e8bd32c2083751c4fac7fe9b13ec6b1d2d1328e66b33ffb4417d4704dd67e6828325d9ac5fbd680431944927dc79fa572028ce1874d6ff38fd0dfce58c4f4e518548a8f139610e443ce02c27b10f9bd7931b5ea8f8f79aa380e97ddd7e25dc929357f3e91b7092cad7ac513b1a66760c81bfe99ec957c51c5a57ed09daff1cd17ee57e2fa16f140e012775ffdd3ea0cf6a87393aaae7807cd71c0d88a27ffff077140ab78b0c40ffc9af8b01afe45ee90b6327276a4b579d2db9e093ee1e1e6973adff7abc967a3161c88ee5173fd9fbdcc7fe1c5c84f0df0237f6df5a810d95c7d6279d0c89bc2a34d13bace8268729f2d549480c40fb354c4692d00154b0e00cc9b88ddb08d66da1eaa0d0a32c85f6b9d53a4d359e839f4ed18f7418d87d8a3ec0eb752584ba2127224e5e34b075233bc502de993908cbd34cdcfd4ef905906bdcca8cac2c8ebe862bd2d2e3c7f852d1f8b37f213e18ef9b14d7259057ae7eb0ae946de37994f5ce489818f2548a0cf5d59f14a8b45ce72f1ec6613a70d3f2cc5548a6410ba6dc093fc0586c0c97ab70279c1530645c7b813744fc1265bb87864b40a13062ab55e6b55d59fbe77e92de296f549c6f3774da96dc294fdbbc3975b2990e4041aab08b5fa9debff082e33b87b1e4178a0c10db9c70a101dc7e43b5f47ab11d424629199ab7f933ce4d3b6a3599e756263c026540c6b97b0b74bb1576bb39f79b127ba84c2c6ac83a7684f3f5f9826de68bd8349ea7de5e7f9823b8dfc8f2348e9b99d7a3c1d295df76dec4753dd61c00a6eb803d50b60579edfe24b2d04cbdd2c2245d42c8cd071fcaa8955e96c7c60d010ad8ea1d764a0dead21c00832f7626c46b6f9ef4ce5318a56dbce35479040ca0b85955b55f2bd55e7da611240605a3b6be4e1e2481eca2d4bc111238ac43d6a6841e503d0b38fa877f67ebeac8354915a5a31b303e10c9acb597945e7ea071074601d4b3b02383cb5e0c4c318b164fdc3a9a93e74a891adfaa08c598bbbad6b3643fd5eb7679e8a5fd646ccd35b510dcd6baa894d1f8286fd2091093e1e9eaee29e90a21e35973802ee674ed6ee3c120bdd098fa2c94bfe1e603702b525a86c0d16f7ca609febf0ff618f09512e564fe0ed5fcb8c79e2aa031085b7854aebdab100af8c456d72c645347047c691405b81ddf8be52337e6f34796b1576646571d278032ca5b2d487853055f95b75aed1a02ce403dc4128e96579365850e702d1ded342f7ed1fe7f217c51e9453c91a94d4999b99c96f3f1936cd60fd893ef61496962be8e7265bcb832dd22eb01addf83e4e51623cfc1fd6ac39860cba4300f39bb668e417827ac80556132466b922b315c050b451be4f8cd89150d3e7b8239b9f883ac256bcfe4ab55aee94157548a26b30c44bab75a95c0bdfaacd873bc3789b009e5e964fe41134d8066cdbc0b00916929f16cbfb839a861af8714bc71c33a1328dc04e7bd5d694f1b0f094f06f534b6bfcf780c60dedee5e8be0fa0f880732eeac85fa35007494447aa445cc8c45b5c9f28e69d211dc1bd46c9a602dab0b878dadbd99fd9caf987a3bfb04113c50ffedf02221f1610a3c8a24ee62d51d71d884fc3aee03bbb38bd60a13f4b6bc6eef03a6b6aa4e57286bf52a24d93811a18680bd2cb4d8efbf1eeac80a692a0a97975caa85d747091ff6696be99153bb99f9743efeffbdd3114ec33192451ced3216a1f6e7be98377845f57a60967b8e00e1ebb3ed535d196c9a94fa57f3bbe1b60dedbf3e6097bccb1700f98c90e4e68ed21553f4102e7f483f75a88a7f23026e94bf2595a5e7e39ea1c2ccc6f5e6759122e3e71234ee9c40c3b94ff074d9338bdd1a3c2161cccfb0128eb65da4ddd21cb4198b709444be149ca7072f7a48120717eb4891a315642427f0bd9cbae262511ad2c54b471bb0c4114e2f55a47d67e304a623e205d13709685d5bef601984ef57bccaa5976f71b5def0b0ad9414593badfcf9393b1dfa305a6240295c2ee88a547695c95493b642e3d50b61872c6238f9c40a0ab28ae8023e236b888ad01658599add22ca6f92a82520e4826c781c780755577ff3b1ed25983554f8036175c8323ae9166ea56534188c9bb8dc8b8fe12660e9effdd35190e3206affb79ef4fdabf32f81fcb109acb7b2b6f1ecf9df9086e5ed3685ff96f268b3012134f3d558cdb0e7756e02d745e0071d7b0864ae90859c9e802417fbbd59290f26b8e1bd22181e176a7e062187c31d8504082f2205d17dafb9c6c880a1cac72385ad391e45980d0788d139d723801ad63d26ef3da8295ffbcf9a90864c53535bf92a38f6cb6fa1c577fae1d084e026d3c33d4e40d9157618d33b7de82b847a9c0244a17697d35da4b80f813b6a7abaaff4ecc55711b78661bef6fb512fb35688e663b00a8567f98cd56adcc88efa9b135873c8f2d1e7917ec02927421b0b9a8c52359f0a8a77b02f5126e1fd70fd00edd658338a218378f3fc7181fc53b4b6cb96346c71f7c5a0cc43dfc89c79c333db4b178ed567a8a4a2b3e1f9124abcec9726fe6e491c0a565717a7353cda323711f511bbd427cd3394dd51ca67303330753e062db422fbc14824e1ecc0b74d62969768b8000db1e111db92f475d5e4c04e9e64e9b9b9968dc1d9cae04dbdedd4293a3b4bf077055a821376cda8d19abf7a38447884b335486ea19ddd271b68254f6e2e87e8ee09f200070fa1ad362768e63a609af48d303fc3dad3784e4acb4c365b7c6163147718abcc9f179afb2e27bce170fb57607ac059589d540b6a4a7728a736d99ddacbfd34181c3c90fd4c6ac047d0f5cc723f3f7aa93479f27fa598cddc612012ab3a65db8a0146f5e8d26b867905e0f3196227c6e6297e4012f5b80e1342ff6b8f1c1431d79e180929ab4c9fe2ad9ee1ed01ef21b62dd33bd3cb0995e07485fe53889d83c60bd0e4f0b12180b827d5b77a81b5b27e581febb5136689427b6725925bf626fe605eb13125b2248a359fd1db3409f3aea1b019cbbbe34b1051a75c35d1417fd64b4ff148c01e130b44f419cf8ade8d0aa60674ba943800a900bd8efe47bcbfb8d7c0a797061719508be23eb1c3dd2797c99cc3eba033abd20f26e9825ca02f9acaafd27045bb201220786b4d78a0a04147c176642442ea2efb82bfb9054e6a916bf7c9d00fa6a605df49675036f75e7ab4e88319e0d08f2475b889c161c201d338be82d4e1c3be3ca222c703d8be077381ecc71abb21389dcc96a308501a0c35bc32d4b4f3e4b387492656189ffb0666b9b4b5832669d29cafffbc4e2f86b62f78f3d1385bfc6453db993f33272c8129294a8761effd6ca19a61d261277edacb75ed122c4c959ae7848e18c9d61d01f3bdbd83895052107028b8f50aa60d3baded9cca016f4b75ba4c60a01a35746b0b0ef25d71bd3dfe1735264c31d3f31fa88d68bf297807166399891736d6fb5586ef13c40ed9a16a5e2c90d44be2e6b85d5311cc717c37a5083df50813b25ed3bd79ffb268c7c8a4776c78c2bd02e202a4a87cf3df470719478aee34facf5a3aed7ea967b7fde3dd2dc9799b06c0d0d7aef98ed9f29fdfb9e15b31ed59b57deb4e99dd378ad5c0206de9eb1702d13b2de24426efb9acdf51a65f00cc6d176ca660e52d17e96e9b8af1e7874834f523756295f09e8a8bc05b655f75e567280cdf5fc00ce81c1b645e1a43940a55dcc653cc23e4af10a5c96c89b3c3c59bf8d00cc9f9ab62f4f1fcc848b7654f9f6483e5553aaac88d19c41d08e31422b2526f2fdb352a4e90d697a930e20d4934de9ffb1dba3123fc49142caf5b8444d11c6c057609a8668a5d5ed49f659156ff6f5c36833d4a7477bcb892904173a46ba0fa2996837fa2d11b63b5fe9e7eb7cf52538df8dc64c9a8ac018d1ba15a15f3b6813e2c9722f0c886f52663f7e75f5c9a78c616be3f021976e6561ac9f8c86a7ce2f34a7cfed476daec3308157855ea8858d454dd42da59ff4e787cbb437166768a922d92456534eebb50c8fbbba576e956f08c6ce54298f7fbd6305e91d8b5211cbf55fef96d0ad39ece2c2fbb4319c39f4aa69e84c3fb7ea16e0a7da1cc2f048bb62e384b4858c6dfbb619a37211956f98b5ef072cd27e31585e9a3d36e16e57f81538e364dbb6eefef6494bed835b866c75d5958ca874e6406d63d5ddfa314b1c6c2f69b46f52b86b42c087ae8390554cbe893efc3f72a80a37fe6cfe0b5e8fee2ca3a960cfebc49797834eb4255b892f52582480f6ca5ae26a82845195881f8330154f0cb31da485ce2d8930b9c942026e623ca22aa73b767c60156c478dab0cb52921872900123e24ab112250ac542b8649ceecacd9271d8b7d1021eb90cf50c09f7524f1b303943641e6504ac78df0e58a81468ae643e1b143ab6a4daf809987ae7f01fdf9e7d8ca982ee8988481eacab5d5fb144ca5858cd7c897cb2fc7f7fd92ead6084de00f70bde5f5c27accc8555c35ef38ea76778cdce7479cbdd17f08ab660f64872f4d6eccf7c132d4f470fc9f3a3b35de56179a0fe150d6e49eb17f8ccba31062fba69fc7369af57a58795d96b60a31e51f531b7572c4a50da6c0fc1abefc42f2e554b1e2b1abf8fb4bf74b433268ad64a6cb299b8fac79b826531a3815e8768b6dbe2f658b2f5f06902d6abc18f844e1ad6bc2a13d54c0d9a0d24116d9c0d2ada75d4646a287d85ef3a5adaa3d51845e2ff2a002a99d275022bdb222dc5e8ac9337d457bfd1dc335368573a336fbfc54137e2f46ac506cde893737c212bc515bfe39ee398445a016c030a85f794b6c65e98222e3000fd074bd9db122f640f7161cf3b9cf3c68097542f0fe5f7cec39842a21f2c6c24eae26d7382ca2f9a19be25decdeeca5a0c42897aa6acca856fb25293b606f3e66bb0055d1f6063c485bb8307815b1b06e3fcf499853007dd0888e2ccf7c979ddd802b1731c73aaf8a6dc71ffa53d36187931fb279f927fd998e978d63ca7336dad49fb74d1e38d25e92b7b92b94322e9a8e5e110c790da8ac576cd060fe8868278a5174ebf059b4bfa164509bdf935011f33a11ba13826898c2d7d8219ee8b3ba561a43c29539bffe0b463585f9653fb2c6f8cc336ae3962e54181df9034c469028367a241938cafa59d55ab43af88d3d04f686de0ecbec2dafa48cdc9fffef1be1b3e84cf7142a1d55920474643e28ae0be78eabf1a0ad49339b0f33145a24e6d6debaa8e8ed1ab54377892ad145c9e4a9325a668fec0c3325ca33f56268854beab3dba08bb488743d9b8d0f806836739419246faa0d98fa848035e9d6993aaf0e2ed5a688300f7a4980ae74aa94c8ec68f7d2e9c39269683a6a17257944bd51fb989f6168b011b354173be19b32db0e57354cdcb77012d7cac413c1dfa81888e8ace666550b37e68d73937792cc6c8a6855944221128e409f0b7e81d76dc1168c10f9283cf631cfba4f42f9bed5e4b8327778883c226523054a4accb1dc481d12123acdb689c198bd65a1ddb52dbc7c3d2b69e48d465cdeb7757bde12b62795144421cdf7846fec97c6920ee6ac280fee2ff60c828606acc7b90edf0177791986db0ab90479c425f06580f69e650950652f52942f673d56b22b8e24b0f565ba95a0abe818bf3ed0ecec77f333bea7fb1b54726a991a3815f3811029b0819562d2956a2e25b12a5c32deb70b1d43f28be4c2d232e8d9beb67f467a17eeb691ad1aa73dc9c0bc8ad6eda6fad8a8ba2b465dc1a9709e8cd78813181fd1cc46298454498b5a1c5b8f65e3a0c5ba87abcd69d2c4bd7b12b9b6406db1a90bbd8cd8abccacb0b4bb0adeb2099ef362b1f800915e0b32878af48c3079a345c0a8eb9b9f2c3f3685bba7f8dcd97856e8a239227838f3ff455c4ef49362b1855586e3374c80c8ca5c6fd9d59034dfcd1843a04d867f1b5b94a96c60db15e08c6984a451e48f89bd2b060f9d900001ede82a0fa743cb91c404bc608106f80232dfcc04e9ad11c1b36810f09cb249cd01b0a28479699392d24aeb937ffa44531cd16e942243f0a7ef7cdb0e105dc243fb579cb4fe334d7fbd77e5c9d93819f822ed32d736e17f550e7f2a00ee24f4c56d7a068356db834b801e728e30d2123bfafe98361f717dadf014d41a21ee317bd5a60c09b6f1da2905f295db649ff09f0695a0f440e5f20fa81f718f428a093dec463d7e48d163b66b26744c614b90279e6fce5ef122f25078ad815080d651a06cf98b6343c3490879440acacb4c18ce406c64b8acbe12006bbf0dd6b5d44df0a59d2841a4e8305d9fa439b341ce4e198824ea82a1581614d925d0922cbbde42d49c09e1ecdccbde695b0a24e2007dee64a4d0df2802309cb1ace676f2b621b5da6ac25f6992991fc09425a1425e6889cbbcbcf0321824b7ff149101ffdc21648e9f129c85d8b45df7230ce8d8e3da9fb10ee3687e46225b80a65a6836bbec1422187dc02c7d7ed9d6f17af56c7629e92540bec6860729924e3b265b11773e1aab78e239554da087354e5ac797aa14ecfa9dc780cbc5458d28aeb3f60034817fdf240482d148164ed0bd50e0e575019fa50612eb73f2f1807e4a7d854da29c80e36bd5c36f861f364b39f1b25125d2a2615d4c12e02f14a5dd12de417599ca3ea28b3d7c535e6774bf82fd0e1a9c6c976dcf65c7beefb1d3b9d2011396058be17b2bfcaf8515d0370680339edefc013cd10e47cab25bac6d3533ef73d82b02da192355bb352a51c9c7bb8f03af37fedc883e5624fc4e8cd803a8a2cfbd7e9919d399ac5003c365a20a88a579d0d2e31d13c843e8b4d42c0346c3afb3b4d2d80358461e480d8bda60d822d7ef3c8f59a5ca09660f51b754aff6435cbc53de9df085178466967736d8bcbfe243daf273aced3afe3e0b2eb896611e0cb0b9b9a29136abd907ef45ae1aba2fd8e41b88017c1dcaa95c95910a550f7c8e2608fe296bfe23c15d000e1eb37e3c9ea812ffbcf5e30e10ab5b9880fc1a53b525b1ece4bee43b3b476078d2d8582383642dd2b23c6fab7e8b4c6be15631584bfe790e6929410003a6b4c7817f1f1e45efbb57e6e661249aef227e6fa9e060ffe55bc517ba05ccbe1f5fc5a5e9254bec42bcef7a1ab00d4a80b1b50fe3e32b7464c88f23708f5ee9458c8f42c0f166be0b34b319d8df9d4f7478e028ec16352a49344c4f03ab919ebd44c7bc06d80528c67f3375db4e11849c3f7e2ea42edb4642be494273706841d18001fef2715936442b11549d711051324731088474efece20b235efe6843a4cd9d9f52602c2769242fe5c8f85bb0f91685479ab22c0c6c2ccbe0d2cbecd4cbaa18ae2290e0a640ed8dc5a6633170bb34c0595b7f1e7e362cd1ccac8e94468daf393e4e47124b0cf90dfd0a86ce7d32e9cffbaf41379b64d3799d6a525593f2bead8c8bff9e348252b5538103b5feb49997b748c5df649dcbe90ba637624c4c5d986ca9b41eee58eac47e51fa2ed897bb4c67b5b2aee201821e6da83033ce80c5f709295e53aced20c33a814e2c34dbb6a36cc969cf574291a703dae70626f23fcde7c0bf97851d6afece3f6ce2c8c54f981733d3ccc574c15c32a8920129ef3357f771113a5542bbc9603c76383b8b6d6758d9aa2b004d3ffab75ea77ad31a7812d5c45e512faa00594aaf3070b41351bd099b814b7b2b9e4a42232371161e6967919029604d7bfa5dee08239a718ebf0619dd8266ea292ec5ac9d56b8a3d530a77be25762790fb1186f6f755820e5e8fdd36f907a0c6b42e3a6e00368dda06b8295e26f82e20168a6d71e15df027b111ebc2b28ef34901c7a506b28b2ec4247c2552f0ccfc5384c91184dd39f554c549a720f313971627c02d07cded4ce611ed4c2577bd55930951b06e1cd3001ee5ab6c96d68d3375f8b7c360d1c39afa52cdceadb69e15922bb86125c64a600dd51c36fdaa0202e16e1e9bff129020aad8eadb88bf0163682ca5fde9621101e80ecf99b163efc7a4ec104f3f7c4fc2dd6e357c3be2a1f94348d9d2878b3d5b0124fae599b2668662201af7e5396008fb5f0cf48feb212a14abe25669f10001b37bd4029d8ccf6c878a8a6e280679d86c5dae442b65892d5dee55277b76d273e3b073c7991e1ba2ed2c05685f426520ae16eb2dcfbd64ce54915a7a929d7d5b7aad1931a9b4e5ddf663ff67db05bfaf2be3870272218950df9c2e370f94732b34faeb8d47ec22ab5be67e59380940ef8ea4a8f13cde903f1a224dfad0d3afbba5fcdd7fcf03be2afda77dc78f6cae22a887c9a509c979ba332b047831d18cdba649a724d2be5d2997014d9f051ff90923064aa8c551a9b813c5d8e04d04365988a5a1618cd8f018b8c638819bfc165ea65513bf791873a5aa0dbb64ce8826f84fe89d4d96141ceb2c95b2f5714d283c98d3321a3eb706ec5df4235ce19bbd25781db50abfe899fa9f5f5469bbad79529d81de6c5bd5a9e5faa8b6128c2469eb84364f8b0d59de0706a48cd0baa768e66c03cc78aa7fcb74e748bd5b141e1a08186160a90bebd302af60ef7d750f5c38f568d41f43f5322864129ef7203f6b48a95a467efe4d6011e5464664992b4cec7f8dc5bad1b01fdcbd2952ee478dea772c88a60ccfb4b0d89b01de47a493bf6bcab2a70c2be53ca264a87f676451b69a3aa36108c58266eab79d358e3d612545ed4a268e065cea38e0c526301d27dcd4dbeb1c33a1e5bbb79035ab993ac92709ef70b808712469567f8460c51760ba5b401464025e95b2f031c189fbcfe05a922bbf242321070f177fe48240c4fa564ec3d49bf5c63101128bc749d7de75f5c68541327787f06eee0b3a256eaa3f52c42dd7c2a8b358ec4e7e99f6fb89a218290fcbae063db0ddcf913abb4bf221b0e22df91424413b4454c908d9ba794be03e4dd193352743d84f0e5cfb99f9515ddc28401a5a327305dfaf554f0ad5f4f6bdd81a1bf3ffc386bbab4e41a8309f5d038eab3b79ed24ca3f21e9b27f72e95c01bfceec459631ca018c62118536c5dba26c8a7e2e788908410d352f636d1610c0d6b78c50b1359e735eb8a7af37efa9b5347cfe2236fa1673dc02d507be5689c6349b9f29fefdda62c71c4a4647f95ec5733e1b8f16af84049d5a2cd1dac6ff8a436fbe3d9e5457929f33c74c620109681ce70f0b6a6ba4e2b6486da9cf34dc2b40ae454322319af4821ee4b0ba8af4335c4f3bc2c6fc137b404e36879a8cb2bcbc9a5d7c24e66c1edf8a37d0f34a54f002892cd2bac32b258484be4332e2d66965cb6901810f65b9bf00f779f8e62842a6798144278b6685fa50d39be58e35bd8283c84ed77b49494bc620a6b9ce5fdce09fb1811cdd354a3e682c5249034ba233372cbdcb4e6c4cc24f5b53b975c18a68e3922beba915b3af728bd3de2cb6213fe26878ad4a69313010c1465d242de0f952e9055c2bcd0b596e31d4c29ffb3de4c47e4a6ffe853f01f1a22c250baddea61116b919350e7e45e01b9f103e91ab917d8f2fde407cfdedbdd07dc41ee38ea64b798a73110e3bc43751381066f48fe64bc1e26fb2ceadaf3331246a6ea20903dadd214dce7e9689f750ce299a35352a4062975e5426cc71ec37845b34cef70663eee940aef5642a7eee69e5a706ce4be31c97f5fa861385ee078a0ff12afeb242022c4968143490506a9151a0f74ec3f34aed73cd02a5e67d5ba7c68f3675c66681aa1576bcbdf0b3685cd8778ad25b3573929ee2f8dbf0b1504073f6283bc03da9d2c829f728356478ec151a0102bed56db149c356a8b3ac98796c5ae53ff61a28562182505cb4fed766733be384560e46387e5c1f9243a07aa755647fdf2a748fe99c7fe3ccfaf4f210954972a3868d5a687b180b369032ccd49b6326772b5cb5263c078a72fc905c31cf4dc166c1270185f2e01bb859debe7f2d3d7cd9ba3a9f90d15efce30bc3bedaacb3dd186b46185844aea5f0785c5099bb1584d79050e644affcf55166e6f428f207430b62c925144167d38b8ca5a218f715839bbbfd83eac909bfdcaeac65b93c4edb862dc7b96a59d3be4272fd561dd87b3eaed046b483413434b4010544104757a1a65b882b0e1ef48a9efd9b8fbb3d929b3ab3c10077a9d6251663fae47e49bc1e7185d8d867f5e3e5c73dd4c84750b0161a570243f7b6946b5b999a88b8f227987a2ba1a93c204064ea31d86abdb2c2e46bb9df0e18b1c7c03eeed630be33c073fd3293c587bb7098a53d8585e59b8419ae5462d41f81d28b9707fdcd80e6111e41f89aa01287e06c307440e1a0acb0b9f507a7d11c461a772fb8973be4c12187aa3548caa7127b78b41b91d15dedcf27e183cb46a7fb23adc21a4764ad217d832ec7873410c448bc2cd1c5efbd84a7105d8d56ba74d2af34afe71129357ccead73eadd89d8b988b5fa309004820763b709994df859fb142b1d49ebddfae6e4e4062b4dd0ed8443251c47b92344a416fbf95cf58298c82f0649ca0294d5c6b71b617b8c037d32adff75ceacba6f036bfdbc6e439c668e3f7ae5b79b9a21f297253004c975eba80a43cc0db3e630c36c88a3dfb29bbb5293ec568bebeb017f13762fd8e5e9bb2a4afcf4f9b2bfce58a3508e78dc2bdb3bf44a31fc9a772440d266c7fa97edf2260d397897395fdc4bac2650f0b33db5a42c92097a958b1d913c51da902cba7fe5d0f0fc0b7479cfebd365098e30b3b412d50707c5bc49ee62769efc07a1a8f426f5cf7a982308dc75fcc7c16310fb3a80db4a29c636194907d86a1b3b17ee2b1236aeff6a5912a3a9d0eb0beb194f7cdb17b86b6bc1ffdaa008385e1156e02579a729d9e5634b0939ecb6828633c1a5f3307312b5ddfcab452957bb3e8a917ba80ae20fc8cf25b5cc5baa3e82a8dccef33d456a1e909407dfbd08106a2d7b5e3f883482d48b1c924a94f9d16771e8c99f8575399c3bfdb998bff669e3c4ef61054afe3665183f13b542e50592dccbe4ba7dfec13c06ad92b4891e24e796a95498881f6b86b766e264e90a7e8821f97d30965350061f0216939cf92b7599f4ad3813829f8fcc8cea53fb7312bc4fb0e4cc36764b143384a1152601ed5f8d82992edfd90f0c9f4e47448d6ad0ce700f6bc51bcf5c683e281a705f60ad3c725aea697e69246c77b2c3ac8ec0944b458b6b6b80c1c03b1fd3d7d9cdd295d84eeb27bb69d39c96b165b19d17536505dfe7f03aabb0ace750daf0d606e5ec86f7b11c0c16bdf0d6fbfba628bce94c091d7f7aa29dca2133bf9307e9792862b580d4a1014200d1f4d5789779e9b695f3000280fcf1e07c63ae2febc7fcd51cf2296ed81ffff610c8d80f720a91fb1a5396ddb108b42615274911e0e60d651c745165da6f4821f99f712542c7935a0166adb93c811621d191b71a59dea4270c9978e2ef954f787ecf466d490576b01e6f614d28bf3f2e70b2df8f4b111520af6a6df186287a7c813154c44a1b7d0bd78705043baa88304c71cd66bef1806c95f37248ff6d5629529e3a093c8ad3641385feee90dba7ad3867d3d94926485122bd3582618c67ad52a6d23a3f7b2340dcb82b093a23461cc4a8a3251a740767eb3d13590c7fc7709ac9396404355ddf90123681fcade273b1de876f5025494876ea6890bfe43281abb080ca83439c5593f814f4ed9765832eee1f608f9ff6ebeaa38c95cbd2bbc750b5a51087894a482ddfc53cf5ff2314562da2308a9de9b54f73e7063c16503601c60464b1676cd76ef16a162da629df67bf705baf9978cfe7e68f6d174773aa8ee91bdf9688006e85753d174c8f74605b306d1a2f1d54d2c0acf7a781ab0ec49efa6f5990eb068de83362019496492d22eadf3a1c76955df65c4e8e9fe4964d756c87e725bc0142f141cb88cc934173785fbab29d9180fa59d30e0abf7bf99a7bcd34d2da8dd54f3d253c73ee6c59b6f1b176aaad5e1ac6bb7565afc07d824f324433c6174de6278e27d31d13e59378fca65bb6a157af5757fa2c1d9d5b96d3d99b3c793abe2fa3ae6abb3b4210fa263fe50effe273c1f83eaa1e12891c850b773c3fb83329e8206677958fdd1652292267054dfaa9c7e1919ba4585a58888409120da36459c8491cbe97a2665d540480688ea507164eb2661ae4101cd2d81401748ace7d7501597371fc983c2c1ca99983bf00cd02c78967ca0b12900053af1a6925a51f5e80b424e3ddac847ab360dc0218f3b7a959083f9dbb914ee4c034676f21595c6124cab7585a21c33b4212953911fdb36b06bb01bdab95e941082003695a16654def7958da663b1c017687b566b182ece9669afa423a03a6b9798afa476a132abbfb382287df863130acbd4e0e900902f2d2dc03a8d64cc81673f8e2e03ef9668831661796e92a08cc21dc8aaa0d55c15672fdd9fcab5103b3b17d3f521f0992f711ff162d344d87c0886a74efb038a6ae5bd6dad47fa95fb04f9a9d84dd932afa4e0815e6fa19a4cb952b2a8295dfc34cd2e3a30c3303552ccbc6f0c26641723f4f7bcaa8cf8bdda53d833f60a602daaff3430d81145f23706a240d360855f882750820f6b2924fb79ff9a74c16c7178061986d7219d756db103b16a0a530172fbb71144a79bbfc409944b0fd2926c8a828c176ef75b6db1168910730aa9f82055b333644210e3b024e595597d310d2925efcad4b942102a60c80e6e7d544330326f692bedfc76c9d9a869b15fa409891b4852525093632a64072bd805e0adff5af58b4f61a3eabbb196f03d442ae2d9fc840f753badde5905ebac817557da6d078ebd0d07b687d3895ee264b632695bf535dfc1bc09f691df2aff55b24ceb91dfe940b51d3d1483275d81f13af1fb88cc8579f103ee19b3a7895bed4a4bc17f078f88520d7f75c6947edbf63c9ab9ffc70cb5e62de7f8016b833b4c1ddba9ad019a81bfa33d53d599d87984e021007d7e15f5cf1613b2f32c0a5bf2c5690c09dc8d253112d4eb7529615bb5091be1b9d870d33893a8bb012626b2a5ce49561bc4b6872d8aa60972116ddd8444822c96fc2d67b0d8a04b794740a0e979013ba179236730760cff0cf6a126b360b3cd7de42e1cec4d28a7f9ed9127e1661f925d04e3904474fc99eb574354830d741320f784bd522993f93a5ff4a66de03206fef1f8bcbef23d6aaac5d56cb103b6664d01a085b0304bc5eeea6426eb07cac3ceb8e544a0ad573004ac8b6fa574f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
