<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2c8c1489d5965c7c1207c381b26d4d563a4f6f05203f78a478b2e76e048be4bc0b41a50f74b78d9eedd96601e12ef2abe916e6cb4f5fa06ad0c218d10fbe4c65293ad70eea9c97014b0b54c8bf224fc535aad5c9da84c586580c0849abf82cc1931a195680e088d02368d4ba7d7e8f5def8041101dd8449becc12a73514bfe4704bbb5920a9a483509f8b02084477e04c1d7f568bd358f8774f663a05cfcf42062d47185196d8e3eed496b6563898373b9e46ccc405895104cea9d3a925ee7481f2b54e880201c4b8984f57f4215dad11bb9168673dd3bbc1e934326f794e76b99a31049ff07297e91d70ad46ce7ca1b233b2f1b994e7f04e907d2715e3af7095d6369fd37fda884d2d7ac7b6491cad88d51772761e7b056b8a5a932eb84ede751fda2de44b33d6f171ddd9c105a376cd44fd2156d398d21f484484538c1c3d7cdf7ed55bbd0fffba72a9d91b81833af8f61488d22a2369fc0eaf35dffa1255eb85d7ea89b4b32a762c832c890d867ceb649e8581394cd4521b625357cc44f53f3d95d0f3a0a1dfc7da4ca01163d5958360df7049e9d164456c7f0c1e84dace8238d9c10faacbaebc63ec910f880ea7ce11c2ac54adb0e48082b4af97814413b32c9382d0236d6d27ec22d56b41e621252a60864c5723ffe07a96cf74e30d925573a3cc0b509937e2ba54c5c1ad01fb6ea40394f44128507f934bb06e1f356ce22aba3a5c31712109f691712e7c68db460faa35fbacdf98d3406c8070ab3a6f0514f0c80abbc3d987cdb7728381d4e3d656d50604a1c41a579e94bf231e84e7c89eb4e82727da2643a2dabaade7b2e2a69dbf7ee4c4ed46299b7ec948fb2c7f01d02d955ef006f41777f1a8beb1c66d8928d6b4e5bed9b034e1fdfe8ee868b537fd27c1d8be671991d83789af71bbd31c378ec48df5a5e0534381861fa01f6417f66ddf8fd2045a033d1e9e629c8d2aff7edb731ee8a071f09a50eef00627c54877a3dd7b6c9ba0ad135230f41f31f4c3b6eeda2bc5b5ee52dfc9abbfb6dd17d635ef2e8e6905cc03412c0df7bc149b75a936369b2bf1466ac6fb58ab4a98b1a05e2680d0745ac0875196cc00989753861f3087a0967079910d84939effa61a6e6e8d2376f22685e4b5bdd12d970adb9b44cae19731140f85d593b9466ff506f66c32b161b15af2f1d8fb1971746c105448d965f0923583be10d55145e83d1c7eb03fdbd17f7f909d7af9ace19a90f1e33558bbaedca9e2596932308f2cb7c250fcf982150ba0db9f5974ce2d1dc32cd825140b98fa8fb36ef781b02d7de6d30c8ac8c16448b1d0b21f9fae42ae1a54886e6c0704fc70ac023bf2b5142d5750e1098d786b920172621095ef80577101bc827b78d66050b5d3fd34094c21cd90695b11335ebb6ba522cda1bf3dc93da634d23d4b598737e797620545bbcccc46e43febb8da81ecdf7299d26e5aca78076073875fdb1a64c7a5f13f0f9f99b5600c67a72849f26a9cf50f93de150fe9964f86fdea553f3640a5808b44d969bafd4ec0824903f0407ea8b0bc45c897d2d1b041f014133e1ef6a1ca4a94089bf6ba691e0799f0db3f851e2841e52b9d367f0f571dcc38a08c56f1a91354a9da3f73f4d2d47b51eb5d3667546e991abac248259c5e16654a7b2a5f16c424282cdd5528fb0c2e128226025b4aa22ed8cc02e5f4d63b34d43e466a8e78a768c7e408f9580c28f6774c30e6443bc3d7b99d57285279f632950bcf019879a1781cee290ea32cb91e4c9a17763ed386e233a3f46253bac24d4a67a323a436726d0353bfedc631253dc12336cbe0ddee3e453e3a5019bc99cf0ca98adb14c01166979888893cf3a74fcd74ebb2b1db468b5ba22403167d00ac67c4cd2739c7bba555b5e654eb8ffe94a61fed60aacadc78c13ad89e553fa2a85a5eec8702807684942e07485a47b698e98f1f6fab285ae4f8446cc593a79a4425b5d7e4421ff0c3b3acd8cc879f84a48deb2844c2579d6caf823aa54e146c344f0c7b8074f923726feca859b7649fbe2c7b6f2b86c74fa812add459a4f9e1beefd0e19ef40b776a9a740071886af5aa83ac8637eafda0da9f83753ff4edf625823a07b89633d34d525633224ca36808bacc7ae53980fc44d42ce67340a7ced4a56b51efec650823636eed480f1ffdb4414471b3bdcf21915179f3062d36ff5034d1007a03087bf4ee0d931cec54d58548df6a7ccbed8a3265c978c9af1ac7ddf3eaa005127e9c9d33250626a1be06a350005826b16d405fdd76e4158516856a5201c50db60c8536c3afd0eb2ca18588956d3ca7b89ca8f24f925a931effef9e9ff4571e125f2a20bb3c034da445c3e13a1863a22d7fd9afa58a6250c623211cb585db06cb8833504cc3d20094f472731129863ea7ff6531c0d8d28ee36699d4448f86ee071097732552deef3e380c6e85f9fc01402edc54e8a801495751ef4a5404e9d3719162ac5473355c2a807367635622ff1bbe67b0568c8aa139605a7fa61d37024b897862deb4114c869415059a7410d1d5be967f2af0a2c1549a588a9b1307c7265c90c13b7ec117539a1d1263691b71bf5dfd0c7f225fba95b5cbb2257de113dbc1e77823c41fd251d36ad7ec180866f1a212a62ad3299722fab837a4f2d1af60c4e542f8622cbccde7575e03170bc46c4563233312995a6b1d5cf602a69902a447cb9197e285ea81fdf0fb5b9ccbc76eda61eb3949fa9218ea0499955696d5cb25f8a27f0dd5c98bb978751c747cf5fdd8bb9d1d4e23d29f4403e5ec7bf5bef55d8c792061b30be5eb5b8dfd6716fa3fe94094f6a17128675d7ceca579f0c2aa67aef1f5676bd3164de828618ddc27c6aeab360bd962ce6d5190ee5044036ad7d773503fa3e7dd51cd4b55330ad232b197eaa7d28a0cbd67d8a222a957dffb8c5ee35639093e713c9d37f88e86a56f6493e32b3e96572e24c9091d74a266d21a45aa48219dff87c7a1dfca195f8593638d512068e574d56d1dc9e1e0b27542b0db5ad7eb2dacbe6fe18f51b02efb0891ffd623589e67ee1c065a3901c4210a2bd6f5074251bf6aa06cd95e6024b8ba6e06d0d4a5eddb1ed28f871a9c31787f3653ac748031cce3dda81d7f94f3f43c1fe492beffb09d2f880084cd2e7a97319003a63244abb8ccfbabcfbb350533371651b56ec267d4b5c49bc50c2eea28ba46b77ef2a7512984d41bd2cfffddf9576483541b7d819cd6aa2994cf43f3930610f624bf46ee4cd264350264d9c87065f047ef873326d6672f2f896a341772499a9e6cce4e252f8261072cc4b248e264672d2b59cdb887dba7221828cd416db9bd671c0b597a1139b77d7afb76806b62d096b5f836bdd5f30a128ee6a3c4f1dd8fa19499d3c3d5faee23c435ac20da0345dda932be5d969a739747dae2cbfc25d08775b57887dc5a9e3a6d9858856e2cf909d53eaf20f02c526e71af83ccda30b031bc492c973cb07c3cd96b549eb651c6c1c60b33ee3dbb71534acb9b26fa4d40a1d279cb6a88976640e4bf3151fb7defdd4aaaece0864ecb96d8961f4647517c78955603a6f30d4a2397e0cd550b0d678f9ea18aec4d92293b6572f482d2e72ebfbcb674793bea70ab73f24e6f1dd5dab623e145aaf9d39b8562341d86aef707baf59f5434fa7cb365fdc2fd5dfb38879eb6bd33a64b3433425cebfe4ca5fd53b8bcd4b2929818a7f7340c9c9304fca9349f234a56c540c9a7fc157f09737abee97fc2d8d644ed0b9014813bb9f413614f9a79f56d7b8cbb36dc064c95cd037454d184274186663cab6d58eb64294718b8eca437eeaeb00c23f4633d2ba0da170cbe21161d94c2905f00c95f18b5182cea90f23a974fb4a4c536cfb3d5d792e58fbc68d33407454f46406ffdcf63cf809b0c68478485526e72dbc64011693030cb5041786aeb616d5f4b7c1eec1fbe5aebd319ae39d047f7ef9272f33858440366f79ed64b4798bcb22fb3791cb8bce033c27b05e5af912d1fd351be987048510c2416eac4c3cc7498f1352a5349d5c36c494c5ece5a26ed8b31b70a2eeee1b9f3265a7e82fea0cc5e48bf859cd1c55e7bcc24070e4894a8829ea4a97f5f4ccef588e9220fab91b0578f38ff4be5f31eb53a2aa4134461d8c744b23fa7d8e2b334bb50a0091193c2248b5d4df09b7f78205572149b47fb949742449442f8f63fcf9b2a6a6d630a29ad1c56d1aa79ad61e5074baf0c7ed9516888a09688f4caba995971803d8ab2375d89fe8621b7a3a4e212ce7b2d0bc6f8732763cc69ea1572e122945005a0b4a1a2ccb4cebe1f15431d84612f85ad19d94e44f4367feedadb398899ac96912b2b4d92ef11be0894cb896db60be8b4e0fd86176723ddccdc580237bd19f74f3ee8cecc377abb30f9001e703d52426af49eb8dbe34f926aba718a1eab61d889d25c6fa61e387a65c8c273f82604a12b126efe238e513736a8c67c8d021975508546f520172656cb635eff1c7f72724cc27fd0ad6bbf42cb76d85086031526603ad238f4735cef094841f3b641fa196245d3c808c3b341515002e731dfdf848fc19f9bd012fb22bbc5cb17427af189f5ee92ce97d86eca770a458bb4a478723e6d99b69529ddd0c243cddd11e77acd378a731836dd7440fa23e503e7629d4036039deb2bc79861fe9ec536f761e7c3bc6a75952b6ac2d5c4094144a1ad7c1cd50b61e2cccfdd28db3bd0da4db69750ca335ce4420551efe96fdab2ebfc1c52370f9a583819d71b9a1f9b71ce776a57a1c9a23834f660ce18885df524d2f3c42f34348fe4248bb06385a467d704b198c271927d8fc6ee674d4a61991c8416c45062dc440157deda0f9f7199ccee99490316f4f2ce3bc8d7341a9d50b86838e0d43432a446d6db1200d5f4c10a95bebf852342211773cbbd78486266fa550edde1ce31f85afd067f677b87210d9ee4f98a0ddaf18d03497df7b16f79725b3c8acc3337a8115b65e34b971165a57821cb8b0c8a32de73d6bde078360e639145d5b465e795d628d9cc5f76670a586e469605291828302cc02086e9b76905b71740489c6408b91d728cf81767f9d0fe21653a6ca368a206a78ca3ecbb3a3a1238c7843db5f12b11afccce7ec11d18d026e94ed79dc1f342120cd037885541c8ab6728f88a3937698c5be7cfd79f34a01ba775a67d6ca7b19f2ba53c7feed9126fc4567fd02a907a45879d2b55eb8f319316e2becf549ef04666f304145640d9fa57e4729bcff231ce9c2fc1596344781fdd23d3b773adb6bfbab6f2f474d0a3efc772d6835e67f62fa1f9bee3a45adb7e0e330c6e36649b6c4b65a3b757e7960e2578e65c3381754b1e5972008e7b65e04244ba0e43ead8b6ef20ea8980a2a2d5a15ab48f87f165995425215d96e664a9616629e834b4ea82cf4c58a6572f32d58f1f698a9f3bf616e41abaede284e18ea5df3316e6c0b0b6dd1413e9850ed87ff252c93b95259d0c74b46e6b425d75fc1435001967c664aeb0b256f732a702d625fd18cbeb49aa1ef05ceeb956448eafbbc86f02c5f63d824caca611ac569ecc29b5aa71cf665b4773d0219f79fbb5db7a87e75fb16121c5994d1974365c4ef80f2fe333606f02db93247ea5277ca61e0cc1c1ed39841c6b38938a8c0ff71d1a3cdb71d0070876373bf748e0e2f6748d7b302f74063baf9c9ab3496e0f83015c0e8b4ab0552dd590525da067dc2a57341630fefb6a8b645e6c6cde5c93cb369bc932d5160c8e1b5945efaf00eb06435085645cc1dc234667b75cfcfce4418d1d32e12ca7f1b621df2c71f2272c079fa65ab9ca85bff7511e587e1ba2d8f870a5c3dea579c4b777eebe1646d3367891896f4f2c64276e763ed50c9cee6f8d37a2f6a88835e8ed3c740120d0ea65e8f5803f97ecdea240f7b862fd20650ab11e5f93cef6b6978fd04de8d72d3fec4b81fc79d991421d5c52e22a44b773348f8e359b4235d231cc889f4b2615ef3966a6032981211e51de5de207c2dda1808d393e9bc8a337317e0f19b12b08bed99258e528c62f304a76b5fde4511059ee75c66d8ada6d1458eacbb6c87fb3bce444676d0679ef978d86f89a2c4b7869fce58c713c3cb6a6c8e2afadfa2efcb5d4affd63877d401e35a59f435befd426fa505083328f390908071141c67d164702a93efce4878d2a8022211363842fda49d781859fb0668132bf3687f38414bb4c603183b8e86af100d2a0a74c287a33abf28bf52e86ef291a4ed3f9cf72f6eee07bdde19858a009d3f634f38bfcaf1f76b603eed6869f9ea3dc774cfff9a2d495aa2104b78e1f40a87c4be2dc36852228c250feea8b0ee6da2f3254429b194f1a16f702c99062ac8138e86e94b06c7699ce17dc00bc51c061b8b71febdc33d7d1b59121fd6f9f9f3cccedef15a4f91345aa55217757f22779a648c586bc4848b346cb971dee2ef992c23c3c4c95e0a6db6d934062ee427bcd7ab6d4df56662760960fb8818040b0e07f781dbac558a93a0367a50544782b5eda6c66717d3932b005daaea150cfa66cafe4ccdc827771cea01a9be4c1cf16bd62112c0bdadb7206743928259a90da7c245a9c76d8da0e50667a9a442ca641fd12936eb0d32e529e064e74dd6b9f387f2cc26b7be86a64099a3ee6cac6af503c717e939ae817a584a7f4cc6e18a4869832a133ca114bcb0dfe628e0b4f428e19f48564539908e3705c0827c888d1580c7ecd33277d101f41dbe1f31b110b9329ab2e6cffbb998767c47061bfe5a40f0832ce14b1ce6e2af029f98ea70068ca11e7675c65a49655c0717130cd235626b51ba0bdfc78eb4eb643e45780aa82fbd4d97c483554a35c47e331303c9b88818f1450adf54c8e3a2fc603c018374a3f47b648bf0a780b0510f24a12d405382cba10315544b470882990c0c6c6827b4111da52ca776fff18557826113d564ae0bb4b289301d7732e1b7cbaddb2e14874a365e3323e28e1d2b5b64b5104ed35dd90a5cabaff5f23e47ec245955dffe25bf1bc1c4bfa9a7aaa241e2562f9ac403a04c35d762886f3df3e36d2f6eadd1b50ee73ff7e813fedd7340db7df61521fd24a671bbfa24d96d8a3c3fc3b97140ac98bb008e189767cbf65d805708a7318e4f33b880188157bdf278eec4daa41cb0ba3f93b5a07e40940109bd578fe1a530cfa45c4914c94b79c166bf791d5977c21ca262c2a8754016bfa98e5f1a5a4fbb1dc36c46db3161b46737ed0c9d6aa5bec7ad7f32ca0ffeb783529866d57f64ec04c2450f2ca24b0801d09f12fe358fadbbba742cfbf541ac4755117a8ee6d5d50ecfb77ef122c8ea075fc57344c69ebff85928687470e557410928eb161a8f0ad760f26af8d8cf8ec68000dcea6b7ce4a11c3a49ef24d2582e61342da2c885304457a540131eed617ed031c79048bbc84f4a7ce1e668894c5e04dd82d340699b86efc0616f63eb5fb9d8053f7bcaf40334d863223e9d856f3b065b603f03677cf26804723a1d81ab0a7598eb47ced27104f2b9b16a8cdb9e230d4cec4f83779421cb6820b3918aa2d07bce3c93e6291cdd78a38be4a5f4367a221a10eb9706965860772353df7aa7ee252114eb88b9e2fcff3e519413e9a538f51c4cbe5c08fdf06a370986d401b1dcf38e9bd201d7ad0f9d3a72ba968defd94244b294c2915b53d90774c6fe2dd4500a04dfce098aba0011ec795a44c495c8db4c47cebed7cd0e7e43930f6ba7830640d1b66aab57342c0cda8c10aa167954c8951689885cf85c0f1176eb4a9d7561f4265f7a4a60145899e3cd96ed8d7d4295079ea6e1281370785e4dda00bd60980bf16e568255b54c0cf91bafdc157c680735f3fbcf3c573373ad716d62a1c68b5ecaa6e46472ca70e2423fd94c19789db5781126b2a68dacc90fa883c0790338ddbf6e85e300b65f72d116a5be6c20e205943f35f1cdb42b2a322237bee3307ade802f0e5b1b659163615ff7d30378186c055238567d8ac8c2d9301a10980c764f8b5ea708cc8c4f893d96f6345d5515aa7bf4e22f10d656e36557b896c9aa2d33db4baccbd037fef589f491215bd2d1b20ef997440599e23b9751e02be6a065dac4dc3272e5e0631ed7d5e3ff063f079d2a889313b7ff3955de40eb25eaa3c820f60491360a6f551cf68cc935219ef2fc6c9789951ef56a3f6ab66c4f2ffd4c49500b464e75b732ac092d45203f339e622ffbf9447b8f5ff79bec034183c3965c2fa41642b4acec1e5cae8bc7d1ed840b93205e5f57c9d2dbd162d6150711ff43817f4d17385bb1c21c3582d222ef59f8234d723c722dea5538d3511161652a4f5e0b5b01f5c99f262ce263a0433e3af2bc3eb2f4bcc9957a4a7d911172a178e00680a7c10d6c63d176681f9254ddaa0ccf4a153f11046b05b1926f6894bb285b960ce5e774921d34eac8d9009546c21056aabc6caca38d1621606f39889bea15a0e8eb2578ec1e77d889e5bd17cc7b20d480699d69f55a84839827d86f5754189cf2ea14476e4d51b70f6a090c5484bdceb2e275b1e05cb7c100a86fb674001c59ff2e19db396c495455bf12d5d0880be2b901a9cb872b171d888591fc1be01b0d1ac0fc03517c86ac30bab4c2909c890345e6cf6f331646a9f1528fd1ad05089772ed3cc0d8fd8e0fba4b8182fa4f731c18463eb3122afcd9a7bdb9098d71074b9ac81081f66ecfdc6ba3fa0c3fb2a366bfdbccea710e6bbd3491d92a9caeb7abcc91ae260a995dc8c2295dc1439d3adb006135b70ef297f487b680f74ec6297713da0fdd95b6b338675bfebf087c96df7b0eb7ccd129c58303f104dd9a2abcbb4a4ea61fbfdd55f02c57161ff57b9c07b7e9eaea42498a70aa036d706f463766e88073a1917da042f16efaa7dc19f29132cfddb5a16aa5409b8eea4197038f4ebc11410c2257bbbdbc664a11214db5a42470e50524789e8123686bf43a1860cb9ef97de0009d56bdc91741e368e79dec2552fbd2947927f3324a56881d83b5c5cf7656cef7b2db9ce645ed3964ced6863ede9213ba60df6d6ae239aee90ae4ad6b5e0f08b2b10b62bed47472bf88bcfe8389333232cafe44b1af98df2779f491ac04c42eb6e52945af532ccd686716ad77464272348fd6d71231cefacac986b0f95a466ce6a68b1b64c46d64ad587e90782f114052160cfb8d9fed04d4782f13316ae478eee6c4098b629646c3667982d30a92672dbddd5f88ad300627606763a0e14f3b2785cf1a649d525afb3b6e4ceab2dfa0895eb350c34902033c0f7ccaeead8c255ce6c5e84afcf4df154e592755b544f7f255c48be1dab20b6df05424d39efab7bcad6fc15ebcea8f846d2bb8704537be7bd97a6cd97591df6ffc6c1235778c434328b8e0c353954fb1e81a9c4f5e269139bfe6edc7754ac1711a480171de755a59c905143173bc574f07446e277fd8720b365869e5ba42b3b0dfa7bdf65f8b4c68b08546cd5d4aabe07688f83c8cb2decea510ca90609fed054181f16be599551b660c6b5be69cfaf4226cf4fcfd8f37ef9bf340f87b3203d4190a592551ba6ebc5f50d10c09da2b2a15ffb446c108b3bf5bb7ff2572f487c13bd4dc2e1c4b548a87fcdb19d18a27a1923a6415f24a20d944a3010e4aa8feedb74d4f5cb9dd4aaf1a0e2e508f283e2697a0c70940faeef28f2203549b586324ad26c30a89190dc3dfa2a89ea66b16727f998791a4caf9afafc356270fb304011a302b7616d878191a22c996296dbbcfd0991390a83ed870b7fcb026aa6ac83c186ef51b8be163e439e80d2c33470033315363f95bd2ac11ba9734bc1756125c33002a6da487ed5d4d7a5ed7d0a27174a58e928203fb80dee73e6cd38fbd1e133e966baedc718f4f6677864b013e4cd5fa9fddd63663aa730931564fc4f7652e51fe458032f820d4927394960c6eb015eb3629a776ce1ef906ed774027b8b87a0edb0b4ef893daefed528b54fbd155b84bd609018080006b12d126d6a5e03dce5a2568d297af3e3239c233202857f0102d24b76c09cbdb0894e885424be3d2d7a7625a3eb9567b59c2668f5fd7040464034502fff58233633aad82170199346b6f0580cdac17706f6cf439a67edfe0f8f639d5e83e001ce6ebfe52bec520f1e6450fb8ca609ca6c02ae15f795c9a6ba6405c51ee2d8d0e4dc2df8bcd060a5ee1260a910e5cd946140825aba56d7b06d9edce99e52c45ec5a657897213d5b632247d8db7d6987d1fe316961bc9e8affba89c4a6e7793e7da20ad6ff7e90356de5c183c2058a0abec6b415278b5ea6e50608cbd1409f91fccee9e743615d7149cdf90a105cd17885bd8cd7bda8f7b23a2c678b0c3151b93f77c8b03a95c1dc21948ddae32d96a8b398ed945edcc3f181cda9bf7a839aa06c49b53bde00b95f8c892a708e7e330dc6324797fbe05b225c30849c201165e2d7daae33a99239e90d9eef20dad9e0b45fb90aa6e94bdcb03ffafa26a8930a77ed596f5467ad1401f3216e7745e6938b4a127d495986a3da5dab5e8d813b4799456380503401841e5acc62dea5d4f900ac1dd3687388797d28939c171998c68c52102f82cb5886e2eb0e3c949402507e55165058b9eccc6d2b822e0fb1144674095ab892463518611ca7951b3eaf7423211e3281ca671335e728ba59a2761e8c010bb87ad77386d8b0a2ef81a640b15c6bc6e6f4097d7d69726542367fb438f61731fbbfce466bb89c1d2d7a7a37506eee152bd14fd71edf28a697fd3b178a841469ef6cc0af89c8debe915549d769d3f1ac3becbb9807341e271fff1d56a447afacaf45743fecfda6e3c003730826e86554809a9db4f7ea99ab5e057f0f68a186d253fb8aef428c8f58fe3704156fa0f8ea575c212176c3fe9daa9bfaea9597af94a5f65754cdb643dadce51623894f92b4a6d2f23e59fdaea347df7715c507be3f536471cfc386302fc32168cd51cc7740766f548ddeeacce9bdf462097adb5b8c636d2c5eba72278222ef0aba3ed2939e21d9d782b2f198c94dfbfc92b9a2bce4dcbdb88180608ac7a4bb93a4913c0482875286022afd37a8f7322c45cf54064da206b5ea1b461e9637aad243207fbe5268944d74d3d8a21c0498c7d4e0f11c9eb6d8d35d67d3ecece52ee5aff112943be10a827cd642580838a235f1e798cecbc297327acd4d7a98c3050c4e5d46cd08001ca5550052a2a253d9681a02b3ec47241ff866ae78024291ff9e8cd2fbccc61bfd7577d5406d9ac1ebe84e88735bd191822803c9278aac85948479b28502d1f7c1f409673ac2e665f23ba79927af76afbd752bca8f5b635614e3bf309a11ad7750a71b85b4c6b38b715ce99792dbacf4b6cd5dc464bc48e4c08fecaafe610ed6203717d4dcdccf2cfc4c48762152d3d3917f744fb0c275b6ef65526bb554e5b9d96bd39edb57f8ad4903e88306c7469c64a610bce8a366828d7ac42027207ca628a688b7f883e9fe08f6e11c3bc4f09f836b275aa586f7cfc97ec8ca3d87e252fcc26e49db202375feab30b7561f1b07328b232204d9a32af7eb1dc423659d0330c9129b3b37b1fdc9eb25632d0be550bdfb45cd4f017fcb7c663762f5827e99806b5a039615c36c2e8214d37c90236b9f423e66425f113e15c2a02648e4c9ddd70a04d7517f7b57b7d78664c296156a2cc1cd9133dbb5f3207eb640672d68419355cbda9f241179fdaa0215ebff062c492ee6f568614b930c45b2d0f6d544146ec27ce811dd45f91409ff55db55fd79a5f65ee1bc60060693875893bc2701d521e70fc179769344ab850e53cf4062b63ced2ee3a377b91784145c2b6bbbfd1073ceb5606c59ae180f420284824378fc3c49c34cd043e0db78cd2832dca04951173a68cea4b0e4c68d76971bc7c9bad2570f6c7a1547b8778218395029b3cd8d6d1e9c3538a2656a5b432e16b46156281b257b0557e9ed23dc041d477472b0d11e503435c40eda4be14d0fe8e5dc0d89461672f218a9e448c3ed4dbc662316c15a369343931708ca86be6183e94258ed58da319c96c3be6020c64a82f7c3073c9dc7a127e38291e67b91314fe867b64a8ff9bf142c62c56f4eb685caf486722945d7a005443cd708ad9fe28b7a797920f9e6de7a6c7b465c7fc8d96c196a4c447027bdb34aa1cacf47f80b74823f7f95be20fad527ad4341c61f5dfc246231250573f49190892d81f632985bdbb49894a04f18cc3dbb764b44df38e3c12e5b1b558ad3f7a8686b4b906bbc67210a52ad112b34910b34a55c2e958f12978d0e18c17cbc7c9fe53777c08112525b34d8c17ba7f0de1bdad30deba567e0be0a759231ab98343f0c14af7c203597fc33d0d3d67809cae5b23956dfbb1cd4bb09e59e418b8c1bee0675744147e8e171b4e7f8bcfdb5cca4ffacf77f89d5466d58b7dd26078cf8fa72501c032bb94b8b17e365b2119492cbfa6b79dec6940ff665412dbbc7267b2e2a9bfacfcc3031dbdfb661c4d853ad61058744b2d7d87cee9e78b5a6fa70be6407c2d65bb45fa649abead9f3670d82757dcea587467819c07aef7c03d9023f9a15dbe110a5623f91542617aa36f872a13c9a35179046e5e89a8bf31db20e398a4471848870c58f5b948630e21642cd054d2600a9fc19e50b2baad653a8268860c44f95c4936e1b86c4fc97d2e15530e8a738ed99f13547d9026515c96a25d042b9aea9c8263d23b6045f97cf4681062164906e4d6f70c4fb8dda8e6f218040a164bd8c1f287edcbd7d299d7590f7116ab6e04a57e18fa47bed52dd0f388f63ac76c1e15b4768554b840f4c6b24588271a30787d9c7d61d330b189881288f6e38f9897b683959a71a5356acdec287b0b4151ceeda5655405f16bb904b7acc643629f718703b48914e3b9cce9ca7148446058a5dc40d90bdb657dec50b70655e7ea6fd2ac0f9a63d00c69bcdadb5c15d7e7ef35ab2657ad32d585835860785de86924e903384a447d7338ea4fce820d1f7914a6110e6072491aee20aa61a7058f4a63eb88f478274e6342595b80f29cddfc0ff1b965d395b0069c8b02aac11b408ee0de697c7b9120ee850c869e0e09294df810b35b6c5b04e0a8a8f1e16726fc929a1d16f8a32869b1fc0247892f475dfd8b2de1dbc40d2edea21f78ac4e0ecd36c2bb9dc829d120eb3b9a62b9288d9adbc0d5eb37718ea8fc92ed2dccbf81c19e134cfc2152c9ff4fedbe901651eee69b44f7dac3fc5f3a9f4422810364b919c753889caebe2239ee04841512b81aca2f1c81fb47c0a834b0069cda2425592914f77c731ba95ad4c66402f63ee3e59389aa2c561ba3c840497eb9d97b92176dd8033127bb1ec1662ab6b9321835a34a0bc8cb1896b8c44c52493438a54f65c4d7dfc25d062ff2113c52ff9189a2270d0ae4f2da9091856fed275af13b8052d22cbb92b15ab6f3bff01e2bd5ff6c4711b39608727525f64a702fc25f241513f32e8ce059593f2c387558fc287762af57d1cf57b9f2b18383aeb0660fbbc554fed89813a5478a5e41cb32249d776ded52f9b73bcde2da1a43340ffc03db5b143eebb98a210fd03b2c0794cd11771a1e752e232b0a3d92190216e46aca8bb48c2aaf9a0cf92d3a205b78aba8b7331d4651b13663a59e7ac65760d40df72cf68a52fcf577cfaff27fb39f5c83ceb3f0d0955686e7756b009d09b1ebc8d5fb9c5a6b37d0aca10690dbae70d874266e5980e411ae333d63055fffbd775a3a11099efc43b1c47df40acb8bac2377d6cd9cac7521501e20c94f650587d9f557b50e476f47dfd7dcb743c30b21d216b87b3d7148585ac54d6ace1736724106776b5f44e8826aa47f41d65e40d4074f3b2d500726249cd6c2211f1e39f3044ed8c79ce12722e2158b8777f49c32ee1f9205fd7fe0f18bf4ce878071e941f120a5f826027c683bf8f6a1918ab6b35fdb40350fdc22d18849104adcd88664d0fed7ca0640b675690d6308c7f0c7ec40e34a42805ac0348abce37e29dbc0a3f03aec481a0f9ed45640b8c6d937ba8684c4f3b384f9611a4f3478a5d96ccc89e8424d2f6a3e2d28f9c880760fee6f887c0e8fe0b7e9f9e5cb5dd00fcd8f5de6b587de459444f07b24138ec4e88adf9ef405c09802a10b1ce216f9d3519a3e3c0b585fb473ea6d6722c2359f25dd0cda8a9c960c89b5274eb8ccda69f11c4de4dd08c768b7d92ed090ec8049acc5953140ee2d876f7c87e71ad48c4abd2dfd61db74291a907d38efab6c3a4a6661931d67055b7afdfce86667119ecd1f5223b1cdcf86ef3efc3c561a93bcca3a87613bf8e92c3c46e613401ccc230298eb298c3c90640763e55fc1d767770de431235c4e3f2db8b734c49eaed2ed6bb195379e6017529f83a4837bc9aff7817c40a99b0cfa658973ad7dc1d5f0f120cf28e6cd1f025288b1ad7f918d9f1a4e4f238cd2696d0770ddf794418b52882601ca27812851d7223f14ed49bb47781d4ef3f175d80bf13b3c458ddf98489abd6022667e8f62480fe4adac76a50363191b7dd51f75afde06ce91fc86be09e79ebbf9dd2b9710323580e4b72e455c951e1fd7b961b5bcb7429cc8fcb3716417fa9e3be6894b6642e793e665bc1bc24fde58b5704b4d02bb8be88a6bc4348039c9785c8226fc8c59c792015f827a16d6e69165a51cccc53d2c1d3debb2323a11abc0edb8118e161b89ea92bcfd383e34efbf5efbd2158b9850af006747230700816d2a96a95d25c76ee85a1b708e6cf6e933e5f8d08c6cde113a061e6cecd5b66c9271d26b7aae5414ef2df4d5327789e99d96a5aae67bab682ede61a28225e96b6f465a077c0f8d4f75d8a65fe552cf67126cfd8b8ead82f7ee28a9217d6dfe6b7811de6b087ecd8387be97ddd07e87af56887b8ed47cf677364e45a8696e1f0f1094a9273eb231b9e58406ec053211ebe683a5f265b5db4c925299bd80ae9f35dda2d81b1b670109a4ee359acbece36f82a07f656d4e4ad156d8176a428a46925605fbef5278a4a3a1d85e111bda8bb14b46f2a9c1c861f266d705731004e68ef36d3629d27be9d713911e08c919b7d85e283db9ab10a9b764dea52f6e16d4883e56a596578bd100ae258b5c9431432111e7d71c2c81900ba6071bd40e69493a9a3a162136","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
