<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44bcb18cad133484d1d20a5ab17d191bd469cfbaa027a83501a5e3599a9d59abd0c251ce4f05bd6852113f2a8acd0f635cdaf21487d3f77cace4b6df99e15789fa85031650efd8f3fb85f353bd216221a91b46eea2edac40f9b5ca21285eb8119ebd4a8a031b0384d3a38764eb61dec5aa3e207629793667739af656cda6eb7937a70bfd0dda1e27769e514a4a86de7480f13fcc8fc06bab4aa6c8cb612471261371e07f083aa11ed990dee078dbda8b8bb18183289cd56e5dee29f276d60ed3bf29d8abbcd8f7c9ebe8bee0e38a798b731f9298e676c9d15e541edaa898a4b47d5235a84acfb412c051d0e6c82493d2265056aa919e1d13b645b6bcd9130c53e0e41c7ea03cd0dd40fe8195f3292d70801ac0579dc85e1099883061462b73230af1a49854599d6cf9997f11b98fd017c7a36187a90e2d4a6aa41e474013b4f0c69f53373a7421b9c2dd2db2f6ad130362d322adce93930fcdb34218d644ec7b1417f9a45efb11fc012cc2171182f8b065783dcd3d68a965d0a70b750fbb205e61b3f2e94f6044d7e92dd6cdf3335b3ad91a072530a3c1179e6f082ba6295d0840ab5220995083391465f4a315424b1d7d1b33b3a4a6c2186b6e39b93d3372caf802d7be1b2115c9549840222a92ed59ebcd015b731d2149bd0f5313da83ec729275ad2f1b5364f4dc6c566d8fbe2adc5cb95ccef5ac9e3d115fb03ee71a99779b671b936b95f3d707e297acdd308a89e293b78b24b127f90bb49198d2bfc2461f259c669ea0d8cbe895a4afc82349eb13f6a687a00fa0e973917591b65652b6511bc3550c26e05bee29ee36b51e170ebc7c3123b2e98b804fce9c6a1a8c9ac805fdfc449e05fd988dd410a5af1247a44ba827c2d0395503c871d3d9c65f08252c36281dc0864c9cb47aeab351884961a29e0f7046f1259fe722cb471998efec348ab0f3022104c05b4a8d8e890a7aaaf686e0dd4e9fe681687d3fa55808865e9cd8ed1a0591a69358c4fb7da3347323a36637ec8295c4145f9574fe9a9ecd8a1e1d17a5a0b2787190810958f7abb60ed6815d30e6a08b8d66bbf678e8a44a256a6480c75fa7e4b86e28fe250a16b94c71b8653840aa77d4eab9dfe5ef5292cf289df17598449f88b587eeac4940bda19d7a5c1809a944c035d657eeb11c8575cea561a2db0708ba0a77c95a32ecf382d77a57af3404527ffe3170e8a505f2fe5180c94d9009386088c64ffcff7d205521efa9f744b1fc09de21884c16f37bd069492f175c9f666e24f878476155318decf52d9aac70112c86b786525305b057237ad1a70e1ea819c05fb69ffe16bbc10e142071a593c94384795fe0b7e9ff3ce79985a5d10bc495cc1ea12e85b8748fd738138a5d052fb19b0d21d792a6027339782f927245ba7d4f50b608d0730ce888126049e34da04cf63157f505484772fdf34e0e422636056618cad2214961578638b5e8702001e4370de73b84f1b4067f4131cb8d75d74159f3eb479b3a476d95fbb60563e61f7effddb5f4d1ba1bc05dfb3f20f5826bfa94de64e2b42930af2d48fd52908a5299d18b2947c76b490efeae7e05afb8b07fdd8ec22d7753fe9558c8adabcd95b554e7f576e66a76ab8c65fc814426556640f822ca52f58ff35f66956ab920df6818477131a16742cf2ce1e4247dc44b57c345144f5ccb3b6eaacebfa856f1c87a422346be542b74cabe156668f27b36fa1ad7ce106a46cec749183c4cc4fac128529eb06a84d48377810214e4fe6567b1a4064ce100b7f0db2d4b9daa0ae3dc6be82c61c86f428ba99945ab7e77a0594f79bcc987c4112f042887626ade9382a7a42dfa6ba1de09973eb322954767a99a2696793670b5107e00b0e1baf4a8d91b5f39a49fe2a4880835204d552f965a4a49ad4149a71644f441b36ef5c84326b6435741f10651343fdb0ae48cf3b6fce8700cb384677f118c208ea663762b538c1d049d5fbc014abf4a8b1ccc4a0ff0db11c2b125485b423c9a396d7693dfa31a59ba6b85e77a77cf7e39707eb65d28f948c5dc15f6de5f16f0afcdf2721e826d0caf5ad5f146282f2ca1ad3a926c3515ad29dcb94f1c43f5c0e3681d63dc6c25c8488e309f395f1cb103761001ae0926549f9d054f2516af3aeb57f775c15c3e4af96c108338b4251918d1e83e753319dc896c8a93249b8c2bc96620bd51431d00b88f33c4296d0e65ef9a945c0a746e826dcd99eed726afa8f1e8f98940c4669a9d2c0f562833f802749a5b52d117727c5ae742cab5660010d6ebd5c3354b2fc16aa65526891e6bf9d9c9395a935164ba03de7276c573fc0814dff27362aa9f94b87b913069473e11fcf57a6483bb884dfa51da998146a6d6869a022618efc5ec980cb368b3de997005513ce96e91980baddd61d8c194355775901b97e040d39ec5c5d1e19b56fa73e45264ecc864afa6f4a97be0f2f782f44bc27acd0529cf80ab54d3c3ef506a81dc0cb0d7b7b82d46a3e22f243f9a550afa7688f8a1633ec24e005672f74bf4ea1bfcfd15500e7c8608cda47f62c3ac87e2ce37803fc3c77918b37dcba2007af34495554de20d09cb4aa1bfcbb568b67cf264aacc593e8ec4b1d1d0a8856a65643a640bbf609deded3bf22c9a54c7fea7eef31c161836a77000a7332b9e19308f0d4eabcb1520e64f2755df2825a0f5d57c3fb9f6bd558e9e06d5c625a75f947b54113474415eafe536a6756016678304e6f66db84169fc781dc2a601555cd4b00545eb2386eccb2f43ab1f14ef71fb8a1615c161f94f7cd8f3380d400966e1e678f3ea1beeb8261841ee7114133e89880ddeecc2e3c2adb011ab70c6653a20bc34091d4643c90c2f833b5bb117585c5af6eaec9de07ea620c35c87cf272632a11d223a06f30cbe5742722f5c9458e170a8076ba64dc4a2c037d2133975b89d7564b6530bd94a3f8e3385099d0f843437b1982a974d5c3df4150c1bdae99bf2b08809a497976a9e365dc8c111deeb5d5dcb8cc420a314df231dbaacfd4b2d30bef117b405e6524d056d19ae7e9b948a86e6471472f3f6209a707c4a8b995c8f0645d9d0c23908565b5ba1133c1831f7e4193053c8987a5eccd14901f685fb037d376da2f58f91eedd769a2275b53f895ae22b96e331d58b37fb8f52928a7f35e128dcf34d8d68b2d6757870b69193cd72ece721b1a96e7efa0bfe9a24bf5f4d5d4e36c015226229c16da72acd104d883d1376286dbc7f4ec1558a2773b795cfb85ead16e1e67e5173942bc5a4fa135a6c8ecd877c4f07ef91e3def3caa58e93bffee8cc58f40b327847171caad18406b7bb0aa5036a6c4c03079edb3c4ca1032f8aeefe2bb4ee68d817d1f49f1a2795b921fd221f202edb03e6ac61c194d68fd0331374f5f7cba8f86d7113ff6309ecf4c83e88b329d2437ecd75887803ce87dba4724e0979ce2d9e40449a54c4d735ba05d0e2352785862dc9177c5c713a4bcf8f291c1941db33983669a47f486e0143a9369ae4654ef4dbeada2d1d7503079d28384b1804855bd993a32d3e4910c11571d94890bb23d1b573a150086de5143163ffee593807c5d5e0d4c9a7367802c317dd54d9e3fd0b61f71c1154df3bc491ade19ef886086bf392594ba276408488ae88ab84c2962040baf64a818fa4969bc149f908a07d8515fe0df3cc1fcd531c74c188e797602ee5371303a180e84a58c986e6554d594bd55b3a3fb9e8c1e73edb0651f93a900eb1a297cc6357960137e4541d7d4f6f9e2d3af2789d5c6d5608c8f85a9a017fa48be407cbc0a454664708f8146ee74bafcd6e07183a13d3016b0ae3417565c30fdc16ea3a6984109705ab0b1ae13ec9e7d04cb691a5b733f17628543d06527385d1e25e5a2b7177477e312b52edc2bcc70f68f618efb891dfe059f282021cad231c674c930039a06a0923f9466c61140f1030947c7efb0185cad3d3a961b7381a3be6a9d4121f80ca5801f98da91ed747bf5a558c7f9462f742e63728146b67a3bb6ab03a95ef96b3e0251ed6d5d2ac52859968cdbcbb24ca85e17590d2a478710cebd31e53d6bb53fff27b3124ecda90d291c80074598940bf2f4d26ec1769ba28d4a3e1234d884fde95318d3f970af1d4a34de5b5cb980f86e2b636bb8f3ad55361e58b82d3ec24b372245ff53304c33fd112f104d7ac0fb86a678dedf57d67d0a40a44a6ca2a2ad498a0edb37e93929b99630c9e3b02e3f41b41dd7b92ca70118deb1aa9a810420ee9127fed6ea5f2eb05ee566db206011f279d66da4de4d15633c35f5dcdc252aebed471acf8bc3f86722e6025511acf0852453a9699e37d71341ac47c40647e5280469b5ce489fec88f9206f22f8dea5bd3faf133290db13712efdbd6eae8341dae02cc36a87f1c91001c18b6fdd5b0d18d839578eb16cea36863fcfc7748ad6f6e7b5eedb2099ad5d75fe8162bc13f9fff0a644e638049ed9364257f3842c3a5b0eea9660082c106f28927b757029e0ec6be8793b817e8658996c41fa8fde4bf18cc2fd80141fca8e84bf9df3a4a852afe13129413fce0f39f3dc9b740419911cceddc3a923b8ce52de3fc56f75cb7693c8b5d7d20b1c499b1798664457ea9b72d8eeb78113324162eba9c206f4c89dda52cf37957149044571b0185f991d37eddea038e63aba490d43ce4dcefb31c2bbf685fbd48fef7ee30ce6fa0085611599f19f93ca856e228a43d24601d42d8b4b543a3048c4136332d997d30992420a5521e5671ab38246270ac8ce6f4e296d52e60cbcb3fd5b8885946711a8cfab0853c02e6d7b288fdd7ab79dc1e71b825482e7e53ccfc2a3fb975a47e01b6e3a4ac244f2c36edb8ab010a40c2783c54a8e7f1abf68caa6aebe8a9d5b581d1a062d245fe95f8682eae6662f56864d913097eb759b659a8685a600b1609193b549d45336944a223eb7771ede857bffeba035d2f0f077095a436b6e241be38753825dfec4aacf20a31dd08e2d1293e86e320f412baeb3e2b350afe7b830e890a502d5a5655df4c3f7914538f772c4f285aac85ac89e719fdbdcf47e0bbea84e29cc9541014a3011a9364599134c4a55678fca2cf2f94df21bfee42321c2e47704aeba403a8aa8a1864b6b98ec4bbfb7c8b4dc417a369d87cdd35e61eca4bbb8b6d5771ce4e11bdf93db87cd2961343e43a28b4c93822b42096b674759751237b0c9e91f6d23abc5b1e816cedb9fd649719b5c3f337a5e8c821579a7a07dc963a1ca923404247f15523a76c3dcd6b33c215a6adc504b8b06da10d9db75be75a49840f14ec98ef1cf9c4c10eb7e9db12a91279ba8f7b311ca7973062105a292fffe7b57b295c9fd99aa6f3e8c4e31ce80df8a830e276216bdfe341389310ceeb2c5d371ca5eace2f3407e0571cdcc9b80dad956eb03596ce5797062268ec3e36222eaa1cf0cfe01404b0206ac0e066ca08bb10aafb178a5e1b9b7702a578cc91a6c0e67dd6ae9402cb41c7a3f2ab99377b98bc57659401814a30c5765700e9e1a8480b26acf3be49aae34ee29c935bd874f64632c33965045eaa4f33e7c4735a6a4590981fa09bda5d17652266d4f0e643bbc19046dbfaca89d20555cc8d0f71a5ba1ebcf0805720bcb19405da943cada89cd718dfa1ef2d2c95012df8c9eb2810d4c34574b0bfaa2a33973c136d5973325a0aba062c377ff9af5ae80f0cfa7d27ce2a6829ba3a2712462b458b1c8a43262e1458a15c39a56544107ff0a711e9355b9c892d2f2ee72b64e4ee1cfcdf40025c282011f587f66419d8eb99e515b76edddde84c59392dfae6b6d6d5c53e55eefb6b25f6f55c74abb1356c387f4c3386681251918ef28b3df35e17fe4c8d164a3d822ee9f36f53e96cac86d84485436e119f8e317a67b8b3ce3119d0eb6bf12fc50a5bde371a6a5aac37bce1d41aebe73f3c05db3831e2399f2a36ee82408e1a0f83e3d9faa58a2b27798d8855d5b92d7230d72311027e7b0405dde03551bac0392da1382fcd4ac79de0df73811cddda255f0703220ce6838598f5b4909846543d5ef391059692ae607f1bb2d92e4b10fca029e241a43e6dd9107ada0191e66db991774eb3cad0005b740e9fbbbec98e0a6bece98c3d38c0a005925571ed0c44b79e62d4ec36db8f0eb69fbb9f8ee2afa4b596d50774c13bc1e77e7e586c6a62031d65dca3157f7606b2a57cedd36b18d871894a784b9fe54474473b82636a687dd02da202f8c385d1dd7971f9305c6695bf2eb3da692a87a616173160a4128c32eaa10190496e52f2631a083820538970de68f07bc397f2b4052d6607a7c298490872dd28bff1e6940ad95495c64d2793888e68ca5deb723ea848c25492a1b9b40d6403993db19d34e2dfda0a26f7e3b5c35393da9085d50e667ec6f44fbea31b5c511d1193689b9567be319ec85d601563cdebefb4ab5223ea074e86215b28fd33b97893a6a2d7dc6f0c7cdbaaa86ffa55eda0701d21e9c0a7a3222601adf8fdd6e618421afc4f4649cb80aa7390a3974dd35720d183eed24f49eff0feeda058f07fd2ba67b2292f0d45f41ce611d9ee80fe62e5cb9b8756cfb2ba6baf876f734cf77c7a8c5b32f5b0e65cf7a277952e41d5431747b099f365d66d069a98a982090e1f452871dd7f60d6ce15eb20a2a96c67404a4717485096932e5264ee7e0ae808a88d94ecbd598ac38715fc9cb5fd3326a249b776c1e4efef1de9aeb9f04e2839592119897d2e6f130768acb289105778845e325f01cd2ba30f0b79e47474847aceb154482f52b6f193c509b31ee3f391471168b0aae4753850461b28819bdef9f227e8c2d76215317d6611418277989cb833496b6b65aad771c1f36739e40bd6edce082549399a85826701dd095605c734f61eba5fa3b2d959ee947e3061a4062fdbb926ecf0e6cf031939e900623b153dd74e216fabad9961ca79d0130787876b2f042984e7bb602be6105dcee253781ad4e7b250f0ba6c2191b6b22052579c0f82e6e64f16e8e3b0577d7b9777652069754d39aea1346f4ee81a8aaae627b10ece896e4acf91b06318cdae412fd7059c7ec406356714aae308c5d666db36abd4efdc7f2c7e194f85f4e015004c15319a017cd490d19a58b2f6e2faf19690a07ef24c1a644137bc2e70f39a18f6044321dec977c73ceac07a8b8b5baa2b8cb78a85501035f895db2e18eff4bfdd1f8435dabbe0e08d66e63f65effb9ce56e5128b3a74079544eb3639485000115b7a49ea15ace150c3d3cb6e003608e79ba162711098ded8770d69045f7ed722745cc5d5c31b4357a711694b81219ab26c5e6db0675c11fc539190b3da244fde6446d5ceae3a40c91dbf217f6694ab71040720ecb6aacf5ea9be2a65acf90d320c6d4f9f441a5480dad254247671883ccb850f3093182c08ec1bfaac08b480445908ef494a0ef64d58247ef9fff8a8fc5c10ef208f2b936220d419d332cb45302e6b06d575f6d7bd954d90e02cfc7f2ea2b780c32d5a6b3b05e8fae495368c6c804966142cc72c6e87a00af62a4d7f8947f5d85149f54083d1bb29df8b6901a21cf395da630ab377c94c0d500f5328634748d2eb1a96da3a1da699a7e3b8271d56889aca645918986c221d4a9fc607f139996816a3ce4ca4d371579c8cd23d48268a6374d36ef5c90da719609c8122526840f653ea0afc7771a328552e253807085534063cfc4570dfb9324eb72f90edeb10f2f2e5754d048683174239c9cc8283c17d2ca36f6d53cd8104f0a9aff05343234dcccad2ae768808ea00038d96082889f43d89f9d30102caab122e0e300dbb5a31d301df7fe437eb43a8670ee1a61e72407a8725eaaadc2331c4d75ee79a155892a24169044edbda86d10cc5e372315b9ade5677fc986535c72327c2999cdb4f3e1e2c2582be145344ba77cd6a73eaf92f7079542a5c4749fa3ee90974dc47b55abcb3e035c39fdf645a2cf090dbb9a068df5c8374e32a151b0f4ec9d4cc16d76c73258faf241542b8505b8002b234c191b1a3842c9514d5b2e1a534a595c524d84370c311a91086ff5f9dcffb4a3775bf60fd28cc928e14eef6383f9aee89e1b016e82fcc98b1f8108b9ae4e9d5289de20a08aa9c1f1eca765815f40a62cb85b55a1a5889aeb8b14a2cb734a6c36ee941db8fecdf022d3a7824cec33c9ec70ff8e969f04f4feb3f9b1e7f33bf2807f3690ec9300a2193ba3dbab8e3cd41f7855801f238c46ac9ba286bbe2b28810f36408ed5fcceb826a51f3ffb63165b2603da367333f5a758f217d1b433828095b6f8bf84e23666db3a117c03b5f21be26028c4c99f9ead6a8024c98dfb8ec611c14f5f5f3150563fd0e26b84d86c47c41415e5aa954ec775c0ab1223b4f6b0cad510180342a9454ced2ff31349ead99f2f816454a141024c55ba28e2d47e71607e2e800837b955aa4d49f409fcdae8adec49f516e0e6bc7d8a2c053ac898bccde52bfa4f6311e5b91eb633eef73295736587750cb882533a0458564d0f040e9012ca7d1a3e9325929add66f8648636830f3ff8a3106a6611136ea3d79e4f649872c00cdbe44edc5da9c0f567d405089422a0d9a9678eda146d39ba50dd82834500303f11bc81bfc42f3b53de38c7024b07f97cc732981c3fb6b340a16235b4f58a47c9e36c18f67a517b87a1e13a94a668d8979899d5b9e748712802000dde4a87bce5ceac4b848794f5ecd412b440159e6665f7282d9708e0b95d42ea5077791dc35531779c2c1e8186aa7af2320679fa120ddace5b484be3ada0730f9b95728ecf482660b69bf2137eb00cd95d40719f3c9fe92dca14f89795ff3fb3023e23f38ae611e81c89f2adda0fc786b4bd5bb13b8a707c393e504e283bbe0874b2dccb4611cf6636fb39e1bbd03999f4e2663f76befa45f739917699177bb383c039cbc020f8f4ae8d724e12c52c129437eab21fdb2991ce9880762a8df8cef9cd471bec56fff2ddf426b9fe0ca53f2adb583ee26d2f5007a6c72217febb33d630f61e332e5d883770365cbf678069ea09c21a48a50991ed8f30c77dd3b9d3e05bc598b088ccd4726e5c206f3c64805008c7b2ab821ed930b860044fa273d667e54ad780eda1a651abd65ea8eed0f0a862904e99cb5ab6837e1d00d022f21e58854d570ea2621c25bbfce270df1e84713c1f87596939cc2d2f4972ba35aeead7a7347cb0dc4aad0f8cf8b46388bf32fae74e7db9e783d846c05c997293486a36a0f90a5a9f81277c5ee2f39b59191eac162a26972af3dcafb0dac68e8b73ff8117b7c00e552649727e7921cfc1483fec58731610feadfde8944e48b4a63af89390bf93c8174b7004bc4d6c01ff4324f258725573764e235cdb1d6fb291894aa9872f1937cb883a3aff47568af689d42934d235424938f5067aca07fbbd36240d83c8971f7d85792163d1b04da8740c8031dff06c5648c529a4a63dcf4556dd588c5ebef0eda57f0762d9d0dc3878c0b548f188fceb08d1b2d530e579a54f2a317e244a81d0b7bece410b2cd06be65910b68004acb57520931e4253c472ded3389f03535eb98eb41c7a9ed30cf3f2a391312ba315fe371e06c56d6eeac4ccbe021847ca54c0ca7f89a18d51ecad4bcc822235408f2ebb21e7cbf829ec62a96f6193e5084622e783b8f8f14d5918f08d8dfde295832e19d1eec540547d21c2d2c01c2250659aacd5c043cec9fa55da17edaa989d5912777e246c91a95f64c4efd5617585a02157e775d83ffe3e6eabc0412678d7eea4e7c990483444040639be9cb2029468997a8c0a1fd4b3efc00b707309462736b401071f7a4404b2620ee955ca7a46d697dc3749c104a271f805c05fc63c2976ed1431287cc8663670f439e7875957c9686679a5c8d8f140c7be56f70d6da0d5f18eaafbec12eb4d0ced9dac79d0b942e965af88e8370d6a9dab4d6d7b4c1ca0f7ce4733b036da70aca54fc335f7e4ba0913db9ca02febc241241ef501f699cd1c56dc62c5444250d48e368c65f6d46d1dcb13d1cc5a1bb9f4d2b9fdd3bd1ce1573e35c95e408c909bc4116e6113220e94c72ed76ca28eceb5a23a7a1a70ff92e55a545106b96591250a3f6e2af32c1330aadfe4c35a2e38723390414c29ac5d662b73acd6185894646a31b5e63d9b27f4657171bdcdca97367ff56c47b3c195e1d77f06de21975790347958cfb99b90d9069f9d95768b414b905e00f32172a3a9ab27a8c66be2f68136fe492b0c8ceff93e19fa4705eb6fd9312b3b34feb6f6518cb3e9a66144b37470d9a14d557436a3191cc802d7138fdb3b7b756f230edf3ebf0593fb9671aff93b9b59ad12b98073f86933dee83e22c496df639e93fd6d683fe521a1b313ecb737639bbe6aa5ee85833cc171fe810adc6c3c6f77777cd530081c71fb8070e6cdba075bf97d4d4569055d254ece901430088359f597d6c09f4e55a32e8f16464590535fe675f239c1e22b48ea4237126b78f349c3e1bbe2f666cc562442b23a910df0f124c95bc6883e3281c46d7141bcc88494079a55c3af582d294c9311455f2ad033260534f303c5815b318202326f27e11f05e7387fd4b33cfd0ea8d77e75673ac9d1b0fc6a9c6693816f2f6bd6eeeeee59c825b45e6945fe8cc9868c286666bf9270ad1c7caf030813bd193221e040aaee94c8807be0ef333d2d671a34fa58082c6d67cf0a6d87270009fb2f1ca26d43fad615d3c7516bb443b8160335415ee1d75b5ec72f84e2e65f2ad172583ee810f6949a91b56a90c15e8266f89401d9398ddf364e77b023b90d4d9a7006dd84240b2fbe60670668621e2eb522a1075218130f729d18592c1601a1a21f19de8626a0b7232182a1a5fd32af392ee69a83bef29d2fcee1abfe43399c9a569137ebe31486affe677d0ecf6ec696ea3fc20b5700b2f82dddc7811e32a5d1a60b8ae9690f049b173f246186c8755221c76bc0f97e7b58f69de2b1398de2746489b99a127a555a830a9cc1458ffb9705daffef5e6a77bd05f01411e105f095b74150ccbb4e5473a8ba4ca2422b301b8dd8e504d0cbbb766aa968eb0838a891bc590cdf8e6ec2a9e992bcf8c94852396b538055fc1f4c4f84c15516f0f630ffc06500e8f346f4cc7a5c0a15af388d4ae8855ff36e9f0b38b88179bb6fd39bbb40e7610ac9d0f1cf28d9cae524afa32c24dc7236e611457c70b57068c9ff1d5b50a30f5b661e234bf805dab347c878279491b027a3a8acae4068dffae0cbd8df1444cce444d70c355493b3ff8873a3566fb5e597c164c7865cefb987b1496b5f785e75610ea3e93209bcfb4bae5377e60e24decad5fc6532900eec4847525e80fcbfbf2d069636ffb693cfb105731d9724878403b14381c0e8465474a6879d61153cf444128a90acce8a8365da337caf8ce12e1997aaec6172f0b709497aceed0a2daa4293b36b64282dc1ac8a670f9d42271729f11dba7a437ed31c74d76f1bca33ef95254e24947a4ba3b4de4d380b1bab5804a0aea8657be9f7fa94c1b6317a5e7cec461e96f40e6b790d854e8db12763955cbc3fd8dbaf567d02d7112604d0be888e2ef033c4c8bc28526d02c99cef404439bbe7ab8924300f20b279d84e13597a67d74c71c3744c4758129127f004438250795a5596e8afadf919028df82b5d1efbab3391194442b6de78f61364a531bf1338db2d1b495cb2a48f1f5f787cc001a79db3a05a1c8cb9ee2c15a4b94b6460e7e616db6cdd2406aa4387c88d26db7780337ca76f50140123bfb48d0c17aa73ece3c3948be52e5177873cb6d0dac00224926dd8d1c2155f1c811e5a0d6eaf9e5472120384198a66675b7c081deb2607c3718d16dcf88cc3e4e70016cdccce4883cf2dc1f433542f25b640408a0ea4fbf12e42844f2fd68d623bee2a5b567d4c0a8a523e92ab00a0e48c36f88075da62d3dbe9bd23dc124c105d10317c4da2d490a637a51c28e9bd6faa62aec32911df5a0cd704c58a4547fb9dd1dd0752578f3e7820166215a5d26833783cc15121d9cbc34431c69252fef3b0d00695a0d364238438775c7274fb409c1d8565cf32a870436bed484704b22f5b8b87ccb38dc7f61eeccd3c377ebc8df50d1314f9e50d214366e208664e4a879c14b6f75935a8ad4872a0a61761fdd88420f3c40476aa0e520f82c5607504ae01db654f367b6ea07cf11908dd3620fe0a95475cac99f7c933104f41bf1cb7ada6f56b70ee90a81095669dcd82cd10c63fc5ea4f7e939a4fb66a58a5f56bb490997458548b7ad80fa7203bc4cae4cc6621b2980d56cb481e9431165d4bb65583230e6bbc507644fe6deebadf36488ee398f46167bbfc7223904d194f9b8bc2c10a654b09bcda422e6dd46631064deb11bfca84e1fdd1012981c3d7f4e2598a656ca0f728645edf525968c4f6726288cb00c195a177cc6500e773c3b893f0f3102b0ad985ca2488b5b179e4952d863b2fced5793f28064bf7e698451a1ae52d181813c7c01c01ee03fad960b784ad61a3748c0b3272b87ad4337eba7a440f1d8dbb8122d49a25a6f67c8c3f9926be7978b774e3e47b3f41a7f41a3771cd8006316181d7ea4007a6e474ab210e987e645c1022028498c31a0ebffe4883598f866538d4fffd0688f38f6670fafc8643a8484289264709ed439b069f938e6ac56a120916754c7966069a2fe412193086cc2da1286cf240fb49305410b3320ede1f0154db58050222b6dbee66bc57a00a6d9ac831f15ed320793bdc031625d9bc56de4e061278e08cb134394ac6697413d5d939dc5fd2c5250b84d01ce9dd2dcf1cd58ddba96522b047ce02f550b766a6dc72bc8f4e4d90030bdb5e2f09e9c0b1d8467373fdae0f1c47a14cddbda69e2ce1f4496fe9e4282caec26595a6641132c432b63186553cacd5bc126dde7a92bae14e8180cb2f1e2c02faf91c4f03519e9320b6a434def43e664b3aef072ca31c859f25afb508e9abb7db4f277a9d1b1df21e72c4e599e5876843c94f1a03d8bc43aec1456001b413a2905168d5cbbcaa4cd3efc222634bda978be1920675f12db5629758de833ad597825b459c8c4da22fc1bb480d9eb02d12effd538fbeecf612b6efd96349ae2832d501365dc53a600afef10d0701dfb7a7b8844436111992ba9f1a6f878ca39c8da8701deb5542c31b559b3c3c6a5a0f87689a9432b85e72914d0751c7d9c3af4419bc96105b1613b02dd6d9d353f6a2081b89c7e85fa0af7f8b106726b5428c88fa5afd0cb7371e491b43ff8a768a9e2dc4dca6b490fdd6ad3fb96ba9e9d44346ac51db8a976fec62a0de95041e36feca852f6c573a1358ebb965134e8198e19809d7a3aaa25234a84c32d544e3d4738d26f1c5939cba21b40527291493f80fe32ef7479760adef21084071e1a1e8625fe4daf825416cb4dbf3f08c9cae3e25113e4a7170add8d0d3ebc005f6fbac0dca2554ec9e1edafc73ad5fc02341607bee97ac6fc42151a4f46e51845755d9e162be121cb4e311ec66c8c872f3eec6573a4e83efccef4374a7ea6efa29b127f27ce01236be3b4842227cc0fb3e4c4f84cb0a668bda48c51e9ccb1365372e22d3101da413a2dc93b2f642a78cf72a32a3f393b3c390adbf4f3ca2333ec6bc5f3066bb2edbff7dc322dad5a43462582d2b57e769ca5d4d01bb64bb312ffb5ed2dbdec6ba37c2e66203e8eb42fa5fa8f81740afcce2ce032f244f7904c09d44e95ed543a900af3074e6b3df56a454d554df99089f9313ac877121736308333262a012f4298915c88e06a80ebcd385c011bb4bfa21d0ee4f2107767aede5950fd71c8f1cfd2ad5297ba51c13da7025ea197139052908a412dda65147e18a24c2f549d05e9a6b13fd5ae7f798738532827ec8ad3a18d14274f1eb3229c742926eb626138a7e2089783515a0e4a38a66cf5f3de2b33da10e07fb0fc3edd02d8b8bfd466e8076b7ffb4e4f4e64e9a8b6f0179edaf87614ebcfa040f252e20fefe82f825bca123ddb652b18f6c8ba03cfab1b33341c02b39e8517ef0141c5af92b52a3ea367f5913be879ee5fd6412d316ff407478b8e43974b6f5c726caa5ebd4ad4bef617185c3fe5058bec25e42f46bc200abc3f30afa465bd0f391b9a47d785be540e31607bec2264651168095e096df28347a9a690975bb034f3187790d3a1ad813500fca484883cb713855fa48591404ea7a0c2e0719e3565071bcf0325032939074d435abbf574c4dc7e569de7b66fdf000741de89078806051d808cc8eb317aa54e9fda708e1c899d11f72324414c7f0975f64666b03da57c057897e9281400afce9a20fe924ef861b93d83d3e0e00cdeada7ffc2f1f55977732af52755fa89404339114dc2365bd8302f55a064a28ce3ae21c33ebf00190ec0c063ae26952ca28c2037bec3590678e92f470e84e289aefb06bd524ad1294b966186f55260d6a6b5b9514294fcdd3f672d58b2923c5c5cd7fa45f99dd3e2bf3af7936ab700c4afe9774212350080a39218ad28164c34cb62526779bff36d0b08baf647176157f3e92c0ba5206e7f54e144f8392bb9fbf1cfcba9f18fad8ed765ea9e850460751c74b8d0ba78c8a5a5b43bf5e4a958e6b853dc5f7e78c096c917d3ed9bc70e1007ce07aa791b10460e0f311c38eabf17f5493eb431aa84b98878145e6555285b3d839c72236d627473eb60d72f6d154a7f6fcf7b88a724605290c8f5ef6538900d472bf113e7ae5cacc7ee985c0f7863e0a87813df4446bad48f53a93d2514e779d28513a291e7019ac860c73614b8e46a531a70ebf2e973b182e1c2b925f649a9d1dba276b2ed5e9f1e41c9d03bbffa07c0e02f67fc3e21e87b9e20a6c2d612fbc7a4a6df23514075954eda9c197eea365be42611d5548c34d0ede4916e46a61da54495c8239b4b21cc075e521dae6a040d744c929e8457279906e8aeb7261ef4c4c2062596dfd20df115e39f050faaacae73dbd276c17177cae8d18c94aba83f70dd87ee8303ff3621a428cdf4cceccb9b2d0929d6ca6cfb79acd5d9e95df0c88f78fca5b56a36b0d0aee9994de84a3ef77d14d52aa6f35131ebf62d189821651010b3edc64cc509d2ee4b3e92cf571883deebeaf6a3786a1c1d05632d23347c14ecc9640c6e144e80a0b16d3b6603de63ac16e144cd776b1006b26a332fc95d8b5619c2984fd9e8733f508b8efae8971ef66873aefa3121e203334bcf3aaa2c215781428ec770d083d0d019afad216e500b1ea7c98e911e7435151762005311653e2f2513683a0d2a1ffb00dffa44b3bb113484f416d7c307ab2a66e44d01f0e5bfda7d75d1288e48cde6b2e3f89a4b16a989a7951db7f4f9586ecaefba612c08bc4206d2f67c9d7066405b3c12ee46ff92190699be8000d121f39e64fc622a0a166adeeb814d4c19d609ab2ab6925779e12e581f10cd4000ebc3cb11a31ea840ea452030a7bb08ac2a069fdfa2d5312ee4764cd8eb87ee735144847eac4d3e1f9613e6e0f5513f3897988b6c5b6193a173129893e29288870ad128725f87b072743e87620ba98d830861bbf64efe5b7123a37ea2c997d84268983b9fac9b278547a23f02f20b5442020d3fc299f981b81bf37cba1d59242fc8d6c3b7143a1a95267582cbc7e2e57fb33af749cf5bfe1447452723bb740a9219319d9dce9b27b1a4eef7af5026c26581d81d86aa04e9d214faf2ac470d101b42f02d217bfb0ef2f7b2c458c63c23b613762da296f667b72d02233325b10741b718ae057a895de119163bc54e4825702096110f7fb23341aceea5f971c5f778278309cc7369b9095348d870909100ba6808e4c0925933917f738f70942c6ce792e71f96dc7a9d1a4c456a4565457ff3958d839ee63735b2caf9cf9076698d4390457be6a396d0767c1b99a4c58b9f02952deaf9db7027a9aff93cadc1ca9163304df74886d4459dabacb4d4f1446fb87323d091fd41e2491324f1e594b83e10a288b92092826705a89db827577c054fca2a25dc576c2b621d4f8fe84b610965d948f5b11d04159dcc2c13e10b8be233d285f2d9078aa2ef1e269060a7f5c8b51573d000b2ee199bde0c0434a4ca84fab7b089a2f6557b0313f06be48f9a608b39a8b538a7d5810899c33fd2de9b3f6a4952653c1a0444738e6e67363e93d1f4c4363b593d3ccef80992a197a4cac5e6827610322a7c338b8eb8f15c6cbc594c1906d41d4a021141d564efe28dc0537c6b2e7936c21b157adb1c21b46601eb047f6be013011676c3dcca42161cea7525d8093c711ffedf668b0b79528e3ac6c2dbbecc5b02a306cfd2f1999278649ca8f8be245d85395ab57c6d232975b989629265dcb61517c1ff3bd97479209833d4d413a77e90d1d70dabcf8128cd3e9ab3b63a12e84a4dce86bf3fc7d7c85298cd319c0be095a7c10de9ccbbcf9fb738e81a09e864000f7200bad8b6d97604c199df7f3c0917e5512e3cd8e75649b66a56d5e531749d6abe67b98190361ac2724c29a19b49cb8dd7b233b07b83bb614a051cea9b530cf7690a17aaeab934627b49bf3900116a0009e6d1ecf19347de1c4502aaa5733ec68836ecc32a8e845cbc7ad0ed8db4951c89e228aa5fd8730f7dbd4683f21bd0816eace24771cb9daa7fe03b2810c553cd8a2b5c53b655b3b964c4f58dc2956e8272398ae03110f3cf90b22f97482d0932d7b0bf703c8ad1ef174995866c02096c12778159a038a598b2606cad30010e84892eca175b182fc559e106933ed4852c00c5f5051ada8b0048a2d4ff3c4e366ad30d9775bc84137c6cbf4272c39458aef9361c95ad3e7b49ef544a249eaebf4d6f4757cd7208d281d521ddd95159169e9b00c35c92dda84c72788d611f67cd1de5309c3f256327040c15d961cc24ff9075e9ac7dcf69d3d29e06b1b153288963c21b63366f3c7b3c5361d057d445c2d3a2f609d34df493db0cb28ff21e9a8914f41a8f259832073bfc7882da637a93d980ac65e9075154bb4705faba87a58557b595f9b654cc1af82cb78727ff8b122cca0527a71d997162b0f192a08eef25da7a37ec9b25e9d284ddaeb1d12a78f845ca2c3dca03722f3486d85f6c57b2eabb7a762ae27eff44eff6045ff96d0756795a4f98f3e48981d0e70a597511ce3f40b2e352f6e9bb64e9e70ad168ec5ae37af5bf6809694f59d8578d0f90a2ae6765b9e33b07c41096686039d0014b07a4557d391f42b4003b336dec4be96583a09ad940522ec5b634afa25c73a2fc065b890e22be1a1d8a11e6ba224a10968b026570b40efe25592d241531ce7eae0e263b85d75ffce06bc4ec08bf8b36b25b6139629ff74e086849154580cb1c125f82d3f414ac77b6cd1219cbecfc381ac61a4171c954bff2b28e14cee48eede551685869ca80903503c8453ed0f1ef957ee79f40627d1c410cc41afc448511ba64b40273ad3821e41870a9ed6f971c642f895d7f6b7f8068de11548db3df5186fe91c45450233cfb9c660cef57553ea897245ae15907fd0a21b8b1f85d150cde1b878a57a13f40e7b249f41b1d1b10f3c566db3d6ffb57acb8b879419640415c6ec77131f8d4bdeae979b0ab29f5e6d6812cfff0053380d1ef43ab15db2323560c00251300dfc9eb192062ca59993c42f98e9d8ffa68bb41b918a059ea8615d4be67c14276a3323656b66591d7603fc82aaa5354487fb1899b21b262d54653eaedfba7f265857269b33a1ed3657075aced1839452e921b25c2bc9cc5d44531e8e3bc237ce392ba0a0620f0abbb5bc53f37688e206e3dceff2c765e93628a7e2031a1e11164caa8bc1fe44bebc21f0dc7294f718cd870c07b14dc6af535c5623d6b9626236c170c7e7d9610d37af01fae94eb0857974e88ebc81493251ca10af71b703333701e5dfda7a87893577e06afd5908fdfae419a9abb146eac3956a4fb72d03fedf0758dad40936d7536fc3294f17989fe12eaf5ea425263c3c7505246722e3b1e282e67235fbb661438a0f72e3418e20f2c5c4df6eb0f5325409aa8dab982d8e1478fbf8a02d9ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
