<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6bcee01eeffb6710cc05adbba9f00a4681b817e63170fe6c280e7798d06bd2b69b893194c5b9acfb87e18cc16eab60d24b015294f5a5b6113ad44e73a0bf73274a437df292aa07b0ea7bfe70f08247a9bacc247f30af61a0adf27d8556750d42e305915e807e9130095326de7a47f638abd4e48d2d65fbc57aab3dead74a76519cd0e6bfa43d02ecb79e35742c9ad5e940950dc478bf74f7e86cb1d5d0745a167c42b99e5f6e64382cea6175390da1f694ce7c2af0e2939bbab3c8dbbca925e43e0f2f6c86051ec236c3a946167ba7301c8f409a6175863e167d27881af3b269fc9b02c5754f86869a433c9cfca0df852af25b981647ac0dfd5c1488379dfb28e0fa8c2f6e320ed36fab95eb9cd68b524af0a7ac530c5655fcbfa45393eb623d580d6adac09978f11c651077c3ad676c4e5c5a5b629ed3ddb48ab1907137c8b6effff2749598510379b530ed2ea90c5e9289a30763ba458dd1697238dd56c20f571f77f6c0f1f93b9e50b96d255c4d1cabfab22203db23d9e73e76fc5b0468c086c4f2017c4e132e67f4f7369c6161c45ea2911e2472d13af3b9c81a81f7c648eee7b2b3a5bfa14f3baea81141d4612b199d654f665762cd5b58e443e9586c397285d658fc9246e916a311e58764a935389a0c07bbf45af9d3a2662c8cb87e7f777846b97975b180b57d5387bbf8501919dfbdfcdf169e8ffbc5aa9cbd94a5f4127d16f6f84fc49b7f5edbef8c19a05e5d4166286141f4e70db38bcea8433dbb506b6a8416d09e4702cd386443af9fde72d66715a31441557ee465c7b15dfbb2a801fce43eef6647bdc7d5189970a55bb4a8e05884c1abe5587be6621893b17961fad6af32276bffa1f1531f74539eee3d2ac750487450c3bd916a3ebb112e43a40aba1f5e551ed0e735a57e637c13efc60c29951ac37c3e1fa28b42197c6d45cc794d477f1e1bffc1e5efd05cdb08dff234e6750851b88c822616a67a02408ff789ccdc30f947a765b91f23d9148f7f4b3b05dd5a56c8e47eef25176762423b1e129a81ffc19d244fb422a9075f22a2da3376312bde09af2734ca6d95d8178dc60e1807c19af80e40c42ea15599082f61c1da92dc02da2ca086ac56e373d62d177984c2771b2f417af4b6098f826e3ec93a79f8a908a83ae14de753438c9b700c9f50c229d82b9c5eead40605cff94e473e5e6541d209d99c516117aee5ca9a52fad2c48d04da5092955924d2cbcb7564ac7490972d494de594389d5b2c37c98b5e1a9b67862b1cefd3bf833fe8a76564cb48b06641d7b31eee4ecf38ccdcfd3b1fad7763cd3c1595c2ea837ac83c5b0cc5c7bbe39e07d3cf2393c776547df5354df33491ded16417ceb500be84c0eaa13e93d88da122d34fa82aa820195292b0453c84cad39218318f993791e1f76cb9c442215c2fe8ec2c6c3932cff986d572de3baa235577f66f173b7f4774d2e1c39e8e002969765daf8f3cf6ae287624ed482667d4a23f74c57c192317b276c73e0cce67f146c4cdd083b0fc55221e0c705202392bea78acb54a3c911ea43d56e172b1c956ff5ade3ecb0dc0bb625f75cafc5924a955bfd9de2e2b10e07967c0ecd486a4a67204ec78f6ed664303a912893d47fdfb3e52ec3bfab4ccd2a90b9c844042f728dc9c5a57a357559bf863610d95a32e75c81e5cb9a8075459b953b93f11f8acc89a319e5d98c7f125e515407bb5a8fd79a152bbebcd08815b6eb9914ef1633ecea551fbb9926b8b3e4601867f258bc4850554ab63db419d7a965b4779cb6be7638c3440f93886aab5fb17f903a4fbfef1e9c3b9b6726ee27527f583b60b1d24039302ddec8202eb19940626671e6836f177081e7dfa5eac340df80ace3e18890234d6ed66c5fe2ce9d63886a513d11579dbafed2925752a0394e5c42143b1eccae219db03089ab3584e5f46f2472e266e1c495a778311880b4b7d02bbc907022e17cf0501289ed22e7c26ab28cd1d4e2209de8337437f2ecae665895e4fd02b59c152e9e747ea14aad09c17dbc63db6fc7c5aaae4ef17ca04c656ea5e1e2a30e13a14b4c891120a0fdb6c4455ade69a781207027f531b1f27357e6c8c7a6a621433ca4529344bae08285062b1f864865aa71c86ad29b953fef53efbfdf922218462bae131535abf15b852a28d92a397df193dbbfd37f1c1c278bcd51b6f9cd818afe5bf9030b6118b7835b4256c5c8bc8e33212e65ecb6a52bf836afa0d6d790d00dcd60d1be523235d88ec5a15f7f342098292660dd8eeb0399f77abfd379d034533204eca44e5187a6bd45f3b1d2f2e3890225b651654d7c7586d96f6f826daac3466d92e04f37862a80a82bdaec6746bc2a9f35742c34aa1f930b7b2328ee0eeb64d83bff88ed3ddf260ee716ea0bf6bbea1f3841208972a09282d31be2e1837465d3ffd07ba26c29c337b7c1de318460fb8b84d94e509ce7c439156cc4f1c62a9f5de92398c323fd67c60add3d4d8ae582531c3b2947afa55f90d1063783cdbc8dd13edf866af227dfc54e54862674bb7e289b3dc90d77559edddb57093cf2014081f42dc4d5ba85a713b7d166874fce9c341f15705cc12a08baea5a1e17924ddc7b7a09b242a8f90339fd82233496cda304a2318761aa35118f86eb2d6f2930b433a9b12b9367ece8b50b3a90bdb61037f45806c74b02df41ce16f65f02e0ee926f5b98451b8bdf1430dfa84195eee961d7804129c74e2982916057d08fad9651b43f70596f39090e7b6f2d8c65553e02951ac05f0bfb61c0591e5186a501b27ddef35d2700bca6833de196280fb2ad5d9f9cedb48147606dda1099a39a40a6c00783056b7f6b6ff52dd1d145ef54d05c5682e1585bd93e62e6e963cba9a9a1d5a6bd50b352ffafc073a03f859db00d49e939900f84ca43872212e7e50c80da49f81fa386ce374760e11290e7dfa391aef57a15b5b837e9af09f052a0ce2961201d1da1d399b06185cb4b8776d6118b8743f0739c45db2ecfa5804cf447b3f465535ea02c643cf353a40b2c1e8794a64b600f2b8e7addbc0072af8f51e19f8c684da60c03e2fbab5222342d94fed38b1f48b2c3a6a3f12825bae12e24073210eadbed4affae2a15f975d24633434e524c2a97c8c34158b3a0d5b967a4bc95b6fb46705a769d752f917ed67e9bf1a98c000bd4af0baae8f9796894751d94a6895ec124bcb486708763b405377692d275df256069f78c99ba00abd2dc6f83ab38b7ef9f2935a727fbfffd750891eef26780da10989ea5e959c5350287190d935505d77c7020277eb0328a502a0007aeb6cb5e42c37e87ed50d8ee51d983915c011e36dba247083b413a1509e4a8280f63a082de4924868d5fcca9e9c3a03fb0e4899e18bdb36618fd82f98bbd59fbf07cfb86c9c6e34b4f7e0f66792b38e6d4bacf4d024a5eac232295006931e84059ce3938fcb87dd40a20fb95e3c892bf1ce4b322c3b4809392f3f8cab9cbc225bd5e25a14e53af7f44e8cb68ba5b4c4edff3055e8e5d7209c1ae25db730e88fc7594c120a6f85663c7a57ca9ff00af6ea4527e39cd3e0f371f664c8cc2689d8e00bff1a2f52bab9807743b84368d79cc6d93463262b163ef064d3c96f29a5109b9076183dcc16e770fcedae011758931b6eaa6da161cafa886907d73c58c6f9767a79ef6984ffdf42c28f8f35054784a7b33d1f5432a7f772a2c4b1983d8ffc34623e2881c8ca935a0561dfc760772c124337a26f992516fa077ad0c60b34b005146603f89903b9f16708f9c0572aad224c56393d22fab2a2555fae58ea47eb958a1582ea50e4e1c22c89ce99aa530c320e79b14b57350d7cd9d93916515869fdf27dc14402aaa1958997d8359cfa9d217396a6e759841675f8dbc865ae57f76315927e7dd30f4eb59e214a83aabaf680067ce35faa8d1e796e04fbc68055b553d6c808211ddeb1d6db189a7113a8262123417c00b9c9acdf1249cd846e47d83a0f8048708b8d331edc421656cd074ab2cc5cf7f94687ca05b0d10fdff3e3c5f23e7315fd26d59099a662afd4b58da48646e4fdd66fe301ab5078d34385a0a2666878f7d82b25ff4e4841c5b4064d784d3a27c9519702061a58d188243819ee063a0ebc5496b4ff706bf49b19e48107443a0bb7dff40ed648c68160f87958c7fbd658a69f60aa492c3d4b96e25b45a416c45ea9d53794ad20d31eee3a3426a2d051b99008aa87016b111bf4e82e3a3377bddb093fe66ea0266af53d19f038139610f3be2aa5ca54725d4ae709b9693147d1b2b4fcc70e05253503fd024c12565830a0f5e46c715cc514dd6c47707a4e381d3e09c5ce014975c50d7616e08c28b3df77d48aef63d80899fd68bcbf0b0faee1438dd31834c85b9d13edd12e72894d55ef403c9a76ad4fb7b3fe9efc570f519e1ad05303e7baf38931629c03ec09a792c4c69ab34fc22b3b7b4551e6cdc00b9ecc6a33ca80173ec80852adbed1b763ea8f9c88202b075c057dfe72e532c8bc4442cb365ff801d654b3a82b4dcad19c0fc27ae638c93f2e9d58ae68c40dabc856ae9e589c43058dddaf9b90033c2d6cdc0d06f3622f5ed3d96bbf063229e685ebbeb4a047ec199b3d8c997a0a7a49ea43a68a5de66303abab9100c1262fb35ba9f078a70e1de256614a9a15ea3e419a178fe5151ec829635b3a8944b97e584cc6d212fa2ba6688732b5b14fd5ffd3d9599899c6d7dd3e78257c580322a2685bea68e280a6059aa039af146b2b990d293275a6864ff8176cfb5ab0ac02b49d926e48d24220f6b51b958c8e34e092a48addd5da4e481d32ebd4be049d5fa423b9cabf7add0e8ecaa36ff36bbc95dc587bc2425d9ebfa045a6893aa029ac1bd1d587d644224e53b4dedb0984ad7ae1d814e6f982994cadea0ddc3d4e158a010ce21a324c75075ef4ed6efcd14751e3855929e8bb29c42e2193f610475cd5f545d2ccbea579b02d3297d7f658c39130b6213d615c467eb478ecb658f69c911afb522118a27831fa250abddd31f5b81b2d7a36bd30e87e16ca6ecb3d070053ceacb0c70113f6184be500a0bd220e158b29a14ab54c648ad0db04edbff796c37c9f4b3b4bc17702f6600dcc95ea9cb101233419fdae4474452b0e9cf1df8980363e6e74c1d41b1e02c39c59315cdf77821ec13efbf08ff0207207756815ce31c1edae059e8bf8d5ebab7dbf9b5cfc64fa20469f27e53e709a31bd46fe122a0b7088e0f898e753e5486277bc43e41b71df5e66c772aac722db645fd62daa2ea3c413633a33136f8362d8d40f41fc65a0f4dae459a66608d9385b54d5813c5869515e2e1fe59c40b142faa861fd46c4ce3d24bd01a2389d83f456cd3ae68de28eb6dd5718b15124524a6ac6d926e223cd3c32da4905f4491d4180f20ab8b105c2a2b9139319139fe6eb2627225f7c55f867b21530813ec38e45adc9324b3dc70a857abe47885d709ab0e234a4702594fa09c452c50df6571ce8ed366d0b311f09bda435596ff4d52b1cd4a14fea5bfb3d73069d2c7eb63c505a6a135afd1b512d279c41493ed8e39b78968f5961aae1a0a11e2d45e7198fbade040a1df75e4477c37554352d34ef2cdc465e302953c6e3bfc6adc738bc5861198a0d9052b5ca9c8b34623b3da0b1d5333a1d53222554ee21e7b1ea990289fd4d6bd1d3be32a15d1242e073c39b714ec220a608ff1fe122b349ff671b33a830502dc94c941b102e41855247519093efa7aaa60a9b45e1f2fa7e49bfb680a0577456dd912ec69e7754de36cf8685a132d805cd85562dc7e9633e21da167cec2c3ef798865d2252a643245a8bf3720d9e4345952513c8036742abfe3dd4acf976e3ec91dfa6c08f3221fa4d13dd5f0619451ed82919565063d706cbf163d31a410d33aa9aa6ade5ec67dc90cde1e86e3b9710eca60683c776c9949d2230feb60c20edc8f239a0eb6b4ee9673276947ed4d416da79b4627ef6f543c6a11e62560f015c55524e8eeb879df7eb5a2d7809290f45ed7ffff048b5a5bed7dc0f9461a0f94df107d653759643f50ed0edaf17e4a66f274b78275ac00e28e92e38460a2fae62e63b580a866b2539b56cec0f9d3b1863675cce06049dfb1e46fe600944d4c490c2c46dd12490d19b065a76b3b5f8b41152cc8a4d66ffc4312cb7ed6fb6977f6e55f4c317c0730c71d2d77ddcc11836e42266933dfc94077abccd298ea27e157245eba86e0d4d23362c70e80a37ffa857c8a62774ba59937cba840eebf5ee788d45a34129b73cfd6087de5a2785fcaf1696abef1be23fc57d8d90158e086e8e548a08f70d6479f8c23875bbfd40f0e8f25333e30491c44802f7117f0064d74dc247fd47e2b68a42bfd9cf97c8470e82ecbd69bd3677316c9e59e7f3e2997585e4b1f510b54ba9e4902746fe70d11c9639904e606e98f4f41c86a46d0a2a7f4e257e08f4c60c1aa57479e8dc5f9052a65556bc7c1e1b75cdb29d8ad1ed6791166d9598e2717e2270dc6ca82e652ae71c10e4e5abdb35d0ed8a17b699c92ba53bb04eedc9cd447a581e9a01de5f96b8f36c1803d6388489048bb035f5d0ce65195bda3bfd78ef3e99e6c7fb9ae966bc8bcebe297b86cd76f2d462084cecd37d9c14f414e817a476b62fdb1bbff637ae69601722230187cd913f1f48cf86ed3efb62d926f2b558d92d569d41a26e16996739bb1c8cf20c6b8e4ee5afb414146a370afa481a881711dc7e17ea4d86987edfabe9401ae2b9f3663c7099fc574703544059c9bb647c36dcc83e1dacb948ccab15f7c90635fb866d55f9069c8bc04932bb901fe47e523b2555b6958cf28f7cc60fb34137ff05b46cb8ec350084f1b0887c3482cd55d6cf15a6891b9f41a888eeed84f4edf3fda46a2d6b615a145109f76487a330bc287c1e0b52bf875b742ac4e9755678e3aa36d3984c13beecdf30b5c4190a8e6ebabfa9b1bee943b2777bdae7c7fcdda9fc0791cc2dfab4a7e9986a9c9734057b49a4a796b12bb8b8cbfc704895f4afa93db7b26501c8ae380b4322894fe656d28a3966903b6042549df23fb98a8fe4eb05d1527b83cb9b24ed248335fedd7a3e75a07f9d83463976995f83f522a2a608359f00a23467500840f02659bdfbb3ea61c5aac882eb1c8aaf8bca8c8d306b1737064b61ecdb8758b13ebea8f818c48fec37c462ef10fac24d381acb8107cf73b44926116d9a01a4bc4ee2684f5adc3f9d090344a1a644f9d3c6f43a356e084d0ca2d17ca8f94224518679343c96aad6bf87a1f524a14e5ebdbd4220f7962e733b91288c485a9a5e07ce257aded8845f3ea76d42a66a12891f952f9af6e4db347601d09f1590c77206a4f3d93ea9f8697d5f464da1511c3567f05d0f7333d770f2ec820f90c3fdb996c4f9e981b75709b1c3ad2006649c25e1275d3433f3977c1b5d7154b809fc80363c9916c5f11cd41a79b3f2a960c15c38328caa5af321bec4177a9489ffadc1ebc030edd1145f4aa17ce573704930350817682751edb17f821b7a13bb15193be52fa7dfaf8a50bd529c33c32959ece2e50acd1d80f9c76af73232863f245be87563cebadea162154f33ee2d481fa39c3d3c21a071b7252d2d0d43f575f18051c7dd5c1f702562e957b59a317b7af0a273d8faa306f7d61ff9329afe0cf2482209821b74b341e7d0435c6e1824d42e96cb12e41480a326f8a90105767a7c57e06e5dacdc2e2d4478ce1c6ba53ec1a25a7d612c95f2fbe71e8093007b0d5efcc2e4d32c108e62f200255fd842c66cba6de72ecfd5f8807052f6a84224a501aaf27f2c9a5184fecb98ecf456993dc17765edb0cfc152a1a59111c3d9ae070aa070fce542dcc42deb667844b23c0c755925298ab87ed33fdfa7fa07be6d953aa3df540a439fc1ff1f05612ff5e39ca2b2141a5197375f9d2c455d6c4c842b7fb8201ff05a518e8a668b20d19cca5f6f0a9b8072eddf7daabde8081c6afe42e7481096bf3b6c71a48117cb36e70062827920353b4900360c15f461dc07ac232f5dd1b512a7cffaf45aaf8684c916a9dda6ca27a941e90974a2862150f0fb2a8102147daeb16dd6d8591f8721ccd7d75a080dfa0c1f0167bbb04955d2fdf87f6d1a0d675a910d03229dd1402060efdf08ed3c33b2865c19b5ea31db430a5f914b0ec9de8c0b4ee92eaa444471680cb54d7262c4882442986ed9d4f1af0b05f69c45d62c1f2c1bf9f639780b66d94de3745bc516fb5137cc80f62634c5917be987b12ff7c6b8aa105436d99afbf247d2b2aeac74efe1fdc17cd7876cf921b9313df12c373e1175434b39d5f0b5758eed97b9b41577c11350693444a1cc912abcc0addaac3b96cb39749ca7438ab556ebeb6814e992cc1d600ca67e565cf9b434cda44f255d517e439ce85eb7fffe211aef8983dd4ac2cea53c1de38fa8e78d8f85b67d5fa87272a42be7fe764f8c52d04af67c3dd471d69b49de58485ee87242287d851495d249f4523d5f18729c6c0141c8bd924aabed3c37dd8f669406eaa86057b510af527a59145ee7797afd7e8866bcef5150bc5dd7d517c173f3022f269b74a4e17a32c9ec66861841db57f41b26eeea7b3ea095d46f4dc7396c75d3772be0f428d22d6af583ad0d6908f199975662632541dddc9d4c502aaa0ebd7667f62be65cfc7f644b49454884d1b297d23e98f2e27cb6707e3ebe1f40a1d3f35dc68da28902a5cfa174d8daccd29d48e565455624c76b75bc97d64dba261e0cc04912fa12f33572108fd0ef71743e80868a8b8d0b7f1f21a0303537ff8a0fe3e061f6d89ff76f823c1b6594a4289fbc216cd61c7582226d6fabd341d552870926d64eb9509f26bb92e8662835662fe9e30fda722f22a6a6bae5b66ba9cc1bbe1946d809cefe3e6ee178a4f882189e2109cbc27b0b1941dc6f4df0d435b1bc5f2565b368c883b47e09fbb9f5427f3694e7c0f2513456f6efc73d222decf06cf4b184e8ae7140ffe1e142867bef3ab435e44e8a594e459a08248c8201c76b2b16858ef2e946b22153ff70fd1e062846d159e342a95612c6de9554984fa470d8ca4bc1653aa28ae9fc2216b7b95447b1c0b1d98ebf7b84c655be2a0e8cbe03418d4053dec918280efa02ce14865eb4b8f79bf50a1a7fa72bd727098afa652caba455205b7fd06da37248f97ecb82558483affd9ee3da1f828981029a7d104ddda3b3ad5ccfb3cc863610116e2df93cac8c5d12debb006408999ef4d5f4df8d9078c55d3c6a17ef08733f0cfe8bb2f256c01c869feef28237e57ca0b75ced4e24a7bfb0609be216a62090379a083fe9090b032340cad86184f078d2b363b519302f7021a656cd8ed122c0cbf2b606fa15d273863317e28e3bfcb808887ce1ec9808f873fbd23a7e0914c09f7905b966cdd258d9bb74b210cc844984d9abdd46aee992c07f88959ed02fe2132c54c51a4ea3a08588d0c8df9c54428bb9b016b840cfe748cd6fa2471c2f2abc556798d8e60bc71dac273be7210a8223257017ca7bd2229c7fa6a9d9f29132bf9c6830ddcf0951c23aaf58ac854cb4488acf7adc03ed31474f19c6f1716ea4e5d2e8e672f47680c5f32b08ba7debf2f0dd86d9bda820ce2985fb194926626d2032f50a9f290a134cc664c400856da16a3f38d00b93c5706d5156086e0d9cd41bab258046a07646dce3c3cdc141083adbe0b2b9665a7f35933f3b741bf3a69643e84739338965aaacd13ecbb5128e4c1887ffcf73c7b6c5d9682413f2234578bc415c24379ee27427979d4abe36b97449da8708e1b2197a0e1ee96ef231e4a458b0665f551f6d272cb0a87d12f1f5d34023bc3bf174cf91e6d82e40776ae1f7d6a95d40372c2d453fa30f13e309df3581bd1ecc0d579bf1a7a95f0e7645cd4d1f38ca644b00aa6853510743f4ffb90ba5304295a2a4ad1d62e66eff60f0dd6913af2676d604c16f4c37ae5188e404ad198ae4bfee3ad2a4a7d4d44264b6f55d16ced095032d6d4c5b87be056e694a816347a906a4fa5433370b42f0a4fafdf65dd3e97720b3dc7799e2888b8d3238c2b0e23bdcbcce430aff681f5671e7a6f8c760cf5a2ae7bdf0de72f0eb9ef5b4e7c3a1dddbe45a7f76fc9e323731e4b30c915c98899cfebef91b611b392a41e3450fafca550908f5854434d841089478204f2ddb76962ccd1bb8b408578449b85f546be5084b8da57f66d7c36c1b65829102bfdc4ea08fcb3fdd2d3649767930bdf9002bbc72a12365385314c70aeaba14a9d930826d93e80444df876080ec4c549b0b652e97cc96ae176d72b47c0182bcbba7cd6baa1e5e1a85c3b3b98974e0ff984499cac6e551bcc33980783e28d9179a2a32c56a1d9adb4dd7a8c25c1913f75b1fb4f830a7b818a7ef4d979f54bbd9d67885ca8e87b902ab0124d6227044e58a37c5354597efe48923d75f59ba0b8d7d18b0e3c3f11a503ff4ac6d7659bab80fb850be9c90c439ba84b683c35be17674cc721b55076c1f8efd6fcfd445ae2713c49073ea8644b1354daded0319b560e985c75aa94fe7a995c6f47fabf700bad92e6308cfac125d471eea53ef277d13a0115214ceb1e9582428c74fc0e0eaaaf091b88af1793ffa9608d908b4f99be2d290aac8de072ca962807446404a67d9296154411da06655869bad397c15a723ee841eee9990673bbb871b1950410c127abb51a20b501c3b53976adfdf44647e451f85f441483ed1c28bedca3837f37eb7adc03544ec0615299c5bb5daf411b02651b125518c013daf5f0a1eaff14c0c6b2bb1a9879f24282eae3de7e85f4ffbd35f0d1a97dc1ba0c82a5ee52f8458e186dcf94b325934a25e48afba8d4b5eecafe78a72b4c5acf9c0224a669bfe4cc3283e9badf7ab52f79465f0037da418b190cb626ee30ea00888b1339818138a208ecb5c3746ae997f0661140abe16a649ef0930d5d351260f0dc94b8df44b41574dd34ed1ec101944aacdc5f66ec3f67b8088717ddc42dbcf76745778a7caa6e411eaa8b28e6aceab3b1217b449a01d1a2a4786071d0b9a02919a596f921f16d1d9d2b250591736c838bd6871d20606ec73f6edaf4822c95485c15cc4a3b200dee5a1bdb8e0bb222c74bba523e6525534d01eefe7f23700ddc4a8b8e93e44e595236ed562fbc8ea5ca4d9778e80cc0af795d4ac7aef3f82cb29627028d03cba243cca7379cfd9cebecf7b9180f160c5d162d905b5fd84ce49a501b29e5c0efeffbedaa1ebe4199eb407b817e5fe7e54536ac9c63fea1b92c94bf7c72b92ad70133e2cb34582067c21e56f62d310a0eaf69da38d85fbb1a27e3c72cd8150414387ed754ad67b682fb5bb667736dcba68a6e4bd7fff9357ce641cbc05d6d956c77af444f02d883c18cd4da761a7f50293a6048e50d78da624c008f2aa5af12b50deee79b17cb2b358d15756f396a78e6172b6ccc0ec5a626b82fe48c80efae236f151c58479f851217ae9b2d0bf298066629c55e4f95e8c08f28f60a600f57f7bee5cf71b81d8f8d3124967e06887bbdcb520e7680aa1d4ad721fb2a44db6cde6e6bb528cd004dd2cdb301f745c8cb63a66d3648f62ac83976ff72d7fbb473d0b53f30fce7cc5fa82ff31574c8043df86fffd341a9e2eeefb5f33dc3cf20c6473d1f687a7ef51815a36f65040bd57a519a7557046daa5cbb17a24ba722f9609851b97ed9d77bbb2af2b8cf4f6a7c6559fadda918f3bf20e9f9f2f15dadf7f66b628f91dbf3987b8eef4543e6d573e02002bce37cb77cac60c1307afb33260690f8fd25dac8d0439c3bda2e08d1687ad6d303a1b8a33d8bd811db85a3c7e281f38a2e0aac5145410213c0d353936ac9d63ddf5c808c8ee0fef1a00d4bc69ccd2c3c86c4fbaded471b5deefafd3dcd121dcb945bb1aa1809639545a008c9dc1f51e15de711f9b4a751c1c154cfbfb04776f3d3b55f7a9d511838d0a414cfb4667def83cb934baca493784f7e2a627e66f4cd7f5b6bfd4f30ff63ff297fcbca97627eb54a48dab92389be59de85a39e1fd41649eea9018e78f1ee83ff53313d62eb94de78e51828e2fd5b1e32034dd3b1cd7b047ad9597868e886d8255755a3350171ee8f3fc8ee19a7b0998fe56cde114be21231cc4693f25e930f9de5c655ae83a32d4cbf4fddd24290305f7c66756c6ac49575fb0703d6fa4a25e5c95db84b79ef26239cffd4a2eb76a0525959ce0adbf6d1daec3c3e24737042216e95f92d283304690530df66a5bd68a83e55779aa74a09fac8be10688662008dc4fdc05508ba5e8aa427160e3be5f64b3f804bafc514b99208ea11e6313b6b1cda8869f1411edecff35448ebdb2f168c07721142ea34505f517a9b0bf235b3d3d5c1ec53c95767b2bb42e0ca0bdcd76648da038d58264df0b53a4cc4248f0f40d7d2f96a1a7878d6df269d12745fdd0a481aa8bfb45c6df464bb352eae911659cacb6a8a5abc95654225295ce4905d250c7c37ad3d8c785d6dcd98de98a9d5554179c02aedb645cf97f1b0fc5860823e1cb57ee5590ca717aa0971881337ab7478cb87ae663317e5320832317b2ef494751d9813e4c2a237f4ca787b24c8a4ee35d3b8446d73cbafc02f2a8d4ea5dbc1a6ddb8e15491ed3a3feeb3ebc5dcd4f65fd758ea3572f12567aed84b1b722f90bf4be6d14b0a83b1724b998089ec2ad7afbda5d67c1cc3f907986ed0d3408385f1dd7db1d320af7f793edc2c8422ccbfdce83db43099aea723402865c59dcf9d7c4755cf498eb68ab0fb2b2be2d8373f55b5c871d9b7483fe865f0f08094321712e796c80b4a0470fc454fc70a4e03e3d6bd5ba59eba97c475a1cd4cde416830fec50c1f243dbe5ad3f8ebfb22e955aae765a498711060da292e310ddb1ac56a806009253b1b94207737d76903d10bb4c420251ed7e3b20f477759b9ae930625fca126a9b267b43079d725822fefe721cbf2127066855ecf80b4911ab711141936ea19e962bf29448fe81aef52b204d7bdea3ca5dbcfa4410dee28a723f24e979310bb5aac16f92773fc8911179911c8e3be187516ea156cbc9de57daf065147c0cd204c60d30d50f9d51b0a1a40576ced1c5872f49eec68d521ff4633524423376af9b8d1abc92f8a2d37cb2561962c7755c7556799eed07783f14286fbe43ed5562bfcd94e58e0d9711e7d3d6f55aae57baae6ebc873e0caa4bde2144c8d3e452fc9a16e3399e25d6d2fc79c11976b861355c96e75787729b735cdbb51720043999ef53d2d6a9ab86af3d0b8b31810a86bc16fc1a6bb1047c3521ac87235d8457a59a2862c3dabad227d09a4543ebdf102242faa375458c9716118d196b0c1fab7d893d492972e04470c8318f28af804f63c045d25765db0374babc66fcbfa12d41812b3187bb25e067aac39a3c995deda8c3c622941d6f2797c2bb361c3d5f54b78f575df0657d73ba6a07993aff0067520bd04f404a338f9b99b1c2d889ab73d5a0edac7be89a337da9f982bb5511aacd42ee19de988ef0040199b041e4c2bb39b1288d3e5c69a422657296c36e1257157f56d7558819c3e771e3b77b949b967b944fab27b15ee03a82c717e65d8838574a5aace72ac6a241278737e5c5b830151f1557562bcb06b90effc65310d3344e86a7e0f2239e9f6dc6baa9dd3062019a217b9741549f3177fbd1f048c915f16efead9b50176160770090fce174f4a189e0ec45c939749a942d59303003c4fb6a3e0827db3fddc524461c057d593605e6bf4f79fd3e15a729c8ceeb19c944c2ea743e10c34acd6d5aa1700c0e64d7bce1304181ca7bf8fd2ca542aa75f172d2f7bd7f5aec34c5255541a10a7c181332e750e244d5e618210d6051175845a3f9f86f0b0fbb985a5ffda79898f58c60047adb0e6ca7636eb114f24764c57faa5fad4245f6dc6b6dd06c257e9df1bc44c16a19ea2454c39fdd12e9363359d9c97738cea80d616759cc61ca030230e0ca39a3cc6e9410b45171e269716fcfc0d3a14805d6965ba41e33da5f7909ff8fd39b663d248435d7b0f519f6d1bd00a8bd4e34e83985d7a1e7d2c433d7da776b88568306b0649ca5da38050f9f0f51a6197ab5cc6ca19afecfbe3012f05e5f5897d7829d1dae09bd446d225a8c9720d446990725c90cc324b6143789c78b2cfff9cdf4a5c8e9e934585aa2d01751522072df133da92d9fc8a34efc193e498021d72136fa4877c87991fc0f6781ef74ab77c0490c71e618bce5929aca0059559d052715dcd6f583c0799ea505bc8a2564e856a8ccf21ec1b2a11c2b8ce5d987bf7532bca33193dd4ca8d6a3b6344c59b93fc0658b835fbf12dd5bb198c56f2acc74526d451d3169d4ecbd05ec266af5f023ccce21020184caa5d8b07de567112b07d9e82cab12fea8525292f7e3979d682fd2456a7e6d65e5ac6f6faba0e0554bc456c2fe305739c0fccb7b6cebb4370d8cc119751a0cc3a3dbf2956fbc85868a48ad606f1e31d6679ee2660d33e263b84a36377e4c75b537f084bb2f1f15c7dfd0cea86b4c564f253108e015c1d97899a6b4f25901ddf05e75cdd604e458569acb6a0027fc5fc6d91256ae6b31b7117c4c88244e79c9b91b2421b517a325cf537bf8f7907f23f9350505b33ca8a2e2cae1fc0a40fa813cdc97e53f8e055790724b2f78c73484c9fd10b5d35ad00d3de2bdb7e18f81d0e0468b71a11e955b2ba673cf2fe5d84ecb0f37a1f9c7e5fe4f96b6f7452f550b3e07115744cc5499b54d7810321dbc21b1fb998e47d7ecc3d7d9de82745645a356f19797c45c74231130a3ae5706b1f199ee2d18354da152195c9eac785265ea0ffe2e0a108822fb2af4268f2c22033a3cde4aeff3df3bae4fe10fd0278abcc649a138f8cfab6e226b391bbec8d85c0729958fcacf09285c94fdf2ae0d6c18547b4494479525e06b7b272628464989f0d7682fa63b82a8a49a5881a8916860bfd04e6895cdf49541198c93f56574312cbbaca5a09886ca70f6e734bf3be16d93daaf656bc375155bfeacd1ec956e06dd5fb6c62628c0ce96e03d4c9e4d6766a0ef9b63d917ae3b9f51ad671a068a22c59add639ed04da43b90bedb471d4af888cf6537d140d7d1394d43d4ee4e497339c224773175b48d8d5461e53c9dfde1db34e4ff10d2dccc28d0e913699c163dd80ca9f05edcf060c3a01494ec74e5bbc0337f33e1ce183d525863db0ed6555106467620190fcc1513ad6b08d1ae017a57eecd2de6086176d01a57a7ee1d0535ed20e32f608e9b3aed0af721e379cdf1303e78a98b355c657c94489a5064b1bd954000bcd638e344c85487a9b542c63582b0e0168293674caf1397d6d59480e0d6f9f8a5652585df8d18c6242d6050726f51d9269e3c4f155209384ffc4c082d3edce838331696487d44264436f57c8cc864432e9c960034420627c52d2680fd02aa7b5b7164442fb8c28a55e8ac24b54f1e4a7df0723197463e0166541688c529b9684060438710967afef1e0f8ce856f7b86b2140542035d62d401fe32c71829ac856e6ed143681bb5744b0bf5340516a449b9e9e0bf9b4def8d0d47ba19abca78891b223413977639f3e294248eafdf8bbbb65493aeb6ac961de1c445e35918225588afb51a38eba32c5ecc2b02d81b9a560db3f40a63ef992aed4ce6bdb760b3a49e84a586c68dcc946b609d97b73699c993202cf5741079f33aad81bd0015f80c3202a1237967aff672f78308f158588ea5e907bff22ccca40b7bd2517603d297cfcf2ffe5d7f63619486d134e7c3e957a475444fadab5192dbb892dcbe2246ed13ce1e241eadf9add621016230a4c576c76a01840f4fd6a37606b4245f2261a354a629b738abe7be958bd193109bee0f659fc630f2f89cc91e071e2ce74d83ad4944be26079c2f25ae4945de89f13445756d5586ac0b0b1d3fbe6d8ea9a9765bc01b56cda6103b1eecde7d12c172ec0d64123d6771b8f6455cad07f39e025a0c170c63d11773f3417204b1c3c94b2a1ac8c645ba20d0aa8184ef5fad578002187872dc90d8bb61e154af3845d44d9dffc7ec1166bd33b8dd0c1599e16c419a7d9bd3f1fe9ac8c38bd4c6615c711065d83a3883cabc1f2bc9519a8d7b67a09935615f103ef443e003e70fd1debd53631bdf710f4b45047ea082971258422d0afe12ebbc4ef9b992627a4c49a9ebb70a06ae1f0462bc9e1eb47d76793752ea79831807f473884bf139ff080bc35d2ef9e58e94e01e4afe68efd4354e95db3ea52c68d1a790cc5274bf0980dcfa62a36d5152f5f9fc10e0ceb8bcd2cff96604bed8e1777a6b7e5074bf4aa0f544d481ee67547b7ef75364d026e501b1a7ac7c4f30742744cf57fe927e9cee5848da659985ee8e6f8244060a170d9206f2cae8a037122b2fbe45bd05cb0f697a911a2d656678e2bb4b21354727230850ba6bf142c218df38ffb4d98c5f7a3afd45add7562b3b1603aa073730967a17ba380582343d6421cc8be80f75c3b8f1fe78d9f4ed28773d035e64c46e939cc76fbb4a5e9c7b903836eefa653550c4b0c3165dc414af5820a1b4bcee7960e9f26f10648d43169e36edec1034073cc6d75653c6687bea52fcbae6ad01c3b1d7291b29ab9e41361d1e1946ea2888d477d2f80614a7b64ce03c12b6e18bd281237bf3fd87449dec279391630ae68538486df594d9b44d3ae37de5e60022b0adf451aba255c0601daccb75d56b76d02f8df6482aa77a4c70114d4afcd91b6c3d6f218246c72dc79d2f5c6e51b76da2a2484a855cf806c65e62bd97b35d05f6165fe08a2579371fefa8dc4a2d651276c2323a7c9afa68d65e7cee508c4e3005aa63344051b4f0769e6c1f20db422d407b588f8f0b9eee23ee81004a4068dc24670de1bdc21f620a52e2b93c850f14a478b155129af72f76fd243d9bf2520ba9ff5eb2b1d75ee971be47b179224af9c6b3f8ca74eb9b283e43dd577403406a053ac7a78c5e1041225ffce4693f0ed3a7924e96900191371de1d07d919533abf795b372268e3aeb61f949e21a3e4b019d05cf6c51a40e34ff183ef6df630f9f0abe4155a0fac6aae945979a65aea490adeca0cdffb5fdafffbc055b19c94ad93dcf3a7531da2bd2fcb558fe80276816d70af945072024717dbba81f1649837ed88196c25bbdb068911f38fb81a216af57682909f60d12da8fb0f52e0948758f7e8ba60e252ee9f9857a88dbb7cdc59aa02cfb7621a20dc3a3c8ae5d02fe7321a80eeac6f8c00b006aef8e662c5ce11c7dad176d1dfd216e505e327f4e7ec1c50b73b5aed22a312a9b32f8a8d686061b5b271c09d7eca7be6d879e70ccedfd8643f29e39d915f17bd79d6d4672a5aff92ac58e3a3d4780d0e38d89f613eadc0cb1e6394510a0fdcafdbdee7959dfa77d62183ce8090cb3f5febe4ee8f91133e47e653649728a9e481843b63e09aa353df3a6810f95b1d9ac67d839e73c628aedb824be41b1148b809b21b36efb8e28c692cd13194dcfb5396b7f7039929b7547fc346c9f5081dcc2f3288b7919ec977e20023b916d99f27763630b1fb76f9cf32ca5aa5e5de442157ec297e5bcc9c0b1a02542ab3f8572b4912688b4f36a5e8c9b1fbd768bc28bba056f7bbeeb892894b8aa3c5877073f2ab630cb0cb3beb9857562d00c82b447811127b7e682850581738adbc4383dbe785402212fdbe25028b11e5f061e95bfa6bca346368feda6bdc6f2ff46d94ec7a0b725f86f24ccc7f327b496bab4ca08f55e3478e4c3e970b76a75d9befceb6723ec04fc9b9529097fa7793339667c55d57abf60c8032975d346ac5030543c4d12129eb2a13072fc9dad8608ffb6d5004028dc0b4b4536e210663f3efe65bbbdfd558a0314893748998005d07844a07fae084c7aa660d5fb04350109dff159643032fa4e5cae3f5033db6eddb3edec36b2de90877a900f39b48763a0a9185f8e1f3f3f9b9f5c209d7e7118a4d70f287dd61c8be24523693524053169162fcba6417cc80101ca27df23e88db96cf09dd0d19a84597770d0d5a89d8bd55e53854f1606af7176","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
