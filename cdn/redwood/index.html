<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f945f86ecaa4011faa3e44f1550056dd0826f609aa1fde6ba4340be505717dc8f1b643733513159ed1ce9adb6ea97d8d5e08f27c94a81c0e36df2f96a4db97d93b646b95316471dc60f5a9c58b6c16b129db483bb8b033910ce126296d4c77f56016918d8f11981950ccd6eafdbc4beec98d8f2f52c70ac98b2133457b0f1d9412aa9f8a16e040488a87af6962ca71aad92bc8b3bc5fa382091c386dbe9541b9556e71e529c812fc9c8dbfb546f7c323b83e889fb7edaa0d7fd4af064d7d777f42b82511d8a7cc75d83bf962576c05cacc47caebcee7b46dff1aead1e3fc6255b7f354b93bd558795a18db763f9277dc80c4f4d6be797f88103041b2c16c63b0823501e2b99f2d58b096e8ec991c3c0d959cad32b2043a6a93dcec83fc0ff3d676a60c83fa8aeec9f2d1a06d48fa523251bcac1c093755bfec4dd61a2a8ceb8bb728ef5af357d3772bfa2e1f5238f1af310aac60ad4fe83f6f635e307822c50844f8fc8f4f394a8666f82c4564a66c5a2038efea3d38cf10d9d1ff0a1aa5afec2587f935e54bd157160f4b2302f52eb4c519212c42d88add67f7f3c409dfb4377842ef721cf3c323e4ca9b06c86ab5f7f078ece4d6c2e74c18475058c88aea345b305206eff2e8a5eee2f59521926f6ff9194d309880aecb580f3687ae0265c490ad109542f22530fde7066f3751bba26de016eb1c7e21e896d4b30244df8221dddc7464b66071de643c36e5612aaf4dd4e4ca1a7d9f1024b97115a47707de6d98fe1d074fb69ecd2a63ac8d6afef3063265dbefc4948a6edd7a432e65dc4dfcf05406ee59601da9d89d2475ad4eaf9db0946e08c901095993156c52e9f148095ea3d7cd92e1f38fdcf9ba44842b0018fee6c9f6175e6db672b89c92cc3314be98b1a37038adf0894b14fe77e1a36b25b4a22401549c195280db8fb9ad21751de668245295650a19efeb4e4272c4e6dffdf88b9ed1a801cb7c02db7fddb5b31e2411b51cf6fdf6cfabe9f48c4fe5adb2c2cb998c8dfcdc42264aa1c8cd7c223fac8a8ab3f65e545a4e731b482149270b998f58a5c10b23d2994f9123809273f31f759c7a03e807e6fb88a2f0cdb822fdb0be1ec43551406b36fc6ebeea1767d834301edc5225ea42a9ee2aad9f73eeeb8861010c5df69b8e07d88048e448a990bb8a382dbbbef07a8dc0c1ede906fbe8507780fd0b55b9adb343172e168cfadcccd952a9b90778831658d3b9fde8ea93b75376ddff78f8455621a92dbf0d3b347c3ec5839568e786187d23447f131b9deb0819886bb4af3c3e445050b82dd3f3ac88303aba9a92f1d647aca55d4d2eea80fed803b212d9852e50a1cf5ab6e63ba178f4303192b8124d2c8381299c729a552e11874b69e302e75164a3bb6dc6b15c0db6cf5d4d8613f35e86844b55586f7a8ed476bf21f88710c1c7725ff95a2429749aadfa5bdabd5507a886f4c7a0fe282da5f93bf929aada27370caab106386299334a1e36d2e0af7c9762525af6470300a476e4e5e39d3d14ab6e375e370c82570e6196e3b9e5632282c646def6c21f0ef49c80242df92fc46f6bfa4d94c07452c55b4ec9d77d5c2902c08d5e5d25a4026adf1e0289e5b06e6e2a2176565e06ab36125604982c91f619b44b81e19f5108e8a4478043fd9f66864657638749af943a6582ff919f8e583e5668b0d9f663111b056688804b6a113cd5f11e555ab1eae62ac357c7792091f78a07144541cb539aeceddaec090fb7695aabef1195f9fdfbb8a876f22d8b39f7d4b4f445bc7ea4b7eef80bb546ff4cad63aa9295caa8676c823efc919b9ebfbbbf17cb015b88f9d57bd4c3a2a35973ac24575677317ef2729cde0378706651e3e2af3b2e31bee088d382a41c9f67e54bf0543933baf268b9483b61e962137612fad1b4a3dbd6abb8b92e399ef8fa244e984c01f313f7b18acb2a7a3b2f664e4179fc5af5e75e42a5eef311ffee0707668c0c2aafc22efeacf063a6c9c99746123fad1d29bb48d338abba689c9ac35af4b9e40fa2cf048485f80cef5e6b094e408a6b5748139da33b0389d66e61a546f5af9f374c54e3143bb44f4fb186a1ae96b00030ec4511b6be66907ae5df84b42a2a10d1012eb44541be10321c9437f4505316f8f89af005eccff2818e0f2fd43099986b7869d2ee1eda3ea8a0fa154011ece1c6068069dc0fb483452964bc4c634719a966fbda770c9983072a2df623cdae3b6bdcf5520d701f9ac164d4c0606d1b31a02e66316c6adff3eb2eb95e24ea2cf82c0217c2755203d722d5e44a5516324b109fc80720a6cddcc1d7b8b9883c36e10cba8d32e48443e1554d32ed184701e00771b30538db29427b271291201bcee4ec9f19e8a3ffcf4b49986ba02ca06baea72b2a4b10dbf737c2275dae5b55574031d459f13f6ce8a11bd5fa2415d6cc329f516ef67cb76f4ac166588c28c68b5372c2564baa8cf3129875f7ea8ceb2a776deb76406ac9d6c9cc86fab3aaf2db3f280700cbc2ec2eddfd6494204afbbab5c1ea6ec1a9d636f234d4b77ee1586605232a8103d51c51cc4ce6bc70e3ea2ca10ece9e465116135ee8b362a93c1ad1e7d42d768f1d3260a1fa1919a69c73b34b90139f60c1eea22dde17bd33196076e15cfdbf759af4cfd4aeda3a5ebbea4fbf5fa83f7727fc0dc2083f26ffc17c2cbfaf4181dea057ac6511786d88a0bd446ccc7e150dca9b1db70d99ccf87c6faa1ca83bd78b441fd6e46907f27c95cafdba25e6db6ca1eea03e832393f3109d2c319500bef54164cdd17063a24178df43a8683da7bbb12aed2fff6acafb6769d6142db2391d7b1d93abbe4d02b9f1cfc78621839c78f6e9ecf6a2c3533f7d1aca70be0bc62853079e7dea96f84a30a4b7923a23398c1aef06be5f2c4769db84fc13c668815e68fc0f55171ec5375f189be75aa0e1eff0fb41b5709177c191e885c735ec234d0a2c332812be310da6a1f36e1e85e58d9cd3a389ed20f51b41e4e6adb4cee93de6d42610b632b01756fbccffeb7663206840a5545a96c9bc6a2d84117542f0d57ec286151388c1d8932fc35d470ce32b027c6315ca1ff10bb0e2ef191688c5d1b854cb69d92478666cf50cbc0d0aae2755ff4bd407c07acb00ebe9baee36db6a11b37c7ef41ed59751880910beb4ce2ad44e9f628ba786a0ad33a20138aa6ee22470c552150d04a8e3e538972083a94c0698ec2daf612f9dfbb7bae215f8c78ba3b621f32804f6fcd8a14231970056fb7a744e9fb18af77d1c94245da76c3db787de6d7e133ff489b63a64fe813484912d728b7ab74e80bd8cedbc2377757985c5b535fd745c5bd7c8f851dc2bc5fc49d43b9da07c140ff6ae8aa06d1ee402fef6780d734877f5bf89e11ba8e7962aaaf57156865d8ff87eaae782b5d576fb263ccf632459e68af1bf5e89c3ea3bdcef0eb65ca2a4a978152550a4c7684a23303aa5d2024ea1d38cfdc3e2b61a6ee3f3aa8f123eacd8269ebee85392e665a843b11e05107daa78a6fb1c2ddcdb64bdabc10dcced01b3a5ab24827753aed61c8d6f32bf2aeb3e199b348123b50f5485f66adfdec446281ed403dd5f1fb51783a5a7ad817662fd620caa4ad6d2da0027154eb5b1b047b1f8247324fcfdd21a11b5ccd733367fba85c8840972ca3d32bf60381ff23691a18507a105f313f478615838357586b28c5a211e76b5dba0d037b711f71ae282622c29409e0e68445eebabb609309442beaf6bef53581471b085a9084d95d4b683a4192523f34334b7550811ca46addde591f1458f501671f550e39624d1b256f003dfc8a1ca1d14f07e64fc45ef018a6f35360f1f3d82314dc4dd2185d7c896ed54f6dc9df723e5432a73532852ad3d512f621976fa1b8326be53416bab03a4f87611948f48c487cd5f01ac255a138454f6e0070941bd45c3d7e27e0b7d15b49132a501da466d3f7b2918ca59f2ef578b5aebfa30fade443b7716b90c7c4f6e7b489d38cf178ac729870ed74806d092c0a6a1a60501fdf332330f64ed0208e06b612777a44f69d0bdccca9e58f015cd8a841e5a900d876538e25ffda1d291991a1fcdc27c53cdbffe2c3b84ce9a51c7a8889176e9ff189ba1938eec48c43340d1f0156c722f453d0517495b32ae5ad11a7589000447ac993b6914bab4dddccd77dd265ea26076262e95cf04e1fa6c02d754f449a8da4fb5e5634c66075aff674597f6acc1b7a0a08cd9dc7c37d8583f1b5896af472f7c5039c1bc64ffcf78ee875a923d0a685ee16a824a3da24a70a3e4cf32765b4a4884ce519a9ac332561f615681af304ed38c2597c1446b86d59a5dab6f6c89f674622565c8b11fb2cedcdbca74fa593c8f4f9e9ccc97eb4e7f80407355314b83f2989b9aea16a7b570826cfdd10cc7b3a6086dfd67aa4421868c7aa5dfc48e38187c5b4545e2cb2fcd01c0e7c0a010b0fd9e25d876dda7a29bf620c4d5a251a58a61540a3c915f120c11879d32d11b04b3f84a5fe0ad78c61f0dd498cbc8bfcfb4e2ec9aa2e31b95e0871f7855166255050c6c037d0897f31d77516c2cc133f6ca5c446c767d2b73e15eaf05702ba595bda2078f71d6af32db4816b674d8b27e7dd40af7e4476048becb249c66d2c543e73f83dc0bd1640193af676237f4f6cf4958df0eeccc3801f9c91062869b90843bd79941da8e726742eb05da89728fb4ad23be75e222d233ebc1ccbe4df367b53cfcaee37565f959a38ca6fbfd2b2873764024351fdd4a9c65781473ada6ac07c13750060a7fcfe1922d48e24a72b9ca32bb73ee1f972c89130a3006860cda4ec3ce467004d01a5935cfd5392835a3a599971ed20688ff65f84c6793c272058ad53f293670a6b4b5f552f9f22ac270967827b8930f8716769dbf69cf03180ff74d7a1fd56b4861c4669b9572c1429f6826c612ab543a799f1d581bc8d292e2c2fa8be0c368fac2f578b7085e2aa5a143e80ec4e76f020e722b1ece48921bf09eb1d07a6fc477fa636f757429dea86468dce6de7fa83123cb76009bee3e93c1ba8dacd40837125af04ab151bb22817d65b199342008d8e7b83ef3f2365078b1a1c6c6ed3754d6009861336ee724f94e8dbf42c110a97b55b21f15da882c7ff3f9faa5d7e8f5b52c5f403f38f23e648ceec717bed68880587dc35a7ea9c14346af984a448e7f147dc4009c9ecb2fc29b1ee1daa17e2103d2dea8f2f99080c99b0cbdafff0174b8215f4c792b7881beca9f0061d9cccd60dd3b85af808e479d296c81358cedbb37d3e27a70b564a86c9f7c7fbb38b91136aa8bcf067d6e7c2667e611235954ea410fa836155388e2ab067f024770f1c2de3d427103375491928f7120a00584ce10092dfe309c8f1a5bc67950fc40818aba0180ed53d1f0084ab2ea4508ad3c36d58242efc1c1b95cb6b775f1ace04139658f471cc9f55d7118477151f049e7735b5b6fa6d38529294d8b08fdb73ec962c2fdf710a8995710b3510819c9ca462ddc88d779cc75e05c96fb771d3c124fc67dfd8c2510545151f3574df7974a3591ed351fda1bdcd593e4ba74760e005c6b0439464a69abf871bd4295785789c7635c1bdfc9353738293e6e4c4c548725f2b567fd862a080a62a00c65f6a69c98228fe36c80670929a57ca1774e3b91d85b5487558e3c61571c2c6fd713e74574a660c8f71f2b79981494b7fab97ae83ec083564731b08d396411475d9caa8f156adbe651812625844d94008c49d877e9c2b3cbd198ebdc855dac926525348dc3a6bd0607e85a8ff0547e083ae7e56be12c811f3161f294320b9a4ab949893e166d3b5697134e49ef15fd3c3d3c53ae7403446e3751b7f3fca3fd9818b679b4564f48fdb4408c013448b738f210a70daeb3acd2c564032077dc014743e3a3e845b36ed9e85945d13e6f691ff45b591bb4a040782867e1b4a7cc8948852e6eb13d3f00389b0f00e9387f79837f7e5f7550c14cda7909a13a6d117610b4a4565b37cff958b4d6cb539357979904ea1dcc55a3073183b25cd0e03b7711f9fadc295c63191598793146bc1000021158dec8e9def23ec0977c2a3c767ab4cb47f353313ccbc5289b10fb8d6db93c4827c71d347707d612239d36513ef1fdc26749a9530c9479f7730e7f63e70e92ea355247913061f7927cfc905c2ee9da131223fe7d05bfb5d44fe236404b93011c788c7f8ef0f327c065f4d3f356254bafee2d3a31eafc7a24c9cd93d094560dec397cb6822b67ffa72ed491aa8585f418f2cf9a6e2cc6682418eaff1c5b5373bfbcb3a286e27b8bba4ff5703e0f2219d48b9676325b73ac4b3879580567797657f970e71a782183fb435f6517691aafead4d0db037646fca09a57f976a8ffc766a34fb2cb66075324005c630f4919dacc0676033901a54f57a9fa0dc2b22c0ec34db2ce2d785ac7b42e499442d85d9c0f771e827a23299b98d26d0f9baf65cb57b8652c24476bfedbd23887ef275b22043f223c3a9066dbdb9179bcd5586f31c15fcaf31b0fccf59aae6f6d167a0786530ee73e4efa2a454f78b1fbc64c65cf4213245dcc366386bb806c0ddab99030ec8c2621f49da1d8912048a993af3d21c7f87cc54ffd44ae060efd906b8996abecedd2491504f45e9f076c4436df257e3dd4fa0110c81d69f98efe577a145f8ecf71bc8a8b4ca8ff306d26fa9ae82065b58aef87c17401c08115c1bbd0046993b652465c56662bdef3d0366b54f30a098ac360ed076fe186c35d4c47212fe51de21c04187d504624e2a4e094b419815cf288e0e51369ccba93cd0eb57a939bff9c017e3a1192cbf03fc6d12db16b0b69fb482727d2a7ad0e96b48c243866c87fed9aafc8dd214ca83dd647fee6ee9efa0df101cc327b525bc65f02499e8c85482a410eb3117bfcd10ddac3118ed17fc17557c084e8b077c11d13487b679833eea3ad29ae01241d46b948e5a8892a60ebc16a716e3a69df59920d1ea59a0c68f7dbfb96fef995e463942c0b7229747e65b79cdb52b29ebb7247b7876e4b9a9b0c4fdb9a2d42767bb97d7f36ba4e8dbd426d271f229dd2034980282e0bf6f0b850c48722e7ab6994249f46d5dc0b703ffca79465605e5a6d9bea7192039b870812c156af724ab45c3411ed041d17338c87abbf67e848805987b95ac9ca040b379b8e43fd36c5df4afc9b78be6af997c3b7bad3faf49d8bf2a943296fc79998a4d3f8b14d2bc65eee2efead08320ee4629d2cbad0281acf6e90adf8043dc16c9735db188a88297ef18b537fa936e07f8dec11c6c932bfe0b5c2b064141f21dd9277772e0981cceae6d3727e276610561f9a41363d984453422d63ee75cb3472bd927a710d620f0e47d528b8d3e3eefa7d05a5c9be6e7bc85d3b80814f9ca51e41b7d8b0df4fb9e4d08ecf1a261e3df3285f9b9761759ca0ceb45c764e0344fa38716624f3d24ecaef0a8973437c136b4a32675b351e108fbf80e63ed6c56309e7bd06ca8de41107c716f76326facb90b482535d17a13cea1487ddb843c86ddf43ddfdc0573f9cbce07285d8b8aa0e3bf860029785096c03a8c1173afdfc5b4713791aa5070c6496167881880348b98658a276baaf6ff4f3c09fc608360f1088cf96c49adbe18319e2066d22cc15ff0476343cb7a37f937759006a3ee99c705252b2f6879a18f7231dca190d7c38c307aea61eb566951a8107f0a28bb773140314bda98f0b198ca3dd9a203eeb3fa59a4cdd8b37fda549faec5680ba0887bd9a1a64e53e43688d668e1f21bf676580e76a79e97952a12539748d399d41f352eedfb8d72aa8dc3c3197aed1f7626ac02b731b18f8627e92ccdc89e253c3714d9ec688c4f9455a1df0ba3a9e613bad52a4338e09a3835e90353d08d4c1adfed1597b3cfa79749df61d09811d909c7e8bdef850a819ae1aba07f075c4eb5945e7e6e1d000651ebe888c161756141f52da511331b5c4d347204e3bc8ed7ea638c5c0e5de368639671c30e43611a1232308d39fd0b11f02ee9635b12959c813499267e362eaa20dd9672c620f905be772ff2cce214ec2da936210b6f09a545c69f9e2829bbe951f5b230a53ec853cef2d51a199ffd7456fc287aea4a3ba0a9cd8c7eca81bf7d0d02287bfa82b762c2458ad4e052d439bba29a340b99ea227cf54b655637c37727bfb10858d5fe7e041c479b0554bdcffa04be3ed15d467ddb9f86250a878ad1238c2f97bb8836928aa86154e5fa6e20d348564d493dc955d016f650b4dcd1d88bc9e3420a25850c7f4d53cf26df3ad96dda3f980d6257704e92182f5c77931fe7256b88184783767dd9990d192a80fcb37e87f9377f91a68294e23f77d3d1b712b3808ecbcd7a44259b37277318cf9efc4c47202f80d7fe6d85954c8a765e7f4ca56b45d61f5f08d3b653ac30a59b92065cfef3a5089c800041e01842d204b902b863fb1fae09135e4deb3332924815668b4aea17f5ae000a98765cf6ac4d6279fb041d0804e946162e7424f9b96d66d19cfb1d902c56a2034b7dab761368fed13d72e1d8cd5d6ca618758a38b2873cb83d8b8a0f378298e97b72d439b9a72e11786f172b4639820132dd4e0624c4db6006043c2047bcf8cff397390beb119be455415a1ca4732e36a505485374c9546551937d22ec8722b8990e1b02a6aa892235f3097eec4a95f500cb75fb6dd40678fbeb003cadf50744fd383810f2949c023e01e0dc2e71449983bcaab6449fe7385aeda9fa9afa16b9ab07cabcc3b27768109da47c8ab92b26cdd439cdaf4670442049d86f764203cee775035799170e33509136db135f31b856881a5e144241a1e2d264eb867b1a19bb9fb31ec0e0ff7011323b6c33d6630f64790b134b390a6b5cecfdce9cf3bf6e4ca8a248a8148356f2f79ddeb7fe06aeb58f287147942da77c212299bff069aecd989a0f5c80fbea71bc199065c8bfcb5e418a9c92c6bb4571a4ff2c4f2ad118da9ca207d8f0159d1338d27b870f255108580912ef5b38076e48f193ed4c20bf1e7c0cf55667887e163dd04fa92e32401b05a605c6a5f2fa9cad042282f408e1370e8e35e50a3543666b9e2a265860f825ce4ad6de44e139fa1cd9f409214db1656c910b646402c775bf257d8bf0af5c7c814482d10b474a919f81f5ca669e360d87491814acdf2912c5d71835a0bdd27781ca1164d97a57e1e69813fcd704385881524414088b111087c718e03de4b7d9fb34541f9b9568faaddf66fa8eb1d80342dc008ba1fc5abd7480d5e5bfb02338d8058234b31800d8d0eda2f6631a5f0b50ab753516b2fd7984cd129218ef4ea0b9f573c258e250864d05f064d5c95e9173d38b31beb8d6cbdd1cd3656c4fbed9a561f92524de90a170f633fe0ee1768e3ad1925115704707bb7704a04e29c762474bfaf67b2f6011ea76eb6a58576daf17d4f41413c19c104e6b8bccacc4e93e14c99b76e62020e1bf572f3e0a7746395539ecbdc27d71abc12afbbf8fa6c23a9fe9f9a6ff8a5484af7ab025cad75f246cc139ab5cefb545dbb07e8674f1c0aec3de21d2a319d3a4e1f5885d13696337b9e6e11a3cb2637849241c027f5b19e37f049036ad7f5cdedd11681b22b6347045c3c8bc065f19f4872fa81cf52466e5f6a43e4e60238cb04d5a03baba1b7ef6102790e48a4fb397ab947d628741c2b6e9fc98ae60a5109464164ee16e617b9325dde28fed6467dcfa48e00f94aa0b29cf5e8e31d59f229cbbbb9250085ced3dfca4c8d1180aa9c4bd8da9c6425c8f70570aeee6d65ff0719f008e239c52cde406b6a0e78147b9a7dcbb9a6c4adcba41cf673f3f560d35b32ed7fd5be09176e33d3e184608dcf36ae9d8666f8344ac7f76f5d7bb0f4709a45ea6887cfc1c044552c18826e864c20d76de7c265e5700bbcd6a5da0c33cc046a71fc0257e6b950f574f02c156691905292106a15cb43faa7707fe1190f305a2fb80a7a9809968418782ac3ace2dbb8c55c61d4a1fc12271f9d0c8969eebcb0086212aa8bc896412ec33766ae5b5e5535ddf31a1b7e6e20236acad2f1307d8d04e1e1dfc7d8683b63f87a9201c250c0ab98a49e515cdb6c8d521681e3216acbe01780f22011ccd8e6e0376357b40a2a6967da8d959acf7dd3d4c3df8f4de8b2cdc732aeba5dcd961a79334d1888f4c3f54b9ff5e6b61f93a11d8b8925c1453e3c6fa6bc361a9fd48b24c747ba845676fc5e09c4f9e251ea91fc7ebad25a564e467e0d298f4929cb5c4be91739a260e5d480ed1ae723af41e2418dd071d6712e19f60450656b2df7d12c961411789da0bec97e872ac9ce80b63c8f7638c72b0fecd3fb45f62c842d75869bd23653d2254674ce0ebf76132554488c98c2e38b41ed8ee513118c5772b97b54c87ba64dd5dcb9ea14f7b891bd21a50cc68e7470b43b990664f4c8356337a5f82935a1c14650375b7dd50a733e45e389cf2e140a4a1573b2d61665da5f6039f7510735c7ba2e4ca42c0b07549dda55a2e211bdf4d560ea1d0bc7894a0c4cdeaa9603e0a718c2d4d738309821aff1f6a4f09ed57c342e278b301c7b659447f7f973d8a4cbc24572a5bba4f3b07ace003286963771c6ec51bf9061b2acae76174034c366043304524d217c5b2f967174975bac49d0f587e63e5847c7c191957571b5ef3a9db8c2ce309c55cf5c66b348ca3af745af75b338c412fb8d9225d8bb34b56207e21fc99b207fa672665066d69ace9889f36dd5125ecacd37c98ef83ee2016440fe1f355c3830fbd0d97fee49b48e9c825e55f9d12a760c15c3279d2d11cf43a58e5e09600d5600e32ac0bdcd98c304a5292d995a25655a5cafb1e2db37bd87d52b1e0ca8133a767e5c96edd501f4d1f5e88969e9b95b41e9bbb09009ebd4114c6be410f773c21ecccd7c2adb8b2e19c46c618f5194e588304a5337e1dcc98df105e51a49aad1538c86cfb84b7aee3b27f1ff5b0f30b96a715d4fc3612f5d7f219b60b45558090f46b1e0976c39f6940d72f8beb1229e309f05d13f0039fdca26b1b0db75069b0c4e8951771f1cd3bbb3b6b543dafb2fc5a8e2d3173fdbac3fb098b9281e997ce224dd9c85e52b84211275b7f085ba7edd063d3cac30b4524f5bd6cd31d9c69978b9d5d3a04d28a11c3d6f2b0fbe209b3aa7fbe56ab8497de91ac45fd87d5adb6a0cbb9778b3c57e101de763becccb0d9a46ecd90268729ad58c2fe71cbdd8fb5312faa33665d8ce8d44b569216d068bcbf6a45d0ddf4ac10eb1ba66a5ea95b15dd1d52691ec8516d85ea805d53cd56c8dfe46e34b0747cf32c68592d1fdbb581ce5195dae05444f4a3ff60c26998c43a62ed28ae08b748afefecdd7089bcb7818beba56ee838b9e02f9151772926a6342224960501e55ce71eb616bc2e436837525ac0963eb07252902695ee76d1e8070352c381767d31b90e073d0184b4a39bce5ccd896aae44dfd81267ac0890478b6213024066572d9aae421f998ede6e69e8874e3ba058b5d81fbd820151935be9937b43cd75c6642df2fb80cb951581b720c2772098ed6041393ae4b01ec7cf1b9d75c7949947403cdd4ed6ad0976b664c9f0990f32dd00679947c3fe07d43d67730b216bf91de1d869c6fb692e3c9c42b07271a11c4b919c0cf3edb52f5fa774a114646ea7299cf134ec5657ac67256d0278875fc9916b823bf2437dbfa1b0bbe00d0e83af8b980febcc7280155ffcf186c620120e1c8f2a6110a53f1e214563ddcbbb110fa2e9d597c40838b36cf8da398a576d774c7ad4d89148a532cd4cdd0041a50dbe5c10adcc288bb76475b29e40125fb7685a30df34cc3d75d2a283c8059f0fbabb6a413e59ebce3c9d02786c945ed0324ab0658b511e4918b2c7f7ed0e44561c2454a4465e66ce4d38d496d9c3f7f9f4877ed4be3a6971839c2bf534b3d3b67e598c84ff2c2a4ca70a9deb59c2663e915e977230f8b3726fbe552f8ab13de407eae2fe52b2a6ce222eb5fcc960a3c25b7dcd12df3c8618e5989a169903a883334360ec3219c09ac2b3ab049cb8c28346f1b9a55ad52f16cc8aeb31c3ccd4ff21e2039725390724a734c7d392cbb3c4d1cc97965fa757b97aaae3dedec922bed1b438f5174c3519016fc09d2df46f066d7555149cbd309b36cd46e2bf7b353556f9b52f8742eeed8da73363240f795c9ed99066cd84086088221b14dc3b072d7b64a9a4b33782af8ac7369b9b118dcbb7e5254826a8985da38403044968ce5ce6aa36e5b25da75dc77c6e7c830dceb3b1f885702fd4aa559e5e6f9d35e2ae6346a421e24093cde24d53ef77759559e876b60edfe3ba3c759782b4fbdb360ddc08cacb8f0d81862a21a021ae15522189e94dfef830ee50f644dd369182666e7f7a43ae4b200154e88bb1fe8d92e82f132a299dcd7f5b2575be7c2f7800bab2f2f773f0d1c09b182785eefed2ddf1a6cbed9c52b083c927347281e61e235c9975c4a8685b4bb277995c3d19110496e71bc3b22da4e26b3fb537c4688458f06701d1b3921a260ed21e52e3ac7dc2bae724961d17cb58fe22399c3ce793cb098cce5d45650a8af1ac956a73ed07ae14784f00c3e43d7edd49b3134e29a7ff306ed8f1b464986f2c3386bcc559d9a9b7cbbb95292a9b323e151e927f1093d19f6d4473acb2b1dd47e16119cef04aaca5a8f11a73a8c2c01f0306a689211b4742730663ac36448d581a37a32d33b2ccc4f1ea643ff7b06ed99882e1b9b80e6778c4be041ffe6ca0c0cabfa98ddc040ee6e9a1e0f65721f1528d9001b085bf702a01f23336ce8ce955bfbfc489d56e3bbf5fd0bf5add3818587c17317c975262142744e368fecdce52054d4592677b96668fe84ea3192f5fcf793a949caebc504f33fbfa581e727598785faca2515934d93c6853d203c32c21ea3f3d742130a01cb837eba3d5c0273faa4a53d474c908473f089f69fb0861e3c09f2eb3bc71fb5894030dce9c9ee72f597ac6cb6204781d674a70faee7fe96754c2fbae07103590b9d01b0e3c063fb71c884675265e0d3a55f69090a69f227b5f8727a04d2141e4821ec979b1f2336d9919e8bf4c2fe8ffd4c7fa3c3249227b3fce00643f14302139d98577dadeb87b469930f800aac2df6ef372c67a0739053d0c00e75c9c3e3f51fab0f52e55cd74404daf09a3375d9e856b0e2270e94fdd7670389fd47fac9c0ae2208a8ff8db5cdfc12be9e340dfed437f60d4be52ddad29a0b41811d7056b78994fa45e52df5d240e9695a2bda80d91665ff610b4f2a58ff13d667af6c654c9ae6cc752239eb76045b1201739497f4fc4e087860ef8e7e93b2be6a7240819ccc3aaebf3bda646fce49508b11d2b3120a731665931b9efdfe22b9dc4d7a832bcd2f3a774c927c6287ec79a677312cfb286da4b11856241cbb61de3c61a83aea475d6d070c4c13e245830222cd68bdfb5dc1362002ccaacdad6b250e839da02aece541dc16d4d2a2e1c92db08f3ed78d26f7e721ad82440e9d2d9fdaf0e5ffbaa6abe91a6821fd3c2ace99dcddf6a0a4965aa351cda4e796aeffeb933fe963ad649fc7268b63623aa627f55705902aaa3358adaa7a6a8258d7db0893899f9516cc2686c695c218ad7b7de368ba79253cd8011cd518f23e10018648d094306dad24d834d73d9aa4f524e812d53fac7b6922a95d78435c956bbf2b76b102aac3b79505af58a475104156e48c59064828ccd8b54d3c4adedce88d5ab90d72719f25cb82c7a17a68987b55206eb8990c257185d6a23de7a5670b0ec6a628407e84b0edad762634f49667e73d3505ce14cfa3dc4f7dbfbb99ee39b76ff5fb1f839957b4a88a985b279cce20248c25e0e05f7e80d7d2b5dc0f96ce0b70763fdab44a30f6be46b442c757ad1768b67e8ebcfb0538c10d62a0c222c36e466bdf433812407374c4224f6b66270efdb53625f544ae0b4090e3f080d433882ac4544713eff3d3914449815df9beeea29217c9fc707cc66dd7729d40f5b978a701ebc5dfd12420a218cfbb9c1005f8457c3f03d38caa66a4610c44950b03449bb5e2dddaa772df19cf5632c95b914726544f8af046bfe2bf5d6dbc22df9a64d48ed82b55557f96c81d19525fd8c4f9f511b00f32c25d783cb3333008cb55d4c444c4b4ec098a6d14f7800782d861a6244af8db8a00bf4293ee8bd63483562f1de8bc3b216d2343767006a71be0bb9f496b201c70bc7ead36bf50e4aff2887f07487db893e818397614635a4797493eab11469d079ac8ea4e4d26a2a4d51e9e0af74e9e2d32fc9c1355ac815f3d4a1a09928e9f7edda6dc4916cc072a97d0f4972fc7ccbef119cc06e1e4c30f231f255269b7ad6b99b1bc23ad8f3ad1adbd97ce89f6e0d222e655f290e2a414390a7e317a04d6c972498ecdb298fc12cc79bcd82e4f3162e68c40a9685a11b1c96f0ed45d27d5a2332de50a1a6e23e5c350f985c2d4ecf494aa21b8a2f9f04276a9d777423d81ec3584a303036bb6b32a6da7adaf13299556f56ca64d04a0d39f475d33838bbb857f8738de0ff8d91d28049a1cccb33e591ad349d919c362e2a5a7c1acbe133db19708f2169403565452c7681bbddf64da1d8eb60021ce7dffc74ba3123fd2b43f5c7cf193e862636157bd440185058947850a5728353b935a16fdd38dd84db5de80c7e38f5e4ab8cbb576637afa54716a0c4a159e817b6b8a76880843b969991de1ebcf380d15fbf48a53883a80fbb050ab8e117741d9085c58d6542253787f29686c273ef08aa68f4e23e238b4f8b98281f5e76c1ba279b9620ccb7b647fc6be564868aef887f50fc92b5a944e1c82e62f6b991593f350a9ab00434c3cf164c33f58ca4127504405a92c44ba2ac01d80b22abc69ae49d07323e3e32ec05285193ff83276c51314c72f21ba49fc5bf53fb80386eaca2d77444b7fbeaff2bbac951406e2cb00865f0dd91f1761b70788183a4e2937dc60a8e7326ef99213aec4690cd03cd034c241280c21781238c2515c1b1687db34f8a02c28a7228442feda2d1155e7a3225c87fa9169ade811be368d02304010698b9c4d64b4ed5046529da64bf2c066a0803a294af618208dd17e1ce00c11d5399cf48dccaf092e879c5927b241933e26daa20bda5c2effe3429c050bd4e518757a9501c739dfcdfc8a7cb2c4e584a4fcca03ce576a63af07328bfba97f6464c89ba0531bd0918722e2282b3c91abd7428295b944ca174d3ceb8fbd4953e670c6493ab86067a253e297d699572f893d5eb7a95e2f2ecbb18a808a36a0dbddb65789ffdf684f9faee1dc3c1e81ee27fa2697f36d5d0389749c9bac791842d40c47b5bd21d8e9678f16b81ea63756cf51054462119ef5f2cbec6b1802594a770aa67e3f40d4e6c8e79ad970bc5781155290df968c28b83d3f1bb8861452c7a75878514944b654c2231e720dff85f77369fe383fce6cd6c53e87a50c3443d424733050fbf15791985e02e8242dc8a875140076e639289ed8c4e8ed346c6830b0c95f3035f7b2b8a48c43e313526148d1ddf1c108bcdbcc1fda0b82bbc66c4cbad5114f572b505e62cde8bf4e1c1dbde2abe9cdbc21758d5192f4d1ea4a711248ae0166b36cb8440a5e06a6610925ecdf0d9e4e4c87042484f44bebe8df07089a34c04314d2001f85ae7797af144f429962cb40225bd70b18d7ffbcd61413564ea658047e0661d344bfe4a99c804821813a8078e9f748c0014d02d8d86d47b6b6d9a8289c785a143a588c7c0f6bec102daf3aa5383b3bd9b9e1aebf65bda738a252ff73cf2e1e447a0d284493416f2df43f1962234d455fc681074a4bc9533a4826db78c8fba29fc0b7726db8e3ed4618836d013325f261b64a88702788c449a96658a861b6c9b18d7f4a1ab002187b72eef920a092bf30a1cc5916e85cbf3884929989a906b5b4682e4c7a50d655504569938534b07ce05320d0789d8ac00aa855f71165171d02fc07b5b707945ee70746312e4ac45fda77c9c69096854821b7af718c06ff517be3ea87aca6924adb3694e3dc840cbe431ea62db2620a2ab0f2e2a5ea11450ab0722e1ff52029aeec4728cfd5f526f2e5d42f5710b352a044589f5b3ce71a61f4d2a0bcd382a457d8a1f8b609ce8f3823eb15d33650d5a460d04ae0560f2649bc1d195c59e9ac501b6af90777f183022af72d790db2d8ab7f4a8ffdd4098624f5b1ff913c340a53938083d1fef3ec6b4ebcda1e95a4c121c6632b2426fb4ebda11eca306673ecf520e702d7160ad6d6ba8bd81391d944bf70dc126938f36ce6c0ec98a318afd93dd35fb6d4108260c2f4192814ca7f5aad3d07a20d6b873ef8a13529daf2478db5554f29029abb9573095ba9b6073101ddbbcd13ca9112da4ddd6a2a440abff8e371b7acaafae437eb8d01e21d2b5fb97ec5d021582ec0d61ec53862ca0ebf5fedae4bfb68bdc85320b0ab2c68de72f1c6e541d7373b5833fd51199ffc1b92c55344a166cde99427aee9d92a2c8c6c1746a4b748d51570caac01ed79d25138714e7f7ac85986c97db314adaffd47442e9e5be74a6c517731cfbfba21cc445480314ee7ca3f70c45bd3426f8ae14d6ca5a0ec745b7e7dbaf0e1358fb01f483ff5b66214b2308b100fe77b5b2749ce221bd7d57e2d2188fcf70fa515d86989e195c3e48c9d5ccf624c2fc1f10ec13b3c132c962e65a9a9cdd5b43d3f8c423b1b2effc419d6303a5d756fa6a6cd893dd6e9860e391daa0d2fe7c00a1addc695ad913dbfa33ad24421e50fdfc1881b26b9342a3b25a2fd414a6ea1d38e9cce30e7463e10b52291591f43bfde5ed13a9acbb31f751f45216abeeaa81cb0adcdefdec52b731e22255288e2250abf38c1f5a35e8f6299034aa92c916eddd9b17844e5f8ed4c427d44d34b94a53203f573738d2f9c20a3ec537f73deb1c62ae723aabcd5313a2dabbd65620f067277a946edc05da69e68eca55f39c35ddcae0fa4326501ffa618468c596d8d943e4bf28c16141d4a2f03fa43823d806c7a6818eb0f2793d3f04b9411d0bace1d262c81fe71d5ac9c93e710a6c51e5048c4b5d344979d370b806003c37aac68f617062aaa8d263e74f52dd1676ce92355ae7bddd834f0b4421d0d7849dfb5f6bed5a0300551ad0ba7a6ce24160be2c91255908b543615db6fe0e4059abbaf0a5faa066f76b9f09b9fd32fd69628d910638ec11d94b6a3b11d1653b83ab302a606852b30c098d0109af8ff20a90ee0c093bc7c03cd5c5f6bd50458f03d0d2f7aa7f0c2878367786c98036e3089f4c81aa4f5c35bf9e6abd47bd4a0862f8ac7c1f2218ad1b9f8c79364ebf642eee9589ab0cfe48c3fb077ce8a5171dca558a6b8153e275d7c61abb577877a9f83a7b652587551535405cd3e99aef7de584a7aa841b707f74bdc64696e0aa69868a76bc5e21519b410eae10b94537a1dbe829fc488f6e5ae5f357e4cdea3924eb4f5316bc987a6f8b56c1b79cb165e5cc71e47037c4d967387997bf4dcbcbd085697f0a5b82e105eb59a0fe26ae45e284e5e758a3a75b83e357583cd7d54ea97130cca4baf551ee804b50ab836b76579875a22874b81af6963acddb7999ac7bc8dcc3444ba26876a9b249da70301d063edaf2046fd5f5dde907e5c5e21ad5a659c1ca0fc26ad4dd8d5766b7c027dcba5c00b2d4e311a6443ac56fa79477887c65301cd733635f7d5443fed5d6739fc5a9e0fa4169f1764a867ee887033334b75ca85059b74f04f09ca3a2032113b8c702805438cfd1e8bafe4493fcfb5d88985d5445a5b0da29bb38f6ec46b3a33c177c54ea43e56ad251f2cccf027fff9cb6429175a527c9f3ceb2b8201ac207f8e34b8b1655dfd16d7e4f7aeea9432437d1544d328b1f9d689d7f84782ffa6affea9c39de6ca04e67bf1757bf9f60bafe2884ba2e4d29bafe63b8092ae4992ee54bbbf1882047c3e2e0ce2b1b5d23416b202a1e870a21d4fbf38920ee7d4f727d94006caeff602858d08ecfd175d1c401fb9f459bca19e9b1828d60b47961295f59971f3083d417da4ae7e7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
