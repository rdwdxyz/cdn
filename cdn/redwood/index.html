<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53ec9ddd4242d76cbd2895a735ca40a155a114ff67272db8dceb02e7b26ea3a073ec397bf78c4b5e1c75195a571d2babf2eb188f958f15f384598515bde08ce94bb517bbda43720fda79f4011bc4aa1ce29db575a7a91c910695c392965b2a284ba87ce8c3f90bd96a5001760ea322b9394bacb9f19fc5875917bfe1d33dcaca4ea58adb50d1d52746afd3df65780bc8dff0842df7652b97cadf3819583b46e315d6bfe3691cee6065592ff10b2623b6494f7e6da3e01490ee8ed1612f9c9fbab2d6b4b6b3b7455dcaf49568d097bb49d3b06c4ebaf71998d55e74509a7c50ee2a5975d375f29ecfdd7fe0d018de82b7f3d5fcab99ce6818d6f1d0934dc18ea263f619d6b6a8c79196a30223409ce02f8a73dcff729c12a971a446b4f047eaedf0e21a4773db5fd83be6d7d26d59de27072d723f421d143c1eab56b375511166cc6c2070d48b072fa98f1b4044088affe739c9133a89f53a76ce6000aef608f6433b96dfaf8d1674bd4007918fad3a3a3a6af9ffa1b928ec4047f0e6ef8410dd8ae0ce8cde4d30b489dcc76e893392c0de91b215cdaf6d478e62ebaa1e669abbce281304d11e01ed244b3619ecefd8aa71d830d9d74daa9b29d4a88171c1e443418b15b2c1e5e2489d2c516393dad669e27890d036cbdc84e875a15da0c3d2640a7e1faf7cc0d3fe58b11d7ff6e80f1223ac4b2ebbb1efa298fae938b9ecb8db3905ec6eef31e1d38314c4a2a48eab4c69c74f145b9d5998573813109716e06a85df4dc1b76bb143a8c4e6f5a1a343b876733c32daa1f811d46f6b9ba3ba64dd0e9583f16f733b9ba337d480a3c5a93d7299557c5f5a6bbbe71472dfd5de368207004add7fd17355ffaa653c69ed03315b7cba17a0690744892523d4764416e98ff7800c33168160bad4b716443bb03e9cd8d68b48f6fe3ca729911ab8e7d86a76b4efea4c92086841ad5a235b6c7cf32274a2a9ab77d9bc2d45ffad24cce88fd30de45fcf366e7b6dd1f557a9741fd73cc37091027c9ba6bd9938f2cbab4e4734205d6ba799f44b705913f7d10234f6507c12d9e24f4423e08cef39c2b6038cfb53c9e0c843ba68cc923462fa9829b8db7c7cb767c8d8ff4a988d0ac13d52f4d67d356bd06768c1bca04bcfab17d013b9da049711991d2d839992e2fb8e5af6c8fadf1b479cb4d2ba26ec5b4e7859ee87ff921e9ee4b7cd9f87a6d63b0cf4740615efb61a15981e8102cd0f987b08b70cc93f0db0d8300aa43860d3fb9cb91e793e43117c0bf834a86448d6f3e63eb16dff708c35b970c2a64fe93a7ffa6b242ad9919d96152e72afefb0554334e8e47d1417619af97d8f94baecbc592f6f606509747554fcf1c87167ed5a077e6cb0fc216d8dc7a3e9bc48cc5a574fea12d675a0ca25ba68cb7186461f868c51c3f5fffb5b9bd80517f78b606d89aab9711e6d7cfdb3bb042d00c2d9d173692ee58a3a5b6b35f8472e6ad41f980b7df3ac463e0bf6d277ba88b67863fef7e119213f91da95dc99913cb63c66b80acf7e1b7838bec563db162fc08201ff2f0cb58592c06ac47bf0548d81ea2875133c081d777f0b2282edf39a7d4d52c27354af56a06ed05c70e93c7df42994d65f599e265c41e4f9e2f384eaacb51c3fc0eaea2444d13979d7c7e7139d75441ae9cc992a9cf086cb4beaf03914f8f6c7f63519f3866c4cd9d50c3dd8fbc7c76255b46b5ab270531036a55dd0342ca40fd3023d65bcfd08e4774e4ed12a3f541f5eccc312442ee95a85dfe64fd282e8a5b0c4c98f585b7e205676bb8ae5d66a5a670c60acb12aab8a2209faa7f35a41afa2d78d0b6dc9913a11faceeb97123fe1f5c74a89ea5a08eff74ef124e026e629a658fc08e5543bd90b2e63c7859075d10f3a397052c214160a61963854007c1ab4fccaeddce8e03cf116a55e4ef446ac0139e5dc241807ef70cc6ce53a287e7c1d05f2df27776a66898a5aba8ccc3ecc09ac64364052cde08863c906b5d3d4f614a50f3d4f523db5cfa2ce7a507dafc483ac19871c57b213476ed28fbb80d8a31f396ea760b5feb9ab534d264d0488f28d22f6ebbc8d530c6188c85ff850c33f501554392944d9e4f3eb89e9b265577e65d50764ac11ce680747ce6e75f93656d9be3c529337d7c9554331de82965d2d4e105f09b13e4212df12923c2831f5cd5e25b125cc0a761f8e8692a3754f1a9f421ab18297bdb9f171333cd423ee2ed9650ba4b94dffd725170ce711851a0411ad166bd5aeb7659990aa0dd70f4811ede179d9a6d0fcc4821c5ecc838612684a0415958570cfbde50a4bf0acabc460bbb4bd52fb59de22fbac0e1d0b2827a099f3fda1ab34cfdedc6242240a9d0cd8edf6c7f71b8f0ef1d01070562076e092d80c6d7ecf931b1df2c51ffcbaa503f3d95f5bd27042bee056538905ceddd80e85645f2d46da9d3cf06a01fa469822979d8e25456cfb2c49214140c5cb12291c8946a4fed28c3513fadf37904734f89cf6bbd3ea3b80f7990a525669922efed4e787b4395e9daa74ddfed28cdbfc2a0ec7817b5d6e9e05b9abdb2254812891cb401432d700a6fafa66b043b6199baa2bfb210c68398a733645a4bf6de8a2c0eb3e4f6723374eb4c40135a2857f95b46f076a6a730a59bb24206dd41a249d5a0e2971d072c3c2236589a5546abfe0de0e436c8a223d462386687d20a0192aee1cbda14c9e28d864e4c515a259ddc2aa72998edabd4eaf3f2d511f6a99c2d3c00c3290ef95f9b551b290d3161c7aaf8b1b9416467bf5d751ac12272ae4611caba170f0f51a6715c356acac30c603f38f91c2bf0ed848569b27b38afb676972d928a288c688f14fe7a292000d7544f5d41d2a60ea162c53b9f043284344a9a39a33d2c950b1c874ce80d1eafefe2ac60f7d55c268ab68e5df77ce4d919a7c1e04fdf16e32800d48fc941f60d09e0fd75b8f718f9aaef2849375e3097cbe272279fdd168a20d56d2ff347914112c4dee4f5090d0734773078e5bfefb0167d733bd1ce790f14208a1f7e810a5cc0bb68fa02d3212955cf8194f9950a0239fbfbb7944b4130be73dbbc5bc4769b4427f7d763474e8db92d8a47dba3cb72b149beafbfd31c104e5bf7dded8835029a7ffa9bd059ab1b6ec4f68b16c3b051d615ee07b597aa3bf8f3c1ebaeef8d9b6de5dc83eb848b4009dc17213a9e979289db8f72b0c9d3ff9e91e852dd9442e30b34a457177103bec40fd0b3855b67e1527d4fd55f068bcece7a274ce918eff14774f24e94996bb01285bd3e900107550b6415c259133260385f25f9332c9f789d6d8a1eea26a1834eb98912850468ded6e4fe15df0f669b1352719ba774da75ded9c319ae1852c0e78e7ae28d5c613b72ec555e2843ac705a99137e2abc193e24a2069a2a1749ca30ff0919a39291417e86192cbc2e61fce7bec3b8d3ce3ba75c01f6336a254ad3849c734cdd87fdf4550131fb31a6611170b08e38c76c3f332dfaa49826630cbdb9c337fd74600c149e851ec33c7f0c3983b0263fca0aa6cd551167583c591271cb8354be1c817912c69179686db53d1e599e63ecb65f4b75203d0fd6b371410bc1faad91143e4f38ca4ecf0cd1d1a5977b563236c65e42fd9919f682b43d46cd67a1539428311df32de36e455b23e42680fab390a6ea3f85ba18cd3e9d00eb3e1951be70b6dc4edf82545b0a5f8970b210c6cb2ccfdce056e5348514730ddff8996f73b61894e3a9e33e04cb82d3db9606e6cd2c7e3fa1980aedc1a1b8bc92f23686aab69b29d76d6993d26179b0423dccfa25d4fd063eecdf0d6d133a47a272ffbb32ab8c12663f73d61de10093527086780416047996a0294ac8f2943eda89fa569574d0bad9755d591e60c384a4ab3aceae6cd65fe22d795b2f8f862943bef551bb70b8af7d4deb57cf5a3318e085705b1afa7d61d98ae24dc387fa5aa694a94a04e615d9a80f3cd8bbbaeabc82eb23b3b44d387323b84488d9b1d5c21f3ba6299dd530749b403e6eec764c15306730ab319d4952c2d4ef3dffbf4ccebfa672a60ae1388d52641815720e2b5533ae633a7b63ba34012ace58c431159be9969dff789c2f81ad66fe739dbf2767836144e02cfb4555636ddd9d3aed4b0f6768d43dacfe4220b92b6079302383498b3b4f358cada4e2f2e64faa95fb59fdaa64006626e76d679b20a12c29daf9283e3af840c96e489781a2294e5d0b63c49f652ded4abf575c1380c933e2a5cf6c2499eff39fc692270ba0d84b659e89427d328f2e428c95c8bc8abf231d206c419a69615a9156c6c6729e0ad3b05ccad841aca3567915bc5ca4b58de5aeca702551e4aa4fc55c12d2d2bc696f2d46d65f19b97d3bfb397417afe348ef3fca5824a4a39ac5d94e649ed729f316dc23b7826403fa6bd59e7561d194fbeb9c13b28f052015f60a76419051e309c59d2d2d34f99617d1ef0b61318f27ffe863d131d752cec7a346c500fa464f9a343229f5541d3ccb33c193280ff8c257a725a53f679f6fdb45b2f45a7366451e84e3093d8f5dee8ca3d467056d435a73404619c3695fe30ba3c6fd569826a3aa27650d0c0f92d6beb5bf12b982c9959f616d0e1914427550b83e615e792bce5296e597cd379e0b730a27bf891c639905d86af97d75cfcf2d098f2d6500649363bd0872c550c3569c16953c8736c859d516f4d339db1f66c5fa5d2eec49d4ac04f6d173d68c95eaa2d53aad0232a14b9425c3a200c17e89e1fa94513f8e626605035a8ac498530d1acca7b5fddaa6ea7843766cc9334bc9f5297bbbe8c01d15b97c6e9b16bf73ee3841a0b3fa630f54b8afb45afe6c9daf6651c28953befef5d9539569a7cee9606bc6d19a4ae88e7cb9fb310c12df12db646c13d6191a053a4d33e93cd94fbc0c4fa0be60094dbb447d1c74b762b898d908667fffe2ffbfd91fe60243077c7196840c48b1bfea4a13411aa80c4af0785536b45f0fe7bc86cde90e3cb53b07214bda6541077788043813197ae38bd0eb2a7275705bc9c2c93f4221056ed0a7a09bdebc59cafb93dd212036666463f1aeaacadea1f1792a95478fb3b1913259a34dbb275c0f307fbd2ec77a9cab4793ee4158af627d0727eabc3a90bc3c63d9ee5888456a8638eef7ab7072ac7aeb18410de904d2946502947d9e5ecdae23f7a8d9e82839a7d5edb59b0b377ae782301c22c59de7c98af262f4ee1df10b6934e17e73a1e6228802c659cd8deacf90ed60881ed5d752465b46cd1ef15493e829f5b7f3ef0d6a2ee5ceaf1f8e63adbda1fb686eb033c0d16af20163d77a3081f16a64f83d1e97fb014b07e4829ce4a2ea5b3a4b975dca859defbee96ce0614da970641f4e391680b48070a2ad1adc63d308ecb2f12661281666d2d436040c4d0e883eb1c0cde8467fbdf9feeb1360e6b23ac72a4c7b95b3899fe550400926c0a5b387d871706d12a6284800162cb8c111d133faf15f3d46c22da22fcd88cdadc593cd1d81c0b73396fe768dfbd891c6997f46c90362e9fe930bcdf7da391fd1d73cc11f0eefa50cb10057fee2f07355846914cf9f6a1de001de4f5f61f00893681c85b950f79bee3c74aa755597b9d116148104762c0658995dbc223460bf6bf72287d2f2b3da129848342883981cfe531adc7fbe33002c8f460e4f76595aa1af2c45ce4e89e4553e4bfa169b71f2eba66eac5d2509d9d96ba73df11bd8fea7918863b7520b7bc8f410a57230d703e5161b8aeed13f30b083147c77939cc73c00d7cad0c60d27f25c87142890bb7705fd9435e540d05c4e2e59ead0118d60b355e116b6684c87a436bd7ad91704b4d8120ee20ffe2ea8ecc8473cd85c783506b323390a005f2a6964ab982cd25d8121813eed595fad8ddc33020dc1fb6afd210cfba65114f22a8acd4af299523aa3b99f7e050a5f350f41b998af048efca9b4a666c00bec190753594927e9b14329996e4545ae4dcabefa3348263f0b7c115e11810d5feeae0c003b44004dcfb08adbed6b1afdb820ea6732dc90399469895127354d59296df38c7624c1fa02067d78b8fb5ee9ca1cb715d0f2a5697a733ed0f2a2bfd30d3bf9ec3a484ae85c64369a550fec04a8643254dfd7c07adfeb80084f8c34e6c0bdc977a95b88606986dfc60038ea54a220a8e4234892ff3aec58d3f189badf6f8852b8634afc9cfd5dbe2876f508b7e9a5995440bd31056a166e7304fd16c658012791aca052ab37b7da98f2ea4f3e1d337beebdc855661e8c2b250f1172877438e45d8b05e66ff355767c641a614201190a835fbe5f0b63096719092a9d2337587a7ac9384ad02d07042490dabd86386636657b540fab94261bf03daccaa3829776d37204e180683e1dd393dc5e335d5b1df1404d9c5300e532ed4137d080318726ec967ef60de544f4d1332e6874b88fe2b3afc958c1c94eb7d9f2cc600c9403d0c8fd89a15e4f6dac509a49dbbd27280bf56465b40bc62118c94b98c6947eceb68e46dc787196c430793fed3887aa2ad89ce29d207658fd68ada4451b4cb3372fb15f5cbd109fb5a5d75666db42425291b02e2f7faabedbeea89805f17c21a11f2487416ebaf746aab80228291d97d1b4f4bb169921c0fc10e0713d5e23ffb925721003999cd9eb96295585b12ca69fcbbedfaa4f2935cf17221d634d4c40ba7b7ce494fcab25395d79e071006cfe82ef893fa06c25252dc4b4f69880d9166a4cf8a52dfd1dbc1171563103325731dd43e04071feecfa2adb117170ba2ff38cac25a7cb2b1d18947dd5cc20db8109b687f8ca2af9eeef8ca5514195d89fc8b5f69f7bd043951408e8c9ea45b9340d78732de10e961dba051bd48da9a1fd547bc750813691db03bdbaa7d50f40da37ca60a126d71eda35c349f215263900e81814678f555ad405b3aae1c176cccc7b02c32189bf24d29e97a0fe2c0102e8eec6517985c69bd54e9f54f2605217a21bc423f935b67da2e5a174757f0974f56bfc27b66cea28bc21d239f36ccc07762117f741f6b45c7046a1452afd4e7b1e8693705414d4b53a676e5f1311683bc9ab6a2b03942749dbe280f4fecf980c10c64a7116df0a34a19b277f1786c11ecc3c63aad611fc4212b3f5b91c0a90ef3e1aeba0aa2dc956e3e049ca403c1d9f942df193d11558aa5e9781149cc5cc922a253f09f19c0851d50e5934f08555495221455dce7c01415fed5154b2b83eaa6c9e7c55bdf61be83fecad6edcbe5708603d3f5944ab31e371bb2f9e3c4740fae3b9a9c380d60b0498052e55e59e36e8abbcc98443ea18d3dcc8efb1a472b2d66a7a0715887e70efa5d1f84c3588d9d7b7a0a8fad8a686750b07c54b48867d70b41319de1d1de85855d1fe0a247df6623e1a8cc2ea5fcf4a8a214b372a4371c9192f507c01717c208f4c6d6962dc4329c4c11ce5a7ea756bdb31415a359d28fd4e657ca82d5aad08b899f6c5d2ecece422832b0fe64b75821c0ffad7b261983ff048a244d7606790c108b890687436aeac57cac335b4ef3d3ea32a0f9ad5f1a264696ed7646152ff14d4ee948ea252607d682569824b12e07fbff59db7869320876f0444775804fe9179993764faa88d75bd0e2ca7008fca62d0418d6021ac35f8a037853547a6eff7559ed8429b507fb204fa2b5998018ca2d2cb26ed04f9a6f101d8418c9fd99d4bc61db9e1d69b5cf4f2306c16b8b12ca7b3985ee57788d00effc207bad04ab54d0b1f00e7c9046f0bff85e3c8013dad65796190eea247a9039f7b016664de62d5e4dd7763cafa715e6d82639c1ceebb763db3d46c9de3a657244868addfcb40bebffd57298f876a722062471e4d673e3d8db5467cf769e85951ebc50b270e197e39cc4b406647fb38919d64ce3e886cdff020bb1e1fbae8982b1776934a203d1fcf22f2eac8b544186c43b16f73e78b482e8180e6a2d70d25f737ac3f66269346518351043f056ba8848190c8cfad5408cdb45cba1a9ec848a8484e4d7879aaec954645c4195787e85e1fba038607d146ca9847e48613a609a465f41cab95f32bde57f5dcf9e40a0bd25d6b70a18979b4050263cb33494e365970c2a2a05501a29ec57593cee9a50078088d2bcb5fce372ac1fdcd0c04717972fb60f0e576c9313f2642e64b7dc5993a463cc26450f3a1a891635681282fe321d54b8e399992c8ad39179f00936ea4541ce7914640af90539d20540a31be60e3779a4c149daecccb9ce2f432e5edb657870c76c149afbf49ea278fe3a4f48545636c72109f65d8c944c3596de72ff8c69f1c75f34d9ba636dd9335a76435d5160127798442b7638c0c657c362eaaf2edc0cb51241a563b2eef6a42cc010acb2e9f84c26c848020c05d98d4ce25c65b5c5afea46a5747c159c3e57603d40c019ff118effdcd0ad63bfe32194d7b5e177d257a0d4fa7ce0300ab30952724c73fbd4595c78391d47f259066b753f61d30ebfcbbbde7221be01271430cc96b3be6aae08d2a8f353d78f732f6c10deaf652dbd230e0f89f0d99d3ecfc8fe194758877ea4fe6a1ce2be06295db72e0bbfcb1eaeff43b1eb53ec0db21ce06155807f59311f6c0ed7bc98ca958d0d6b56eaf13441f757a65614d5723783c1cea80eb63d14c160be6ec837ebfa3dabf56e26a7362138ccc590aff2c80fd62ff46a63b8d33485fe46b57a4de3630fa740ecbbaaf0077a7c6a41dc2a2fb6e05d8956bcc7a736b7992b179cc696c3dac6a92d9b0ed24176c42a1894e7757873761355eb6b614ccce49ed1381b9e032cd439995750636bdcd4ce4cac116d3229b9ffb49660eafe9e9f3378601cdd6b818bb6ef45c35dd3713a65508763571da1a27fd0629e003bc8fecf0620d9c3942540f441fa51d5724c032765bbec9c543f64d40086bda41ab7f81014cac9f9528565bbe9f456b79eebfa0ff9ea33af476fa19d6ec3e7b0a6a0dfe84c3b71eed4cd7b3474efac09f945c328ecd7fbc772e46d80124ff4f1c2ed4b223b58264f06f4639a0eafb2114b858f92f031e3f5fe324fac3bcf8f29df4d23ab7f2d0fbeb28d2e53b4fbdc56c60e6f25613b7641760ee25e955a67cbaafdad575ad4f3cdfb4e0837825b3fb3e7820dc6e4f1e4c9293a325bd7d7cdc8ae12c9c072b8d11ca41b9b6f265b24bebef950e6dbc8a50f1a2722aa629552f8510a3e087d9e122b0bd853b3a551a17e6ab1e7646320de76f93a6714e713c90b5eb875da74b5080ef475e6528d043e59113ee77d1da7f677586b4788b8f6211d3417f37a80672f19f149c3212e47907d761236d8b8144338bec8715ed002b6ba040d7e9d712c8513dc5b05f0d9385a87ea5128e3c4100d9075758602289f738816658cc11a24f5f1504705ea8891ee8c8e9911b84e10fb43fbff85574f3f0d401550d28a1f1134b71e129b1df5cc31c3d4e9dd82269da83a42c1358914dbc33eb5a1595071a03afb8af06bd9708c5bd297b58b0b69477e56f6e18e37d465ad6a22189cb9bb0a49f0bac6afe16076f37dd999a584334b843e46b2e408eb4ff44fa8ecf05f1f2de9a5441b4bdf9914b8930e6947e9aa3d55b6a0b6474505cbb6bcc7004089eafee40a23cd4ee0b1953576bf66ed2f40f8897fd0a230c68db746c2cc34bb4304878368908b4e6c63aa3531037e87e5e98eed350c64b1e98818e1708304431f3c14dbb56cc694c78db3924db4e27d8bc79cd81908f21f383324787e06d574ead62e974cc82d916e9298c40428577b6a1815b010d594b42ddbf845846e9e123b090909e109dcfde89b8e91b111f4bb2716bbc20b1efa55720d603219079fba04edab0a1e4cd9462a4c430bb720bf64fe05932758fbdda00ee886c88cb71c2c3a68313b40dfb988bbbcff1231c5d68ec438bab7d476108ec1aa50db642f7dd1535234ab913b5621d9308684a3ac2cb0ff39ea5ca3ff504ab31be17090dfc2b5c7e7c0d58303eefedefef725ab2b97d9a91fae180558c544e6ed17d9bdea0ff28844cfd28775be44fc4c6ba84bc12b72566129546b7e566ffd3186efccc36bcf73df2fa61419c8b12a586c85165e03dcc0a8b83605392bb4750d08f0c5587fb0838a18714ad2e1cb7c3cea37dd9df6618ed280c5da665e92f7d053f656b172456575d18e915cc51461363443fca812febdfab4f0b346ce608a64b2730ada2eb3a506d8f1d952cb88ce42e14d21ae41b90baebfa17fc2c2e966e7dfab6ebb738e4353897e67cbbc05eca2efc1a78d073e485d013a7fb21d8cfa523e9da03c177605d97b200805705d473fee1b23cb8328d8adc6a81d803830064d84f28f5866d8b1258d0083f5af57eea7c20004125eb2d0ddc52934b6dba5ba71956916c9ad9a0b942a19af6988d12fafc382cc958fa3d8d0f60e901b075d591a3552983c933801a329ea14c2b00d658dbf40dfac192e12d29091569f715f83fbe4815af7c59a5300d7762c8b24dfdb24c130d17859cb17fca690b83437d452e35fc035c471aa226d56da19dd462240633dc2b9d4beed8416eb766f5d669ffb3fff29f5e257cb19e15501eec8eac885ebbcd4b33e79fe2807fdc9c3041dd76acd31a4dd885a45b1f06937e25f85feceaeb1b0afc21c26d4f8443b8a8e1ee687f61f306a88541f6fb8044f1c1cf18e57920e47dbc8fd02ec38a3101d8818fc33bc8658462b7e2d76d6dbf2da696643661b24533f85eb28880872bb56561c6bb6816a4bfb8bdced9eef7510cf343eecb734bba18c8445e04c855de9872dd55d7000c88c36a91a69938a01c872337680658651f50320d3523374f1c79bbfa3ff15dd02b7bedb8aecc74af49b29d660d64421ddc5e4c0e513f85ae32d976064cf65d34393cbbf1915e6850fa700770265fc82dc5f4bf896462c6c4aae4f8441ea92d173fc83bf79c8facea5cae76989ad8381bccd9f8c06013f9f2e3854775ed12a97f176624da9983f302ce8d91518dbeb3458100d5d9654584c7a0e5f3fd164b0dde0d4140f408d23bfa755df5effcb811da69319328f2088de6420134bc8b4ce14ce1f40b3d84bb567f975b61bad85f1fac1a5436fea2f8cc2ca1bc4b83881bc73917b2b7d2130c1e8aaed6c590c7c7179cac4944028e79769be9e8904a22747a47733468427490a5a106a3c75561da5461cd4638300aea4e52f0f39c36e43725ad1233d9ffe858d6e96aa5ad46f75c76a7f133454ab2f24a6baa1dbc8312fefe28c26a349cea59f14fd185f2e7c65c3d6004b67c4ec7b0e865266e558b9cbecc0d43a1fa77766a1fb38285a59225ed46dbf536836b608ae7556c3f34efc9641cdaf20fccd6632cd8704069b0604f619d3454dc3e45c0329f8492999f679323486ead3030d078ff07888f1673cd648b84dca500d1c7d7586960e40b57fd7bec43381cf8e9871e00adbe3198d0b8b83b63149b57ae1e198f60ccc9469158099e963637769eddc06c5ea42430a262efcefbf17dfd3c86eb72e09cc89499f6ad2c98b5358c6f02d3a564f7778589ba5592d51e1065c6863db19c3dbb431a962f27363cc44fbc097b55493360ffd9b59b094b75bd5ddf6d186d2fe9d4b0a79b25c4437cd20350d78bc00241159aba9ab7173dbd483ac3291d691753003262809db1bc0c9dc063ebd971a16975a2f56ffbb25686e4a325661eedfe610670e9bf02edcd9edd726a4f54b1a8e9fe1d1274e8d842b4754d800dd04bd7eeab0d4424a6185b2fdf32b47744147510adbfca69c869732a6654789dc1b7e4dadde051bc61623db676711a7710c415d13ecf16253056c0d631de5bd018f142adab0ff99a1b067831d0b1048ac535e2804784685ff0c1121b7a15ff1d1ec565b702492200607313dbed02f4163e5993ebeccc8c9217b4a4ba5e15741a2bb6d852ee63a62099eac11ae6e99e830996ebc01637405e7597d30c7b70caecb56546ecec7f52a44abf6fa58f6d4dd56b54ebcc50b1ab81c400b97b800ce68468d3011dc346d61a82ec772b1eb200b8e75efaee6d141c86bb439cb881a134a46382a189a6a10e0508850dc15a058ec152f339cb8106dcd4efc5c25eaa1241a1f54945ab6d1798449b47f317fbb01d0d9fe462976317680779cf3f25a95dd24deaf0c79f10c018660054cb2ff4a826892db96ecde221a3686516823d1e85f3b1f743b5b64c36ebc45296257e9c7be3d0aa4383a4eecb02d0161588a576f5d8ba88abb9de045b56c9fa0138208ab859723ce8f97e8b49b9ac2e7288aa57d219af04d7636dc7a6630bebadbbf7e36b078ddeab46d5e288968ab255802bd628b3997fbce7356f8d67f517f558087b44c83f0b85279150dc4ac395ff4ebfd2aa639d77052880bc84051799572d4245a7bad489fb31f3b9c8b1f0c9d2a4e72e3882e53afa5c8a439cd7bec7ac09bd8cd18bf2e53eb271b9facb18a494bd219b0f41ca22e31967cc0d323ffb62122df3049d7a4e4051073a08f85199a27cc66b59089f2257197ffd5d0410e5925a688ae1e0607451143442a504d96f1abdfb8bfc1dea1bbc955b99f1730189709f66e1e94da282aae78c9a43021084107607dbd50855dbd203d391e568bbe09bb1c17a8898c4544758b01186c6e901f5ba6263eb6e3cb9abe6516a56b2278f8e6386b9c4d44240479608fc7383a04dc5a88580053490f26cbb58c76e85ef038df36aed0a26ef95d550c5a9ad2a1b443a7df4c8a849a722a652781a49602adc2ecb583ec1432b86b721972d42f5521c5ea56e40198af71b5df1a5d398e10b925a1c209716a258a87ccf0157271f5dd69b0fd8ffd003b30606636d4b921826a2a476c7c6673b3c897ed3677fbb953d6a965bb8fb672bc83b29a5aadaf66de738ba0e0d0d50363d37e4be5ff791dca9934a957816f1ba5a637d1e11d5dbbeaa92464105bea7118e02ecc6432a51c7443d991eb2ae0cb12fe713e3adccfae01621c0414ee8e4a6b8bb6855df2e90d8dea0a47aefa859765697295ec52de64c5a11710004eed604e9ff1fb5b256d4b44cc4e8a84aac8e531bc089bdddc81b5e99943d30a50c40d6bca2e7b51295e149ed44440bda560b1c6f4fd1e00ef8a6a8a2e66bdd1dca5aaa38bc0569b8935f003b38bd99165ec1d85496cd111abf33ee022576b305b648049b66f0bf5efd98706bbbfe17e7fbd65e2db0f9923c9c28b5b3276afaadaf063cfaab6b0809f793b4fc6fd2ad8dbde2eb0eba7511b9162e18c292783bd8bdc0cb455e46c6fd50377000eed1c2281d37f60c49201ca27d24a4b8533cc06e0e461057ceebc2914d879bb64baacf3b0675a8b4c601d611bfb69fe1f32bc10c22af98c3e0f91c22b1448a659c29645e88dc922384d75104c00a9a1f305c37991a04082d1be1eb47e4a21138cff8bac42efe9e243ab2437f5b855211adcdb6a7faf37b515c040b03712e712f917aff6ebd4657f7e1427255fd59aa205b4c95d220e1aeb453970aa5a71852b16b7096a98d7aea3e3ac9389036450eb734aaf8aa896a31ddec35c7e2c800960dafe137e5fae7a0f10281256a008b66247c07b345488d50538348fb144cdce9d3e6498ea498f0aa77b9bb9de2a96a26bd26f6454269c2346d3991fa8b4837e359856cee46fa55909d3a6337f399252f7cccc323bc583c989678ec784016d361dbe1fadfd22e24ba865f30e557edd2b78b0d4d008c38275a97556704dab83e55d84599eda161e3c30c8069fd1761507f6faaa29e41c7863b25f845f2b492c7f0c28bbaefec851e601eed052216d3b293b79379b80b43fafd17d580d86ead8ce37fb7bba8da0fef9794b001243e54cec43a90eee38e5e14d94aa08173293dfe09fabe6634adea646e9bc93c20ce29421fccb0eee62f5000a1ed4db3c0115367f0a291731491224f4557f039bd248ce7abfeedfd233bc8c54976b0f9f5c6b68125fa791bb14b48ff68d3619f429bf48780985b39f6577991835447104aa19409ba24496d7134a332918eeceb4aa716ca57ff287d0ce15515b9d32caaab91bfb2be32e7efd0eb8a3b1c67a840f4e7324a930d05351bf96b5e36d7e36835aaf110da3d699278a60e1bfa74403ddb8bf96cfd6be41b27b4933b6c716b46380de2fe7106a01d4eb4402530029166af52f19ebfaa589c6840b6764f2ba74d31c77b808818c0ab5307d5fcd41cb7dbb24d50437156452b7b2fdead817d53b98dfa0fba6ec9f756a0ed09ba59d37cbf036fb941248cbe15ea6244c0c54dbcaa6dc67832eb2b26c070142c3165a64ca7aabec44d2aa1076d5181b62f24f1627d025b393b81a7cefee4625318917c891ae5028aca7630f886119c6ca350cd84050835890cb8979dce129f22b699d61c2b494398419bd5064b825a365a98e8ac6728833849dadcb1077239937038f58f701812dd275f8083d01f4e273cb13a88027dc5a06c5381a20a2a43ba82373c362b79e949182a07d46862c1adad9de4c0876836e86afaa1b9d84a7201a5af8e1fd7a17785c85d94f874e9778279b99117171f89b1623974090b8077ef1211cd1eab57119b9c792094eb048fd92af6e372886bd7b7991197ffa65a00cf8bf53bfad23909135c0fe2d47833ad0c2210ea73480203df6dbe729356c20f0502d58cb52acf43fed085143bed701f9e2a214686db4d3de95e80225c318dde4e62bc25dd736d00449f15369b990bdddd3e9b1bd2946dbf78628328bb03644bc3402f6b38384b552a9b600831f38d3320f90ace23b3ddef0fac10e38af5f574d9b7112c904dfba50ecd9e3adbd7fb9faf5922a1d24ee179a29d6bc2ec897b73e5b4f6b60131cb2908514df322157fe9c89cebff7495fe63c81064f10f02e1000f080fdd9344b0558e351b0a3d7242d5a8a345c05b287d03b9f05d5c4cfa733eeb9bc0fd7da8c0a784698657ff3cb09b47058af056bac0700c36a6a423f2febd1372d5e0b489115b0aadd87a9e4672ceefb8aaa97179f4d9201bb03dbc6cf28705b3337c90bbbe67226c4abe4fac3a27572bcf5f394964d486a04cd64191561d440f13842a41054702a4d28e14a44194a9071fd5baab05cd3626bf89c6c98c444b8f7e175dbc3bb867ea3ebc2c94df3f981e706eb1255d464714fc15785efeebfb1f04749ea7c02d9fcdf0890656c821aa46f9ba6f0b30c3a4780eea5cfdcf4b0e5af823092eb4856a2042bc3502cde19cb530ce15974afa27da53b5e3008aa718110790b1b03dc9216ef9f8b744ae3c1ce0371191a8573d6511cc67b70c6641748ef986f8260abd9936d806ece54ce015a5c2a136742d654b758bdc04302c133e96b1e83ef1843adc0faecfba41599fa02a553591f53eef11002820274a458399e09778b69ef2330115189635113e93ff1e1cbb3bd761fdc6494083d1b9136ff2c3821962e66b7611e223bc41b4d14bb78c1735125f47b22725403abc89353a71c1b72b5ba5b7ed7f3b349f6eee950a78293dce9f1d159a77a52c1f6a396d647931c0062d9da58ab9e6eeb6d4bdf545274badbe97a2997bdecff586698259cd77991d9074a7f9e2c5a43e85b50e69f441a4f759481c102ee88476899b0c6f672017fbdfd0001ef13817bfb4e8bd04e1fc9ae752d0876c9d68311a5d13927226df78f8c62587f09e22af1e771758f72d144f86e624b3725a67e9208da963c47631988f06b9c79647893057d8224556ca6e16eb308f5bd20a13276f7ad8b2a13b508ad7169e0d286a30e5c048f4a2c9a5dacb01e7155a3b3561ecb12d555adaff4ede76712bda405e1aa0a90eb740bdf602fdbf544d9cfea9ead38d5969925de43949561afbf4ddfbd8221237e529129ed675539772e6927fe21c43f2075218ab54c2c945ddf9fd81bd056bf3d92db1da647d01e298a669a0a5eea36fe04aa71027a66340caff6afe9c1d239dad1c8c24bb45eaa25dc728dac06fb31599f9716ff2b2f43dcaa862cd216f537b9549159dfbf9a3bff2182866e1f0c9e198a152bb15c2df3c5335276f2f0d16ffd5c187232be0113fb5f3d0f48af7c6d7c13d640c7297d14e76cdef7ce629bd0a912ccf79258a0b2b88a7a64e49a7842c42f1df5cf7d45ea903596d7be67873f823eee76289f5a75614b6058b06a24216eb6a89f81f1666b1f0a8295c3240cff8a50b8891c04879f0e0e77b51d808448b7ad157966e177cacbd8758befc6f5ba7c74dd47fa3278317d5e851e7ed02f8d200c853b2db3b6633fc3c4b205faf13b18337ba23eeb817f72854a3ff5baf2aff91bd371af0b550fd7c37d861c2c5395bb856ba47edafef7e501f9084b2a08fd980429c55862d14f9b6602b24e739d1659da60a13680e17491d2327c4f804d7ffc2d9d08492c231c7a48764ba24a8ed8d486e228b9387e335e096fa9a199add40260272844f19dbc64d4aa73dd7e063f835ac7c24e9212f2488b70edf56b2292abcff47f70ebb2b0eb4f4741adf2a05b19a62f925ecc2efc3a56da746e1f45044e65b23b88d23046f13fd940b5d7f9143bf0799d16bab1b7f80836302bcb430c8aae4ab99d63af084fbc641001bf6ec0092b55a3678153df79e7706d710385501c90a875e77c22299fbf226c6b3a70316df50a0090786e4ae6bd8df0930da7e4214eb6a3019b019558c0da8e6a6f873724de66046e7ac07f2f3e53063de9cabbafa6ac5c442dae2c7d56dc7b8f3a88a93bf7f049da9e011d93ed50b6d93c54205ef57dd723e44f6f0ab38ca19a943e4d9514c084fee38560ad8b08eb4b9ec8e9a4c64eeb581f7c40e61e5828ed0a8cea06038534236df935d31b416f961b9bddc0da2ebdfd8c3699cf6163e38b89d0df97b7e4a741dbff83f46c866809e1a4c241524ed9c99833122d6421ef15909c965ecf593f370eac03cd6cbda20cdc65830dafbed104bb671f8964e7136aa9b5156a344ce2074f767433c23ba0211b113471cfaf4093b878e697e492ff5725e930d0e30896ad1a3a372ee24eda2ccf36b1fa385bf789889f1a72312138d3aeef58a11cd5597e7f702c740b01d69e7842442f5879171660784d098fce3206b1dced3b29e35616e4b4550f539e3054fdb7d69f5aab38833dd439d88c2c6dc6bb42dcc5fd54bba4bc85b543fdf62df58eca81a979fad7a0a5d555ea9315520e945d7639a391bed44dda7b594c1321125fa268acee3a9399f59d65a1175ca8ae872b38302e112f22c554a3ec252d6263610661d730edabe86d2a91a425700908874f43651beadf3a17663aaf1bd73826e30e3f9842f33c55f9bbdf0974ed292d9c70b1f4899fbbc8f602351954353875d6ba09c6c3f50bda60400ef873fb8a0c18576528afad30dfa01cda37dc6305cc2e33d273717bc5bbdde36017adcded775cf8b81f257130fb034320d2d5be953fee8703327a0370f4570ba038fe45828ce9d3dc503f8e7935c574ada7ec3e376223aa48ab07093a8cbe1ae8bcdfede723288414c761a5655908d117ef985499dff234688759bf10f3039c17c5f62fb6c7786a1391a8b0464de0f0a9ae517abceb69052dfbbcae29e669dadd16da5493f7a23d4395f9a19f3f1309de6edc87969550f99a2d4ac5b2640411d986728efba64e3f54e6702ad91cf85caddd41eefba0d3dc21b0f0c93f1d4f4ffdd7d3b187db743f0065b05cd09f68e99d61c6915c9787f4ab9320795ecc8be99211a4249cda748ce573c8d74f3dacd984cd13c987caae1c8b662c5b8602778a66236c4eee910cfbea1fb25c4e1078b26517e616078de95565609d5f57ea7f5e47af6291efe1f5ef5f2e977c1f9e0b39b6935e4d119cf1a03ad0883e6b78a8836ce3557763d9092d23072d748f27657177f1f54887bb023f97303c67cc36b47859361a19d59acc5a1ebaf60326e2b5ad50e86597d5fa97f56d697ae9aea0aa8952bfa26148c8df5d6e877ba15139b1bf54e2dd668c07f3bc90145537b56ccae195ba293371514811f7db9d153fe95030cd50ed1c15d1faca057229cd858d27805aa67f3c71c126313f13056af5d7e5755a0c8be1eb157954e5542e2e57623043744cc7a56d3fcc8243dba8ffde4e9ed2c8ab83f3143e5de8126c6e55eb31cdb2b83e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
