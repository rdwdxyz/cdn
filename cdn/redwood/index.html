<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01e21da15d4e006d7dd862c99854685c4d92257ed125ebcb61172bcba8422e105679288d6e85602bb8351d4dd1feaf4ed637f810d7c6b903df07d791c248dd5f3886373ee02880643bb9c2cb8ae2418d747c859a9865efc1910c1451c37170d9698c37ab5c3c8db6d3dd221d3733e307437fb30920e65879ba07a2d4ae9e9dace8b5c3d03cd83537902c24ffa5ed441be89552237ac7e1fa23f8bf64c9712a0011051f359467d477fd45cf49b0d21781537c1700969ad5f111e886a99af0a23790431c1bf2f5565485e6072f910d7dbf8404d831296a79130e29f6b83fe16dcb1ffe343ec593f8752f79d48127d812f0c1f9923c8b079432fa1d6f963ea243bfc0e044df55b16c69dc7dc4d5b271c55aa8d9a51784392bfa5f439ac02674e9df80984d932be20dcb56f82f73d446adf0b8664ce1069293153668f09f0a2bbfa48529b81d96c343642af3d8178e874847cff4b2fb74594cb1268d99c2652e09d9f33b18aa8b91ba4f66fc2018f6e077ed8c0a2eb5a891f22848fd772049ef714fa640b262ee65a270142be9634a7c1662dbf3fc00a62eaa7777aaf924bf32bb9f100e71c87d207daa4d97490ce9d0d7d4e31a170d996e08f022338ac78611ac6051c34ff0d4bb1015d8726b483f0eaff75ca12c4b944cc2a555af48ba5f390ba922bb566cc629f1e1181c5106af17cfeb9507f7f5d9ec7eabac3ff7840ae1b655facdf81ce557707efc6bc00c2d8b7297f81f9933ac69a0e15a6b33d51c981caee75dde0e3d52e8c05fab5f645c24e9643405df08a02fde87e4d6b58e9bf428f354dd7f46393b01668304df9e32a1ec05fdcb791616f9ac708c92371663c946f037ae09fee007f7ce032bdef8ba0799aadf42aa75c997650a8ccaaf02e10e81054dcf2c25927a9ac51a41634c2ea2bd5c8979ecd1d442aeabba329ecaef936f889af26b7b6b7ee807970fdae74eb256e2d2ad097adbe85d57b065d47701ff3e930d46e6d92443028cbadb34456068e05c311d9dd5a01c856436daee26f5ce8a2421986bbb223d44c9cea828a815bf358e593131e59199cd2a00a6122c348dfe145b25231f1f4409fa35d928460cd655006c4a85538146d48d5c460fd19c5f92947177ced1422ac456dd91907cac1a7e38e767a7098ae2f7989f18eb21b3e647ca3c69a807e66b38a7469d75e48b0b8a10e752835fa9de02a6ec40ceeaaf4b325699bd317a2be62898fd4ea9fbc8e52ac1251ea55391a1777d979a68a3990de5e23946422004ce67dea1c8eea3112842ca0d08feb958545f5551f3e8caed897b5833fe04c52583d9eb9efd5cda64fc4ec26d49bbcd79eca40852dfc93ea608c0ed27f98b30efb90247aaae3741a7c673aaf22e1775c16b3206e745ceef303d23f37a2ff14829e6295f731f25181a905bc920db4abe8cbe72ea28921d7353cc3e453a7a0fbdbc4d528eff91ecd761cdfc4d17fcd46d7ab3baa33dd4e4b0e426044ef4c9b387c06b478ec164107616191645465102fd8d6729ad0ec557761f39a64f51ddbd135c16812f6ca6ae75f5dcab4ff94cc53bef18f19dc404b2a5fc6f012e7f891d04390cd3517c5886aeb8fba8b2a53a52ebe72ab85a832e5ef648a2f026bbeef61dd703f843224e88905694a44b29918ac7f51ef86500abbad2a58be563f4ab99414679aa08d2e3aaed360eb677390b98c525001cc1559732a6658b494dec543f55cc1bc96b3cdf980c6f65fc5f0df6adefaa2d38a6583c55704dd4e623abd0438017f481cf0be5008302e4cf4c7a9cc0a766b5d22f7f44f496b7abfd252aea95d6b05bbf21c20578dc2c7b3b04a221ea71d85094e4593cf748860f2e8c47f608cae681e5b0e1b240c2dfa8085746d2124611593ff877b1c668a9bab5dd6f5d52fc2f6d3ca114865652084c87d6990d615ea06c632d3ba9bc608277f14dde0f08b1727913c69531b24e25ed833268d785b4a63b14f50dc7d6a5171f31dbe801aaf4082650651f9a8ebadb8f42f83445fb90a2636b46cfcf42fc622c99d25c40e5210c4f29f7f6150ffd4f337dd4ba5cce7f5eaf78f0a4327600f2297d4c72f73836d3038a0d0344dda5cc3f79c1f908f2e1f39063813c39fefab4191e5dd57e09bc9dd74965f9567e48db0a73c531b61f4e536233861759edc7ce3bb98d2fc0e9270e9a5901dd663943cee32749b51cfe66e21452b8d8241bbba9fd907c77221203de14e3f928efe914f17cea630e40b5d2014f59cb86277e1d938e9419403577278aeb4e468656a44767a48c72f9e09b47d594c83c1d5484075816cf32f974f4a9eca5486e57a294d2b01946df43774ecc9a4e367ce81ac9367da3ff988e7f6c0939c3cb711a187d2ec90a518619f532e5edfff6549ef70a8c7c2fde234004f8eb06b9bdd94d7c44f721d3f4e26713f501b44b304ba8806881bb9f2daea64a3261fb6cf009a7bf98249d677d9ba2ca42e1f872c445d056b6df5b1bf1de1a9e6b96aceccb3681b5a3ccb45cd1796dbc91f943fdbd9a129af25fb83f38016faec4f34f2096547090cde31fc4d42d8c1cc687ade9397c00405b5d825a8fc7fc46b72ec14645a3960eca160dceb8cbfe4eeeb136e9d842bcba749c8b2b73c04ba0e49c80735dfb8fdba0d463ddff18589180985a72cb835f9164459bc4d03b1c963509dc48f86e46a4078da0b8f9e0ca458c90c1d750c795104589cb13464907ab3fe4dae6e8caebdd8c025300d7f37263cd7bc6d008c4b0138e80158ab25aff2284dbe9a03be67ae3af4345977a6ecf2346d1120661b2d92395dbc7ee2433c0a3432986300a449b963ae6b180ef92089a2dbcfe2866587bc123c2ae0ac23f28a0d7c4237e01c4ed0c08abc1bd17d4749cd7468b79cdbb613dcd53eab3a4ffe0f1059b8cfb6b595ce9734571f0b8f03586ce58231239a230bf319517289f7c38ce6d00cf0ad011e16f298a42925f433fb552886b8366763f6a894c6003eca57da973532bc1427a85c25d23fc719a2c3880ee112b4b92005a54b8eb7f36cd0753a1b3fdccb377df7a75bd1b15507f0cd689362d4176ecb8303c0dd0e3cc9c166f3ccd553559f55f4bb8d94a990acc193d0432cc28cd2bd25bf70330206f4ce1626dbdf10839d45e73ea3b18e7f890525c75251dd9296c863b603b335af37f15929109a61709294bd6f1469fb632a1b5a211b442093dcbabf2a10349a17d1f21e4c776c4db021f62548f9be9042ea5fdfcd144e2e0c3e414e9cee175295a73868f86fff7480ac26bddee08f45579790e7b5416fc34068a032c8db193b1ffee3a2b64a5441e08081c0039cd2bf9322a01ea226710d8ecba6f79818fca5bb7d7545be27f44d10c495ab396d9c7adc02d95ee4c943f4a6e1dc16a24052040224e8958e9d635509fdfacf57e4a474400edd9b04a8aa05ad897697ddb4168f7c01b6b09f430318c5b0b0c96062c6e37fea9bd6b3f572103ad571cab469230cb4a58d540694f0aa934dba147556517af0f820ba1b9be282e4a7bb013a817dcb1f606cd447b24e9bdca8fb411d3e72123a997985a1018da26bfae715349ed55fbab2cf3466c4a33575becaeb4262687f2a736516cb70f533ff06cdfcb73e76e7f75ea897666ea1fc88768a4891cf0d4fa324a76cf30df55e895c93c38e87af351b73033ae3d9844f792be6eacc923e26e9d45005d1795fc788e95be7af4912dd5b8571a4dbd2639b33c760e76a813bc33dd44e1c563a894dc245205c1c42d67a454b0380a8644b03238d733c7cfc2e9ac30f59afc91860e48a897713a0630d5d86135b196ce485180c81524306559ab0824b3bd1cdcdc541a9204472d97e64185258c269081f0424016197e58fe6d49ead6ee6fbd7082180acbcc36330dd50b81222e61b5f961d2b96bff8bf4f792e46e76e4bdec528414226d1f64cb4c36f2faf469c0dbf65ff47f7218f911f9eb36aad06ec4aa41c5af8b4f0432fa112bd54f47a663ccb3cfb14b6747d2effa0286c0686202ffe59137a348fbef7ea375f5ca9aa5fa32fa59f1fb8d0c982d2749b15fe4d0a56ced98ca5118ba5c5ea4f63f17bffcdbd33f197634bdd9ebbf6f2777b311cfe3f3279831ba75935a8863731832d9b42e894497af012b21bf5ab47780e9633a0921937b8e53324c811636532e9d5de55edd479b92cc9e209fb738d2e84bbf2b8651e1134244936aff1ac3061b77e96731799e2c3f9ce4068203220afdacb0b9bc16266187c8684439ca3eb3b31ff04f7b33a7370647e612cbdfeb64239338dbee8628ce9f1c4194cc991f04c226c52e3a50363c8cc462553645261647ebbd7872dfce2f7d605d9e479d35ac8cd0de9b8b604d3309b5262737bedf26224d750e07466b0e584359f57a5f8b6f9c45abbf7109774788bd63d5a4b5140aa564d4ef5aae2456528f6f3b726568dac564e14c2ffc7f5156c1d68ccea37560020b0f0c7aaf9e4e7b8d2e8dadc28a065f64f7a5ba75582445687aa356f592cab13caece5138e8f9b39e36170e56f804428905abd2570889915af075f65ac9353c6b782d24420d020c962a4190d3ac138c4859d0b75b4e69baec8448241f4d8a3d7860e9db7f9276918b29e4bbad541d6159dc8fa1c62f34a353a88db30ed4ae51f890de76e18dcb26d9456a0e26005c6222fbcfaa0a42517eb40793502a0a62b72b56faf6ec5b4eff3d81d62771cb1f497a2e2ccd553b9e7d34eeb4807fa05909fce72a037e03c80892b80f1adb49c4195545ce2961863e0f60926d4ab959596ece6beca286b9cad1c10bde2f2c41629ec92d9f411d79793f4abcfe7783703f3385147c7bd44ab337cbd3812d9b9f8bbb0d8f7584b8850c7445b07c2449495d4883911ce741cd815165db51173091499f444142ffe2a189df51dc997a607bd057a5d786dc324f26baf68427f2476b48a7d46dddee707468f7d56dc22294a92a88806f913e5b972be5fff4e151c4f6558eb7ded856c9d0a4feceabc2411e22ac4fcb5cb5278204e9b612072e57c8b02c3a2fa376d1b0aaa1eaf932ad9faa700421ed64df6f75d3a815458676c2f6d90dc6898a0e900ce8f23407bb0e2d316d3f0feab00a2a0f8b4fdb56c3bfbbf394d0ba3c81601b2b9b3d2d73bef7655394c19cb079e596b40c3f1d55b45be8178be381b5239c5d0ba47f92be5dbd26da004de5060518413c2afbb3055539c1e6eb2e931f5c94fa0482bb64cdbce6f1d715c0451ab1549b1deaa950c37a73d5da54504a2a52e4cf96aeb552eb836234436d68b32f64bbf4b24e83988382e8d871b2ddcaf5279a66ae6e68676b1cec9437b2d2a844b95de8d5312383ea6f85f566be1d483936ffc23072b6e0d2d927435d8a057ae9def5135eabb29afc9f4e2d4ed5559c4c072be8db8dbf72122914e0d6ba83bbca8e2cdbcd697e888b8d15fc7f2f849d35080a83c78ebee0578fd0070bcda7c0e7bd7779cf498858776515a9f0633b8621dce7300b44dd90b9fb7adc5a1e104f71be0d84efda7029cc0d604c6db5cba14d2861785a3593c0167fafdf50705db19a6df4546e5ee95f027205d994ae659d60ce1f05a7c5bfc6fb02fbbe4f8460018dac5d7997be1511305b68747693f83d55937e258ebad942f057935cdf6db853e179353979bed894a8e22e00aaf2acb6becb1ce3ef59921f9d83ba1fd4df30ba1fcdeab58e858963a4cf8468c40e8a825761a29ec6f8e1e1924fdabae4b6dcb0b9d23d7168289e17bfd8a35c0db1fc31659eed035c02895d8edb0a9c863ae82c255c1eee6da25cc5922d18147be385b51dd806aab86250f2900f191d48d5bf7efd30d8b196cf1411e091c3ecfca7cf7926337edcef02138417706bbbcdea7f0f21482329b2586e47a31b46eba3e3435ae52d83fc70d5452d1aec68e1cef356315851b8059a17a8266a63e742d45edd20f593596c894c88dceabdd89bba127f5b1c78b005f6c6365d3f39f9d80e8cee0842172a62db74ebcc3016fffaba3d83ff2bf8adfd812b330e59741e1385bf264457de8860e1d56807841a4571b2e0d818e17fd773e768e959ec0cb25b971f9b52970c9a6e0ac430b1d12c9750a04e6c3c0dcfce6e559b160d97fde519522321328113e77385612bee96926cb842dbd07130f1db47d71b8c78e3eca930dbd71e50521b57471751357e28ec84407c0aaebea4b4548626cff152f7bcaeed54e7e4d010cc1e10fd753515d8d5141fbac4778b824be8c3e138ccc5871949c18a38918a4aa261207cdd71dc6dd0f29f2ef9cc63039efc423b84be564ffbe0983be4f1afd666ec2390e8999751309e8c4c6646304453fb76625eec5b694718f5ee7e013980366808c39d482a293c2ca63039fdba8a1f254028d795c06e165046286e43132e767f2c0c1855e95b0ac71c28592fc5bd12099cd61390d37f75d4d4a3d25d1993db521db6dbbebc1f9ba40fc9af084f6e001e4d19b8eaf734efb367056930fe1e32306425bdc753aa6d24ffc9efe099469243972fbb7e0ce9987b314a80cb4c3af67c68a702e349c11e9ed19a5367244857a7c4a29b5f1c0dd3afaa30de05dd4e8375d9b5f59038f40d1b2388f2d8b4afd60045b02519dacf97f555a39ce02b8780e82ed6cb66626cf499c03ec8d48e2843eaf9479c01fbdb76ecd341e9d78d0ca3627610dba1fb9a695c5b34d6bd7581193dd4b59fb021a13b0f9eee73b87f072a9c040cfb7367c9ec4dc1f18f4ad1a9335abbef39e300c738ab7e4328cb3dd5f6356daca3178e02138efbadd19b446414dfb1fd11caf647b14abd39c03571f17620c3248315b80b582a6d868b36c51a976fc21c6a39d5d9d61ea2c2b11c2afbf92dd992ce98fd0b31a7d7acf8515f185f921b2eab14730d74fd28c605632b8edd59b7498ddea2c8022026551be6deef22be958ff2e5ee19767ef7fb03bef9b17b44432997bb32a3d9b3bc5a8245a8d325a232cca9fb0a25fd4ed9dfd12bccd6c299c7f01fb52100b92763d51885a9ca7f254180abd559a0a617c043d36be81cde85dcc582c6291e39cbacff0a2e0f76ba8cda7041e43148b66d5df47a67d9730eb056c93a35b801c79faad87e0329017bb14ecfb4e8a90c3ffc9ed543007d02cdbaeb475c5fce961ea604d1d0da88d2cc50c7e3c4763cf78da5d6509a48ddcacea1529da4f39059a44e2d7153f8d8bb8a0df6b91c8eba4cd019fdf2ade0d39d5b1a88279a6766de72923d219e936acca5ff11062e7ae7c0bda5f09c512785cb261088acdc509a9afd2b3d2bb9c2f30840cc70b44a8c1dcacc1272bac258ca313d8206e79791e6fb2d9c959770e7250cfcd179d8371be57ab1d5bcc00c55a8e331ac627c331ff95df943cdd0bdf1003db842b85a8109532012b32aaff5edcd563d5aadd7f220fb50360ee0afa97b3da62ca2c9076b27c2c951b0d15ca0abea8562dd0fcca07c1324d3dafb4b6bd04ebd8df02e7b2869710930d5ea0c50c0e04438c0b3bf23f1b81670a77b7318765848602fd882365de1bb8528de67ca4285e117e010333a19260ffc55718e1c1641a8379e55d596fa0aafd466bf6b58557cfd4308fd75bbe3a9b2bf3ffbd965ada44c7addbd334063f06fc11d9f32e1f0bb52cbe9648a47920e80b0df74accb29a870e84c99904a21296d987dc872275020ef0a356f7954ee0e1687dba38c583bb8d332a81383cb80f62022638845ff869f0d7c87f6c68cb96645df9aa3e4ff58ff553913fa29f6fd606d4398f72a9b53c3f83f4b60231bc4037e24a21d0a323aba913e85dc663d0b2668802e8f61c32a981a0bc149b7795e640555e3bfef12373581b6a35a8bcf192ee37e66432f302f3d5f7ab0d123f4f43b84c8590e2fb2314d1decb465935a283618b5990027b411cd21844fe18c0e4c2f56b6207fbdef7d668e5186591292ed718aea2ab7cb79d38c7d206470e3431169a32a696ff6ea723ae4348abc6b312005e7d2a414fa292e532fadef38a2ef4dabfa9c6cfdbf9471a2e12ecf222f7d8937f92a2bcb2175ece7e0f5d08bc8714e0e7f339e836ac591e22b208292a85f043024b47511616f781d6209d0dee3d43b55ae09dae8d3e75d716849f9360725ffc2981728ed2b66f4182fa60efda28eb7dbfdda561b19abdc00395f06e91c69f5ae9d134c00f738c641ffd14bc5ff9a801b82f0c9a5ba0337aa1cf0820e364f3646ec8878092ae92992d6cb60b489c2d9abb164049ac708266a0a7ed2872bc6a9de243ed8460d84ae2121e6136fbc1012d6d511a317c7ff294bc1a9543508d917ba3dd11e8fcbd9356afdc1c71cfe216fe3dba1b5a977878f36835601c5a2e30d93a467c798a5368abc5fe7716cd3fbf3ddbd20c4989e27a46483a1e9a8e41ba83d4a6dc1326a4ab67d63ad04cde27eb7564e1b762ecdb9cb50aee222e007e7c162f3be2a4d0117d872916fd37a3bfee48a794a77f6b18dffb623b8fb1328ecda6f5886e28a779a1142526faf764eb580029251dee1eafe4aaf779bf16c1865d3f9da6751c12aefa9d38d036a9e9e69fd87a747bdf4c029c690e8eceeacc89a09df4e7aeaa95d492b611b3fb08ab09f693405b1a82519b9fa4c6612c4988287aa4134ddae49069d9e4300ea4b10520d3e4904050d3844a0d57551def61dbc256e38e062df3f3d5de7e24ff61283854ae6965a71e555fb3c0ad6a99141f508be15d0830658a142dc59f9d9056eeaf3009e1cb760b9704b92a38dcbfc0b3b3fab32a2f1d15f965ac1959f2c042e93821d75f955a1361f84c7b331b5a10e262799e29e8157222d303eefa4e339dfc2eded1a77de993894227e27201b774e33ef1ddde9bede393403e82f941f97a94c3e78553b2e4bb830bcbae011df6c901480bae79ff37ea77ae364ba9ff11f0eaf95a37ba8b552948701bb54f96cdee70344880ba0baabf206f377a756bff2ea2e7a254954fb390ffa4913bf15a39bf1b95d82c0b4a292f7f4f1ca6f744ab58fd50afeab6936eb453943ebfa20d9804582c0c15de1450e9a0186dd26c8ad9a105dd4c55dc326240c07b7640b5226bb07f0e3e8f13f17458a19ebed1e33c2194299e0398bbfb187743d1d299ad32385ddb254e7a2c9c3f524d88f2607ec988ac721ee86185c21a05e09fdcbe85d07d100d9d46d1a2e62c79c3121beda419d4a1a26cdc2a5a0fd3ea465f027dd6244d3b4ac136935bebb9ea05fc25a392544c6cdac9d5e66fd51d336f4d552f2f190d6071a6c9bc5be380e4fd5314dd182f93602ebf344575ffc25599f80142673685a6d6b16d15c494405c6968948160705242ea19602bf402ec5ad9e9fa2d33c5a14f653dba26f55d68083a1a9415037b30a4c7481dddc2344b294300d4615aab82f699c8102376e78a1ba9f9e7afdb4c541ba4c87892b8633d92c86f251e3dca1b6e0cf447ca837f49f8df5abd2a8fac4f2eb04d97583c5e479db6ef1ecda39aaf9ad7e16cddce73e3a5c6c2aca6d7d8eaddd458779f688db783c35af37433c65bef3c1e339857c55ad0ff6cba1915a7bc72d7859c7bf89fda5d37c806ef99aa24023cbaf230bc908982fd02b5df9118883e8fb0d4f24b2be8476a71d40055c045af68a46977deab90f0f959b573432b6ac8f2ec0057cad74297ba7b8289f6baef4fd16223b9a6335bfa495e2a5c6745b6723ebcaafbf9c5e1c0757adbc88294b745240bc479f29e3d0d49661e71bbad17718939a4d86dc88dfa4a9f394f4141c001ca65f6b9b1ada6c5d7d0339e84ed0158a9e02d293405c2483e8e33781fe4860b524894f12bf59e389f74e34832e36702d3dce40b7e531780a50637ed8628fba080e0b2d2d7f2c07b3822b70639a78750fce3d99cfadbabb401ccdc9780ee41e425c0013e1fae537cc652fb800777b4797cdf9c8b315037ee0c5e886078da2afbe02068cd298605e27971af92e36825c187b1aaa42ea30b3fc525e6e2701c93d619d6cd7b026e35e382d9730c3349d053198c6c015b2d6f091835d5aaae0b668be19770620505c1aaa5e1e24c5f6197b414d5e86ddb4a152b64a09f7c7788a08ce01cf762c7337b5fe31e475a60025e340a861551fa87d8e9f5a553e21a3e0b7b89073a09c9a195cbdc3954ef7e69441d044ec69f3c045df6ff400e23fe4937400722eecd8442db5b3886026ee300e0f5090712f2fd7454937093cce42749dd7cf4b524e1130da60e141eb5b94f8f77a0918657e186b2a22917ea0826b8f74c346ab18f4e1a1bd6d75e99ad72a9db1b36f31c8dcdac3aec9767b006a2eaba88ffa4709436da3e3f8cfe82a2eeefbd9d71134a08b15b8efdeeef7bc645c04c2c8c414ca6d8440ff488c32cf09e00a8bfc9efa93a30de0f69e9d43da329638294ded6d0e7a19b45981409f62a566c853a58f8647581c7ac8530d0cf08acfc2bb4648eaa19baae39f6d9872ce505f8b2cd549257da6c2fdafa3e47cf8cb0b35b91e88cb4194d6ce915993f294993c794a964a2f8f78863505bb7170d4f34569ce7911df382dc4e5352e5157e697674d038ae30a5efb860e5b877b3223ba07d56bd325935f7602f4729952cfde7cbb4531d3e611f1c4407fd7bb2c3aee848fa9750b2994bc0c458d2ab6e62dc278693dd98d03f6f9efcd124aeb4c38b19ebd25a7d0c4efe23c8e72ff3a0f80ed7accfdd8ad1531603f693d5dc9b22109d5671ce3fce5d53dce8d0cc4d20349ae19233c86c1eb588054d34210e9901f211626f1eb423de7a22adea81219d26c3566e8cc6596169d8beaa7c007b1878b137a337d9a35ed6a41b9681033e598df93e0a70ee9f378a50e4991772c160856b2ae5d43d7c483d3a8e0643d9662b8a55f03de964343cbaa9712ce2a785be28435d26181164de4211ae43f52c54dc4e0bc91be82946ae479ba1b983511f93686ef1249b31e94a5fec7f871d879ecc53deaefeff365e925ddfe2a597f1b458404226b4ce32204f2f6ca306966de0872634e0314e7ea0ed21fcf5813f17a9bac2ba1392b167c9aed8345af57b3f4b4828fcf8782603dd6df3caf0fe96c1bd9077a340e9a4d557a819e58a612a84631540f7d38ed4c51f08acb39dcbc4c832c3efdfa1ecf18266cf55d34c6f1f569693ed1dfac09e67fb066a325b2ca6a2550f372789a87917855e0504522af75c2f3d365b5976dde3d3468ffddf6576220d9b134f7261d796f7796e3db12bbeafc291d82a7f3b0cf75d9594580569ad665321f96ab792a42fa8a947bfb5b03bb4796543394c809cb7727cb5dd62c95860c870e40e49f3cf599eb3092791572b390789b747b27354404bf7b05477e1064f272bb0958497f693fe9c84f9d5ceed1aa8a12a266e09c5c78b89f383b9fd0df808bc0137bbf804fee590a925af792f157d81aa5af032d2e563563df7b454d82e05aadb21e32c0fbac54211cd8114955b97a3ae2ea99be56253629778b9c83d52cace73fcc615ff91907b882ef085fbb004adc4275d730b8cc22f160456bab375f2c71275a96e00d3b0a7f3d38f62ca086fbb53677ddf41403dc2e3920a4797f281de2cc65a5bfb6b39cedda40d014658f89025464cec6063849dd25a10034e230a32d240e77d5e76f9bcd00f294074669cd0b0276cd75f30ba4fb1e1ea9be4d9e11aff763d2ab7127f8f2a61af77223c07973f7787db9d4ece700a78ce795b447c88056116ce54aa7bb07f687cbebdba4e0b25521d8e0d077552700a0471ff0ae2891c848993812147f358a3000ecfe9d641091b093b8bffeaaea9b14a452ea75d6e45a4cb769f0fe0e805b1d13ef4a86f9997eba8d3ef50217b0de10820e2c566c25103b30feb3815ff7993b6e9adbf14e3338ca1dfce8a1bb3feea5c4f450b6415a5f8b58aa5aa8751722e40ad2ad8752641449bc6b12dff83f2a9ec4f63ab2e9b54a1cea243b4a468ffbda032febb80a897bd02a5abc428ad4e0264761f00d335b5dc960b1d1688f13ff16fac632a6c99bd5529303e5edbf54bd0e3e7fe42ced9042880529747840dfabc8a5728bafd7d00e4656211a635d58c799e2c6c441f38a8460f4f962a49c2201f36dc748992c74fe34b58613fae66fc03aaac0333fa430a8f49c298a5e298b3ac0b8f8016c3b400e49e9c0dd2e53270ad1c586a0a164a4fb42baf40dc8b99abf3647affeadfa89ce114b39428f744b0e98912eadc413ef7baceaec6be0a6f58c2921a69756366d634bdb482e8c665c7f96511d9a520f39b6a200f71855ec710f24d60c1179b4c54a14f817864b6402885e14f6b8bc849390f8e9bcc7b23f08dee75288b07be5ef2937da11e08a8b394f1cb456a24ffc64f1233545643ed61e955a6c37065f253bff22507e08ea3dd6e19ce2895ddb46afc4a50a69e00a7dd7512e2f56d2bc90c7c96f0b2886ad100a55afdee2ea06f8a235d4fc0567c6fdafdc51c9cc78c4d2d9bb09d316a79cffb247c2ce41ecbf122c22a3aac5de9f41b066db589e36dc68ea6fcebc3c5ae9e8d2422d491e6565b1fa9ec7826377dfbeb49111d41c2dd3021df937fdccb39caaf7da7bbbcf19ba27e6da83b466d0886397057ba65e23681aa910a472f4a63b3d517a7619071103af3873d62f5db17d8e7609e9815cf7d92dfaf0079e2f565ae790ffb2fcccdf34d5f99fb602eba11a6fe8fcd696ad0afe24bf842cbcd1712873ac1c901e3c6dc29dead4520858a354769aff27d4038981f1595de889c1520dcb42e9e5bc2cd7a546622d00a42219c56a089a8d8122dd141646971d94d253b6fc9021f2e79c56863976dfee9b6f68502e8edb1abecbebb4e5f2fd8352ef7c0b5ac7be19e6a4c65423a303051b52b3bcf71cd05bde96feadfb29cb30cd046a1bf97b3069d80c38c86b1c06f4e7a4a0f64e261c4c42804f52e31ed1ec2ac76dbad6a28b7f223e701af9ee9d7292259fab70e0c758327bfb1cb6e5bb50cd2c24e63aec856eff7454bb19ece55dda50010715a134468d4475072d3a2562b70c362ab6b23d58774b190f1b113f68599403459f60e9cecd605d823874be2ee16bba103cfb0cf5abb6144f951cce3b6239d35fb5e5c9fcc561dffa7d65bf5d949aeb2da2632d4d15d5ac246fb77ab4f3a1f00eb1dc0c1566dc5d3e4a80703bea6e2b3161112b809981aeba87fd4cc51bb791e23c3c656edaecbe9fb2c88c851d94a453db3ac827f3fb085733792602a3ef6f2b18065ab0cc3f5a54a8ace1b667e7eec39f0b44ab201028285afaf6ed42de5c725333d108eff48b37bce8d89b27c6b6e3ee3fbfee9a2e28ce8530982502566ea830de82c7145d04a4c8a2e539ec8c54c94938fdbb1e49979357b1e055c0dab68268bd471b158d138b66758efd9d73a7bef2aa8b5136fbc8e6654c089fdc727289350e0408bdada3b399a0649b9e473a0699578d464014e88444989995a2a58f1f84f8b92c42bebb0e200d4fbd1908f85427821187ecb82aa7129913bc7a1c23687177c0adfc18a97b1fc2d00bc5f753c3475a7a11d40a994fa531483dea81576fde0d36777bf187dbd8a06bce11a0250bce85d4cc27126d0568e224322ec8da870e78a7814dcd40d95a62305bfdbcd77207ba3c11759f0d7fe33fa14b7322128d4c80f5d9fe0a625b229e64f1b2c114cfe7f94981dc3b899ab65f010fe005b27e9d7e0f36f0c3c5f367bbc2af1d53a9049b23b90e9aec8e121025009313424def10c6abd7efd86eb72996669d1c24507669fd629e8543cdb018305abdf22097867503f8ffd5e9960602a44a788512a412488559d432d2a2404a3f704c45b9533c014c9d6b47276fd4d061f49629bd8068e8f63ef6bfbf78979e06bb82c69feed8aba8a0f41d7a195913a7985578c155ed47486fe5a29cc7fb92acc18bcb54bfe6b0a4751026dd283e288126bf2b9ffc74625b9890208ce97a8a1a1aae65147076b52b6303df36bc74a112458941cabfd90368cdc2e2d0ad91a26c7ca64499d7700ae0547235580ef4225ddfc826103b31c1bd41b8a011ddee032d3add7f17de52a06f4edced0ee2dede715ca28c604069e3c78e6757b6d44d6fd6f08fc546995ed74143bc23580e4af125f5695b252f5840b706c9b0957c46782ce2055f87cf36adfddd614315651ee1804768fc4229e985887237688ef2435435ae5a875763573d78af1037594609d0843407c27f1c5b48c950bfed3189c366ee42b59702c6cdbb450c878e979d23decc12875396a473fa2d3313f4c727e27ea2cf8eb6821890e739ab1475ea31ebb499e116fc55420a7ce091332893893abff93d43476bb9f3ed55f14e82e8ad1871def6afa7520dbd3f2185cbe898c13b8cb68d19304b43b63ae921da827446a07845c3b28e46f79dbc893607a21d8c65882cd406871776321c7f6ac0168772e13217742e67418ec0eaa297afd12c42e0cb47818082e96a89b96673f53d9544b32694b89217e0d22698607a854e2ccf5b0dc9a57991e590a28ec7019eddc4c41c3b274f4b34befc80b47c63f65b91388b45c12c8a65fbc9ffcdc86d9b7d97e6fd173fe5cadbfe5ea012aab40f805bbcd2957adb66c721f873f5b117bd07e2fbd0888424ab8c8d1766401e07d0c0122775063c440d7618656b9fcb132cb4ac33b7fe285ce10af0f73fb4f5383d17a4886bd90e9a02c2f3cc8597f36e29a5e6590ba7ec28221c91d5a111dfd3455dd1cfdf7fc3a49541cbeff80489e1aaea27e58b384eb63d7f713fa8fbcaf8ad187a906b8c80bde164c093c12faec4758a1175f08fef0bf2b0e6ceebd4c857a7e0a9dd56519a006716fc8757b585fe29e0da71feaa3981c3571972041d8c9edb669ddfeeafb8cf5f1bbcb0bc69fd236ac7dd34367f908a94b7aaeaaeee4eb960e32e057fe7060b57ad10e1d63c4b253a444436002fc03e02e7c6328a71e6fa9977402146dde34eb5dee8f0e33e221559d13f5c26ab8730fff48b264aaafac75e89110c7b611c28ce6d60c0d33de1a1d94074c0ca08ab1fba55479a8be1d79dae15d9f2fb5b0097a800a85392cf3075715e8d7c0e31679e69d24760a4dff717c2bdaea9c36e97c9561f6f240d145a1a647ebcbb6daa4e9938eb82392bc769c9501bf2f49ca36be01812edd7654061df220802b51c0a147abb3eaec9ba6a5e89a1a3528cb3b27b9d1fe52ab7876fbad5a23c509c449f4124732c7ccf8b7b9e8ceeb82127f221c8c081d82eb0a7f0450ccecc0195ebe3f37f5888ae5d0b6231ee16ab680fad7fd81e6d0bc8a72ae820cec33ad8203e8c5d0433d1f20ea8d0745b1a12c0962c2f9a1ceed5c90c1c8f570e54dd87afa4dd649d52d98cd7a9e3760e538e0f9264aadbef1399e6c668884d3ca7943ea0234ca80deff81b96d7c819631e1c480e3fc47404418a95ef7d59def1c58217028afdd41614e32e966181b166d530e193a5032aa41e993e936aa6b6348c0ae63d25d23bef99d487d3564c438b6b452fa3e7247991c82a203e6612a27be370834284aa43068da0d83ce0ae66b1047e223ede427702f87a8824e7e8947d9c50a7846f23486607435ec0c901939c1bc0681ee131d50d47ad83ab1b020652988e3cda010eca062f3fc35fbbdbefeec1b60ea56c545fb6dda70c48e855e4a9275ad94713aa9ce70d0aba6dfdce20f1fa13aebc4a1f7671af9272926d00a6bfc1d47e61e1e1b7bbb8dea81148f589744fbd7c0fc69806d17f64baa497dad92f00970421b7b08deb80980014ecc6a41304f9ca3f8ab75f5148369cf35e228555de5a622a63f2991a11759643a42082437a155409cee340372ebeae6dd8035e280cb27a888fbcb0fc65d40340f4b99fd7221cbeaa94a9fa3cb34770a5a578ecd2a09e7c8da2cbb2bfa2dff8a89f786624e9a95eacfd5a28dadcf7014f8fb1f93c352bb4d62849c68a9b56efd0c18d829c8aa64f4a7f5193385fb63bd4a8027ecf4b3779eb0161ecdbf282636fe1830ecd015899943a4fcb7d59fe74243dcb2aa76c6468dc67415589ffe4e3a3bf54b5483b01c97619628c6a10bfd0e33db612d07fcea16402828412dbe6f96a7c014bb61f47ee3fd6939313f355b4b4b0b2fec03b25d415928901b7678c4747a4c162784e62ab8e93f743a12739e3b4e41f8be914f6c1c018a3d4e00afa88324ebe2b2d4c8ab230a63c4b483cebecbfca95465c05c4404c5a2142bb377bd1f809028788f40d7c21dae4af633d2be34163e68955cf5356b16551919345c19038a8a053e717743394f6777eaaff535b0231b7c5251e89e03198adde524667662f9a32125372284137a1df2ab28a7987a0bd083f69ce5be273ac3ecc6f03bdff6681d3e3c56c72ab3badc364d05fa65b6c123a686cc45f0eb1eac87e792077ffa262af794f51940ef95c0483521c18c4b08b2fcc56ffc0f3c49c6c5805f7ec89f0ed17da049bd20b57045467399dc96db02376c43f301030d7ce0de6f4df371f6af6d3805d4a01c4b5d96705a545d60a96d07ca675528d22750146de46744a017219b497b304c5fec932b0ad714b37e6b13bcd58c7179353bfed45ac2a53ba90147ba6f4318fd2896e610416f1fba1ce66c8e7558f00950697d36ba26e049c8c75863d8d7cfb6816483856f8c55bdb8f7017f965b7c62dc63f9869624363c26c6e70b37da94223817892d1504e42903f98c67883ffef7afe2f43904caf2bf82bff6d96d701a21c344590fa3ba263a7d46817f77028e23ad5b4f3ca5043271fe064eaeabe79c3dc162c2a9583777ae697e049f998424d25f274000d0e512946306492b457b7064ff8b5feabaa86c736d37975dae9da91ae4ed3f202de470204108f3628ee5240ea2cffa0002e24241da9c974862eed220e02531e045743d80d7bc8ae3b1e25af56a2e3bf2cf9005e14dd99450811a26097243d3f78e511a31eceaa8daa818c48f0e98901db5d3e4a95e583b0281ca2e06445e566aa07e1686bab4a1856ae3cb21fcbbdee89f9970845d5801c2a39955137cfead5f5a9a3d9116316b704d82aa545e8676570bc48836820f6eaffe5dd793fd2ebfacec0da964d1cc39517f5302a83f4523e8113a600bf35251bb0209520f65a70527e298e1fa1be4b67442da1102bb41cf98fc2c08f6f70419f9c039fe86536eff2deb856e521af23e60df8a63dc93efb03a8ea9c8f52d32c853567608c95629f2c69436c79c4bce789355486ae298cb8843fd3a1af53be036d92b479aac31de603a9f10b57dfa24061be1a7ec4945c746413697c9f6f1cbc4c270d8d1b02b5af2804854c960db8efd5fef07e2649e54d56d918d8117724b9615cd9b81f1d448e5331f2bce430a4f182421b700bc6e49a7b2fe35d9cf47c6b26d8e66113f41ba9e4a09ccb0fd34a732dc9081b0dcc0151cf145f3243f17c50d86db9993fc7bf447ad6bb1d9ce6ca990c3f9e1252947bf3ad53d9cd5fe73ca1e11811f2e6b503a6593829d6c56aa9d32d9a6d6ba7c4d215e3cf6c9d2b059f5168b0dc87f146ef442a28f1197c7159319b6902bd2ebc58ead249ecf017cb0a047f761a2377c16138cffd715db40505e8badb53e34732e1a56ad14902ec83fef65731ca89cfc34a52246d1a6bc502d2a9399537bb9119193513f69fa096ed1c7698c8cc6e1a8b42cdec18e69629d151d5b2e083908c2b4b16924538544bfc162910006344e0236e5be1448dd5ef5ef53af75073bc5e98ce76ca09cb3629c33d6473239d7170c19398e0bfc884c9a9cafedcb3dcf7688ca1814dac67fefc6e81adc5553c8a071e6f2d6e83caaf0d960831de1ff9abab98c6a9922065427db4a4a4ebc8d2f8ad3463bf4ab30f88ca54a0c8f766d0ceae513d38c29ae46054d31e59f8427cf7641f16bec69f829c571ed8cb7efc147d1901a2437fd8e42636a94f266dc8225d283b3d8a922c155cb2339b0d7af3822f0e64587e1b9d224a53ce31a1a40982c37c5388e3862299dfc5ff2ccf836ad59d3070ef9ce4faf72fd32301bb0d04de9050c8d9380895cda67870629b199c76631f11e0edfe7a4890c4f89adfef200888043daf5d0884979a4f52d64bd6e69d90f81a8358453c499d80698c140712ba0ebae2cc4c3f08a1cd72a41d524dfa918a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
