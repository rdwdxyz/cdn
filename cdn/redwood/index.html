<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60ba4ce1ce03d967c31d9116741e97d177dbe0f67aff0dcb7e3720c1e4d01b66eadcb6570ad27156e0db46394f0353409ca42eaa16aa9ef5a7291e85c467d28508920227fb4fd4e477017218d254d8224e7c257661a0aee2a3f89e6d35c02c567f676a3ba2c9fbd5285fbeccf61d4c5e577d66baa336199d72ed085fdf663ffa125aeb79e4e342bd5956b365cdfd88588d095575e25ec600910fdc5edad640989e82974c44c5899de813a277aa8d7467ee017b91cf326831a6944231dfeb1d4d7e33a3dc2fe33fa0872d05fdba8d7316679f4388315188208145ccb6b2a4ca8ad02fbb9ec163f6c304b9ee1583a2338dabdff284e7cfbe9581f0720c6da2921d8d3f795e29cd593eb8cb4d4987f2c84cfe70ba970d657cb25a89ea32e730a8f3c0ca493cb78a3ab25d2ee45b7e07a2c76691d86d40a15ef7258e831c0389152dd5def45f4b4f52889469fd0dc9dfff9e2d53f3bb4699455a52138415298d0acaecf26035565a53d6f9266067344eadc8117cc3380cf49f6e6ace05c256a00db55f84f627f1c525272d06e4308904fb51dff34dc2b0088c8165a6b8fb657837631d48fa3d0fee9fe0853f5f091c0f53103bfcd03b084c5adb25971ddb6fafa627634e2140287246c1190d6c6656aafdf42ef4058b284ba037c33731bf86422af8807a49539839e9de296d07822f0e8d1bff7464850a7fbd3abd9fbf1b141b69e8c5c976b6ce4aa865411d3a70712ba5c836291a8be2d02574929e18d44fb4f6f67ca126fec724cb33ae881efbe4ba437433a1f3c17fb5352aca8f4f8e9ecf4262fa7f57b9971807a47f5d3d8da471a071d6311ffecf3a550344c972c653f512c839fb9117e39c68201471935d4e2deddfc33c68de75c90e7aa879eeda826dac5f7240fa00f21c7889e5162c38318d56e824a49f395c4a4601b9906aa8cfb7952909219acf8f556d21b1ee8039b639569ef3c84b79a0d66ba63578bab21e6e8a791f0f6e826644cc3f6722b46f116440c5e43e1c8d16392b6e7b13b0a05e9594c5739982d159f664ef57f5ed2b3d86b8cffadb9f86dcfdc185fd4f930f198219afe11e2e7fd457b782eca5f4798d67a5c45b6eca4b92a2ff35b6238a9c74b177cf5dd7a68de310ae612744505b3908993fe4f6c6c9fb8c2643dacfa5baa6259cf794a8bf9ef529b7b9f54c4e87b7f9618e54c0ab6dd5d6c5ccebf6699a9e7349ab146bcc1ed1d3f72a8d78e5a778c15a3887913460cf950b0f4629c0f596651554369d2d1ab4ce52363d7d652d47a900e0cf25c6395eab02ccf28b9d04659c308994fb986b3b113622f63657ba2ac2f284992f867dd44fe2171af3113488806e85e57d8f28014c267ff436de6d1f1130884e006b44f27d9b255f66b0d7b893dfb66f2c8a5ece04d24b3aca1badaf0d4f2a9c4c9a77b2dbb664180154ed5c59bca7cc44204682421ac6ebfe89092b306be755e4946df030bd8c94fafa92d1240cb445f42f89e49e35e9064ca53b59c2956955ac5a48a9cb78c1a6b0b972a022249077b63adee764ce8b3ef47d9eed2fe6771147e93815c47f52929b509570b7f574c69c76727d6000928fa0ff56bd92259c06eeaba3f6789588cbdf1fcc41e71ed2d524d0ec16057330c0ce9195c3d33a1d0f415d81d7df20945c58f4bcc6e1714477b45f61913bfeeb2d672d5d39d95a61a80e6ce7a2b085329be605a7a84f178ef6ef3aa97e0a70b85c1dd813a2580254091a225112ba54449cf7af39c83f210f0fc10d7cc2b0a2d227234bd9426799e4629968210ce3f50c67b96263f454d2cd0988aff4448bbb5aff0ee35ff00f6f5cf2ffa9d0bd31d5a14650d383c75d5f38b26022f0f1e8f88905de06d834173a53d20b4cebdc8d503e332b8b46a799355d1502b51916b7cdcbb3c925acc37b7222c11f8e9c60bb6bfe049ca564f376a345564304e83efb6c88100352d717a37b1725ede020badad36e54cd72be767cf236c3905770af6c90c53ab3e55e848feae891ff67c44c9d59effddd0222e36be3fdbf2d6bc5c72f06a885386ff65afec56ff6c2ee36209cc06ba8cf983024ba51cefedc269a57afeb644fc484a9ed468b3f337c528b359b424e6a95d89eed5acfff53280fa51798a2bff8a8ffaab4b8d652e5d6c05127291cb3514a7a6c1b958bbdf340cbef3708f25d4ba3801909e79e4c3dcc35c4e264cb8e5bb00aa41ada0da8851a8fc91b139bde0b7124f55c8264ea37519883e11347e5478f0e1a064bc79a9bc0fc869c32281a54a342b4f701d083e423aa840191f537b1685d37514aab02876c11992f85a1150622331bab6f0bcff167e1ad44bc11971b205d2ed9a9819212c0266084c748bac199f459df910e94b1d444e6233294cdb11121468865cf2a1ab9021b5ea2cc21ebcf1795c8fcc95bb80f96e8d6407b35392d228bb8e880a27ca656668894799c39d9faecccd55d6672c55705e8231a796e16b59c6e01a26680bb0fce1e4f7026c2c2ebcb038124304bfa26a662f528526eee4395b0dbdd4049552d969619c7d429f3c756988e1ac77a4fc921b286c158590715ac031530469a8628b64d719a5a8aff5329eb8fd94ae76fef84006aa5a6b19caf9f7be48b3f38f0101161e198c15d9303537651ece4f20135edc177ccf226f85d2e96e5360a1809a2b82fa50980c42bbb500a770699617959a372382e89602e026180490a7cd0c00376e0bf33557f292df58593d787aa00c8c746c66e173eaf8f6218d768f2db1930ffd4c51cf31c10a9df39920a80e82ee85a8874a4def7568f6a2e14c7b7b523073695dea20a72222581833df4844bbbf1a024caf8e0263ae33592378e61466eb9ae31d516f1cddc937a76e32752b56db4ac14bfc6c119f9feba558a5ae6b53f4dfb30d105615a133edfb09f62734264edd6b7370c195cbb61291b040bb1868a62f818ee3481cfc112c3fdfe1f31b93cbe0d591e7ad563f34d570213d5a0ed770eed395f8685f3492d4c334d9e841930b1fde9d7b014f0f0d7a26f378a1923591d837c7a8931dc84f4013dcb356808126467815f7a99a914905e1205ccf5a9a28a39d601c92e661ff7843a6a1acaedd3c6591c568a3c8e988621364c8b5e633fa239b7ebd6f7f7f9d3741785d15139297e7648b165d585a0f0f23235b4ad2211ada81f5e8340454160df21f24f7052c63d402cd05d2272db8882b4dee5333a840bea8e98b880c7fa69f61cd587f0f3fbd32e1bbe9a7351584c77761a94e2d7d2f467c70b0a81b9d7f63cab45165bd93c74531fdb25ab8c85187a8540ddf203735a4ea0b4f5d07bd58ebc3e941fbb7b95690b9a2d92ac5cf14a25c6e5f61048c5e8f0340448e053316dbb74af6536eec5e6eb29f989d5a01a1f66a213c226017f1da4864d5462f8b77c3b0b931617ab9d1036fc853e4d87047cbc5d15cd0b2dee3897a78e65473b05481959b07364f6977fa71895652c41111cf5c045ce8bd5c1194bf70ef14ea348fe67ad2407195cb83638fe4e17115a5d2fbfcaf3374847654a5a1360be147ef4f4569a86fdfa5c25d7a43098bc62c65163d503daf52ddfb4f7639ccd1be515cb0237115dac289f5305aaec8c7c3701eb1f51bbad5ddc4d8b2873d1b6b2f6b0bb6ef23827eaa4538fdf9989f954e901140cfbd8633e8e68189276ce4ff3d6814218412680c19dfffed2d48266869102896cf4511ef9edda1bfeaf57cabc27f7e49852ad3d083b7a57c3a9e21aa7b5a8f4a0a675e3139b656bc07f148806dd7625326b2a61e41dad5cae9679cccca8f34685835c0e6872458ba8dde74c7732984f08fe4f16ce506a107d210dcce6a25946dcbc887814c7b0a125b1ded7ecc0c30ebbd6556b040b5d0ca1504432c41876c161ef159dccdf471158b76b1412a68508e30d967f6179887691bb7cdd290cdfd95e381a080862cd5ad01164229ae1fd9a71f9b6d550838e1f5c0cbd721e03b0f861f09f40f9df6b5891ef20f4ac9ec85e28c0e0d3b6ec2d3e453dd642be80a9f850d89b5c7b9fd60b2199d5f2f2d1725d1df2d064741f48b8d7e772700920354dac4b70f20796cbc06fa1be77c8d053c4222285239a9574a76edba633393aebd0296f8c0b3ca637f22b22f8d82b3f523a93430c05e193d7bb19212949f84c31fcc59ededd2e53a1a7c05e3ea0c6439e1aac4f3d8a0213328af1165ba3325efb454cbcc007faa018c65b474d72c670b131bd681ea1a1b9315806e7fff79bd564f8cf1dc0e1bce7b1045fd5ea9e6cfa233b6cf2dbd9ce360aaf6a81bf1663b113919ec9f4ea0febdb19f274da060551ab2205acb7ec036db78fe81fad087fa122c8cf0815abec4595647c2e7ce4b556d0bf77e49c28db8c8e4f02a1729d7b040d29e9829719482517d26566b017fcee4c7fa728040ee3fc406dc4e26289d4abb497d91036ff49f6190ef7ef0646ef4acc07286b101627bedd0e6e6c57294d7eaf27bc70a7b25cf52b602b911eec0f625c9e3c8db04fba07839a27c8c72d6f3393f571366f2e8f8024ea0974cf9f004b62885a69b57d6c0a0e1a331ed71c80b3a06c87e35877c1d590c3ff1a829f621cf449156a91e318fed0e155a2cc77f5b80c9378d1be9c45946d330a787dae44c43069f58f7fa4d2ebea991c9f06e3d1cdd19286a4aac14e6f198374c49813e657376c8ec43b450fada0269cfbd0a19933389abdf31a5b2bf3517009e392f2f47a3cd1de78ab8443f6ee27f117663f5fc00397e9424fde29171a65fc35782d663e31e8c565cc2113b34705c9464b1cc8d977895e4fb9dee704b02f5945f47c3a3d2ee770f91324c99936f41869fcf62c633fed127c4d93754d1606228288f52bdd325e5106be9458df63f87f85443ef54aac1e570f5cc702aace4c925b8f92b72c438cb2432b25a78c71a43f3c2e4a5794fb94bec2143c17b559cc9ade856855f842ea1c5509e391a33a40e8218283e68df6c45c34500436fcb7581d5614cb4e1d06459e12ce9712dd6167b76db545b5c38f9d6647e0bb2f560a44982da9282d51d02cc5a1b9d8eeabafd535a9003545ca8467428c50f00c4d34c2adb53dd1ebe65e377126277bf2584f35f66cab4d0bb5399f9e4be207fcfb5a9d7ae5b4e475a59e3a5044be407c37a2afa27d29f25ea4f2d576a39b643418a41b1b8a700e4448a74f80461222cb5d10c10043e8c2b76bb44d5301a7591f301ffce324c3e13485f0a71f664421be8d81fc84b952d42be6371ac9e5636446f36a8b0a0d63088e3f0813131672693efc08ea5aa0674ddd7d9f2b1354f9f864df5d62601add8bd4393a4e354be0364a7ae172a3fed14a4243ef55c188e46e1779e752aaa838722910839566df01d9ea76c5c1c1a1ca7b39a1561d8f757c421a6f3b5e495ce477f661e5688cca9164887685e07b4f291bd8eb8403d68730624eee224f6e9bec7dc8b766e2a4d6c9708bed7430e71c9a516e56a91074b7ff3888fe4c2b5fdfe659ecefc84b01cc9308ce70e96a3f743e537638ee6a24d7bd7724731deaebd81bd69dedb7eb1f5b119e14419342ea500fc51cf915b15af650a60ac4fcbe9e7d1e0d1f21794437f4dbefa983d78f97e064aae36cb9bcebacf02c9d7a4fa8b41769287df6d95bb01d6f93f71e1a0662c8ffacf0d3658bec4750f15846be95433290c4b089c3c8d3e9bf5593a1af81e2c04c3b65f30a645c54db2f754dba3dc1610c761323e5db0b5da2c4eecc297e9b018081a2f5f83789626dfd224079545cc49d0edd5fbd0864ca89af34d39c317087f96a3f146d02eaf8252047811bb878dfbfde13b91bd465e39b25e64b8113a16ff2708577ac458561b804aa1bb1c196bc1feb82f6d0b6121202329418603fd8d4dcd7559f8e17e4c341e78966d65001ed3a7e79d7af9645b1cb1ad7c148a454c4fab9fd09ea165826c293a1773662c1e81fb1dcb2a3d8e3ca11cc01e0873bf6522a8be2db75df126fd1afb9d71f3e5597d53cfd557eccfc20117b3239e99c5fda4c587261d6e116a6a48354b09d7b40f0973bfb1e42c9d525b28d781272d19be519aca43c6c46e252aafcfdffa20790c3c53c458c9f2be7e1ca0341a5bcd3f9f0c3413ff45eac171fa2b22e103276639c9e83315f4a2328ce849c4e042024f9de4a9390406b1b1bd8fb68d2677924a5e69501365fac96c571b3cd9a0863aaa2db2837b70f06d51573204b1aa0be3bf6e21957d7cc3d59436e76224295885b2493149b8b6d171315914a04eae80397a674d793e5382bb78d438030e682840d0fb93281464385fd2e0841e5c0ce47138c422b032c46ffb7f15e8e8179cc827e1f79f050c31c811548f92b130f77dbefe41c4192d18b3f83244b5f175e56fce03e72bacf509c1f78e5e6e99143a8ad59c35ca8f3af18dd1858fc9662a3ca9a8e120c57156ae6108bc0b12d1b2901263ff8bd8ebef4187125eb2165fa566d229c17a63649bf7ba8865db152d2effe4cc9cf122ac4290974175cf7fed51b3e82bf0b2403b22c486a1e251fad90247771e982dfc72a1abaebbca05a78bd7d71c0bb13f07e08384957cf6b67eb5d294178499d4cd1ee2649e237eb4192fa19892e1ada9ade7a6fddd9e816e0f595be78e80c7f30bb1caff9d0e1463ffa9aefc874e2c5a0efaa13bed9ac73ab370902c0297f7fb71a003454839e5b1da47d96a47f511666a8653bb3b63f2d1e0a0601a4f81e0473f551a7b4244c0b7e78f2d86323e9ecd250045cb89188cd50419509d78a84679edebc535c4c926a9960208ed55171bbe00998b9f23051eac071302d7d8900864052c45c339c7ce48094f9777e516ecd29d5d554ba639bb6302cfa8e0c068f80feabe468b3cbd684e312bc048eb02c15c3539c598115245befe59036115e9b83ebc98029e8c3ed9e052da1d2bb6a9aa9867d3eb1fa789086f86e370e958f91faf5ecc2b4c28edcf18e4b50a8d67530ad346814e50cd90d455f861080ad7c82382ed8be783e0063362c4c4df2a9d43666e44e99d7337bb5f4a02bbc31f9fcffa7ab8589bd6ee060dfb73d1e3b176f6734c9b37f6f76bcb85dc521dd2663d9667c9aedc60a003966e790e6ebd14b1592c70575fe390813760a6622254f7694716e20278ba58469bd536aae732b04d5f41bc41210415636f437864da6e9491030783f8c1d74dd6736e7503704398fdd5ba638299944c0770776cd8ae6a227d028ae3389e125f6975161a58578f3970c70b7f375e736f4ed269cc2fd902de3f199ea3e8fdf4370e000be35d25d7f44d66bc7c11754963384f9fc6cf4310b23ce6b4cf5a76b42173c5f7cac6632701bc5fb7979c7059f5374d463f35dd0b02e1fde58eb20c4ae4284ce310cccc3dc7eec5e8eb3269cf892ca960f3ac14f1987aa0fe8bd0f0ee9bcdbfd446f5c11f86ccbcd9adefc8603e7ee0b1819bcdb2d28d6773fe96d3d46edf7436f41507e0e90ed96dd9ed58c068064a145d65e528447a0c0f142e6d2e0352ff6e7ae9774f6a09d323d885d9fab36eac417acd06a73b53a2160e31be7fcefcb479541a70920e4cfb913dcf1a2df65ff2bf480ace5eb7f4de4e4bc813d0b4f4fba1bdf80237bcb3e2602c55a56f8429e9ee64fbf6883505d6e8bfb76df9b1bffa7966ec112c995a66951924d278987bacb4ee704d5b62920bfde54526f2f45f3498e017f06160b7650461b17702e907259f9ee481dbb5cecb3e05a792a0e36567e5d81ed646cbbee25cbd2aec9b152f5133931e81cfc5d0bd014e0066325d830e8d0b3d00bb1d77fc597da5c39a0a66ed27bccfdc6953c23e287f098672b4aadf024473465054f7b6083865af04599225863dd44187a8cb52aa7bfee10aed666f841ed5df40d178e9c6ebfdbec8b2019f356ce16c4c74e117e7c4d81b2333e75bcd6748d5176695c56dbcab5aff6b9bb4c6c55b5755183d93f0cc41409405304f4ef482a7e566a6b0e59dca87ad6bfc8dbe130f856abdfc38dfd001a7aff785d60684fba5d157d6e73011be34a08b904a18a27a043140635a13a339ab70a9b32f319bd3023663b1e1f253058c5fc12b7b74606cd35815da54f1ed552247e61adaf312a37b70094931ceb648c578b8bc7eacc1277c06ab3be3abe06b976fe67b9b297438e6aa97d0476dcdc167b2a99e6d5c9eabf90299da1edeeb4bc06293e422a1675b02c784a10c36c91ef1a55ba6bd34bba9b5f0eebe487391b58bfcb3086bc891d4583ccf687b0947c89999360ca734da43c76af7cf0fd6935d8121581b124da06222d5a2d28bea3e9a83cda40a029220fca1b6f443567a7ad73160b6e36ce77cfef6a59efcfa91ec894dd6f0c4d0518c4b64038b3be0ea42ad91d35fc0cc6ba954f885fe5e299e364688f8480cf728b2db69466db46c69b8203cfa161307c2fb6efa515ad15aa015681d056ef772ad0a2e417cd855afaf93e1327ff7439becf364edfa6be8cd6eabac1f76d8e48f6ca9346d9aa613f141ecc09f4348e69bfdc08ce63a42d9a7b1fe0ad782b375d109969e94622ef0a1cd680b658dc626c662be1585f23d1e030f628ee0d88360b48f4108b281c2e064f541a2d4a7c669a79149a9cea47c7a93fe8beedb1a1d37132cae9f5980f3149d6effcf47621aebeed9fe8be63d2052384e4bd3886c76f3093220e0601a3af9b3a8dc3c7d7134fcf232892727c8995118d6da866654dff12b11277e8b257cf19a4e4a963a834416ec48ba27a3864e9641d4a2b2c367c39cf0e93021433841938ca3c1e2de57e48ce4a26394103d6237c7d92d3148d8e6426c06b7d90a76726a1efaf66451b1afee483bfb51f6478de8469e454cc4e234deaf8bb7ae8ecaa8edf7abb4b159a87431fec0fd398c61b60fe944b68fff9d7bc979a7fbdf4eaa3f162ecfa4834e61101b6cd9884d2dda555818d9b1cf834ed9fdcecb14e62c07eb8077a990424a10efca6b75274f5127a0970ab708ac6adaef31bb41f5bd46a3a6b150c9cb8a516840ffeb215bf3ffc82151b44d19fca63a3dcc946dce8fc7a86aae6955733f2fc15a39e737f21deac605ff6f8a2b8e5904bb17be6b4aa8d3e0d02541563346ca32f87a7440999ab57f30087265a0b7a13b07ea023d244d08cf6cff7da13b6c3717432263ecfa91544e953b90c1cc388d349ab6018959482dc3e9a68fc28a1ca202cfb2fcbe57cd170cff98fef843361e8d417f6229c400421fda021d6ed69ea93ff2ea69f51b6a9c4c15148cc177e608077898eb5c59685247ae89a4bda4a27a9372c739069e7b314c98e436cb40e26afd7bd8437918c8197721fad963909fa348a691bb3319e93ed74a93b51b226dbe31b661f3dd87eb4871725cbb2bbe79e7757db8f3a4a9c09bb3f6445376c717d5d5ef7aa99561609f74a9de9b6afb0e8643ebf05c5e62916b7597416946519053bed0d1f295ac5edf57a17156c463a37fb58c700eb158c85ebf697431360c3e20939e8e0d240341e33c9234d623df0c65708e50d14c835bdb259ed932bc7417fe22e88508d6ba436dcdf20d2322c600d1d6b4b9805e36893905ed1d9aa9aae6c61dea7152a51ca8668d868859ee8eba939ff14d8569bc0ae083c0a6cbacabc903c0266ee52ea60c2632b58ab955fbbb1a56d95c4e4039a700137e84200823b060487aff39f4f854be288bb415808d248d418943f30caf47c5fe19226918ddafabbcefe0539284edae5c9501571eb796ac0199248c323d42e8c4658d6a150d18acd37a875cb0150f6240ec6505659bd03e09f560c4b782833847751e9ff88a4ab6b4ae5c8db13c98c73e4729e456c9bd2aaa294d18ee7f8cc0cdf1e952b4571a7baf4c9521ba0afa1a2da4197cab4ee00fbf7cbd39e514e66b06eb061cd543e222b3d09272846bb557e2d9ae8341cc94b4c5760017f59cb30fbfa1e2ce816cc39638132ae9a77a48eed86def39ce6883b10913a08587b28e91295b4e32688034cb356cb173eb2cf4a74b64ca9c241e79e258d121424c84c4835cb9810d55af6cfcb56de6dd757aa0c7ae05142fe63e7d2e9cd294c0b06dc0487fb4ec41fcc9ddec023c6f1229ee90943c2e0f23ea75a28f93fc08466f10aa91ee973d5fec9ac896b441b74051143940172539396b665f86dfe76c2e45a107b5613c09c5da16e86798c692232c4ba6c85a6d877a2aca787b329c3592fb36ab2e273ba390dbd771c170b6aa150d5875ab4746200698f125358eaeeb9ead8d67eca68f2f3bfecc5a73a88b69c50721fbcdce32d5197a5cea0fffad515a3ca05ad18b68dd7882c87b40cdf754c9fa7ec49e0706291d90d5e5a7dceca3cb3c0453d6f00be343e4789e81da8ff9a8325efdc2aa2b982d4a5c43474f73bdf9053acc9ffc647f0825434f6ec6705c6cef60deffc1e3f55daa0402f7cc489b13831b4afc994d6bd799334dcd43fa064cb1926c5ea8d0a88d38f20ada72719e2a791960ae1984b032c44378b00de5fd731f961f7824fbdb7558635432d0fd9c1062b373af96b2bdf2c1fcf6c3422c1b9ce39529e1372991e11ab5634f7ee4c242d3a635adceca9ee690a2ef32c9e87511501406e7166d66a0671835645224eeae3325ee8e32ee4aabe131f68f3c7e36f0f5dd1c7648ae8020ccc64279077850d92b38266a13f2af4e628b8ecfbbd686139a1b42c5bb46cbd0018bde1eaea227b5b9a153ec6c34ba4e17bbe13e48a8f994f80096bb4a5903dce194b524140c46bb68cb71e5d1e159ee40465a67bc86ab71f62c0db8d88efd522ccfa736de20254e53f10fe9a99b5ee5170e7973b17b50b7b4ab4db4d87bfa39e10743a7ffdc6af0e987524f5b4b0a3b8afb40d43de1cc0b466145e55d8f4ee4f826c05132ccdc3cd684e718565f6bd7e5e07c104f9339fc60648d744ac2bfb69abbd832e0b4fc2f4a7a613f892aa900a1b8edddc86d8b85249c5ac22b086100dec6d95a42bca791911cdc0c125e71970c2267db0a58709ba14d3901bd82a77d7b1c55490f2f6b02be7db8097291f685271f84324d928244898707db7dbb51e304ed04b763d4fed637ce36f233e926ab26d88a57be9595feb37719d8fe80afb7c55a5c28e3807a1f94d7b6f8a59c77f044b5952404ed86b38a0f9ead61a5fcab0c773dab3039b4bc9704b5338052a613d109eaef062805dda211537d73e6b25f81ea2f1cbe01a917a8b342a5e1d1e943eab47f67e89658c67e4860e936305ddb89baf37f217ea2dda6bacf3d6840be4d07c3a9161410e5650c012b67a76fa4bcb3e8ad878279912daf94016fa4e54a3ec4b3a813cb9b6918295d6dc58c8794e1dffab19ab4d48e2eda2067751ed9f63159c5f3a36589ae6b972996f2aee20b32f5ad79c58a9769bed8f1e8db56cb4b5a117236a5dae55665ae9cc5cea95c65d95ac4e3d75c60d2bbead65554131bcf37595e4dd81d600a9d09283dfff226ced22066b81c640bd200c4bb5fb6bf1742ddd4003f9918871deef9a999fb36de8f65b4be04edec84fea24edefd558cc759bd26659d94a43ad7994b8a671cb4d3b39febd17736f1fdbdc1e5904089f5eca24a7a9459107337494e780c9e711a546948a8743b0cb35521324b6efbc1c02fe416d1f39cc15b4ddcd27f3a57d7342a4edd28a30fb1ff06e191dd94249ca37ad38c5430885eeaadf985c70964c68c7b8b8775c71c625e853b15462a784ceb9631b4222393999a609fc01c14ac9b3680775a5c25aa85600f2f4f7ec89e5397f128d0f49087631c36f9a7f2ca578e20b457552d3612ffad78c848a60b5eb6889c7e22b5a7b3fdc4ab77b3ce29359695ef245448cf4b03646a285b76cfd749cebad8cfcf4a7ba5b8cac343e445581025c3e696b71fbe18866771d4fab57966387c198e52d8d7e601e470ab1e720336d5349af8fb4d7f17ff4cb74c366347743e97221602383779e931565f6ab095205fb9140104e5c7768505eee4489ef52603b5e0135f7189615643de89d457c5b290d866cf57dd16759568662c95769cb56024cf8fd5c0217ae80a459eec499ca4c8c07e8172668115cd620178b75aee741ef60e9ccc9f68a5521a1259270bb05c43ce89793c733d3fe4901e56ac75fa23a9aee2c61d0e70cd93b4aeb1ab8b966cdbaaac37fcf894a296d8f0839ce5b85f868befbbbe6f0a666992ea976b766761b8515147f2fc6c46167f2ca9f80809f5d34511eeb20ceac15679f8ce0f18e10e02056e299a1ca13cda9b670440b2aa229318fb989ce8c9dc96b7845209d7528d4be70fa830bded17ed575b845078d79e6c43495b9dc7ba2d39206df57834f800684816b27f97ce70094eb88466d9fca8b1819ffb8ccc2245e9d93a1d5664a763e37b5eed5d6728ad3f8267e51108df4adb9e247874747dc08fc0492263c2d1daaa27b922bc76efc6e649db8aff0060f762aea11c1f65c3925e4685b317163da5f6eaf2a38a99fee2b8df4aa22b4c1f855a169ec28249d10025fb9fcbce30f6bde9e924f8ffed6ae99f5f09a896a2c43bf9712a31e7d36af4b7dc9dc0947e20cdb5a3381d2a612b7387d3e73e7845f95dfbb59b826bd8bfd41d4054f9efd421ec0bebb1879475c02144a192f9e9f4dbd6f5dd73dd85ded505dad9b4f03dd7e09b3a3a4923feb39a958849502dd0f09733723e09cd7a48d85f5e8fb630f4de68c6aead5e6f385ea52e3bd3b255c262869308d8a5c8c851b8c9c56eb399b81bbe2509607e2bc5c6748f856fb2b577a21635ce6e6bd19002f78a9fc121de03d2870ce898147c237cb59eccde47762a6449167044d81769e54f22fe6ac80a9401910c0353bb94fe147143e7c5d09fd7c3ca0da87612fa69dd3a07094c22842499a00371159f847c1fc08abe521fa813db0e40d1acc2d1f6f080f0c9998e84adf980bb4cb7354e3c389eaadd9dd7e98350c4d5ee2d3a6a1ed4565bf592c6d1502fc0d4125161ad91b3c416084ecd5b7e492e43c7fdaec3d837337856d900f944fad49a9908a27a04e861e8032a650a2971d73c4a49993fc260aabdf36f26d68fd6071f0818a84a383128bc43649d4c79185eb6182d2415a62eaca702b01df274e47cc9aa799377363fa54300745dc157539ec9581d83f0f89eed2bd9a2b52482c99fed8a9368457cadc0f9e554a7798eb6f66bbfc5f15ddee092874e1db0f38df7bddbd3dc45b83c495406254620f8b04216c37d3e42b214712e913922e6a1410dd7eafe2c6920cf4d3af55142689b06cbbfbcfb6147e923748829242ff4032801cd825597b04b293390b23c351e5f8bc4eb333808ab4f098b4ae249befad3d791ce6d53068b3c7dc0cd53488803efb11b5e366657a86cf289267cb46f8fe12fcc56c7bf4bf9c60a1d8752af429c89f2305fad07a936e9249cc9003022a77e60f71bd442be5b232375f13bc9d4b398cc5a27dbefd5f29b8f9feee93ac2a578884039b163929fc5eda810a18cfa38555d416af62aa0b3ee686ff061272d4fe8e15680a6c0b67858ef9749d721baaf3eb9a80dbb3024eeea39c369407c7c7d64fd02d7499c458e98bb4764b6d43707de6239f4a21b61f2b6c549f25a9464fda20f23b87c5ca2d22b4934fde1e046717ddf3f2945bebaa1df0054d15c02c7b2054187f72ec62355f1bebb07497ed9ac75026142f7cce91554512b231e178c874714d3fd88419a493f649fac71c9cafeb1306ff9381202cb9d4badcadc1f49ea060475f5efebcdbf0f1fab30b76f1b86b6bafd1b3b7a7ca661413266802886bb7fe3f49207b8ecbf729c9bd7a4ce16682d09733cfc9232c72e22916a85c10b4c20d5cfe1a7b51a22b75b6299b4d3d3e234fc4b4e2a6cb55c5a4609f8646fc92240b99ce713af1eb2420f07323eb263a2be03cb772c001d75e700bbce1f0cf3905a0387d554ae2eb92cc97b9989dc2dfed0adf3ae38e7b42cfee16469612d63a9fdaf55a6dfd39244c47b402a33d4b41714d3cb678502ee8814d2f966602cfeef3c36d165055361f7113b4d2735579fda9b198cb1647d6e017e30140be3e9313db14bd8cddd95a4c95722b4fee74e10956edf3614e79c2eb4fa379e3243271e13e58c65cec6d6fcfbc5ff628ed95abf4de5b236c3a885496a3fe92209051ee684775c4a82422e20720ba7545fda7a0d9cfb80cb8872eea4c131c7c1edf1d04b8d65b887bc6e77c0eadf17d15a9703ef371858381796bc1be3b27fcc13195b0e572dad696ecae1b22675c57503504c8b95e9fa1bec811a2d4cc7df992a4d431fff71139898af1cf79bcf245328c965f990cde494156fc3783a74b2753c542bca72295fcb657c310d8fe80f05254bf926d21aed0cda1183d0c2267f7a93f88f94d2cac97895de80ee08c4da240ee4e9fd5293ec3cb1d7c2eb48134e0ee3e0505a36c150afdd6de56263af782462c8535df4c27ff2fe0b97e2733f7762bd9fd7b2a1dd09aaa20b662a2900ee8868716d4e8d7470f66f2a47f79533dd9e63c807725e420f9eef1df62c441dc2a41c9640ea9d683ad372289c33fe8059a70f68ab4f19b74d5089ba0c634c73e2503a952235f8ddc79ad051df7340e0fba0719d1fe8a31abe4296f02506b1d6a0e5458caea9723f22184012454d53cb94bd51ba8afb4ad71d8fd4a4b5dd8197110381fc017895e9f0cb320032e2653dd2ad18ea279e3c8ebe7db24524c3133f7299a88fb3f05789d5bddd837ffa03c534f7661d3f10112f300d20a4d362c0a04d0fc02fed73432068c95f00c56e7ca3acbf253f329fbe608329fa4fa81a006ec30b93f4aeba52c16acd6cb077e9c55c4ea8d65afc09d9d01c75129be9094f8f773e50bdf6cb65e061ecb8d5dc440a76bd6ea0402ba9883afcf006dda3b6bc8b562224ac6ca9f821d378f9c3c266323738292d7d1713993f181141c2a49cf033e5632d98a6e34858b0f88c92e703ddd4cd6ffd0bd5a1b821f6ab9438a9bc5fc1cdb0956926138a0ecf0e90d9db2962d5934c4f1d31563ae312c9a941cef937b408e86ccca02a811a9dbbbccb1b33b5acbaee1ee3312ba76f29f0269c062cdb163f6044b40ceff04bc12524b63e0cdfb8bb95cbbba92169825f325c802b68ae277ca651754ee1688b59f5e548567dd3ced30ccf95e347ac38ea15a92ea72a5b48365ad917aaf7a0ddfeb6f98ac708fec3607476cfb2dc23e17cd1a9581e6e61cb0b559b0f6fdaea3c8c3cacc9cf7516e891bcbecae1abd58af62005c921b8fc2733f827c2d00fe3b5f6ae6b7d187d135a87234de643c19a1da4a19cb0428c87dfbc4e2260be5d571360a95dad5d0e11561005447155e5acce0c551b26a7b255056df87fab5f4a3f824a99df3e2e54de268cdfc07bb6a228b07d3397fd69328a3e7734afcb0339371d24a93d76fdf75c724a747d1ddb6c8c00f3124e519af08ef09c497d16d9806db80e0879117f767e6adf56283f55e669facb47f142f1e5935e88e81576f86b3c61470cbe92d0985283b508eba261cea47362bbfe673c762efea17882f8fc6a77063b2cc25adba5681f1ffd4f58f831edefb26dcce2a23bcd03668425294660231b0ef4a1610041291ef79795eb900c31096fa04e396323d3f95cfe87e4efdaa4a5470ff4c1193ede1c22d1461bd459d1603fb15e6baf94dd462081a047cfa4c0d1d7eca3d51e2cd793b6af6accee81254cae0001e65daadd397612e7966b298369c524d6f58da26648fccb58b5eb0258da6abb33f1212befa823e2948efddc01de3b17ff60df0a5df6b353a71d28e095f7380d32c685a737c046498de46fe5d882b41265a003d8f98c7ee018b1b3a2d2feeaf43d73c7b0240d27e545a28aa0faeb67a5cda0297c07b209f1a99f56d5c344c8387bc979aa19ff74f1419c7ad18eb74a7cf403fc9ec4920ed4e5bd1bb949f4d51efce49f054e1d392d4dde73daaf816f3a7eddf52a821da5c4299fbaaf6924844f3c4e447a0eefe310c08a58e18bf2a332696d78c5b9e32df793028cd79c6b5d7043a491c8f3777e824cefa0f0d90c9c2b47b0e3f4b4f0493c4a6c3a75ef66c9f2ff057f1f7eb7e3538dc09b608473ba1a797f806843b15254b1251c9e6b0d5f1080048164eaaf764110116ba2d30f896718726c8b67591a1301dc84310887fe1b7202a3077dacf65bb1870932a530a883d2f07d49b36300c7db0fd450a4a625e891b8e56aeff2f154a4bb228ee6de86e462818ccf269ece2ef860673702722598a5fea33c45cc045af29c24fd3f308bae26d2cd351c4ca8569d12cfa4479606ae4d50b4afad57d9024c37710688db7b246e08ec8f2da8ed46f4c8c11bcc1e86a54758de6a69c072b278d9165671105b2981cacf53f220936959d35f5542b72e4db2c6c57c1b4048313fb2da7620f1312b1291e14344a1e99ca3c7c19ceb4cfc6c91b1d7e6307e4c0145d0f1a6c5d73d2acaa041f425b068ed80a1b3b7a0cb91f10f78a239a5b496c928a931e2673bb99fdd7dde39482ffd6617b41975abcc269c8860d6e2babe1612d2e2e3e9205933d03bba9ac546e968026af607430f0015febcd1db530cb6496447b1747fa16770b67528a40dd081a2f98f266c4d769eaf45e89dc4b3b714b4af768203d1e296ad8409b2324a47e38d84859efefe3556ae57506b0dac69423cc9b31d52e583f4cf23539b401e2f2c132939a655ea1314d0eab81c134e80e3e527269c3aa9527ce166080b3516e78d140272f86a1ef6e4efa35c2b0a89b4e4a1bba37f0c3cec64f9a0c49f136701e52f82cbab35fd2f69bf0998174bfabb26df707f7bc1703e95be706320fbbdd77780b8f05621ab830ed35f0d968e3b087461ffc2d6fb5351339b6c0f870ef3be58d9f201ab7b6fa8e9efb3f6818a675839eb8dbf4528a07f67a75c2d8191baa5c2913ed2ef039e5854fc9a98deb6e1e49e3f981d2c5bdb42cda452d60ae2b6c5d8ed15b6f1a731d04f4a526577b389d8294df3a602fdf6f99350a115344ea150e7888e5a6d28e76d0b818907bc7234dc8ac4ad69eb048829c3780e73e8dd61857271611e51521c41c218255bf69a72ea11292f405482a0c2864cd059bf45ced44894a79c680c91d3b47fea100225259ef35276eb2319f9a5383b140ada5ed149314c2c36028be3554696f6149035da79a8adb10e8d290045eb0c29659aee719ec463330ff03474d9ea7a50a7158c9a7c7b47791094ec73b3e932ed429e5f0e0b8ca1b5a44e1247c8658967875b02511d095f84196d30e1f4e5eaa254e3d91107f1b2d16a480689defd983785e6bda00d9e128ab0eacaf76abfd3a2f97fd70d1ea6382d9a5be44f349eed704de43cd6576fded099bd98d4f54a1ab7226f40d1a1108608230a158a62663b14c24a72c2a0d940dfd1bccb1ceb29b9d672e346639d11f5e11ca977239281265b907e5a1565ccb907aa6ae5859d98950e7cc6b470630829476def8fba2e21b536aa4b590067695bcf27e9d4587f822a42afd4986c5abb9aebc4b791b53545a337f6d6e2b9d76278c08acb12832b02b3ab16f889eab75d57bc6909d9995307230aa53a3efc77031b8a484b6f2ef5f18fa4bfbe187de8100ce415178cc23c95880d273b80180a9364e443ccc77bd90b517f3fd67bbc872f07c89aa2309246d1e5bebfc09239d2339a178ce82d59e67d548bca493c1542e159f86ac2f48ead1c9f7b8004bce4af664859d78118ca00350407d75bdf6c19533599e0a2621fa29ad218d40c83d15b2f2dc4314968876eb0d4705620534982e6b552b58efa68da9d12089030cc22773a9b921a56855ad8984d868f6bbc43035924cac80c8fcd88b48d651e2f46b8c73630e5968bcffe10db8a2c4abef9409eef665f9162a6e4b09121479e540aacc1c354d26d83afae590a40cdc4483290edeb7314b51f7849d16af4f19b701e4f20a09076ca6cbb634b6274ccdbb30d5c09b3dddb9264ef383ed2e91f565ebb5aef46a401ec2f683cb87a4fc8dc18837bf8202879ef8c1a1fa0971933de89e68237d1044bfb2fd9e98ddc8447c5ff95b865812a08db8ccef53980bcc2d235ead0737b9a203f60fe64db0d1cfd2983dc64f00cbacab4701b1da97356b3c00637eda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
