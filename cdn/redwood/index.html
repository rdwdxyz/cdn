<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55ab8a82ec171d2d5bb79da33eb5bc7bccc9566b6954ac14ebd98919ff8177a5b081ffa6c8a82362d7e4932cafddb7f6e2824a034980e240daa367e9da417db3be9583036c0e70f4d8bc16b1ab2e2d713bbfd5560cf19fd86f279f60d24eca15c2e341caa2f692ddb7aa27f931bb80cd54e69d4fb2fbe7a85ac11fd1ac09df6a3a9562831adbb8946f6b02a317257053ff50f648c5a453295505fdd96ce29c18b1c8642ee42388a01d7592408ec44ab5eba3d09a17b36437dea8a4ba91f5cd0776bbd4bfe70f0c65eb5d6c97ec97a013e908ff7652a3ea1432094f66e946fb57de558dfaa08556c64ea4fd75d4a9aaaba698d6b6621d8a89b89431c47074247d594f51d59c622e8d402a17e5b0855d249e47d22d056673f03b53556a5b0b39c3104c31767153e935c5e1e3536a077bf40bd8540866a2304d0aed6fd41052da987d112c7e4d550d758070db42902bbda74655e532a07742100aa90bcf311a4bdfae17cc78d36b54e05c5ef7901dc8d420a461029ccef862c7ab3a8e964049d781098442e164127336e5ebdc523ab900df5e4733cdcf90853280bf7d17ad5374cc5bee3396e955db318740293d5c0605d0813642df90b4e19b0dae4bd069ff53a8e47a91353df64cab422f51efde43d6de65b3953e1b05f2b55c4fe2d31993050ba1a286651a3d8783b00eb16c8d2489757f495de7c24c275dff17e5a094542f8be29a2fb06e6679bea09d2a312397a72e05d8d8c2077dcb6588a6be6642508a2598a7e829706b127e37a58dbdcd8eec5e326b8c2495fa0d8384a28d55b42fe16ed899c33b30dd94c20461013053b76a3909b52424f87ba5378f44abc7cb1c363be1525bda072d82ac8f44e6631d31bf02a62d3dda2a05698fceb296d8e2bb24fb2d845e66cf85e42b33a24fb2f23f8d0df13eba20a20dc8d9ee9b428ffccbef85dac661d5ada4ff9baf7eda519c266bdfa86422a181c0b843e9268fc2fcd8e558cae02abc447b7bcd5aa40ae046ded2b0e70cac100cb4082d11b8cb173fdbca7fb8a4dae389c444b81720f8e54111d1355f82c811c98bed80a80681493ddfe2790d9f962a723d8d640311fb57acc92ff6514afc9b00d7cab6951906fd874dbe257cc04290adfdf9c87033c9c72800854ac35b883793d957adfa920806e8f4fcdd01b14557894bba810285bd789ec3b6ecf1244587d3beb94fed73c5824b32f88862bc950dc78dd722eea510ad235503eb8318178240dc85bb052f7de569b946fdd66a74e019372d2466c422c7b2aec1311163f60c9872b628d25d669df4da61a5773f9cbfd5d97449ec74340ec0f4c55952d571e7c9a0a39ce6d104c80e42c8a438860fbba8210f7464546a223748f7e447d60b51ba345824eb2b9a38d33aba475bdb3220f6670dbb6db8f6f21f954a2427ace814c1f9906d2948d56f54cf0792a3fadff3888be8c7156e102a5cf0d026076e91d55571f64e72d68232e144a967ba1a457a5c2509a67900d305e76f8b5310380bd46ab6dadc42e8fee2124f764a6b1405ee844498c2c5876b1d148fa5499e384a610035d33a9f91a352f9b17da18f9ea840c17903c02d1a5cf3446ead56dc7e73de4fe70e5d47e42a1002e595575a12360e433765f155a02355924bb94c4ec265493fc55670e57afeb985e78df72cc401976f6d865a91e60dd40d252f85e8653272d006d0da195f0a63a279c305306293f85f62d9032537c9257ad88544bac8d4bd98400c47c40ae70d0ea3cbc49bf14ef2741a6f678b9fa56a7a87de326269f801f25f5f6c246a02a47ccea36793ccda15d00406b2b9beb202fc3231128eebce73b63982c49a4ee38fe95e724a2ccc01aae980b83be8a743eb082da7681fa1105c21570e588213092cb28e71c2869e773648feb383f0b014072fe66c6e221470834db509a3c6802cb1c7cf5af9a4fac4748653bd62c05c9081556ee6e6e757dc2bdac92da43b204f6bff52ab2aa402aec9c99ef4b866233ed6489effbc109b2f189e5aee649996f0f468adb31f43a267031f30a4c21217738e33a56f8c6aeaf44e50f338276e9241ae7e4a5b0d43e091bd46248305d008079ea9e17da1780983aded9089dbb4fd53e14aaa72ae97190b09a714542444967137a1246121379ae94b0c9bcbb70869344ca4710cec3f5fd1b561707b559cb842412f7260549252dfa41d8911f1a1ae04cd49456b63c4804d353e29568d4c74c2e8f13371a6bace4c161e40458a908d8092fce31c77f95cdeec47c270bf29f0c3882ad8198871de146e23f087d706976a7ed55c221bd9b9bae01994287c4ea0571760c3b3400229bd88f3815d533af7d50c1111bbb042673cc34220dc12b8a8624425bb4d2e070647d32a88b0f2e437632a8015933bee69ec59e7d88a9c78776700a7c08a4ae031cf88b86354ffd7bd477e52c3f9bcbd4ae041edc3efd9ae47788bb49eb2c1676a4669ade1c3e7de9dbead70d83dedb7f21bcc7b617d77fd63a493bf2a37730420ac692a3b6034b802b3fe13f3be067c68d178ab3f112e45cb9af3e80f5327869b6f1c10a7766f3b6f37e3812ccd0085db7262594b8fa586b2e944899ef7fbd706b3811b7b7a3ce955f453c31575343ff4da8b4c231ca84879565194ca19e33aece9b188b37b841645366fd74c8c92960c8054e207af29de9ae761df5755390d27295897122328212e6c6b139ec66903b55cb3f798435634e0d591fc2b826810f7dd6e23f3a3c0b6d1eb8021d851268a5c1432d8ad167d42d97b1e93b1122edea12f41913e7c801920cb5ff9714918b308ed6189e8d3f203cede2eec700294a141bbd080e63d0fb238e0a65f7350ba4c43b96f119ed971e8286c0540aabbf2cc0cbdc15b4fb059c7ce9d83e621fc17ab3c39c7ae923ba8c9c0db5d4825311396b35a7115a38356f9bc60e7ce7208caec8b3ae7d0e924aad4c7fcc2b4f6fb223dd0fddbd103fce43ec8d85b1d011288ddfeaa94b5afa43016d00c7a8bc6626be060a17fe704542418dfcc941d2c37f7b7da1558ee356b1253cbdb3e1b5059ee231491945a4db5236c86c3237ff8f316adc9f082bc4a87867e83c3ae0fdf58b08f67778049c2fc315e06f4974cdbd52d37c01ba7fe25df7552506d10052db3c4600cbe21327b0736f2e841b189bdad2e1874157abdf73417f7cd8bca5fcd882474d9a877a714afae067934e043ef80e658ef53e79108310a8596639da931463b2d6fb539b619970a1a19600b986a62a55d9f3061970f2e5b525229245f1330ebc65d3a5bfb655d0e5ffa93964adef1bfaa5837452a53d7d4f9812cf5a363b5d3be2dd4b14b9eb8372fe332c9454243505e8df7cb6f189398286a8c5f13f8c94e13951a0f15f191cdc645747d108856e25045836c405f770fc2b94547eda5c388b06479c14766237b3d287c3b087fd2397e38e5c22b6d92ca2b51e09a8c3fa983515e1e92d36aa24fad186c23f808668825c54589c2949b84edd57687c7ec4c33b21c2c654929f6b8291e3597d6ff25f67c55abc10c4940cefee66beb95342915a019956d771e877f1844f9baea5550a55ac5913b46bee37c728521facf6dae6e648e6c71b838f4df7da5fec3900781c1fa508f35ea51d1a30e7b5bc945405c330b6455c09253ae9d25d6d3fbe1a0c59c12f5433cb478ea8f7c5cb4425a90bd46898f9b45e8a609195f28069a7837f3a41c9aa079e5981c67249e8acc3b3a9562e5c01e791e1619673feb63b511af89906e7d5b9e8f6c2779cba1214264451f9adae7e3cc4535026ecafaacc422ae11d77695cde0e4609185426be922476c5a7a985b7f3d13051f46217d3264fa7669d6c8ce29e44ac08adbefedbc7631f2c4ba9ede07a8ca2cb0f50ec0a5772cf4862bc1d0e3649380507fcddbd54498dda374e18b31a816db76bddfbf815de29546ac8ffff060ba202be9ec632e684dac38b1059481dd5d153a46e46609b1e12f5f4421309dc8a2c7e6c190d4f6fa88fcffa6741725a562b717c718ea9c29dbdb5e5d1ede945734455398f50269d5e076adf48d6cbc5a40905734e37c8bf17443617c022aed0ff41fe5c80b0d99cb1a3bc0bd61478bb99e4cefb74384eb9a52089e1b1763e688316558f93abceb9eea68a2f28d6c6ac82cd6d9696f257a037fbb2383f6fdbe5687be2aad14c3765eb67d29d98a7ea1a04bd893850ad6db936583ec8f05fb2a4ac9b1a25072d862e8bbcef42bdcccc20ff4abc427c75090e98dfcc6d90df2c7ceda9026c61d4b5fbd69bcc8fa1588e8d32b57039622b3e2b3bf97d86cd54c2ee3204d1c799a578cb938c1da9b7cb58129f5c552df5c0dd3af8249b754e1db106dadff1075022710223a01035ea3daf7b3c3d43480f9dac75b7bc8bee12792e40fa85aafc430262f25c6bad0fdd6a2b3802f7858ac83aeda936ee0c0168bf140f1d6aaabe633115e7a9715ace4c02d7c0b954e9f3ab06c7556191da2d0efff30001d4983bcd105e06e2b63a20dce65d695aedd858a812bc738db0469430f91ba541001efd0cf700a3b8fb3236d90b266b3d90285d1ce58cb2760293e57a40ef4e438dbe20bce4d4adb9221b1492c084cb643cc46b306cdd5233d4062dd78412d5a03db3a91d4e451630bc843f29357ab4d89174f1f7f27b7661f0b4a0005ebd0bd1f4030c78a01e380efc219fe7f0cf5a5c0d7f859b73c1a7b68b82388711e627605eb5e021bccdb29c51349ddd05726ee089c19d9b76baba2cf390c8c2dd869f36058641f2400fe6a4009cc75c53c3bf82c602840f04138e1b0f9e69ca6477df33314062ad3ac67379039bafeeb2e626551fa9f37ae639c86d6e3a59c2a195c8b66910adeb593e73f70d6a6024917266d197e571e008be36cd9f538d5afc222c91991406b775f58bc9b89c25bd719258276befcd25d267abd0d5601260630eb9f0c782dab570783472a58bf7803cc1219a28210c0df6831c26e648e6b15f83a6df61c773e0c278e73a858425c32c0148c86404334451107635eeabb8bc612114e701f58a7aac9c9b119f55c10d140872da7dcf4aff05b5ce45373e8bb83e49956153afb4af6807484d51f75fb69f6a8789a4e5ea08fe0775f3afaa17f87ce7da4ea1fe3f6f77252f99adc072f09d08bd4b0a494079dfe2ab3e29febf79fcaf56cfc01aa559101f27209985ab3bfec0af205ec16cff2206f11ed24e938384c1ae6d6417342dff88963f0b129b8e6cb32ae229274ee2f265da5cf3f18ed338c78dbd9466f145ff14cfbc4c56e940bd836d09dc7d4612cd1c1673cbb5ae464cfbf00edc192c150b6964fbca803ea3e883b33dde8e48ef5e66721d24a96c2fa42911604a8f0ecb1db28c9575dc43fd838cc51c3b8b015135efb5d7690ee041ce725291244fb03e66a74227230ea365aee5f1843f5b544efb7b5c072d03a3c4cb65f2b512b646aeaccfe77388b2a39fce2681e6234db889ce6f4e168fb16b97e1f8c96c24225f3585b01a4f950d05da3d75c2e34900404eb0cba50cf08c48d416fd16933f238c7986ca61402d3327cb14ec798f600b3473ea119c4be25bf713a72dd1843d75804c35946cab52c4a200fca410fc9f0c6ac0b2fb5bf7fbb4570c979be2b1f3c8454beae0beb8c1d6e04e8817802de6fe237d74725891c9a2756aea0ab2b0b1233b11af02a174076ab309c42e57abcb3f85122c8715f29fdf44d60927e912468ac6680f3d5bc894ece962704afac3a56797c308ddfe879eb7203960add00d5eb7f69d2223ed6a34630692ae57de6a482d0e2f6541d762d27279e784f23b29c2e518db80688159d5feb9d47afd20a7078c671eb3a1aca32be3ebae97d1c43bc74a9700337a795378429f3484a3cc6036444b8050122f5bff2744f275db985bd02d47814e9230395655497cc7db75bbe0aa32036cb3d04f3e6de99a1aa478b5d1c5eb9a8e3fb9303fa6c52f4961e575ad0317defb645d297af5a507e263795e7a6c2a4c01412e6a80f0be263caa917c14f47be07a3cf800acbdb46a47351305c78cfff2b1f6dfbc14fba380c573548801444ad62987b59b28606dc782f46933aede7b8786e9805e52964d6edea337575f343f1a8f1746a663184259a2b2d029735561f2c0e386e8d926dfe9c9899a321793bb9a1e8b7691e05303319ff54e3871abf1bd0d44d2264d44d336c6b6215e11718c4271e0cc0bea593f1deb45ceca09ce2351f1f3e488848492194b23f3d84c792ab0fd41c3c31d4c01b97519806c37866be9b038d2595d954d4285eeff8eded6342efb2a3296639d354d05c47d69a4aa747d71632f0625ca93e07fb44455e155991c31621b01495ec59a20c7652962e1e8c2c8c8b6f1cdc595455e3a50d16abf7015d9a9633848e556ceef676b75651400a59eb9d833f1ca80ad3f9b89452315c4867f6b834912a469c7b0a9164c5ec510d215563110e7c5c7835a37ab80d5cd758922fdf167036c3fd2ced12fdf682375fc695f6565d2cc06e40d828073f633f9a4e823daab1e1d49ed9601da668a971f838566b22a214c55254baed19c61c77a5f1fedb1f5a5e93cc9a8896a0e91f5204a800a4991569e9e2b995b81ae8341e97abd19c1b3bcee4b3f9e071781272026a04e78d14e39815217be98de4091e1daa50fdde624589aba6d5c5bce2dd23828a534e5ed2e791362ebb776062e93407f90ace42d0440a86201489e1a42a96dec99d422688077fd1d2c7473f3955862677719ff7bf4d1cbdd23297c2db776e1b659b53f811467b9a07d3472a6f1bb29683693b5614c9cb07e668027f051bb0df99184512b7464750c1f47b3118dcd198ba8e4d11ffa952126d67656798a545cf3d63b3bf3f0bb3ab3d92894ccaac5d6853abdd0c36937b3f1e0c814b76d309c765efe8c4f8d15e465347d9b160a9506b15b177616e675698e27c20ed750fae0aa3f7016299cf9e978de3375f83f08aa73d137c163eda67499add13f9422137ba13758986a9ce6a631d025c09d526f7aa5f4b21247c2463d79be50d99b5ef9a4714e44d07a9b0ffc83d6a3a63c51e42c81e9b4f00f69f4590ac71bf522ee53ded00d8edfa907a7d770d51b0fa428e006524e8e894a70219731bf1cdfd2f1494fed300d1ba74f0cdfeb378feaa41e2ba42da2258b3237006e69689655efaef3e41ed3b82fb48c4accab7d5d527e36572b5c06acbedf16a976ed590f5a326e557de3f481bc76bcfd6c2b66649a536daa313b988132eb5d5754652efe231d4b3a6b2f7777ae53217b68008eb1389802381df5d67da0ea59fc3761a1d262468e4c547a752a31e1275c00e27a8a412b506fc244bb781cd369406cb0ec8ca332bdd0642bacbb62d6d5c2ee2de7fe0e8d3d63bd9b9e8b6a0ba5f9217ad5ed589f981dcb4ab100183ed4127330a241838cb14a9726c0857fa8bfdd804c9d4afe07c17700c3eb789026ea88ae4350117188814ad3ca9666d2082be62e1fb1b4f2a812ef2d76994815388d0c4611fdb125e4497ba96566fb8381719795c428d17197207289178fed69ba4d756a78d2a1b350d657818ded03902c34684c8481588ac67bc65df3c8fddb266b7769ef67a11abb6e2a76fd0ca58478fa968eb0d97a52b2ecd795d12dd373995c394de03a44e8bb5eb6e80b71f1e291eb5554ae1cdf93721410cd0838161552f95aa3e67bead6af1cf1383f8e304da2d5f0a3133b1f4970f17709af93222fc9c5e31eeb47be870e4e2e1689cb88c26c3739ac961f86f60c8d4b6755b8b4e408d809500c8533e52c3553d8dfa601d79dd680ee85f0d2e3b732f4995b454ab1406b4a598ff748f8f3fbbbd0a3308f1951a946ae0eb4e2fd89698b10e15367d1f4f54a7904155a0aeabe7956b66007bd6eafbc181a4896551b6d950be1613013e7a513d94fe658a1d4f6d29d43232a986bd663e7a086ae77a59b76b22f1c063d9644d017aab4c9f4deeb79d878588f857554677f924eebd33698533ce9422d3149e893389b214f557fc17a5cea1f1e52b754e40aa004cd4b25c59db6e48dd91e3bed1bc3d29db2782b07b3bf5c438acddfa206adee3b7a3456f1406825d20bf21d7276a13f3f8ac495783a7b12ba2c0ccd67bd227327c0ce1043fe6e307bad6cc6860ddb62409c67f3d345bc8ecdcbf31674bb2c6504d2668b3a983e402a62510ace4704c3c788b345fbf6946b17afb2c0328f902cd2bf567896e85c2dd68707ef71cb3a7829832695158a4a8fe003c9711985ffa775040570cc2265a0d04f2113ed39faa23d0a14f9806d1dc54fd9f7ab918ab82dccd9e3c1f70e9b4b09be90d884b2fe82f0e1a8a5d1dbe078d5131adfbed7a9549f30b2e90ad92c9af124853a23e385aaf7c2a72e144426d2d8ca3a34f4b0842b0c632169a854371a4e727e05526117c4e6fe1885700a7441616c07600ed73dda965cb081a38f19e24d9dc67d17bb95d417db13a63e6d4fcfd87cb056f3ac785df76ddfdd623884c3e995cd8d774713241b16bd8971ca72ff72107f7b2fdb4ed20c5163c3fc1d5d083723825121c97a1807959dff46c6e99e47242658b182a010579451102e878a3820da1ab228e3f5c1d2b0be1c0bd8a4f4f4f1fa1e55f2dd64636ab69a6a3c69875ab0ee2204f208f30135322456e387094e2cb6b493a1217ed7b44b89d7426d84c5690719a3da9307c7a1a2e0a8a8e39e3e35696835c78bc35a51a9940971f00ce35e9e8ac5c39d8b36da0a75590257fba6fb3b6715b70d3cb20b1c8558a56d813cc0b64dcc2643eea794fd84fff139d317b5cbd357f8a12f09b3b1141116dc6918749fb4e73884d374a50e76ad8e739ae1df37f9179f23a6cb84bc8e7c327b6e01fb4bc4cf1aa1f181842498701f0b5d8737069353d608aac7299a9aa31dda5c33df81e7d75aab86a05d046c3bf1effc7f4f778c1dc8151a0711a9d1e44e5e7f6dc271ed9d07ad431f04014370ba3947004cb7f92e5163036ce2b4690285129fc0a0dd8eed39e79a8cf84dd5fa4a3aadaa42a0aa7a6fb1f59e55d979eb2e5ca446a05623e96675cf47ee79c796f59beb0c03257b702e64ac490f917e799f99967334614cd8d54a13ee4c553d21979e59b2ce76285eb3d8b47fdbd5101b503df1f4092cc8e5626d70c4a01aceac6d55625c14905a82989eeea85d515197b73074af48b803e04a6702d412d2ad89e12428c5248321416572e990d40867a3f8616dfde58de77070b7fb39f681e1e14d9f513733b68b834ebe7b06ec415fe5b42c02957d459bc4c8ae7d44377f56aadb45f36ec1557af6affd839e18db920b8f9a9d6c24a39c1312cbfa2593c2415a7491bc51e9e3b18abae79b551c68274c41b9e37357c315fe21edf4708ab0a0f40d3ae4fcdd4f3dbc441f7ab7ae189e3b1b3531d416fdc94d722666a3e7e7baef0e6db055e052db9f049c92137a95aadecdb68823338f39ba25314a8ad9715572e5d955ac122538df3d0c75fa1c5861902e30369017a80f0b4870ccd8a6c6c77ef2adb50cc45aafcd716053f51a9f22e7b267ec6382f4a5e9328981bb4c7f15c8175fa941d4b101c1cc2a72f9e5f75f03e494440fa744f2ea10e85ca5719e76e079a552f5c5a0b4401d01d0fd12a26ae4db3fe3f976e2eaed90e26a47d27d732da7f45fd8dac0f2f11f90a2aaa5c7943109762b33da747b2161aa3f73b6e16140dbe8341055311e6a734bad500d08bb9edea2055d1e55b9912b9ea607cb01ae43a718a6e5807eb41e32772e6e999f87968ae8bf0fda2328f2816b6bd21d38a3af738d734771fab917c1493ccf0366b4a3407ead63089a8366338e48e9d350be2d92ac69dd49c3b084e8d7407ca78fbbcdc42c8c7ccf7db0e0547706a79bfb05b5b3bebbe4649ca3e6bf837eb4cc26363c52e84d45dede90f308f075701b7971541a5031bca4bc88ce38c76ca8cce83d3110c4a84930abef0c84e0354457e9e1dc5eae1615c643b0bf61361acc4ddc4d79c0b0feb58c746596d69f172e37b21275d37669375e4e8de366caf551e79b0de0768056097cfa7d68776c6e3c23d5ed97b93b8e9fdd2741c26d8e3e9805d320b33ea7e079f0f276a56f238825f17da1bf9af5c75957a4ec948942886ab9f4f4a6c68d257e9adb151f554074ac4193b0a12713c314895a68b6c12f3d860f643c394a58b40ce9a6fcee40a0da607a9c4f029f5aae755fe70efb9cb9bfc1b529335235fca62b32df4e69761322d546b431eb50d014db12fb54c740f779c4ac661260077dce4dbe8864a20ad308ca9be6637157f89c57950075faf02e97475a7d1da110a44104cb9283bd864ce4ea28f8f8726e9a14c0b9500154a2d2b0be31c2781e62bdd7906c11652d9c86fd5558f514bbe6956b975e09e74dbefc11cec662bc78fe2f8d8ae9d4d11dce1a61344a41437768226d39dd2c3df62ba7c6f8736d1a6667ef5ccfea6ab00a9870fc6e628e6a9b78ca690b97a9d2cdb1bdc32dff00a85de3843f3e2dc5d76c9673856403c9d54f0a6910f461165be641d5187932d9efcee97705bd762e89d7135fca2e7adce7ad6044216b5e03ecec063875f3901cd8be0210b284d5c2df6fb7a647c8c970672828fc17e9b4d0dbdda6959f1fb989512ed95e999b69df27492f3c170cf0b75666d6b258ed3db66183dd321e395514154bc7d08919703829c219dc320dead83697157f7401d6b85c57cfa6ff46222305cc6102d8b0355046a4c7d4e9111d6c09a77d54be06ecfd3502ebc4abdb07032dfd8ee1512d01ba596f8adc18182dba795ebf4fafc0b6daed9480aff26ffb6f0670a59f9c74bd27eac316b986b733cc4296d24bba2dc32fb12a3b21aee645fe7fcf2d0e62a306a2159944fc9e7c74d97f4a705badec46388a6cf242d3b5859b75d5e8b095527e1cc9e446c010c18880c6cb5ec3a37a199946abef3411fb12203e4c47f57807b3228833e1ceaee4a8e6564c090ef4262dd38e02d1f79aa03788f1f931cb136cdc04b8ee7ad799af9eefe36963a01482c755c2c69e8270054d6097d83b3e31fcb20753a81c87380bca1d06572f27d2b46cadee9a6937975dd9fb9646ab59c9476678db6fa1e7f6af25035591e26776dea3416b55a2e7b516fa311a997ed41c3f821a46a55c0f3010fc18b0a90f209c2ec1e746761b26212c9f9a4133cdb50ce3fba194a6e192fcd5d128643e7d186f3a3d333cca900616faf95ca408e2abbf9eb81aea70fffb17d24c1f037c3064e3d78c47ccfee74515c1d6adc29227063c729137c13294ecaa3d7988a726172847d9a48d4aef4952b2ebca016952e3c05b18069dec0d917d63fc395227bfe074d835c77ae996dbef805ab29fc6f2eb65f03640e99de71003363ea271ceea0eaff89c5addeef4ee6c0d029067fed97610ec73083c68cffb2cc579fd57200eb8fbe399840362fb52b293b3cb4c04949b235c15c46de3703cd90817fc245058a12dbe89f09d847f82dcfb4aa4561678f6262e0927fd9ca407aa72f8026ae54f12364a8bf4c2f844da90a37defae3bd8c410f82be25e78b91291c620c256e627ac66e21024ce33b294decde232f82950e7cae56be130c1625922a09c99456865e0749fbe333046f4a9633359ce82a365fbcf810badc7d0d608021d4955ef26abd5991f016ff0e2b08a37bb95d59cd708253d24d5b01a59049cc69f77a8063ef88f10edca4a870e63d8d82cadef8cc4d81d3698295056b69520caba39e05974666b185db927a964a5857d84e687b8e74a73bdf377b9e29318755aab7b3fc6c932e566a4b964f606e6496db26f1f7b26e15d1bf079980302155df9086d0f114351f39d49bf6e0c3f68cd2f5444980b36646615112288a12f588e8c20266323060370495472d4146fd2b8e5ff8ecf4a3edcfc68d52e5df933d7a67808a45433dbe60ad79aef1029ce3d02074c40667a803a2900dd22438c78cec21a243fd2c69e93aa7a9b6c417af8ba514a71383b934173a3e762d42214883685d14a0f9a36f4445198bf8e336602b70aa9aad1ed893b35df017e9fc7e50d219a221fea9276052192d9a522c2f10887f77e724b2ba3d56f7f114fa754889b17a3f2c21c5953436ba700366c1ae69660340ca71641b4d823d6d9756f109334e71df9fb16f8c1ee4a6866caf59af94661a471c51a0c36efde7b2b0ad51a48afc7dd35b37f6d2dc6e53e0b9978f24fc958d939e596b67143dd3f5bf8ff856d7945bd703b3d9b587b9f8e6d3ffc8aa1b2856a080e90766feb2d4d003cb704dafa4787569cc1df6ad179aae9d7ddd6d03efca319b611ebaaad702daf12a044f7504b576dcdf0d284210c00fb5167965f9842097a01e47981eea0980021988cad053de867cac538c65ffde465307dae24d38863361cc01c4848587c3281c099931e586b7db3e47822b1611fe0a15e347f48fc2a144981751ecb2ff35687f47d20a6c01a097e55448aae9b446376112e770aed4e2e8f06ffe15add0f31eee23f2b9b17ea27f320f57edf4763f9d8450dfe7d424f8b401080978a03dec6baaeb1f22b63eb12942765a64c57d10492faa05b3891b345303968d4cb4b3f64193218234ee422fe88958234c586dda9f5d316bc18602e8a05f3f754a9b125d60e09f5025d1b6ab6a5872d114d2b6e5d39e76c4d547cbf5f227904de804dd4997662b59f4f25ac6f1d85f99fc98252b4e51c2926b2f78e879a00b1426a50b7fe7bef4bf7f939633873338dab35724760b589110347b795d0babcb25aaf3839eac6d7bdff89e9c22823d36a6f6a454c8642fe50dad903b6111fba6c0f024d6ae360d474d256965f3a4563fb1e3250ff1fa50c651fc2e7082a9a5e37ccbc0ed2e719d5372aad32171844d8c1f8a8e40789f9dd5e6d4f39cf16279c877225779567c1b020e894492a393b497a38ed04b263d7ec5d5449c8f612d8db1a43f85b14f22c4c247125cf7bfe7196c8c72371cf802a9822015235f2a8c54ccda4f221009c9a73ed88e943da45c59902e5fee3dae3540bdfe749ae2cb6e3e2fecea86b5ef4ae2a19b9ce151a4d6115302c5b2d94ef6f8fe812f31a2d6c2bc1755ba7a76eaabd0a38d8b6a6e0c14bfdb9dda3684d7a824a74e2e60084a3de94c7030fecf0be05523bc20a089d2ca05ccc1f332d0a755635f7b3b489f500e089a84b91d8da02de643f90371b2fdd0e15ad319a86d7a1c0a696e139197a1fe7910773e5930790c6e396ce5084c2f0881b72a8a8192fa64c6195b2047e0dece0f7a43f73e06354457b401f9c9ced2cac8d7ca5bc08f045b4541e318858ed61c51a911a7903facbbe6ddd598719b0853f00267244e28019ed99a3e8d2f8e46844fb39e5c0e6f4795fba23523b5a4ca0e9080c89a9c93c40af1f7e1ebba9e05ddee78e562ccc7431ee3d80e46663fb50c7957f630b2afc42a5ea3ba712a0bd601240e0603e8fbf60a6b09ab95ee08a102e176c25aecb6ecb786dbb6b161f49273ed3f8f984e7494a0893626b205fa9bf98c5c074a3f12e633ede5870902c09b484bd142a95386822b9d9107b9eed7c476032b60114a823294507f02e377bf2b03586edf2784e1f67b83fcf9819c77f30eda17cb4b772d5495d55e82e1ee2a37cf57751073e526674993a0f859f07bd241498b903e6d4ca4303076c7d0ef6c1aaa1816c59fc1de227f710e936deb550b6a98ab1a4b92ffa12d65ae2df4e010a56a4e13bafdc30dfeeac95485f69371b4ff069caa5d2109322a06a5dad9c7d398ea4c6986ba49f1c1f1267d5105841c6ea0f3dc0197ca8feb07343107e4ce05f6935c0b5ad7e2d266e27aea052c397c2de56bf4467017b0bdff666b3c871ab04c02ee682ea14b7f614bf79c9fb42a4c0b92a94b99f9440a5e7555a31b6d0918dae66aec7c0ee3173f74ac6ecbc4f3868b8ceb178f38618e42e9571e77273e998ebabb5772968677a1d1c5c8785f895ec0221af0bf6c22e2d1fac50dcb381f601441bd6f47138d07d59183cdf30ad4c61743127dc1f8c7d3983ef9f2d8221a86c916a66dffc32cdc48ca5ca0bf39e8403bed731d35360a8d0e1086cede03515e29b510a1e906654dc0a499931067118ec5b4e0ccb8d833aa70e659d582810a815729bcdae21f156acd721701a9b732a7c35f9d3f8ab7adea371b76c9e6d3c1afca4221b77d8df94dff507213b670ff8724934d14fbc78b7829c5fd562ca5784257ce9590fe87357944bc4d0ac9243568de69dd06fa56bf8a30cd1c34c85588dd660465d99241d3b9689f95fece3b50eb6d5aad1aaf3821cfcb4c729cd073df2fbb922e919988893202064e03db09fe7ba0e2c2fa59c0a577c73067f6058540a9895efa621ea3e66d851e6b41c9c698980973a07a195821ceaf81102ac94be3dc38019d8db0b0f4dd6bba8d0f4b8915ed084e41f49f9c41c5cb67c31b83b04894c4fdf251d738f568e09a9237e006775c794f2b526ccf705b063d98a6d67060f634b91b842b5fe7c799d1249cd44b8ad0534d55285b63bc5d1ddff76768f7bf29b2af71a0985c24a08fa4171593d34da71f6eeefcc99862f9c4b4b54003e8bab85a280c77f2abb6a158ad232da7552b48cc12da54975752ee45b37f8851ed424bdff641f9d32cfa70b67ec14ed64e4c7242b487af3fea80c790dfbb648f83e0b2d19e44bda813ec9e85610b2f9d4ccb01a28d07771b9c05b278fe2c9ec771564384960b30eb75e28202db6904acc779874494c29e8b2634306804be89140f9d5c06782f99f74f69d2e231b7234f469bb7f49ddb0a49dbdda6f599f1cf839afadb650fcdbd3be8b47030858e06bfbd8334f2b55781fc0149352c391cdeb4278b238261172f251e6fd57cf14211546de8da6ef1f1318ac876197b838550bd1b9ca0a6f47db81a28cd371f19b1b023c37544fc293ff5d5686ec5e0f6223d0054fb718f0b6244a628fd041ff86a1def042daeb09a0963524854a41feacff9bff5945b9a2bd71ae109dad7f13dee52a0218f5cc5ed3ddbc519f09b81471c35d43ba96a6a4911e4849e8a42fc9af2cec3e97cb9adaa569012a69405a6e7a19027dd23aea145a8d097e35ae7d8fb66f0338c91937ef70d393cfd81064fa0d3b3910e59af49350942e4f428612bbe5b781518b14081e3a4747cd0f84f1aebb7e5fecdeec163f9e4e516cea86f924756791017342480d27d7637603de1af484825eb6af60a91c9f26e73fc43dc9f88a031bf51afae46c1e2bd56b7b18f3b40fcd96807cd260a611f6fe474555c43e645408b014ded4955229a278c415659124e33a473f905dcadedb4a159f23bc3fe4292673ea61346bb0acd0ca9af22c07441903e4924871854286f6def7b0c44919e716bb527e3ea93288d74e04563a355531835db96fe2b362a31108e38f683ebd5af7df109d301e8e71689172b9b0d4e9220760786db6d6371879fc0c408e6dcb3e255ce19d61a78397590d91f4fd90dbc97b61a1ddef1c7fa007149ef00568c0817bf4238ffc17ddf1d5755ee223f9455a3a63b9af19c159be415a2b327eab2c5e0f06fbd37ceb80830c0019f85a63bbca057d8f3aa4e47be5e64e8b28818674d64d47ddb70765f12c5b795f69b43e015e82280190fe07fd5e15c1f5ce8abedeffbfd9aa17107a72f6a629a90aca3e65790fdce0ae79b33132ac26a67e6c13ba5a39453f455adedfe77b0b6807ad5aa21aa1dc693b4160b59113edafc323417bd47dd354e9512f73f7f8c749ea13929ffb27248a98fa02e2f5b9881202579f04189c43a960fc469ed625022885154d1e34b948c1de3fcac58f39790a3492e48394038672acf0dd3c73fb3f6a9188c56255f56a4e15d065eb06c3b37e9d5f539d38e56748012af84071e45bcf2ff26fc09b6152a7ae3075eaa58bf003b7d69b982644f4006bdee968a2043fddc1facb39d45dd3e6efdc97dbd83e5a68dcc1a5049fb167735113635bfbcf304b02ba3e51b14e3c5dd9785ae68d64605b033cf686ea4f95d88ad4addf274417c5b612ebdbbb724b7f60df85a4be6a285f0c2957721057186a3ae8df5d157eb8ca0ad8e96cbfa97fccd76e4fd9d90f9df5346c52aa9e90c10b4e44c871c12f161724254cd63bdde91d794e3bcf72d657aacc9d502cfdb1dd7cf5466d915d18922aae5a31da7535ff40565e67cfd8f5d71e5b2d2aa5912ca09271fb194f9ee3db33e5088819e1937d4bb619e6b2e0c9babf919dd3aa460f6a0c3bf009a5b41a90fa15b256d9ad3c17c01d47811988aa87eae25ff4eb3c4451bf0ef7d109869f3f7ddaa6339b8876ccd8c5ad0b276290a0d69746df020a8c92b3dedbb81576570bc8f7aeb37be860825ebf15c8bae0b72ca4f8617264f3aee61b0832871dfb06503c707322986ddfcbe58481be63192cd78565acc9230d351b78b3b64eff5ac69036f108b46fbee60d4cf2e260d12bb70a0856a1bdc717008967e25b69f84f7875159b055b5b4caa3498fcdaaae90b1f828d4f484f601c9057d8aaee150311dbd4c30bd1c5231ed52a398d70fd28a638a090f05fbeb30cfd57342dfbd4d7bb5ef9cc0e52daa4d1c8f2ff060e9d60fd4e72a1df7057a979277eb7bf0b7bfdb52ca2585f1601776ecbef98b8c3b074e8fd9fa032a29fd9cf2347a95e16c10c8e94afcc782e2f7989dcabe058ad74cae8fbf2238e784e3835a1fb0e3408103bd679709ba3d1b53d63b0a1f1406b1f4a5d54b0a52f1b71feb11054ba98abf65fbf3804934d89fa453540687747cc38827534763163bbbfa104a5f60d64dcfafcbec77d7e2fa1cf65d8154910511ec80dabcfab42f9307ba4eac5dfaaba8fc10040f070a0729597af8f33c5b626e4455bf53b0f45e835dd10dc93fd9f2a152591f4f590ce4e3d4a8008f2c3f299ef01d46f836b86f45a2d31c3e8ed12b4662aab6bf3a084c5c0a1d6c6b9da2301e86d9fd2bd87a8e294ac8fd47156db04a7e9160a5f6b9943e4d63c3ef16a79fd2b45dad77e5fbe861e9d2ee39c7953c6c89c3675693d5af04dd4e35d6dbd8d79ea1b7d11da9bcf730a52a2653c0dbd7192b708e0ba38fd30f5d4c23d940c5befd6ccf6981b8f0642862c59c423852c6222168ed0507bb3153e017bd4d784e8ce82470fdd5a7dedb1bdaad6e327a3f53cb418b01466e8ba28446085267a7bfed626b4e6a8bbb070678a5d708a6401d0715f24bc74459a8651724485b871d4a2dff79c2cb0ba3ef92df5de02d4ce5a9f5b251ab91373d9d3209aa487609fd894ed67ac731d07d899af9eb34ec100cc7fa184ae5c2941a0ed2993bcd2d8ac4a07e742e68ae1e8defaac2aeccfc578029590e582e92fccb10882a04ea763461f05c557a961adbe1e7b9e510852eef55471157fafcadf0fa2eee49ad334ef96a23e01747d582cfd55a418410f010b212ec1d5d0c0318105f8052943579d9a5257ecad03ca51fe84fb3c22762d583313fc213f29de22b25ee75cfe7c969c12ae87fddf1ede23b00b45bf1177a6cee5806f3ae5c635aab3939bc97197ccc82e26bb1c56f26eef65bc4fc627c3465981d51a918f1ead4b99a89ebd97624fe3b31c8d6656b6b2bd328489183bd48117c089664aa6fb9bf08e7308b6c9b8ecc0460ee47a3804a17f805655e00d509db755dc2483b065081cef1c172e46cf9a9683f8ac3195a370f148c7e0f5c52dbd4cc7f7dcafc261e8d0a98861cfac321acd49ea982efa2ec5eafc96927dfe3a7eaa9712d9d7b7141996084bfcd6456a3311c887d685ce4326e51e137e4a5f8ec37b85883542242bdf5c20da45a1fe195eefe33192bc3ba431a6fec1d53e7422888a54805b8f673873ed9356203ac98cd2394aaacfa341777e7bf32c4c2066a0fdd90de25f9df85f9b7d25667a99d1f1de907d835a146947bacba9f9db5486037a6f800724cd3a9d0c715730b38a8403c0df564d6a467ba33372ca4caa5bae7589518aae634fe898c818bb8627e688b23fa384e559324ca04a22a70cb7780243d78a4589d4458ebec3ef02805b09a82745ef30295752f59ddb05406be2b16b4639cce321b9d8372075e9e7b619cbf8ca4df95dd9ea7b25446d086","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
