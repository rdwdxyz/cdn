<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"97c7834eb6380262f316f0831137f30e88e473dab968eb0caf42f5e9e3dbdab82185e2390eeae8657f4b0a8b13ae6e6e82d73c416eec2326a40c918a34705720b2b498905171bfb8653d226144b91c3a99ee7ed60acffef505e968647d1320df74b0d58b915e9433afdee1951c434ed8c4347fcf1c530030ccd072be12b8f8b3b74f9df4f67739a4a85aa257ee8ee3de5183a8193448d67f84950bbf7e464190f07ae528dea31b9e609e3fcfc236050279fd1b668518052470e72e8449065f94bc97ac28ab7611b2b0df1ef3f8ef340bf5366fee9c5b6328afdf82f97ee6774c65e753e1ec60ad251c93f5faa859e0f876c538c42c0d758d03b7c258e3a342e330c423276dca2a979d5b5fc8cec2bfa7666a5e7ae2983b242294e3aff3ebf5a68a3fd8cbf22e527e45f2c82c8cfd7025ff58f6f7399e0748cc328fbe3ee983e3e3cd75bc6ae27c41527679554c93c125d1389b966e5922182b2a38dfbe6ece9acfee9c54eea62b0be29a46c19a247ccfabc670f0f338f94bc4d30acbc399911c26eb7944e86c511872ff9734e75b84febf9103d59a43c95dc54876bc00c3167b7ecbee297443587afbee7ce6df79162250fdda858ea0f4db1d4dc819d316dd4cf0dd7332a4bf021ce7d502c6a43c610e91cc9e7daf24c799627778d2ac5e8fdde007bca722120ab1552f0e7116a2f81d32085f4e520ed0ff3470453aeb49009cacd1ac672d3c350df2c1a88af2b826d4f3fb612a3bd0fc826acd1b30eb28a6d3dfd4ff14a0dc04b44bb4d1abc914c97642947690a67b9c98c468168d871c180f37dcf452872409b5dfc83a50d9e7aac65f6302ba3d9c878220777eb61db051c1f187c7b2be911a23f72d6734877ae0c6067a1b5625f2ba750b6fd44e0ee374d6538b5fbac020cb064c59582e6ffaef3e4f42f0899a8944a34524e0a5e1479180f3c91436dfeee6f82aeb1d28cc1645ebf5a53e1303b4005a4b68924340f952a44be2822c6d4e2010d20c772fee2f1e6e49e3e8fcf3f167952cdfc88f86e6d4e638bb42a056d78a6a1623cb2121c134bfe7e542bd18cbdccaffbcab2aa8242e2eed15c94bfa20eb1e0ca54b96369a9c6ff80456514703cf7a85b872bd1508cd1855455b225c687f92429ba03836981c8c20d41cb86b696a06c83990b2e1d5ca3c96ddc11ced53f1a1c78827e5ce69b0fa48c5f8f86a2a3a526b1c25006806aa20dcb36746cbad3521afa112f0ea4b8000f1a0a0f3852485a7b5097d36d0009e405320ee1c8b526cc846250ece29a06fc5290e7664c35ed792a86e4c5d97cfc1e91cade9d1dc337208250631b8f85b20cfa80fdf15019baf8e07e5431406a9aa83cb7d1f5a28471f8661b0af3a7bc0fcc57748c9ab7cae9011286dc0dd914f1ae6d235847bc0074783f63f5ab0b5bf8e9861953bf2d42711823cda0341637e7f4e73e804df00bdb5422ce65dffe93986d7e3ab30e854254367c3f632d2c55548ec48f6e447da79aed047c39162034f6528de9de9f6b5a95936bed105fdab93aca7d88a27ea0d480969e56081037ccc32b6410dea50e4fff14653498c97fce72e083db03cfd429a28c5cd45f0bce883c0ec5e9937cc6faf7677d5102e7e01c5a8b0e1321109e082f92d9fd9295e3627aca146064919f23220d502a4141a28e5b5e50d99f3d37304e42bf14161cb04ac43043ffcb659efcfc4d9ddfdcc55d38af6e9ff917f46941a6345fcb2a8dbbacb513079752f61bffb8f0587ef81a869574b30dd304cdc867bb340e9bc1447c19c4ea4f3710b7a4906df568ecd1e3bb9b5fdc3578cc68960eef7d473d7902a23d8e4b8bf0f1fdfce8a817cbfb5d72d0676712a05c36c66a142aca87959c42aa2517d17236610ca426d25c324307b70a7f0803cbbf107e8a2a6a255504b96f08dd181919988ba97b3db89189c58d566227610922fe79511e00adc589822511bab4720d6693dc6b248895570d9359b18b699b68951dbc0c24c6ceb1f29d5989fd64881ad8ed71e883385fd63c2000deb3881ad67277af73d0dc0d5784559de5f69d9a67ea53bb960e1c83311b42134e56f441942fd45892138955a082ae3a6aea90ebfedcb073dde90a7b94b1b694a10a40dc37fecc1ae1998165cd43df4166f543a63001af7479f53dc3f309f7fa6027687bf54684b778f1a56083b3563292944b7aa42bbab8f23909c65227bb81d9cfcad4a3f69a8c9e54c420ca878f1c9422f0541194eea6ac0ec1b766f82d15d4f9bc73d1f73b47bbeae766d1861972ca79b3aa3b3bdf787c41fc5e21e6636ed1dafb5de94558af3b5418974c449d0491f5e5d3596dbe640ca90910f8e6d1fd1d1eefde796efcc31bed9f8d780b2c1cc77b939f641ae98b65fb0c44098bdea5aff1c56509a7ebfc7550de626e43de8c6d56c9544746da341abc643ba87e6b6aa451b3c2aa943456210f04dcca6e897e136ebd7d2030c2dc03601c0e264589d6335b9453835ed5b2a976de5db0ab2db60eaacdf3795a4a28d9f782aa4b2446216c3ff0471788e972841b4a69937632499b5a9953f2d90b81e128b310ab5a4776738981283289153dfd8adb00f221817c9950efd365f9e2b3802c991bd43f8f2036bb546453880b58311be65d8a336754f96cb2c94f7ef087a1e6fc7cb2a59d08a2b9e4013940b4edab867e92723bc4742be1946dbc512a164b726dae5165d50625a15a2b3b77dd324607e7aa12ada680dade9c4c7e64bd9a6f8972ece7d52b40a5fb9f41fa29f8f0bb27269162c2a1df02976c2d3f4b374f1815a829b2679749c8d1ea6cceda36f53eacc6e31f04e4509696ec9ec8eedb362acd5f840e9b1713f9fcc8128935e601e7d86df3d673649c3a4eadcd86ed5ba586c4ca17d735e10630dc45edab49f64c352558dc11431c14f9c5423b54ff22196d990a9e208053417fcf02ff838cc937928ad46571c8476a964b8cefeb72407babd85b98831ff170f12fb25a827a1ff7699a76068f502a1b3f74dd0111fb9530d54e329767f8ea4fb1fbb734f41f951f80fc70f9627c39bcffa66f4618e1c52bbbd98ebb19f5488ebf41c20271e590f7429cfe4b21b0410b6d8dc8ee39c2b8f496846d2e411fa014608c3823ed82eda178fcebda8dbb12c196973b15033499f9e823cbf4bb43f9589167445035a15a9f68bde24c11e4910c78d09588b21d5d3de121925bd4071771a750679804329018ddca6de6b8de3881ca311396560f0733e717c3a4f6fc783c4ff9b8dcf09afbdb3e40a644f719481c8bd355459e55f3573f055af1d0e601c6100b0b8e91b6fbc5ca7b23f234205a8e6b43457f8ca41b7faf095eb7346e25cd4e40f2f79e645c81223405688556f11635561e2751713c7b8e1c6f5a803cfe339b2d36fcc5aad953d97566f4c6821095c4637084cfc5faf060a36853529edb4761ba944eceab9bd38a02c1a9765bbd7520a84b90d42aa64e2a8da01bf3b818c96ce4ef113c3a8c4e14d1cbafcf4853f2beb59dac7c0e3a6f430f67577dcae1594380326d9d6e4f416c5515a3d15aefc35eaff65bceb9d056489c1db0c37425e36fe72c2449bb99696265463a59041af73a75908c505aa80fc2740e875a5551f63e2aed0bbdac84336cf458593ed5b77d873d05cfa516386b977a9a57482b6d9b7c6a3e2546cfe429c1c33c4dd7710d17c00ab741526e49eb3c5e84f413b9ee3b5906ed4d7855090f1530d31de24ee491d4479505eea6c3d3db5f170df92a91d751a101f3584abbf7c8b4ca13fd644f3d7973b711a64c96be62f5799a3f83aba6fdd425f4b7f450d0a5e898a296e0aa7a1e6772cd7ca05dca09a786ed1603a4f578d6ccc4d1acc3575c4e676f38399d97cf4a57ca7344a9d1afe6cd691f74d5160dd8c4c4fbe80ff4e842c87876204985f6f29ad6577e0bd2674d966ad066054882977d2078180c96d964e2b42cc0c74b8475a5dcd244dfbb569c57ff0eb92dd3189bf64edeb423ba2273bb362ade7f7d30909ba57974baabb503c2f38c60f418852bb9a9599594707bba8c75962abf6d3f090ebdd5a4ee0bf2a4b0cf947b51ebc02125ccd22dc934518cc5c90614400bec154eaeae1a7b33fa9839aa21bda64fa6afbb248ce908972b7ee6df7eaa4a89ad5da7d6dbdcced3cdb17e49c59ba5842752181d765a883d534afb9dd9989b30281af386dbcbc0c709d635e74dc3326532e550e0ea72c651c42fa7b4cb885407cfa824f1e2da46afedbb1458a1dc90e0969daa76d5f384fd8422a942eeedce214da2ce1845445ea2c7e58e61914ec9c12e990f56c4f582421aab79235fefa785a6402c72110c5854b6319df3a1c3637a90b9bbf725f9f1bb1a1adfecdaab9e87955ac18270c9cb513e3a4fbc56b26526dd87de24701be7fb9e579b9687546a72f873d4de4cf2dc96d3be6681a1138d3c7f9a2b9a8213e081a5906da12a85b982ae6b8ab67656f5b9c8f65f8aa6045c2b88156e62df321b45fdbb400202fe3fb91ec60642860b8a6978836779340fd57facac4873838c06eab36a9f4f55a4e5294359ae37a6a4fd12aef9a045a84671fbcf89b59fc8b4db377dd983eaf26aca2baee1676fdb3f42249e631a066ff6550ddc99bc91b3ed7da3ca815c7157495910b16d070009e3e2f360280b358f92b3ccf9b8713317cac4c7bf78cd0def4513f4ecaeafeaa318f97168ae99eeadbbd719b4ede4a6c9e0f2bfd0fce32cfb7b9267b113ca4d20d77d091cbbeb02bde8feb558faff0445f8476facd17e3fb90872b888081e6cd0d120562e2cb00e0b407a7963ba679986f344ba925acdb011f177632fdd46870f154e100b5923e1de5baf506d5ecdb59f6191c66a347a2ffce54a14f3661a9de4d8d1b675f96133b8dcd3a3f7ac1387799511a645581fe6fa93659e748694c6d68103d7fa024ddac5ddab2432e5df211a8486c729ea2382e509b5d3cc8d12fb0336894dbec3c2ad8fafe71670f4c93c607aa2dd00fdf1197231c9a06058e533804c062098458834322f9efea0a574cca7a9a7c6d5fe0f1765ff6a869bb87f446bd4041cd78c64d011be3c223ce93d5cb7d0356d33247d94335a213c1515f48668e940dd85763834081254b52a7f0f3b758259006c8e3c29131469003a7ddb9b70ecef790b48bc4d513c1457d77ac7118d3f3603606deda59b6337a9fbe0f9fc32f3c812a195b4f7fe626945562c245b8b344ed594d9523fe370a195ace135d317654264f6a84dc5a7c31eeae587c858a90b7f9bf5532bd644d264139d50b432e07f6da9718f5da16d676dc6dfd5cf1a75bd00b6f301cf2f2930a164dc612d7c439544a7396d8f56b244846453735561f3bc29b3ebb6401483a74fb8c1abc5e2d2bf4e0682d5dce861704c6a534d9b35214b4fd161b2c8c60e7dfdf95de293371afd66e90dd5c52d260377fcc46530076f6b541a6103ce082ecd57aee2fd2971716423ab0364a2f7056930b69ea063a12b91df8132f5a5eec025cfda25ac8d09e90a8b491f667aba82b92f32f818e375ae8e0676c9c3422f72f22079aadd7a3807ae3aef7f362cd7da9161ca0b21fd84498810903d34ff982438bc3f773d1ecc012cc03f9765a4e8bd018c64a9f8ce62ef243a5371d996118abd5be20a25356e441271d2e726e9bd70d2d8abeb7cb93d0a6153f944b83c6f626368d728a44782e03ee2b2a6f23df99b0185187db0cdcaeb281901e8231be1a0817d3c3eeefd2a8406328a706a144bb51d72f83e54c3c9b338f102a6c43357eab4a1c27960335f63cdbe668874f59ee0e283fcea70df763169fdcc9e0daf3d41061884a5a5cef9f6e32d25b824caafada398f4653afe505e39bc2d7b1383aea25efad3bc05797f8ffd87a1869a6e40831590555aa5ef19b7e0708a875de3b50dd4a189105849e4fceeccbcbc9c1c8d3d3fd4f3774fe85385da0a15cc7512d91bfc260d955f57c0f0a73f4bdde953433caaffe2800006008695da8b1b7997f6f9cefdf8cbce9927baee417d69f9ffb02e4dc1dcb5248d429fa6cbe4b332b5ff74c9940eaae2151f6ef494251c72d001d83dc97f504ba7d962abddb80d30049486e9742c622de99501ef83a20a885a8253912b1bd8a6ba295a82919a0970fbb132bac0c1a81e94508c0e7536d3cd57a4570bde5bff4ed04423ff3bc7baeb3c5216ae74bea759edae373d816ffcf67b1249bf71b5ada2eae26f51663f82361a854fb51fc8b0d9124b38406fe783964a91017e95616a502dcfe34a1d1b5893aec501c866e92378314254760b58b7a6eee6295d90f8ee9d93e170ee84285ed049d9dc7a509d8211053290041fb05bd806c649e444b3b3a3681f3978bc75909053559f3c7dd5113c23269b25d7af8eab6a3d0534e7f453075919df7a99ff136dcda965d98d8a3c8f86064200e692b872ab6d503cc32cee7426b477bd35a71d673dc2988da4cdce6baceb0c92a9ab876e999573ccf8f6e8ce6f40ebef6e9a0f876fac4d38da4c715cf901a3b65fabb92884ea1c072e8295912ccc681b1da963ccbba062e4b2514e5011bf6a3d4f89a37eb478c51b8525ede91a84fa9d38c6c7420ed5d04d65a29e1261db92176fe2f1620b9db1cce9d027bcd8fb700a9aa429d973450ce791ed4919c767596953498e41f8c09df12c06efa99ed5a33356b967a0da5d7bc19ef2895dbc9b775e355561850bf3b329d018ce28e47c648915840ac35c3f75900495f9e4ba0bfb917a52c2e4488b5104f317b8a9ab5605f438ca2397a01e0b3fbb39fa2add41c0dfd3efc86499c14ce2901bbc1111bddd4b112068e82de9a0dd1d16b960620b2b634a0b1307964e335615b1c1f09316791788453e013c4b2b254392e098225e9c2058d430f5dc59494728e563d7fcfc81f3335c6084a1327fc158247cee24a8cdbf0df0a3a0fb703befc9482e6f6566d73890750634f6e860ce20363c5518b341dbd4800c12d9c47d7ac4359651c9689a45c09f2ef0b1a0e77e42b725ada95bd6c025276a8cab391218d48189fc0e135525304035cb09ce42097117d3a70a2bbc86b705436ba8d6f4000b99eaf3617b24ed8f4471ccb93e4d3398a303f5c9fb9ae9aca5598090246bcd5c4f8b0a40c4fab9ec762a074425a7db3b7b023407891cc2ca613bfbc073c2fd6a52c2134ab38db66b8591152b5ceb3f1728871ca27e1a3b19d8056d8f43ab1986107664af467b179a53e26fd0a3537d6dd9b4197cf1138dca363612c9a12ed78372b32143ce259c09a57e3870955091101f790c974f4ed2e39eeffbf9a5d57bec4e6c17a019b5a5e394665697494396a6c5a6ca34b945c7825424328995a992e06ebe182a5db95eeaa345425f0c079b65a56fe7e35de88831fb867280a952b08b9071a05beb71d327f9cc3e54b110bf87873e01f4eea09d420929e4f456ffd4611f4c141959447ca5f98e83cb130a806b46f9ee04cb8de76a42a045e4e2892637ae9e66a32081bed2436409e2a30deab5b83491f2310cf2d81852b83ef94879a2b2d3c499df5fc492e011da0cb7c881375000d3e2329a8dfe9bdf954e5154c0f4ca5639e66899f1813d23daf00cbf3d6ea11ec51473678136e556f35fe8dba29e353baa978b47f7a97cd2c825f8f9ba0fbb4704f58a614e899bfb4865edb987a54d987d22351b10722a730eda73d6affb96fe1ebb3d71f6545ea21c98c7fbb4bcc2093c2e7bb0ca7cc4999a3e02346405dce72fa600d9243c3fdfed8ffe11874c10ff591a5fbf195fc1421cc76b73dc14c61f85b12c3695bc037df7f18e900acc6aaac9a2f2321f21017fb20f07e2f2373332950a98a5785976236af061bb674d2d9743ee3ae923b3686a469c00e9bd422ee483856f7e26d241fe1016983163cd57865184f498eab0a2fcb9c8a107a9c10cbe76ce8452e48760f368ea1cbd5ef7feb144070f34b16e9d4fc27d3d799c17bd8c6c751160e615a944b4792afc66bf13f0dabb0ac098ecc9856fd9461dbb2b81e6077fc943fb3683fb98a8a9f3c4037d362a9a0660ae483e09f3ae38b9089146cc24cbfe9ba698b09ff2e0e0f738ef869d7c16acf7498fd9d6b9d42ec9f3d79ece72e903d43aa1dbc664843699d564e89cc5ce80b99813fc10eb64353800162a6b5825590d8ddf422fafa51ee27634076dd7a6d48cb48419437f3155724617c2281ffee2b2407a585fe157c352dcbacbb6f57c22aad34fbac1afbb7187fe99dcf33fbe4b2181a489f0749ac27326b34619ad77ae78e9d31a0ac9af41af505b9676408c22eea72ac77f19466bea72c4ae9a7d312340bab1a8feb1168fdc53d4b0ff2472daf73a726893ca9b796e40ac04bbf07a798e5fe6cec8a32e3326e0f524b0078fc6ebd9d24c275ffc8cd44bdc3c6d9d904aabcbc186116e72797adeb853d208a3efe168a1e9b0c3ed2ff64917138bb066152377e07b632db5e030b56f8041211a74b2c40f5a46b7e2548689bec3c5c26aa7f65512671bdc2eae4bd89a313ad75360d4957401878a7454dc5da869ee88c28431a930274f4b5a3e5584f2445d9e5873d3fa8815d83cbc0a2b839b4bd04b86670ecf74a157959f0394309cdb13a7f6a8f374942dddcdda777a5869f588973860579604a6e968605e6bacc61bd4e23fa84bb6a4a80461c6aa0dfe922eb1dde6c486657334e33f800472495c07e16a1d9b7e35c8154224e940f9e31ec885b7c1afc0d876ac189b50ec8a6b84398284c0ecc3d312791edd41702cd7e5ed26292d8772b22cc6152847ad96b2b638c2db42e04b74ad9a71225e8738b416f3f815a87d91d6179ee01c72356381dd470cdb8d8406cdd08aeb389bcac237a9abfbcc1ead58ed672bfed00ce501b0d76b661e4635f56af549a69107a025d9f4fd780bee8326e7e5b4088a709c00fb2bcccce83aac5a366584c97ac1ef0defefa92d92b9a9e2ba12244563322d8615d7cdca21b647f53035ab3bdda1c8ee154504235dee239ef2239dd2edf625db2ab8b06f638a1c78ad89e222cc17fd77defdefa0bf7acc31974db0e2f20ecf76f869a24d0a22f3ecc6bf057bfd36934f548a8f8e59828d91c255dc618f9922dda3ad535d688ff6f8bf04fcc11229caef86d3007ed21e88398f5217f7745d6a6917fae40d4356d17e860cc7d5bd4e48774b1d40fabdb03055e61dfd027fd2f6fff66ceebe832509058b623b97a8a00553e9c3af918bf3b8e88b0a2868d918168c5db87e0093b16e34eea4d9c817342c041237771cd60039b776e833a0f1bdae7d825abb36946e96f1b82dcb1e5ed08802e1eec473acb237afca63a299ce5670156d1e5e2d0efc39db2ad4bad56164e24c7b31dc57647a60d3dfdbe0746266bb965d667143d5c3df586be8725d9ffbe4c20dba61a533f2062b8125729765bbc9368de1e0db57d80e52ec588f19332b0cf44eb1a0c8748375c862eac98731725959954b4255c4eeb526f5233420182ed88ebe6786664e7f85c29189413b41467ea7b104e8c6553140a5c7a031671640256f12a63f97bac0f73dc23e4220a87b65bcbeca55525bedcd26a3246e5bb52afbc0ecdf9192d710d64ad34fe2121574fa272c5838f3818d46eff57082663bf61ff68a7f5725d5e33b227bca83f25910d360253fb9a86db49092b6f18a0db5785c5b824eb7902190e05c666685056d9c20dbebe0c392b70c286895fca512ebe1e125d3afe2168522f61c31b4f07da9de63ae9a4b4f4243e77cb34a74aca8fb785b1fd2d75539db750fd59d6c136e4b11d45156713f5e335224cf0169306a2480be45cc7db914313d68981a5d5f980c19e2e9c5a60fe9e9afe5dcb84bc1b50becd85178527205644a76293f44412564e5e282e155c12eaa163dbcd2e1f3e61315763e5f5d45215ceef1758be29cc99589a43521e80f86535eab972ba64f3184f1bb98f262f80f748665dd4223ed7000f363233dae39f1a813cb1f6dc3c73812eae0164aa6937cd2813f3f786b52408567c5dab479909754a2fd2ab47cbb26f210eb3eed5d59cbdb535f5368326837d70c11dbc6a6a97581b49d0f7a117709d2ef090ad1b0700be0d1bcc1cd4ef4bf67e929673716ba63c2887cc80e42bf3651025c65ebeb41f0a3d300c0fbfe76b5253a6fb8371ea83a234595f4ca96c6314ccabae6c4ada8f04e3c0b4238e19cbe785447eb61845223118ce08b7180ace19f0ee872082cecacf656fb4ea27555a88b499727b7ff4fb06387405768918cf5afb84337eab5f1fe49dee9404c027d7ca5408742c5784eee35141855eff7f0d471ab528c10fa8aa6cd9aeb135a23e62414f79a3cf79fe77c0ddceea4c2b0c4bf25e7ff91e69b0a2934f0886b3d5cdc210e3523ffe72a649f508c0ee607f249c685054bf9ce75d114aade2ecba78478f4ff39649ee0f95053a5f43f8617e4afeac072574094ccd66e7afd8bd2ff72146278e086131ddeb8660a6eb797e3e9e2c5faeb80996dfb900c9ead6752fb8166fb45c2e832d8b6252d2fbc9d81562a7179556047a263d604df7ef86f6b6cf18ea0defec41069b1171b9b38b1124718570c2bd58ade54a081972f3cbb87c5a4b1d1557648a321cca66203f3c495f3f887487bf92225f87e6a56e566fa68ad10ba9e530c043fcf9376da94bd1c79500d8ee6e5574f13c618576a31b76553a4c7c449e9c1dacab39465dfd99fa1282186b5a43ddc2bbfaf9b6bce02e959a9bb262365eab32293a5714db88d8dbad9644e73299effd7998067fc9f3520b903a3c036d999df0801c7516233f45756215d123ada7c2320bbd66ed9b8bd3e29b5e46a69494eb53c50e414108cd2a66336a6eb0d3990bb76bb4324d7ef5a461365e5b1b904a3c6e902a40f32e760f2b4f3548f558c7bc54253411648b933dc6a8c21dad839e1f488634d3520286fffe3e7a8495ceee0e869d7fd4a314883685c93d7abdc1fd5e980f0e4e4b327bbc081bd180149fbe387382f0c34e4100fda6a7dea881114cf99e3c4c2fc2b4e2942a2f47293e769bdffd97c49386de05d4c7719e26d72ff7e1957a3343421acaf5872ea7f5cf2422da25b5ada0fae8b0a531a3f4e5a6112dba70d9317449191f014b665e8504c38efb7ab1846a8ac9b2fdb04751b7b0605aa84ffd9c466eee0c752eed7448bd6e68d32f663618f3c99a0318343c80e5e4a9b55660672ade08121ea1224d8c5749e73f2589fca623fc6d92dd2491f2c95adbcfcb3e59054a4734ad34922d9cf0493817947dbce6d9a03076519f02103b7b2df8a7ef3d780528c9533a1f3404943e3bd4deb8ceab5c5561c097557e068f5915e6bf7a1f534bbc199a24ec741094d78a338e2c03cbe586298adb14e9bba45c0a8121b4318a18cb04e1153100b6576db70f48b0e6b0d65e9b4dedce7a4d4c4724b032f8157a686cfc4d0526bb9ef9e821311ffe5cdeb5a2af611acb71709dc522417976ac75ac6c044e07aca25d5670d239e8c31933f3b032cbcddecd4785199828c70b1c36c21eacc571a2871fe81c7f77a1bd99d5cbb35bdfa7c6ba0a0146bbfe8f0c7a5f026f47ffd1b8c76aa4e0926568fc48fcc11be1350501668f12957324e219089bcfe41fea70e4a6ee19574ec905acb4e4cda4b6da233d49b816b4ad64eb01a19a21064a577d1ed07c3b31d5568129db89cf3ba3d9d26cc1882b9bbb4d38e9781427e8dec29dc5a50016051be1b641fa20316c385c16fc96279336c42bd82e7f1668765f736a89f9816453e95df05c3637cfb4c77be1e9b81b09cbe272c601c4b5e60a907667cc0cc9359addde59b2fd51e4f62765c02d4c812ddd928b38eefc2b5fae515019359a9dab903e17bd278257ea7475e7286e30bbe60766df950401d7dfe64db7a937ee3aa2fdf04c6cc5d1c4bef6ca5068867fe5ad57fab3bc6f9696f869939ad1528fa084c1f4885eb833be2143f55a07126a5d4e872e1a91a8deac333dc02a3935e37fe99d9fe2dfccb223aebf43d9a578832268666787d90942c85f774981aec9253ff6a806f89b1e14cacf6c883ac7c4b56c7c70776549f119b408991d584cc6d5667ed0001f12e6a4c542db9a5072724d8f43c993f1c7f2183be6b55f30a49d59e64327e8f5abaae5ae40ab584d51a6fe30a7c3895a127d440aa59296aef39ca9af9fbfc83350996542f5d9850325ec24972825cffbcb44fbc4fe4b2be69e5bf930af2166cf01b5fad053fd8ad2a49f48288bce99a972e14c9575e227add72533f187b25daf38a5aa05e41a3a87f481f053c3880fa01c27e3c740487f0c665eaa0972a86c54a264d70678dd844c8735f04ee6e1a25e95981c9a8adcde2fd2324d4d5cb83f1bcda1a069311ef2fae3b1909414285d9070a92a60e326c763504885745ee3cdaea9602d0aedc7ccbbc834f7cf2700aecb224577ca2d55ed95fc5a7cbf65a9242fa4898e237b54ad1b5cc13adbe608d80343237782117bc021b25e405c5d927960e986d72dd9ce0ac8b9b14231cbe3e5500f7f084d7e7d4279114589bc98ed2869612880b618c5da64b94dcb76935d46f7c8b73baf668b7d61fd87956943fc611d60e63fcce77815e58457086b5d36bf922ea4a7c90e8b8344cc794ed9a7d6a6df0847b2d55970410a741fe5db27acae4774f6cb5422f59069f7a124802072362209def81691f0f57bf6f820d14f246c94642eff3a594fa184a7c5e5853328adf7507233e2b87e4db238dcfb5aa4aa936ad76af1ef70ee9c22c7d8b45a627b86cffba5c62c2c31f2b6f95534a5671dc424ac7a15e956a534e848d93bda9dce2d46cb9031cd4db07eb4ea48aef40eeec9f0e81b1ea85437244639d261d45f4b5248b257a2a4783179384053ee67bdc54c3934fe92c771ddf8822180c3127bbb9c8af69ef35c3ed8527f8029d5a0275ea419692adc484f4c54bca77abe316570158fb573caa49a4769fe73dd707133cc5fb7dccad1c6a067c8222dbd6c779b6416a932b7602ae7757cadc5fa4f9577ce74a0d88e297db3fc3d067139595b16273b9bfc6ab989bc9814f8fd280b27aa30abf5b720abcc46b1cbf74fb14a6b7b900005d74c1ee41133801c44436dc8b5942c451cd798a90b57bf5c261d59667baf59c96e2e59c6a6d9bcf0075b209339f998cb26edfcfe1405deb99b8c0ffacbcfa10145af6e11de02fd9ff5ad116b5b91f26248ee44aa174cb864a5beba2828b1b8b0b4de24dac840eea893090f6b8135feddb5cf890835e2511d9ac9ce7a6d59caabf1ba611d59b59f9f3accbc2aa21cc5a122a24a44dd73e2861d56c44e4e8c16ef47b0d7a912f23ceb19e9be5f3f3c3a1efcc0d29a99296ddd85d55c76ab5749da3a08746d70ee3b993157b11449696c0749eeb2b897cf544687fa2ce94a511d145287acdbbe4f6d98b0be0ea0e8636e082a8729df94091c6fac7527fbcaf6b0896be7923377f9f50788a0461d043cf6f1c5ff046a537e551bc4b36521fd9df42ed6487f7c8fccff8d1358f8ba90b09fc9820eab09c49949e5622560283b927423f9211b8187d01b9154c6220acf8f4bc10bcfd0ccfc19aa0a50f605fce6dd501d6c8e5d766b698b4ff8a364798b71e532c38b6f9064b7ace3d7f2b8ded81d60a411874114d6f8a954d35621a0c4f893711cd936402a537cb9358ee75f4e60afdbff6a5f49251bb35ca020cc8ed4b4e5fc6cfbe12a9f98cb0885478b900f15275fe81abd3a10bdaa988b451c0a00da75ccf267888d244e54f2b47f473c7e3eab2eaf77c3d4f75582e8822dbda63ccf490aa3b4253e8c47291058fddd19aae59d14256b15e0ed3ae69cfa4f91f49b285db8af2f4285bf3d4a2faa9485fac6a574e291857b7e4a431812e780c2ae91b4b4bbb5636f09b4e4bfbc381e4d100b00406a0738b8c220c4b20395fc6b42cc938f3d5022972e92770ab757fd3aac5e029c4c4bc7f3c190117291bf162004d7309407cd6e83a3cd4e4e610335199e53ae9ed2925da99c26eff07a4c4180dbb3a35d1a5f3c7b9d1ed5a1797d320c47d0a9f5d4f9ca0e9863188398b474bc01f00b7041d116f85e12442b3015076e38ab81098ee353a8bb75630dc84ec0590f7e744a02b47e86fd9f4432ea6b6bb8204cda27ca1fe376c4e0e41641d6d89d26387a161ebae9447dc506e171c6cfba2316447aed3a274b2ff1333d0634cc1e32e9bde636335967c7644528b0f993f44d5d0f2d0bb48577cb9be4132c4dd286fbe5fbad6bae3b8645509733754bca5237d276666e394a3509ecd7428bd5fa9ad4af0fb06d35d98d288e49b7f31f220b090c919e69b7179cd3f344be74ef0505000d17b1627e1b95fa3392e20b5cd3482b36e30b79e68144e2b160674d0a5165f2617c9daeceee8387e1575cdd9a346e24fc9740a06fb8d12f8e970e4058b4bfb4f9289e429844756d53a89b4a2f6487e0c773e004a492c84d74179e7b4c819f2805b711cb0f2f6eeef0712d0d575e1ea7c54ff1b2d7d137a3e3e052b8cd65fe284e5bd96ccc48de9d146e7f0108e674f0df728625480af84ab59dd2e8f0d7d3398d4cc0a9d3f175c6dec529b3f0890af19e4d9033977d2286d20e0311fbbac5675a9f596d7fe2d12b4ca4951cfa3a3d15e2397b8aeb5b6699da6e9a93783cc4eab6bbb96b632612de7f943087d2813db39cb479c244a2f1abc7e3bdfcd4a7bc0149f339d8513de80794b9a9394b0fd1306fcaea7b46f6f8b18a773aeec43b35569a70ae81a43942a727f7a0c1d3f3b9bdc11c2a41cca074b4c57263a0654a8678cfc74bc61e7787a44c345023d03d76c0fcef650d2a3eb6eaf1b7e81d5422a4bd492c7c3e5d9854175b0275f65265fa13961fff85557fa7d2a497b966c58bf215118d285496ff99b67986a6695b72531e7b25f39a5b2c17e31c3fc332493cc24f265016039bae9b3acfead2240291b76c0b53cee12d5399371696576917858b7070b725ac4c53b5b943cc7dd4126ed7751235b6ff8f74f28651a4c7c9fa39b6f1c435bb4d97146389ea95904a97aea98bae4468c7be68fa62872eb12a6da46474d0291cbe849ec10454acbc8eb951dc0ebdd40849e337a7e37b49cececadff709c4e4fa5c834496988e67bc21f0d6ebeba9b0f1e2f73a3f8cbd78ed8e5aae233734ec9c9eca897456db0be6b97a1f3d9984c0847b1eccaeaef4b75402c5cfcecf0ee328c84bdff1f86d9ba1099ad6ad2e103bdb89f971ecb5ff6049593c6bf90ca534b087e19043c250fe7ed9b996c46a56d7eee91d30f377ad3eb0bb6fd40d056d8debe2a7ee3a808b3658d4d938026c42f8fd3b881bd2c2621506effbbe02cb70c39dca6d2cb68403f02521ec509589b35d66ce8a56eddacbed4fa18b5139ca132822b00672e06d24665ac04ec869bbf470549d9f9862f0271a77b9c7f162f28ddadc811ee53080c0ec5752b2aac88b4a272756b64f24ed93737050c52e6f6598d2e8d0baf7a4d208179b93b2b2b03328418e6acd63d1983a86e54b77ff36e65476eaf458b2c706040d03dc2b22785cdd53113da15f0a3567cf00c6d1b88286bbb445fed96950d0a934c17aad06507a5cab5e9ddfaa9867d6846abb36c53ae0a936ca3e99cfaf0f1daf4dbeda392ce4da9605861fccde9dd705e8bfe5462b0d4ce893cfb0bf4c67627f150df52261fa2a71000f652be45baea1a850c60350f786d5dae7cf5ea4304ca84c88e9a9e2a5f1790ddd481b5ccf83410853cbb063d42aac7fff1a43aac5a551350f533291f9005d99dac6a7d9580364e42cbaf6c99303e9693de36d2c4081083923698270049a200baf3bf71eed5359aa4c0e541a44b27d4ad276b791ab82b8bafd9a47ef489112e3a280e7adf9b99dc48d797d3a00e9533f7aaf7b53f6bf1bb069d1b468ac743b6d118c37dfa8a5e9ead4e1a33b0efabf576a2440306d1f9a4173ac6d85c204c4eebd1cd6bd57cf80428c284eaa50b0001d2b3b147210da64a2a61f4411d7b344974e2da0e859112a1243850631345608e964856574a26e642614a5021831798ea7af7bb8b06ab116cea59944571ec9c7847f834124b39d0e16ab3deece7ade24c8d632c4155b2804dcf2128f9a2bf04166f30f3fa6ae714fa086d5be61dec48bd84ed5729f160fcdd07ee0c872ce5936d36ee1dfa14c8c70f1b14fec6155e8871c1aeee12e6f39cc886ab62855a2fdf7f2eaa7d207be814ca0763aa17be600010379496290eeea2dc1841b8c5200a50c8c5059c5ad228ef6e337485b7092da735c81b85852cafc88da511ba0a4b0c62c6bdd817494e950b51e45c6e4befc9409c9d02a191a39e5d643fdf3195497a7dd19015b46ca3c202f7fe46b03d6deddf1a93a11c784e65355e1c855d3d7c62fffebb6c9c4f62d51ce268632307e0d4be3968505bf79c80c5ef0e8c8354728e511f84e67287889bf18f8b72beea83b603d2e57726444d3cc088b8c1e6d6b925d8397c77f5b475f8275693d912955fd40047f72277c6a0a87139e730c1615cd7fcb55053258405a6bb6524a5b9b2935f0ef9c211cc0fd34e619cd32ec7e03e2fd87c0d37d7e2aa28f48211eac8a8985129cb7e918d7ce79865e5a1d83922d140fe83d66900476857a2f25a043a7a3cf477d224d3a9477b2f35ecb470fbef37208698ca07f92904941e6657a52a6e86c07bc43994e8ab246a81ccabce3d560a13e8353b02d521c4348b9555686e18b9dc86a2151155a6fa291d88d5a1e16f9006ffe51d6dcb1d8682cc8f22e0e2f9a200505a15d859cc8252d95aff343d0ab878fa15de07f0b76e709f1ce3ca7d08717b7c9e6b546c3b30cfee09268ec6e290085f5249e92e7b0b233a2d5f4de914c4e17855e824ecf11642907ed48c3dda6d21002e38c930a3c3d764493264344d8a3758201139deb30e2b73557f0215ce1db4a765e7f012467ce8b3f2429c65561a7ed0bd35ef9fe41d847033b79df11b783b6053a8c1a81d68699ba0ac6811e6d27e276eac1076a05e4d0830db90d4455282648c44c803183084837f8728d4c49ad1afd5568c28dfb7e5f8b1236ccf12f686a35f3987e26a3a6a805bf8ef8b2a50e4f8c5c5b7cd7ff380212322ae35a291386de38f34e849cb24a0af52399e565fd40120c0943285ca4e3cabe1af38e0e007df3680ea2c4e7c92efd7caab4173b72e75eadbba74315f173ea72d4f7b473cd0780eb9cb0246d43ef9dcff89ae4406267dbcc7f1bda9def69b54280ab90da44945541e211c38335f4333256f4007744a91e7507249117a3554b9084de5bcb8679c4f7fe14d4099c16a579fa47a6eeca88069eb4e455efb18edd0ad49e63fca383f8cbc2a8edb9f667721bbf512d2e705b76585de845d1b8c501d59a3dd4926e6517815b5991e842e5889dbfe275f8a6f7df970b8dcd692208ca2faeffcb98f49ad29d52e1c98e2e2ccf5fd45f2b577d4139d20112966df9af10542ab4d7492fbbcc49d70334556c34558e04b4e36df0abe466449066e6b00eee8d4c3a4352ad70fb8ae193c8af572ec946c3e3521e2b5b1556b63beaf89dd7cef41cb9fe90fde0847d51b7d89303f42ed88cb97af707db375a0a346cad324d603f77a8ece49c8dc8c002e63e4429df4ec8090a722f77bd7a60a46d4ec4bfe0fe8672f3d8d8def9e962035ec6edbc181ab55c2e1cf12ee997d7873e94225d814cf1b8eab55f4f257d23bd9926f289b3be6394f762c8867cf9aa8457eda992836c6b8963b28a4ac21482617d6802549bca73a4510461ae52a3df64c45f7f9145508e81aaab0f66d1685a4ae65c0a0080a2d9137f3b73e0b3f7d888a1239dba1a58788d786eaa0c40b31467acf2201826f2df01cc94ab1cf76b0f461da6a8373f15da38b57e4f654d42cc29b375591b90dd71c892f5f756af589cf2c32a2e5050dafe075adf715abaa6cdaba7215cad5f0af057a92570a9c0b8b939413ff95fc1d033b2d38b0a8bc50efc3263a058477cbf54d7bde237d04a80b1831b4d6203f1bf17b5859ecf128dff346f7dedc99fb4fe54d705b7eb423888cddfc804d2c4bce147009943621271f5e5382414416be3ac24667572dfca9039421a1ca4f29d732b6b491a62d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
