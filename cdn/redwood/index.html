<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72a3f3f716ae8d0bdf5416d35ee4d87dfe4e67ae359b2d24e0b0afde6c05158200b9a7d7e80aeade1769194cf62035c1758721c06487fbf56a9273d4fdc4689ede2c59900d410f870b8ce7109a84b692168941a401249a7bf8ca16c40ce194c29ba1f886687a73fb6c82ef2f215dbb514ce24221f285e0d2d391c4a9a494654cbc93ea4ffd60b613c3c26c4f1594203c6fb54aa52bf39948490273d02f5df1febcce026658e9ff2bd99c6b3dad915d68fe5cedd75e20214d919700d5cfc2d60282e73644801e9615924e3a9fe05c4f8855a030fd037fb572150174bb9f554a13f302c1fc343383b324d118e2729f20622e498c40d9bb9102f230229f763ba7cde5b05e15ba90b5fc21bac51421e71bc811ef2f4e51362dc86514161f68d080265f9138f5a4610ccb51418f654c5d7b6d46e2636bec65c03ab5c3c4c603d45c80f8b00e72b8faed203f59ae451fa4456c46049e3e4a6f1bf03d272bfe9001d2ec7b9a9f7a40fffa20b67e595a2cf05b4c8b0150780d06549aa978c96031dbe60435c6c5d6b063e0b99de21d809bf4769df2afec496c9097a3bcce04d9b6eacd8421f899a612e89239d1420ff0a0ffcb376e7045bd5903d1ed9f6d25293121eb579eece80fae4b6341391646855aed9e9d4c42e49575c854621b8c2409abbaa79962ad4c641cc0c2f32b22be5b05330a298d2e39810c92b954adcc70a5b308024e3e256f85a392de511da4270db3e1f99d2f0be9714c896d5fc0a59bea2df68079533e01540b4910c893865106b2577cfd836da97b24aeb0c5023914e1b3defcb5bcf77e1b9179292054ea9e1f368ff80fddd9a875ad138bbb1ca14f578617320977a43b2640f77838c916ae811e1902e57b341141fad65b3b00f4a8223fbcefdf9b92047d06133b411a8359f9d92a1c5c14ffb3a0acfa7badf8bfca7bf631dcbeaef7f7be882eb818d54f8ab3df55ca9497596c30aa6bcf04b448c27cd183a5e468c23c61216a17cab1998288599a6ac02c404e7a2533b746abb208364347fc08203b737bd3bb337ef1e60411a1fe953be06035be0919da945da9f8c832221470baa4a24ec99878887e0873b1622537e4fc782fc77c34beca3c938411491e2400333cdd14f78b1c87679aa768836dbb49ed10737b31b05c145bccaf4e8b73c0291ce7d9403fe896d4c1ba5f7a398b66109be416e1b37d0c21c6981d1aeed7f6be1a24da48af16a4a988dcf5e30304047a7c8aae2a5fff68f414af5c72cad9399b62ac2237e09a52e808c148f4868e8a77d90469551e2ae59639f44f5fd5b1b60ca45195617f1137bb9d3c9c9b85179a0524c27cc0414713bdd0d0d2162a740fc45dbd628b84bb5cb567dede49c86d6f360a207af96b7742a8804f6dd01820aa96c0db8bded8ae74df45746d57bace068d6370af72029ff82bf2f62feff927421225180984fa5773de2a12db54a179ad0ff0ef9cd2e8c93c5a29d4731ad59f2c09ba89b4243bdb857f5790b3ce06932f8ec14f0a953b45845f7300f81ded8e7cd2e9474fa6a4009bb7c5204227c1ae4e8bd6255c227e3f49b19ceba0b0c665c26c49b976ec3bc6c1715c66e24f0ad5535b8ff2aa9247c72ca9dbe4a371f8216dfa00fbe59268836e47d07f61bdfad67b512c2394c377ba475f03104cadf658865499696d78c748e6d9bd3a16756413aa1123f421491bb15d54737f2899e54b2628af9cdc586615302d18db1738e6621c7f91900dbd28ed8c4f5b0dde12ae6712008ca50824e68b295b0a1a2957a861f15f58edf8f72abcb9bcb58023488e2bb1b7d6274ad60cfe8770127115876c5168866bd434a697e9bebe81c77460dbd247cd904e868081dfddf895a0b7974e7f388ccf09da7689daa231df8830f0d38f72a62af9a1bca3cdb9d49f66d4e59fa373a0ff1bf80e7bb405c470332ab744cf14904dd0c60ad5df225fc87345e59d4b1347f3eedd186670f3cf37870570942f70ecfafbd015a4837eb771b0cc7516e22cc1520f84a8d1c5812f3ee4b55d0249c103c11b27865771ad7c0b46265400ba1664f04adbbc095bb3d477f8794430a28de8b4bcbba5ba199bdf7a7586a5478b0606121ae22380f1d6720c4c2b66b16d750fa9ba41f067ee1f549e33e9a8fc84c0aa712091767605db6ae2b0df674e3f3bc8e773722a86a913386f080e7f19fbd9950277ec4a2a1fe1a48ef64e689f4434289a4304430e87977736bc17138b672c2c31e5426ae07b6522afde90293dcd295945de286948caaf21680d496f68637023c9d3686abf4eb067e02235c91b5634fe1155bf0884209e38d708322e633cc407a356080cef5ac24e387b8965fa41c3e32bc66fb830dfcdc1944d123c2fdd5d7cd9c8051832bd57ec44f9fc088b4e50c83594129011c3210709e57a386c591a5d403598a95d2491854b83258af8862c959f2431d5a1eb80213c65a358e8f0f3ab62c0f993484618d6489e2c843da1c8d94ac2958d99065979a97f1e9bfd91dfb4768cce4929bfdb416d4400bb2fd10fdd10d470c0a6a312a390e618a29f4e6e42133846e790ca35e338e42275cb171c0ed75e78c382f2ce5236d53380da78d771c199cfd2476db3220d8ded15db15d8d14844bd1d8549dfb79d8430dd40872b673e2c0245c1717ce0e52235cc0701d4043cf509e52a6deffe10f39616760e817c8a796c3556d241905cde43257f4175e12f40f05e8e4e9ff8e9def5b6682f6aff9cdb1a82008d6624faf811b786260066592f6f273f7bfda8a42df62a47285990cb23198c96d180a3f8383c1fe2b38ecb5a0d8400be32fa2b48c4c435e5d17563907248b3c8ff97efa12bf0b01a496bd1e6b991a40e59545821dd2cfef9df413d740b6c989b26d4bf9041ff35d1bddd7ed605750cb1a8cf998bbbbf30b957a53f8c0820a9dc81961e2050c82ad9b4b79b035f93a6cefead2b79e9f13c758b6e476a08096e237984fde1dca5f840d216d48cbba30cf36d26b00e3bde33cf8b16261abe19824a5523646d323e1666239125d8c24ba7800bf2a85fabb9a30c7083ce3542546253d6e330c81d5cf3f4fc050b6f9fd7fa08552f73cb2ca20810a14ac35a2589af9f43b76f5be8aab0beb64fd95ef6a179a7b6526a15bdd2d19d1c71096ecbdfb12feb066e9d52b7966dea25e25b9ddd2c23dc22034bc50b88a84ccea8491d5b96ed9ed7a8e8b42e24b1466812da10aeb31f22fe4d5e1103afeff35b27d5983d18cb8d3f6bf9066921b449cd7450d603e78c65733912fcff4a66f831d125e8e55bfe0f71a481c646bec1c953ddbc6d5c5203e66799e2c3f21d24338a0290b73ba0f4e3c7db09ad8b74407846161feca390f4d0e5bc8edd861676f4564ade29a83f03df251400117ac9f4c74018f0f3498a2c168395a97359adaf2b409adaab6ab8a5412921d3f0b79a5940c2470d79d32106a76d8dfa427b8ae9587f8fb45b04affe288d94d747840e22c86bf995a840aa14d18c68559faa5291d57f05a61d495df62897a07deb331c94cb695363eb0a4c62f9c5b41055d715020835f4002ee5d06af3d525ac1483e4dceb624c700aa104788b03de9154dc399040dcbe4dc9c33161f14c7993535b5d516b9d8951b62c5f4aea991d58dfb5b93b0765ca6772688a2ce4c62d0ac88fc209be95a8156a7eda7b334d43349d601a8625a2138ac141aedcf699cd1004834cd4ceaf9bf61bff11a0ed32b4c06e13afc41f0f4917dbb691a8eb5165a6f76631d0bdc63bab1f6d872d6c085b36aba64c45f48c43f622f58c711b2b6ca51c990afe484750464f9e3511f91868dea22d10fe8f8a35f0ed347b5b80105359acb3116433f2a74fbff4e07203d778f0b117f2cdcd8eeed770c2ce488c3332424115177c827cb3fc2c8263fc2bc018c27ab3995845cc46cbaa6b0e5b660233b819ce0c0b4d0a27cb11e321dc5ebe07fa8d0db0ac8c8c01b0f9bf9842b15334029dbe2fdb382907c2e0f3e5e405c56c91c55b5cd8ac083ca1cd41407705f04bd37fa7dc1a51df8e3083bc13fb8413f2ce5cf92bbb0dab66989568c5d28e9bbf8d74d78b91b40a2c847246c04d582229d2cd3a5fc5d6d8edb5aab8476d3e82e099591f8ecaba3c1a2ca81bc9c5e8ca038adf8933b14fb06d92b21bc993e21effd5c8f41ce33ac093efa50fbf2f8c5ce71b2927e88571f843c9f16ca206091bd22c371d8fe315abf75e37a2307d110cacd988fc94d419b0b696d18bbfddfb6af90fb9d06619ddbb7564fb64abe81fb002357797638f9c295b15d1de7030f6fe1a66d2c9edb3cc3585c9c7f721c766b271671b9d71b38bc57feb1f8575b4d83ee52d7f588c51f1756abf97758da0bd8b5df237713f9585cb0bd13c1ae5a858735c98753c4f4fdbcc347549ce8e7e00d60fc5d22f4dcb62ac78914ab9de35f4411bf12395e2d4165d99484bfc23f3204311053596b57eaa996ca1617fc980e8b52cdf3b5ca8c2d3ed08df5c800b68adeb918ea4cccdd73299a5643f3a67ac8ac64639d9e4b73a5b4cb0d92292cb159b8e7d78fe5e45a795133f5900e90583e360c60dff0a34a4f91d7983470f5c20f4156f6321f1317a6f827ef85d1156935b56944fd8496d1531efc0fafb2b7b725518747ea11b68ea5e2afb60c2832697877558956668515e3f25f85156dd75ea25b40401ff87059ed324907587bf96384e64b1b00b4a9a9cc07eb0c231d04701c3b1e13ab22c35975a18a012631312d9f1e1a39b5ab6256129c91ff4ba80cf0519bdbcf90f6c4d53c7da5024737e807a390c9337cdc2c1644083ebcb94450dd62d5bb4d5fb9bcb8d76d04648c04e3f71828e4d5ecc3e934ad7154958b433e050cad15b82e4882870828627a22a458d61d29333bd10d6b44ab2a815dd6f7fb3d92f480c09f259421def5de5b7c6f6dc3b34bff6e4130b63f6f7b5d1a663d507e82688691425efdae22f44bdb00aa8c8c7388092ce640b5639ed07415566263c4495b19752f6c53bd47be362038d2aa67c876c62b43453a94ca71cdbda70f9e8aa616309cfd3652a6152121f9bb48c31c157f47da75f8561ddff5dd861edcf332c92bbf818b49b647b5b08a639d001bb3bd4d591a0d3286df192231d5512cbe2fd7b2f5c0ddc6e0c91b59d392ace9b9c65a83ec3a758630c7ff7e7c71e2066aa2504027e5e0076f3e8d6ae087393f6ce5abbe0cae154bd6f08c808bd31aceba0a89b41b5b45ea511a7ebf0335fd152d29c06151ae0b6d7c25e6013e7493cf1103ba7adc9c518450a31885c2a35e6654dd8611c75a7a1655cd4e22b78f80cd5e4727b383b2b8ef1a73fa5b9768d2a593c4cdd1161cfd455f447db5fd3218aee45b0e65464f76d0951cf29efc369a24de7712f583b9ed325d252bf213ad2def7313dfa23896e011435d723b652e02b09bddce5129439946f67cc9fdf0c217eeb6521962bc9d0a3e36c63926ff19ce4edd224681dfd783accbdb192f88057d698d835686df46e70726c5764f11506934c86f51ab84e43e836fa171617d80929ded56807508447a5301b9ad87df6ac6ad8958aeae5aa22526c3593fac3c5a77d0bf72a8a0973ab048bb7500bfca9593c600bd4b3bb7312618f015afbe44d4126460d3327312bd5b313dbade7ff7926f00b780bb31f59550ee61080275f9b557ccdb3a8059f576710bfafce62fe27d426334784184cd3eecf03d5877b8bf7820365079141998fbded24d1f97103cab93a9141f432d7c2f42b709e8e453a7b78cc56c942e8495e525ee1d8c5cdd67511d2fcc0e5fa179b6a92df7b8525347f8cc7951b855ec6834d73b914b849d9b00f70fd8bb7ceb464149ad4ed42f7ed089b07ea6e682490f61de524b3c941f6fcd392d7830a1a8e73a01f319f6f46430728160df5b3afecf6a7809e8b89eccedf2fecd0c97fc0d537d5db96dbff125c7abc38e615a348cee850a69ba9de1ee6a4861f757bfd2139b3e0a70726e64fea4621911b71a2a23ca4d6576cbc266dae9950ca54f195876ca104f65369a098715338021d7e9708ce3ff9f53abd8669c815f26cc75875d964c72d575a9322993eea6c183aacc9094385934dbbc8307b252ffb28c02e52fc6578a7457500de79498195ecc3f57976ad86325025e21558039c5abcf66ab312bacf091f9f1036a83b79d5adc4463d506a0c54ab07bbb122bfe1c0eb4c2785ef5564f29d3f745f6b7a562c003204b0137802843bff8073cc9df28c6825b72924e7fdb02e521b92205ee157e994abde23414a08253f6eac0826e3766e800bc934d815df1d28db9ea11a220bc500d38934bbdd97cc47a3d9bc7637ed158abae9de807626b6fd743e8c44f75950dc09e7c0fc4d9a537da28676f0186b2049b11075afffa2a3d7e7651e83d135d71c5bcca7cb56ee4ab0f55862bcb3ba3698a04c124f18c9d345f355e1c584fa689e79780732b594b5e0ca28066e049f726c851cbebc0a4a86d338d89f497f34ae747c1dc7b95ea9df8dd9ad74ee822ce0797c08453f6b6b2f23c52e41cd20d0251ab2dbfae022e89206962d45be3a07ad57de05447f4a2505120795efcdcb879c0687da8e3e365815417332cfb8928e4440a27310ebe9c6d3af0797781ab7d11ec3eae5bfdee5cf37052e016ab20bcedadc10de504d747b1c7d7103753f7bbb25114f67bbcc15442a479835bd42175afffbadcbc93445c21fe38787ed78691591d94c507f84608be5da6c8aca1a6db9a2bcb408bb5e6215944d941dc0fdd666d8197a010f0ae23fc3d977fbdcefd09af2c0df58e708e17c1416b897f77a1f8280ef065b932b0531a91baf5abd65997206d4e6b2c6a56b4f661a08a0a16b80fd78398d24ff8ad2b5b754cd1debee2aacde391b265aecbf7aa8b076fe94bc382493bc1a4bd0b1ad18dada87c5a2bf01b6789df7487929efc42f26c46736db365e97d5c98e08ffd0ce304194731c58f779627fc9fea4dd7b2f9259159635d40385d89d072fb994ea07334b1d84f14159357accb7e7265c963ff064f8edcab94beeaddc510585bc83a97581745416e0c66b29609063ae63bb5e0f0a4e4cc604b37ab592e4208ae67e2030d6ea3560b7be9dcd2fade306f97c31a95b9822c09fa9568c3560fa3be7e8fc0f019b4a3c0906a844f0684b62e791f1d49bf9b07521d65348bc52868119f338c6f567609213431f32824ed312e074a549dfc8dd02f1e2e307f01a555171e7b38556839b31745dac0cd7b81ac2fd2353995c48628b23f26d11434c68627f6ca3ae66085fe51f6c06afe3b58168880c2ea676a42a1f0ead41295a8e774a2f9f42ccc4cb0a79be6f1c1fbaaaad503b1b7a3a2a671db14c896bab5db63657272b94b8bc72af45223281b2445aa33f87c54d6d972314fb118228c3ae047da90f3a20b184b60335da8429b6de9f1269a753756d020c5954ab930ec07bf82b9808160c3cd8202e09de492683d00e8779e3eebbf86003060c730511f5ee6bddd52bf267618beb2b50d612ff440123ff6e40d07b4aba4ff57e9b546ef8e581401cfcf6720bfd908791049cd992620ec7e744544a504756868828f8caf6ff95cacddd71ff661f5fc067793dc57475ef73f6f95b747336a2809e81356aa4efed31f56b8fabd0d2d0130478c74be8a0df61ca8436e8d533c9a45574f6e0da409b9624df871a91bc5235e2e5b37de7ebb30288aa870ea113a9ec94b058f7d3726db1a36031438edbc2c9d31ea53feadd0b28d0a782a9c793535156e7fcce6128644154e4861bb70aa3ef5ced8f33c0797247e602cf54eca100706a4bd75465e603cfb8dbae87f1fdc283a66e16ab68f4d158ccd709bc0a822ac84fcb2e475d4f71f82049411e80aed3f419c23bb883c7a9c93d536e36e7c5817b6a5b657c0e230f8da54fd3f2a0f6f74636ad6cfa37eb21d710a9cb8f8440cc34fa432e8ce0d9261c4993cb8a7a578ef3a341d5658d3ac3dc94e5d57b54009c81c3d3997eca32a552bb50c51091e56c3369190ad111fc17f66a89ca382634adaf74c2b56b2e3e75ecbe48e6094e8b9a68eade6b51a1a2a0fb6253b84755c183186547f8e0f47690c3beaaaf453846c5127dbf60709332dd92eef91d65d0309e7f5f0cdcd611cf61373849088124742128612b03e7ab631e0d7061c6421fc16849bb3ff4a73c959dfa04eb814e994253bc17d4c6f262302717dcce0735b2d13809a69a507af6f46932feb4c5bfe977f24c20ec8393af47a17a918c29808ee1f1c4df35949e24700f51b858ef40b82fcd71b13147c274f4b486292a53d1bd0a02a2131c67522fb4733ea2c5bc80629ca48bba642c22df4e36fae0922e64fbd528f8038a521c098546e50889f0ba46ab15f9fc9d4b7c5d8df8623046aa1a87f157eaecd2e146973cc6832920ac7b6584e547f0ea4eef0a3ca761499d8b05ecea4cad6d288b62e608f01a0c468382cf0148935e1ec959fbd3ee0ce9364855fae48ddb13bf9e78c223cd1e5d79ff086ff25085137f61b4d457faf31b62fa743edd1115210f6ad856851a8cbe60ccfa0d4a04196c03131f64ecf186d5cc28548cf61cb527a65f49c0e2c8999ab2c43d985a23f6dd5f19a51d0c1131f3668a0ca382a950df9497c473ad68c0fea721235eae71b182f7797a64e0b6821d18317adcd5ed5d3c3f7089f2b8be0cb3d1796f951d9ace5fa18926daed1e49378f5a1417a7a97e2911b9015040d76b0aa7dcc01a761be0a106e497c942e5436fd1e798fd07c3d5e129c4f1bd35fd2a2226082de6e64b9810b9e6cab93926058a0cec1924c134c84445a254aa2c41d2865ab8aa626f8048ae6b68faeb05883304222edc00fea607262443e903eff05dabcd734663fe8b4eb5305ce5d7187ddbcecb81e127f18aa094568bf5dc974057bd756b4936ee0fef291e678d5b30f5ed1c717dda5c9bd2a2f632cf6cba0d0730951184b6b1f55f52bfc0a44dfa1e16c2a94bd2de9422f4d852f7ea65c4d1944cc94d8622fa858e29731e92c81b2090cd46f1ab4326e9fad07eb9554b21276e73ac90af127312831ded5408f4d49c83b1b8cc8e08a56a706b0921ecaa45eaa8387e338a5418bf217fccd929455f80ae671423b78dbd584086cede0ea7e12efede4d7d6e13104b31520bb9637068f39c461271e551a37652a5f2d0261bef11acc231570b01fabb3ba30a91f489979cf16aedaac759028cc2c45429e2e6fe57628c8d039ae91042a4ed3bc4c0b125c7060831b98d8446747f6ff6920b2c23303a2835d0aa16080f2dc8faf3fb594987d1e28ca32c91727ace64760da1fa55bdae8a9bacb43e8585237adaac5bbaf9b48a6122a4d369b7555d060adc97787a58817edb4e7b0e31e5a6dbadb80132a492ff1c24272b52a789ed92a5d5bc323aeae66be73d44202843d1b01f3ca67abd18b1a2fd6ff1be978e5a6120bd12aef669c838c8fe13d3406499790e76df39e499eaef854c7827284099bdb0a14f055f19506be4c510051099809cefea2781556af7597d5dba1c327a5488d158557fa930f8ff1a7c58211f02a1d41da0751c6b0914f7482b2f757cf7fae4de2126bd7fe2fa0c076c67a8ffa3d75343dd43aee65452b0025a661cc7513fecd0832eff1e3d9f6d6b41c08813f82dde15f18aefa2a6633550bee2eaa626b03da0cc73ada5cb6d841b64893f243ee35547e2db1bdc212405c5119888e18368585e8470920e263d3aad46676d91ee8c1d87361a789380fdb595bab46810d4c97e6d858df1ffc6f26321ac1771676b5a2697942dd2974dfdfc5d7a9d562a023af1a9145bd30660098370d5e87787b3956f02739f7cedd1b168d2f75e1f14af26118336a520fb04bc8bbadeb5b2c378033c0ff592695f7dfcff3c87328a8a92a464b5dbadbf82b6e7808d649bfd8bfcce69940b1c7618908959132011a5dd88270e8ff4265bd515ce6075a737f9461c41da41f38011923ad9722c7b443ac6fca5e95ca540176bb66a420090fe4db272efc844fc3347fec2241c5b240f1060cda11c7a42b9db2fcabd7a8bb05eef0dc30cd260db9fc37c629fb441852a93283ef7239aa37d508387452760514cd298b902a84875b710f706d5c1149afbd8aa7d0e1370f8fdc7adb074aebccceb11b1453060a20a662a6265b2eee67f08f283430c4d5cd415b0f21963a75f4f63237a86fe480aea77bbb27f3b811ae5c9d8bed9ddf9adb23944a5aa4f352e67f6cf788ad3cae3e8e9231e4b4853c32289371ebd60911d19b0358a11a3e7167234398625cd9f0b9a02c5d250dbaaec1e52d8577fa8c8f8942cf3c32df305a82d7b013ffb81cd87022f0783ec009d6fc3afec88a90280e93b123209e0b918c3c50bd30ebfd0b1288712f73f804da64fecabb93890b316cd37691cdf4d9422a4bc075ce8d611387b3ae7cfcd973728ddf72c9d79d0a718802857e866f693d357e646fd23b364e8598adbccc210455cb80f5e667170309714c77f2b6eb253c14c62b0422a4d376bebc013d4d66490f691dccf9e833994d8a62ee9d902b57336da9da9fea2a3aaa667f20b5717f8ea24226929bb3d619870a00e723469ba552814ac2db4b3f9d3767a02a33abbfd34816084434f17f09effd5057c364ae3a1c82ca21dce070206d69261c4ed279a41f50e23b28668f0c183f2767025fb1492fcd1fa89f8f6e7506debed61725d15d8ceae3a48ca69d468a4172dfdfb1f88bee768a3b16220262c7d529ff5cb6b95473bd9cc4795864781be82ce052a03df64c2b1a31f50e906028446a522062ff7d997dce4a452f7b7aaa343494c6da4ac7f1bd86865881fabacf2b72d5eda47f7cd182c9d268653d608bd03bf9fca2f65386b32da4d847375657604836bb5833fadbe46051e67fa840d459dff5b67c126d4b3b14e818f2330b0b5cc0c65fa76a72228b8af7fcdbe9740f9879cfb769231b6f141eb7cc282214cdf58383a65af2340c0dfea23151724b9b23f7fa4b2956d8ff001c83e3ca07cc1206365cf4819714c48c72b4d8a27fff1e0e09bef15044fcf7bd0046922948a282d8db6a86b607603b1949885ba9f1d884de97d2adf8800217a64c44b109c2251e1ee6af3a3719685fecc94624a84bc7c47be2f85be42a5b7553de9045374a31e7b61c23d37e1633351f826af7d81e2fdbcfe229d46026bfb4a6404a062c68b565bfd7430f98e5717b43bd24eda439188961025090a15e6aa67fa602f20c0c59687e92ce3c609e9d1bd7c3572de4bd39ba7f32fd649ea5b0655bf6f8d74a62f2c8043c68fe03c0e90429610e32585e834a609b9fcbf212a951421aa550a058ae0db4940ffb0e95ef5e077ba0caeb52505c85eb4988533ce6de29f4374f18bf5c26ad050a0513155a582ff0bfc392e4ea4160e1c6ced250fba9e55caf2667e4b6a1e26710023b9f673f0a3c773d2cf45138592a3cb83dfb7de5ba6666173f85d6f5a604ffb9e7d005c177e64a0d3acc73c3c368b4b1066abef981bb6d937100681cd4c9f4c0abf3a67aed9f17ac6cae825e6bb11fa39b9f22759a5289933fa52e9a41202cbdd49e7f7b3f3ac06a80ad2e6d740d0fa6ec1f72f2241b948cc029b21a884f039f359d4654f53a87600ba3769cda6da648012c20ae458aa354c03764e0fc353c9622336c0b457c1b8ad17e294205b22edb099dc2f2e2041b541e7b7113847f4e26d787bf9dd1be5ec38e5b63652ff67143fd2af495db63058061dfaa2a7a1096ca45a2051654547067662b57636299d6897ce3c6532df55a53c4fd15b5711740896090349b6e3a4f939e17ba4b816aa08e56d7266c6884596cac9e933bf78bebf1e834cd6b14038eb66e21929bf691ea57d83fc1fbd31fd4773b6d8bbc283d1306010ea74331f84075c9110f1f386be8b9718ffb2522553a53cfc17e4a3b952f1e13ce72275b0fa62aacc098961b38fd2c1bd4eae069544cea9a4ff672d3f648453e924a4b9831cd4d78e85b3f7a9d19d384c9e86f74dea21827ffd25fc1c806adadec7db29b42d0c4b6ea0517a6b80b9ffa1f23a5e5fccd4c4b305c52a76f5ab439c0f2334f60aa86634a0390f064cab8259d87992bb8054fcbd72450e088101a97b8f715a09dbb49506fca28175acdffc25a08943dbe2d86af2bb76de077d8f89af73bc5895a2d63d1b9db09d89e63056d32476c7eec2bb472b483d380a05f70fce08275a67722e051b954c4f5baeb576df385702a560b878bcf91aa89138d2b79b397644fcace9b14349627a03dfe4541a03080d2a91b27a0b343bbc5f3d1284526021de1c1ebf2bf281867d00054cfc3827420fee4898d145dc2e061ac7d9fe1666063e3950b924ed78574205d036ca48dbeb5bac0348adc0da7b22d0dc3c9d5d7075511ed3c9e76d9172777077603b75daaf1007d70b6fd938adfda385449ca505a5f4d56373c66431a737cd3f9edbe9a5bd1a4fb559186b482d0844820c17910559b23775173ba680a5fe83f2ddacb5f489e4a2f4e6d3463e3d6e0103eb560a1c4bcca972b3497e50cdb24542827b5b561f21ecb8da35248b23af0970a33be4513c5ff58858e96bd7ee3880c10c874f28f04f65f03568da577a1aeb5197f3b66d01a8cad1984f1f91acd3c470c577ecf4457596d9f5c8bc3f4dc0308e265971a21a8aaa3b3f30429e3f62373f8d0a83232372a164949ca1fca3742c99dba6c1303e667ca815f31bece2cab1e0ea14583af3451881f929de5265d07bbcc7e11c83d46b5ca5b56c4740b8c0d46162dbcdca8a091f088f89d2288d23ae224a66950570d8c1fb5dd39d6ee3ca3aaa17df5cdc100b8fa982fd1829160284096d5325c2ec4c3b6f0b5da9f5406fe606a309ee5f0cb4023d86bb8851cb18987e33b5dc944e5e02ef516217d5e6bb2893bcd044840cdce7251a0e3b112186b46abd36976e259f3906cc094da9240a50934b92341c8c4ef5ffb1f92f4e7658fb7e8fb2c71844136667ff5c081ee051d0d472b33066a7cad332aeac4c6881a92a0a41b6616b7cc0ae6b60b1d5f5fe05c10195a183a1dba08f321ad2f8342a147172851a31585e2c0c72a5372f54f2cc8c64a262607aa067fc1fb259ed84b425a4748ecb49700c6b2591d36770f91b87946e40e5e76015e30ff2c499e4d23ef0bdcf6d9394fb5cce2cff7161fdd20053769d6bbb3bc96e98a12c8da5d2a28d8c8b30f55d424428eb0c33550b025b630e40ce989fc4aaf7083007bb4e07156c12474130be5fb41beba657aa5462b8e0081beb3506168f36f5e83b8a7d603494c5ae6492cb9949a0848c59b6c86657569f32879f90d47a835922a324d6b17c5218eba47583f2fa10e3e489615271a49bc2c0f8122d571a7cf0d6319e67359fba91ef16e6ed96c4de8109456ace6a89b2e37893908dff0115c82efdbded4e50eadd9c0c8f82c94905fb1b69640d3977875deccc06d11fa519d24c0c3bf9726bd570236be5914fcabd699aa48e686a206d6ac84db35bfbb08e0a200262882ccc88a6ca00bcd8d61d427b3edb412949dc641e383a34dd8d36b84acf66ff3403b4ddbced68b636138640613a54b05deabc88c944edcec4d3be7595ad12c1c78c3c1f1a22e0095f376a690f6dc1713b37b8fb7ef10cc0f8670901cfe3294aa538733db98f36e3f640a9dee015c68584f50c42a8bf3ba219a2b919523bc7a9801e25a4baa04b11dd5d6b80e424cc55807474a56c681494aaab4c60134247ddcd78970bbe17ede2ebedf4f628374a277d05d95570bdd2d837f90013d289138a1a1ca3908b0a6d509e2af9e19ff2374fb70d0377f837e57e54c63bc1555cb2f776700852c58e7956d37f2287b56613740dc6b896be7650e7e2a960c45967608b38241c0b73603f4f7bd43d36ade769b3bf488289f972f076869b46118c6afb401d5989eda1a12dc4f97aa5a119b19ad33729181c3f82886cd10a9c77279c655719dcdf954443f8da9077bc0051038e1598b38bbf9d72105c72fe15c2095a75f29f0ec4fec0088431989ca4d1eaa9df999ec8fef9950a8debee60a3c3fcc67723ebcaaa8545b1ca7f2728e0d9a02cde230acd0ad742da7050811e3ac6b0a94165ea42bb51c025ca499d96effcfb20d80301a7d0a963b897f3c9af40ce154b0a9dcae23f0d4dbe98aee52412296ca4d21d2d504d6f0614768617f5b4b6098c849a9aadcd6e43ade778a47de19f890f428937926543933a5df8d179ca93a03975109a91c86cfaa2dfb308894a3e413e162771c1af436ea34d40a2b9dc98008b05b9b6a91d7ce673e5d7e0f91168f119a4c14f1c9453a226a2b89617aa23ec4613425048a4ea1009008473eee7cefe181c674e21ee69742d6ca27f8572c020c7446a1268479406c0a98403cf26a8694f8ddfb42a1d9cbed454cbdcb5577655c39203d3e5f106685a68388a53c0f4182ba3dd0c37b8e7141ea508a8f6a2a2fb24831130b3beb5f31a15cfbdca03d9cd2d6a4dd0ad6c8c49a1ae7e0445c3c15a899a24fce224990a56a89da457fc82390f7e61732715f6721081ddf1c9f183ec1b95c868f41946c1b80e3ef52721cdb67bfd42177d5ae95d15afa3c18f4b00648e50b6a4b6b31f829c491ced2be40ae0aa9725a3ab5d2086fbc53a6aed4a9c07e9ce7979b65314ae1ab427b0d0a725f977291d930edb8e65ec90ce0042b05c9ff71e4148bfa837cb1a20e878e54767742f02be6b5e96fcf87ff5cc397c7a74b047746564d092c7cc0d654d75ef508ab5267c839b682c19faaff091e0ec79afcc91bc73f29fa5d242982dc265643b42e4edb8951646f2f17ee5e2d4919f1a1eebf500531d951e4c86b1ccae7d5b769f45a31496124d080bc7baabad0ce30f79556ca23fa1bec88da6a0992533fe0779b159da5c2a66b65fd55a5d3ed8f925a90515a6ddbf3794692a46ef295c8f28c3e399fd2bac650a56ff2986177656d62f612c054f680f3336a5992fb5d3478549d0909daa1cceb6554274017da710b780b368528c20beabeeb2e7d38db0f6d845a52e42963deacdcef96f34982a43f4bf59f507a5e359e50ff597454e92c623f871a83c0eecc56366bf5ad70ee5cb9b3d1ec4e60e9ba86086edd26b9fdf7b6347cd92d664c94fe4820f47f483714d3ac76c45efb3a8d52d37d0a6aa1308309d62aa13756920915449f2fccb15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
