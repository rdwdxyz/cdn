<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08d9d422571255e8b4ca2aebe12db7836fa8de3514568c6566fd580276795519ea6c871c95751ce7f8feb4b5b25ecc950aa17f3cf6d68f147efbc83843df339a53954e9c5d82ebda2288442cb6ccf0c620ce37accc2e445be5265fb2dea7d44f6d31f89842790f4603fae242e26425f559195a6303e45ae26255c04d38bd0a017bff584cd68349ac19626d960efeece62f964cea2b46c46cf26ba2e830586ce321905dc10e8ff03567fedb6546beca3654e5cb0336a3375da6773e2052506f13a9efea0a077b321cce09b09709b09f925341f768e5dd78efdbb9b0e74557e47593b4c285d51c7828da4b8f7efac386fbad065072d357113c309c74d7b45121698099dd4c4c4c4eccb80639915ea8da59e1e381e445b5a369d372005a89e7debf0dc275f146f8b71abfba6509cd0cabbc8c373b88b603bbd94eac3a259dd5d0b5a3827fd11d55d07a9c82137e3b792a346daa1dfeb003ca1a0d4b8e678a855b908bcff1f9787c53da0b202705f95ec19e35e82116d3effbb56b55c2f2530e7f7efb961a4bf7aaaaa7ff6f85937ae313eb76da2b95357647d146a7bcd9b16ac0a7d273b81118f014bf47631ca5be77d5e5ba665b366eda25127bad88587d0c30299a09c7e81eecd95484a8b39071c0767aff7e078778f449eda81776b83b333fa31c39f21dc25e6f3c9a152889cd195f99efa832309b0467b446617a76c455a0d4e1c7206af535fc86e8a632b12359db4c71445b9202187986964e4ba218a8d2e200548e79eb099be771abf4ea1c0b1b2262db7a853d05084d5264ce7538291b8428a69e2d962c735b59ed7d0509d28b9fece5a4b6d072de6053db0988bf9b0b021d6d3ea53b1ace355bcfea7e80730ce0b69af9a9605cc2bf378bea4e3671bbfdf86cf813686a9642e5906570bb6770337503b1de20f4571b51df9f34374a333f506f2a927c684a4888dd44ae5aa626605dd464ca2a115f72d800392de8722f2e3027986e416946a8c3a8d11089a1c51d762d99e51af030594281ebfb6dbca67ce790d53ebffb8d464b1bf21211ffa329435d3c54fe40e2727a568006f304b1af0e0a3fb4d7df19fd74aaca015853894e52d1c988fac7cb23d49ed4404d3f64660520db8e9b5aef381a3e52c772275efa04323a16e9ba9879442101385c8d19241164bcc9c059d25b88a6677eb7c25fced87f4ec356907ab370264054bf703ca802a077238293b6b70da6e16035ee6a72d8dc5bc4e343827a9a7fe36b2529de6263d7e25e72f3f0b9f59baeb790c5f22e894ef594a03353bd41b5c364cc7b5942ce8b07885ce2b3df77119163d1ad9440dabbb3e419424cf5cfcd0118bf5c5de7488599a250bf7e4e368d9660b97b86a6b13c2d515dd072f75f067c76d3a3c5e5a76854bf73acef5ea5dd78902241c16e84665b7648e530ef36bfeb5b102ea2bbae441cb641abf9699adf4d205eb574cb909135fe1679f1855a16b8e52f4319c0a98c6025e155fb35f681944d1b55cbf4c72c8690d6a00751890d7228d2c0e795d05b6931a4006259fecc3c0179fb5c07bd3c7430fdfd6d0530aa297a6332060948a9b59927d3522914f7eba6df5ae661ec7bd8141eb36caeb7d6ab1488a9f5c2f09f89f739360c59ec7c5cf4052bd9b667527a134daa4b5cfd7b7eab2a72989030c8ffb025a147bfe30945ee92de9651740b2be1645afd59af678db0d7bda2d5ccac8fb331708211b6d4371345e0d8045e06a8d6188059464ba406e82366b1a1b844e55d1129dd157429c26c788bfd9fbe340626ea8662f6239d94b1ffed7cc13744d47f5abf971125b9e4fd3f243e1ce1bab7cecbe0b3c66e8c50b1b820e78e2058b02245285575a2d6342614b9436b6396cb3c0a958b8ec060a3efaa26fa2fcf1c3c7ad7e27ad79fa1dd2da43dc89a4d4c9bbfc5d1a2449604ef255a8caacb286b528a15791dae84e862e68cc0e9689b57ebf0fd776eccc624dad6e344aa66711f201e2a17f1f37fd2baf3be1d725fe35ae5a75827a3432f1262fefc2a1cec784c259f1fe001a1fc75695050c1cfb12cd9b42e7c18cd1b0e0e05e213b402922bf62338f1b5eef3b9bea39ea5e88be093c9a672d8cfb446ba6d8b54b022fb3c51b39ffd5bd36c5f74ecf95000dfa2990a4b1e93d1775603f0683ccb8b9e10f364b7d58ede542b0f32e397970afadac3242e3bde5c3527b074bce83246b7e4276671669551a218a5f72ec6817155a15ec05c6f8f5245e358fca2520648283d9f3ef38c81ecc8a724a5fa2d36f90135cc59a9cc29ebbf40b2d7e0ce1822e1b56da08efc3e9f86c6a3330030f3816729fb618b9b1fd9a6d3519a8c9aaedbb5b218d7224db2a2c212d1993f99312cab6ef9355e247fbed06de01481520cb239e29ea5227df60f70e2553fc0d384a9959986aa28a7dd599cf4890a7fe954a53e04cd946660ce53daa048040a6469e092988c4f743d3ab265611c0693b43796c5a9e0c45e3442d5f1e113f40338da4e74bc84af011ee35b8ea2fb4cf1a9e6cea37c2482cbef9db70615010073613e43ebd8050a0253caddc49bcfaa33720429a8c3df49bd8e21dd4486c1454c5ff2a2c830d455b116fd6082490b1f9bb6a06aea7e93d649929cc70314def2747974398cdeb88d6a9ea771806498b9826006d498c17648b2b6e0c4dac22e87f84da218bed2ba5b054688e2a98969382615e4bd30ddbd44052a53032ee61bc3d6948d90357e20fec7a2772d35b39d9238e56880e578cfc7ac6d6c7c93e18ee452cc073e0001917ffcf5b69765a015e1597b2a7bc44fc311aca1ebf72d32c9358e13117eaa81f9a711d104a68524bdeb080645944e5c47c5e7d008bc5ac0894053c94135b8dcdba04591c0bae8d742525c3bc73542b9e5581b71cceab69a0655c163de24b6a53f2bd35426f5f5d4f4218ddcd3a58b3e56fccd162ddb8b0638a951a98b612ac03fe7e6129ea6069a090d2368024b26477d21d9e71e8d4e59ee658c4ec4bd17830bb83a6ed7000a141a9cf208a26e08ec2a55d9eb1a82ecdf7dbf98a0e1e4c3ada6a59e80698089bc95fcb4ebf7afba5848b923532cff1a9228066a919c6ee96f073fd245154054cedcf42a5fe28da9556b37f7c155113757e82c10b81429011484991dfaa64c5d0c67e8691bf38333b898cd3ee4fe3c7c283a846bd7070c8f22f8dc84741dd6f2dd2ef9e5543d171eb3c8841bad6413ae3804be7613f055724bdf0d9666981c6288ae3be267a413c9ff32940da561c7cfcf0c742e9adaac97136965ecefa4639840a0afcc29e94a4251c2c5b39b24c1d375f597a46ee2410391c3b3ef386d81a5a711757fbcbebbfde21a607da8197931f0350a7cb7e6d8ac5e3b18072f17a7b86dfced8777ce6410ed07ac06942361c5bb24eef3eeeeeb98b8942a5a97ca97e113556494121d94e24ec0ae67c52657f162ec2fa85f1ea8775386d1bb06713e81b3f83454ea599f4a70228e97982dda183a22eec66a2277e900dbec88aef678de8e231af92d2ea99cf29360c80f16231288d4707296d10b453b64e6a691bb830027b1a1b5dde9235c97680f72d9ada551fb2f1da687d3fcb1709945931d55827515f2b973371575ff837aebdd9ce40bcb761e674a44e2352081dbbc9bb15b5f175acdb5bf16c8f680f06914efad2bf62fde0d50daee4dfd8637945974d0d5d1c5c3e5c9fa8bc7cacc1114fded2f7e98280584d5f2adeba7106951f41614a2ee2e58b004cfef8e7eed47fea3562b9f700c176e387a8f12cd60e8a7411052bcfeffae7be0a5ecfdb63245c93b28e7739d6d4d0a748c81c3e2cb269aa56c8edf7ab0afc9eec9b0f1d0abefdef2ea57de472b07e815a06e6d8119e093c75bacc5b248a243c75bb9bf4f3eb71acca2e98a4a114c5fea57768bca93f1cff119a0428c162edb204e2e20ebf9ded8b14dd30b5f6d130eadc02ff15137d39466dd9aab36d9fc028a76b122a13a07d73a293c067dc6080246f269adfc00b16bd6b7226910ac9378afded58ce5505a11fe331cbd5afabfdf6fc2c5c6d70a843b84c4c7e7e0e75c206efb90e8fa76598b5de1b3577c71dbf165891f5913e551cee2b9c83bddb10b2d5b084c850f2db140dad0f566dc489366a3bb10cc15e3852ea0ceedf4126f484f0af743ccb4ecec9a8947d17fa1ffb1b0188d0f6623079d58cc7ed577cef2d9e21964db8d9a1ffb41c58fc2f33e334e6af2f11d577e394e060a8df1b961533403a33a735735003bcdbbd24eedd1ceb128349d9809f03f3bd158ffd838af89a1d662a7d703e1f73a5dba25465bc86fe59d9ba90dab18dc42b507e3141ac1d0a61d8d0d535279f09ade6610adc26df19522894ae86035b16c31eb2fbb4a9f7cb6451558a7c8f6b6365ec4a7088aa1fbf1c2315553c7ea1c75986370b1283c04bbb5b7ca7dd5a176bcbf4a43628037c234edabe85b1537dd2b26fd18d5399ab9d16dfe6c7d8a914c03d5a26293b01d8ada39cc11f45ac1f1f8097d286ccf0bbc641d201d842b3312035222dc3ae539a08a97adcadc639819c05dc05baa88b6630626a19164c1ed9f26b3835806c3f66f6d25d1a23b9f0b66241d2d0593a9f86d4c69f035d346c82eebf27fac997ee2c70f5a75e1ea0006e53b71b64ac0beed5eaa8f09d9d93832a5b9236121bd6d81ed8c73a95410671e12de588a87e1e9dabb95e8276c9550dee506be6d7fc6c3d2b4db240931848857c275a40dd88bf03332608c9607a0d8c7f4bbbcdf2d83d0b13e095a55ca66316068b560417db06479b9f09c7aa6617c003c18ff53bd65470bc0d9aa1ce2542fa3322aba6e035ab0dcfe4a891710100580de598641d2136a08cfb196056c4886854ce364dc496ca158b7fb8f81a05c36309c6dbadc714bf703882d42ea093ebc55ecc396369903b436494ff5b1285ba11a694e7ffe695cff44b95610f467f6538123cae008bf76effb9370c4b843fbc632f8dae65681614a2e3c1c3e7364b4819fdb2407da81b817379f72a9d7b436efc5278525baf8843d207d76f9b9d217b3469f4ad79f3208105b2359fdfcea47a567b78feb49a7282324cc825674f10cc0e29400a84ebf3da09ee93a19f2151ac594a45fcd917d5654c1aded959f1a9d92216e14a30be7c986b398fa0854e4e1ac828067c2113d5c4b3c242611865ad233b585c54b91b263f5147527046c633294a2b311dffb3e27d25d479f72f5f4e7d19ba2c30727c5d4af140507f989a13c7cf29e0676fafdb77f79747a21276f8abd03449fd73c437fb9ee1bfcdc187b763f9ce836295366ffe5b2af397673802ce8065a24b054254db558c3cc0a2c3c892c4782c6e9d63bbcd5c5d6bf234d6da37b99b5e58d3a1543853cd680df4b9dc8f28826f1015d94e01bfe6d0c366e051a66de9e7c1572681e61d33522d76063284159740a725abe21fbd04727e0320877bcb0497ecf06a5dac2eb6d23de9d071748592d57fc3a7c25d6248f4de799467bd32db2cb27e7cac28ec8d3a599b675ec20e73fd8cada3fa3115a45a1236a93a987d0fb3994c41f9e16094f65a17047cc77fec8c1ebbf7a6ea07eea13f8084e4c0c30cdd466e4e5d8d6b30711e7b2c4ccabae45ef5b8558e3d69d5a8a4a9ed8e78bbf9eba2ca834dfb5b171386b679fcb2e8611a839b0888c91d6cc8ceb50c5a9b0471ac1725a55046573e6952c80ec0503ed2a7c406be6bb34e767964b24ebe215854c93bc07dc5b6573f0e9caf84bde19cd743ea73909e60e739abe30bf1ffb2ad653401efaf5dbb4173ee44b406155c45ca667584fd05412b6025cd2e7bbf4fd002ebe2b9d7f4e1cbf3bbe9abe4488dcc85d223b062c309622dda6b51697f036d43bc238de465acc9538151591ced536541791b663f686cbb764154e086c4017f0d2750d0f51a5f50e85f57e2f7486974bb88d1fca1aac0d6ff47ea94e029cf740c1055cc4cc82b9f23f2ba548cecd554177cb0385b3c62f084cb88c5cefb9437da0ff25062ecebded2449c2998cdba5045ae3ec13c695f83e058685e2f4d4c1614f638f6d455d106cd38b0ef66d8b005fc42f74e7f18dc8941b8f1feb59dac879eba8ad0e4824d62ef179a8ed57e6ad37ac575e3f7bac616bf4cc8b386b4c6d15ca1416651415b4f141d1934e87dd1ad304a72d17d6e8f2fa92070507252428bb366c80982402b577eb763159a018a33cf707da9c316c3ce4b8b028987f9dc08958c43fe7f6eabddb03e8946bafd84e1d4d2b96b57dd31a11cccc32c1f13c14c84cbec540bad34186855f865419208167ddfd97aebfc1f2849a0973ac35945ba00e6e51b4b79a124f0a93c325692a0f7f670b6ca4163d93710e20034d7d7683ef15130f17f1d6a4fc361516548c156d07b88332ddef1febdaee5ce15b97f533302a3e61ceef41347b029a62776b9728795b816d32b7a47c41355fb25925c317ce294a25dd5b197d07bc276aa07a35ca480c8e71abe734abab58233642a29572c8c76a1b5c2dc88e6c9b91bf00895281549d88fa84b2cdb790b7b0868e276ff67c5161339e3e7174bbb091936df6efd0ae7dddc34de4bdd1ad848e9408419508d81b5a8315c4f860b85ec5791e4f07a59729aa12422609a8d0d8c0c700a3b30e0949467a9852efa88983923cd006745d19740599777db1197a18fd877fd0b14017619750ed37194da4ef06d6a303baebf942b629d16d83cb5380afd64ed09e59b763b17099c14bee488689e5e5d0663f102239250c64f27e0b1eb57ff397b2144db5a2433cfa6c99f6a44c88a8837c42e405df6292db4257699eff74c9d8b1319657e64a587865954ea5506dff8dcb9ebb23a000e2ee25a11dc96f040726bac37f4839dcc16b85a77e477c2de00bf3fc9a9822a8b60dc72502cf5818c6a9c1e38eff8b53848534d265a70e15e42282202b602e6eb2325feaf4083991a8cf5901d06818e30772760ec74244e727fa5aeca6d399b5c6d7a0fec6fdb062924716d2cbf68c2c9c0ab7825591d141b9edb186f88c256048733a9b9fb35dc6585157b366a4b3075bad6fad3a6b13668b95fb3a72c1ca5c6aaa830619f2239366b7a5a895283b2e641bde14d408a18ff770bd57e681d337e341b94e32bc153495dc356798cdc84cbf2e443787803070cc5e7713a1c2b7a1aba293181d45e286aa11d04923f0ad1a41ed6fc48b71c6ea1e02f4de13071f45a2ae8d36f6c01c743e4f52867e28d123a131137dfaa425b180144d8bfa262e251da71c7e62a779aedd19b9b3417ec27a1f9202ee9a8e6dbfc0877ab95c6a5b6bd571490b601e0cc52e8dd50cd090b885b90128f01fa8f158d4833896fb115d77ee7ad7c97f67a856e6ed401005dd7ed5ca20ffc1512f9a3257dc54a96736fd6cf966820f5392f4e42563a08d7b349346a663c3eca30e8814d9481bf44de8d6ecfb76391bd078d15c151544230a5899edb9b3b2d6157bc7516c3e5aab6ff55bb7f10ade9df7d746c5e801693de84ed61d54ea4b97f58232d45f52445087d39ec9f652a3c3994dd777e9219b9d3dfef9c7391de93c5e330d71a2c64375c09a758fe5dd95631c441db66632f88088a8aa5ffe5ea1cfda54adac3819809597666552a8ef7d045ad58847661cf5729fea9f09bf64c456191ecac43e08e14540ec64207ecf71f1ebfaa9ae466b2a09afabaafc485fb941332ebc27cdb41890c60791e83a570ac144dea64af21161a161ee121ceddd9b0f446857b330a357acc55fbd7725c75c0faefd6bf925258378c74a40f555612934bd568088313669c132e29ac935715ecfee6db5db3778230d74eee95a1db7b3d4961a8d956e3df731231d11a45466d4ba4a2187824829f9c8e7f1aeabc6f78f6b70b1c274b36088db7426b77c86be3819b8bdf6798734238f9234bcbbd36b272f4221385f9116445f0df0684d2297a2c470c7fbd9838d057cc2956223a831e825e6dc88e839c04d18dd8b96c8963f389e4f58bd15e3929184eeadd736d9340c969396376cdcf1740b5ecdf116d82610254dc88b31eee123fb9e8eb9a879219cd2190ffe12018f47af46a0ae215e7ff05a8c426a313fcc5347216272162c57d0c5d210a9e9a757fa8db939a380d33526a83034343ae1be9ceb3b5bd484b002b81ff92cc6351b67819508a03275fae7657d0fd71ddb0681e26eda22e04b68cc395605ed8d78bd99120d070b9bca37f5acd8a17201ee7cb533292536c6fdc5a38beaa3870d336bfd644886ad4a99f3c9fc2cea53d43e1d9ea8a09ff47d89024a5e69cf0bfbe25e7dbff990457cd919d135c0d9a0fd69263e81d5735615d5dca10c7a1de8ff8f0af5906fff41db503955e33fb941da1f4e7b159ead3fb8b073931b693aa7091c45b07788f3a95ab2df74efe7bb7eb180c90aaca4a0a136706c7017601c30e525217d47faa471a3d06f3a387c650605a2113cc90f6d728d2c728f528d18606e5eb8e2fa9027d6959189c5ee479c0c882fc9c50598a0e3d4ad6ed5356cf097689d4fac0c730c281f3ad8fc3eb5729c3532e877a38654b75a503e21263bf48bd5c68b65d63c3c2d8ae69f90602f293e33956cc0f74950e4661c45ceef5c3e9cfcc46fd47ff3dee8dfe4421a1384e5802be19da587a013d69d6598352f1a04a1fee30383cdec85a19db60d797b1d7a9d639a7bbaa38b3b218f2c862bf0c8326c55709b91e5443be5130d1cda4b7db97c656d18264eaaeb6670905d4fbd12ae10e3bb98f537a10b77f935904518e6f6b4ca89c330c07e9ba4b6c1ec91e30a6cb77faf305e7e7ffbb485fa2260582aa39c31125e88f44af1b6349dfbe9922bc807d68377d60f0203b224f6aac8e49172dde11cf3ace471a4c8f9d3e5a987d5617eb623e765f22e07fb75be9605bd6067a210f73bb38cec3ff594c89c2b76f18e43b017d9c6ad8276a87996e08031d654351ae011a2b2ec1e6180145c1f4bcd762ae79372391f6d9aee96e431bc53fc8aa94942e4524cf4048c9bad7bd34399014d2aaf615557d6127bc74e5842854fee2b4981aa8e596ae7a54faeeb4b5b2a08e807fae608f2441f8e13959570d46a060786416d1d1a15598df82150311502cc3eb40fda8e91f0830bfc10722a8d38301c16517e966c28a106359eb857261af7d0631c9ab013fdde7ee473f503c4f1170b755380d7640110599c42e49bdea891e0e701e506f8962e2f30d1777d8e063c99f6561f4da5ca24dae5718f286d136160e9480117d7cf80bef84d4c82d7ef977951cce41f084b717b83ea9e8ac4415c3c1f0e254fe7b97dc4691fe7fcd3a480b6cb63d61be75500dc284f5ce00cc752fcaaa64f45695a4f07270dd09fab6bf86e6afefb6d1118ced989b01cfecc5f0bb3d389304668f64aec04f5e263d1a17c4c428b4773dfb718a38a80091d5c592cbf2440c347b0f571192e50c091d86784d1cb8c497055732eabcfdbba6d7dd31813e97d83da2ff16eaaeae0ef36a7022b79bf2b9c55bc85930927bd35ff2aa42a54a8f3f24c0dc3e4d5e7416b36e6ada3882e3b8e31707f58945bd234f78e09b0fd9d5a2fae5616c1f26618f9ba5e15a8947cc29fe9993ee70a01af91a1cf2fd7d8aa77335f074af6c2b3013e666dcb4b9bd0bf09472272b75e7675806bc0a92f27c5e86c1a58db811795ab86b3a46596079f2aceb927228d25f534217f27e15add0e6691d380825e20bcf44bb14df961d58e0bb72288e520386f62c2e3f6c0fa2368845b77fc338c1194f70115a9b1057ccd2f455e95c8ead926324aee618904c1ccb9cca576364a1d0648ec328949d031389c19b06f1d700517a0bb7fab5f8cecd7eee745af788a24cc69aa256b8717aaae698e4339521f4051bb75de5e3bf87833ca919d9b7a377cd6199ba0d82d2e009bfeb566e5abdc36517406e017684480c1e5d2ea47d84ca1639a4d2ad3845446a5aed6de081bfcf51e94f32b13468ac5a2d6d473920060300072d450fdda72d4cb9a4982176fca9c0b85b8d954cb5731be1a12092caeac69547ca878d037d9a10c8502fd9c08e5c0371498a3aea3408cbf820b37145a3a84bed42408314ac47d2d9d733446287d8034b2d9f5b517ea880b573116684b4d8bb937420d0f4c8848db6f5e490c42e4172a2eddbc3c57ed6f2bc06b8b2a19a465b64cf41c917981070216c4480839d79eaf567f8fc0595ebd973c49f2153ba5f5bf31d8406db06518442c31c8a0161b11be639bcc7411a9ae165562e13e3e9bfa6f5cc95e787d4b51ade4a140cad1372e53143a09cad334796f50ffae044633bfd4b7c19a25bd041093dedac185f7d3f504167f784552399f1a869e0f6070eadc852022726a96b72ff5cc68c41fda5fac8f2527687f474dbd947504e6941ba1e2ab5a37f44bec58d8434f518df36f2d72c2699026210c20643d6372165bbaa1d39803839c3df0cf713cbe0e767d7247eef32986cd6d57e0e049693dbd64ea4d5162d6f57c3e92e1e7ac4ae8060c8a9ef5136d11248dc36bf3f448294f7f65c0cf36274cc287943afeb91fdca7d55ea9d7200bb060fd4d82f7f895903bea78da65a952a753e5afdffdb029adf2383980c68207ca6735773168878c3c77938123ebd88690badaa673b6ab8e3fd7245070dc99156b14195317067f910372bda7eb82e46ba73eb2b9a37dded1b4051ea00a4598efc63498037e467ac3f0a90ae1c87789eec5e6d40343955b1002c76e1764f6bd4e73de140d325a68ec3f85c0a7df9f5a5992bb6514118424c963fa16494eda7c68601c49ed1f9f531311c1c4a5841a4a68e638d2f3d4849f087d472190918a515e62d5ca6adf45944cb54cd90f88ab7ac53c9e0330e9fec161df119428abbc08c20b5a4304d4c9c53860621c6aeab1a9b20865621d8377684de2cf677446e2714cb0d61b450bf66791e83cc91eaeb78581cc0212d5743aa7d8d6ca5bc3f557ce265f298b12b33ee816a2b5ab0b5e3b44529ab04b350a155a43aaf8bee6f80aaee445e6deaa765646d9eaf4d9859ae0762661aae23c8162c9a893b9d4d4f8756c07ca305ee263a18756f20a5550b5488aa33626de81ff5b7827e39348e7a34017d1ae491461c51216697cd410b629d98f7eab6eb3171409a6516915390790278a34c24d3fee9d30d5501a5b836d7089d666cf23e77a82b2b8d89ed5b22cc54844eb70ff2da737ea5e6b1cd1b1a5404f8044171fe05a011596d053893c2d34628937aeac5146b3a53c99476d7615669fe13b42be4d2bbb8d0d49b0fdcc0706c13cc74aef3d65c989dfb2332aedb361104fbac2cf57fcd546e0e4a7ad3e639b68cb37e896b97d26f3249f19141114b6478ed3f92c837672a91f839fe057efadc70b7549e7d56a5d80b8c585c939e92d1d30def7a617e95d12950f7a5f973dba7ccdde3a0e193f3501d7b790b935cf1823584f3bc1b2f9ed16f0bd09ccbe6dddc4ae8a30840b2d3ca54cfd2f104cdb95fcf340de640b7ddddd338c33b0897c92592571b51d4b04f5a35dddf47e683f99047cf0bf7c44ae9fd4182c776a3fa5bd037c2afb20b64f33eff238c8d99db4d79d80ca5aef4fc2b2773074cea9bf2d928ef42c1ec3332eadce6bafe8670377ae3d7097748132703bcf90557e419740a8b18dae183eca34a500969a6d65adbc4d58595ee84859af29207c50c4ea4b3592490599b8418f687908f65ed7aaa2e2585cebba00aabdbd05d13d96313bc1e0509516ff738b2fd45b36917b52ab3f90efed51352a1bea80de92fbc1142460b2c0d753fa6d93d36a37d68174b06ecc4dd00c7cf0b8846735155b33aadeb47cf9f37e9087034ae731d4c44a52836b0eef644af470bee9eccf8932eb8df452d7f28b56772044e74589f66e0874eb6cd553d43931906025517addd0b6980c6058a29609e025358c35cb2d76868065514f38796f194570aab39aae48b08f75219ac29ad98459a829b4734b4ac3b2397329b9092e709c026623c890e18ae8384d8a0ce5e2f965700697d871f7c99954ae3536e271ae54f55ada490c9f62f738193175e0dfc80761eab8162bebc05d07a43b50e27a7f86f5a2b61587fffddcda2a975f4f8ea7b8afc6e85746e4ded4cd2f44f1d9f1fa1dcf1cdee0cc86ca1e969e5d4deed5d2b4334da04a7b13bb3c93619c64c7a6b82bd4620dbc089b9e818a7e247441b890e7866dd9a2c29039e1a82f7963be26142c3d137d890e0b156ef33bd503b1ed6b6ea6ea8207bed026a4c31230783e4fe2ef9b76cafb32d71d48c2b332459eb5bd13cf521d93ee5210909a930be1f0472bb85470a8803c3c6ceba5e4004297ce55af18722443b91ad090efde6bb72d25d2d0415d08334678ed223ccd2e291475caa6c9f9ab9656788300a521feb31bebab405e5981e49c3e77d1cb1ee5636ee6b484122598b79a9ad3e9e4dbb91e078d20c2f79f05aece19ff52fe9b7553d3718cea9f6dd08421185313f3cce9b0fbf329d27620a89c533bc588471364debc91a1fcf28abf1dcc7f3b0da7ec3e192330830c3efd9d6e38910ddf40e3364aac05414412af6af9555db5b54660482e76174d52e1b1545efb687b372aad42956650f041625d71c2082a6ffe1cceae5618176d7e424c9bfc40c54fff847c773b9e8e1558d91337c57452de7043c5a0ea105e6ef07fe604b86213bf97ea322c43abbd104519563b2633c76d4351b1f688200a1099f1f489e3eb5c7830dac9db49abc975e60daa3cfc62411e5a67bb82772b1937c1a9c99b4a49c40281046d426195bde9a1c95290b01721cb53fee349220e7415c105c34c35370a2583969b2a364d3543d238cb5f1037012c95dd44e3f2801279532006fabf9a89ba7fd485d331a3e3fac4d9dc00264911106e0aaa530adbd788983bf92857e9edb1afab13e2b7fb40021c40e2f275985e6f108029c63d2d26e86f201f67629dd1ad383a3331b9fb7f5d3988ad2cdab01e29fb129d06f1712a111a8711241898a5a072626a51fc5db6840dea211eb42d898c72f8309594a253547bdcab4d9ef208a40dbcfa8bb8ac53ba12621df3f034d0fe1a96ee19f53cfcf2b5222c78c741f518f604c9f4dfee73146ceccd89e6ee97ea003a6f36a50f966442a99d13031cf80ef79a619d1fad1e6c663a13f2dbd6773a144b7912815fa5140b1009ea0f243d0bd957ccdd1c46f1a35c64e50f3e0d6f51040e43f0a7246ecf42c6fd0caa5292e1ac7ff8d1b347e8ba5273a353c03eebc1a71c4aed5a71f9ce2ecd0df5bb37f0ac2ee7b47bdf1b2a81c82b4bdf97fc66b17ac2c11ea7a492eca497eaf00e95c3e66d99cf0ec9ac7fc508dc3674a6852c1369b80c7f32cffe3a74ec4940582d60a27386cf3956349864eb1bbeaf1957d1c92ea025b224c0fc4280dd51abd4d4a36884aedf10fcbd7c9a76628bff984395535b27863b17e71544f70afe345eb6beb8530ad882f5667640e1f684bb99cd1d3b1676f56b66fa916c8bdd201b0ee511f06a40bde61f69c0ffd8674e5c49138697b758fcfa1e6e4eb04b3bc67628e526bc1566aeb05798f962d27ad6722774237825a309ef7a86989bf0e67c54d15da56410455125908ff4b9ba70da4dc0b964c108eb84fd494e6afc7e31e7a8063d74962a3bc12791c4827ff68d431294f984cf41f056a4f1e174e644f3f59d0b81700bda4f15da54221ac2dc479ab5b5557702be38ee0264932dc12b58a42276b041288a1164f96fc82f3f678ed03621c938d8778e6d684721e9ba082b2c328e1daacdd3c2d12eb360686e06b9af5db7d02dc4549e29e58c8577e9009c8e290f0899391cda37366283898938c463b9099b7624a3a08b1450c54c285457ec6a57e06f89097e2ff956b39d2dec6fb36ade5eeaaf0a0ec9848cd50ada186bfeb38fd09c336e0726b007677b76b797a88ed496fa6a5a672937e9d63e5203a9d1a1d081b805f5c104b3808686f884ce1ff0d409b36e4b08ad9d6c875082419d1f731b30f543af5dc2c8803d6b6b280110c93222f3040209c6ea7e8eccb85003164e355998db0f3910e7733db0b3e543b1e4ad39448419e3f42f39492c9a1f0a8e49370058bf2c6bce7547bbe886d3fc477ad63a45e95a700ae4bddce226b8feadc705071a91cd71f216546510c44dbc7376affba37f36572368afd9430ec96b10d2aa0bb4488b522e7e3432c1f55de94fdd91a429d58c07385705ad246cfb5f340f402be653da87c991754ed3ea54ad135bd16a19a7486f3c0137762feb4b9f74e4923a63eceb63e96f6ebf8afe220881913c1dae2b6c4fc27ae1a03d9dc6adeedf64762e118dea654d9b86c9b022f119c94e5338e072f0f6e64f110667bfe5799577d14e83a4139c01e8586da68d647508bc81a287166ad377850aef0aefee821ad0e6168384862b2717e2df06d2567b2d285f8015d08e0b9a53784075750c2e38b69dd84f61a4f0884ff41a1b4de2d0d63596fcc98d9fc4695a4cf9c241d4a30c70363884b6b4dd90218772c0ccd78332ede210d0d37ac17aaaa41910d7ff616465d61e1e5264b9b353b4a63edb0b829105f060732a100ecea883e6aa777022a2c3da2ccdc2626d0abaac9f17bda683822441931e3f072b2c7720307c32567f98bc3ff761a67d0b92e7d93f20e23ee904f81cbef1ec75cc6d50722fdae73828551cf80c82c95c0b077cd84744ed819b4f54430af2e44b91112458f4100acccd0a76e0fb199349b13af4b510c5612923d50242cbcbee35041e87ee47af6b399042433f7709151e869a3779760eb8edba893a75dec246e9c74f0bc8f0f80c3647e5ef1b4eb3c841e562d97c01b9530e36b51bc3bcfccb470a6fb3d7e16da919f09f48e9db100580dd28aa1b89e06398f7551796c67fa5719a3d9d4ed794befd97bac304d9497170d72270bdd6d47b41ab8aafb76b1ede9329bca0adc44b6e4ce3af3e40f1aa8d2d384bb6d6923a728bf305f2083cb48c06a2f3eee6f67e90d01f417f9a2a1ffb30d4ff5efbb55f948e29cc59f3972694d8379268f369c4f58e2b8e1ec3d80cf7fb8d947e95403834f2d10a208a6d838d458d02756cc57eaa8b579f7286a4bb688e693a3a1c1e7f7efeadbdfbaf550bec3758ca6f64409a2348c9da57eb41dee8f35d305ae39e93bd0f282a38a1c30c937935565646a00b59fd37b3de21780968b124eee805df82b0dd525dab7f089912c6fca811e72e086350172303be3bae2cda9c502167e8adcf15c947d9c302895e935bc5b21c8c9ecf4d74065456f22fb512120721fa03061e4fb15029f4151dc16aa3c3da7228c47a2994534b0490304fa63b9cc6e7c98b2d1ba73bd9abaca3b134081c8a1b542ec930b4d171e357658cedb0b3450f5ba7decd1a57cc67eef2a2f0c04427cabb90d1bf2416941255d429cd11c37209419e2e508baa348aef5381d8acc5f2fc3efaf941fa2e1f9abc32e785cf655ed9d2d879dafabb72aa0791b6948c439e0e66e7b73e20b64b9bc4a512bc6c6e72642d07c4c8137961ff1f050935c1f21fa798553f0a947efc4bec06d5e024936dd3c31b137b9dea61f5e461f47be63027e7176f56cf21dd5fa6817e78f5abae14f67a2e48d681ab2c744201799855da9d785e4c4cf89597db862535ebcd8723d7ab23666d187b4f25197ac6a720381c69c51851f2d83ab6c50b57f8f0fd6e02a5441f752da2d3692867e1c8acc847d8e99b0506a59625ee8bb85a0b8d6bcec58cff660bb3856fcbb638d200d4385db371261d6d0a1a642c40834ec808056ba8aaad07de13d3cd0bd51cdf19744c200c281672dbd82d38bef37084b355f51ddf4ac1e491b19d5723c74af8e8c099c7816017e9dc06945d2497cbf2cdd7d7361979492bb7b533bf2792fe8ef6929050a27b5abf5def6445106932bc169df9959984d6f5c7aa2ec634e076bf1a59e771fef41ab4842fe89e208339e34ca077146b5322147944cd7f7ef7f9da42c476aea18dfbb1db775a5faabad0eb6dd430bb62ff28f6334df813610b1d4880fe7387e539202d8beaa8331720c1910bee6cc6e5c6d4b5869b6150b57e3b47aec6a43897548e397944e30d71ea457617c907dcd9fc333facf6bcb79eb64a9e51b574c1b76b958f0a677275b2e4265194d9b425e0fc15d41c9f74cae7edfe3398a031de15444d84c509c669b095e60769b4c729d51cd5899c7870fdf630092cb5ff8c3aa7845c991e17d573937e44e2b8a925cc12f9582e24f25002f8db493a25390002dc63fff3b9eb6111eefd2b2a02bddcbbbd6aab0b2132abecbf0a88fb3705f3115475d3d01d9f24cdc4212a00658f93f562550b0a1a5bf2894d1a93df0fadff2a6a9eb92d84d0ea6d1582870730c5e43b8bc882ca564842babc985bb7d1ecd7c767ac57fb2adaae3a38a8dded7d9aec65b2fac006a329db6d7a32213685a6265a8c2783f1245d550f526b4e38f056b5170115e21e6a60a8227d86085a28141f97047007541b01092da071e4df4c6492463c00c5a4ab0ef5814304fde25bd9d7ac859115342008eed0b2f349ef6c35037959092b6704618f0cf73032c5e654e5d57c8ae86acb33eb84d4f5341e456dcf89645caea1ff2ab7cc73e2a4060398323cab543949f1b5e9df35d131e7359e75c99da2f5423301990894b2e980ba5fb4d839e28c0eeff35a26db498ca56f9d5fc5a978134e5eaadc345b1cde117c4224b775e1c4fb3e48e90803fdfeafad802e07ed133037a31937c592bff18919dda129d9526969fa5c46f3c55836bf5d5901243705f397e9eb06ac3f56230f60a402ba17e1c734d06c5fe20ea340c9aba6370d68cdbe03917dd7270b5926174189889b95fc637b78ee137858ca71216e40966cba016d572cfa50165ac75442e465ae9511a4b2b0b19eef78c100d56dea3d17cb96d5fcb168162b1100afd2c950a2ec5e831c2d40402ccb2fdd21206bc9c29b2a082edb658e69f1e1cbf1414fadc596c8afa1e47555ed5ec19bd3663d39b6aedb471325e398cbe5d0b60c2935fab5b5430307ce36ce5b6de3c8283f1883173091aba462313817a53b9ae407eb2d863ab77ce13ee38019457bd360abc94680ccd72b50242987f8d4768adb7781eec527669aae8b1e8bbe7f005f6e5dec4a9df3a1f9a25102fd1fcdee964aecd5ccb29f2701bda595822c72944c394e957ffabfc0ad517b91db1f598a728da48431665228c24ef495be74b189255d97937747711d3dfb16609204136bf2115292a3d038c3c0095a63d625b7eefb333f1efa2091d01b4ff2945449ccaff2c74b11d5298f1a511e2a338a95d64f0cc3714154f10356c988cf84021dc0624b6f6b004d5ed17795eeefb16e63cec0fa68a87c149b1608d2e26c9077196f65f6fef01f305e1bfb63f4cee0651250dd94d469de28ff0de4e776526da556403bb23fc79c438c0054f1d56f3dc625e01d22154bc89ed759680e0ea54f1600b58eb9df62eec180c8228b4aaa1326423d67b3c57d3a62cabc1c2df61b6517a32b7c13e73d95898fd0bcac1b46f4305def3105d91ed58a9d905442c3ac28d70be5bb2674b3ef37e30ee52c8697de28047d799e764fc4db6092abd7fcdb0033b98553821e36eaf66bb178a389557ef5c501e51174aba169ced9200e9c075ecfa57229f99353361dbafe8b24cff1dd483f7117b9a97a7e6c7df56562e019f0ea4a6b6d08a36147f10d6eb27562b4dc86229e2ca8cad80f87765d9fb4676799022d7c275adc699313fbadcd946c546980b0311f98c5dc0ce1210d91babf5dcc8ebf02bc3baf97fff87ef9944ee42cdec373d642e0f0e9a4d3e88207795da0c44836b6fddd250e47ba2fdd8e6c046491213621ca4ebf8898e1b544472d63c6155ee13dae26444af95c1531f4a002bf9b35b532df4fa2dd1fb912e68d36e85161094011efa8cc94bd73b8ea96df97359a2446d17378d9e3d6bd6840ba82b0079383b14dab8479dc0e3a231b8a75e6ccb5203aeed6bd528bf0849ebd8b01103cb6200c29f484495e396a543dc49a6f8e30ccdf0703dee3c110de3d0388097c0f411a211caaafccaf5f0b3f9e3ebeee5dde1529","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
