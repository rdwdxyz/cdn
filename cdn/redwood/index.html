<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5011b57c94ede70762c097cdf248be84b7f2b04978e3c3c42a061f1b551852fb9b2968d9905f99eda4ed2d0dbe882f32432b7a1120dcb3e159315c007a8922fd8af510f6237c151f14857a2256c01b9a0483570c205afbfd0b1ecbf340c9f0515227a3fc7c09d5d2061a654e19b12b6a24ee90f3466bfa535d1c6af658ef23e98f1047e1cbbe19ded2d5a7d5dab2a48b20194fae6c48d4759efb8069c43481dba3c49a1e2ea800d6771862bf61f9a0821447fbc8aecd7c46c201a1f6ae9062c43c78088717c20e136089ed337d20e5fd02313c93da1f1107ba0d38a53324eebbe48ba2ce8d78bf941bf888f2b222d75fe0a0fd719b03cb165b4e21a44a6a2242819dcd637f1bda323607f9870abaa4878ff5e80cc37241e8d58b7548dec9a2599b71369cc661f219f70d96e232e9ee13a38eefd09955a9a8cf52951f91cd15f5eb09f98bce914c93a6b2c83e88e3429060b5ddb3a5deef53da72f8c2f0180c722baca4ce97cf050d09a062ff81d5bcdb4c4199627100b1229162472204b6f498d34a7e7c49414764c4423b7288a36f51a5fcdbba30d1fdeecb94d0bd5931ed1ee1da89d42981b7f33bab67d331d79ca2ad2055adf031a9f454bd6d02b98fb9c7a5c9381e5d2c0e7070c5f15b1f16e30ee09e5c2778ed02c4a5ac9e6d7f80ba1cf45911cd43518f2b2a9d88aa786b985c4045ebb7f681ee24bb7210118bb674329cbe58c985727d4ab99621d5640c26a9bc4981a14cd31b1d1118329f9f9d4dad4f344c058a1c4bcb7b5d5c01b7b6e9850aa61c8026a391ab7adcd4dd5a3769052fb024b8419bbe45aa81e0e19964b135f1b060291808024fab997eb2a59ba63ead0b4b46550a6c14011d3de665537f7f97aed17b534b4135fe9e6c496335c9263072571b1aff1e68c9d2c7854bdc7bf079f059ab23e067d0a41860380d6159cd1f03c047eddf5d9ec99a58fce1a9b44764c9b523f7ad28b8ed4227b8b27d1c8d5360551707584318d622d2ddbf4474973bdb8815d87a5ac320326b41f52b26795f7384e967185378c9a4757031f754663913a7cf9900eed486ffa4cf7eb31af5cb6605db26c6f63763bce9934306d7186f04e03bb4f1ee9357e6899e107d92af7a140c6f6252340cefb55c9e1a89e24024d768d0b74778873ad004c33f0bfdbda762c2a724acc5066eaf69b5fce8dce0e3c7367a17cdd6f9888061bdede34b3ca44acbb2f213c3cb72a4f88fd3732557738c7607f0bb40e8d08a1a8997dc519cbf435fcdb4cd4fc595176b1e16c4c3ab1005f6eb7b03fbdc7b690e96b0a5746fe7c363c226436ec18d3f66161675ff15b31434c2dd79a503c0e853f8fc3964fd19a6260abe19112a2e9ff45dac648f53241256147d2a8d92fc796571bc09ac688f50d0df117a94bf19d2ea4fac4bc91be7dbf8306c6aad87d180a61c09138e54b226b2d3eb6bb142f4e460520cd46bafb4e7acb3ae2ac931cf28146d3cb375a92bea4ec4f3c6197ad47ecb75a63ee60d3660a9e683d23cb6129064019c22ec57b699a797d93375b2825aaf3b7fd080bcc378efce2188fe38f384f3ebd87ea5408360d93558e9b4231dcfb148c47fe37f9c81dcf3ff6a05a313ab0a5541411ef26e17c0846b64e81d9b86b99600a4031a868c8d9f6e07c77b03ade3867eb05dfdc4992ba489e16a2b14c8cbe05ba96bd0ba839e63d004d570aaa60ece242f833c4a79878db2a10618009c3720b82933bfdd8554f2b16fe54e3929c9a84f2b193c3011841b9d84639a090b538d7fd54e7efc216ae8cb853eebf14c3d2587c94a5a2d47cb91d011114372bbf80793462f5f41c218cc9887c99df4d854dbe3c7640f7166f793ef93a64615166561615335ab0b7382d433856fef816b4bd2e45bf851b34f11601629b5b369531469d667243a2b0e77eedeb06c75f153b5e2d978301bc8db75e96d4a99ef3a5e0d8dacc33a95c5639d88d9c69642c3fd0db26f5b7cf4eda710373c8169bd734024649a6149f456438ea2d193832d9802335340ff867f03f3c9779bbc49a421fa9b96de7c8d8d384436d4a8282b8a0a82418c2412952775d748503c1825e3489558e14b6e2c0786ff380157c20d7ddc5cfde65aeb2f0412090f9eea6fa35aaf8e3a268a45eb1137306b45960dd542828a71fbb2d646b5fdbaf73da218d2737eeaafe3f9688a24058501a91793496e2fa1e80cc7ac9a39614ea61eba72e15c85248954f250ff8754f6a0feb6143738874b558730b9240477a942bdf4ecfcac5819153041bcb5045ea16d2d4d0cf029e7754ced0de3c46bfabdce61c6e203b29c682c98b2c845293cd7a4ddba73bc462db66b6e22578e2933ed8b50c994ebbc09d06b6b7ae2c8a0fe9f20ab3fde501de32affd8504321f85d8b60ac29fcfc7ac0b6d737643262b4443a7ee575d7caf71ad046fd68d27ec697e7c58d456c2ac89563952f345fe27b394ed065283d779cbf4f1dc9781b425e168dcf2f48ae1ce6f55a0e6faf2737b278f621e3e99f024ba6e83f1c404cfa450aab3241c449bbf36e27e947efe4c13faaa35b8920138172c54b836d9c2ae4304763c71a5b6ffd658be479745342407c17ebed4acf4a00da5640fecb5c8e279f5a874c358c2dd1608b7cd546f62b8e8fde6bfee61a5788c64a7ac48a1ce6ad91c1bc44b74d41197a30dfb9ae0b14e0957c9a9f82bc29246437573028d6c2d08e5a754d5abea5cc3a16611e45a5a463bf0c02d604a215e8009f3903ac1394d3796faa4c7519910959721c2321ba1de7748c02b655e2630751d1786eaa9c091ea04068d11072780d0c953105f0650cc6a28492e5f93226b18b8f88ae0fba75604c55ca1c647c1af0b121cfcd62a20c908860837a91dc84fc547995b45753dd90230d62f5f71d6aff62555761b2becd1fd045f077ade36f403bb1805013511b9fae0f35557819afd74a22789c557abfe13e44ef13ff997c96083f120ec2be7aec06dbd9024596166ae94473b8e99a2e5673e30529324805abc24f385f6d7873a47f26b6975221e8c1310836ffd7b9844ce821cf594fa438c1d4d16caf62849dfb69b1ff04c6ffabb57d6c4ecd95afdca82afd761c79fb1931cf6a658a957a14f6373de1916da135e1562477889f6cabb976fb1ae5a4a96d25b2716e905aca03ca5787494e819e14685f10155ea9415de9705d8ebd3aedfc77e2503a7dae733dee451a3b242022beae7fed9188397039e0eb56b9efd03a3a5c20ed26d8073ce59b1d4bdee84a6926f7f4caf4a34ce1eec2506ecf0d951852f02522aca1f5fb35a5a936ea46c247ba3ba71cc2761cd0ba64d99e3a7ee7d0edd72dc8363ea3f934cc2859451a17aabe354c3ce563a90dafc3abfc65566b754c7afd9bd62aa1f129debfbb4f888c4007d7406129df23fb898f59b7b5a6bf4c64689ba6de5659fd61a67041fb5fc5a728c535e02919ca22d60191381eea70146d2d9ebbd2ace6e5dafbac12c7f56509c8b3e31e424f04a26eaec2e737b79c65872b0feddd112b395d942ab052af9c3d629b53929910f52bccc7bab49428346b1ac0f0bb3930c677c8819cfffdaae2091e2554f110c61809e38383b21c964ccd9f33e043696474057f5eb5a3d0fc6253a74a10b9878fcf9ceb31892d46a14e503e8c4074cfd00381221eb49f8f8b4759197db58163afa0337e99d1cbea8e704aab10059466da7ed28095bf8cd8486b9f5c6aae5023da948e6957d750f84e978b00b3b8a90ec5203e3d7887ce81d0a2d958d26d0ddd401dc72aef8168da7916dd1bd021ac20f8e64de28a1fc86e2557a3d5b807edb26de710f687dc8ab2d6bf9bfc17f7f1abbe499c85a4a8ab5a08e27c78e03ad9dc88637bb09dfe999867ba12de3e179b064f282d612ec323de0710168c416a7a70c2072a30c838e00eba89072911a60507efe7a824327b60922e873750377d2a04a781ddcbbbf50c85da715f0fd4990a23c54d7b0eb192738a59a1a2febd94f72c3222116cdb5cb0d1cd015a367c110f9ed770ad570d97c8718b9a05a3d9e1b73f98792734784122166edbea6901f3503d7f4e67c873e7d57a44eb36440a272ec8d48daf368ff41bfcaa47dfcc9ec6a1abb584f1706ae0fe75c910a3107c6c2258d2f3c0f2ade713fa6c547fde7ea1da4158a0a453919201caa72cf75aafb0ae971b9da10f13e5d806630df30633750f185489aa5d1e383bd3e4f4be28eb5ddf1a0c3e784b4d2a71ba055bc424b14651a70e7e4f7be89f3e157a3a4e18bdd27132f3161d2167bb32e869e3d12bfb9dee14385b4a8ea6b8b47808f51d86287f79732d2c7a8117c7eb6015fbf1f54526bd348aa540ee6112fe3a962fc5ebd946882c71a1dda7bc2d3424bb07d67da178afe01b7725c1ec89d13504d31852e091e263bb285de88b9b9d9741af294c3eba3ee396ee956e107155e049630b34c64c58a23a08b87e12a2f8b7d3b9c1fe34306f5b205afa6d3e4570110f299f26af569b0262b3b0a0bf49d54d90637ed579a63c4c98238cd193d6bc9e89a6a24b918f50c9d4112410192517b972454622043b814b24a27e0caabccd2ca481ec42bf8c90b49618a5b8f29817d7acdef3a8d9d1f48cf511000a017abfa237dd860ba0c51bd9f561e493da9e96ccf64fc4a2b87fdeaa09fd3b7d8d0e07f73ae87ec72f21f8bb9f8ffa4e24f056f0ff4d3aa2f8cd4d348b5e7653eca1d31a62bd5478e7c0f0f537bd3c3d826d885e74cc3fd3019917271e5e3ca882e4a730d9396c9ff854c39ce483201586c4ea476e8fc21b46c7c74a03fef3239bf9bf7b9123cdf705be25f4a9e6a8e79b3bd69b11abc77bd5c7a3a0c6ff970cea686e5a329efc70fa956dc2532e8865dc2f5226e7ff49db3e6e516ba44374a615fd1b7baa07d6dd581c47e550c0846dd445077a39ba09f3458b1cce7f2a5fe355e17a074e70e67172cd96e2c50c2a174b089174312c588a46444036384f37551011bd3b17c2f3b2d64e52a17ea4d9e33d4509e5dff6164fea0dd1adbe6ef8defb7c163d311e567d441b22edad009490739467f92d16f03cdd0320864236b5e457bec1f55746f115a2a4cac9b3fe3c5b4613a05d6eac5ea9576c882903c8896168bccb6e37861e3d138e7cbdcdaa7cb9dc1a8c5e2e59a6fa0dde2e26aff45c71f7d989ac811a8284d41eeb546c3a7cfbaaa960e46318c566e1416408f731da977f9607a5bc94bcf8fd1b72c865ea2e0133fad22e133219515579a8d4773106aa767332362dc484de7000ad1a0e4e2c3fb2d29893c48550b5240f15d4279d551f1ffbc0522f572147e9cfbbd4bbfe4e682188474851a298aa41c43a56eec85940cde552d550463b01fff05a27f50dbdfd79fdccd9bf9d5648ba74d21b05b3d19ec384c53233ff8b8c1a11a688efe790b44d19165be3503d2e856c6944a0c26934478654c3282897088a32491efaab5dc19153e7423749da173770e8899b04308b0fb93da467ae71553d4589f86ee6f7fec94423287e4b6728021c87fa3853609198460bffb2b9c7db6425445b18a852f41cf5527f41ff58086723ed9c03c0bdf420191e5fe86ae06499dfb3795479f4caa09287499966a656b7f621935702e9e534d067a1adc6e52f436a581a8e29c2a5a8f548b6fb3df98578320d1e198a50167c7db3915b4ee0e45bcfb0c13070dc25b6566f27fbf6f024a0ba286989a1f988dd80b4fcda6b7057173417eb1219a01ca29eb532bc7eca50e70d9e4511a4036a45af0d799e85aad656cb626097678f8f2eee7e1b7aa51f17e8b073df516149717a2d65929c476891fabc10246b9185a245a608c9f4d97bee8903cb46b75ec6c9093e5549ecef86b2b97058f5061ec3db7ca7295b358b7856606418a2ccf98d13701b2929850e13b28ace2682e270525178bba1add35710a1be8e274f47c4afc1069b3beea19585546ac7d3ce76a38549e1c4609a5a56dd38b0684afd3c18fc84dac1eb1e263beaf74e493304a480f1d59609b704621db77c4eaf1a0f2981eef12e8a234f147e04ba6e2d4e5a47b8da25723aeaa11d9b1d0e903aee53c3d0a13de1051573bf355e4cd72eeace2a861ae6c71f92a8fd643061f0dd5427cb5e050fd3c61a93caa8916f8b7cd711ee63410332589b1d5a6eaf5cc62db4485e1613299b54d2a8c711f1bf88eea63026d9518a166f38c6304dd39951b3ce9ad71da2b4ac4225bbba97bb50d42c9bd53dd41828ea5475d216378f8e88bc4189fdf2ccc4c54318f4efbd5dd4953c6bc6eed1b90d7335cc574205c6c82c20a783e374521fbf34236c4d9f7ef6a4ba5d6f85c3ebeadbef082c1c8cf4beb62ff5bbf1b918e4512371747b1d4ed1e2dcf6653ed1492d8c6be019cecab03ef7b839edc4e87e6f35bc1ea3951fdba9b10c6bce673b8473d636d2a1c12a8f21c7efd6221d3132c5fed899192df52592bd5b8e77d6dca89b3f292cace0cd1d818093f48afc2700d57028c32f1bb5a784e632a6a0b9224e209226f26b7239549a32e815854b02e22632dddbe91e67bbdd9138523fa59776033cefaec24f358ff19de6eccebceefa46a6ab23a158c01540a6c67792043e76c1a092881499c2b943857653d17ce4fda75845987da5e30c3036da55b4eda9c786c8dfea4680ea5b98bda0dbd47d0ac9629530dd716f45312a802c2ee5ed66a58cb4ec89728d44d91231cb213afa6b4c9dd85c4366af2a75711f85059842b478324aa7b78aabd5ee8d83089c1694c09143286049a70130269aecf5ca9e73f1b04dcda61e99414e32c763f3e7aaa600eac8182e33c1d2d8d7ab25d5c5e79c895441ba0b7b0191e8fc70ab72a4fb07d8ba2bacae0db243cccf50dbefd8f2e1611824746f2b0c2986752ed672291ac21adbb33827e1cf150cfcbec822f3a19d07c69c789f05ac183b8db153464b96cdd106d2b8cfacfa9a80de1e5e0b79196f70d89067892f4eca62fca4339225ab61f1d5ee3f8d5206d76299f356915647dcc8a09f4c067943551dc22216d3477349e3dd78da33e33660bd48ee44959fe0cfe6cde6ea931ab7670e4777e0b24a1c213b874c9407f4a762c20ddef665796d78b7ffcc531df435dc2bdbbdb629a3ced78afa81370a4a60ab42658887297545b09a3a7b05fb1cc899b9ffbeeb91b541e46ecb753d9f746f1c50050c130bf214bafae7728c328081b718830d4916ecd69eeeaa2aab4d6b32b0ad217b2bd95c84432132672d3973fc85db4a69d907b3b492a8d7003a235e035783027a1c49818b74f50b0f07a2280d12ede296a43c9b9ce7e9eb4235392f1db34f0a7f3ae2aa310e6c3820f0706aa4f1f0a087326aaf29f39f5990bb7111cb51f7f78b851cf66bed16950d3108fce25c3badf0a2a476c928036988b3ca394f172a45c790ba918eecd8fd52b8198ed016f7729bfe1a22cd32eba96366ecfbdb12eb16a8865b64e2cb3b3f817bf1553b5648b645d8653b6860b02b978c466d999cee259da51b5029a6fc13155ae777c72ff506acbd74fac3aed24a36429698b174c4ea4b062a40e3ba93fd4f1908ce1df0c9d4621cc77b93c6ddcfc27e75e9ee476c025e135791b1fe660e4cb1f897997073a4bbaca0e50e51c4e0647140a00bfb82adc2d6415ffc4adb302c6aa5d0d14fa56b99935b738304fee06b7082339eb5a372249e8639db98ee30a10b636f04373046164b988a668981c80b5234480cc3e7f90eb589815be2b1392ca6874510b1e0e63bd4c3a7d09af60ed9021e9613aa8a3718b52ecce41b23720ba7d29239ea092e67a0615c52af58820ce77d9e3623ad4657e6f4ffc625869efd3aafcfe81738a582297a7783fe69d1418a2d968742263903d66ff66ea812fdec69dc2b84a820ed4dd8ba3e27a29ffb263e73fba0bf5e1f5f094d626dcbe0425802c0fccf7ffb4667c3ab413cf4438ae40aa3965870d06512ce07e04c1ff9a55e1a2aa6bc91fb6afe1adba7ecd18bfab4b88e2ab06b0ccc9758441d28ceb0ce8d9449c5b0dd7c54a48342c44973a99dfa2730efe402282c2e3c4285fda1498828a38c136e077518f95d82051b7e7791a88bc0bd6892402450d28b6eba5cf171daab241792f9680c7bbdd357c14cc53e6c1d3d5e08f34b599193494ee922d37280084f930e5dff010b69d1a37cec3cfbdbf60008963c1e1e82df1675e96a858dbcbb285861cac56c605e7a5ec954e1ec2ca4cb4e65c6d2d13f42e74fbb002d59fe0e7e29a0cd1d9daa90075d89f1d0ef82c2a88562f02aa1daca978f0703932c5947a267e317b0a2f2ab0c46025346006289025e1da89b4aa24fd29e44cfad772242cbcece0db266645e46b339cd3dcf6343d57c49c80dcd0e5bc5035675f7573acaf9048d515850980f72f70085e036e3cf25df2546932445d6ee7a367fda3ca0b03d0cd842ba9428c29e1f8fe95dc8630690034bc83d994be1f2bd27f83b93f53868adc69bdda81e665cdbd97372a5c6a9133498fd1417250bd02b6554ad435b57f2b4434ca905a18e9b3306cc4053ee50f7613dbaface5a2288b25b29e8ca9d93cc175946805db187e9a353a55b61931aa88af3a2f2c7f19d41df1859d6e16fb6d2d2fd23b46b83c77a3ba5bb0f265fbf94a6a12f9216dfe25f44d62e12d36889a4d82d955a3ec7045d555face36d5f5da2276d0d7fd30470a0d6a5d42d5cbc8b8cab5d8170e4d4dbb58464d334f72d954f6664885e79788cfac588819aa796eef9445c4ee12102729287a8ae0673e3c1df803d343c1f1a9499097f44c42adfb3fbbfe541b84c2ed801948712a25df383d2810015e8541c1143d4a61e32be1a3fdcda1dbb1383615dd7379f62ca4ddee4a9e2347e5df82b21135234ec21d830c423175cb90070fa200bfb035801905749c713b63a4ca7b37ead05a4fab683c3fced5e8bd4f461fd72ebed8910e6eee5012bbbdb1317365c08ecf17bd612774048d92a09149624721b365b518e9ac096d2178c205d2698b33ab1efe1a73180d0440c89babd4476cb4eb162b76143b62cc9ae7f68eaa7ae2f934fae8227613e3f313b07e30f622f8efbfa57d4077b6d98650cd2d56737e7524eecc9f332a8956c8b0cebacc58b7e95b96f79688cb3177796779d4429667a7d785966eeecaf4169c11d81561c60c644b9e0df18ef260a17651758d08f4a9ed532d8fb16c2f1de7178ccc82099fd08a75b6e15492df726584abe176e5a856d51768d2d55ae61c3494d445c70850dc177fc92aa4d591580087978df8fd54b5069447bdde22747fa2aac6146ebefcda567049ed6b6e18b9fb482347f939b0c7093882f165886bbc60bd61cc300e3cfbb9e0dabf841aea846c7c86178ac70f7f0b39cd183fe80347b8ef052e6ca683cbdf9889380d84843d4079170c342eda5a3a33839866a85702cd6ce7d0194d98d2ff85feb7767cfdc21b6d2fc46ca8c800c8c97745737ab4893bd1d9bc18060f0beb0dbf01871fe356bc95a4e31ec9e5f43f33a10b42193213abca84dbe07227f62fde94ff573e2c45501c5b3a413b78e1923d9e80912082779039462bfc0166a6ea7dc9ea2d7a22de43e1dbd28c255527b93ca63346ff58f5b7e9e703f31b56eefb6c7626ec234185ee52bcb1f156d244047b78464486e3a43540e215b5d58775aa8dd6ed29230c1416c0bf6a0d69696111fae2b4484392e0f397796369c513040f38c23a7d8271aa78d1ef843c28b4fe6d490492630cce892dec91c1e25804969ee67b9b56e12fa8ae98ac8383bf044650e14747e025d43d650a8b04be3d3ba5930d3b5bbc8147e448718fc7d19399e0731324069796615b84dcb035c444fe1b61695c05d9e9f0fb024a3f3ad58721b5d09b1a35ffb59250e6f3954721cc0887ff0b527aae48333af0adedc522512abb958e05c0ee508cc0dc5c7b09d4fb9569cee6255d1d3389dc15af5bba10adb8ae85e66e59f68d3fb3b06d5e58720cdf7e43b0408289dc9ed3c9b20288d1b27dd8c272dd42496714dba626bb2a4f7ab67b49c19675d03615f21cb5dac257bfaad2e11038476deeeb593b319ceab5aae6c0f65b2b1621286c2bee7eef07ef9d259a41f00472f9fb99a157e52973a8dff75822b7f9fe8429211bdc4a80cf1834f92d0f47d8b500fd449edf44fb4cc5a5ac640fdc55dfc725e845d85c18c5eedec172c8e0ccff1d4ee9a71e71fd1f2c7a5b3f2775607d03561a55bd4e05451f0774fb86e87a4174efdaebc9c845b6456a0d96dde96f39f242ce3fb7b09fc09779bf07be11b68338c06cd04f68d756f0c87961f457a85a8cf564e1249b7241cbefea811465c73c3fd79506ab78bf2356b12b57d68105a01d798bcea7749858bd9ce77b6bdc1340144f216075ed4b8c94749db594903d35fe4dd8ae178995bcead4e514c82eb36ee000ff47f217b8025a8912792ad40dfe4eac37feba0412a77d4b624da732e5352d9e460c87eff9afd6ecae6f80f5236a9549217d087b1f9a821a7b91ffe4fead9249a21f64dd726e73beebdbcf4e79cfa033346c9b9362bf13a0e11f62f2ac0b15bdda2141bedb5a219bb7ec504b1b4baa0aa21415b051c0f02de9c7588a06c258487d1e9136a91b3a8c7fa0d9804d941e604170829c3d7c8c02acab95f8ce47d96c0333d42ac2dafd787c8faa94c4ccfea828a85a66d4e76b1ba6111bbfe5948a79ceae212f69158c93ef7b8e0f302fc5ad4bfbcedc36931582aa62ae7eea69bbf5c2d43c7d90dc42546b26a84bc41611eac2bad6ac92214c480b6e1426aa82ee1f9f66668e0ed29fb6b6be1f8a427a477f1e5b88573347b2646c221fd68427a5d6956a55dec5b169f9ca260ee60c0006bf2c302d89111a0af7d307ff9035a307b44bf88f7833d7b141b4b9ab960594234653c5a45e74ddd862c5d9a6aabd0a6e9cf8ee9a257ffddf9bbd84941f85edbddc383f48189cdd3fd0dd078f9724a9d1fba0738255375fe9ccab51649913a0456e59434fe094a1850d50fb0911699e3d83ba3f97802536b48b9012e3e9bd920da048c3bd6437ead9f23b2c081152bc7edfc49058d08fc38526ac378a60e2c9617d7f1f5e6e2464ea4010828368569a893a152042e845e93c0d3333c7fdb8ca61816efe9fb47790add9d2eb2c0e00d63c4d665a4d576a41fbd16f9b42652875abb6eb6571f8d0e909a9439617ba5e39bfdd9a9ac4fc268e579ab31c67cf20d20a7a122623dcd82b331130557902f3c4ea619a87673847a53be94abe2101a1fce0897e39831569fe3f6f23bba3798d576a89c8bbea52e13f963b46e2d63a7f463ca3418a7121eae373f4b4f1e17002ca27b2e5ae95f83c8fb976dae58a60a48d692713bb9f6eb4be454eb92ec74f40c58602e5ffa48b35813421e98f2e57e0a874ee940866f31614098bf87204a19485308def51c96085922dddaebad6c7a656b099291ccfbd528b7296e3bdbce3c72d50387a2e523a35cdb7ee834e476278aa743e9c7160703ea362fa0fda78118abf9f424012bf4148d99ebb599c9d8778b7ab661309206bc66df4ef53f5846b95f4d6b3d52d93ca311869d29bd0166b26beed94deb5b53a693be649fe60c3dadb94ed3b91af20e02a1f375307c833f9e11a00c0dad6b2187c5dcfbce241a59027bc7ae3657a9abc8a0afcd3f6795feed8255c67495cdcd4a99c249f25796111904030bb622c275fecbf922fc8a804032f505c0f9a7e35a1a2d457820290c4390f6f451b53a18482a0d01ff83a3136b440609abbdd53546b77bf4af08c665396398873d04252fb1ac67540f7170ae0a1dda54cf4e34474b77f5dcc5794cd054b7831cd2700b928803bd186eceb02b99e7b5404f7bb0e5e1582fb5a67184f7888fc97d1226b0932c9881847b53716772e32421d7c99ef162cefd730064c2e848dd3737aa851b65813aed9e9c32a976010fb30bc19f77fa412da5502941eb73a84e48bc9b7cbc323aa93d29b012f65db598842194e5d38f70128bd220f7a7a457a4d8706536fff55a1fea219225f466bb0c48702be3ee9747d2ffab22c0c76e5e0d357b07b28785d15c82cfb665e792dfe1583672bfd9e368f2bc810595b2a793de6b0692cbfa7eff324e95a2ecdbc8fa4f902938d73dec62a6e8ce2d19628e878fc81153d99d9648d204eaace89cf298b9bf4c1f3c6c5852246f25470644a5ba41fa75d2533695b7317ecbb9dcf72beee1b2d5cd074668fdafb08a0f2576d378b012e6f01d57944cfdb27dd85b2a5bf6d6db13734943cb68641068c480512db31669ed121e1f8c35d8028fb10af3e158e61cbf89f3dd70e61901228cb6155f77bb5371b24a9fbe885a2aeb09c89738024829ff920cf8ac2a40737274663151c8622933c9fbd5ecb8a8344d388505ce92806e167b81a6d1b2b42c4b3183ca5eef21d7f4dd41152ac56788a2079c14d46c0a6c087ed01616851eca520f149f7576298c68e9328b98d2847e09654b7213da424929f119b40da2ed87a052d85fd3f7257d5a1403a08ce0cdcb1a5bc377b92dd89b2639b29d65f02c588c15e778ed3e2f1943288bcb0e4cceb70849ac643104761b9f87ae5d9ed7acf696d33d42e7cedfead067a692124ea79a8f6e512f6d44ed60acec42c976d3d16926173df02ddbc312100b95426b95ca5e98e1316875fd2b862266963e9edb133803b1ad8896cd9af7c6f777587fb3d1a91ee682efcc2efa66bf89be05fe28a32fc3a868cdb1c6e98b4a9832fb6eec2e5ec9c3fd9a632f936601180eed245b24d9423ee347f14b867f5dc0055df25278f83fd8705a07ad45a122a2ddc1d38247d143925bd0e32f7c9003d89f5eaae231f6fd7f11f2742bf6798cef37ff49ef5754f08f851fb161a1b03361bef063678a8c9f872ac71fbe0a179704bf030d4225fefd27c80577ce9f4862482d9eb28557e62fcfb6d76c13640cd3a8df5583477ae1a73b6045757334d6a5f26d6050485451a9e6700b857e8712abaf942da3dea14a339175ce3ecb5d272c072c545813fa4d92961ca97407f33cf6159a184d04f256390f04d86d25dd5d9750e7a740d71bb5f6ae538db52987712ff5155ccb09faca8963ce0f38b4b379112ee1f1b49d5653c321866fdf72809f0294427b4d48a870c706074a775a51607faf192e2d5a8ab3db39ea185c54279f9b2e49a0fab6886d8092b76c159a8d58d49c277f139ab46ec8b59966a770ce9aa5cbde2c5b79bdfabcd889dd7cbd2f78183f48b3822bef3c4d2ad483627344c42024db34713e49c64ce3e1807decfb7d7c4310be0d2d58cbdd1af4b1bde8dfcfb7ae6f97c17780dd2cd0f62d2a4163314574511b1615422aa502b6a710e592fcb0eee5a3987e65a84ff3344138c9eae57f6965e6ed80f768b9f70297bf9fae8a4189ce378381fc245db9bd91cbedf66532398fcaac86b0f2b2524915797e232925c1991b4d6eb4d9a334f6018602e8953f8ee002c687ecc689f855b67ef13000fb9b15081e4e89af737f4a418f2b9b48c63e42b40f1a4d004284e1a100dd61ae15b51e217ef0c98d8e26122ab5c440c619edf7af3475ca4e341d62a7d922eb4c920d9acadf4f6cfb98f4abfe815d4bdc6fd972ef82ef4fa66badb95dbd10ce0e272aa43d223f6ae4d6e3fd38ddaaf0c4a14a4de89ea5ec162508e35979195ba03d24ac630c1c10772dc289f9f63ffe59ed529586dbd2c12a1c07e3705f64e9d218fa23588626b60b31806041b1f1b63db87f1e6421ab92759f53c16f8fa424435fa0a5327dcb809f9f4eb662e5116f3e62f0e682fabc64825b3943e44aa7206d13586f2ab1e902365d0b7d5d6c417fd6cc83e01ca5fdbd455c046ca315e7249a55c035c3fe32940f3adccffc54976396c9dbdc31fe89c756297bc4eea134888d66eaa65cffa410644ce58587c5aece9cd0755784d6a21424938770c759815a50783a689538c6e3febea69bd1fafd8eb9406017a1c414350d3de49c1260d0448e8a4c2ed61ebd8dc7123dc9670ba63692072003c7a7b6cf4b3c6431c286d5a7fbdef7e18ca5c63198c71216efb4eeab06c3a1db178c10092c7493daca1829d647273cbf585a47e3ff8347c21c950856e3172401dd5eba7b92496c621ca170a51e1bb4b43cc3ed798b046a0a4f5c35c542e52f8206e5da81e907f26997ace4db00a3665375ee7a9f1eb9f57a862afa79291419477cad7409fab284235370f0370a63fea64f8818ed129d037ba76816727743727510aeaa05aacad9c5f6f3cd11dfa8b46fd13fa5ae3a63c1451d3a8e5a8e8e926da30e0b77a24be340f1b7763f3b9641a320f32bc59bb48dd87c3af6c72e91013cd84224f0d4d101b634cca60b76bca4ac46421d1ef47ef5496cfa2b93240b75dc36091b188d33a639f55367f903b4b9bc7508257d0a6bdebb8d1b90e9f832eff81ff583da3dcc4f89d48574bfffa7185f4a4ab2d9b217c6b2e5f7bd4dfaed64e18e4edfb1d9fef490603097a1fd40a4842e673bc02749d6ab0928353fb04e14cc399bdc9b1c9695560927b9bddca5bbde58e2e6c8b0921da97d47b713e1061416900acab036129d73d1e2116fda7453d12c6ecd58f595f46837c86f4e53147bb39487c7b11fbc83f5ef164c6584a4ff565f5acdf707bd253a2ecb5152f1aeb6a4c4c85ea6407e5cfba1c82f03f15b22ae03c8970d9bfbf64b5dffe64387fc1228bb42437529898551adf28fc50e4947cd20e227d762dd5c7595c54b275faa84fc8e98c3faf7f11a72d4b32afede7024e951d656b99de07783c8d976486c55a2ca315c4eb95b9d11e41ba3f59ca952ef935b13fe10844be55a0023e383ac640a080c53627d760e2f3e7b043f196a38f2e850c8ea4d0d85318f2d85246ca6d73c79503e212495b9a9b3ff8e385274162607505c7591d997a3d25977fa5f0d674f93d92e61e30b84059bd0e845d2cd030216aed523331b795754f0b08a6fabaab9aface6ee6754f6b5491b20ba412f2b99271050713e493cd5f0be282ec6318da3540ef68b58a60783ae42c4c98cf3ff15e366569625f322937340cdce652725531f69c41a018710c84d98112b2295b1cf33f1d41d836f556b2cc75ed595e12e3a309b75d911147c8c4dd2d803e1f4b72092bad1ae4ad4a2d890a27456875678c4234c307ab872dba61d5709ef477dba10bfd24e6622554254963a0b7ca42e1b01af380f30a4c2a7870f2be35e7adb8acd394d5983617fe5d86a777cea13fccbf206e01e6601dccc81895c8774a16ec4d0f2e7615f696f7495526b789fa9012555523c2df3796bf4a54f2f856f9523a685d154a76abdf0bee19fb49cfb11e05beaca5301637e704dd8d85d053b57c46d156ddf14841c9d4e2e8b20b9141f3b0344a3c712e6522106bd103a701fa8f893d441883df65ea0950469093f878e637283273cbbaf57bcbdfdc20986395fbc3348c64e4f272ac9f4b865057c2c44419d9ece6c278bbaa3589ea77499aa13df8a9f519cd3a0a78ba947d057e2cfa0ca9f10a72b6d134a13cae63781ae2c6d095ccc1e9dcfff0b1831f1d76059045b276ce0b9945f510cb8769b9b252d002063abee18b7604e34a3ae455fb35899e59beded3423e830ca5fa3226fc51458f26e6188f5a87bc044bdabe9ba8941ca15338a3fa705edecaba3a61d019f5fa2676d8a5d4c14e1073279cb0e757ddec34203d97da80f98b8660a4f91d5066ff390c87ef1a99492937509c9750a67e931b9b4e5c677b90886cb00e3f84ec9591565f21d3373d301b4fb1673a8a8e1b3e3ece9aca758241a3f8d9bb6792cdf9f56b60e779ff7401d2be964422c7dedeb1f472d9ae1efb33d4f7420be33a6e3e84df2b93a27a7f47e5e0a68e5f668a6ba4decf645887447270d0d7d546ffe768a9c46b1c5beddc88aa40b24ce92002bfcc7a92e284299a5333cc612f68433ccd11f8b1d2b9b17708f9ece675043d6d618c268e16b20706fe3f2c88b2d4d08d09b606bdba332f357e5d440016c4612682c101054c5c7fd57b45e4712dbbc05eb4f84822e40894f399a7edfb4bd0ab4cc64cca756c95e24a05112ea1b0035bb52fd72a68a31c1fb08e84c2649ddc85df311356ffd1c12c04c507cc7a74bcea12cef6cda5d566217285bd9fd1cd5a62e33e752fbf2fb892bef1f3a16bf84a4c35bd01e9780e7eb8b12d1ada7ff6f1d1d5d0f88e7cdf1bda976d3953d2e2fd25d693c4b88fe4abaf6070909128bb86d78c476eaba2243942b2a6bc17db2fd4131f404fef2b94fad10304935984c76844a0adfe28aea7960d01d59b179285af96699431711e13487e5b4e79a3dea7654497dd9d5c515629117629f7e7459818d841674f1bd48e23fd2891ae16ea3d391adb60bbff7168a8eea8c8a85e7d29df36c8c5a37e4e71dbb1d55d88688d42fe96a044f3968f5c82b2ebb1a8dbcd624cd7a172292d2ba695f452ffa3719eb4dfdffdc7c4e03ae9bbeded322e36baa89b151f9d38f62830ae55a67b7d5de4e872e57d72056d862f86f47895a6fa1c64f18b3851441bd7f3fe31d8b36663d3b6c36811d537287583670ba024d4ad84d9ebf69fa611f10f18f98e20f47fffa1d8df6aa41611ed8749950bb787af807839556efd48de53fdc13690399b7f9891a9dbc907d814ff42d07d897c38cabbea7f2abf919ea7aeb90ad2870519b7ade6f00058d4fdcc0316d3268d081a6658c47e3d52e781a7d2dbe1aca51dc7cfe6498e128389007c9a95088c565b9b5ea842bf6a60617c7d5b9aca91caa0d9ee1899627c4daa952f71b697d325e6492d02722b1727bbb8e74949571f83820f6e4825aaf379f2f4fb58566bee78a276182efe6eff4f653d91fd342cbd80c70b29da714b10fa4e4be52e1b724be82abff4f885e51322da95c2bf7a4fdaf8c1c17d20f1e6a8037731e985c46b8054f659caefacb5e6ab9c69804f70d2b7fc69dab3b1710a5f396cf80a36769ebfddfb1f20c99941a2a5400087b9ebc49b8f68d41f15d494cb5e9b62207a2866f80fa4a91bc5509289c3e735615b452f142176b133c08b4f223699f3164abec770a710e4e8ca93b0ec9cb1f2bdee28ab4c80c985af6ee601007c2862ba4e7d36b965c7740eb15148027cf88b5230ca68ff9cc521080c33badd31ef93d622082c290e7aab80c22990e5a77ae07c951df0e16b51e21187f5d9a1cd940769be45ae1a7d8785e82ed3750d34760aadb8430507dc033354346e1e62b0be5cf422897e5421613a8fe0617bd839a091170d29425f940b6019dad3a1a448d7d8f881b3b5be3dddd01cc596239e1bad278d4bbe9a174d0e0c5fd5577b35a3ad95b80abb650d023a329b32b097cf2a7c743f6519010bb61199dc51988c7cdb913cc9f3dc35e0b22b506c72f3d8303e962c83e26a7c4f7f98734fb6ca08a80d23e2d54321f47c358b62a6e3469af03ef50b6e848fbb4af5e9eb9274eac9d3b613f4daba9c302ae241584bb5a34f43366080f8f07af50f20516009a00eb7f9e86ee1a8d7f6dbf5018a26b4d21e2e0e48370fe50e5df3267050f42ac4e2ab89e9e38339ecbff4909e2a248e9347a7a8c619562974cdfeaef4fcd341ff9d8632de130099b4b41842b539c54fbae91ebc53fa8ae558b552955b64032d8ba5c84b342d6e05b88cb0f3bf2d2c78b6398476f85904e3713ba70f523c310200533f1084a3aa956803500f41ba837d633538a2e3676443b9e99a36896cf69c6cc9432ee13294b1dcdb45ddb21b4ac3df9ba9c935ba46cc4e0d9f55f560bb6c939df3101523da9acf5883b8b1e923fde9d6528d4082f2b7cb6884e90b45ef3d9cc3add60da2d4cc0f9c1b8c019e5a0e550e4e653475ccf81471236e4bd3b28c3179a37294b5d1a1642efb9c669c42dd264833ad58caea1c731e098bb0c35ba65aef22511fe2a6439c29fefb66ca9a812858286d72a07897fd19829e22326f402458b5d0b40b031c80a967b3a0a3a78a313467a5e9ba572b8cb8ab129869e5d16eeaa117c163867fe540d2816cd6a33ff30e4dc311be96116aa97567426acd9291fbfe9ea277db1d8bd89b63f1c7f52c77ed9b14a627c21928211db1203806d8d6079","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
