<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d60ad84a18456bc87a87b576b80557a8cb33be66adf6196cac7232df7a36a48e4330d9780e5d77ca4a22183934d09f4c780df90bacd7d535a2fa7dab45d5e16abf428806cc0e81236708769b6f874d9ed5b51df82e25609b75b8592a394f952517798843515f1700c6f979e672569df24cd0b73967cd4868d1b0c1d81cacd0b80f08c794850cccca212aa313d11728e486a5f780abec41ba1104c4d5b74e9ab58ccaf3bc47afc61052fe8ba3021e0004f9bc52526a21952d24746927d7d04543dd734cd39da46b8f76fdf61df5947e47be86213b2bc33e647682ce2702bc98afbc8b88500be11c79a0c7d3e943b051542fadeeb11086cb56e18f70c84973f1f1c20de037940879736f2a30536f46b4f25f0e107951a6747b39e2de1f0b0284713eb9995dce1374d965c6fd99897fe159adca037ba0120f58379c3a77c129fb7926cd2191d4bf25a0f088999a2668069b185e8c2508cc40a304e3fa7859b2725f2bbb567a2d91c9c9428225562091b9ceb1fc089b95add66dbe0debe886db4167c6ad5d4497d5272e3eea3e87ffd534360ece8b24fa94568ba41ecf41a25b33523b9ab66a8c8f7bde56260e6e759c5c7e16d2e4687fca84576323106f9987ca2329a51a6355b46d15ebfde4b201522f077809a67f0858975955491f34cf4403a87742cbbebbbd208065181a8fa2f7f764727ed5ad8d741c602a0724c55e71b7e914487dad3da44ff22ea8be2edd13d3677c74e73a09d3263148d23c490a048587e94d7e3842a06b68b9783a078826c4a67f8527d0ba69ea1e9439b63bbd623575b817230a58cbc0c6f8d5befb69a2069955c93f7a1a6255876fef8a043946f550c5f414ad627a5bdfaa2c9d2ab29792b0e42cb272ff1f6b6c63bbf6bb610851979126366a360023b7a9e520f9defbae6fa36fab5f928d565674d10171b81cc10a1c6edd0662cd5d1434b5df566417a2a8a188088bc34a2c08c01da082014f5fa6eef0cf7b2718aedac521b17aa6cb6b82f67cb7d7657961685514bc63f576a602797e4495326844891b503ae426a2a02b7a1db945bdd540b09616441c55e17e5157b200e2669975b77d3fe16a5c2d8a46604285d9732358f3ad385b90538ce6c05956708afe88578f87c8cdb87e4ed54e1da92d3aef56afd7af745b5d23d6e2fcf1b7fa21a97638de00664a7fb7a1a27a72864023c13834c42ecdb8f39d3e844b2d8ffaf359debb8ab1a9aacc5ed0d4b48353f435d68b3823941edeb06984b81bfc165dcd476c76f0be18c4dda225c4b0d6eaf70649f6779b7bf50a81cd8c231630dca2fa9f511b3040ce36223b418f38a27664a3b239de408e4b79102ed5cd7fea7fe2c3088db8a16f0396d4c2117766b672788c1bd0df3fe8b9e9ec1f4b9ba589e97a078d53dc7cc36424872d5367c00dd82363447e248ac68639e00ff55a0ef2a9080aa8bfa95b584113a43f63cddcce2a9dfea42822d31a1bbc8dc7670110d021abe33240e417c9f64249d1c044bfd179036937333b22991b1e620f0c2161383752d1e22294de9b0df6fb40f81bc3d48c7810f0ed9d116ad2230ae3506996b63314e459817fb76a916a29cfaec76da0a16252b373546cff3312ba8e07ded7dbebdb85bd5c41ed68fc984fede9991656729c28a3f24b3190d799eb7bdf7e9796246099162283349ed64c5a5c450dfe6bb6de8956f580b079cd09e23d21b6cec3a3bddae8c975eba7a13b25f6245deff61fa15a43f9a818fd6c26c8a2bc1cb49a26bbc18d44b0f7b85d5c610d765d2d7a6f83c08fa1086a7d34174c6b029504cb107fce9311e31ddfc920eda6b5ce81917ed4762cc06d016d8486f880b6b6d4a7239704cba50e8c3e6cb95e4e1106e6acd029434143c5880365ad9363c34ca2e69933e59563a2d903c66e0a5c324d5907777181b6d7bc5851dc7c0f0d3966e575cdcd36d81c85ba5bb8d5c5c6af8fdfd98ba25260a154f177598777e60e69b5dec04398e5ecb5589a234f2e239ff3156d1dcbc56a0e958b651c98d2f82105cac3d2cb3858bde8df30ee93a1ccb47549d93140fca8770e72cf8c32b51cf709f8de0ef47092d6d68ba4e4b410392285dbac529001b1a82d71e022ef9b6db6898a2f276ed8f0116c77beb5b215e7093b567fa0fb74d4af95eaf7fdd5dbc067ddcef77d69fc729368b6214cc3581e7256dc46694d105ea6f1a6bf582693345ac3adac6e0aca42612aefdd5e0b62141378519a47f320472a98b8c3eca0c81be5c063a21c9ee5d97c1feaf86275a8681d4af286df343e0dd172b8641846659887f36805317fb01b4a6f6271b40f55dedc1c63bef0021454ab8d0f36c151536dde6afe69c45819795c20f7251a0183eef14321dadcd0857df81e010c6c7530b46d12cf665d351dfc62aa4d4e2108e6e0aca84d4029b8e9c2e7b56206d0db32cb6bef74c41467d8a75dff7cf75dbe576b42c2778149b9d8e067d49614475898d0b879a6764f6fa674563454766fa3865c87a61158b0463e886e889b38d1e95aee69be9b5287d5256a0a9383220faffe346b35b67b9d93541089b6cd27cfe2f007e1ad20285ae4c7a0870beacec5532a86d8281f7e4b0584ce33a113c03d2d5281343069e1f2bfbf879bfe53603be6ae44a9929d1fcf6fae54128e98685efb23b3bfd9b78c84491cd23d284f26d20047dee6ffa405717885177859f21c1fd77453b0cc90938c7199ab5944c3e685ac1e67fca196e91b2fcddc9c1a2504f655904fd684282d6dcce739dfb95c59755abd53d81d2c89ec07b7e0fd6a94a6fe8020f3a876e29811cd3edf7a7af63694b94d49f99dbf046bdefaa7be8e658b44cf0a7386ebf26a08c630a23c9623253746bf3334ad8d9c86742a209acbfd7c601dda0097a83bd8ffd9fac42cb5414b37213856b55a50dce7f5f4d94b9b42417296ce7154467f319f5410df0448772a1ae2d6e9ea49dd7dc710ce22827c0454a46c920f6af8570ec06397cc2e010535aba1074e153b964db4391103fac246a6e659c72d5d45f04ff2e1faefcf5feac6c45e461d6ef0effe2921890c9f02959f70ce7ff27bcc83298c18a76fe4af33922d10ccbf0faec5c003246cd030d13128a4f2b0a8c640c0edd4cc0a3debd3845c6674feeb9c95d013d492795689397d83f02ea9e7df5d7f092b00391a03dab2baee4d54a963c5a6e48c018443c8b8fdf3cf0270a55793f45e782ca3e98ba22ebc3ec683599087684374a0989153da241fe93bf0afebec9ca82d28b257c0c2f09a9cadf5fb20e765f0ddddbcff909dd8e75fb6eafd82b12c796187200495fa084f608a95dbcaf56ed50a1f01ecddbf456422dcf2cf5a909441b1572caa73985cbe9f9b4c9a3d8179ee6f6ff4919bccbb205ee0052647b6fa5c4ede46791eb87418f474d1272da3375f9e0233ac77df89ab82d7f8c7bbea7c7b072e01ebbf5edde2bfb3da9840d6b136ab0d519fbc5750a02f1b1bddd2e42f8dbe294b50e14da5ced9ec08f4119234a0f718a9925f89a08078ced11c8c9d8b74ca86049227f098db660d68f923c9a7a1be607bf72d59876349bd7752c69b74b3f55efcb24c3eac43abe8f47eed1651526f96b951f78e681ec3351abe117ed8616c4e3bce40ee3fb4ebed0bf897bd870c9200ec9dd33fee47617643630810497ec82e9a98562f73447af2ba1da4ca9c8447c50400bfac31e930d6aebbaac4b5ebf197dab916bf2837c79db06c6ee06bbe29a163fe6e9491042dd5c4e7b29538fd70d6f1715d54202c983efafd9535b62bbda14781926019f4b2082e4ad381980f4ed4c1983f4640c92f635eb5d8cb87be287248eb38c342bec01ec81a3cf742b5a2db37b4b598d4566fc7322ee7b7ca647573d95a199fb06ed2f048ece76bb45a239fd4a793ddf04477979686c4addef3f3d9afe4c94c31e48abf9b2e8669d415fb3959c12161c30023bc4ffda36ade22edb44fe7b41e7ae3c8035a5bbf8e4b1ca9d9d2106d927de5962d15ff1ed2527c689ae79eb5cd4a4e18d0d317d46de9bfd3c3cf72fe520296dc7152f11db38f2abf76dbb9b942a3c44bbe8e83c0259c36e7121a619bc6a7a910af7d3a0049b4cb5ebcae2467b1226ffc94a4034452aa2df4268fe3ff046e46742d93ea87d3d34ba7a3e33f7c8cebfef334c203f42b2a3502d12eb433e9fb2f1e8f4792a8e766196591eb64a26aaef7cade9dd98e34cf361d16b8112150f463962c700674381387d38d5527ec8ba92095b095cabe80a9567dca7c29060c11f135c9c2c44950d5270ffd75b23acfb8acebd30c3e1820134a92da8b2ccb088879b525eb0a51ffda7083c98f144e20f8b16c3a2c9c01c5a91a40a28296d57e02e93b5ecc94183f85b4ef000e93c1650fbed6a5b99a3e91eb9120c01a015c3c81bac9257aa1470741546c319495e53be199f9e2d06ffc7680e8eeeae3e1a97131b5f0e21628e63e9e8803cb2fee18f3287e2e06bf6f1b11a75fc8d907c97458cda67298e75f9f3fbd9f92f1394051311e1322d34800f08b8b85e81d26f1bb4f183b0cdc9f68106d71d3d9ba9e1e154ca056893d17472d54c7ebadff0ce45c11180293610d988cb921a6ee1769de30d105b2e8d82270f878e2b96538073e8a2801ff844c34acb9e1b50b29b44ab62fc1d72c3af8126b2d1648b8431b0b1aa9f6eef8f38b6e90b252069db173045e2f85e647513baac248ce4a7f45e64213277b5f156dba9d8c8925bcf842a35f6d813ff6b39d2a62d537892aa4c5789c05321810ddb22c422f3ee6644b30623d99f6626824a5b84bed4c7bfc8c0c63f0a0cf4cbf7db11ebb7d09b6960b1ba3b6c8373230af1e4bae97e87ac75ae8a7bcda3e70cfc0383cfcbad58f8362b6e71268cf335e8fe828fab3516f6917025d00effb47f710e1923512f460c5ba5a4a930e638b6bd07b88c06ee768034e21c9eee5010ba47ffcbe9fa32355260fe42fc30d897d2c7305b4e142ac607304c8c2747de5cd9e57891ceef8e0e25fa3f8687b0feb4a4a7fa5640952c34cf25f6fc7e4e16921944b1073fe2da46b7d7fa4383e1026f3d22fffcab9bf522173d03bcecc86a9d6193951064f8dc52ea4809d7341087c8097a1a7b74ebf92bd5c3eb9ab8433cbbd1ae97fa597fb11ebe8370504cba1145ee870a2571969451e9d10c1578784c869b7eb74b43b9b8a12a443c048c8fe1b9d849c5c898e90a0bc161bdb461e7f47bdba5a82f472ded6cce68ae21fa60454b58b5098896d39cd0703e91d1fc15d38afca1983e99cdc863381898d74a6476056c68df44eb05f2ae48fe4f1200ebb07ffe846a9e05ad4f2d791b098a5e754b398ef0d42d2d35fbfc90a9b75470a0a4eb7daaa02383e35e22286c8629d15cca68b15b98e7757ee57c5dd5c8e160c83154439891117153ee2528f927f115eb99d28b57e909b4e6abd1d24ad4017169b6318fed63e7116039d28b2c005039d05f68ea4c8c3d013db9ab6f73f030a19802c632a77b9517dbd496613ac20c2f8ab3069eba64855da2e62362d9a6e9603057326580d503c4a614c0ea4b0b7b9d176cde223ff30e636a2d8b5694324da6c4764120489438b5a0c6fb352d00901772b90902310e2eb2465cb093c070c6ce170285d558083f4b464d9e0123626b544454f6e7c7a63c3397dcacaac98269bca363eef4b3d08840fbd2fb993bd7d8040228d3c258e7357e36e2dc097e7875388a83d2dda3ee875e61eba3a3c2e5628de7202030c48f9d18946fb5a474acb15842eae45fc32571c14a1746884a791fd6d2cd1fbbfcc4822b3410879d67814c0ba16d90956ad42f12023d7b5ffb1998631d0de39c9ded1598175f6e957e55f284cb44a3b511bb7349e415185b452e233a05442ef9a86551211435543fdb53ace7c54ddfef696fb213e4405b4f9d43fa2030f5953b070177b36ff97be76144dda3eaa98d008f3a901b486b068b393d62691be1e9011c7af021da469981908b1b03b3602d2ab26650eba578aeaaceda8325d8d5889e74d21b43ebbc8eb4b612b35e656cde8b15d9b070ff65d4138cd12c0ec8774b81b66a71880f45409f9e5acfc57f1c8606edbf91709d3fe606dd26273bec37095fd96cf7442e78c92c770d18f606d089d97323dd9abc6b5d47ca2b048c71f0f2c3988e15e1c3eea6f9c62c81160f72732e2c27f9e449790f235c1c7fb083662642a91771544656a93477da081c8a5a05c35cfd3ac6869b15dfb250c63dbfe453f8749780690111359768b699efe19bbc5fc0269a91e9e12feca6407ee8a0a36fae3e4e294cd896b4b6810a2eb6881caa69cb37ddc64dfcc644e3bac24d27c4f5ec7c72298de3100a629bed2731272359e3fac240bdf355c32bdcd6fefd917e314e0e8d72e260afa8388bc1abaf1e8dc4e6124d74a6b0206b4d1a4658c571afa067371f68e91f3303a8066f4f38cca59c4134bac09135fd4638861b193d1b8fc9355b5d1577c30150283722743e687582ccb6d51f15251bc3437a28771ec5546cc1a6f3bf6cfc9061af62eb1240b79454a988ff471f957ad55da4366b75a2cb7142e39c8286565ee834354a1c061538e2108e4c26fffe6fd120daacad10078ce9bfb6127f04818d8a5c7c8938d2546a599bf4ba29924674697d7684e4ed70cbcad07c287dd5c75d0e6a95ba30c1ed9d855a6ab10a3d1c9b10c5989d5653c29c6108bab6d6ce1602ffd0a6aba06529f062f10074225b62f055803b9f136b20212687cf0960370f88ee0cb07497e010ee4c65a3d6c68f3e2c30a2c06ac0b599f9f7701ca306ab281ed75b3d56ef08ef0ff297301a763cfb19d1c69b9bbb78aa828ae5ba39bcfe46072630631851a4d653473b96b7186bc53a08e728c55b0b01303cdc5e6e41a8a62fa3c49126563c5be7c828d80a86c1bd541f0cf66bb0a528b9fd604d46621cc1a7ba3c202a334201fff38eb57a0030d70c0ad7435b8b95857c91679b2480bd137534c303930e5190fc3db309fab843a3ec2fa6c37882b20ac9b0d642857bd52c47a668c428b5cbc5cb4c30254894518c1f06d8dbcabe83f2898afe061225842dd4195164f531e71205d486f019092975c16b10b31cf4a9ddbabd51fb1f174d0ee4aac4d23abce62d814c424a180a2356d9d59728c3dd90809587f569546ae8aa1469198f46410cc2f61b7b65a76ba1484e9fa9d04083fa707eba75ad8e701c12dfb8af7d22ab9c634691dedb240ceb7be0f4f16c9c8fd5f5b174c128eca64eedff71ca096e550ef8497cb979d24e2f8ae3200afa629c97bec4b29011e307ebf0ce8377b3d0fe3b8534f7990c9f6e352a01f49586f487b4619355683de54efc7dd1618ca3e0852bf204a316845b7e3de5011c294cc00b5243e4f69a16939e398db29db5ab7a634ff37db2a7a3fae4277462f58dbcd50d6d0a1e3ebbc383cf0bd1360fcfada6e07c4214aebd41560a3466341c03ddfb31d5da76f36860381c12d8b403d8efa6498578e2639102753a3abcd583e140b5e28c1f442f85c53a600dae3bae80682bff5844f4a425f0f1bfea78d014b9941953647b56efa9d645e8e1579f992aa8a2302e355c0204c77ea446e587995e46beaed68968d452213495ccfc46b074cae7e1a09ef0b0d6a015702011840523c75112435722861315a43332bb4365364233601f395be30857c8f45334726840e50e5ffa36239418acfa262d89ebf449b589dee49dbd3f3a5cedcc1f6291e0f13150503bfdc6c76603f8bdfe8f9d64ffe508863224fa5582b00387db5b5da99a2873efef09a7f460fd3a62b37c8efb0c68f578d96ca98ce4ff7d5fe00861172d567551e0538f828656d8638db239c8ed8bc0b0c7742884fddbf817e8727eeb95638e7a5bfebaa3b190c694a69a1821e05481b69e34052bcc3a4ed19d4809357703e9b85dc2114ee6bfa8c14bfd07184c44e55652e9b853b9ece4d1fc7d20e7a7dcc89de54fd4bec31eacbc043f9fc78ee142c6e3eed4ab6ff55ec38f935a6850a654a5574b1f5712b700be5d4148825601bed6689ee0f6b66918c2830b59e7c262d3b4ea6dbb70ec28db8fa3d977918c7581811cc2f8bb26d700bccb58488dc2771d6b952e31a00974960b8680ed084048b7d25cfbb853571e398981737c21a3a411a9a164d4ea1f4c81f38e9d813fe2ec482d3cef7580a35c01093d460312ee3d04cc7a4e26cabad9cffd2d91de991fc5f227f77b3595f409533d89d99ae743a62eeeb055914c54ce5f4b6cc7115389a196e7a82eded908fc4a70a29b4b96d99b5d585ed23af9798783d9ab951edb4a18e99fb4ef4b681ffab7efa11e7d3897883e4b748ac878b7d19d035c81fe510c379e72d1d5c72d070735fa14d369d1c91c9a30bf9fd9a0f8de47c895bbfcc4a2b757ac77bbd1112908c0fcb749002392babdb8cea4fc5c0f2b2e65c680bb213c4e70f8bf66b1e71634e43200d55b812f8117513c022a909ca35b1fee212f659b09d52e71275a96e58f5f3847fab1b0b62b365b5e563e8151d67f9e4f2e902217849cc614b7be4976c333b40722ec4ff04c40b07da0b16f24970f7f21906ac486be1daf5698bff9c6936060d8c0c000ad794d4d5ef5759d855c9a05878ef2715b1013779ce4af20185352af6b37e497dc8aee927a722e19ded6b2f9a480b56dafdfae5cc41e1d7d05961d08f342b0bf8d3b3b1582345a9a8a88b5b2e91b53c9b9e18024345ae26cdc1e0f1a966a532a25ca1125c12ec2adbe58e3490a7ca5b54cb74431031043e29ad712d9afdb4db29f5d6ef06f06a7ab2661aa53e60bbd46d2dc2d229d27725dfac16b5711b1073006c0716cd821a4064c3551d6879607938d6bc5a781f8688dce7dcc8bbbd5613ec4b51dd88d0164ea87f89a53d20dbd65232583ddb7f97796c3033f7ac2d00df8ef85e74d050abb56923265e57576419b94040be4068f41cb310071878a0b915190b6ef90e301e4b7166bb6ae3da76f31112c03693926911c5e066651c2e96a42a47b55d355eaff590de6e4a738b3abc429347edf38e8f5ffd93ec997f7efb899fc46dbad3c8de3931e032911fa614800d3508975b5ac52e7593929587123837d7044cdaf39276057e2f5b1a8ef84086a26a4b60809431c3ae9c3daaa1876d7561faa14c90ae2a5d3582450d6b41f759739ab496ea43b40d931912228eab25480f67a6b95c27c6d01cf7695690fdc3346983b3bea6b3b356ba533ccde915cbccc7493bf98a8e4eaa0ac346bba2b30cd5de439165d3f89bbc8d3ceaa3c7b132b4a7a49cb3a99ca8c55ee267239e87cbfc6a917768e0680b8b34f225714a8dd28822cc41c7ecb72104d1eb31823e67516f3c735c0e286a4cd261196c69ff8770d4f3a2c785aed3dbb6650d2c04759b2884a2125c88bc396c9074b93207dfe727ce861213f2a2523a7b05b54bf4efd2700af317f7757e1f40f5dc01d558c327afcd8cb537fe84fb39c48b157adeb28e8e8abbb38bcc10e58d354dcc3d7684498aa3ac86611ba3607dd87d04d9050e5551b809b4d5f64b066933b65a4d0115e48f49de47443c77ce88caf6decb4977b4dcb75a6f5aff8a0399de4dc85885982e574e7b8f32fb46a925f7607ebdce46dc9f7a769414fdcb0a18e2d987014e71247c1832b71b4983587b131875bc7e4201690d15f8500fe17b3cfe4656da83f29ba551fdc8c92c915dc33d7b3e0f1ff3bfea9b8b02c313f86b87cef5fc1994bdd6628a0941a095f1eb67f56221a43177cab652c48dc4b15064bffdce74a04418c6af7c753d5e9f6dbd4d9403a411c5add972b38db608f85f62f671075df1fe52349cf14cba455c352a0c4d1cf5ec44e7058c5cfe3ebbc31c93bf797e45ce2a02fbde928838b81ec9f929354de07ae84b437b8105802fe4f95241e39c495abd1e8ad261da34fcce64e4a547e1f4795fd165ebf0151354984b4a846d4d483d51e20b23f3ff323c0c3d9be190579066e2a05a9745690d53fa71011d9ee30f9b1192f3a3b0fc509647744636333909b47580e7752bb65625164702e884c91378dd45475e2ebad95f90e61902f19f8258c0a5c991070050e7041a6ec78366286fbe948e2215fd52229351f17caf59e2bc5ab5784a9ced854f49717ff04f8938ccddb3dfe627a0218647ee3d554a937fad50c7623efd49c28474f6330e3068c356734fe5eaedd32caf9388c88238f9f1b6176c7f83c22935781cdee4c7fee6a00223572b699faf6e26406c7aca0e4b39098ac0683a212adefe6f655b538331c3a4108150a7b2db8ee6433c36e94971b6b1fa309cb22ca1dda434f0802c29362bfb568102937aede3c478af7ad6023723b482301a81cde9aba43cab3bc2ee584a3a6ce96622281ba41f5cff5063d28c9d0df24eab6d07d4f1d84c53be9569402d4b611a8819fc8da2b8975512b39cbf0469debd7c7d9252aa18dd58155a7646b5d181eaa68945c1313df39692564c093bf6e56ab3a14d49c0b491b2704818f3bfecc97b70296eedc8d149d48b602b2c19de4cc26d3218eddb0dd0534ede7640da2c6564ab8d5d86244ea74b782d24744cc98a2e6a7a157a8d6dc5d881f1c9d8c636e74060825d848e43c899edee1e58dc44096a00dee2ecaf8411cee5f8e07aba79466ca3707cc19941a62c17f4947668896716c84d32f2e6c56f7259d4edaf1a6eb77040bf4ca7994145a4de3a030ff7102053e25a055a03c280912d6876c9a5832fb437b8b9750dcbc53c10f71dd4105ea45a6c0adaaeb0273c18a795342dd29673a857a0c882dd434e0d075148b59f7c4b4098e60f7e2a2acc4787d5de705d80083d5b308a014aaacb5a7c4109aad24c6ee04b862e1309dad56bfe7c9be46881b42c3b7d082f9877ea3062eb9b142dec3e961e103c7f8f4660c37eab39d43f3518419a83322c185f0665d3de3848ab2aa1c52fb0dea1f4b1a06ad9fbaf00808a60f790560f1a11e34f800e64c948c33f9bc46579ebb84e73e2a1595620b067f45c12d4686e470c3fbdd29548954093c60d0095de91f7d91a7d759518ae86ec591332ea080811e5487c6e4b915f2486efcc5aad2167ba59c67c251c4bad135bb5a86c71cca4903f8447e75863209301b7d8feeb674d4f5639cce6c7f325ee0151d0a3415b2c5bb90ff4be779cdce4b323559c9173de1f63838c22400c3113fc28b87b4a491900c35faa374c33e35f37d2c6277e5e730a38c3cb2624466282a708212ac3f482a5485e8c26d395e3c84802eb02c9de663d1c5d889b02730146e56e06c7de82903f86732065ae8aa913d9c5e9e082e8fa95e9fd85b7659c49c9a0c1ce6618f6398c7d0689dc30e04493b1a64973fe5c8ff01c5e0ff39e2698eed5f458e9197317d3ee5d680451241572528ed6e0a19ed21d04aa4df45855966587ab73f89880a2686272d7182f38d519a35430448be761b3a015c36632d6b54599d9ad24e5d3de5a1fb64fd3cc7e09e912be0e2a5146cb91d9570ac64e5e26085c227613ef16e191f91145d6ea5134900bb7b6359f50d3ca6b433bdacceda53a5066132c34ba447d27657f5c5f3bb3ed3c60bdae50798232e5ad520dd702ea9c72de7d5795a62b891b4e31f7d0b554871b32518cf1cc18a0cb4b8ffab98118312d00b9e2175146988ac0744024bb93827da8c50b2076da50041d812dcfbd39ff6aab5133862d729fe9651ef02b4177548988e5d75e0a1abde3d337ce5eac49f649f3c797caf3166a76cba2cf76ed9ef0d3e49030f524b519a3609f4e4a4fb9b2a1591111e01afbda032096d5822b2b8004e9dbf8fbee3feeca4a19efac7bddcfffee64fdc428d750df46538430a26f91fcd11680a5d06cc41cb3602ef689d4b889d14963c1d3bf4fed5b2173de831544c14003e03c7fb9f52c721f3d8876a837e33227240b355c97cd3b8373fd2e5968c1fc9d136b7a042c8fb1a167668687fb7101438943a46bb33f98f03a9a290c5309c9cbfc43a39039df8adb4544270488ffd56d71bed4587689421554a7a70859184f19adad8ddddea409652e230435d367dbc1162c389daa7b41800d313d76b2fc1a6fda68f71c64716791f1e9adca2d3e2d36d8aa296e47f3015c2eedd1e585c2e52ded0076146a425e9f709973b831a25236f088cdd234fb038f785e5ddc46551d89a02f499b51382f983205659d799f9e95794e3a9cdeadc95c67eb78967ef7119db207bc532c9202996ad2c865455358f326c9f63460f331ca0df88f5772b0109f56c12ca4f03283669e2cd6eac8d1ddfb91143bbef543ca108419531f1ba980d46cdccdd45482971f9a257fdea48b0fe4d1dcfbeceefc9cb9f21db0d8ce07b02cfa8814e6f05cdfa035e4db9a53a30a803c175f6c7d9ce76a7855124bd3abe55c4d28bf0d08e634622f3d6b83ff870643ff8af2208efab8c9803bfdd143f6657537effece4727e08383e7f1d519180a987c1a59b8973039bcb7cea053971c1640eecc659ac3f8633bd4f105da3db7b4c77de2883de2fdb4ca4cdce0849bc85db4e2eaafb8e6a0223eea89246d39e5b0212ab6c9b956f3e20143dd37b707db13fcede5d5bdec7981e0b41188a7edc6183b4639d7bfa702895f69864269e62aeed30910f38edf65d0a646c60ffbb9013037344ec57b5dd4b69bb9e4c2512f7b5a1df63082bafc6c16854c4e2ded4433e19c7b40ac4cbde0b0bc655ce9c256bed0cfc08007bd9b259b7c6df2c94923ab1f4327a2b50f525e6731ad3c419f6033ec6f1327e2edf542feb619df040fd2d754a524a70195dece0ff4088a52ec53d2db948714a1757078f34bfb34ac8aea8a270d7146d112b5051e0e156213d7f2af8582802fc5bd13feb8f5c8643d64b98dc18b97a4a3de328bb35dfc3e70384b458fbf9c8e4d34fb8cefaccbc91bef166cbfa675c882debec5ddcae4f348991ff979130911c21afaf81a62c1ff59119952931604f0fdf5be4f4bbb6c81a838104457b1ff7b0a16d1f15a45b00fda7fcedd41f764974e83e6efca0b29385f83cdcd5f70fab80317350c9aac618176874894c000ee0edf17bcaa2f9994eb1119279537dc4716bfe5649f92ba6e14f53f333b5ca4419c9fee6b2d63e8ef6b5f15f8f4f64018f7800d8826ffd5a8123c7a3b2b1d7ca391a3a9990eced315d2e46044fa5c38260cf7babbe89a24cfc56987b0bb77e2eb7d4faaf973152474ba56a583e34e371e9cae0a70fe3ad23c0e3c6082a4361126b9fabc5c5d3160f1ead7ce3553e11a5f89d79327780ba149030fad64d9ffa1ad0625c3a4d1016746ab1d5858994183880132836c04798bd5a3257ff81267f93d802ee10a10d8b201b4f990a4c383c9ec6950c7bb0034335179186df0c5384cb137e4c85baf8d2599929fb0ac152595c18b876cfc9eb35953c3599b2514d0926ed865af5092322f2b2de118b57798fd9e8539d63aaaf5f7388867da2b8775503e3d785596c4d28b833b10b2cdbfb2e2882f3e9a86990f88281f2e0bade90d23884019a03f0d2a94db4354cc45e2059c0d9cf5cb23be9cc267f5c1f2384ba0d3d015eddff1708c7918412126f2f5bfb17692a6243a6bd74d2d265adc2f9d692f35a08aded147ca22d8fab59dc2de91315811451648c23f53d9111489e6a078be83a787499352356a8e1fd4cf8dddb67cc2cf3448f74707089404b5463e84bebfa74d8063f4ca2accde414e362c7e300c03d905d981137e26c94f5bcaa4fa7d59ff72e2009b9e0799381d0d89360bfe8e2d3c62da37a65aa620485731fd6f092bcb6805c5890179ee00d070f7fa9d8259530a07c0c21fe4c3c73fa5e14a7178a886415d17c1375065e58ca9fb76b77a25a113568d8928a7dfd67b0793021a243ef0a4ff2380bc8e077b7104e7b6d7d53493b5850c319a026ab744e1c0dba016b1fa9e138a5d7eee6b8930c2839e0d84e29be175aa6ef4d126a5f12719bbe16708a97bb45f6bd23776450b874db1c376138916f58582fdd2183dc826b047b5e734ca19b8bd5956fb2ad97508fe255af2d0d4815175be118f2a394ba068ab7a6ec719edbc817cad6adedc9e962a36fd1a9f067d2af2ac0f5d8aa62cdeb6f60e64c82073b6d160a7a8e46fea8ddfc626c5f1746a4b7cb773623cee24336f82632c417e75d7155dc2305234c748272d8be060a02d4ab489db44dd03858db44a5737b2c5d2a5f6943c6c67d10a17880032d6aa04537c19361bd5c59c63406098e6188c149d04aac1a06f5d6c543dc5e5af11649087a34f3145795719d141c6db796946c76e08a7f0784864706c400bafbfa46e0502e3427a89d86555a517fd38bcebb8ea41973948f32ff8fd2665242cbe8d97fd75189fffea1ae24076d5b254592ce517f07ba085d61e7a413bcb27b23e7a7a93ee9df22beadeffe55b42427af3507bfae8aa0d6eeb0d9636b5510f59850045cddc18e258b0542d8efe5d1ce800ca9e2f6144053a02bbfc28d643578455e3c0267828ecdd2e7c7868be1b82be42fd71b64f52605c836965bbda4e6845a179e5fd3792ca1665ff23db5163c4750345eab94fe81c76e1866a76dc3a4ed6fa45dbcc1bb7aa01b6f056a35102c863c109624c204dab8c1f8fbc6136bb046297882fcbcc4b04284e746c9c2a0045068a017510c78b0d613a14ef89df72c194228a9a9dee1610caafd7458db1b89ae7274edb9c570b92f6daa5f297f73daacf584a4662367e8a92991402fd6f82a71003c827578b88c50566f09c0de691b10d272ffb9661fddc98ad729c11365ef5eba360c489da0a4d37adcbd205db33b09bddb297fe86f29ff3263c238c7368e8d8d9efeefe54e09989cb650ff639ec2a25f6d93ed5c6657d67c95ec0d7c77c799badd01f3725cac2d0f0d984b3f2a2c6d2c4137157ebf193ad0d3ca5d920aedd40694a64abb16c23d76a6bae525cb7a3022e93ff3d395866d10281d665e8f1a3bdacdea7f4e0225d2c2247bb1280d5d2e63ce2583ddb460942ab3f65c6ca1b0f8e8277b4da1895a10a6667832df601aebdab778fc0a7057e697b1b5c3bd2c90069d459bb9d7a7229441369e764418e6d6023acf0b4c6d49a65a76c55593fcd57bd26c888dd26c6ebee2363c129f876778944dc20c11c0aff76aef5397d8d53cfcd270098f8dffc32fcb2429e3fabcba57d2f927f0e49e22c02c5dcf553f887bb8b1061507c2766f66e64a74923158a8393b9b7c3e897595424c7f05994a5b7212f4527d25620e7176c6dc06b416597ab9864f285b2e306a2eca0c52d5f0b6918d0322f063008c47a5600560e2d5aa08a78f18bc6d139f598243e96bcfd25f153948e552d0abec1f103f685a900cdbb68ddaa5c4e6320ae52e9bc3f1f7a7c1c0b217e3a5fc26b0ebec9a2cafff47eb77dea8d24d1c382e1bdb8ac5ceabc84d327b2fd541b8945ff33861ab453e2cf7560ff58643c1a9488e4d84a629f7ac5f32aa4a5021d3d406f8d0a4b5d30f769dc2534279af84ea375042788518aaf26f26b3a84b7f2a1493159b542f57d6c84bd217f484f5870883b45aad54394520dfce837059394a326e73258288ed407fa77cf390272b8192bad5fe3851f71b6ec913ab444928bdf95b91b0f74a37b3e4e8b062e2bb70c1995c45ca818aa21ee7a84d38e0f01c53583549368152c289186d7bd56a66a0dde10c0c9093c929892d62045ad2046d2c71cf1f417ed9d80bfdbcbd189f73bfb7b84c9a6c879f624f840c57a0c95d90007828a1167c2e5f9ba8cae48cbc6562b2b763efcccef6e09be98dad3f13898be618240ff447da1fc638f69db17ef059ecafd15ea34be484edc89523234fe626a4f4fac0565088b2d3456bede71a6ee46c2bc1352668a65c3b138ae5832b7c2b2e503eb72b87ab440a2102c27ffbd286fefe5b95a917dfc52101ac37e98af89541fceebb50e0a635f414e98a2cd8d0b7a21df710bba14cb985adfc8324b82e8308ea811cfb8e1d01b791ac724545d9f2a2f4d0502e91154de30b1f82bf49cb3bb795a698b13d76bb701e0b88b797bd5884d6775f178e9c27d95f35bbe42993176cfc72bc0623395e430ce797b2e5e2b64d08cb6f5b96dfca1faddbb68f9e0990b12d1d568234e6b26349a289dff6b3c8e8e3fa47ba873bfc68f8671ad0adff79b842d57a62242cee89c54ba8585d172e4400c54c49a6769ca4e389becd747f741efb451971e2fa5b1067304664b323b14f4fa8edf1e86ced8f04ffa8b33be1096bca6907ab7353670735005ac90a16b1e7a39066a2584f2e5cd463fddf60b49dfd57bcd6e12ebffa888b64d810886ba2dbf10fe302af10e4b396df7d85fc630f9d7644f4cc52f5b80355a80ea97f2bd724ea4081b91bd7bcac24db79d1ec37d13999745be4e8b846fa5341e8782b12ffe79ca0c1b1e8f776dfbbb8f54afa18ae26555a811db57eaf4ca11bb1684b420404ed16b9fabcf16df418aa4ee5204f0db7f9aef7d3437c7418145839c2bfe6bd8d8764abce79032546e3b3b66ec2f0a86f049f01fe9ede7779277621af374b524f91fec45b8df8ff6b3247d2f8f86331c639cab1e1e5cb77c45e1d6b3e2abe8c1944e09388eba220f8afb0dca5eabd536202fb240737f0de9480ca4f65e861f5d6e16d8c587f8f71dca88693c09afe834594f204bd650610ad49ec36132a754703cec4dccfe4a37aa4cb8a985bb60dfa41d11c247f495fa1a67f1c59a0ddff91ab303b4fd3823cdb89d8ab37b2b634d0c96c1e997bb02a85520aac985baf995c798d81fc3e6151e8633fe5ce07bc19c358a5df400920d2793c63e97995e9895e6c1a7a68cc23e6edb373d248d232bfb3f3681e71dfe674a81c394ffa1a12fe0ac822e1b1f96f1fb68ca3f880f693d93ef9b172aa0623115aac4cd9b88ee98808f79e88c736e20b3146dd343f0578a3f28aef3f66cb762461dc6618d450c38031e0e7a5c1df84d3e455d5374ebb84a7d41d19b3ed601efb262dbe6c6a276816f125f982fd87c217732c5408129b847ff2657e73c9ec2747724d7f32ae905460ea0724b651d2a06e8528ec5ca32d1ecd402636072091261da76ad3777241881dad784c63d759544e40a34fa961172a60ba7973b40ed9e390cc2877d953731101047683df98514c6359cb532d2e199a24ce058d5f2ce47cc3fcf22872e0fbee69e7d09e0728170e274bbbc5cc9cd75c06d94db60c348c956df6d2094205e172d918c739af50782583b23d228a66b9352472219d6083ba50361f4a7fac8e4f0ac0ab4fd61899327acf94e8045b23e49970f1cd949d118951a30bd6e3419b69c97640cba401e12b2de49545ace96a2e7f8535110ce8a71c9d137b95dedeeee11249fef63e8fcac34b91d08bb9ed824da40d7be5aade935d930de69447755ce6171aa1860fae4a3104794aa4f54e64e925ef19526c23139d75ef991c6f4d5220082cbbdf7ea6961c1aae33e1282e3af1f77841b580b9fcf4380788eaa474651f116727e06a52dfec29d665c42253d58084d9e221062abd9bc348ba503bbd913257a018736fb15e4d8453f22d5fcfebf5007aa3f4f7598e737b87c85e872c79746aaf978de34de9bc087c13b4f979009a121a62a07e4b1b66576fc69f262e6817cffdfceb84faf6f7089fddd3cf0ad9518b5d973864dd6a6487cb297e7a5ec5b5533b28d8d49d84a26f249b476b6a4d8604c99ef36a330aaa01e58674fd6f342d99bc9017e6fcc167ac6ee420067bb44113363f267ae056c1b0f840c0edc1f3931958c0fc22654769f9e4ef055cfb77192e0010800a368f878c86eff00281980c086279957fcbb4a43f036ae3de7410bb471f69eed969f378cba182ec37e72f86cb83cef1573efd9806f186100bbd40cd3ca94f150d1fc1a8c46d7a7b578c5e01db82eeee7d5b7a83ea47c71b17ccf3473b10b29e9a1e1cdc1842b06db571d6552a3e41cc57cf3435af3fac320dd74a773d4ede17f6706e9dd4609178f9ea2ce4a78540f9114b3be516cc2cfc7b1b99ac24790b182296983aeb7611e98ab7fc0d19c5d80d8deb9ac7c5aa8851471c17a54ddfe89ee92b99936f30757ab2d41735598621abfe5bb384658","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
