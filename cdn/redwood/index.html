<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89c8c14303ca0626b8950ed1dfe232b4f3a51347fa49bae2b00253519d7fa8ce0427eef90f412b12f0293532b2ad3f006a63189c42be67c18d7713d00501af0b0bcc63a5ab8f84956efc92b947892c2d03a7959ab4cc4f2c309484e8beb577ea5e1392562e8bb166e827ba7eaebbcc2230d3c0141f585af68c64cfefd92f6c41cb8f1736334f612273f085aab00bb90f7c17d09835d8d32a604ffc6c40cbcee6d9fe813d50a326a0cbab3d82ee990880e3e5caeae043c2765d334dc142b17176c5bce0a621330ea37ca3f40d6a32840ceb3532e35560668add72fd1cf1a283441f48212dcbd0f2ee8e826a13a45f3f1f342430f787e86c687bdcec3626f858430e7ca1941bc634621785306811f52d5f53340cb83fd756135183d56f909fc196d8a8b4e9eabb9abbf83cc60ac141a462c1254c4ebbcc2c397d274f6e5aa7651b5322478787149dcc6a22cc2cc3e56bb091352beb312ec8147274f05e2805c9e420516325b587b4a7abdc7733c10765bcc1033870ceb9b421f8a9ad7a943f55fb4b8bc28c80d9ef618987ef7808fa2e41bc65951ed78d4dc9562dacf5e67cebca5e4103c03dda284eece5353628346e620ee46fe64c8d4611ae5ec13ff141947f04a23a383e6aaada1abe6e3d1eed00cfa37eeaf7c6bf4b2043c1e597d81e2032a0dc5741fa0904546c800a4f8b5424835dd50735e812f723bc73451ef86279efcf23fe3ea4aa66c748770de0ac3f7e29123fbf776491b1759b2245750063d346036560abe6461e8cc8ca800a01c581699664c3296f5494fe5fe41296ce6d798ce017785a1d8dcadfe9fce447ae4a04b0327a876ecf3348ea526213dd8c1f4730d01e51d2ad298662213a98ec3d32543f93b2245104fe2d886bb7c63029b62390c44272a62cfe78cddeea839a3e369c6950369e031942c29e767e623f757605759db1a9b79d5ed52e792c4db80cbcb0c3e93f00415166407171de140c758b0c7e93ac32f31a533b250e369504818c5d84b6fba8864cf3c873799feffa1672a01902ff4ddd45b4d142d5fef8ed2fe06edc8620beeb76fd337991d19113c911239fa8ce6159a865cdbb55b61eb03019a47930c82a43ec35a7f05626b687594849798743a5a809ee1c5eefef3a21e253922e99e28398984f923fb9222b4427b6ad21a00b333c58822693bfc51ca422a9b3200cf729a80e627892797aa27264b8f806a28c766f3250be964ea49b55b11e611b1ce5d595a6f4c5a25379f7e42a39a919bef0b8664db341155302dbc29d8f9608ecc01c094c94131f769057164137b83915dc9bcbafbd4d899e2f0f3fdecb62838261a782fc68cd5f10b1bd41203ba32ab43f72d4d26b343f5e9a2c7d34e9172fb6f507d83921d28b88df3431435e7bd26687fba594256058b8e05e574c2bd18cb29e6e90e44602c64b780084135bf840159c254a23a0c8a711584f2a72bd79dafb3d2c980206ec3a60ad03bccf4cd9b61b9b4968d097e075f9f9c08afe1c4719deb72ce6d694bdd7753a970a03b79a693a0d120c9b1062882e17d0cfb49fcf1205df5ef2491c5c9c945e5596222a7f965668f02dfd25a12b3781c29517d605d9b7a69b38ddc59393f2f99dc20a90ccfa32b93da1b87ea83896eb6d9276da4860d10a8746e13a8d1337460da72de82631905be0db86176d43c9fbdc65c56e3bd0a55a5b678e4fe031d04f4db162360ee5b1da5156d0023ce98aabcb2393a9ee337368a3aedbb70ec93f89b9183c2e23c7aeb8e20e0004f0f517f74f1285b8d4b41b0de2d545662b78156a4153850b898aa2d76a729e12fcdeb52c9da8c4541ebf3e212b4f2572eff1b94f0c38bb18e7d0f5d8f9983d71d4c2e28f2d49f0182d2464d31bd351ac0ed9f3120b06224647bb74fecb44bb8b914c2c54a12d9b3932ff505d6ac6ab7cbd6cdf10a07a8ee64f134a13e5c775a10a8bf06afc9e4faef4a4f4932d3e2b3fcc2ad830abc7885626cebeaab872c0d231cf3316ad08deae59f9dc0157349e1800f889cb8930044ab8cc1009fbcbd717163f85de47305955fcd2166f37a903e917fcf2475192e25199ccb80357fd2f94c0e1f5225f2d599a05ed1169575d4afdcfc3ace9fa68f9bb2b0cece2bde1f3727a189098f377495fabee0e901da83634569d4eea438ad55b4ee12aa497916e791544085584a7d9c856ea0e2b7309c6098ed55622b3a81e9fff5c559ed4f50736066db979cfac3baf7a1349c82e040a2ab2da439a84156b47acdf314c99bb0c681bd54e597389879842451801faeaa9e0766305eeeb60a105c494f1d3bebc07e886349ee9fa8cde144bd74e652d7904b37a01a11f458eeeb0332d7e42f1ab0674521bdcf429dbff93449483d267faa561f28f1d4dcbd6cb5237fdbbed2b8bc0d4f5456c0d8bb4bdc37da537f4e524d88efe30358eb170b8fc394576e928f8a27f54b41fd334d43d7f58fc2a852e59a651a41a6ee9081b47e2c922a70b60eb194e1645f715a88c291825367bdb752d3d3f297daa0b9ee233af71416721b7e41aee402c4d3f61b7b7e833525aa0ed4d36dbfbd1bf235cd1171b009924003ba582bbaff8302776c9433cd3f09536a51e688d2ef4b6b5c09dedc04d6daed1362af9aa0b68bec65f1166250279bd4b4bec20f5e38c50213adcb347735e88f72badbcaeb097d4dac4510fe2f51a79ffa8ce2aad0ff89c0b0f20b90d0289277f975ca544c92943238c9bb8a68e17f3d1f79acbd964a512cebc1f9bf8d4f83cc340834cdc63782f86ebce0d9d1db1cab1779143806ead10e95933379b3c7d21ea26fab1fe87e931815c862a2c5f966ffe3b768e0d06abb652a3c4856bc3c23e944a8d71b1fe134625f0060654cbba615d8f55c42ded49d0a67e41ae1c56f06bd03a6484c08f4e4171fd360d122bf131a327b7ab66a2ebc326df3932e5cd84555f759d6d62808947bf8a8282ff859e9e7619f36fdb6d9148dd3acbe9f54bb95c6b0b71062eca50b4ca673f68d59bbf98e0f60de25e499f8d3866f50057bf767864511427edf472a97d8540cff3da02fc2d75bba4ca0630d63a8831d8f3d6b7d41967a28b648da8d62ef149280edb7f7338d7682b54b4460ef72e49218867a9879212b379eb62ea2dde85ba7a1e5251e2b49447862efe5d22cc33a746b1dec15dbbb6490b134f1bf67af17b3d68dfe3ae0715b318bd80681e9ef336e5d39b5707fc0bb447d48db70e2e26d637d9ad7892ac2e3edbae266ce0fe9660ea5cb1be0ef796e63952f4b6341128a8b67ecb8b2ecf5a57f741879853042739cc3e9d611fb7dcd8fa874fab14fde8bfad8f7352844827e98caa55098265ab900ccc55869f2770a39e4da553a7522b57492f0bd41ca5670e54edd570a70c18c5367744ee7284c53d5be1b37e3a5a92aacca80c740eb89ea1cd65d08585b57a23a016f07fe96df59ec071ab35c565c265ae2912a69627bfe446b2568945f419e365d2faac2b1c855918bbbbb9d3b03cbd4c147e31a137858a4f56ddc94e04fa945d6f1de487507b3f4d388ff67e1e391e3acab27e6c7416c9a61ea622880ec0aa6e860675f7b615b0203cad11f9675f3d34471df04033b3d2cd38b754d4fa6a07d72148ea5371f85173390fef9d0e4edc4ee6aa4bd3593d1bbd3d3ca0d45b1faeafef82ea84fc61ef4855c747bf5aa1fb94366bb3a23376a7f133e183f8c39dba16fd51bbd5b739af51bc71536362d2741790036650578b42d3f74c807a9afe5553c02c13a3774ea27781ef385d78d546e04f8164d0584d37ed7d4eede1ba3a9b8c523e631b2378346342b5a98ca079dbe6dbfd3b91eca7d66cd169703bdbd9e461159f80ae07e0d710d9363eae1a3e9d553a9b86983f12a6f1bf0591b73e541f26d225c37a7018858ede8c7f85e663ae392f617599f27ed66919710d43d3b02c6db1bf49ec055d67e8fe46f0f0fa251b40e774f7291c9c017a9cd33cb869e116e6b85a519e1ed9c858aaf91da5b817b969447d05e73e0a025ec57714b719fe82d5b0bc633de81b33eef1633395a1e721148f8f63aff66e5f8ca39e9f01ebf781cca5bb411dfc0f31d9118ed63aa1a4d9382bcb07478640bbae0696ccb47d14e9fd636431297a6a2ac9d794126fbc5d8a8976d4a4fd55c94a757badc7d7f5daab5cb17b7f9ba0b3c780de8739fbad4eea4dc34d39ad9c25d50baa8b5714012e67225fc6b7a0b6fa8e0eca7c603a3a85432384e3984927abcd3bc95797c749f66c26e356cebebb6251dc47bba5d6310ae4bdd83552f5294d93e5d3a80b5728d15974472578ede4360957559911de668f9a062ebe26a77d043c0cf35f5d44904190c8f9f6501c24cd7d1e6640f8562977f7b03b0cbc44318041359c8fa269cc5dbdedb3096521915133236d8a2cd2880d68140302d6291c7dd608b7bdfd303ae7dda5cca55d364393a864b2c26cc5c22e180003e37a176943ba971f7202445d1fa6a4917786537a5f036bb8634af7ac7b2b287bf18029b348795b1c3f26c61bd9524f50ca3771e8b53892293029a4fc5c5d02f940385d0a593ab9036da7167131885fa838941899662eeb30296dd55f88ff032e6aa0748182b8a6147760dfddf85ae9316128784227eaa7ed48dd2d2df3550c1c1168a6a3cfc89df0af7f70cac7de8970c59099f51202b057446c8aba885387f34cdae542ef8b5d9f11ee0175e962883ba3682fa7760fc58af3226c010a78c2264249be96d62fdc38e7961de8434fa52332b3386d4cef131309089233e5f5b8fb9245f4f48895b8cd6335d2e58157f4cf85d4c9d0a703f8de3dddcb72b84d1e60e48a44640ff38c1d98ced063ab05360f5859df72f5e132ee680ffa3721785c45247ef70b1c549a4b0caf3861f3ffe2ab7cffd0988edce307890cb36669d09533351ba4fa1e21301517f3b8dc3217b25408faea1e848c145f82130a40a1d4c9112a16d9cb52ce40520c81090b01e886aaf1309a4e9afba29889ba06c1dfd7c0ff265897183147f8180e29676e4d79831c6aacb66defac1868f80d2a015127a3bccafdd06007a28098b871533cae84973f143f2800ded5a886cb898d43b3e08268f0d7e6444c2102ed1398b8c528e7e8ab51dbc78cc00ed25c7a4fa9a9e28cd70e9ee5b046f168718e3032518172860f7fbda8540bd1ca4a53478fabddee6c2b01668f8156892f5cf437a2945c2b5ba691997921a0a290de025d4ecddc4f58006c1f941318c320199d3c0b0d6df7e4353936f1bb1ecfeeea6d7ae667ec63361377008fbf631766850b51bbd8faea040c0129a0c5e310834f38e441a9288717f70df1115d85dd07ed9eab9bccbe1c84f8adec0261f041dd5c220acd98c447cb76fb26a05f648c1bb8ee3577fcf318e0740ce64b0eea35a8ef6668c1a42ce3eb34ec4d8f03c680650d3693175dc21e2adc9397cb95181351ad29345e06b8cfc0d155e910253c07e74e8b03969ad5dbc9f8f630e9c21e447d6b245befdb500a2e6c1bec8b13eabed0cd8086fe583582912de9b57c45b35ee645d76ce792d48c70b98b8049428a569d7848ab06d5d44f72ca22c78534a7371c12e8a42a3e4eb2a6e29d8dbeb584d6fc49cb8f6e2f712652043821b866d5686d46b48ce1cd505ff382a4e4d2ba6ff44b8fff06f78c6eadedc8ae3b26f5e7d2326fa6f2c585cc132f8b7daa70469aa1020c2050c18258c72f62be1403de458dadd817890d009e1950e84003899082cd22498c430a4bcb88b1b069e32ef8c1171ef2231f83c26627f0f055b48c9759598268afa5607bae86746b52a63c26db7a5d31fc9b4738e776a8db6731b34355ba61c2f646fab87c8461ec870168e3bfaa6d85512e6473eb336a5b8e52a95f1de3b90e8e0ccb2f9524ff89f185e62f066015cb9a5841380759d1d1565ccf5d6feb2b8540b47f3e9d5666d0f3faf97e5532d0e09f042cc6c0475bea45339b91ac4aa3816e5b58ed5434a7b54bb59e6be8a6efa2f45f70cb108c44a3503ecfd8aa059998889d135a8955c69bcc72643e21aa23c3dee2c1b6874fa9244f30b2092ac76507ca5895e41ac087f6295fc9c6816d8fe314eb542b5448823823aac67e4c5b08abff9a92364e2e331fdb94a3538f2b48ff684cc4b7efd95190f1295f5489be2b068b7af5bd27cb00b4961717969328182eb090a1d27822d4068b4085f5cf3878a16dc5ff59026f5322e6c438ab17d4309976ae8b3558cfb3e0296c1091d63ca09d02e9a6b93d2101586fa56980619afdac4e77a433660db4fac6070a4f46f44a0f7551201d70f6353ecb4de8f8f95be12810b74c8aa8cb7e6b7cd7e1ec09164933509bfe451785932715f0935ac4ae678a869b341bde20bb72effb9f8f367ff3f75641e9903d4ae8cd0c8145a55f749b83af4a880f62bb55fdba361720cfe321e547151536695c87f523d10da50a58175936d8e48bfcf6493575db761b5b5dca1cb6baa10411ca0979e6779b6fd5c41d16489d69c9460ceb9a896a8660381cba68ebbf17b8f1926f850d7a3d1907d9e06d2c2efa8f012e23be3c8fc3512f001a9e85d642eae7d4e6d9b365e2378f403e96ea48d040061357003a0e68424f04a964801fb2dafc8fd1fbc351feb83cb33167960b00d903121725538748673629f89dfa2e51b653dc3eb5df09ae4fd94936d5db8a1d42a15b1f1c66384d30f844f067ac8498d7c24d27f463c7e663db7e0e9787d77f25534cbd1be92f4c533c5ebb06fdcbcd928b5e0a87efdfca09e5eaeeaff43ebe03f8732302c2a689036c30729007d613c778097dc12ff1dc5f1f4835c0c0b809c233e1ff813ca9eb6f2bc505eaa35ef038fe081dcdbe074adf34b38bf17d3b92f816472a5dba77410259597c2c3d88db49cfcd1084096e640bc207393ee0147742c8a053cc313b1b02d6da032313dc666f819c6a1e06c2ca6fad97ec5efb47f36d1cf32be85b5e8aef6622bfcf72920a71181fab41d0e794e84b348e781d11c800c659d32dfe6b6220ee381698ded7ddaf67bb01216446776bd09ddc6b57f1113fb78f80441de840634fcac80069f440138068afcd7ff75ada9ceb94a6f9f01e629a257d635e791decf33776521bf7ca7190b5dcb144a31449e096f26dee198c3969fe524a7b4fb2528bacd72d1847e97d9f75b4f599cdf866a6c6973c0b9fa06bbb87e716e772b46475161fb1d6bed00984df49ee0714f8d11c18b867c0393b4a529ab422c6798ed0a06d3a691f7fa2da018399a969f9c21f52f8442d3b445f490739e7f1c693dfb634bccc25e1bc2f2e707f09659e9b5f66dccc7c2e2dbbfc53608201232581a05c294e1a2af9754b7b099d240ef00f601fa0dc7a5f5d441ba31202405b3d5c6efebcd583227c575dfab1177d2f03a7b300043aa2a466854942abad43a94b2a17df514fa258048c15c78121b07d0965ab8c8c773f0f54fded765aa5672fad6e6f2951864e446686172a6be9784264c90e24e83e9f18b4eba999534d877e1a826487764cdcb987370c35d7910db6dfadc82e0a17fa48ffbbb0acb1d7f60977bc2ce7cc3a3558aa08c23cd33385c44c9e289ee1a78413329f95f89dfb163be797ab41d9596f9f25edcb22a440f771d323516f838be30a6cf36fdea333cdfd83d90c82c9ec34362d46b9121252e89c3a64cde97299ef99abe3e09081fee8398d0e5c5c2d2ac214e5b382a5657553e8a2ac7ac0745441aa69d27af333822eb0917738a68367a03bc84f891243d6e182b897ac31adc877f200a831db75ed7f2f6cb95833cb5628b6d851e0d54a5c54d0b9658cf8042ebb4a813bad8a496b926687571cca98344856b4e0f675b02d7232ed17177aba24ae677be710831795ea863ece5d46bc36be57a24d2bd80fc10096efb19c26b9ffb2ecafb066c33be04d8b3c257c88954e88c2d93fae8c1ceada405d81ebf0b9f08c97d8ada32195e4879128db1087b302888c8291e0f7bcfa223ef03d93fd35be1c5da0528af5ab6360d0a8fe61afc24e67a82588e894c7cb3364f668b555709c8383b379096772a718bb86a0685d4d407e29ccb04f6b96fc3350293dd247fa5cf70f4d12f64b6d3c5fcbf3c5a11f16e0ab36691aa315e9c8e3400a1e28f111705c044bfd4166e74f9b09104e86c7c5aaa774005de8f5fc196873b17694f95c97d3ae7efd285457b167b81b6b4511f723d8427ad8f9be968e4bd6ab71744cf74198c8d0037ca955d97040f6ceaa722cc894b9bfad94459473f405cef22416fe1c0edc74365febeebb4c20f8ac00c60468989273cfde8dadcfb25960020a46419b75fb90e9eb24ad1c3e6bf490acc05f26ca919c9b4e6464964449e78c0fb7d3ab83a595a431d3be36b13f4678d1203b8944a0a8c92277a441b420f1153f579bed7081a82e285f7df0b017bb037b1cb1470d66cacb48854eac32f8cf9e817b400d053cdd2afa17bd0f162942c07e6804c2ae8a6e172cba6d7c888cd46230552458eab5fc439c845e7bcec772b4fe6af5922889719c8beb71d33c2d53d01e5d17c213b25701b71719364ee79f8473defe7fd4ae3a7f9062f22e0992a81c140101b6642116d710c9f3ec6658322341094143f5933c9d23d9891cb82fd09110c3117e81b1c5d3050ec0f469a442abfee608e2a5dec0ad887ddb37e9a3d64e64a7ca3b57880496361806190b5817029632280ac845a8875e262816ba75953bfcb42f92749f24e869aac83e7bd3d46c14501e397a3a9973fa1bd802deb170971aaee17aa6f9a93bd542744eca71aae10074ddbc09144771d7c55f2df73acdc5bae66c67514e508ec931b21d7a2a8622becc1e13ede819b53af6f392177bbc6fcecfceb5b6f9b0b33f8caa592a59c90fc5088f2a6aa25dd80a49c7c1205b4f963afdaab1aba94c99a5a8d4de8695d24488125fe36c270fa7f9f75a28067748bfe8b27c6d288ce36cd15f729f93e6776d9bb2d6cf63272bd5626a1293b836734b2f7742173ec542038d50dfb16810f87c9e054115e1c1042dac6090000e348ee4fe6b331586f434d0f76af5ed9ec4bbc9bbc19785dfc25eac2efdc7576a7723e6c703a66873fe8d2b5ca04b51f16788f02095a8cc6517886267e5cb846c5c6ca10b8e91aae9d01710c7c44031ad85c00a9d839d1df252a166e3ece29a5c4265a8db8ec5afa8c3775ea29fea19f90f3a45f4c0dc80295501bbc115b8261d83b56a2c492c7f762fb577185e2f94d33428b92f79a42bfee5a9c9fc57bc64e799fa02da8f9dcee674bbcef8667a15ed928779fa5881334aae6948377dd1d78344089d00304bedea18f1b4217e0e1e04f7bcc45e3575090d0fb1047684af625438ee33bd868eaf412edae55b0d67d32805998a944421243f6719f2aa29bfd4acbe2ebba26316d5254e7277cc7cb0c0adb4761a5b70b7c03298c9f40431c66bbcd31898349745338f795a6933bab629bf76048b455ad2d8f009bb7ba3e321ec984cc9d84984056c19d6c0361b93576516305f529568812a5dce1e693623de4446efe6c4c8d382d1e9940ff0948c7b4513257e998ece9924962effbe53e00a7f78d7772c43cb3a1784eefdf8e5a5091e6730dad9720da28959a70645783f0a19d0ad794a6383d9d436592125ee13f3647c753cd2d1e54e9a18bf0abefcba3ce9a2069419397dc18ccc612bff92685163bd60f3528bdd6045a6dfbd496066fed155ebeb8b36459c0e70a81e23bd3214de5b69f8ce6ce61af5b17312f94c92367cedc00e7ad91a971e12cc7afe46ee4c41aff4e552740d4fbf5799b1245f1a4497a6c64569371fe08b63255223a7ae66c3ea46cacba644b4ef403e9b381e3b1c9ad21f7b76e44396ee0662dda6f34f7e05e68f9d569f4f1568f7c019d9e84c5c29b5da5fa927965aa15798f4d3d61504877d1a167bbd9ab857aac9f98ed3e7fb59de3d260b8f53a3daa8f3f475280e99ba7a80f9282de3990e85501bdd00fcf648e64cd10861dd64f885ad55bbab31604c2294dc75b68c509bd39ffcbf60ed83550f2c1e247dc617ffee912f68715fb31dadf3475bc619b9d9d1c6323cab8ac24d56b3c9f124b6560c1c2cbcc26e56c6a3e0fb31416672d3aaf112a04d9142c4ae82130484b1fbb011631df283ce2f301a83d00965487484738403e2ef6c74e55436a0bf22841f814d82519468bef6dfdc1423d6479489a89cd25e16e66d1c751fada2610f346a9523b60e9ce356791fc0668508e569c6b11d96e6ddadaaefab76fbb1995616709db66cd4d2d388e152cc25c88d0068404f12d270ea9c3b912ab681d6de5f5e6c28a3f4243a8038ae9c34e51fa8aab45391cc0ba2b4404bb949032962d449c68663df711d90d80f84b765599fc7ce48e713455e4cc52580c7d95875f27fd7d5316eebd9ec3e92b3f6de161693f16140067519919f46673604d0a53f0ae7da0f17e0ab1e624ba7062f81468bf95112614c193a6821da9cb30a80f51dc30636f790bd39bf96065acdf71a69f81901f26f7a42bfa78320b56ab7309aca263ed5da94fb7d2cfbf1200626d659c2b110a786335714b2fe7115aebf9bdcd0003d34a919c17ff05e007bca0e433e362f8d404b85d035bb9fdbb621bdc4dc3496f0d6534c4d6e902bc8f276f894257e6abc5f45e01f8908398cf96da2a5260d2cca6055e4469baf8215279fdee9c48de1760d7146b267bba10538ba1b9f4a715f9b894e4a2ac5ab3abc4d56b1eb5b12f7736321e0ed38853a2cfdf9d42cacf384c6cfa96d52c2bdb0289fa1c47c45b6aeefa30efb3b314d58ccc66a8e6dcd3ff462f29d742570a24a6e8aeda0b503dae3cee83725cdc195a68725c2c72b5c2759ca8055a3f01a0cf71d84f7670e4f3defa1a121fc8cbb39001625bb60c4f413bbf6bf032d1bcffd2354fd7b9953f77b0d0606994f9842bce05c94fa5d0eb40b07c32139d79eae4325d259c85fa52ddd1d6c714d554201e3a58e551cd4532e2e279db94e45897dea7dda33ae22e508b2270e4c8867ed1adae32cbe64b2c4ce54ac587309470e6b3bde649ba1fc17da116fb159aa67eb876653a6c2e48c7cc48f8b260ce62c40388ec45d7a7389961f95896817756e1cdba37e929aafd99d4ce99f37aa05794068798e0116a3e701c8b8498872df70ccede36ce0e322bf7ad0155d17c714533860b8d74939e79bf0c7ba26a70a3eed9eb368a43a2ffef16b89de9b77d938f86ed1c9194a23959ebf37d5904dcbdc06c5ca0825ab07d3260bb82bf318c6d0915c52693b172465f59e0b59b3f917444c83b9fcb656f919a19e9bff7604d07c39ba11811c80a68ffe40fc53fbc70684d96bca2e45c65d277ebf82f2614a552ce811a8a42ad0eb3d435448896f880b0e861964b7bee511b0698eab48ab689dd17b6392d194c1252423e70f75b897e3e5a2056b0603e2d271b696b571554e6c712bd03c43a4b960ad243c296398a1a6c28b4b3c05c004285031516a3278d12180afe7f546a870678cee30373e81330d76e03272f28b2854b98661ecb36e7d19360587821acee1b4f454395b78af041493ab3556e4af0a8d4245d68d3aa343e19c0eac74c93d8f3639224773519c4c324ce7e25c0c9f37f8fb9306f3b202b9557f4fc98078b289bb716a09d7ed04f821acf46dfce20851eefbdc951a1adfd934264fcc7c5058997e9c01bf632cd646b41f51dce17176981703028c62a32ad9737d3b6530fe9160c9e2dc783facd1b8e96fbfea5670e3b7025b9fc7153803692761d2c6683ff2063b928df420086301b3d16e87e852cf862abd4ef08599e4b231b89ca8d7565dc0b0d33ecf9c92965cb87cf209e7b89d88a0ef423a21b0d2f894403a316311e07aeaa10e6f9be868241e77e272dc1d12245b16b60b113d30b58a14ca42c2412af7c05d945996ffead56582d313ce70db0899a381d86fa67c17d10ce4dd822b064e16c43d01a2df50ffefa91a7133ae6427c4c2ff1d55f0c54c3ada1ca751de61702f76c8fc210bb740a5008ae2f4f9f937cb62446f910ac135508c24461596c7c259b7af35830638ad220f2ee5700f2cfd89ef6b1a49c712418939129241cae0e53d5eb9edd0c500185a9e99332839ad8a406db09472eb8ae60d8e32d063945eafe812c0ca6fd628c6243fe091775ea9f64a1044697c0dcbf9f8e615203a6580a7c162fbfd07c82ad0904120c341831324d530bfe07f86e91c925112786c316414a2d132e24380dfeb79dd823907c3584cfbee5cfa1b3f090a843419452507b25c0da78f25e668efe1cd69587625bcd38fa3bfbe969fc2f7c894f3c2711e33fe581441c2c5802e2ac77fde108c600baf67a0de5883c5bebf0d87b201a5d8cee22dd623b1d98087cdc2df4ef99d95f2c7a5d010dcf2b61b35bdc0c01318eef4b2863308a27a719e4ad404ecccdf60b922d9ce59e6d2e083c27a1eddd9f49d0e7fad5662ae71b78d25bca87cf3a76170a2d6b184abdd4d1687e98b3cf773bf1593187e80b90522ca77693cd256f64f133f6a1247217e395b7416594b5ec4f8c3ab8e0783de304de64c4abd9e7c5a5309ac019a896ad9737b7871f15fdc3133f1966cc232d4001f2cd76d999a56e122c8d960c6584b9304a313bcaaf3f5f8b3af601924aee70346774fcb430c44d052e464861f21311ab89ac6d4f78ba397c0a0797f9a067d7a891203e275c4614bda445f6785bef407aa935ad3bcedfaf3264910774980276a65b41275965706a870efe277dac002aac2712800e499dc8d344f0c8ca1d149c67142ae42da64e47b53af668dfa57d26062d3a2f00029ad85b96377f5dafb526876fd52449266c624129df1ee39b860024cf308ea5eae7314a0a1233560ad9d48d0398fd774202e40e382456ddff125059b95ffa3fd75d41473e247ce4c2a57be347c3d9cb779277f35b646689b88d297f8ac04b7e309837f420c388915b70c6d7df584685ded9993baec129a93dd63c1a101639c3a2b6a31b3b6c4f662ddab032f7516d86bdb472b77f0759849e1925a9b5ecb4d31af09df1a6a80f95b45bcdc9f107a25178764e98e828d27270db67223ab37bbab0f420e1ae748897dce3b5ef9ce91715dd67640c2d86f996cfda704873cc6a7ca121bae12d772b68150e5941236c5ef0864fe3bad2f30982018dc0737e030f0e2e123afca8eee78eddbc6803c5dc202065084dd508983c27ac8302fcacec0ce4f1710bfcf3764a8c8089321f8e1a5d16c0762d3c34f7797a59ff517bb4daa7b1020da8f35ba27ce8b0656852bf6e02529ae9640e25f063f8578aeee741fd4266c2fcadd2017f66ab273caaca118f5ef9cde6f173ed462b40c90a8140277c12f4682e686d26304c811c331d8ccd40494ce7b28fdac4eaeae969c877df5ab186909aa8be3817886fdd0d982e0cad48393da622b65b6439fc079212e5bb7f47336d654f25300b906ff116962b5f85f6d0c3196303715301f88be9584913218023bd08acd81d054123d0c3b2e8f9620f4e4597468143e8e19be38cc9c070af4390e27ce788934a889c1263d7cce29346beff7a4a879135d7fd55604baae1030c92bfc710635d02ce6eb7aee9192a763a02e2f5f64e9aa7b88d7a6d640e105eb6bb7a44bde4365d4945de8a81a26f87ae1f8db400b57195b78537061240f789bd6d6cbccbdb6899e4499b741ba49362bc1cbede1ce3a5099662a05c78f3eeca9c33083a794f25c27647fb270631246cec27a01a75ccae956d70962c4e6743cc930697d707be9f2d5c2070f23805a52797f8b475bf0beefb0cc047c457986f5f858be33a839a3f945ed35a07feca78bd7cbdedb498a87f201578c8db0e493cd06b70d42bb996d59fd1c8007fc2decce4e756d3a0b45848184fa886801b5906d1b97b7250e83b0ad81473c7c71df77268691579ec9a253524a98673920c45588c3568ccdd1b7578c2cef635ac7c138296902cd5f0d7619f40a26454c26fa925d92c696c057eba4b1ac48b820df2e2e6657a440cbafb38a91506bdefbd78759f39cf42c3c4089f8278313329f5fe4b9c79965411171010dc541ff2440e7107087e9585066e1b00520ba04ed51e7fc20778122b5beb786151c12e0e1ad451bc36eec306d71d10d0988f4cdee731a7d8be230d4bb708344ba6a1733847e94aa7a58f08c55bc933e267c4bfb54016cb3cfa2d56eb217a98e47e2c18fdf08e31f8139bf26938c48fc20ac826c4eac8d9407e9c68314b37d18c3e05aaf67090c21e47bc8c8314b937290b7a29b8cf6692df9f48c20c011d72be7f04336b7fc34f79fada079c522df50a54401f1c0b92ea84989329967e3494333bcabc27f214df91001e296d70588f5a2d0d1ae10bad215ae501e2d5fd0770d2e55b3cc1c802610d6c1ce03a6e26ccac789f6fb3ba1349060e2d65bb8c6e8d0a2373cc23b5378a066cb4c232872c07b2c961b17f1abf7da85a9bdda659bac70a4c6e471956169765b3013b4107977346c3e98cf3274f1ed968b07d1b580dd3b2ab2a30a14982db55579f4b747e48b9bcaf9ac1b7bd2c686dc499fa6d6a88001dc5ae6057549d6bbe7b1e0ab696ef43d36ddf8754fd3c231ea3a054620e157ac3f8a80a5a61bbae9836d06fae3eb72b7dec731d4a1a86e808f33f2743e10f7267eb9542a6dbbb48cf1d73a675a6b4f0087a21f93988bd043f2496a4acea0ba6c7152fe9e5d61bb4be92d44e07ff1691ccbd9810e99ca14c3f9661b181c6d36c5b8dec89288f8ae4afce663b3134228739dff8c3c9c5cd10c852f6407ad07b87678995362da4e2f25494bbfe90fab11e4e824ac34b9cb406dc49a56820e960ef095d6a4c13d24e675ad8727c051b932f280903b78345a55d663e5ef9ed990ea7aa45070ebbe22043444806c5e865b759c8cee2df64cd22487730a0ca85979b914373511fd4db4c88fbd8533256f357825155a54ce7fd17d501cbe62ff7d1d45b81ef213238270bce0e7a6168021ac196a7d1fa9fe32d3665b14093ad573ab3553b1487a88ccb735d7b8f70b148c9fb9faa917bb602d2b1638a381eac6fb908c0e4fd306079e696e76986866bc51d1fd22638f5ec4cb44d2d4841ddaf13a364c723d91c325ca1d7323946d472ffd2aa292d6c73169e2701f186bbbc751b1c3b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
