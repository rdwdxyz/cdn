<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffab8b89df15f32e75ef26f527637250dd83c4b9f3a41decc50f6b1a569bf554a3ba83461144bf18e4e036ce2b7ceb476983fd8c5c73ccc21acc8b8fb62d0ea2dc1978269943c74e2fda20b59d2ba3dfd5abbf3addb36ea5ffae314b5c925008885895ec118d45aed5200e2260315295071caaed8675f3cb4a688d7312f2ad3aa0a4e10bc823abebfccb5215491a758b5a14bf4289a65d31b94b838c2b92cb191a87ea762fe2f6ed425e064bdec10c634b857d81c6d5b09e2135df59c8c8129c0b475eaa5b7507382e17a8c3075ef7dc6b4a9827333d57c136e61d777514510bb85ec72c6b9971bbb2bc7f0e17d3db8d9eefd62143236e6eb2dab8397f3d844dd709994f79c9e1422bc4a4a7852a808d525a8b4b615b4add0630cb08d796c60ce1b0dca6305de7eb0dce0a2dd90297ba4efd8a06faa9922752362b181252189d2bc9d3bee1910aa15e5ee640bfb25e6abf5f0f089a429007961d8bcb4534174920ea3d0d733268d8d4b33cb423e06b62edde0561c2038e1748f3c7121642c0079b0f3156a0b0f4b9c690e07f86c3bcfba9353ee20c375168252af46483db92d2618add79cdeb11f2fbf4000fbf6af528cf0fd0fc0ff1f8f136b62636090f1959fb65632900744ffd2cd029e67a283bf394f94a917185adaa8f2aaab2eb52d3b51a32c3feeab311e6505c1e2993434c25cde1a9da21d80c3ebea83986cc865e5f29c48b9e5590b0577a5e3f407555d583d245d9ff29d6ac8c584780e6a1a7155ad8fa0ad638e10e80c2425a087088a19fdf53c98d44ecb862fcefefe13e8eaa98881f9e8a88ff4f42fff31e8c97be230c7a58dda0fbbbb4d797550381a05e95888c8104a3e0acd3e0d1acd8420e2dbd7f085695b072f55c898bfd6675cb9ed5a0718d1f0a3b10a895839696d0d4a803874d593d3693e42692e95315711b97e1ee38a19241960a38dccef63626514feeb963bd4d941f44940d6757f2aace3c05b1ce074bb4673ef6c68759516652c6f93436b11da45859eb1d22b7ed6b174ed98b7583ee39cfbaca4a21767873dfb9d1c41c3837339bd8e84e275d3d74962fbf767efb2948e6489991c3fffc897c4ef1b586063e498413ea9a53086191d97c3913c6f9e513f2355b4d654e6f91dce382e2c17e0e4eb6e9ee32ba7a72c502475006b34b7615583b711548d559389395e55dabff666282fdecbc77e8bba740e5077a542de9d1f2077c99a4c95e2aa0d805668a93de724f40d2421bbc98e795b029a079dd4091428bdf178b0805e5991d098320ac3862ff45d1c876b067171db697f81de5d2a75bd49e3e231bb3d4d3e7db328e859c4ea11cefdef21efda5b0b1b19f591c93d846d9bf1d9e5a29296aa72fa4f9d5b56cc774c047892e22a54846e019d3934f7d8272cd0e91e8ae057cd17eb7d1a842725dd5893fcfe4fbaccede1154cc2da86791debdb1c6d2c85b18bf9822a5aad49192edcc120656df9fbab0d5ac195fb99c7d640f17ab181eacbf493e4cab1d0f12f345b241179aad5262c2b35d061ca1766daf823348690af8c722d9445e6704fd200c496ab902dc0343e3278f258fcd466c1fc0396d61212ae75561d5a4e07be2c3c9102b7a30e9d24f7d961249528ebd2806f85f5e407d91cf87c63946fe9dcda2f3af8c761dc31f2ea8b21f6d32038cf46fc3ae47012899e77b1b1f621060497159148d01b43ac612ef831932cce00f932d1398b8799e208229992deb683ed09f8ccdb009fd3e65bdd0507bf5902aef84d00a70af535030da8cfe086fb6576fa29828e48e217fb884636612646719bac49ecdd4457f83c0143d6c71ca516330b3eca5e2a9d97d86462b6d5c3dabc0a59e5fc16191a681f0db59a689edd271212c829b36ceba28b2d21d59565136f4c88b3a4062cd524ab69585ade7a8a96bcd8e3f4ba7b29fb74ae20bd6dbfe9a35125035ca8be618b2cd0de7800f08f4bc29617977e626256bab9077910bf08103538afd648e16c48d944e26ce2d6e90410c2cedac5813375b3921bda2e4203e100f5d9df637ba89655477316a82cce19859e2b7828f1f64e3121cd4555d2d4218be11549bcb7001b449f41ee7fdd9300e086fe4e8c4ada869d59d0d84a18b6757b6a86c67c0374c075821882808a0115ecff15e6e4093403c9946197c83fdacb1ae18b748535f34ad1306cdc1320d03bebe2c486627f141dde3a05ad3d01e3b418552e19357fb048be636dd5d143db748f5c55e1e2bc6d3b13e685d0187fc4bf7e03bf07b62e8c34900295dfd6477d7f114978671b1ec6d373229daa1d60f7a5385820313af7a4de5f267df69f7db3f381530f2c79b88d3a78cae1799197169dc5c49edf6e381a470b2541137e7cee2897b9a606fa413d26a755c8aa1f1a84cb4b62bbbec474e719bb386b4efaed374b65889c33a9956774507a75194eb4ed67ba6103694d6cbdfc9066841fb509bca704f9f02e41cddb73a842d1f9b41c2c2f153efdd73cffcfd8baeee2c1ab20e4ca341d181ffaea82b6b124c360a0c2ac3dfaf7768f5401bf96fba3c69142415e4437911a00691a8cbb371c1962d9f6c2e8411818f389072f9d1aae246032538d12888c0ccce36ce1dccf0461a312a02f55195984ae10aad136a71b0e3c1674f06533ac2045526aeb9315a27b5981f83afc8ab15e1b466d05fce1528b7092cb44701fa8cc46bcbd197e27be6e78cb4b7a74ebcfd2127cec4fc3866b479c4bb738f71d5b7abf99a16edf7f372dfc4c19cc34d77e8357f61828b6ecb5b1277e8c9b2d610d063f61d8452f63112aefa5484ecb73234d50c820ac20086b2c134cddc340d2ed7598b49f1237d94b77addee057f5207890117ec53edfac3241330c0d5dcd21f039d3300813096d317cba49fbba255d9e37ec353b41b965bdac53a013a4accbffe2d1ccd1fd8968ce9c24e4157bf5b68e3316bb15874db83f6adfa1c63a08fc581e9ec4c214f024ecb599c939a42d9085b90f4da47b58438072e18b3e3b2c395f779ad217ef790ee70d11812d4e638e0a82cfddb37625d1786afc84aa572819f56305225bf932e3c869dcd06d5527b3b52a80769bdb449d0d24beeca327fbf66378a2e520d13aacb68e6a03c67069cdef21aeccb78ec8d57727358e8ba7d02e591965f948ef87b98b935c53b6d9b8239eddfd0133beaccb69877d91c6f281eca62c57c6882fb259e824d25725fd661a8c0dab8ba874758c3a8b7d3eb736cc909d86bec0d86f49a006adf11246e0375316ee8d08774c860bf9668759c9e05ebb7d4ebc116dcd521989988f503196cd9ee608e3d6ba19037ca0937acdd6897075294f170bd195fab407599fd2efb8ea8f9d58921b27b21afb2449d08f64e499553169b40d389d70d86e2926481fdab27d0c1addb42e09ae5ea9a9c0f1bb1b14d46efaed25e7c2a705cb1a39781fa306d44b2533aedf391c0fc7d2b6d428ef06f2d8e1dd94ce6f2556b5d361e47863d837d08ebf6fb16448270022f0d7520a11646c8304df89c5e597766241d94ef68a55b25f28c7fb208627efa18d3b3b1aaaf3247a783dab277492cf28e630ce483623e72ee3300bb23171205afd009699d3bddcc422c6de1c815ccc47fc6bc1fa4261275a9a9a0165e8db8baa564b28bb4c2c9fe54740267f13a07b6655803dcc9411f4792fc886fcc89b6fa504c63e57c59bcd2291eb49d66b35e1bdc4319d501848ee2942f02917bb196b6f4c32f0e98c85137b592b5d32248ca9582d6890ada26c350433e720318eb7016057e83d01fec6189492011b19d4a88fd9101d8be5320516acbd41dd4ece17ca4e72f41bef546e499330e19778cddffb643ba1ce3f244bc02b9d2456876c49ddd782908ef679001d557103a69defa039055ff0505a1c18434f302744f691ead792a88a972fa276e68f8585648c9237e3256331dfbeeb0cd4a32c9d7a8d0d4d4420e8318d838d9be7087c67114d321c4ad2a782f54ba08b7cbfa42c87d80ff00e500ebb375b34d6f4030e3675584457a11350f8576771222700d7861a73246b81ce01330cc3e18f21392071aacd1cb4127b25934ef44c118b0a2e9732f6dcf6f1be6a6b92dc81929b79ac71c4df55b3e07d6bdf4746643f0239c18f7e79a94f96583e7162e8e66308a8518964ee10d34c3891a8d09c7a113d242e1abcf15f1c829716c8a282e13b8c304cb1809f5b9ff50376365f2fcf9e0f3d05b09f289f47ca2fd8aca8528f329b6868dce2844c4f7e68950b70c42dd41fb7b02e468890f71fbae5e74ba29b6b96526002ea196da5d0fd407f52678e00b0c4b08d110e3e8d93c21f4601a50a8346ae7eb7a0c84bbf47227401551b762afd91f818c0d679e256c68e096c75c6c91929d69cfea5c6e8367fe00a33b071bb29b06351cdd3f4950872b49e4ada8d9d98e7ed28ca3ad3b6b7a56659832b58927898310279b3e7e891fd44561506dd160d048ebc9c028dc999557dd969d0453f222cb5e44d26fa811e59eb031063723caf9301b0da367f9cc0d250bc7099b6752680b93c079924c27c2eee1a6737998a612b4a24de12bda6c7ee230615228c3abfd258c6321d9aee5357579442e8c7b357b7aa621971f0d99f8940a0f652145769a5bc410fecafe3344337e083868908145b60ba8d2b05663e97b52c53d9425d5b251683a67d48df16e810598781dbce21578f98486b7d74c6ee3f42a95cbbf18d650856ad1e3510ee66651a42b5bc0566220bb6247b18df33171457cdd8d6eb47327aaa82aed1d2b6c43c948d95e9e40dd66f2e48621983f129c72f69c4c8a78e318941d3db03126f6dd3b27285ea59f32dcd0db65b32725debff313898f11134927c359bf846d749c2e9533c3246635442df1aee4a7a26058f13f74ca11e495431d661a5dede83efc1f1bef7e550d0ca0d446f986193bcee70ca154ec4bb7ab8e93875d29251540464f05c005ff908e32d512ef77efbfcd6c552be4c98c94fdd2378bfb9f36255f183356f3f2219e6fd206a0dda089f1c7a4cde6f00610dc2a02d64e5827b11ab383d21214ab1e69f6f3ce1b7ab72b295067401e66dbdd88226cac45d5d857f9ee1fb5a1929d1216554bbe55e7e2b7173c641022db5e7f21a49f0669e0de052a16c813551b02ba1dcba70ba60871241686a1171819d4118a057d4b9c27fb552149d5dbb919206c41a3a6675576b3cf377b4957ba087d07f9d1ada20f0ddfc070cd4c10ab914dd1ac07399e54e5777ca17f796326ea3d9098d23e081043d29425c1ca0d044012318537716dbc811e2ac2cc85edc30f037ce28178f97d0d8126a0610559dd4fbcf5b2f8e3889e2bbcf0995abdeb707977fbb0fac242e0a22afa9e32a8746c161abe2bd5c17419047068c93dddfdd4d3b029b1bd30a5610269aad911114da2802cb669520afe1c2ac9bca508cbf35f3b541e2c9e848ebdfe4734f0802f9a4f630b07dad25db64ed76b35073fbe808a116c893d1ddd47a0689e072ce1d941c03869c3f02710427ab092a373a2f31d85714ceba3077f3c78f9ee95bf3b636665b231f356b7b2d815e8b7da5b42e010476502dbd2eed8ef2ea2928b5ba6b7c224b19ae09fcf8671f3c39ec817337eeaae32d3d93ae2ae9313f967f38ceebfab5de9f2502578f06d47153ef9e66d3fccba934f2570a1b1cdb95cd957c4c6e20d563056499932e081fb339259a617beea5b0a24d2a967d6b9e62e08d571f365c1981cb27959a564181b4f811617eadeca417d0767c800c8b3aceae6dca29eda60e02f888da81ab17222dd3e9c1b57b9d0bfa0b09cfc4f50016fbacee6c3254aa667ae2dcf8c899d4234a43d1c53e2087bf04ab5e92890a19b8994babc26b650877efa9f3c400ede83b66a3c9a22daa71ac585bcecaf3530c33ee1da58fd467633bc62bdd3ea3d8017db30775a8d9d083ac4d56efb5dd5c6aab3de1eda7ff9658ed2f540dfb78537054e23073bc17830ecf2f9ad24b18260f0d9ab6a4715f065a4c56fd012e7bf7188541712d9f77082700366a86e16a93457ebae555a1837103af997b892951bdd6781d09d5a96b487a7893cab293057d3031d011bf1748773d65ec891b494c1ba8848fe3efdc6b66c5b9474c6546176bd3846fdfdcf0e1339b88855bbcb93163f1c3b52223e5d1413cda300c2665f129dab9af31501cac68b580c16c9e1e069db392f90fb5933a1c8725b6d16ba7719d219fc4df021243ec5297bd3e620e32f896ad95ddaecfa6c834ac3f7f73c2cd230ec8ff300c977a8de424e70f7ec20fc963cf09ac7d45a764a42deee63d1089f207e5ccf3d45def6657aa0f012fc5eeaa00db658f1cecf781d5a1063d736c3778ae4bc6243ae1ed4e9545c37cb71afb0bc7611f0bbeae9aea58693cc854cb2b8dfc1356578dbaf9d7f8ca76dec268ef1f318c22864a6a8a044d1760d9ce59bf9edc983cb1f0f8ee82bc02f80a0f2b4a076414f9be0e1370e506b20aa7fc2e93eb18e8688e9a5777dd184e174967773b8126e14fcd0217d916868f9401836d8b48fd783f99a7a4a1f605c6a1d7d2555887191de82b236df2886b59ecafac2b9cc37eee36815c762cc2d3233676ee6467d38260a004c1ef3071eb9d3fc6cd10292750fde011ae46db0055311d136995cd3e0f53b87e7e541ee0d7bec72ae745e313817305a46180f25ef9af521f9f98ba2a9228d5c04054b6fec6b18773ed3c75579caec041f2d1708accc576b875bf391eda2d0bc89373b67524621e9e4368da0d919d3bea24ef2f125ae11fdcf1359d0ee8b5fe69826606d69d13976c273515592332da2648510490b49afb58c44148fbe893ed5f4cdaa76105afdb3cc10ba6566caab65b88e73641b2527a750b2c5e42e3dbafa09202a591042d0d46bcc80d957f4adeb7e908347c40fb417c60e9a44bf70059bfa111f135f5a9cc9f4e971d81718a7126dfdbea8b9a984ffb515ba6e8fe50975485a40fa6a0f94c1ae0157ce02447b00c98139d4e6121f4a9aaac355d4df2c398a38fa6e86a05e79573d960a4220be1c5f5676c61677166eed365b1200f36a651bf618ec004931ab43f7be8c5de119a0f6c0125839206b383038d7c8a083d54705a28fa3ed4a5863b9e84ba26ef63948c5a0f6b260b2f423c6d801f5564799a901cc66fe8f0da6b858833d4c8274d1f69f734d1621ddda25539bbd534a4a3be8578dce064eb34eaa5cc1e95477f95901d44dc95d2554b3aedf8a1a6c52bdc0519c36dbd641dfe498a1b70016819d2640e655cc4f4f029201f61b83a5b15e39ca302717d448260cf4a345400caa83577d659b057c9d384a2631308ef4850e4283658f1057848eb8e4de75ee95c8ee9ad052da065390565027790dfdfba53ff629b3b50777778444a551b55e42ea73687d1dd695053c5d47a06e54735cc2624c9140bc51ca758dae37b05453ea69686b2d0f4f9fa2ff523be23577b6facfe46c8ccb4ff0bcef3032204ad8b548ea4fb29a20dd6e01f613e94486654cba245dd95b6c65b06bf9fa51695a9f28e189f2094d058a8f4b3371b5b6f89cbe24e07e6eba1e913416874621e15e447e9d28c69c706d8cdfcdfe8f026b1cba7427e2f702aaf720a866832e56627ac50eacad5a69d4d165a57e7b61843cac477857a302a8f28d6ae94b07e5c809e56f07f9595c8390c7295458e2d389098dee95fe83ca603c56b5bd3bc04f7a7def11ec0c6312f8da17da85eda21d028a97c84f3bf125c786fee391cdfa417f87e4f7ac8fb5b6989450093f2dc93ff105a83bfa77c3ba70c0154783be81ff2c7c85bd234602b0f67dd139da4777430a4483329f713bd3d7b741a5e7e8f6fd7bc99a256ccad10d8b559e73a414257cece7cc2da21d49203d35a140b619a2c23ca9b9535f3ab0c835a42a5f4adeb1c5b228eb99ff30bc012d42e29808dafc70beaea611770c0b300536c315f89ca2684cf9a7276212273bed909d3f9d004efe8fce32b93798a765cee06a288341a6b8010a5508944a8121116a43ec4999dfbf048a6aa38967667ef0a558e31c1dc986fb24ddc5118321f7988f32b1c5157a821dcefa051157f6fe121edccb650763a146664a3bd037ba09097491a6de46573b15e5e9446723581b5e6d5cfba35290b6a91a22bf096ff1e8d857214b94ed0e1e7cb7215b696158852ca9b93328155a971e10df278bba08a3ed363acff1eb083202841490f7a88ba7e7707ffc210d129755514271f3e2a944466791310880cc06d4c22fb77f7fe87f9f6fbe914b48c8ef82921fc1f16e149fe1f9f8eb8cbb35160d34b0013e09a258f69c2fee0a1dac4a2140e65bb1b6c7a1b6c751df663a55ec119b8692b7c7722fb9503c389b9632d0bb080aba97b2e9b9added966f6498d68abb1ab36c07711d6af868a29b6ac95fa6420963c0c41c540b2cd991780778ee6611752eff26267ee750efc48922d95a6f52d32024488493ed8b5223b3d1e8c6066949a72c67e253c2b859cc18f525a1c97a3ea4d97f9f9ad4ba837fde6be1ac3b64baa5dc025d300b5d64b3986711e81042516f81f1d104b0f4999fe2b80a7ce95af8273364c23f43136d68fa395e15af09e5cedbb01d86d698d2e756f182c590b099279a3bb3783560bcf8eeaea797008828c4b4764b00877b83f6e10e7f0500bd8e2de09dde9382bb04d648365f0f17f02c7b744975bd3dbeef2a525dddf3ac534ae6d329cdfe523338b84a52830e6102d2594c15446a5ba676979f9aabeb6cbba6b1550ee5956544b8966d15e361343a7814c2d91ce78f74ae7974ed6b5103c4516c75ccca40363642f293e88d647960617e5f51406736c22cbd5ac23c60bb6bfadf4250f33f95fd0cdc987abe8f1fb2a34f1c9f53179044d8012b2ef70ba99506d1929d30f6062992f594ddc842fb4daa2e8e4d9f4ef4a00059636ea8fe7f5253d1779622dfea04d8a2bac5a24d47e21ddf2dd28030960c879c05046e1d30cd427ca655169bfbe6d37fcf07d3e69857ecdcc692c24c82166b5da9868fec824cb433205bee5c8a1e37546e595c61c6d0bdc583fda9b5a23f66db1063c6f40f90e22d18f22a51746b9cf4799213d388d49894dfa65aafdc923519d25aaaacccbbec138db636bb8d59dfe78afb07e40724dd9103021d8ad31ea3d681f8753123f4267a7133d48dfb55e7718ab64fcd39ccce059870257ef5242829c275f5d2452941adf915b4fae77ea7c7fc1658d69ffda0dc3c32a9b57ef8d3907ff0c5080dd95f31990062cf9955ea5cd0997b36a320ff2f4aafc972f0d6d01d1323837c65ca294ddce64f1a0b701927a252cbd8032348ff91c044ab195a445b4ec9fc93915f352bffb9b0b5584c4cfeb6e0f85f5ea2f46163b34f50cbbdbb6b8365b45b9e11da375dc7a733dcf0ff49f509eeeed0f9407dbae650a6918e5f4bb39bdcb0acefb4ec314d7dcb9d9c0e185ba250b07c0cf6cecb8377b3760dd28b665eb556c0f762c643fadd742b40c5f9cb4686d72dc9fd181976ccdc2c40044c369f1f773250c983401a685ab5ffb750120c8fd40ba44cee4dfc4d412a33aac2a5b1f0a0dbb80548ef233f3e4b70d7fdee3228a39f46d8fe61f8b77fce6d7cc8c039f2fd9ef6a4c1aaf1e98f88f52b34d07d82f46d8ac279eac715775cd38cb9bb9f3062a9f7faf08d8c3e18374794cc1e0e73bb8bceb52ad905014f8b95f9fbcf5c64f858a56acc6f74218bf14197dfc132d5b489f72f99d94895454882faaec400213e9b24b4cd45d20ea117700c9389d6ed0b695f50de3ad8b4e8ba4032a8e6a3a3235e14abf5a8d8a725a93c1f3c96ea704678192371d40bf58b8fa1f3ab9091859de3adbada5dcd89647833fde41a005634f50be7abed151fea0bf0b7f92dcdbf91cf1a5649149bc8e12c7bc09b8c114e888a43ebecfd53a135ac9df978690967f08d7d3c09c9e86eb0169db1487d38ba05913fc07f77e64d041bb7a51404796578da85ea40b243ca09b955ed64d1b6ea937d1e119a7968858e3a8e82bff53dbca62f48975c8e8d694d2227dff82ebe45725c0bb4ea40bb00d55cbe96ee7b1950233bde02cf0b48d1de8eddf6b45ee001ce14be282ba6237c7b4a415a0a74b8d0cf63dfa43cbafbe7ee7e85ca0cc5928f1115d917af14928873615cd1e887487f99ce7e263ac896d609c868595360b6832742555ba239e6effa6c0c6587c58ac9cfc2ad3e71d0e8a8359190727c05f7500dd84e82258a65413e0c1b565bafd51a2bbd81acd0bcfdb00a69bd7877264c06a91c5c9450e05ccec5b7219f1591ba514711052b4de383d4deba77a70b8ceb1abc41937de11289035854eef1ff1b1828b38a0c2fc2a72515c4fb192266e30583f79a48ecc145cbaf8a90471a8bf644029ceb97fb3affd7bd1d8ba3f336c7c67d4a8c12d2f3d50a65b1c4a16e58819fe278d3e134af482a4aca371702e92e638f708d9c53772ea23d730305612feeba1478e74b794ed2e2d02924003965776c77f486e38fb637d8ed44d3d80efd0ad343cff2c98ec2cc8d4534f34f999d9d665ebdc2215fb9bee1d0c0d491384861d84473c0171dfcbcac2a838a7fc4729dff92c1aceabba17fe10ba75cc3df83b42764ec1ab28a8d0459a42d62a28684977f2036a1292027cd851d01cbb100bbaeb9e3488e199843eaf89024ddfa0867214999a0c8804cf3210a22affc0110c68e33ab3612a1839b8b6901aaf3bbc47f1b0bec1f4d91233f14d05282d6c396b5ab920503aa82822e32d1cd8a56c0e129374c5a8544429f5045a7b0ad7a29434ab123977ba6166b432ec254d66f7b26a97b2d0909090b3afdc12324871ca293ef3407636c791fa2215e71a96502f77adda84d4df910e834ebadfc1ff10a7a853c203b1f23bd09f1fd35cb40514c85052954ad9a1e9679b3938b5e2f7b1ee6c722d25b14a7503f6aa9e928e9109b0db8b2d9addbbfcd378d104d20533cea53fc1f12bfd743ab3eeae55c5f764e3849d99a730940c944d7c43f82800022b8101070632f1c25e0776ba3ac18d78b44cdc50dd21cd8e5795cb377972e4aba6646e58582716690523d3f17391afd9e31e5fea5415cc20058b6e9bf5026ff7dec3857ba39c1635228111611170aab4358c6fb2046d20e29dd869673a0049e8f87d2a236495fe7b6501f66ddd3632b4a7c3c3a4c1f63579935789cac41776b626163427b7949c81b87c84d7d402cc129c21a04d678b2c98670edc849ceb5d41a7ecd673158c501076ad67eee37748f670fc1b6238dc53ec178bb0131f6588ffbdfa5399fbf71df2bf54519ffdf22ea79480fcbd331f7210a10458b090bcc01923a9502a4b5dd6ae38b2170f11174d22a146137b3a8dc24739ef351e51ee56697755bba837650cf8f5aee97f0994b69af13c75da060e01e4cd15c0ce3ca6a3e75f70e55415c16f6dad0582a17216746da7a997fee74c30ae5ff11c8c444ce8bc14f4a86c14f1dd35aa238c6fa9cf6ffafdeb06ea339cdaf24f1bb251ccc679581558460ab43355fdde1c55c4d33a796a25a6f53679bf1719f85348b1cc57326838dc3822ea94657ead5c186f2b03187daf27f33472af38f640c17ad9197ff6985e9f8baba81473ec9b7f156ece67e8270d8cb16b30ffe97d3b886eaf2e4c9a698d26e4d58f563c1a336d18a47304892715b5fe2ae8569c094b57ae0084d621d09cd0b7e491b056435db14289f2fa71c2f4226e293b00ac607c8e41861d3b91f80cdd778c19adef37dec4d02d21533ff8c439e18f6c0cd01d90711d458b43291ed91e50e247d0b9164c4aa5cf414ca2141b4fda0deeea0bdf244e0fb917149d13993a727f395ee9ff06576401d38143d7b519faebe1ebcfb7f9c3b7259d483cdeba4c2394c620ad412a24c6fe4eca80145b73a1d78feaab94ab16c83b94dd2833177d7ce28189ce010fe31294cb094dda1adef2a866125fe1fae8a5a914d5087ae4705d1ff8dbfecb6b9878cacf4f7003bdee540c3fdaff7efae2d80c6d8ce8d4baee4f7cbf4be26ae080a0f3e9a6c137edb527c61272b2490ca1bcb56738c36346a904d84d567fa3faea5e60dd92ae04d37859ea0fcf44809b213bf0cbd8e974126a5f4d28e3141772380471d839028784f672550cab2124f51b76f05840d4e16165cf132f6c61d0a57ddd8aa03920d344fbc8d52c138acc04237400d010d53d3c32ff711be6559f26ef0b1e0754327df3c41cc79d9e56f41fbd58b9b53fd90eb611de7f548ee1766196e0274d886631409b4e297217088d370d1de352d4c035b75d39b671f86ccd3b6985b21321298eac9b6820a11a844012429abf4267b0d64c0fda06e23da218c795d5ce822a39f6bd78037243c1d62632946b6cd3be8b3f51efbc89928c0da6fdefe1b51917cb98b5b7bc9ca551ee26e7be791a96cf7281f7c2f72db277b5445c73543f722e4c6741be95b48aefba39e4f7ac90f8e02e4cf70563caecf62b4b8687f42fb3d5b50d675d76d975560cbf3b048fbba893680de0b453e5386220ecceb00f4d4e1938c55e46c7850746ca495cf8280c7cf62b33a6c61e008906fea2950db7944656f89d17b19d9701f58504b4ab9ad85c313c24fb56fff6a3198a340da56be1ce09ddca8f6c80fa8ad7dce3934e0a9f98be6a53901a44045424fdc844c976181c7fa5c1256607f321c7c56a3839c11d95770ac1f264c459cd30db5f14044a33979d5776e3512ada7c4e7013296765f96bc30a527109f1dad926210f90ff93bcb71bc6b453971918c359f654559c2219637a37b6088198f7c70b36425edd99062f57cfa0350b96ede911e44a144263f808c0f858c235561a9676d77b78168702ac4634793a634ea0e84ac0076011119c0790a956891a111eddeec1ae5ebf4919998f754f55955c03cd7046593ac3e9f3862aa33c4c2c369437b1153e168dd6039c006b8ddc9da86a080d6d16ab1528bbaf6312c64e132931c5c9a775f29167602326e7189b025bca1b9c5700e00526fd31be7fcbb43509cceb99771cf6faf103145b71098d833e8a66aea365de7092638bb4cc6ac929374aa89606a9360a4c6d5907d4716f00b0b54d7c1ffddb4875374c71a989eef868f9908f3af024e979f81e5a680bb2875c553fae9594616581d75b8b95530f8333605ffae81383888623e41c7995770e6c2211114445e122d4e2084fb7835e2782b78c8670f25bf14e22f3bf938575341473ea77b73366d91950ce59fe694b1a16d4d22dd08000ce9d4eb38a26c05be0e79de6285ec0b1e6ea46406668858f4c43bf53eae9a847ab4d9c333494fdfd37ef26cbba6c998bf8d3a070fb9d2d06af804b7f1a4156bba803342b2400ca8309b9e817f8df8c04e59212bd3a33705be8e1d1f2de9fb01cb0275432a8a3d0c87c592e10c80fc440942f656668305bc4c1f6888041660ea139e4803105b5389cb75e8320da243bbcd0272573ca436eaf7a7145d003b94570a0b28f1be2fb6b8617cfdf2c57b5c261d1f7812559141f515a09139b1a06c660b45f1e02596b2ecceb7c419b895efae436a8b6f4f10aa2a9bf661b3d383cc8f53f9f5cefe1eebc40089a6436e884c24547680d2697798d8dd9f06c9403632f730e13b8de918cb9f74d495f1e5351a9cb19a6539651401eaff904dd3ec3f8645fdbc5da58753482bb4de70ee294e77efd2db85bae5721a7ff568d029e45468245b0753095a61bd23434f301a80bdae3481664e20d51293a299bfb63679ca8c9371ba231e7dea2fb54862ce4e7455453e69ea85e445e7188e9d32656fd6acd47fbbfbd0d169567aff041244e2bf76470cc7934268e5e6b5c0aa9416f18a780200f58ad2afeb8543f33c70d1d7a27db1003dabfe98a34c3180f54b4e84769497739fe9c490c53fd6152a1dd429aeba521ac04e555589b8a26cca6a98a7984bf004aebddf797c56060d80014fffe961b55ef27d9c8cb3c3a195a2930e2a6c05a96a2740e00813a376e8fe0889cdea221e5db2d2ad5d893fa67fe939c8232046ac88e6b23d2a1109679f5d92393449706372eb03ff8efba971049084f4399ffa9bf1b404a042291545b1a10027154eeea3f4fb6a0bdb228543e5fdc5b933ddf26592c2a3c652a8f1d38b9ea97470ca9a5700d6e92f8db1ba7ef52e1458260bfe98283c3880b1d4cf2c7e927481b1bc2380999512eff7f91edfcecc0faa5c4f99e7bb2f640bc5a7a388f1bf1354bf46da775be7defb0b2f34404af59440957a368a9a652b8806e37afada47896c6d1921ab2039bc8f3d2a32a42a50b2d4b98e30cda6494e42b1ccb5576aa86156b1e5595ccdedd371134f9a002d6e8777496570402f6dda2923bb10d26021dff4921a862c296ea3d0ba57a219292a344a67f6872c1c90da1e44ec495ba4868cc62532eb4f28b6ae6d9146a694510d1b4946bdda543ada21139f50b023c9ecc61041eb4f43e35ce3965be8ce7e2f4fa9963af852187b67ff5f1837e0bdd565c9e11e4399ae3d0fea88b728804b9ddc6061403eee4d3204d79035ddc7f30b36e1e16f6e83109b9de01ced098834ca62536bd9ef4887bfd560b01886279ca1a5f6b4b07a66c32001709a712996ea4fcfb9b566ba3a2dcc74aff57c04544cdbb1dc0bc68b827896ec93c6f3f0284be176928588c3e8354ef0bb4d9d5c105a46fde7f35f601daada082b1457211d23aa98db0fff73480aacb81ae797086543d4099d0798b72e761e4f0148c781113ed08b3cbdbe88e6205e85e273d5b9075124e07de0fbf49e7e98456dc5f5f830b983582e60f5736dbf58b44aa51f26cfcdda6829146f165598cf8632db828bb4be5f29f627e012889a912ccea6d9140382a58416978ba05da71f211b93d9db4c294a9d3d63d89d07937c588c96366103a41f5aa54819d55eba397ec3b35606bcf33532d811c144d16a081a447572257b94cf58c624550968d224dee08c492de8512a6453a9848053e155bbc990cb392758de09fec91fb9491cb62d47ebdcb83a713620f20ebfc2bc6da68f6511e21c123b76b286eb31f0e1a28b2b252386948a6e52829b8b427fcc7a90e70e5027cd2ca74d9c7dace85d699b6df9c373b1d5c5dc77733b9e4cbc0f8c67c2040485b59526533e85d92b3d3c1435e5c6bbc458aafbcea8ccfd54be223162d12c18c4b1d528a4bd4089b2a9a05db714035b23c786a39d7ab0ee98d93eea50e9fd2497b01827a246cdd0c2a431deb600506fee75a8188ec6ad999eca14a4af256b323d469750009de4656e45660bcd194075166f836515901b9af26150df03af6f82da8bb5133cd212ff2d21bf3c6bcbb8ab23173fc91ad6d1451eb532fbcaef933519961b0bcd1d0887263c1a26e09b1d2a552d8d4e983b6ab429fe1c8d7c152b3306dab7673530c82003d44233f7ff8a8209c74916549f6836f35d85cdd3bd9d6170283e57ffe676deebda6104dd7352b4b973fde6497d294222745502f6a01a92d58f05efd2ca313e86edd042e1cc3d63608e726c2714e8762487b2c101ed246f0a153debf770e1ebc9be9535c2228abacc892539011d89e48fcccc5edc9b2aa71215a137f0ba5fa41093376190cd29041abd54634148605135f1cd2d90b8f65bb3f3f5a9558429468197adc921e3e3d5be7a7d0944c76f8e456586094adeeb11b7282db8ceb21c4be68eaef64dbd7345af1673d7a12df4260473a173482f818946a7357936e9bf90650acce37467f9d937c0637ab5b4f493c0d65ad31e4b3b75dacafdc69432c3e8a7387aef3c6be628e537ae6d9971ea032c24b7beb4cabbb9dd5cb2067f666255b759f15a4ce685d3db30b4525e7737b49041e4b2b6e44e9fc7d6c04f0ed963445aafbc8c397ea52b06cb26378ea8d2eb454a4b378094440b6092341fc108324e87e17e0596b3560f2a093dd9bf67b04b77038d360dd960f8fb97868869f467ddaa2b995dcecb1e19d4f4d6558ab033ac46dfb36b358a535ffeab5149eeec462cb1dede0d869dc382acd84c5456916c64eadccd0e17e2fce733246abaf35f62174bc916f1d43bf8a992881a356537588e07c320cd61889a64d6b947e5237f7065c4683ae394ef9dc7a92c4d709ecea3178770ceeb221566e45fecdb90dd8b889e25353ea66dda98b93568d84dd650136c73994b09e85287c5245ef00541e6b883a0736b31becda00d08b511b674fdd9ce6c1f618655afe61f8b1bb81a01d55fe57031b47cb89327fb2905a3fc30a93a6f5ff4cb154fbad6873fb0992b4a66ba607f81329f15fcbb5e932f8398e9bee4659b4b79f84dd5706399b6d5ec5a132a6ad5ff991a88d129f030a4e277d4892aaafbe3996dff62fcd8f534185878451477c01b67da44f827eb682515452f303abb452329221f8e94350fb55b37f291bbd993c0bce3f07dd75ee88f940b15d9656f27d8235bae9ed2d09f7b671d977ea0fb6a1cc5838a3c38a2ab22d428152c7d1beab9dfa367198fcada87e25eb0a9b5be821d944b43121ef6260598b96d8f926892f914cf8a1146d18d85ac8de53d47dca258be073fa105516dfc606671d530cb38dfbbcd93c916b1f043f5b732eab1272d7793fd05e46890501243927c16061874abbf8a9fdfae0c01bb9e71894f080f66a16a0abdee725956b00cdf1b78b9c33bea50288035fb93b43d09defabc2ae3046f91dd7516f9e9a6ddea9878b454c93c32cd24de3db53823b73da5fc6f504b4add0817c0aac3ec2ad0ff716ef4a0984b23e00d341d727d914bc67fc84118aa094711a8dbbfe3fbf85f025ebca4afacb530b92ced61ae45922d941f529f067a7ff1c236276ba533653d5e0f400f20ea5d36319762c65fe8e1623750bb1a5480a0629bf63ebe6f071c0a96e970702fcfcd4aaf99ed60b6cb608d9d26958d423dfb7140b33da1ef0ea37fcda00cb01d7935fcf5e25ff2d0a2b54da0d4f9b2544a37cd47b810f5310b724e7a28ebdafd253ff8afde6705c4490ea4e983501db3ce579ad32ee128310448ed5cb2fb6d669e3faae91b2e6c6219e36487695929e6bb99c66794af38b50c57fe9b143973819190d5210461c54bc59d4b87567f56016265808b4a82b8908488c5af1c5d69dce626aadc7e738a02ad938495d792bda783f7fb86ede34637f4cd9ba8747004ca8e96807a5530b291bf5f00d35ea9dc260c84b0e4a1cf9d7e877acc19421c41a53d8a10999a3bf569fb3ca7c74328cac59a2648c73c82bcc755504d80875ac2516d4ad8055ddea3ed029bbc3f6104e47e0fecd1073d86ad00224660352584fe7ab7ca222bd576ba4c1a3c92244a458ee6fef4f4eacf2da9df8b87153bab7b2e7845184523dbfb915d1b80e22f4ef2e100fee90576fae94864ece63e7ffd2b8bb2037022b85afabdb18ccb7d5367c3c8ba7a33bbede48878ee8fcf1437f6b2653c1f61f2ffc5654b80100bc059c84ea98488d391711e2cd60ab3c2a16ca38433135aa82a2883963cca0aa7575f73ab38f75ad359e28a5e9fe64846d100f439388e0f15d74afa919d88c36638700eaa22f34d7ce7baac84b704c6ec8c5de7baa769d016e824c3a8ea579146c64fd50a077fc327864cd6e60e4b8a3341e3e71e6966fef3d3d236485523a1683d27a437143d66e7906c712792fafe00390bdd2ccd152411280da3ead784b4d6b1b6c80516c66d56350c5fd8813f54cf208f6ca031fcc0fdbda6bb143c4acc42dbca8f0594729b7088c3f1525ad75e04b39f953cb5f58cd22920010ca7c77f2338fd5c7ec99e778a83f4a98df75bd97afd9c9f7c4879b2ae96a88ecc248ac37ecc657ce399a453e9601ede980079203a31ceca8063c8b6e1fe5a91f9bfa97316813340de2dd49abf45b7526986fd453a1ef3c5c32904c32bdfb2ba20389c6779b704472854d38115993f374f82cd75d4e8849d90c024fa53d0568b61b3ef3f91d1f6333d0289554b32bb389139757680362d19b189bb581143c97aa221aa24db0999e50cf79ac100d5307993b631a35e2bd938087e905d14b7368363df9b1bb622b53b5e6ed9c78529e6317441bfc681dc7b795c9538381f0c23b8af8b000","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
