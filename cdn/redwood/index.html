<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"994f8036cb37e1c110a36970c6a0d368a1e76c46c5728bb5e8de75e36a897aa6496143f184957420bbe38a8d738b4df5b65e91910045fea2e665c2f8fc782a21568cf07d99a46f5d3232c41be0145a6258eb24f50e6bdfdac995b770d1b8d5841f9f12ebff20f3e77d995db3dc6ff6f121833d115ce589086076ae0db263c9d399fb8eb4d52de83871909b3108f90c95acc98ac22b1105a0688412fc79f6abfaa9638f2a6b1a541109216425d6aeb8cab01e641194f38237fc3e0118c7d3adff145f91b8302c3daab945eb36af250ff88cd8afd9ed1059254f05d1572cfded0ccd5986563abeb6250a4bd82d6dca38bfadae5ddd646025bc5caacf405dfcf12a5ea07a56f4ad493d7303485e2e2b9772d93cb8d5b9a4afb7d171bc609d3923cc6dfc3872852d2cc5b41a2be3ec3104a7e2003bf2ffba7c5b519a5b9bf546199d817eafb62136e8170caf25b463df7a801c55954de55a6082bffc4d155b08a08def5bd0feb9b47eb03f2b0d8ff6e03e55c90343089e131457cf94a84adabee2f5db94344cd4bd5fcbd572299b111f13e02f98d9d7617499e29eacf133d9c627a39415ee8c81ab855318fb0583c8d1af0f2582ad8901f2fe231fde5fa25d1d42b01f47e6d6a7fe05c40dea210d13dc91a26203b67bfb06fbab1f37793a8086aeab23041aed919b119a5850ea235528fcdf98586db63ad50c97c06ec6bc64a23863025df061e5df60adcfa5c4a594bc566a9da0b1a2d49b110791aca99ba363cf674142942fdd93fd77f5ae938a82a141533af23dd1457e119e73afb18ee5320f50865f8a226eb5cd7fb2fe9d1c2b30d66aee8de2eb2343eb26cf0fe7d321b191d58b3aa22fa1866fd5473b617bf30ba563cbcd2c3384bb34403294c7cef49d8bf9dd0d02c03cc6355aab15213589cc97442a500d40100a3e19b097c3d0d338f8d78082b68344c7470f9f4fdaee12a8aafccbb9950a19c7fbb5d421e80d3fb73921ef1f72492adee3594a939b311ebfd38aa4cad5dbcbff3c20453cf5360c0a35fe914971c457e5fe931089401c917a83e18f1264bf3aaac5a13437a115d6efb94e18a10447fdbf51780e1d52c957ebe61ac43a4ab9142802e020abe501473266ca01973886c5b45bcd68268f6381b0fbdc957dc558c62237700bb21fa996a75046c4b811179f8506c2985612354cd1281f6bb220718be07fddd7717ca92aff48d13c94cc16b2bab6655d65cb956a5316480a3f8807f3832bd6aa0161228fcbc0bbc9074a29cec774e2cfd4a43ec2bed0f278f8e3eb6824a27fd9821ecf9089bd0b062f5bd7c13e649364597f0ef5cead6f9bfa6ccd984ea4d2d7bf056eb3db4666cb39a236b17918eb16ff3b2e73b47610572df69b4e3df600e8e525bc77f56336294689cd734d02a648c8bf847311c96a37c0f573f59a1ed5a417ffccdcd096948fccea2a3c279c69ee965826e7127db0144607840dba995215821aab813ddbaa21de7caccedbd661651e36674e3555cd1c17f190dabf08c096a72cd7b23f50bc35847d9af9dc6a932dad434be6e9ec22b1ab2ac8041b2586088e2654b5fb47e4a0bdbd6cfceff9077609fe0f7da965f519852b862c1307755d748833456e5a3982249dcba474619d62fc15d1f9b3744919d21ca0c4fd7829de3c831f5e8ab44798af4f5dd5ba7115447ea3347b17fcbe989ff97acab299ce7b503e848e3c3a0daab92b3c0cf6275246cd81d169446e9a9000b8eb87f7eedc7cb20fca3df412d4c1cd7ead30fba10de7fe2d4e696e83cda06bbae7df95b35ca57a73ab52d7fdafd7c41c72c7a49d174d6f8e9d93d15b550895da461d8bf95c3085390a0d63ce7b8ae1b8ee8f3caecf4723890dc51e9f8edb32526bde3b1c65cbf1080d801fbf9e16d739e6431f2b1a6677100a55ff41918f0360603f1f7880021ca82cf9a5c014b4fbece9d4bced967eae5e958c0dde95a7150717e4047e209deb98259f560ce40be64ad75fd72e5753cc1ac19d5baea34da8f8592761a4d6dd46acd629903ae568a8d3dd53083144c85fbdce0d72669a1d76b76f8c03afeb43e7500f2573ce5542a699516344abf5e555e5110e843bbdce7c9ba6b2f6827c003da0b27a7d9a34a1f1fad3507ced3e865c32bc2cedb6a31bf118f1cf852ff419a12297ead7fb7bb343dfceeff66e30d8df6dfb554d424def2203b70860ed582a4aa997850c42cd5a2f348a407814f243ad7c89ebc2454e3dc4b0ce38c9b7af3fc52e605666876ba0f2e2926ee64a6ef5e657727f2f13aedb60141768aab7377f8bb56a45d4c13ba1a15ac36887cf2dfff3ee5d31354fcb5991a5cbf559eed82c3d9596cc5c903edc9cb3743186a23197140d4f69f3f5f1b8fa030a811f89bc46fd5581c3b100339019ffe6fd05be14f392755c13e57aaa283affdc0c046ad06b902e35e1f24eaea8d4632a03e2b8efe4efe331109307be5ed619b4cf0571c32ee4eb4225ad5afb53f25a0475aefdf1d88287f72f6e496df130d1f88d057dd91a3d491ba08181af2398aa19168e429f6f6587a6405478cd55a4edd6bec62aa8b43b612eb26c8053adf3b50915f39dc7616f78286b12e753170c3f0cd32941101521a73bfde19f52cff7410186912921bf249dd830f62e2a11549775e2468c8758e9c31a9827aa0e031b2ae49ccb6a2a3c84db30053fcfb1d30222906db709cd28e3f92f20fa36782b386172793bf1eb2a3b410d1d7c2e6ef21e95bba0ac9b36887a7646257c8e74ff2db3056970389a9124a868bb45964ce1e78b42f34cb3da056da8817408277c53dc86f62aa8587b23ed57370e8ca72978e58216b7c19106863f2eeea42d0b2a3c23ba68ae0b2c5a8caf7f4cf0137474b8c0ba4c653774f8413a3d865108091adfdb8260fa8fae0a7838846453f815c0486b3d6e5c25da6ceba0062bd0deb417e7337d15b2cb0c485f156541791a0a9dac173639e6d14a4693699c79c4f209a3899f68aac75b56ba11fe7d5e462799ec7bb462595a0ae3fd362b5885f7a95d6eb28184dc713ebadd3586827a29d3d3bda08cfe63b891a275c368d36ebae5231ee279986c1ac68ce99dd8f27d302195d394d26cc2b0a759996c68b46764f421d30a5db3c6e5f92e2675d1595c49baf77933b1837b66a731d4c4269c60f8bd314a97418af9dca69d725f0eff89e8d927371a03214823fdc91e80b813519f43811e78005ffc862ea494fd802fec99c27a479ee9595326945dcecdb75cf91a584c3442358561625fb716a7db50a4273b1e081a5e72bf187c313537a8aa3e02c92215096e1fd9204c594955e7d0ead89b15a1d7d83e2ea16e14e619a9940cb006986acdd717eb30050493d07bc5446a2d6e0c88a3bc83a5a4d9458e40cdedcd3d5874e16773cf51ada85f9100c1af3b9d58a53715e79d0ebcc936b2063dce8d90616dfba3d41bd2c3b3c21f21e497049ffea7aaefdd29a24bf03a7b92597e7a0ab173cea8b2aea554d223aab13405516b0b05728b17a32cdc6462ee0d2e1e70664f02445f0d413c651d8211118da2eeeed8895d96e6c58bf4cc9d14e086ef579e2c47ffc4a2391adf019cee3760449e7d12d0a8413b883d974cc48ba374e772f3b384a7ef802841863275d1ea2b560b69cfecf8f628b53e9aed2840756e0e5772adfe103f4ff55804e2f56cc159a23f72e6cfd9bcb59fd30a75a08398343e4a5412b5426518519e55eac4df5814eaba0e3eb3fd64b008315d502e2e6131bd106ba186005d2ecb68134e1e0e41035f594b8f0fcefa9220b6be5d4a8a90978d9d8067aecd811b16b141591a06d6c9f097b3fcac7cdb4a8b1f66d3b30fc5a1517e390f0c08ffdcedff4c5a1d0c006ab56fbdba0a69e458601cf4887cc6d7d6c35ca48365f808f30ede8ed81b1e9c812b1f3e9190c96493a7799fceed81f4bc8beebf99450ec85fc0e548180d868969ee3e38bc35df093ed78a0a73eacce15a7a755f9e6aabd13ee0591580a54619c54106f3a8cbe015b6a68f1399cd615c240b24689ffa3161e395e0b4a7bb1fe8f1686478e936f60b83a16336f74f16321b5affd21950131b176f7a662d94e54326f31dc702f9e223797d7e62f35031d4e432a0b9be875d8c5c689b72bc6b4ffcbce8109aa605adca430f560225e2a64f18790b8bac7ef98a24ee08ced794d24e1e2736f76efb6c885db541ae55c11b0aed1649419c37488b00f2cbe5a94f04ed31890b2f08d49494d255dc7446e2b06b82dfc540461b2d6239d7704c3e20f0d4bc4908810fe005868b6a49c8cf5cec9c2dde980baaed580cc3f9f58f687ba3c5f4cb09e111f91fe3c0dfaf262ca3430b9e6493f1e12c5ff9f11942e89de3e6da41573935b89c622202c7b66450e037b356174c4a64ca1618f025d070c7ec0ee46b4535cb68809de84b112bb911c7082acdb471ac4e9e2a1ae877227473a6b366a2e01d8fba7e3c7d2454d4419bf86714e1ecdcc418114b5881b749e8dc71ef86b8843fb159e11a7342cb3a266b4b2659ced2795862f96c2aa0361b55c6844588fb63adef0ed4ed5653f435f01e061da439be4d22fe9d84a12b2efcb2e4443243d6ee4a75998fc077b85fa9312364a966496b90eb0409a3d65a7777ea2faa4248d68bcdd3ebbbf37465eb73672b3acd4e4b68db29d116f7d45039b27f199b5d3df3711f5415e4ca5672b45d2f5ed6342df390620b8d119ca2fa278af3ced368047b61ab8c844b192e764c4375fd432cb4a42437c4f09a96603609ee6fb735a2a7b2b2dd9f017492a9599bbb1b878521b417067e57f8851f506905b7f0dfa8655ad1bbb9cdfba3caceb4af97f46adceb2a6065cff9a76162957f36441dd6eef23ca8bfb09e725a30291d6cce191337f1f8ab728ae9880fa6e816f7d67a3eb53c236e245d3b892b70a8b9489659e624c16f76c1a209ddd430a88874164d4f3d31df425723a82c5765008fde51708bdb59657999d18c781e787d71f771126fe0dc0e8bfd7bbf6f475a528b0450441bbad3253d5b835e230d6e28d1a93cfbf82ebdaf06ce4f01f29c8519d68b300ae3ef950f8ecac452e7ac484ef0937e88b648715d92a1c99e3f96d21b7f565ecd5a12ce0646a1c9b4e2335a16baf6d0acc092a4778a75ec1bc9ecebb16133c3a1d932605a00e57993540af67bf9e49909b2586b606ce829ba61a1cefa6bd513845a48c619216475e637eea284e260fa1ded3f2e819968e17dfdc84e827bdac3b2e2181e2d1a96b6354c9ac93cec025bc052bbeca654440ce646a12185f5901b143887f58d529287dbc4a9d963ecb0884706ddf48061201bb2456986b51cd87a8e2269081f8491db0ee88bce477a27466e3b000c4e415a60f6a70a95416e38488b1eeac98c5a61bc3464902a4074948e37ee3d0eca3d34422a581bc99f3cd5be357e305f4b30bf41f8493eb209f012fcbf8fb8244c5e9c825ceda448e86cbfac059eab22320313ea288731752d3d9f5f8412e070e9049124faf8dd64faf8b09652be0db462f2173b77b8012712edcc528004e79c4f29db42759db6ec016341dce0b579a6c90510173e8c4c86f410c8f8c441ae3d4aa74f5f55792c86af1f07092c60e9986c584072a371bc48ae4e4d5412665fdc30ead7b045ae7d283e879d8408886bd94aac0b31cc00bc7e74b88213e127ffc86004931c46cd609c0e271b894f59217f7f9ddc7588190da0929c1fd6ccac29259e7da4470e13df6c65a61e884d0b99415e874fae8603256165ba4f9704ca26d877a715170b634e3bf15cd3c336704bd0e299d9e01e4ff44cd9c2f340e43eb96c752e1318457602b7b474a2f279ee6ebc687027364d23b5b68166bda5859366dd6f328083dfebe194ffebcde2a9b2d2dade27f4ed287d93c6db256bd6524093a0be63f73d38ede93675d8e4ef08c351d6f2cdae539f26510bf7b28e37668ff56279ab92ddcf1a08b127d97535dc121a08739ee11dcd7cd21e815b4c47e68a936f948d7a79b0573254c1959bb1b968296bee48febd8ac237a3e5f0edd43922ae3af2d2328352c0055647635d3cd55fabd75b2f70d4e8a97353ee822f6ed8b9ba1b10258d5a1afa947cd0614b20514947bfbe3b5b261bfa610949eb76d6928d813a47bf52c7bcd880f7ccab34fa8434ea864495f7bceb5e0c82535562822aded712df99461f10e8b37174fd4a1432c56532c0e091c26c1a9f548c80c330fc988f35533330b621f24d65c7966ce9ed692d93991f2356632c6c55b8eae9bc23b6982d3bc369916203c060b4e320d93bf3629457609b6f9f1ccc43137af057e98de1d71471835a0eb8b90cc6169ace443c2189cd8b2504c5b086f32a57c54f28e1451cfec4e90e5956b3b20fe101a53d3e0482d87e0cf1fe887526c7c27f6ecb41da83276deba261925b5a0d1bd42759e7d130b5b34bab0b6669ed4ca493b4d5dfc1312a673fd1929e54b33ee5fef4682e6b67da95cd0467e42f383fc1fa39942fe79b99e496a89c5eef62f13c1d14bb13a82804a69a8b9a882f354237f22ccdcbafe6a522150b40f7548ad7669f84c60f5ef55b70dfff82140dda809ecd87872d07372e25f340dc0ecc4feef37e6c4ac6a3793a50b7e6bcf52676030df281c298cd9b9da2def2d5c6e4713d692ca564194cde3cce9e51c9e2afe2fd140763f520dabd515e85509b5c61247a07549ea5a182bcd065e36f25335ecc82012f7f61b6cb34e1f02cc2e4fa4a51172a84c99c68951984945c66cc2dca5d14ed1b3769af7f583695be28b8893ba53582922a9eb47effaa8b0c99488604eedcebc8e29d19525edb160568fca35c420d3b2061a474cff568d408691fa33ef89839d012cfb9a27fb402a7e74980f428ebe82cfd30f5c7b7af98d4eee414cc5184815cccc5dbb9d557daa073867921d027119b4bb9e92e4fd831e223ecb9fe797b7a40832faa69de52dca390122b8a12d9409954db78d8b21af33255a199b24fcf9ae9fe3416d270455ac17b851959711bde2b8a4aff4a16d77687cb5dc4a574ed2157be83b22a07eb1a7fdaeaa2a70e30080f783d0850bf20d87ce02351c8b09e9682cc655d5d54632ecf9e097fd7460068d45002710e1bdd12e585d87d2f8e7125c81c6090485949db11e23c94e2d0c7a38832094a26c60b135f3e7317aaaef712626665490e47c9f21af6826fab9e7910a0c28b7009456040e27e5e92b78ee7d9add6965026a63f0c655a7d7efee439f452c651c391789a4eb9c5ceb9bd2997df9d9898c8a03ee40404fd8a3ec546c2d3da17acdb9c8a96cb98ad1147b70e7f06628b47360c37e4cdc942a44fff5e217f445cabbffb59bce94437dbc80673f9eacea8cf7758a342eb01705971db9913e2d05605b28cf7cf5eccbcfcf128aaac971c0e6ea8b649e898b4e86f049653d4e0cce6e44ee4e85851761866e26fd03c5aa00c018e9931a42c22f6c955877b88d798486c2f026816021b15873672545b59048bd7ce553cfbb8982ea37e7caec8a86673cb324208f727bc779e8281897dd0c61c7d68cb8218cfcdeb2b43d1add77637f864b50797eaa54c588c59fa321531146b7fa7b22362522a500386bb21a28f6b3de40020bd16dea5e1cc5669f2f8fd92ae1ab057cc5d5aea06625cd759073680f9963b49e983b66b08f79ffc07906359d44e3b834eadd756b1a2b58bad8baacfb4498a72443035c8020166280afd8173bb070f33bc68cb2fa9ec8790d94f298fbcd5dd41a62102fddaefe4809e62bca7579d04ac126679b3e305ac4c4fa2b6d16025671073c9be6812bc8050ed5beb5f67159f7c2a0819888feb0eff695068f40d281cb109251c07f504ab4f7c82a4967aa7c912ed97122f5a726dc995287c756cb343c18a3f4710cbda4df898ba30077b5b280a99f1db40d56dd607fe9761007292c5cb4c151db3720a37edc3d60d34f7ac9730f63f56dc3b21495fbb730f0f633fde64ae332fdd2bbdc29c503101f0115f51b7dbd6460ab11b2f28ed7197db5df3d9fb7734559a08ce12f728ee36cd82be07085fcea855ffacd8e3a420cc8f273c86a5635764d58dcf20e1e04c3390518cefc7dfb1aadcbb8200acd5be60662911d04c3065e0ec893c5c8ab853a75346e88cd045029532302fec6ffc9927fc4f1f8fc5c16190c9b7ee86bd1c01e6bdffd1614eda036f74df203034b3731c8cab26eda74c9cf987bb5ecd12e5d9b704eb1284bd985f7fbed19dfbf0730e478c7a24b86929b5d23e52ff3d17ddc5027bc26e6cca20b403b98045b1ebbfb8df295f78b7fd04878d2313c4b405d36e04b9eca257377422703c31b4eba594b232ec9c377ff756553e153e16a538446c6f37a9af500cb5097fb8c1372cb4387905894f3aab1bde5f99464a1b0d0166093c09fb1c005df6134279035e9f8b41121a2518d69039e25c8799508a86121297268a8eeccf41f7f9e9268c06e69d4eb3b214c9679f1752d63639912eca6f5f31e34c484715f036fb77613d31d9147634f63a581ffb1e86d9bdf0efaf4f46cdb412d18d38348c2279a8dad7454f312b7734ac346e39adc26edf5c9d1648fbd3f0ca88d20edb1f54a931ec5193ce972e46ef9b5db107c8343309defe8c1d141397a7db3dca09e901cb69a59e9eb81757988bac9f6cafe03955a5b011ab2dbf0181200863504abfc386067330a3d6ea0f11ab5f985cf0224a3c7ef1caa5d7cdff0ef77a0a43f790eb7c537cd9263824050f0db423191e59b2e6e56a8ef3af2d22b601d0b8cd175ffd218d2c5fa77a2b36f553d2e51af6a25a50f92e59a186e12d71fc1605aa7012ba91a3d1b7f943644355ff65034da89a07394e2f07f56dcfe3a18082606f14abfe85c34ce2bd00750aaf6ec2dd2955879727a48ca8ea6a3b2419c73405c8c3b7679c11455b49c624be0c98b22dd705bb7aafc1285b48954cadf5867d23c3db3071947dbdcc6c81e8ad5e71272fe6609ed8261e96aded5482ef63abb2a7395d2e265989852d367bda1eb042c005eb3e63dcec84febeb76191868ba7a92134c0c85a9350bfc7623fed19828302010ee19e3df943680bc870cc5bf4ea543d64578a3a8c468fb37865f05e4c0c2bfd94ae586a5d22a6c5b0f0dc87ffd5ba6cd4bc04214f3d58714babb25bc1e84e8209b3e844d97d5d8590dcdb1d5d24b5b99635711a42f72740b126fb9cc42e0bd9cca97b06c13fdee06b1a76d00c2aab10e9e36046eaa3e1847e5cfa080865f065ca4bb74a4d028e85f91e2d2ad1d5797d09d2009cddee710318075349c925a2dc8feb39cb9b0be7d0fdec701a914bdf27b57d7ef3df6208637e65473d76cc78f9da717fe84758ce94dad2433a8ba458edb4b1e57c52d31c91d720c467d119d9d85dfcc2bda22f0d6327687d2ba1dc6db7a83059af1b2156156b218113c65f9d64c6fab806b63def6600a99124f314b9ed66c7748bea99a0234f46016ef5dbcd50154de41395a1a2b48645f423f691c59ce0ed2028e31c18d42b522b83b0e66e409492cd631917317ede993330c4868ae9be6de8ae518b435fb0f88bdf4bd88fcd8a7531b13c798acc2c0ba89df36e93ddeaa01737c6126bd2899c2ac7ad70a8efb45f15afbc727d3e2b6cd5feb59423f4cbbf47bac3e5625b2180dd04d21f867f0dd8feb35501c8dc36aeb0f80fd5431fd8678876c80b2549d5f3e4cd3e97398199b028b3d58fa7ff930c05307127e337c8ab88810074b23071f20e3fa67e7c7061a573ed2357c45cc8480bd5c2f33cb62e53eaa1305c26102714b0f757e5dc0f0c08ddb571c1ef88eecbd1767f8da59de68733550954fe76bc12c08c676c4a8d51a82083e39307542a1c973604e3f6b0503eada5afd165260726f62c58fd5e9315f513d6b9dee6969a1108f717f3b8fbc9aa5bb15bfb4dde1c130f224f920bf8df9581e5a9745c0f2baa0ca9642e1272ba43e113984e88f49a334c5a10c9a7a9077f96864885ed7a43149ee5f2424eb6e4a499765412922e6f67c2002f8ec3645f98a4b5d25815f4bf798522723cd459e0eb42024ab8716407b50cf4d63d4e9ffcac3855fe09ab78ce1c251f31b560baf2e3d9c2ba41b005a5b2a17a4304b1df4b0abfd473199a08ac376ffb0c66f5768b3015418e2ba73fefb6450bfd598142b2409068df4fbe476f050f09f7eab18153e9ee92e516fa842863dd2548f924675a6adc64a8c969fd9323479af6fa3f1d707658c4a13cf03ea5f37e95c6388f1ae50aefdd41a45e6858c1b037b24a65442b4be5db6257c6bf8a865ef3df8332b90e8d77585935da1df87ee6cbfdcfa1500a5eea713c9f9a5842f0f29112009cd8200aad3b8f4f53a21b45978830b820e1e3c2373ad3f2426eb57f6bd4335e50a84b4cb856d4fe16bae29b9a33f43919225cfaf84d48a71b0b77246d65eeaa2b8fc297900db2dd816bf32e2e73d5e17dc269271e721c89297a75a357dc99030594da6717eef7de68673ad41349f5e5ff30f8fcd997c03428da265718bd14f38fe78bd30142ad6579ad43eb2cc5b7d81eeb93612d6a15433908797c9e7d0e22c2be5db72eb2ad739defb1b072ebc585fee5cc920e476244b09358643d5282f0e2423f22b25fe2126325422a201a35eeff0179f667160a7c8b564c796a48be8d9f02d67fe3cdaa87fa4f8289211f66ec8d87b4d597f0ef35123185c04f55239f6a4ac55d1f7eda3a7e2287b6840ef472146b8eb38d18ccd064ca555e6e299c8380794255ba83717cbfdaabfa6d459e0d91a8eba70aa34b088d3a9d6530c61b0614f3238fe89c4e8f254d0d35c0ed389ca2b9e8273cc832f70075f064a06bc1d06a891dc6e4083c936125f8d35cbd98405d26817973b6930ee18a0e67f83d7ccbb09d2ea326c87192f235003eec0586a8c5094e9d52004571f6862e57461b43c31043320830ece1a2f2c2feac70e8edd874571747ad02418710721fbbe825f36d5327c80061659785f2734e475e9c977066d9fcf80f56c7d3e17f85ed90a6c7c2fe8619352b917c3c3ccc8436adf06a1378aaa74fe7979626f084f3ade5c010b6aee60c5be48b7c87529dd9791a541aeb484ba8efaf2ae156576c677c0c0069aaed223b66e98967c5e77c81d72fe9a6500fe5f14db82212f126a01045ef4ee23c3a5deacfcf02ce08e060d6141b47f52886e6a5d401524d906b8627444a0aa7dc59c50e0c1677b5d2824a29be24aa6102c1d7e39c12cf04594ab6442356bc25a83db45263d8166ac1e4d314d7b5512991efaf427b6e4660f9ceea7c2d1ccb6b80365b756bbdbf7fab7ddaf18164cdcc110eabbbc8c5ab1a0a189d76fe2bd73a36c35f4a8ee5e82086873273eefad850b6f2c020b2b7c062b0d7ae3854824ef6a7acd756364ecb4759f2901dd9600ae2ece9770b5c305929bbb1d20d4a2fb4b29799ed5002e43c274eb5d55cf71da2faac844ed3997ff6d2c136f913b7565567210d01f34077c1b7c0de9406de82cb426f44db602187a9e1c16e1c4401175452f79f7c242bd42c672cff15c5773d0aacc3b9a8bf86d4a96c05ad5743da93f9d5e4d2bacb957c739b55a682586303986c7f00d9441bea6598f5bb240494a067a24b85d68cdb1184f098d3a5b0f84b3ade0ed063d8a38bff0de3699b1c081ab10aa022d3c7f470165abfc1432848d1617775ca9752468f4ae77052f9fce2cf7afdf0804b3011d7cdebbcc85028f6ad9c40c4a928fe468349ea57e86adf630ab8cf4300e48f2621af725d8f9aa2c584a4e638ffeaa2fa81b0f72c8a5da7958397c7d1c84496f4a26e037f7206aede7f58355ef76fba09753c3840675e8e29352c82d875cd9171f3870979fd1e69ca0fd768cd61e329ff89c3ddb26291b927e227201fc4a3ca45771fff14c3cf8bc6596f96d53eae710484e9e02ae7e883b9b280b1a257f6ea821345843218f85d52d2c04d45db8d03cc49334a09d22cf3fd84d900de4b41e80a73918de75c95e0660300479863b10bde1553047c171bfdfa34534589cfdbfc8f931c33aa55bb6d2cba552173fe08002bd4f6b0dfd699bfb07da1b788569073beba1e3b7766d3a3ec09abd41f7705c223fbf380f7c0ecaf9119f206cb04f36affc54b04b8ab707b358c29d1c068637fbf18907e6260a9b1509732a57554b95ed06f16ea96261e3d42ef418ba45ca2a1e8d66dc9ca31ac8d4a136fce3cedcbd6def61348a866be7971d916f60b244cfd6d65eeabba7d9f84bcf8c3728206c0aee0e2a61a8afc245e60f9605130251696f51cfaf6864ccb62c3094319e0076edaae3ed5078b17bdf49bb4e38077e3afa416ed44bad70781ee6fe3497e37da14dc9a199c6ba1928be65fd7e8dc5183913fa6cadcf592f156d95c74bdf65b0ecfdb05a3108ffda5fc57eb9596b2de227ed24cfe1ff0caf95b4a358b397684dd6f9cc1d3c1d572d6a03b80f41dccdec5802e6d7bf9b2284c1db150aaa0cf49824ef96194ebefdbafffd2febd6145d7ad43b9279c41e3fff4869606147d8f025a2a315cf653591e62ff7a7cdaf4c803e2c5e2be3ecec2565dfb8e1f0cd3ef766afd6b6efde62a02a79a2f3097a8ada0fd2b816c9e6e7d88eefddf59773770ce31678bb09dcd84278b5ce05ce3fba80cd9272da3e794c8bd6713969bb06353a26c2abcc0f3a4cd446fcd9661a48f7ec92b33346eaa1e88e1a5233532bf6484e19ee0b3b29f70c4692a1f2dd2d92b29e133c8663ba7514c5fe2dd1016e3f44c1cf269c8b8d8499d4917c201ebcd2df0df35ab9c66b9392cbf879978694e3c3ef29a1559ae6d2371e9244a7d8996926a7100ab615d2aef817fc37392145d2593e1e15ed91a3ea7db4390102ba1580013e112ea515b7e52831e50ef6b8c8374af28dba1567d02492bfb57be154e9511652030502207be23570abb12e31f861b4d0f0cd502a914c21eb74153d803522762717b00d916650edeada0ec0cac4315395f19f97830e00e3677b6f64ff3d5c7626cea8078aeec417f16c5cd7aae3e14bc9aaa55b470c9eb918b3fd1f8c7abefcc848ba4fe9e92180139fc0458659fad50bdc7fb32925d7fbbcc5c35b8d7f5bb79979ba21fe88991d237e409f2129627f73cd1a1713d4ad75587e5ada5b0e91dd6f8381ecb730ae9ea4b837b6d933d24a3243616289bca0292f34b1196df1bccecb42609d95fc236be1e3a2fcff41b52651d565e77b1c95d3f67c1cd8e13492f205ca8d2b89e70d799e343216a0149b37ca76824c9a3f5f1720507f8cc5f6623dfaf8379ecde684bb5c3844c456ae79757802ded6f212470b387f115180e6f59f1ec879551bc84540dd684911fb263f423da0a56cbe6ddbf4ab6cd4c9a9174b89126b1875522d020aec523a80b1d2ff6dca3636b6c848b4754cb8a0eb949a525e3dae31d8a467598cbc47100bb128b567f752ad9ea914040646f989b9b77ee1585e9947f7e40e9dcc7d40d5de3d12dd30a54fc7ab68f9c2e48c75c55c2b60df54c1e5180a017afd95a10954b2a819f88a4f771005696cc61d7575899b2ec49bba6300b8088eca72df6f4105139c4a107d76b2ccaa45a7012abc58b970f6fb5dec1d62b458b8315ada23d2c78d5289ea51bbbf0cb054bf6832f92b74fca6d229ae772335a005e0771bd30e1ba866d7e4926fd1958d1fe991c8bde956e3e8ea1cfade6b2f6acc95c286807542a424620eda8f29de12ea819277b55535e4e9965d75f24e5e17fa9847d1c653f969f75de4a2729ead0eabea6f919d01b771a94fbc3dc9cada03329ddea00e6c4253e7b2750e9ae3233cdcc5483326f7bf6f4ba5d5d05de27effe3d1eb57d063c4d65ed74c6a0203a9953c539f9d987108552bd61b2b96b93e69bf72768bfc9a182b192d83e5f4c69a7d7e7384b17da9309d23555a90f7130e26979d17ee3da413e8dda777296abf7dcb8282d63b58ee661dc3145e531cb8bb0d5f23f38bb395ce61113431f1891b8e3963e5c9f1300c04095ee4ddb54bcb9cc3b508216817072f2a19cddb79c4d291a02bb2ce972c8e9f6e043114c8148a2d96f7ecb023e3d2c8cf24cc2a199b6a3fe8cb11476c6982c5c4254c8b43b529888b9e8c6f68e602ecf22342b5f8ed8af99179cb1a0fab9a1a8242317b7cb641aff5371a647ce256d26a00c5617f88cef2fbb344e4d13386207a7bc60cd161b01fda7dd7fa4b6f6ce72ca02692d114045a73c79bc135ef4ea84ce6939e7115a14421467da2fa24671c934c666423dd0717f1be42bdfda813a0e6885e7c727793a24d7f61999d25608d0414683247954d6aad3d58f8f20a0e87f50f3e3cb66bbee314c86d6033a6a5db03f9a7273042c316d07b731ef265cae930579fe273f1981f2a8713ff9326fb89ac54a49fbb17704c950b0e67af537a0b644f3c9adee7acb92cd3a01036029c4956172a5cf54f1b1bbba852f3986d379574864a989020177d37a9d12b14c7879c42c35f78637a3e3fda17ee708980c73e3e23656f2d3c7a5c5a38bdd44125ba851dd54c4c5e231b3d3e0e6d7801a383477f07695bd9596e5903e48252b36aa4305e732789cd89b85158e9a74d985330ca22638f9bf92e1e0d643208543a80d546fede79aefb86f1e2a1a9c9bf55aca8734d18ac741a62354f6f8c3527393c5cc123f874de911feeaaef77026df80a8fcd09630b67e487734cf3b94aec0be5030706b34552422cc907d5bf86f654da87ae79a2d747e7d0608f440d76ffdd502580825cb127bbdd74aa7291f8242feade8190bd230c459f60feb7c774f1df6fbcc25dffe647beb64dadbb543154861416fa9d4c274a440b05572a6bdc806827907ec131214167de630ba128d38642a0ae739b1a81d057f22194d3f8d21e6d07d4a98b69d53f0453bd0267f555d20cd7271fd89ff7abff969d19c93813a24ef69b0667dd348bc97f84100db214bac8c011013dd4248bdea9b6fea83c852282b552b6097acd53f126c6e4a0f112af30bba9378d6e2cce0ca989edda89cb97454b000af8024fe7f0524ec97dd741408b03d763252c05418a54e248a6f1cd1f68827c3a3f7c02b44c87627471b413dbedbec748542179bee85c02f3fa9d419c1e11f9757d56a9ac63da2ebd7cf3b6f603a64036a789256e6b5c4c0fb36a58c68cbadc01306745b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
