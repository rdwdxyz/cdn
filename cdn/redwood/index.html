<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11745dd0a5728c8d0008ad5f9fd5d3cdd4dd62b89a96ac4a261aad512ec038358470b3873b21f20fbb3070e78da12bd80225687a905b986ebc5d470ea7b4cac8505dd432316fa1a8c19ff204e31142583a1eee7f637b1d1b8f79d1dee382eb411e556ef6e8120c8438bed0d0ba66ed7730b02951530c774f7a0fe4e769448cbd632807e5e13224a966cb84d1df71be552a649e6e3f87b033eb72480ce6eee346016a2a7cd4df63dad6c3ddc0c09c1422f23742c947c880085719295554300dbce395494c403effa0c7c4c1fc8cfd4a94da547027c831586b33a2bea66d79d9a53130c57e836e5b4fa15110562021a8bc84522395e5750bc986b01ef0ce4f6c70a1be87a05802fc539dec2ae42ac508134a270918646e6dbea18c91ceadb8c7adf860570b73793fbe1be08ceaefbe2230fb5062819a3eb45decde2b20c12dabca91e5c92cbbca7cc5eb41e929245af6c3b96661f655255f91de168e961a7eed3af249a930f6a23e1ea724486e787ff2dd7c114fd3b5efba3c8c80bf288e47d9ff6871a3cf2aaf2ea1d2897166c12d588eb3ad045877b7e3a25b8a33aeff7cd3c89da18651a54040af44ae992dd4843e7a7033549cbcfd54928b401b30a0d81349d059260e985876c7e388b41cbed56430740719cdc13d9fb06b0eff34a70d452c4df6043cca5e4681498374eeaa14b192e050ad190e67d672b0f76e9aafeb2e905436a0dd265376d6a23db1e1a1fb65041061204d31bc8727c53cceb20f04bdf691fdeda80df38e339a60ff0df92793995f43d8c76e4f9fd064e79e2155bef5dc7c17060b1802a0ca59d0eb0879e709d73753d899ba9896520c0909e1d6635ce61870f77d0f83c4ecfc13e3c6b2cf4873fe7b8866e3e48c0761e3afd5bc38ada816c6de91104275645ea8710d5a360ea625a9e7b249a99ccc9810a6241451e95945f83c3500de4b2f0a3fe9a22a2a5c414d6ffa894dd8b38a51a872b3f4088708071bb67661fbf15f114cb93afee6022d262e8d388bb0c77e825ebced4d83a1d9394d8a5d322b97834f8e23ac1edb64c5b43b47992d6d8524d08b443c9138474e04594cf7aae6c403fee47df28ec5059785304526e8f319c0612de2bb1b92591655d0cb96138416e29849c97f4da49791b1f0715a756b6bb61ce3db387c6daa01f710586ff2b2aa3c341f20db2e9a278269d8dc66cee095768cebbaf1cc1cd77d4c57bd736aa3f6b6da1379326ddc215811a0c7a761f9967641e5776378d35639bdde9188fe744fcade0c6fa40f5bff902e356317e1d014aebb5127da374b76106152a6e15037e73c5d441a02cab2ae4ab87be80c44264ba477bf3a9c5a2fcfff40353607b9076e37903d9c3a9c9d3a5c7b31fb769355cac6b5e83913fefc1da1e39b6625da61fed51534de402157dbc9f2b1eb2d0f92ad42662e49677859cfa7dada33cab9328b9e76eea9d8455bdeeba69c1827be906ad77d525ed1f7469e8f020d49ab4f255725a8fbcff6e2119fd3fb110d6919b00221d7a5180b6f8d184313b71158069005a41cbd3a1b9025bef68a88f12ea51ebcc7c9b88914125bb4c2665826f9de99d4980d41c5934bb5dbf7d6637a7d9c58b039117b92645326e30391bc3ebb9e022b60c049091bcd79a4fc22a46ef48fbe3f60de10f7c08f009038f1463636ab077c185633ca92b344f3d7a36a8877ef4be665babd22bf82122739d3861862895d0373923f0208eb9772accb1cd61c432a404794a36257b37c200289b7c696b1ae582b9ffd0f70eaa40d4d5e1ebc6e0eeeb69c37120512acf41d9d8076f584c09e0f6975a65f38309c1499e522e65063523ede2eb900094daf0fdfe2f4408c16283d7fed7b0dcdb8ac1c78f797e215bd30484efd3f883e3c4bd9591a0f02bcb43b63df7528ce8f0676574ca2138134645112f0c3ddefa8d1e210ec84a36f88d2467ead4d44411222a18da61374318fccb47d0be025a2fd17cbac83eb08061b99117c361413ce4f8192c43d2696c9fd6d05822a49f8b910115ebd7bb1d363eba8e645282b2add5f25756488e5e4f01c617b68e68f65ed884680d572c645b4f5079aecf0e8a407df81b0da315a19824a6f945a774cb9f45ab3ca80f64b8e5f353389a3ed28d6bec0b8dc500a20d65f85c860a3b6b48b8ef24f3ea65bda8ca22ac3e2444051baf81ad2fe82f0e3d961681e77af193cc57ca13256e68f477d72c849e37f6fa1730a6abd342b73c7b6ac569dabf80cecb2b8f4b18bb37972211e1ad80442a7ca8a68234d408c50e95094e8b3c005dca2bc72032bda1ea2ecb803c634c359a4fd290503dae551c8fcf80bc45bdc9c8b86da29d3ad778aa8141dae750232465071b440a8c20fa5c450b6bd8884b30b69218bc2c7ad858503de3e7b9fde158aae83de6a1461a02955cccaa80ebc4fd7a8283b96e55d66abf8928552d6bea5e763bf605d9f941bd6b2fb8c7d8fe3272653dbec1b65333c6c60e12ac0d51c0ef76ea66ad1fad268b628d0c36066f44e821739c054d877bef8934432859f107c2a99485a5c237a4a28a6252e2c73025fc774703965c92005461172251719773c5c8788373d6f250509ca629de359c46ed4b46a1a75e4bf471835405502e5625c28164a04357267c2ad59275b1c1fe5b05aadb59b6574d162c085ff7aea7f6f629bc9f3e77865acbd7c933a35dbb5aa4b5173096ffc3c5d3dc3a89f997e9cb6de6a11f63c041d6d7a52275ada377eb531485765bd4216686777eb35550953764ec095143527c51230593f2628688bf3918a7dcee4046a8d9359e822d592a97fc86d6eb2dd0ff89e096fe0abb0fe3883626ed8c1fe611a98a5f4c304d09c4c5c2541f1b909a8574489846559437425d521395c07a645db2946607db16c662dbf6796d6f247fa1cb63f6596271b3721024f1fb32ba6be1c776d978a62122635522d1cd8cb67993820062d016febaf02cd6632070af841a429b6394feba37255b82f865b7ff01ef7d5250bd14b0ab14755bf61f465e14782e3c81c36e57e57e64e8bbef811a301d6b2d5068f53633efc3a8bc8a61442f4fa402620660706033b2e495cc36bd898332a5749299ee21d9a9357c80101273d9b6a114722393c0aaade68eda920c356f34c2602cd367927845e4fde81f1f88cf81b8156fa8088563a12cd8035244e9cb6c35032ce0968223522a7ab155d7140b10b611b7ce62a3102f193fb9f6576d40fb08b499b69ca73ec896845ad39db12b0116d002addfd9000b5ef1bcf6081e34c84c99d77ace1dd3cff2c9d71d7434a3efd12fddd9bb8085d5958f9a7470dcc7380c0e6f48c37b4201f909f036fa5f36c1087f8c07661bbabf23c10d152589c85c8824ebc589bac64bfdbfdcd0d487eb79f0f5acc111f7ca9e24273d27263992aaaeef444598760eeec70255b9441222491b9bef93ea6fe1c089e85a8ea409d876c41eaa7d5f1a9d756597a8ae6461a3d04368573781534090ab8c8a8da2c0a1c575c14b9a26d0d5d67a72b54cbd8db6d23036087bf646e83594d75b687daf91e46a2d53c24099f499b44f121bb4df71f1b912e351be1cc6f7e60489cc3fa3a3056095c019098e9462a601acb48d98e220063ba27d03cd6e8fb7af6b887e228a97b829a471cf5068f6abcd5cadad4a4d54c233fdfddbe08cac3132e02e5a5e733139386b5401250d8cde3e71631d77a8570837fb872d3aa40e4de09214086a7cf4426ce9bfbf3fbb4c6dca09175e678c8f8607471e4865f3933fb54f3a590f8b48d8f22188872514359e39d6f682152de836504bf6a58ae33023b5d80533e3216bd41d94343707f17e30a0be35e5e2599fea0c912d97dbc24773b61fd81968f45ecfd7528966f36958605e5301b3ea4d5939f9f0beaa44d5ed34c1e86a0acdb4f72b9716ed3e6a371e7070f545a5890046ebde754e6fb3a093d7912e2a0d928670af85c7d28d1e55debb83cf87e345c3708ba3f866d828e2a6cacb53326c3b8aee8b713802db6128bd08c3e4ac2bfa16efa62b8819f214dc2789828c77eda165beec4e15e8643db5e321f56a240942c234b87b41951ace2a9b4395d72b88f39743786d70eaa73d3d81bc850798dbe928cb7597c63d6953f963d4688092f24873eb8aa0d3ce5117817397d95ea4f3bc33798b339d022e9a7184e1799db2403f75817b934352fe104f710034896653a34292e7f4500e1037d5eade6ae4336182375cca8bbb19232be17a946d0c5edac15ddc8671de2c8be46fdcbc624c423885d33f68b0d22486823a2f4fa36239e4f40665a661c774fad806afeb3d1c4a5fc5d000488e1089b8e5c287e09a90843bb54f7a1c0b7842425a53c6db9cb8c7c40583fd7a9a30013981a8c705ca5904edc6a5b1558bbd2e61c37cdf5f9dd01e34f2b571114e2948a1f72aa1574b63111445cc22bc93dc1c619c295cd2cc1ba0ca41c3ea06a137910d5246bf66be80fffa26d3863534ec1c5043935ea3fdca0909b10b5914079a6c018d0d8f8be08a9a5f06fe43791eafe5c0497d05c8f096765d07fc0d31166695676052863edcb8cbf17d5f6cda3243f73c29f17e95e137f99fcf4f7dafe118f6a637a3275db8b17d81856447354055faa8785b258359d63fb029aeb1231661320fc8e3fa13179f9cbb7dfe749bcacf46bb7e25ee248c918eb7d32454ef1250fb1711788373ae89195be03762bfd39e2a12e58a0cc27215206c7598222e866cb2fe2d1485d58cf036be3b09b6ba4f527f67a52b8eec69c9e92b3090b6d493236ee550ee270bb80a47155514cfc274b1a597ba22000c6de6d8ad4e05be0b0e47ea71d648a27390da1c6bbca9e82f33e6f162dd38cf82376e82be402a8887f6e2cf222201ad250cd08fe6a866dada360a1a1b6b8a8b9b3ec5212e95fff3ff115b3f9e54c012dc6a35912804fa30a609db37c406edd66fc847b9ac22a1c7d7610a03b81ab7c28dcf12e7f7546a2547b3dc261bf96cb0c0809ba34419d13a7a8ce2961e3358145343366467866dffd966cf9ae14e8560796a79a118ef00a89a74b9fca9e01eea7beaadc353c5924c700b6c2d8a2fcc44dea4c45ed34836f11fbfa760759721ec0105f00a0091a6d25780d7c491d604fab4f660548b3e4a78f14c5433a2595b86b0543104f3467ca5964408ddc56589533922f3502d2981d873a29c862cd0b1d28b8fecc48b35ec7442537509b68344e65b7c68aa5f1be3d32a736a3aa6151de24e1b25e5ba340bfc8c8ea04e116b19cd3829f92dd602a514ccd67324c0a21afc2b8499ded2e2792d052770c91be7c85a0c8625525ad9116357e79203d8028672f33eedde11efc9a8cb738931b2c29ef88f6b3f6c0ec63d922b11a30345f83b7f359890aa4dbec1089b847bbd52ce16ee80a4d35bde8367ba3a6aec644241651c06083fcb030445e542c703b98cf7ed6b0ce930b6f261035f4bdd84efc690fec051ba9626a0d35e63162fa08164a00af39dcce180903b3dc0e396ed797c6260b92283ead0e9692b10e4c382c19b7adb16fd3caac7f005764e34fbd176792bc3f574a92eab3d8771264992c7ce102089716bf8eed082cc707dcd69df5c8978f71d5b541d304d33397bd79488c428cffb8d01b6ea7f0e2d4fc05f0bccd0479820649361fe6e67e87f26b593bbeed5ea95c77bea41f25fa74e36286458497f201c3f6407e7db67e0b9d85037899f4d7f47009bc2035c199e7643dc3ae9a1a5be38b844f628e3d3d4733e4f770e522912e37463013bb8d7ba4471317ec0e1c665a8c4762969edf537904992afd3aea630bde7973198b8ca00d11e6d62be2de6bfdf316d267da6f66ed07e284ae89a9d169b9fb9cc750075f04363fc7a1ff9d8817da00585938934058530f0f56bd8b8d7142b541b779f9894b6930e1cbd3a0383d1cf33df06fd9c36f8491667bbe44bc938f231369e6a465d0f873938fe06351d814e038c9b15b9632e1527eb836862ea73306e4c06aa4a32b155338e3466200f1eb61a52c48b2e701a7bf16324bf31c56e911c0c9d517391482e74623f2f7d9bb19bbdd80d560a41bba8741d779f897f534a32248af0e08216c0d6ab7c14b8aeeea2c3977fa767f3175dfdd3d7deddd720d33b489b21fca4b2147de225d0f088a51a8119e4ce0b1503ed851a88e9220c92a6654754eecd6241e85e95496d58a06402349758d8d2546a869cc396e90993f9018f8ebf57bc369100a8869ae12b32059997b653283213d220fdcfeaaa569345369b15e796ae1d684eaf19cb0182c74d9d753655b6804b65f328543a50be6b64c1b2bc4460c8b87119b4bf0c922277ca879f52349a8d1729fa26dcec1e5750905d8b99c6656a3d8fdbf125be6ab45a5d45ea7f38cab9eeee5321f9b0fcf8d3a14ea4ffd9f29140c6e8734ceaff64a2416cb2d2cbceccb89d188c23024bd08273970d923b262c51276750a7b9f77fc86eac549a221b463db10519fde5dab55d2c956722e18a01f341e1559fb24846f564b5d6dae0aa7c5dafb09a6051064e71bc89c9ed28af4f96e9a0187050e66b08a8ed7ff89b89e7f9014375fdd539e9e40f07d3fa42ccdf615890a75642a3a637cd5fbd5178b8bf8fc65546db71089b53beb3717051bca45dfab3f8c9bdb7060a728499e812fdaba5ca5ee6b0af25d1a794fefa3b2aff05a4b81ea1cc8d9e66c426d950a7082e56dc227265ebb6a01a657516944c120f4707b5c330dd4b01ee7a8162bae697f5ec4064650e92b8daa426b12781b9cd5660963ee4254937c2fa5847e8be6f534f7a0e945119d83c4b4ad4f0c6138d8a81d9d0770f71dac810aab49508c36385715d9bc8f1f4830e6ac11526f2dc3ed9f5aa52993952f01b07406c938d7159082f12010401d347021557df2758c10d5c11a4f63c63844513207c8d1b96b6074a91219ccc3b90f8683444ac002ba45d9b69b004fb1a3930c08525a7d1f899c9ecb8abf8515cec7374d11f1076cfafa06f7c738dcf85a80d40e24a66312f96bbdbe26012abf6dad99ad6ce737e3fc0de0eaed0d620e7fd15e6cc6fec05e49e8b0fe431bee4951114f70a9012d01477e07c084aa72e5be0b5d02b1a7e2bc9ea6b27cc5d01d4c85f37ff7f0ba32287380d3c24de03239cb35ec666a1c22a4d0adc71723e45beded385db35f79f0147b1b15dd5919dd22897b79e2dab8bf043b1627f58d904004152118333574b629bffb2121dc10d47953dd58d30405ff8c79400fae978ecdb01a0ea3deb0f47288c3843115d431cb5d83129251202367bd6d85436ac764d963734ee93a353ce0a8ece08acce514ea6154d1fd5fc9bda37078b089413d21ebf0fefac996c76a8c8d68a06de9760a8a7ab0130b8dca82caba39b7187cc64a485f12dfc3a776d739a244cbddc8d14282ddd1204720303dadfe2785c008deb60d5a5fa4dfaf98f55db37599a659f870caa1ad8afe1aa04af22ade9deaf600e4035a6c50d188fbc7f2d5cba4ae1e9df6a8b971cd83e6fca0d7500e81da8047446fb1939766c4653df77aa749d33e900adec438c59c46b19500e0abb3b367a53d422333adc6ffc42c8386c16dece3be49fbd0f2fd4a35f2c28e9d89ed49ab1731983f3cb8cc73229ed4be8490f7d10f8e21f4d8875237ced780ba67d885b414665574f93619460c8e8dbb9c1c9a9ff3a924ef2289096b538dbb1ac3537cacb5317f8b53ad1101b555c3edd4553fe3ea22272eb2e4d54351066e35c879245a1ba6bad96f4f3b915a667e0f9bdcc22f2f0a3125f26f39af984009e120f2e0f3551d1cd05f3630ab9b64fb918260391a744843516de05641538889ae3f81abb0b7ef7269f79aba7d67252283af54b453d372a1f63f11d91c30d63d9619b4fee32924e59d3d5e1970671d7869821343ac9e4c2cdba97d954e3322085fcdb2fe9dab5b842e631fdbea5c08e6ec7fc081b50a8534d29fe35ea9d9b304eb051c3404cdd07adcf9be4217b034df5cfa13d933ba214158019ed8d8447f38b48b5ff071dda2ee15702ca1fdfb7ee85251ef6a271d6d6feb1091fabeed932b6383f2661d7126e85023e8972468def0b7d58b9327e26a7df9d96ad6be200295519be9aeab6c19c9e6acb3262645f6553e9fdfb336c00b648c7f88a7bb2605834ee5c96c7f96d53376fdf194b02bddf2f6b406ad37d031f7485b2150478daee679ff306698d3b5f2f9827ab30daca934cda7938e2594e21c2d3bcb8c5d90df1398c91e14b0a82d54186d1e88ab111e915bb75cca53457529ea806d81b0fadc07183564557b17a0010b795cbd7bcccd05c31867523f7b7e6d3ebedbcee8c5e0dbe1fe21f23124de046b3b2fd6c800acdc065fb0e20b1388ee6ec6efda16a7159f76b8b695e40cb8c5bc338f66cd35454e5507cfdb2debab3c2257dcddc680f342eb22b0515006193fca77d2f8dd4fe91a7d931067cd923f0097b4010efddd444cc810614e2d0a1ecad23b5e5d12e626096ce3e4d5ed484f11819930da721fa885b3108b6115c736401b5b21f55b33a81a20fa1478bf6bf37a3491c111bf8d3317947aa9bb2227f75136c12f40253c78a119c80a2d5c741ab1d20e116c39e637581588a354dc528b320bf980d6c23621c864617682db6988e081fc01c6c41f27d28686fc992b5f5ec2478cb8e22b20f537cdea3679c5e6355df7d34eade8c82ec288ad937c39a712582337f14a81c901b8239fa0a4694861bd9a950421217901a520adc8f20c91eea9acd021fd5fc6b1bdfe754255b5d151656ac1435db0730db03e69a98d9f27b01c9ae35291d062600c9473b1e25356eff41f6a46cf4a9323cbda80433391cf19b158d616de665a70ca827aa947fcc30fefe9f27eaadd476eff9029674d844d4572723aa5610b0d6cbd81c0a70efe6c57a2a32f90a42168ff366eb54893b5968724cdf0f9e2a432b7d4235dd0846fc2f8738db508b781799487220a9f6ca9bf84851ac9f01dce5bde8ebee4b97e55df16d1be63bdc293ced1e499e1cc98e4e939ef61908b346d25a3ad4e2a1f8c87567b92b281fb2cb192e6a7c59a4ca76385d13cbc6a0f7e845e84e4c373f1d56ae65b87043cc540eb41cfaa8f1cac29c656089bb848d7cad98c1436a804a69b40f2d6a959182f9c8f2235264faa69e95cac03a4dab48c736e27f648ff1c72edb753e5efc843aa63cc4ba77efeb4bde0e62cfacb6d82585e1745c9252737e629d4598b75104d9a6e1e3ccaa411262eaa4686b15d321bc82c5a4d9624d642226d95089ffa887e3aa8f64e7134bc829e028b48da458816c19922b7b92ba1fabdd54c9a0150b6c88738f01228860634129e578e553dce6f153b2542bba7ad99bb1f7d1952bca912cc6504a8a63fcd0fd9dd2a57b9cc8138203828369c5517d8231c97790831441cd2f30b1c0ea3bba8ea6e908a8e6973f69c8595373c703cfd04e44e61273df240bea380f8f2aab10caee1142ef45a8426f45122954d9055801c0a98803d06a4a9fbae2f81c11046d12f5d991f334f9174a306884ff2cf502b3dd8ffbb61d8690e1fa77adac144929375de8744041b0e090fee0dfe1e921c8583c5103c6a87c6ab7e6e6f3b08168fadd707f25a59fa273e381e5ee0a01f23b5186a0b4953c3f7d38b9652ccb94be87623ea8d3574e1d1cfb08a1311c8f8c4931271d82f6c4a3e5870afe0dbe7177b07744160fd1a9b54ec121fbb1749ae88f8c13c2227d1e0dc7ea3c4a05abe980a0d675d0e17e8728396ad2b57eaa4895144c63354d84a17643388217cda74c1c24d85587df4b1baa82cfe42fe072f338e97fb034d2404b4f8fc62f939c7c7e4ed52165d758e8e38840e5ccd2cd52527ead645f172338be8f1b784cab8ee46af10ff4ee22076244a4f876f83fe2418c8a05f48564b6eca9d618e19174829e37f9b5de9051bdb1d8d93f5950d134505ea2981fa70f838597da533c28c446b59fe0bf7b275240e8ac5de33b62c1cc30cb783b58aee06780e21828dbd708e38c2f616944c35d3c4fe0ca6f4feaedb5c6b93ba95023be5875a22909d7624a60f3dba4258d0f13baa80935ae06c388bbd2f359f22856d550afb88a460e5253d02974a4de4dc0e063863841b14e7b40b27d3bb75ca23586a607aca6f5dd945fd4d725cd353188784ea89c08368a3b3b2eb210c6cbd737f4daf92656b3756d66520977335181432f93a3c74109ca6e018df740aeac2cd296e8915af17f4fa7471d4aed22bf21750eb3075962a3591c51c5514de2fc9b6430f867ea5e7bf922a1ec6a7f578d6fbc198bc45586ad1f86b33e1d3d095eafafbcde4f4137b4fb94c6cea2b61c4a6424458b1d4b008d2cbbcc41fe16bd817abac6a5d256f19af79fe0b038483d1fe5f371e9bab2ac0e1b3760c2a82c29995c540c4aac87d6d91a3b67588f53acd4d56288fa7f7eef04ee660aaa7473620be6a90dfbee91966ebddb8e2054ff59fc8d91701a242f8ea350318a024087b873fb08e289a869c4807fef12e63e911416e753126579ab8f42f60d190f36f9c2ce989eba5a9b8e4adf94f7fc26811e20c8b6859e387e0bb119c374d7241e64c77c3abc9c0677e11dc1431b30bf09c7031517036d333dd0eb321a718c3be431698c7377d49f4d11f5957e3ca55b314031f3a75ad3af5eb40114301c3c3bb51f65b1707551acb7fd42eb1bcb2ecc45886a7df9d4d4694bbce4e046e3ffb6acac725d4b24a70057b76f154bfb0a5d7343aa86495013ab4502a4fad08b01792d41d19216494b2b71288aba5edcace9c41fc64620e01e3daf3796c888f06e1b0185f51139a628ad8d8901a03e2e4adbb886ff752027f82074dd8ed151a39146905941184bee5bde87bff445f089416443e56800924f6ebf76bbf207465b5060c66abc4111bea382c143c06d3a3418c2f1b21a861edd26f338864ccb7372e4c18f4cbdf227bb4a5a4af21c5efd383d109a56b83b488e1849deee17fd0814e98369f0a87b191fb73c947c41077429e9296cd734554584ff9b87fc5061d831a79793949ad8c5394a6fe775d254be32afe99a4edf667cfe77ae3017e049d3d21b37449e2d7780fae188d641424497c6a7c011ddbfd9bbfa82b44b60e4e64e26d9d161723003499817aa664db2b9bfc0b91e77b47d26dc98ef60c4472029eede1277d41cbe4ecb3b178360da066f4024f26144f95c80f71264ef595632abf3df436861b06c71e98294cf5f97050297d75a6a2257cfba849f81b31991057d1b2742ba5130170a90ffc2f1f8ed54e936ad5a147046bf8f4a71dc3264e0dcf8dedcdfcddcac4c400283ddfc428306461f8f0c812fff63855866f1516e5fabd58bae9612a9fafde1a91d943d4cd40ed7092342a32492ae4bde9fc86793eaf6bcbf00f38ddd8b38c24b4d549d9d675b49bf156df94c5f2a1a21f1d9e7eb938cdd46ff9b0efac5da47bf7e0ec272e11b3974237acdbf27d702245b4b745810cfd66e0235c08c3f0cbceafe0a94560f8eaaefb4bb581df8bdb6c53d767e8c3282e9887f2ca61d2f048ce8a9f5ff27cb0ed8c31625101cc15031409432f58c393089bed0ed1821f28fe9b3bfbb67b700c479b9ee6f8feafcaf1bd159cb395c8bc04cc6181447327e4c3b5c69cc6f834e3e28824df02c9121c641a08f1aa136ee042e823464f71550968e266cb8c199cbeb54e89c64d78cccb66b19f888b8f50b2f7b9a27f4580cd9591187486dcb8eb88ec55b22b699f5b85a36e8fbbcfc93d596a7989689cd1ff37c0258784d1f124278b16de88e6f9db0aee590ed8b2c2aecdaa8a98644b01388d126ca6a1b4466b9eb0911c6b312ee63afe75f473357f4fc1408c752d2efe2edb7d4763e9dd5565ea4c44da0c2c24789c3a3e39ac553643fe552a2c0d4ad7da658e44c81d760f6ea26055450fd809eb33cf56f68401691f2cba2b5210e99b742d53e7df819eec5c990ab644b7e68a6d716503489a1a55c5a6da5228cb75a863f41e4d77ef7e6cb5d1af69c1c406c8fa9b48e95b299e0dc0f77e33c403296de05d8d2c2f4368a81b1fa04ae196d27d94fe8d4117a5229cf8fbc893fab6870d83c344976a004e71c8d27ef5a5559c97b2a29ff20d1605844b5d91d51f9d7d77ce258c4927a994f06857536c40d1aba35f234f6dc57ae7ba33b4b85bd2dbd8e87cc606b7003228f1d4de88ad98d5b7effb3b688a11a68627feb18ab41a82ad533ba7a98648146ac5b6d69eb5557756b55f45ef5263a99401e6fb6cec6798392fba3a733f3adb1b973fa4d5cba2ff3b8fe6f950b805bf27a15fbe5bc5cd838210a25f48a87b7016831bec7fe878a5c084176efced1648f49324cefde4047e444a378467abaae91fed057b8e70fe54ccb3d927d1834bb83914ed28d7d1c973e4b75e49084a11f38f0f684ea4d1a1b686fea39b9cfea1704fbc7b87bb2e684c32b242b4bae2307e6dbc31342e216c14fe1e5e4dfed0994ebb3cf5c1de004ea8599baaf0fedda7d414af9571b2298a1ede9a21b36658fbd5562b071f0a6180e5808c0d70cc071bbf4f06cefbb1cbf403a21b2bf2f77a7ba211e6ea42565b123bad24c1945e55982708ccdb91fcc1377c23fd852776061075b29826ddb99cd1ca18aeddbb9d482d7a6df2ec2bccffe3240cef894d3fbae2b038c7300c88a7d9fe8c84a30fde7643716cf3bb69baee1bb14acb1b0198d60e0558665d3f7e81fc4ee39a3687cfd73d597f71b8f314cd01b33892ea1cb7064489c21d23d24b5e4c4c3a721e835349e8cea59217adce544a90e9df4f7b4035fa741c66ff524f8d7a10cbde75d101dd4ec26b7c75e581428d064ea4bb0e4da8a9b2a3a99612a94196bbee4664e28f1ffec79c1d1511f20a227d2c601bbcdb713c7463c56bc352e8c63140066eb0bbe29c5d19fdbf904a6497dd98e90c9acb04f28abd0c95f282de24f00ced57623b4bee519556ce7501d19f9639855bd86951ff89167629057d6e042ba70b69d79b02059544d1f5e1fb29cf2e947d2e10ac7aa3e5229dbf23f27403d8ff768ae37107258811e66af31170b4ccd05907dc167b30b6c002927e7c0609b640e9c88941d0c003e06298322fb57371c39f5b759eb0419697c244905c4b86d4f0d30a0bc5adc08c3adc02dc2513f6429ae675fbf50d0c614e7a84ed9b8d9be7a8b7908e22c26c72414eb8938f69454ff165a4bdd959c60c19dd839765612990993daa9821a06e89737bc2dd06c0492f048e0621e3c9c839e22f23da9148da521347a1dde881316d114e0ca61669fd9eb711680f4f08acef1599bb55e897e4897de45bc257e05e9b4e0ab5d4dc9b354279838b5c41ca8161ac533efdf39925a0a928038b4dca11a2b419c2b29775b0be144c90b83fdd44b85b2afe5b3b1adaa42d5b5e369999eb3325d1699b2ffdeb891320d89abbb75067748afc323ff12f18cfe00cdbaf8883e16987aaaf0983e453c2b4cab8aa1936c6b62c33218de001a08db7ee31078b39c37fd3b77e7f30f929d20707b0534e52616ed50d2c65453d5602a61ccaea54a4dc2830d57443c91d3648ac16cd4de267a303bf4d6a98a7d8a22d8e0fda80fbde2dd45a88dc87f4f93f520427dc386ba2dee1ea9774723e75987fd67bd6a85683b34d218b6a54b972ca39e955a64fcd95715b751b03aa17f3750ab1129514a6f6a32353ed1abb175910d39aa3509c6a733a68c3724793ae8a4789696ddcddc8f186509b755427b89f3e132b2580bfef3c14ccbfa55ad0962f0170bf29341614f159e3d1a7748ef1fc8953d81a06b77791f410f7bfff57ddd1a834fae21ff4bfea29665963909d72d30c0cd3e7f94a7c562e158e424d1d3f3a593742dabcb17f7a11fe54cebcd2d0aa79b896d0329fcb1e6291c42b2aaaf9c444ac53520c9778d8a6164051026dee3bb7377e38624bc4972b99634d4705cdd4f629dc5e107b5a4be131815113e07c2ccdd3d87461305fd277d19680095675caf0d2a3f5fc18ef2a00c79dd9f7d86982fc26402e9bcc24a2151bc0a5dc06ded47a5cfd489d4a940c9f67bfc8734c44071de26f9cf455be163328d6378cb83363691c8811a6a236f5c071960ec5cecf41bf32f1603251ee6887269a97dc8ae8c9712c25470a91a30801fa8e7557e552e4dd06ae76b3d0bd62595c45331f01a1b6cf02c20c2ae251e90f5282afbd079c9103648e31985f901eecceb3d0d82459d77bc2bfe8868cbe69e337317d2f6d1817db50de67ee8ffcfdf5394745702d117ae2aa3ae0c05d8266c61faaa9b8487884650a91e902a1357f39082e97047ea2e89d2d21decd66565ed16601b1a1d929991c641d04efa8de7d978146ee529701bdcdc4d4286890b60dc8da83dfba09abc5c8e42f082305a94103460e422241c9f7eceb88b18d791f2793fb24f9b4224ca59033d657b0e2275be57fdbb10f6ad977911d12e06ee94e12f614b1d2dc428153af7dcc852ea6355637c3e8deda3480b62395f50c99d24d96b56c0d81a8840437c2f52f3a96d39579aa0c820aa5b16b4f6ac0b3f100b81a1bc537140b450a1c6ac25e7359f25ce8fa1bba7a3763624fca714e66b8add5f68aa16d6cf5edf6f41ec1cb163fd61035ac3ea10f1d0e236adb53aa5ef95feb57d5e5ea988f89a49278aa32168f41ae371a377058104d8e5722f6faccb7bffb1762deab7dbf9b524afc3e459f7f858cdfdcfaec8ce6b54db4043e08e000f93fdaa1be90c26bccac74437ca30f60a0635bb7be8629fae4d329e130e94ad8a3737d769f74cff9a0d713c8f4301eb9c11df09a84eddc59663f83d7be96ccd080cea8e7d3c1db00886a0401be1519a01ea42c205a637d7ee3c045e7d1cd585c33f4cdb99269a73fad9d4aeaed056ee084ec3765320a99adf5802436eaace5ed8e18fcf3c994ac008eb4b95b3bf7e20fd4b9e53e2b02c5ca8b61b26da11ffe37c3e767cf8eeb15771d39e7213387948cf6d97f78c3b929246c18f249a276c17b6c002fc7f4bfbab2309509b99d5085400e8b56786a61825bb7469ff75821d960f821f4e6f826124fd548d85f3e2ab5189ff78d724273aca7986cb901c116da615a7e113380e13a71d762e4b2a557d7e1af18b3a229334212e0d1e0413f7a4bec53e56849addf23e7cbd1061454eded81c1b21a0e4e90dca4acc411ea2eee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
