<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"261a2db6ae9a09e5754f200b5232c43c2f20348d6526ef3b77c732e1107dfe01190203fd1a3fe9719e0849d188b67d32b3da730c52e844dda5fda8080e9bc91bbccdf72bc2874844c58f6fb1c4baa1608989125328f792ba06ad8cc3e365643ebcbb7f501ce1963c7a099202ff615114f289e1ae5899218c6a6b0d4c682e10c57ca0aa84ca40fc2b66acb143a9d464e59b0a5e204d4698fd6b0481ee92c5b349cfe69ff1633e1e99d2b035b95e08fecca7ee4e5cfa1729b999b81a53249b6e96adbdeb50fed48ea1fd54897222aedfd401f0cd7e91346d459487e982bbca39802e34e408933dce59ddf26ee7c5fe4c46e0c131ba710518cb5032dc449b3d052274cd7b1f5520ddede9c1b2da4678ec14e8ce508a81a40c018c89e5c06704b95ffc134b680eaef255b7d80effb3ee45277b05c05c344ea387d99fce93405b58b877b99c68c1fafc3ed45b3d77c07f42c2515199c6d1048ad350495339a22ba4f777124ca6b23a79b69590ff341a4a5e634d373f6ff050f9e05e5405e528c33910b41ee82804e632ef06208294fcd1e49283e915c75b3d2c2a510423d1680ed59287c21146ad4445d5ae7c9da77d35c1a07429ee7d7388bf5e2aa45c49dc1085d717d65b9949239ed0a312f216d3dd79169288b8cd40ad4bdecabb796f68cabc854629a514fe8f68504d1becf137fd0e05f65de295a21e43c2588183f94ce4d5dcf654a73fa2eec7bc21d49cfd25596d6ed19b5e856fa183d7fcf06f6462e2b1a6e47708dc9d01f5959647c9d674e78a10ef2daf7ece9ad49adfffe8c5c115027cb6f4d863ef5754679684e12c6046640ccc4e511a3b6dc477ab2f37a55cf9f883d49d7b63910cdaa918920d6b10234229e8b0e89bc95ebc8145fdbafeb6ed3f6dc6721cf7a147b99e8830cb608b4a2b568cc9d5d5ec62c353b3ba94ad47a41dd802c1cf3f7d7a7ad1a93b86b907e19c1bc27cb1094a30f9a3c511f693b4d37d8133a8823a00af92baf371bcb159270f8c8050254e1e842fe7537beaa765fce427b0e39d8f0691cfe28d96ca5c6039ecaa7e59b9c8e21cfe4b6e33217daf57d2ba701b91184486f7a56d632deae8ad6958093bec0282b247ff6971162f92a048b5725e4ebd5b066f1fe220d0f550925ce771e0babcff7e27ca0e119c1cd00e0020799a90e5faee559901be8c0cba68d49d4cbaf7fea373f40b2f0ec20aa1b429eaf86dbb9db2f783c043061be7c4ed94159177a954b1e1b3f06da53a3fa601fa2e83a7af137660e8ec2e097f8bbf70d8424c49fafe0c8886a853c9af1acd970d8232e09e81f6caa5666a638e244ced2109f25e1599bbce556176d7c78a4d20d11b34926124417d7066895fc48d361b39f5c2c1295084282242911746b51037ff008919d9aa7ebb4405d3162bfe3785677b41fb977624d06cfbcbce6a2cf7799cc06542d3fae09278e4875eed6442d8abf6821a19f2bb720f8bd607f50889b1828f700f6d09e71974c81a5f2e2cd68c15d6266bc71e20121d2ca17c30c2e14a35200f16476499e95a3ebf437dc2a895f32caba3e161d56445e80f8f1d13c88fc2d1a9f5acec6e89014f794ab42dba5fb4b62749bbbf55bc2b8a271aa98b746a298ed59c976f6720df428771c2b53f8e45069a3e81bf3a9695e3c30ae09720dd0d1adaa388ecbaf3e6f9144271f26ece4fc6f931e047903694c0d9638d778ec4f77f338e5a896d198ee5f60a2f6e173fe41df26d9e700ac985f1cd42d9285ee19a161504c92d1dd0222acc51ddad05a71da88e5a3561868a121ef11700b9547a342fbd888eb4f20de765d32919eb99b425c65d98c21c965d9dcb45830faa1309070a1bce60cb4ad01794d7599e5e0cd4e1c89cd3f229072e5e2d472dea3ae33638e4be0d88571cb992144bd4bca076aee38ae1b02ef55129e2d38f702f489fa862889ebf6aaaa24de998d7d8d891d436449b95683d7285dddcbbabd8aa380c20c823b2720c9ce88c8a713dca7c5506f5755516b12083913a178a9e351b85dfb2ffbcfad1b3b1ab219ea0003a0fd95a533221da57cbfed598341b3b6e1d2ac5f129a97ee2e2cf8682ee6e485c80766dcb2b77d03337e16dceb674470f7371dfd7467d81308922f0fb58efb31c7eca91fcb573ccdc4305ed6a782df2fdcfea93e9689e197556ed8345e5302b49cb6778e98cdaf2e5e95e24cd3fced5681a3f0b5617643989ab98fb15a964e3c9e8b953a12e6dc2703c05a4c74501e90dd135437b47b649839aa9cf9c6c59fb35c95c72ab2abf63acaca0efbf6b315ee644f75e9edc856a1d699c9b339dd03166e39e977b4bcd0f8129fce234b32e9caddb6fcb55dcbf90984132c90117130024eb5f5aa430d7c73f44e5268c77becfb9e6763acb12fe9a561937e10122dc4d4413d9f2b82d2ae436b16ce201a59464defdf72223c0b4d19eefc7f4f7caf8965327cb61bb562829a7b441d9624d7b5d8982db564edf9dc48b5abb9e7c8fea0de75ef097f6eed00a5b87fb1eaedbe710d4ab7aee51a951810f3517ed745ff80c447708661970e9b18e99a0d2284dae8afa398a2806d18e92d4736a4b9b25fe7d84b606ffc687231bbd613247179a9f614346a76209e9a8850bfce528d036d3c8b80b1c4c505c9f01b216ab6adaf68ba357b7f6f9eb24548af720bebb72657d4c71909de2dfa301ef5a4e389d836e493fe3c8ee499547a196a6e786ac2ae6c9a460a24755a8119ae2901dc26eb023b9c98713cf9a62fa9a7c71a34aa2ac5cc3a541827e58262566e98cd7e981444c216c4cca3e82c1dd2129d67f75fb19448b4657587491e815c52fa9ca45aa4031bc6fcce824d1190e5f38379bf96e5054edbb771caacf89a4df6c9ff6124a3e8ca2417da4011ef75450cf290617976e7ba977bcc05d180da4042c70ec0a7fa33b77638c7ee27044d3bdeb2c34a7b577bce1dfa5e77ba6e645ac341acb802c037538dc2d84f92537db81df07c8a328ac4336911599202c9540b9b16e9437f0efeb6060863c05627f6a1cef688715171733ff57a5a33779e054bcfa1f645e1d50088d45bceb86f3c280c3f100e29ab8e0b147404a28ab83b56cddd61491f398f9ebb5457672960e3d7fa3d67dab9bd7cff82144b56d88610183abdb3c3ea819488213d0fa3d3ee948f0306d35c911e0ebba9d9bf1f0ae831a8dea2ecb84e8b71e25e5a538cd4f373c272564e3e9d84dc4794af734fc81c0c248ae142f70ced4ffc8def59a6be5d732ad97a112c61f2185c2180537a5610aa88562e34263928708b2fcad13963199ddef955d04ea169c1be4ff3b24258a66462c0d7eb159c03e36e3875b929b6c6a5556ef80b57bc8e9823ccf831f2fdda9bc7b2a4ec9450d927935b5c035874f3ff3416c80087806a960da67bd529e90b545f625d1505492c28c4452707573c4c4d82b2a783edaaf9bb16fa5d9d22b502c926c1a8910e7a39f5f0cebebb273249f810e5e12e5dc80f40a1996ace2fbd0255a40f968bf90e950be62d2e8f8b81b250860a9f05c0f36e458c1553bd042528e3ff2a05ae9842080d73bc97fbebdf45e217264f82728fbb869db36199eae4d7e8c1e09d5df4603f39ae59be3728592d4957e0ead3141dc32368486dc07e1a67513df8bf75c6bd8ef043040508b313bf4c76fdefbaad2086a1464c9a55527283dfec01a41b7b24fc766faf79eba95838082dc39772673931f3fac4d3c1cfdb88a467ec85583404477a3e0a7807df35e539b2d977aa0c9963f45e3a5fca39de7a519b50a04eedc8e1f98c558fdb46274a7340dd10495a6397befb4705a7fcb4bf1beb58451efc238626ad26e76eb93886635182cd24f13c5bec0417824eb4955ce35b4ecf702ad28f2ebd0d78c8ed44ce047e3858c326199903e137f03bba302993c5d90908722b0110fcf256f28416ead91071faa93b811000b6b54e86650cc5354df2815b90fe8a639bb19669e04c86177ba2a20cd3d158fd9d754aab1c307e509e4b17765eab639929883d0beed8aaeaefcab8ad712c180ca5483c942a71be45c77d89e7f7334d5f2576890784b3db2dcb4f1608aebcf607aab6babe78fd9906ffddff8bb9be8d325dc147f5e4d3a68a5ede2b028b342e2bce9b89f53b570b20a9d104807937380fad40dadbb01e80192dc4c8be612ad57eca06d9f9281368b2fe83ae2451512ef46c0289be4ae06d8b5a86c75beaf24fbe0b245fe2e37466bbe5fc568d01909202ee25d418e4b23bb5d53aa72621079fa412bc299526c1c5928e4085464fb5c62db28b8df982f7305bbb8b2c57199b8eb3ccc8dec275f62c2cde49e03ec698075578ce04aae6358ef927333a3bf1a2e379583a617772076226fb3f655447c17ce5609434bbadc63826cedbbb94dc9358375ada8b80aa511f2be94732524bdcd23cee7bb4cfc72bd0d0980fc9e325b9ba00aca0353dc9741cae667e18ca4268589a86ebafd0eb025601ae9ba5d53494682c8f35d5e7302109d7b73bc1db78b5029b0d626865333343ada2311b770052cd878f47d412511736a3487d4bb88f8a96527932b26bf0a5872c4d51cb76055c7a0aa94fd31b3aab42db36e1043a45db38bf18f9778c4b053b7550fcea26359c832854ee2b53c203491558922bf2674f1feba084c5613412ae39f6bf5c9c6598e8fdcecda33b91f63bf17a9d06f420439894dfef767a4638b9abd3e13739159fc0fd30c34e5fb3ff42ad0edbaf169d6befdb73ee1996e05304c409b62deb651c1e16fccf3c76f13462f18231650a5b6848a5c73e8c0c7a237158afb23d78ad07e9876b2e59f700c853e34605725933b712e9a0947e8ada514485957d5fb83db51e482331e51ed364059e6e0cd9ec37b5bbe43ccb755150a98d1e085a812a448db91190ebcf2277a8b1eaf1badd2d2db075eff35333b338518f2ee5544abb5c949136538d84dfa39a226f76a78c0b4e4c0a2e7170fd44506ae04eb1127cb0f62c8ebceafe36b2559fb0d93e0ef57dff0ef4823e64ad324236d693f3eb9a14e1fdd95a945afd08aadc0b7bb2e95815b1da4f06fa7f40027a7ee0c36e0c71f7940ef1b51efb3757137cd15ff6dbfc34f3aed78eb51ff26e01f5a3533318e2008d24bbb9d34f5d30b1a9bb7972178f99515ca2c44d305d000f864d8d503c7acf0ad75c7c565f43013017c029a87d5da3e72e6ecdf3d04acbd59dbdac50be4d092252c1b3e0ae0ea8809c17f0b04de3799c98aab90c7b9bf4cbb54472ccc837318eee4c9ac9bec9a2284a66a6a428df571059496009e9c473006f1484b4cafaf80f8bf0b77c98e22afe318563d9fcfc6275cc9ccee678c6d4d92743b68915665cb18ded267f0f18a7f99e6fe18d0a1f0d89f96e690016ad530465dde776375a0d87c31ea6ebb0535fa340bb6375af8b440d1159c3a6ab176bb2209665a59d05eecdfa72050db2d9455df5bb528d09cc54ef2d65596f08ef7f0f4fd52e546941f3c37b317a1c621819c76683ad801c9e8d671f860bafd7c9a9ccf0f8c3591c1a5710a2e6a81d61eeb20458deced27e1cc7a215472d15b4b40a0b19ae9ca6b36dd20709d2dfc85182aff4def960352e6a3d101f30069a95b8758683c4def4bfbfc597621d83a48cf24b28ee7a8441088724e9fd09e788a573ef51a87c6a37eb9160e183315e66c91ea3ab6df29bb6661e73b7aa6095216f540243ceefa61721f29c9f66dfe31568648b4c55214df499cee6532e8f8a51c2630f77eed1d9364b9ed09fcceae6ca507acb44b377bb49d264979b431d2681661c842bf546a0483f2a314732fb26d56fad2fdf555393421c49a95a4e060379a9b8edc28a9f50e762335ef871631f0bd7aa1cfe184ff877f14574764911d8d8129a10db1725d3f0e4b597280f3db69a0c8574bd29e314ebdba0ea77e217ef759a143c2124a88e0f1caedd3fc0e6f5a9e93be5eacb1070a2b352b3211172cc5f033099252d2f08b4147c5ee85bad7ae75349ba831fc9210c7f416d1cf069f2e327bd752d8d7c311c9866967a03b87e8f89b7b7bf2ceb0983a526c9ddf9f6d93e5b66df214f77fa2cfad229d4185c72383147433c9385ac47a5520b821760b9442c9e5519e6eb9d98b7f65820e389de6f55636ff7dcb8da670f680a51796386d1f987f9113c43fbda2f887772319e7052499515b0753afe6fb622b3368cdfbfbf4863a6573ae5fa705aee8d1637f4f78381267d92e1f6953d0b6e378954f3a469770993e654d732623f7b25bf97484873856290894aca9230af7a78dece64cc20647f63f4e9ded465c93aa3ac5353d369d1272cc3250349ec1a15ab18ac6225cdd891395ed9cd9759dafa5030c196fee04adf116a8aedee92ef7ba9d111485aaa88345f046afed95e29b80b58222a974930184baa25a03272c933fb3bfd33802788bd8df1f82c7d1741cb75cae5842e7cddcf0a56a6de6d5969d69325529a56d055623a1f217ce9f658c92c8aef21377b42820a30eb390bac2ab0a82a59672b3b03770957e3bbd78ca647598c6629379d999b0363836e433d8076a0df4bc110ae70b3aa307f3351cb6c54c2613f3d54d27c5dc7577f0b00b541aeff5f671d256191a9fa87c60f895fe01458b42a0ed6de59e58959d0a8c322bec2b405f85645f80a80a334d298f14ecfbd49e0cb2f489b3eecd52c00b5564eb701d79fa9c7e5096673434815d82b689cf3ef02ea66b639c849a891b796e68562b6804e7f2ced44805263a7b398b5acbdc790dfd8631192861caee6a9cc9b6326c1d26598cb1dd58de9989c8eea6cf583eb7dbdef3f1b993a6379949f846e2fbe21d788f84c16606f9661585bce5449ff6fdb3fa2f6a0253d93ea27a8e7ca496251fc7b3d670269c7e21071ade8509c450e01866a5bfbf8bea3c485dfb4929a1e9f72943917d1ff3aa9216d326389fe3735ee9169e5c370b95dc3e796aaac8578abbc682cbd4ceaab1b30a087003d2c554ade944cb69dfee2380b7476e5d4515301624df7d112ab850e30e5f1741f0d85c3a9728e4b0410f88625cf2518748ddedd3c1e4cd2395ffd22b21d388e1850230bac2a49f0d2748f44280830a2e505333fd9f376d8aaeff6c3f1717e430d8ca5bdde244f76b4947f43a5083ec76accbfc0c8d6b394963b51f8347a1bc25290624562fa3afc40ff2f65f41ecefb0531d6b8f8973f071540742e75e76ea199551a710d3542f50067f3ca8258b06a6e9cc8aedb965b30af019e0b6211425d8cde41831cfed25b2e7e0119f4c3f9cdc98faf27be2e43d94bf817e605687e87e41c263d9fe10781ad7b033ae2c6c62dc7d34f8f36f03070056e248ed8157e2c3970961d5c8f6a4b6011dd9a35e0e78e5effaf8346802aae64b1965a7b8af9f91eaac084970d852e5cca40a808e8fd8bef750366bdd7ae1e70fb323eeb94abbb91ed7faf74485bb23377998ccdabdf1ffea417fc098e9e93759c2986511bdef634f1c584dd01b7ffdc48e790f7bf2c43da9754a6e44c3b0f3800ce25edc666471f1edb9b87f381176d63bda50e55c84eeb8bb30cca0d4fa73b808869f26fa5cd9295765b7dd9c50e70e77c857fa269f5e45996d298fa0e9358e149be1910a97d90074aa11384ceb9914e758450311a03da2c71b146c95ee439acb08c155bf33fdab39cab2f99e6513b4ac5b7fdcbb013f7bc691c1797791b8971b79267406a477c3f4f6af5b416ce9c0f7f8c18cbe0bed97b05fc5a32f43598cdb839fcce4b072e93e6e531cb6c6d0bf649fd1b7bb24a603714fb676b5e5ee71acff9e9a98b5cb38bf25a0a4cdaebf0c619f2781515b57051cceb2e86403a9411075074b719626873d545696fb9196d1deb47c6670d24c71000c906720f4d3cec0cb730a148d56c50de44968e53621a7473a15a2e841095441d50a6795470e88094dca99b28f9b4be708792ca360131f308966d5d4068bc5e7fdca73e43de32f805ed97101564e85dd5fc351ccf6d2ceaae853b8c189cfac8d4acc7233bbe2b1be6b3f4b474c7eb4a25996fb128194f242a80ec9bdff93da659665933a80f5be80e701c61ad154fbe15c45b7bdca50720e02961d36e486403478e1f63df5e5ed6727d46e85460980485a2404e20c9dd3d8208d8701f01b5d3418eedbf4d463389d3485d15835f9d28c014d9926ae2f848610616e6b78974e218e058efca3c9b71712a64fdbb2446c9236b30f53be01415ec72eb5cbba270f3b6871c22f03bae8e629497c357b5a5706a8d818edc20821c29f50f3f4d83c84027aff270602da1a55c0706f9223ffedf03cd84d9ee552c22b14a334da02c0025ec854bc7524a079c85c91ce9aaa32fa2b4c5669b9dcf9d5a539495f9e8d9850fdfe850ba2e847221e196490f8ecf1ab8f96586eaaabfc618e39cee9bc436eb53ef8d40cdcef58cf42d579fef6dba23cb6e5a268f1a1e375012b1620b78036e2638e8ed95ab4953dfb449e3a14b7ae995adece60780489b6495a83bd66d2fe0b1b9a5b61ca93ed374d82290dd22c3e99aa2204d09c999633469a1c4b48e772d083b7947a7eeee1ecf454838e743b055f12ce48300c6fe516cf607a62446df436237bb59f34fbe42f28ca8a4166a6abb79d34b2cbecbda5b4f55ed6eee705ebc0666beffc64038ba8cc8ed61277eb3234d730518cb7c31eb83b8ca3d8eec40673978b5576513c3315b91c33f09f422cbf52d52c08663b40efee5b29df3a37e8b42862a8d38b5820463a1ce9171d58bac19e951889215f883be12d545df7d52a53f0c1044adbc67bdb00d93a33a040549bed165782fbf7c3599c6838b96873b3fbf714b49055bd47bd2be3a7cbb03f9fa41da05c5999fa953844bfb92e86a63964155f941cbaf2a447312ebdc8d192b8f27384327e6260a5fdb67905de749a62758e5cd60930b0f0c516c408e96ab9f71c355a6e1b486a0a272d00c338f550e4442c35da8ad705d42c7d5daea0be86bac003d98d694f3514843c6c818c4ff1af20ff0ad43eda609cbd3618ac20c816c43839faa9004e3de3e8e97011a4334dd2896e71e1ce0d5856741487b42d5d6b992432f50647b939f89bf1fff42f5ec4addbe1faf89f364af8bf5d78f8bf2b6a6c9b117bed23860d745fa28a7431a8f81065590bdec958a131d9e34dd8108aa002cc96c736367e9d0060388ec4ea2879d71d17a5cbec343594826f61ac1fc3da2c60c51731f74d7f41c3fa94801c4cf62e68996dba282b68018b9aa0fecb1bcdea129914b13fdca0d64224d550b1b667952f5128108f4c3955ecf959b5957bf5282eb3616614dcf52d3e092dff2661bca3c765aa44344ee6a8ff51f6225d39d82b021717561042864cb81d6fd57a7b1329170cbd6c6a174970c7303b5f2310f662c638ab0c9b40eae3c2cc3e6903549e89e632af3348dd304bc634e118c9e49e52ed8c558f822531730387f0feff76a630d41f20e665f661631577f23783091e6292fe5023a93ef0492d5d199343d601eefdc4775fc7bb0acea9f6229aa7b993f7eb274d81258fc73c231c52ca04dc9b64e2e17b7b31ebfac0a76a4fe1a80ff2a1d39afc32867123543d23d09612159f6a4795dac38d449fbffa39590b03af68e77a8d6dbb327e38923c1fe460d87a5d0a5f44818e233fbea8aa935899e558ceca00c66d359fb258e840193299888ae9b37135e23f4a0088f5772b95ef3f5a5ea5953f0cdcfb9b41ffc0429f26d58a13df0d6e4734044c1c34f00baff565673bd98d8ebd2a91521bc01ca944c1a01f2565ca334c9f52329ef74378e9a74f430e1dc46cddd321de72cb58f1d9685bee9ec6a41850e708c894d2cd9c24f400d332cbe6f7754f3c990923c3f065b44753563eab7d65ca371f02dc27b0c28c5b074eae332733eaebf1e868fa5d565fb661afe654c3efbe7e50889467e0c69dea32900e5099fe340f52ae81da555eb7acb5fdea35a09d7d0b968be8bc41be730801b5bd4fb3b99872f1a85911238e8c562618410df95f93db92cdc7c73673e5b5d7fdde7b83088cb846b4c1a9b203764d86bc5993548f103596f3d704a6384a5a33ecaefd2236788e3a1ab8da304f90ab28a521bf29626907f85b87ee4ce5a61761f52d9842ee4f09e1f90d52933d973ed853ac0c14b1da522d115217acc9482227e49684dbf6363a4666f837a13cc5b7d000561a5619149aa5a7d10d97fb6eeb3da54e0e5e5e86ad44f74a1677996f990762c81c800dab20c26686bb93687940e63ba4a769c3fdb93a71f33894f1d940edd8b3403808593dc2542366443c863f98aed4449086090b4abd169502d9db11f241abefe4ab5789f08fe3b81c169707cad2640cbf299f0f185ef8101c2ebf88a5b63764bd003d5f656a9aa29811e1af0fa3930b15f8559cb6a2345103c7e202abd6dc0424fe87a2d8dbd24efe6dc3e5644eea49322efdffb93461dc8dcf88a1976b02caab43d561892ffb2f4f4f14bd6db70be6929b523d16400cc32ba51b5b4ada0a0f74d1dcf78a05e3c7022f7f41bb0f56aca77697b72ac05baa636a9c6e4352becdbad2479e5f853049f6b01a0c1f8724f63b5f90c435185dfcde885b4d0d80ecafd2d4f4322266a7c383a66b8cec9ae5212bf2f5bddfc220cd0d5ab90a0f416e1e1b6de4ed04f7315abfc28618a119db9a4e0493637095a3613db01f6e613769310984ae359a4d18d222c8664515862e655b845a6822d84b5306148e5293657a29e0d2241eb9b85eb11434ab495e665f5483db05d8eb0c07d66890384aeef6531fcd115abffdef50fe72b129c63441bf209fd3a1a9effe052e8cccf4eba9df350e3fc03f9e7407ad3dc5fd88f0e9742474b9e9d0d18cd2d53b593017b7855d661b8de90d5aa2c3a21e9cce46e7edb8bd027e519ad03b9e531b800d260875633f2931c7884ee4c0a843f16fb8d0d7b53e98cd6aeb789bbad0ee9d563d427562e27316bdab744d90f283a61a9f5ae31a2fc354f28a70348c1f6ac3d4171edfe79afff69a6fd31facb6d2c172b7e4dd42f4237acf5b0dc1609ed5954997a67b1001917fde2041baea3c3338a0c5b2c4cb92b5c6da297cf8697048c1ef8b473f571983550ce44ce541141f99236435c354e73f6171ca44eabf204162bcd3598a79852d17dab28ff3d91f1016eb7231af8570d06350f8887b19f43b30fa3bcfbde0cdbd2b6dfab0b433bd0874d5d2e2b1b6b550e3f9b251cd9b2d345eb9fb880ae39b90f4e311a08f19bb5cac2d6c32c1ff301b1864c1351c89a2aff1270f3f99604018ccbb59a9be9454fead47ed470b98ff8e11a1940c29cac30b6b276c856cae98904271f0df6c6852823cce04aeaccae30baca52880ccce11f4af2abaaf5dee13f5989205c379a87edc7ba05994d62242585411ff2072794b3c8104cbe1ba4b2f2c863aa30ef10b54445b7db533b74df79483a2598f57b46dfcaa95dbeb5c4e3e42abe2b5b4f42e0d87b7520031a4b51610fb173c21fcbe299b35bba734922d310e7d85e06f0241ad7b8986dc111d69812a6b00e0be932bb9129d8a71c9c9da051fd3a1583ba7a088f8fe051238dc22a8bea4fe2f1fdfd7bacea4872e9fb06e59462f1883b74ab3fc09e5c166405b488778904a57659c0184c6bc031766e0ef84743248d3f6f5a1de865cd6d9ff0c6c8b105e432b3de2f10a79b41644dc674273d6d95e58201c4d6ab4aeb3b1ba85c7b0cb7bbaddfcb615843d6d653458aaad1833ebdd3afcae4085feccbeaf8c03ed71e9d11e090049133f0c05eef362c4ef7c1152bb3a98cb8b8e3d6b4d1acd72afd12b98324257fa74c11c3f8bc574a73c54a554ab5568654b662ced5c3a84be0eace91711faab2167606a6c379ff4070cc2d231a300687844da5812b3fd715a122cd666dbffd7c25bae5b109c276739dc4376d7e0f307ea454dac7ec4066e136bd3cd04b67b5840b9bb9e663b22872e0e999e4c2f1d631f57daba2b101f8a5ff60f4c4f9eb60b6ee0fa5e21d535cfbef087ea1af2e4febab77fb72e95c9a43292af0617f6c3c245acebe670462d4d3699cd46f502514ebb45d8d17c794d80e8d174057b8811a6cd388132f17804764f93a3a18f93ca92fbf964e3941fad806e1ceef658b8a9cc435be009753e39516f02a64b780a3b86f6ca36edcb59517707bf9073aae3f8cb3bc7c12dc043675bb212a67b0e022bd079120c42fb766dbb5f2e18fecb0382121c0e8ec2781c601c9a0e92a35abba952c6fc8eb6c4c21ff8165cff152d4e59ea8c43108a49c38c24f04d6e9d82408d86ac59c4d2c0d355b1d95f769f3a547221f0b49fdcdbef9e5b53f6b3878414c53747dae4aea7ead414ab1c891ce9f30d94c4350c42e0a1bfcda8572fcad0316c59ee287b56d1bee274ce68fc6ea2ea15cc5ca3e5c158001d52eb3a85d611f3a8420216da4b779b1631c3620cdf2ab275a280562ca67b6e4f7fe86f9b4bf9f915a660948e6bbbb92ffe7307a151b88d535874246cc486e5d754032f0e22c7e5151b00cb96e2fd173e5ef73e8c8f6188ec44b337c07a6ad0cb936bf9eb45ed220591a2b09588817aae3f225749fb940534a3545562e22e092bd3bbd5ff347e40e8eaab30aa34b1f4e6f57ce5ff5314b4bcd260a529800ccf3be5e611bfe653bfa7b5e7d5ec2e9ce2e4103d70847f67b9fd8b328c2e6065b1e1d00fe1fbceb748f73a385954887536568b398557937e12f09bcc07ed4d58ed0c1db0a8d6868ea76a57ddee470770c5c357b96e075091fd801757612acc546d95955ff13d6247928e7769284e864e9cb2a95c5c59cf6920503d0c8b405d1b2277a23bed4409252f312d70e16e2aab31ed0d6bad040e74fc5c1ab27091dc2db22c886950e470894f55fec2faa8e0e907815dc582fede07bfa2a0f05705f48a9256b5a126cac31035bbb26c829f488ad168f0325dffd350ea114aa0e07cb50e3ff591e04c21008c9e999c895d61c2781dad6fc555019096336f56ec2dee8dc60ac110f4eb968e2b0bef98e00c56770e7f3e354d7918e10e94874d17a4757125d703f1b4e3fdb17ce22c3e5831a94092211d8189759805da72c40dfd73e7dab6c2dd590100732aff6ec7ab4abaa319cb0e562129bc88aa5f2bb93160ae4bbd77faa5ab54cb9b67a5b4e8e40c8f4a42cd259d52a5df99c33202910355f2ac2d3573ec593ad9fc457fbfefdd200f593b0ea2e97a9609e289f3a5c4af229d8668e3d5f61304c0e541e82a9e905661884f64da435a6f2da718b5c30a997f6b7a8bf7290e94b43f5a234e2831af7d852bb5d086eeedcd1400f50876b0da23369e13efdbd9879ba12a077cf7faaf54181777ca1cab08245b3e07ae34127b331b9519531bf6a8e76b397d4472780ee5086f712cb963d7919f9179d3bf646ad8cec0384f93544005fde9b5dd9a0ed9572dcedef2f9bfaf70e644fe97bad40dfa962534fab6549910429a84c041d360d7238e8a3a517e3c49c6f88de36b07245366a13859d0c8488911f1d372b2d94190db6b7b8edcacc93482dc761b7d6b40c5ae3eaf012e1dd68ec2fef0203a5f68044e637f6fc46b6f86b129dbcf94f3b9f160a4a39180c907984c0a68db1d54c45bbef30366eda9e8460ffa1c663df26ab15297ad7f3235a22872ca5167970e44461903f93c90835e518925141f687ac20a06e6c4dd262d49476870408c81b59f1a526ad0c6c01196a1a64c4b3a4333e115064324a3442db31599a4821f2061963c51668bb1ee14340a039defa9f99ad3ecc84405690f927be4f93dd6e6510175d0815f00469752008aacc4d9b9f9451588f315241ff395e24daa8132f65cc5a2e8006604f55479cae0c3f18773bd6fbef87eee8176b03a8c975499cc5c364641e2840e7330fe9f60258cb01b5ef65f1c0993424f06c47a68750110313108bd92f3b780378704b590937e46c56fcb88f067e97dbf9fadd65af61a537bb6cac25ffe750acc727d17b4aca0df168e5e24b8fcb6636b000b3234bb2672f1c538ddb8e925be32ef8ecc3da6adb1e8c46066b8c4b07ea00b8059a4ac6ff8c7691876b0a492a123aaa50580876ee40c2da9cf3b9e793e6b7def53df408d205dc4ea7a3e213375ff686c37b632c9f629a965c8a58c4caf93345a5de53caba85fb39d1869f9d548006cfe5d7b36a25e9f1699d9ffdbcc7757a1011cf15fe299b34b92d682662a48ba593dd57163bcb760a78897ce91c522a9132f96a9470ef9e9d66a06e3823b35d63165c9fd33b1bc4fe0fb78eaa20ffb6cd79bb4cbb1adab9d8eaa8028ddde9945a32c568681f44d44895187ec48a5594cc5359cfdaf769e2757cb3860dba8258d2d2825cc26e7e76803ab3e571f97c24e36e349082c364349356548ae29a521da7935dbb3e2e861463faf5fa426841f12535a6d0f319265ef8a720ecda5a27f8e49c2143b7db1fd4cebcd6252bff7f264e66289684c7382ab70b39b8e5148f3801a06d507a4ee1acf70ab5c1ca2585735f7ccedbfdc1e7c1227b12669827a6446577f0ac4afaac5ecbc72d9d74dd4eb0d6969b985e9b2ca077156efe116ceac560e125ee3370ef27c913b2ec790bf709f5b9b81db8f84fa24c5bde3c636adb1d8604dbe867800fb73306bbdc068e945ea9c75249313930ffd22343143f670745ccb2030bf86ab63f624f6cae146962dd57770be83db485d330744c3c6a1d3b4b3ccf980c79e8d20c61ee771394941a255f90ed7c06e57aa6164b99a7a78abb7f7906a53898039caea44f592c971df8d386328576a6d6ee8d8ae976f73761564451cceebd61113754904cb070650a70e0fc2e364cdc0ad3ba237999542152925ba3fadc1b01dac0d3a1f1863fb6dd7e9bf5ec2327cfc71ab5104eb42f6219261723c68c694ab8a7301cdff466f813cd2b69c31ab44feb222dcff816c707b6b4e4fbae1496a00b77cb4cc301511537b9613a9e0cd65a9b20a581abc1627706f34bd2cdc65858c01992ae9c26b082e0bbeba26bb1b7292f7cf4d0476d1490511c5333176c360176ded6becc46ad92b5dbb94e24afef30214a17db31b2ae8d027cf0c45ecf62ae1f726d7705828f9de4ccb60f6c8a12c5cb75775a4f27823f2334d95709d01a274c50032bbeed68575567f03d1038b88ce4a47fd10e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
