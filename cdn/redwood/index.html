<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8b3166ace0befb49235088314a5309940d5607add4cfae0ad3e70fd1376bad2f4dfa754e954ea759c19f56c368cbb4d85c53074347511e767367320bf25590d9ec6f0d146b8caa0f6ab2356e35f3f70792c86aba1447801c9c790b3760f83247bf215bb36cea5b865334bbc2157ad5c33c8540bef623a6336fa7ec3aee3a9abc40888361378a5f3cbcaef27e52ba0f8961d59eae0ccb3e52288ba919efb000f9a45052f82cbdab53743f69ac41b04ab064059b02677bc544820d58f7b6494bfa1e16869a3157a31805a25c2e81091c341aa1d6af7d1ff8dc75e4919f6b18404ccf720b1eaa7e992c1ace124ac005766832da1b4e2f81e5f4d589f11cf5266b9522b985086f5a1730f055ed65c589c2f821844ab6cb17aee161db3429183695a40c24ce5eeb444c5d105ec62d76b95f6ac9236fa8ac581187831116f898d36bc45aeaf2a05185fe64066f91419b939a4dc59fdf43d9ddac04c37d14765d3ef9c50b290fc1c74fea4dcb861a916669e9330e3474f8b91dca7b62c6d83b23d0899a13eafe89ae4a00e9539229b3d84ea04a5810588d3418cff192d585157213e2614ce478822263101f23cd028486e7b3de56ef9209537519ed5b2631c99ea125177eaf87be3d840cc0d28a9911b0bc9b0ab8c422042d9a57e1a6ae79fd251a7ae3bf416eb2c33a7e2689cb2a521e6bfb1ad4216bbdc45fcb993d8cec44590092b0622dc0f8a27e4ed5867eb2f3b28ea5a339d4f30b40af7f1907833fc8e5c204a621c8b366805778d735e9bebe6de5d44659d6f6cbce85760acf35730ed9282ddbccfa210794cdf74e1301c4cc0d168ce76aa690299be89ad1e60fc5b24039820ee39970bdaa53d2929618326cb64e9a183e222862e1a0648cea01828159d7de7b6e6bab449a7ea316d2eeab5e3a3f93f6eaade380776b881ce70cafcf7d41d8135810d4905c657394c356ad462dc1de9b0e79fb2b890c53638b902dc19179d08415573cf5583ec0020e8c0d470dc4c0f531794a4a2b383ea3b4e995a793c68c74b2a7fc96bd1bcf8dfdf6e70669bd55f44848383ac22b89f5ebe6309d8cb3cc93f780ec8bc766a654d073feb901f1046d343ac7ba35386e90c177c428d0aeacf6e60a2ba83773beb61dda23a5c09f0eaf939f6e00d7e2dbad9ed35a292ba9007f933afc8cb5554d421b0a187099d40668a57212839d49ef80ad18d769b7100703a5626c18575c6b9b76015e6f2118c3d79ab086c567b5d25eed90e64d5a8e3f06ce65fa135a74717855517d14ee5196927924b07aff19f324543f99bca6b581b45a4f77bd75f70f8f44fa3f41b9132a8aa9ab39872cb5c8e9faacdeb2afb751a44ce175dbaa683a60678b38cd5b6b70f4fd0da4830c37c97053fe17dcc7c06697f24682d434e03773b90aa9deb1be18b84569be9cf32b7d8feed7b070402462728e7b946e52bf6a72b9821d199dd401186ce3bbeb5609f3e0368eb82b8f6b8b8401735eb1a23b8bcceab0ed674b2d6130707c6c26fc89953cb1222c385af270db8d338e923ce100810d44e767becc9a54707a0edf3b54ec68dbeaae9e012b01ded75f332c9c91db5b5fc2761706e550bc79f543816301b525f9c1bda12d03a335c0c685efa2c05a216b5d682f1fa368a7728e3b4efeb47982a1e522a8ffb1730ece05c3dd89ff37b7423e18bd5e2be776066ebeed03df5f80e5fcc4e427287f4bbd65bd5d5f63fd6dae8f420dd6459100a174d604da639928a8f0a4ee181ad8a61f2846a5f050cec25b5a83ff5605ee2c4bb0061b20bb579fc7e1a7fa14644422c0b8e46f6f00471541f08a20bf162480dab4868dd85a8f642afd0704f51bb22b04af333ce7b157fc6c0cae4f3ff44d82ee021da257abba06ee4a612dffc41a71c5a88aaa87ed7ff31a577eb4ad6d33f316de69db423cebabfd12e13a0eb352a937bf792b8a73284bdc9d69b6966c90490f4a87af3e9f79dfb28e11e0ab692821535c7cbb8e07feacf1d18102259427b05c5e863ce02c0b9eaceeecf4559ecb1a4cafc7265ebd06b2453e0023b3c969067786a11668a5407b55d83d52d6047ccc8cfad7d7b94b1e3237e9f5cf7d111c348f1cc3ed59d716fa2666196233c3911ce7bd635af12a76569ea0983407b0aed18a23290a995a9940a4472cf00b7493c1dbd11fa6980cd33c626b71b7196399c7c3ce526f02b377a28c857c3f7a21292ab3efc2b983ccf63d5df421785e9408f8865e7bf26e238c9d410c1d321b68b52fa870ee6362fdbdb9efa1051be850ce3787c2575ffe2a685b6777d5868a6364e96295a6837d18c8f94509e3ea4a52eadaa90be72e07553d37a179f29a0cff74ea41b730260125adf7570323c678003e0d719876c8a7a4f3b35ca8d3f37514261310b8b92d2e03a8ea46f02bc81176ba3341587ef62d6361bf8d84234548be9a1e24063019928a650fc15e26e4096bb89d2e9e0259eefb65a4e5603b485edce17986a50a51658bafb75c890fc7aed1e301390616d3eac458b1dee1ad8e182c1fba8df4f48b40ab5cbbb257f57fccc8604011173d4f21cc66873c647eeb0259ed19ca86f65c57f859cec35b636e08446134e42e881c3e8c849a4230b40ab7fc271c75113d9646f1c490d234698fb10eefc7cf4a635da254a59743b0704b58454517fd4f3f61fb4e1bea7caef959af5e8d247e59b37343650716121b429fc69dab8815f8a27c9247e5bbb5bf9247bd7bcd0438aba788d2f810ac186abe02190b8170319f4b634ad89b938a4271e2054575828891aa55b2926af220fdd967a31ab63e12b9aec0bd0c9ed3ca499a80981bada5693fe3ec5e66c7e5188d524ed762bad23dcf38a337cbf726e36f6a0274053209fc3842b985eb832de44a3ea13d672a9e81e035a1c0b1839dc8e274d32d95fd1a51b66ac3fcadd8fe70ec530be658af43c511b9f13deee23d34acc25a05fda7df115fbfd9aa39522a4ffd5616333167425943f92d89fe44ed6f52480dd45fad98b586e63c930760b162480f7b2d4dc6efe404b722081c0780aa468ecba5feeb04e04d0bba74de2c42b8a5a2e1d6ed89f926721f616a6645bb4c4a7843e84f7a36762873b0a0a8d8e2258dd91549aef4e336fff99afcd7a2e2c952dc23c513953a4e8356b9f2bb5e0866e94d1165d33161bcb03e2a2272cfd259954737fbedc8c9fcadf88d0a4700bb7effb8c75e4df4b21aecdb4c597828a812b8935783d8ce6b4f67aaa5b43e8b839d44cfc8a145205f8af85eff89543e86956b75f3f8a74dd7e74d4823a82cc47366e8ef7cbe72126ab3f3cb61f3d81d42b6a08289a50b4cfad1803deaddfa46b50f224e11604f6d70ab7eab2be94725e690a313793e08ec8d5eca6c466518b3b7eed4a7365b2040dc5b05a506cb6cfd54afdff40a0d1e8ec4603c9cf1a376dde8b61bfde5df2cd961f266ad7510634b010c313c7500f5ade7a453ba3515f50eb2606867310d6f61d8787d41e739732ac04dd2d15abcc86eb11deba23d33d5d038c0f8c4def1cc6f59e954c410a18bfb708e59fb809ceb6134610fcddebbe0c2c1a8b8f7bda1808990397c3b0432e84180020dafda94a11bf197c4d4b3f6692411894e1d3411654b1bdc4a3806c03f40c642ef8bab12d0b85048594bb07b0de234d8b227fec9fb609f19bb20782224c0ea84d8a9f3e1da65d46096f5c2fb13150c93841fa8ac0e8b9c2b460c5e02bf600f4fb13090b5d4c13bfd2be910d6896321c874d85cda44fbe6b4f8e0fe6bd0be73ef186f67b4ffb8ea787372dcca7eb28ead154b67e624af3799a0c41f33671bd86948b99acfb5a3b64ac99eaf4d1627f2bc2a275c59ebd4f636bc64d2c76b236106a8f5b4cd29a9032593c36a92ba15eb2098dbc877a41790b9453c7bef19feeda258d4107f4b3c2b4158cebb2092801b47fb0ca899b13f71ea353ea8069e6eebc11d5bcca5a1d6f87a3fa43257e38684d8060525a9ea0caf4f1b8883599ce656911d777553e7ed38312ef232bc51f404a5b31f767eca2cb1671c76f422280b3ee6d3bc6b3794de3c05a55843c421a0ec487c69289f3868859ae588f6ea3db67b781660e6dcd616afd0d5f5bedd37650b989608bc5aa47a741ad54c9ec273e4dc22100b4dbe215e294e81b275e1f14e2eef9e94093932b7041008e65753c94c975519f589bc3d008d9b846ffa07e046251dad81b378fc9d1de6c6cac7c4986e021fc7e4fa51e06fff6dbc987629afe591f3ab90646d5a7ecf753598141b8b4913a840fdc77f5c4ba3301170b24047d8d413417239bf45972a0fd4feccd8ebdb04affda84b321d9582c74a1a7b77f00e4cb4444b8a56a60d05bb74365855289937020832879bd9d620b816faeaa595fec6a9f7db2e810a9414f1d823b777f48fdc2c446701e38457164f98d4e87ce6d2f53119854e5e5b867c08906bbe4328ad2e560b576b5ced33c5405db00ef2d74acf8b3c7f1be4658efb09add28e8ce4fcc2d0c2b774a78b25ce84774c21b4341df22e501921877648fe905f8107cd47303e50d84776d9e61d8602bae4c31f1fecab7c6f95448b47260463c129ee96986e005013698eea331a9febe4c9e1ee07bf78f2c6cfa13583b3ed9b9ada0a5fd7dd2ef8a4ad3610c045cad8f5824fa9c3eb0c2b98568519e8eabc3410d3c6161897d7f3cc53091ec04c0b9d4daf596baa89ad5f3c51249eebece55d6c3fa875201801bf0f00b915fe85c40d3bd734fca3744a6a6b4a8be11859cc81cdef47d2cbd2265580632a543939bb176a4d6702c38a0387854c1beb1d6b2f72459e0ac0d6c00ba287c7fbc0d4512b202ecbe3cd45cd8850536f45b5c04b3b787ff67d4cc94c39c8d57ab940b4f73b4b399540148ff4c25d6282fd9ae355dfc43bb7d1314a2cf01a44f941d18f88ff448b80d618b1ba131d42875a1970fa389b8b5f745ea36aaecbe524cdb42ab0d945189fc1e85e4bb3db3c12994ed3604c371bf6b76b3b6378597ead908383cb49578733c28f8ecb1e6bb4597bc8e189a85d618f38d5e51e661c07e8be9c4ae96c8b65d896c210820964a1d337d08ec33523f89496e8e9a730628e8defb6984933b1a14d711c6c0b4ef7d8227388bdc29a6b4a7ca4c347d238808e6af13ff7a90fcc2768ac122084208bdd92de9dad656362eb392ef3e21a8bd465ed00c9cfc3fc9e2f8b1432e1a4d229ebb0139dd0e76cf2ad3d0fb733d0fed70ea2ff55fe3f1fe8c36954f85c99f18f0c8e2abe2a21706473c55a551ae1e4fcda7c1e371f8c21073670f153922c1829c511548af57ceb486d75b1ce7fa9df5219ed9abfbc182a73018abd41d5baffc4f24ddae6a1e2ec9fe074456a387bc05903e677051e11365eb1ab998499fe24ef235e97de369ab26c6e052705f2714564c155f2931f3289a0ba631b3b49c6d944882231f7ffb3b0c3711fdebf3187b85ea953f721ef3e380648c987c1c1115fc3beb26bf37f32da871e182dab50cef5780568c9442f98be2e6c78dadfeacfd756524d0fc3b4bc5e6849f7372fa87ec5cb9edb4ff4bc9bfd1568d2e994231a6c54d0164faecb99dd4aceec44e532fb8ae5dd8b4c534acaddc950f090b1bfeef7ee80a0041a5d307f0f2e8c2107fc1c0d5abd454573a1bbddaed9e84c7b776610459fba32114bb4b3cc77c7420ede6cfbe54b16909557584c692ee342ca9b38a9dd1642081cfa97939c4528464a9126b479409f6e3dcae4611b44d8fb593796e184c076cf701c7220d6fc2e375989777784ea8df5c98ff0e45ffaac5fd6a8d239bd75426b0729711f93bd6fcf0766a543b64b43183a2b36d35fccaecb615c7b7d1eeaa7884c51d269f6602420dba86e363d300a3ad08c989d747424e2bd9defd7f4daf5533f94ef72389ed9839e9dbaac0efe9bddf94f9b81d2fb6e410a8e3cbf867db8751e4a68d5e3f1464989d67104177e207c8fc9792c5f01a48bf627ecfd1048fe8772dbe739771f9075499c1cf88c82f1182c4de7d2d4b3841d4e4d7e8aac900bc51d86bc3879f1259dce6afc27f53bad6b64cb3dc58a59bc3b153cb3a4b4a7a6f610a0ea64c9ed79d4c8e2d448fef95fdbb23babab514a554158b3c30f00ce2b58531255c3ad1561911de86e5afc652732f82a79a6bdf0a3afe47f6669cb2350dfab95d0bba3c54b3415e27f8e08024ad4e59eca4ba1c7df1ce58b5b89ebad1b0e44e00afd227037d4b1cd950460efe80e1c3ac1c507a49a544dcb073f1a3a7f2d1b5d06350da66cd7e100504979efe28a603b280ee634053b184f0c4c7ea392f2641288f89ed904dd04615b26888b52f4135e9e69a2b7dab1111bbd19ced99bd7c5a1d33b84cfc2ebf1e05047dfc04714159f960cda845eaa188de4e9d2fcabc385e58ce584fc23c33bcf7066abfc7de65de928f1065c8e49ab4f7a78d437913834c62b1cdca44c008f02981b6ff46345050c7418058fd43203b0adfb1ea129b5ffe68b17422cf97a0df6fffa38d06b87b39d53c0addb99e79dbf2c2691f348160e7ec20ec642461cdf88c59b24774a493dcaf1b59e51a04b97ebfc3b7cd54e5ac8cd8b20c0b8f56f3f3930aa7b37e57a222999bad55bd05f7306bf7e7a45652f801b41f87e9413f7ae151b3cc28467beb7ac4038433a8d6e022d74aa5ce71fe40d5b9f8514af3a69e671762153ce6591d2e0ac33401c3957dad876692f87e9431b274f128f013b31ff44ba81308f2226f84934ff7967afb1ee803810974adca8dc0a35b051296a64ed746d383fbceb486c21760f42598873d8a57b21b775b75f76fc40189c7426708859979569169b9cde9b12bfacaafa50e51b23b46b1eb6de71b48b46ea6d9135cdb2e20046b8ad54d176719b1eb0f7234452005113a085853dbf8f8dbc05bff6fbabeefcd5f9fd894ece2e517e3fd86b0cff176bbefb41a040baac11b713b69ac07dbdb1f60f2563b5153c2e64efc4e909ab3763aee7f9add18656e0ff415ae0d47789204c866b9cf1bd5d291fe75c0800ee6b17c009dcd3989cbf12a5d0e76b158e224ab0a42fffb82927167dd3fdec1292e2cbb51848d111f8149b48694d7446ace1c7e7055fb5cfb91590d23fae4347053401a6b6b05adee86c4063cbb710a82092cfed1ef553e734cebc511688faa60ec6ea5220d61cb144dd7ce4eb1c2311ca9c575cda64171021518822d938bd410197f86a057dbc232c5fbe7bb0d8cbedfb55161f5a0c93cdc3900035e309152f1e0fcbf3a44028dc70dd3882715e17b30085a1bc8935d07e7504165a67be598cfc682357894ceb207f9cb1e79121b332c93aa09704f4b435f1059f67aac49aed304b3581751ad0f9063acdc49f9807293d57ef7017e1cdf680fa40e3be726124363ffc2e5e3196510f10b6e4344b10f6bdd22803ca77bc83188427085585f025b642aa46781cb4db1c7df4de7269c1fd0fb70fdfe628086d118385d8e03a6b15954501950fb0694804cbb7abdaf94e0bdf4195dda7a68898230c1ad8c47472271fe6a618294f5d912a6dd2a3c846dc16a0ed15035123e0d9a27d43d58d648755e713a3fbd1db8085206492384bc76e2befb3ff637e66c0425f6d3b26b84eb7bae73cbe63cecc3f1f809069dd6fa4676bbe086e071da109969775820e523a9331fc9a48b6c5850b15f2f08fe5ed6ae645b3117583d05c4879f45a477d3b62f271a87c8e746d72039e1887f58cf22fa204f62eaefd9b1c8c73c90f660fac8df5cea2a80e5571c6a60196136b0ddd3dd2d24c2ffb85960e95f7b5684ff52270752b3d01061512d419536a205c1ce92f8e8f076249df66c84ea3d388b92f0f41cfbbf7e140213e80ae7aae99173125b1edecc98719ab0a7037c6c4378b7505c3427386459c4a76bd360cdba40c70627d8ea7e21d16cccb1b19d6074a6129c9eb75f1ca57e2640e31c6a6acac1b76a2c6c4594fa20752a65cadc1fe41435088132eaa723b2f1d26268b4005c50ace553f90d4854175752c9b81b7f191bb569a81f25a5cb63454e41070c200300482dd6545390b5ff32cc258f09377e4d4196d6aab12a3d902b994df00040b394aadeb1451ab2eecc37aa04cefab357617e23bb34948a126121eeb3f39b26cb6c0fa8ccde06e03611273cb00846a5d7ab20975ee6f3d031bd5f62c2f17d7f5a57b1210a0a97ed4259a0725a6968e3e4f44e81c9b78c4220b4f314399bb404b807979b0a1481438913fe6569ad76b49c0ec058e65ffb25883f5b012eed03a4ad288467bc5e8d4e4986826594397accdda7a0cc3a8d64ba0e59574f5787249dfee4b8f28de6359ab7f8eb523b42a0c2011fe3deeb5482602d2a1102e8483a91a1375ec8e54f1abd0b794b791a3d01d5bf34184ef89813cff0201cc710e761e23b8c6084df16eb3326c7dd80d17004421502c3dbfdd9e12337ce9ca9631ec26dbc05e067314c25e50fdc8bc5c1e748445bbb7eb4d405eb0a6c476f16bcfb6dc9d05b06c91bc7d2a8be8bb63bf2f846c0490100a0f2baa74471c172853f3b3054e1034cd37718e3fef274a8f0f2cd7174065e8eff704bcd7a458f877374235c263cf98e8dd9fbbdf5b4902ec12e986cdfaf4c6d818e309e9c737ac2ab4ec4047edfa3635f431b89dc3bd7fe505a66e808fc8f50cd4d7838044f9c8df0a693d30f52d459c59af08765905be29052a607e2b1aa93024682a335fbc9fba000c14da718ef8bfd5a80a59289cd5426dbea6df58a4c99ef57b70030b2005f2e7a5aec03d9abdf6fd11815e0f1e8191fad04f5a516fa7a3da3ad66f999af93eaa588c66dc09e79d4b5fadc17c12533ec1a0005c8495e65b19cd9851a4db1188164b81ad97399448d7e22e1431831a5b09e8c07aa90381da8cd24a8a9bf44281ecfa4a833be31c911c113a5c4d71b19fc3108cd32083e0f454a8fa73377e7f6af45b916465c546b3601f675fc8c8cf4bc3ea0b13eebb1a2ecf37a3572b9f44a4c3b37879b317f66a2bf2cf35593c863f92dbade2506ce702c7056749c96e2336f4b5211c3756ca81a1e2fef18efb0fe07cbf882777e161889eb06f799e949b77e75fb7d0989ad616c463008abb26ce39626750b7b9cb380e590efbccb8b094a2066ef46c46cc7f0e1ad33952814dae933cf6541daa0c937e0505c54976365a9ae77bb1f5b2b1b60285d8c55adf7be4b34801ef39cc2b8055685243c52f2d00cda2da3a100aa32e04649e529a3d0ff2fdec7f062f0229d7c39c378bf43a9aecbaf6d0ba74fe1254e40bdd098fbe35034fda2ede7a6a14b3ab0654641f122cc2a5587cdb24860a8eb2f87d1d6737059e96fb41852c94e67ce22bd0c024adab4c9f171bb69e7d52a34bad784a098b171a5969e08677ca4dba2840b56b7ba9fa4f7f3f7fb757a5162bd93a8d6a59a53248c9401c415d8250ad8e40460186e5ea3983079ec78b66c8d962f5aa74ddfd38514b8a21483005d55db3868d7b10f269fbc67c9f75ed17d974556c3651413524485ba5617f41c74987cd9ccffae091bd2b462d605fc4afb319b5b4222ee28fa18df4e2168ff449d05ffe2b1b02a3515e55eceb69c633b4a69a15c64e8e9d8447514f0582548330e899ee33a5eab2fff41031dcb64321740005124b2084cea759139cef157b2314aa8c9069e8752621f311e924ec59df5367b12442601cd36869ae1be9489426ec7f26904d70dd7e38319e6c1f2056742fcf614a13f5a5c78ec8a2c6d95d6e78749430087a3171953903e3b7ec97fe1048a40dc2be4eba17c8bcead951d9c2190a4416a5a529752302f0b0f3a12600ef230a1cc82e4292cb870d09f13eba8f3e26686fcfef6d1cc7529bccd98f0a34f80a017f733818184c365f8adb265dc2c11d69b9781501d8c39ea00bec2ae919a4c58fb807ab258a4c00ad8ec240286b8243e3042aab96fbf601acccab9fac4bca108793aa3affd53ab1136f9c5571c02b6778a9c49cf84d9192cc114f6ed52aa9e6b365b860e868ef4de3596843f1833e5b20fa86eb866a5ba4064c87483dffcd0588303545bdad08d8d5498f556a4b1159cddfe5b3bc73cf3b513653f1e798b816d9b91a442a7b43f3091527f75cff11f959f2e1bb0f215e9729549cf54479d01348507640217f486608ee1be7a4c3082d8bfc5b9253a8b0b64e2f955e8f2c6ffa6a8a9a851eba11086aef0531abe387ead099d026c160466fe8255a931a59f4d43bf6688561026ac27af0c79d191a76a18a7def9adc9bacea963d283d0956510343c12f5041560ac5bcc948c0c1898e83fcf0d06c705051b78f7cbbd8bfb02b24f206f0d102a639f37f2229c593e16e11ebaffa9fff43f1be87fb05c120447bdd03bbe7c7ec795a852075b6e3ae15784176040e4dfa282fc3521af25ea0d8ee829012ab5c49ccce84b26192bdc7370dddc6db3a7eec873b257f0d297deb029edee5f5b70aab354c3e2926cbca5c1e1ceae668ea022f879441d3af9eb71cfcefb74e5c784a1bf6d5d31ab3d825487f0be2abe7f0511af2e1c6dc95d60900bfabde5e6b4f26f7a45c09d35cfa4c4c3da723d3686fb393e9da784099d94f3ee7e77c476cbd8766796d9c925c4042f09afb93195f7d537e9825f63f9370662080608cc436547cf24dc06f8072f9f0f1ab835235638a4368d2105b95fbdb034f3fa20b0d649febf841266df5e6b33d4c7aaa8f1cf783c0d9a563c5792f5e0a6d2805d52c2e190d2197650ee0e6de51ea7171d8ad27b993fdb1a2d7de2de4bd90a536e6ee269f4138cb69afd2ef964bccb924bc2886f795beeb31814204c901d117e2ce1e001503ee17f185ce80e4cd9df2befaf0edb8cab6bf7c6160857c3aba353bf8e93f8340ce23add9c890365023b8f163bc5b52fe2a9bb35396f9bdb0de18388cc51732f72a260dd942554f8aba68b52d6dab85b8dfc5400edf7e03f9e426aed6caabf51b219544c1bbb8b68be75395cbfaa822984199c6720f6cd0da6dd417311da3973090721a91c201ba6a9467c790bbb765b615b3232345e623556b04874cccb092b5a3200f072833beace210d111add0f15e3809df18c82f84c167267005c6ca233fd72384100bc84deeffd73e94536a291dd20fce8f3a3d3721e13fc17937aa388e7b388d843ff27c0229e7156bf1e377b12c39b94f5f4696bdf08de8ba6bb1a9125955a70daa3650b40cf21b2cf1e4627a2cb3647600d2af6dff6bc7671a620ebfdd356326bb1ff95bf31a2a34049c871c5be94fcdb3af4c9ddb9d3c993cd819a15060a13bbf382b7dcf71f199aaf9c8c98b201e7668f28d60118d657da74ff486a4fe06039398fbe6de303e18d2168d85cbc6c019cb2d8e18ef802f1f57cf349227fa2e12176837c5cf8b9857e4d615cfdee38cc3400995d3c7de16f22ff45762a82ac6f4b17fa80298722d282de1e5c94b7e35ed79a67606d4ba1d9121d41eef7fcc2f9863034f455e281ab5dcdf03b7b57d81b5eea5b381c49df674082dd8b437304c6f6165ab70f343e45595eb17cbdb387aac6f154736ebade1b0a1832e7d8ea95224aaff10db89d29cc5744ca856d97fad445e7145afd1691c3e22a254de7567453aae24c62ee7682fe61993fa9abfb5fdce93ea9050841d795bbedf1fd7fead611966662f6ac36fff95371baaa17c22ea2098f74f93280f68b5cc69e885d49e4e1b535adb206b4334e2e5e400695d510e84a8c0ded10a4d48700021271d153c466377c36bf51fa1d62fe56812e1a1ce55c65d228876045913bc36f98ebe876033fcc51fef392b9168713b386f4c5e2a78410492a311277b8bc54f3a3d8f14c7d0a4b9fec49d0fc7f69e1be7e90e507b620bc9f0a3fdd757a4b4211bbac6064f32dc2803adbc786313b19d38d857c74c7c1607cbe24c2f7930d1a365ee3a0bbe10eb670b0560683030a8106c2da2aece575ccf0691cccaae0a6d2cd559207aebcb6499672268901c3592e5cecef31646007d79f6e6517e4a53d3aeb64d3fdd28a10e3a5e2cb2e4ba6b33bcc2a650871405e6c131d0c00a188d6b81f6225ce3c2335f33911e3f4bfa1802ab38a622795cf68be6e2789bec048e3d46e7c8a74d006543f926184a51da11a10418e182660d4af645d33f17d28747144df610275db7759e5409883e89cfdb1ded6880b63f15f0e88666ff53527a1a41e2aac64e23d599169873e298addbc4a7371cadf253a39066ca381273a50cb48110aae6eff1e0e89e94eb9732fda5c87695c3015f74d9d1558a331129c05f3555f1a0cbc7e2b562232eb5a0f244857c1829cdcc9b0fd1f8638fddf19b1af43c7cda534076515405861edf80908e32169b3f506205f63f1c201488f72e845325f6f9f5e65fed30d37b0989ee9cd19e3e7cea115cbe1c6e86e28b6178af59d18b0a64179b443f0b6340bab7170c8deaca0d472610d9f053d799fdb33b85649c67aece43d508c269dc22ab1f7de534d88ebf94a5c338df5ec0bea3ae3cd668997070fe71b9f8e79ac1b8a07d63152f4994a814bd6808ebc6db4351a038297b9923f25f02951d3c3b014966e44483a613ac1ba0d54d57d616e299ddf3b4c38306cdba696498ee2863572643e5b6ddf5cfe4545cafd6f369d6f44cd2a2eb59ddbbc3e24e9050596fb263cfb37a1f293094afdddfb90922ea937ebff4760b314935b391ebc9f459f9d1d6f7f9661f60ab040dbabb690dbba86d476fc95bc92f31a71d81588268f6f1ec8915d51c0e20747616a98dbac9a58546df45d5bb6befc98ea0e0f4f4bb69885e4d322a7179dbf99c8b8b78d47567e0b3b306e1040bba9500ee8863f292db9940314764076507d43dc98ab6c6b1fbd7d7a1f868bd09b8efd9cf5234b4d9a3215f4e891e730409c02a0df20ccd7fc4a311e017a35b947745aa173f23a70f4d21f84ad9742d0ddc6109db83e15f93f1ce0f48a8fcd67ec47eda7306c02c95cd9be9027fc8f794a5c99f455066359bc9ba1813d4606e35e168b4e8ff79f321a7aac3b112fc7d77829453218fdaf82683fcae25980781c5b59e2aa08a0ed61a04ca6d272a32188f10d1ebaca142182a9990038b8be89f395b7c07f72e68b45f51861849aad1acb5387af5a0ee210c3984fe03367d2526c5dd1629fef6b1a0a57957a4dc1b2ac405fa161cb574963430c048964b6733fa107f9d4a76f1950234df0bb320de091cad66afa318e0bff664c30f7b6bad604424dd901aa05f1e6a8153bbeab161608adc1394586c39b6742f1336dbbf2d8ec544304e72de6fc8e94da7e52f4457d34cb5d30cf5db3a7de480aa770a15bf5ad39772d1327af5550b9f9dfe47c5d6cfc4a09f497aaf6d892c64e832213bad9f99a9a699f3440be7bed9cb6f9d48285242f07fbbd38cdfeeab4606f452c8bfef4cee3ca04b579cb14aaec3f1b345a18bd5e37decc8fd81042ab4e321b966bb429446ca1e010408b9ccd51e85eea0e2923165b377e81ce88723a6c228c04d4931d28d6b7c5f1a3281ac589b7ea0a08041288633b962a90238346fb960f9114c497c2b2fa6cd479184a0ba92d3416a08457361f841351fefc6f9a44c4bc5782f4fe26c77a70edf5fa43cdcfc03349741d871a04370fa0403c25b801cdd5ec0e2a0bc28e00822725afe25422b55a30ffa359fc051d9f37df9a96c4b18be774c3bb43bc2cba79e52710045499511b23a2f5f153356b0ddd942a9a4b2d3572b92ef06c1eec4433bb9eead6977f0a6c69219c0719c07e5650d3d1f348b25687ecf3c9c2a420e216f3bd34b1c74a51b7cf017dccf6772c5765aa0b7eeaa6e625990eb76b50c432636a0ad450935049dc2a856019135d302e17b58b63e18d153ea128912adb8fe6c3d28b812adaa6cf5c6fd3eabf559fc87168183136381eca12d54def18acde0d325925707047b0a587cf23f04d1de8b8f0d0764843484af6759d75d4218b3fa65c3c5abca6b2f7d23b31bd96adc3d5db0636856c050172ece18d869d651bbfa18e27c8f559a56bb7a15a98937f51492e879fded57eb781e20be16e54cee4402cadc93bd60fc6224a864a69aed69f7282123826baaa1697a14c56f6171635f3233f918b811fe864c0f5f79f887934179fdb99f0cc73d83ba048938adc4abba4230a5052c8920f9fb3ca7f86506d8844724064838b4466e6b12cbeb1371299c4bc81923e0b18fe7b18497008890cf9ba8982cc89a8f37dec53682385c34042a9a8e21cd3de1c5a0ee48e9ef44f0c60c6e843a39bbe73d2dcc243ee71b2307c39fcd4597a374455a1c07bdb03ae3f14a5dddb308613bb1b77d51c2e1f6ba9e16c2a2165b43456cc21f6dc87000147df77d46ef067535f2de9ffb92d76f43393bb86c88edb1e824982631685b0b13ff63f7e8f22600feca66419d40f749b58800bf3b93daa471370a5fa59b071f45b10d674d0029e1acddbe0a741d1d36cbf10b39d737836c0765e3dd14524056adb26543614d6fb238927e20142e267d3ca544d81a2983813f6265d39675aa7153bfde6d2eae6745c042d7b85c24b975303b931b8f943003169ba50e523cd08eff79cf29f54c0cffe569ebf293d2a5b8011a1dffcc23048b473173dabf8b12690b4495d59082deffe2a928896cd7badc86529c40514f02c8f801fb5247f2ddab801e64d719791707174e793b120f8f80bccdfc24743014623509158b175aace27ef906b167fbd11acbd044fbc5a020b506feef8345ea6edd2ad9c7d66977a35d3de0fd42a23d41b3865f1f004a1b1a804666d86eedf8700948576259223485c9864ca74ffb26fc3e3ac75ad00e0ea014f11e8fc3b9692f7a6e706105a3c89bbd0f58f0ff7aa4c37ce032f750680c7ec03e410e8d4a4b0a7832445d91da6dad86897a01423531558ef42a5dc97df01d6f1f9a181abfe7657a5dfd7ba3f8d385a3c85620fbaca6c1749a4681474cb6d8206133d2733b1fd0e815329265ec90244a96fab8615e89228760cb7e797acf184ad083cbe4fd273cbe6d125e9175cd8f70e7b29b49cc8edea33f76737e096ec658b482f73dcf75287f09d128e6c0fc4f5c9e404a5ae326c2ec30ec9928d4eb6f8236b4a3e3bfe5796b930efcce1239a29a1793cc1f2a5204e9e53dc3d2dd13aa721703a4ab6886ce4251bda3a257180579401f8cb9d2ed440b979062113f8ad52ee40dd8dc710c87fd0e65938ad7047702cb356df4e70778c28a9bba2f97f7319dbcc9e5a53eea1b8ff8e8ca8b30612b6287eddc3887c194942e25eada2be1f670c523d1edba87e5f8907401dbdf1aa69423280d891113bf6b91349b6aea01a28dc367e60e218ec5490e24d8c8dbcf88ea519640f217b4ed80f78ce6dd8cbfa15482c384706ed3b139ea27365a8db6a7a498e91d8fc13b08bed7fed9217d059bc33c2ff52687f9d7f831b6dd85215a27f7cda630adada8574369080403036519f7cc3f4e72ee881e1d1b78db0501da6b48d22c38608dd470fec38aac3470b1185f903b720785de7109a866f2078da8eb42a74cd8fed66100127a3bbe005a967b06e375c0dd191fc97c0f22487cd7e26724dbe983bde1dea65e8ef37e570ba9e4cfe050e67c042b897bf00a7bac2993587b09b18b5bd10bd6c4a8c5bd7fe7b46c90bc0b3429ace65d853e3c17abb59330edfd96600445ff620c1ecc21cf7da35ae785f83b86cbe6eb5c0971dc295c15adf0c1209faee6b9bb277432eadbec809db1c2d9b67623899a628c14a3547c29c4d7e85b3d27863245c06592efdc735c7e2b4a39f76a2ddc65846c918d6c88ed76131f04c3c00ed8f3f83fa9779718e6bf69b086992279351ebd3c63783aa0033862a95aa5448da0dff382b8caff24f5fda0c75d253d682c0b48d9ec52786924dd41fb2ad4de7772425b9204cd91f0b4e1513ea14bb03af2722e94e0b64dca3116f6720a4700244a47d9825456f7d6cf3a9bbc82d0076194f106de851efd2fa60b1283596f4bc60e2a9983933e094532348f4d63ee98c32d943a1e5cf5a61727e57828efd9717a530b9a12009ff3cc99f6194de787d310ca3f50a0b05bc661ed5408933d0c6ec93ed4ffe6933b69a0ffa18db24c14c3d48f0fc78b5d9ae464c68b48edd3afde44135c87febdba2651f383b9d2f82c044c8382e9e9fcea54f39af71b092db89569d13d41ca409b129083b55812c750d9d6ba8a588ad1733243341786098e15536cdc64eb9dc71e1ebe0529a4ec81e5a7146485240daef1580d2c3546b6fa8488727425c7d08b605b4eb18912ffe1b6670e468917f6a7ccfc599d67da37f8b6fc8ce5564d5984095b395a3b0c326a51644d18608f49df2145de66c772c79d796f6a6cf9888ad6c5afc4505b84d0164a11d81a3de783f389a5fdb0fd1c5e5543edee6400748d8b3619c3e61233546c59809163f148ea0dafe0026a25a5912d16cc45a39ec9a4ffaf724992fe9482eaa37b2f5da9ca69be0bee4856500384e2dd85cc8c99c73581f222409c3ce7b5e223643bb9d20810398ada9b24000f99b35f0fb46f13ab1cf09339a36991855cebff07fe0680241e06065607ab81fed2f75cdf1487bea9a8a5cd1f36519f8ef44d3cf3fe1d78ffe3a1288f7fca06d003064fdfc2e25dcd513c2811b68ee2d7bb60023904c4958336ffe21bc08276c2482f41079058971c8e2fdbfeb126c85cf8495ce3df1e55300c149a30bd3809120af7f482174f2a88dac3130c21ca43e85c36a4a420677f81ddd3f8612eddd956ca0b8e79886577e01c824b829e661eded54069189636579b0914cb120f5765077c82baaa9858573fa1d2c523f01dd1f0717240b1675ef7487470ef5d7854cae841e65b2062c788780b9244f31d2053ca80a867b0f8f97d654d1804f9f8da37dba28fe7fc5b4babee2370303f2ae5c6e466f22a8ac842263221b2faa7a3d0eaa0299f6293a6a55f15244c2543fd0d4b2ebb556fdfff55d4e62ba833b46367c71d93b40d4d25476783f8d931006b499020f6dcdf85fda7d056089305e9b52a00a38ec4b730b0ca9a7bf873fe911f02200539cce02b147dac368760009be1b3d9d8a74b4eac988504825e1fa5bf7aa0a8289961a5020ba9c8667de4e35a9f504d4c5ccb257a0859143c72baf8426f7feb5839f0136f4effcd9f2fe7db13b055bd3701b9195df0a5a559be28b32fb4b3b19f3fd2071361d524db568048257101b41bdf8b6cd361418b20516156eb610f40113a68f1c58a5669e9c71d3e038607d830eec2a252dab4da3084e243598d585be93d00c027ccf2773a56d77d74dd1556aff445f2577a7970fa2a05902bfdccbff309702daf429ef10642edfc337b27b53110678375249839cca8e9439af79f6944895266d3e6f7cf9f25697ad976f4e4b9d983c86636d4d993a0493f670bcf859a4dcc1c7cac14f2aa20809bca642c5f557c602aa582c19b99474b1a608c7d37627be5fe234fa4fbe8847777f4601d2f9e763c8c06be71600ced17ec53d660a518c8234e5b75f7366e0105b6353471d44995764e5881b044a7e890242bd3971368cfe975deb62244deedfaf5c57d100f431a802f0164a8b818da7741ade16ec69cb881ce8829bc6ec6504f96ac1f28cfeba0e0fe6a9e7de9fcecc9fa8d53bde61d0345ff139a675f48906b29cb0da2111b405c8c0725a075fbce1a7f50583a5c95b94532f9c619e9adc1c37f384f11400d5d0c57d34f1c7bead6788e71752372fc4578c89db7bcf6ff453d40cebfa4d5429d8e8b9c85892c0d8d59ff8f1eed9214f0d2b0bb4d6bd8234184731e3b5f6d5978f8bb1f9e9ff179c3f0d3f4d6dec725e1b1a2665cfd5fa0190d99ac6b257ed3db98abbd81c819eafe777d61cf8d1c6be6008185e76297a71bb94ab9d90630066e0b69375d4b74dfcefa8056006ef71ec332c037365abfea17437a90e5da580cfaa5de29056559c687601f4ab46e3cd767a775367bf27df6954b2aff32bc50fc46dbeb3e872935d6b242c04df4d45abd282d6074a7c508f4d00a997959bfff7221cd1cccde4f4eea3864baf8d64f1c6224ec4ec877fdd065035ed8d972f0d2664e8d9dd01889a7ad748e809f9bb3132f881947e33fe0344b153","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
