<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01b48989a74ae8bba018e86257f0dfce460a3d77e92ce211fa0ddc35676500866c262f037dd1b739c4e67bb61efe1cac61fb5c7c24b251cce4c7625c3f311c2df7a77f0c5c3849b1ec1f557eb33f964e03f20f3613b39e2e235b951079c5e0994f4c5b8e075405b3d293e9c092c5b7c990e91b137f064f18710ad18d3322fe7e678c23d4d963f098a45364a53b6bf941db52f5527351d410a945d76fbfcf0fa687c7d1a8c77937cb600bb4554d3fcee7ae40384fc0dd074c2adbcd54a3872b4abc969ab21dc48fa3331b2fb1e0cfe846fbae3069eac2fbc10e8b9ed6bc534ce1eece494c5b355c60d2f2f42ef9570de0b572efb951bef313d7d245185c3385034b9d78cb5898d5930a38475115c7ec3f2fef3639f3fdf5621e34e876e37ca36e103b5e91f5b8d90051b654828a6e5639289880b708665594fab48c759aa0d263f95844df759004cb3e8096c1e70e9ce76811fd4d717bb375249df4537b5ee251ac55be383b2e10381a6e83df2681ed576dd6426f7d42256f2c868cd0e4b35961c2229d09a8fc983739fe32d308a5f4bcec3f37138a50e66b7ee7b9d696c5cc1d3dd0af965bcb231f04a046413b286dbebec76ee06a01adfcfb8faf45d4c99fdf1a9275810916e73a1d089872e09e282f12b3be15741156b411a1a7e4f414a169982d97d67b3c8b5d117960afad9fff4e91ac99e21291ba37df9a0fd38e0c91c0d7b4d710f1a4587cac62ece1b2dcc5c21f78abd889eeb174daafaaacf0c6a89f1d7ed99808c0560f563d83d0a41d561c6e5a6cbc28132de54c7686985f2f27939ebb6d9f92561384ebf340fac9284ce51f0791c0bc23c1e69cf32a535e562edca8fdc17c8aa825cbc93414ded4d2ff5b80bd98d8d55e6a27491580901eeba4ce809227f65225f2f9b1564db23d7b4414ed29e0e0b5ec30ab30f5657ff1412c35fa492cffafe90ea1023472fb7c0719f073ab180d5a07e55ffe5516108b0c2f519ec0096d2396665f32dbeb1a0de0bf04c0a4041987581c1f5948fd8139da8a1a09f7a31ef3665adf95f198b341b2ca34e41deb01352cef835fe4018b2e285cb0f44f8bdbc28290f7ee380ce084808ed841b55605a103a1e14595fae684101728832212a879776d347db2075a583809b0d7b27531eba90f7ead88949868c6fa6a95ac7d4862a15cff78a8de0964994278121d4dac713cc7faae6762fe60f3bec2bdb28234bffa5f5e5b1dd5c5623e4f98ca50bd37a9da16715c675330ee080990ac9e38d35130ca577f4a71a7195ad5a45c76c5381110177ba4372339862c7705c119526123d9313aea895cd9f1ba00e609f4c3b42d56ced6adef6a161f93a8ffb8238e1a3161e889d82d30c0c3fbad07b99d05e1faad60f0dedda090619ad1a75e954817216906cf8ec976595a173f82e2a2bf38a222d5e347257e35186bb0653354f8097688b35734b1a8eb692221e843a7744f3eabc90c3d30392ab70953893b02311a0020c192f215242ec897fb2df50d43f1ec6429009e7c27574ed605c0942b96b63ca069184a6e41db6a9117f5755ecb8bb4d386e4ed50233e54e53ea9c0b07cae04036a9b3fbf1d8a9cb9054a6d4036e61a115800b978e4ccf5747e59b3df0bdb42638a891c1715ff469ca29cde465dd514154459585e387d47511ee1f8518d205e007251c1e19e4cc7b74cc0dfa3e91cebf705c5b0a183c5dd765b51a193555ea1d897f65f91111e25d45f163ea43a8e61509150343e71d3eafb250b0bf6ee84d0cd49df23d000770b556afd807c8eafbb00a1770b5aeee45b4da6c11995feafca6b860bbb03ae8d89d883958673a5da7cc3f38550b218b3559518f0b1ec885c40f1ac59d37eee4e29e6b05b0252cc5432a89b41de98facaff8966f5ae38e150b75c2857d029396645b61acf41483a52f6d5ccfdfb1bcb6bd1dded2b904c033ec435ff00db53f537f41c7ced740293277988f1100330183e231e149c353e23d8c653c0adbcfea143ce6bcd8308ec3fd598773f273a5d3c384790f6da1fec211522eb750d7b3e2fd707cc69c06bdb53246f30d6d6b467ed5fd33e967576efd256d7982c1c90792689a23cf99ca7179aa48c0863b53c5e95489a59b2a5449f475ae77381a909c65c44cba03bc2753cd7578ea02e3c2a4d6a4642adc6984bec74b941dcd1880a4b7e7999f49e161a1dd13036572eff9e5f5ce3f9f7c9b0dd6cf32212c0b868bf0cb1005b0cb50b1b21e64869a498984bbe17094b0d7e0104f9897707bb77f427531bafd9303d5fa7bbdf7b2609fb2ec4bf7142792cfd136b820dec41779b0005e4b4e7452e5408494252d0b3ce7da7762c0bf7975b4e133515e68c24f3a10b6aeebeff13eabd6797cc195b32cb0c7a07cf4a35f977b5b977f21149f28419b1fbbaef49d920f414c5d64d736c6a1da86ce8fcf5d28ea551c95b3eb8fc8628a5e5f3b08ac27807618ac6caec344bba9f25408a4aa8cca0a920587918d17be7f29aad68dba7400365fce7a9f0d7285948d5ebb19b1293f92004acf15745e39170fe3604b09755adbf216ccc3e2d1dd92101a9aa4094c60d19c73482831ad7fe27be9feb36ac478c6e623f99a7d6720a89d24b71f693bf101e6dc81771d73007f2aa2f63d85d4d353d1b20130601894ee8a6df713c4db654f541cb03a984ac58e208e7cbd3788ce842ea1b4458598a5f6638456ae74d7706a3901a8cde5e35f8f8cc87daed67ef2edb87feea9271f7938929a8815acad4e5fc1222c30a48912b55ba298ed16b59f380eefac9a6bf280f9c8bcc27b0c93b88dfcf6a2a8691329c0d5bb620e949a890c3547d2d9027bbe0e94e2b8be8ed0342a220e5ac5ab9c1fc4cbc6d85b7751978b914c56cc2e3cf16626c5309f758379ad9f3211ddcf8d0fceb2263adba22bc1448fbd5ae3e8c51718e617fce64988de6661b3b8b5a30750dc21d90a799b79e26e51e0017bfae598d7fef3bf8d861369a5d8285848ac6c07a870674fc724f43d50f28cab3a1c61efe5f53902d1f2e60c9b8a34343260520b24b8af21b62bd4bf17c65f8c30627d190af53a5ec13160b6a62d1d8b509ea2c938949085d745aed271760f5f6dca6c9133eba3077248e6acf3f0bca3814da9eb6d7ca759a657ff5d9205359ca64f7d7bca1218f8b8884bf9f4c66a2a5150368800a620a7967324bc4baaae7287c4d9df23c9773c40cdfec67d3dfc12a02614e2adf373e8b49939bdf7e69f890e319515215adfe0533bb6ade75232e7ad1fa29770034851a548be281e31d578dee8bced8434b92b5a013058efbf7929f2203f7e7351d842887f846cfabd4f3c5d9c0c354957c0572e48389462d37f963f4a248d4478797c3945b3f5759411c4015c6f77ba74a5483ed2c7b7e693d57db6320441c6de985f93dd7e7f0d0b5558d280bb61bae92dcbbb195aadb97a228e59aa1b0fd0191b19621fe0f81a819bb2932afac70336870339dd30edd250a84706b252469cf1ae9bf898fd21da5f50a39e51943e313e3c1721861564531405a1df7bfd3589cfc3136280c8249d92a75d5bad661a924b95bdd77f8ed61dda63f64f4fd0580e857c5ee1042870449396d6c956b8201449c872211bcaf342dc9f90f6a220a4daa52adf1d50735acbbe657f14c9cf2b78b7ddd2030bae43f7ff21aed451e192c8f5adee77f36af7488c5cc5827bab016d16e0d6e39ba82683d132afb3719f299130393d28f7cf0b89ec84d8057495ef7f2b1b60c6379b0bab433f4fa0b9d8586c6e4ddac7e11b5d7dae729cf8b11d8e770bf80fa5adc0f4a93ef4567dca5242044ade0c4234244bdee4d3dea151561904126b78ed116cf7999699a235b7f49005b862e72736dffcbf5c044384194258a2b8d8b69d9fc7905010c02c2ddb64b3bd8eddeb7db68f9a819fe9bf03b915a86708ca006a6328337e8af7bd15a9bfe295b3524e97bcec3d2b65781e39d6cf21400ebf5f9a6740ca962f4ecdd62c1db9245fb26d3d56b3f99eaf791e1d6fea5a9780ca4bbba810b8f0ac76141eba63ef17e8df28cd65f542ba119c1b2027ec8430d5bd56bd47a144efe1b44617d080547bf46538494f981b652e1b6b635298ee1a606d2f1318401d7ffdcd1115e9cd09124a096daf75eca774c35933562092cc087eeaaea4335e75eda948a8b502b51f68911359a076a79adb3a53a4ce7e65649fc62753bad2844fc5ae502114778ce5dd1649b45a4fe3b9d95dea216b269ae489cc5b157a0e4e7d917f19fecd2d036e0c71d46bb02d4a41b89449ca05ec9c24dbf84014c9a07deed06174c17d7b966a9ad5ac37c645e0bf7e5b96b83ce8c524f70df30f3b45704c5f07340121bed3252003b0c1878adfffb68724cc2bb967c65b19adf40243f974ad83542b1c1731a3f223dd4286f99a671aa3b5efb2d44c56d196a00b2ce66ddf5a6ca289243dd2751b25cb54f9050d8c9bedc55dd818718066bbf929fc9540226bc6c0dd886bab785719977fbecc45800ac6e87ef8020337b5eec23a796a6a680b4a0170c52bb0d204f14bf3704ee0d61635602bb3595b898edb57953b69aa1039efe20e78b28fab55e78dded42cc55b994c0af830cb0e4c7d5778f60444b289847c2e2e7e67b460796e2277a0ac48a9b337a365c0bfd59564e13b7d0d92d15aeca0d6ea358dc579dd10e129be2343ba8c74e7543383633b4697c84326765e06dd045967cb3d47f5c180552b1ea5d7430d336ac8e9c2f59338353e1d8dde13f310885cbe746ab5bdb198e7a6da6335d8a5512d732bf8aae6550ea6e0c9d7515d0133864aab45b0043eed19daa140397b6db030438d2131748aaf1c2e5cb5e841fc833e581163b4a7d500f12e5b375a89e55c624da6846f68b5689d6538c5e3440d4e5b1ec766c18cd7deb5ab729a7456c68b2ac86792de2299e2fee73f1037af5f41814f24e0218a40ea6a6cb8ebe9ef84ccd3ea5961fc1af61a18b78acd4a21513c928423d50b3dc8404332e25d887fbbc8aa5634672b87f4999844713dfeb1f5ea0b79695055c02d95d7584ccc83cb8fa2bb8f51e1d41310503671e1997bcf669ff8ef4f881e55c83c2e4d68ecd8e9ace18511ca269e92696595c88ba30a1691997ec2a0ccec8862ba80295b5d91cbbb4fd46fd34b7936de81119f1c72f03fd60c65c2a2ec2c962a4a06d40dd441282196da7adc8d5738b609cbef3f44534c7a5911d9378b40239690cebde1d8d0a5f2cd52ba61613ac210886bc26af8d597f10cf9528637e7582626a94478f0e0ea6c9277f662f463268a39436316ed6fb2071b266ccdb4f1abbbb61c5fb199b790a25fe8356ce93a5d6827cb0950ea7befdebd3b815aee74783597654e8a0560df940a183bf8718ab90bf2aef6593ff6073a6e4a5efe148a28dd0a309c412d4c2359d23de1ac492a4714a30920c0bedaec385721e499993823dcb1b55c419a9690e30b4b3151b4711cfdb5fcf508d22284edc809d9b5cdb9013abcf34fe9bcc231d05e891cde77c7dd898afdef9d40fd214e61ad805e87e5192f2baea6050dd54bcf8c15b52001ce1a208a01af10614b1546c4f2e7ab975c9e456b360f4ae45cefaaebfff927ec847ff8f626b9554d8c9dfcfec50576994ee028710548065dd9bc45326373599ada0a0e70d916b960f8235ef399b2ea5594d0358138a4a507e648112181a95debbae74cecc4cc90e194d0103c34c97b8b9dc5f0ac7e1f9a6485dacb8e3148c2250863c2c7b17c81cc8c984f6edd3472b226ec282ae82506005f8b377cfe043f711aeab38f68e8ec4590dc96d22ac282554ce59acfb3dcd2a413572812348257373f9dd9b9dfef28d44cf5bdfce3fbf6637420c99ee7edae4ea196ac1bbd3f90664bfd7eedefe65d8b0b01e91d1a62c9d45237da23f973b6e3ca5e6533b1225070618950a1660b08447e9b4bb9a9eec317e7d64c0b0a7957d5a2480909a6997a949a7fe0fcf7a89d82b6a776286c5528c9294c68e4b68999a7c9af076655d02a01b6c28a93088c7a0dcc60d0c3260cc926243ffd720edf0a6a8903eba267b2012a1e8b82e23b7f776d2f9ebb4d78243a66ba236787d6793962408b53823f7b131fa13f59618f82f112219033edc0f7a8bc2222cf2364b20a34ed96bfa4fda6088522fa80c78d54b2a38972941a1492334af275036ea5d8337a0f98ee2877180dd41fd5850afbf5bcfedbec510b31324f765c4905e89d0b4f61e5d678ef9cef7ececf3ddadee95d772eca2629ce4bb15793fbffb22a1c425a49734fd196f1ecd863f58812754148360c76ec22b1e6e3a4529ebc587deb98ef49f3025df403377ecf5ddb0cb647716c6a2c2e45a77c6eea3667b38e4dbc184fc7eee1d860eb50c2c91f5ada381c2a657bf4fb5e2b7795e403e4d3b121fe6748192a63dc749ef8ace5ef068c2af63fce5a2f898dcfc4cb4a41ea8acadb7d14d9d14f0917edef47af67d45441fff71267225a31b8f27d792d4f73e83a37148a4953d7481790dbcadd1a4222f1ba123b052855ffdaf23b9ef38d71f0099fcbc90ef96859f5a813b03dafbf2a70dd71585aafe89a7e636ca8977ed940dc1d37ae61470617a847520e7fe91b9e83325a2ed2e3e00245eeea188ac0203dbd892e8d37739e92feddc10300038e68fbf05319024e7734072ec045a2240a1c8c76f9118a4fa852f105207a9effbb815a8a5dd3232f286d1e4390a67e598f721d26c74c9b2523ba51c7be8c571e0f0741730914c10f89326e087d376f4e1a0b443a81fe32698f66c607c06bfb65ff75125904129d3e7e197f684f80a511800753de0ab43995e4208c72ce4ada28eb4db7e01ad265a27f4524a58b0db04c96d82fb273a9718163d1aa79331ec9801a4ab1d5ba0ebec5372f3a72ba98e9dd8abc6b3515abe3e6b4fdde2fa285030c2c1651cadb83747fb2a8a0827c4bbb9012024c7e1ce78549f3500be1d656a1f9b471823e9f10a913d3efa7e807a387fe2a2d61e0fb611bb196e23a725cf61878a6116741221072db1de257b7bccb51ce0d14042f10d4257c218ff9272f4202fa5e027789e269c0dfdc1c66f9057fcab1edce002740c51c2bc6c44135c41f7aa2287e7fb556927ca853e8d26a8012c61fb69a2052fce8a5569ccdf9b39456d29cf4e499c3ef8f2e6562ebe8c311580477c12a6636493a6630834099e2e39a5d32eb6d0fa6f6a1efc838b9b4d205380f6935fa0ab8cd49446516f8e2fc78b52372accaa7ed362615232d81a152c2adb138a8c50f0e2a40eb31439aa0bcc1db7d720ee674f59c1857895a20cb65986e8254d29eb0251538c14cc0137a355f59e196adf8ceef2a6ddca4ba644c3702bc438204b6606b4880136dce7fbdf3f1e5c85f0b208bb49cc841a068e0bd9e700ad255f1b9ea841c325cbd5998b67422fe205765e1b764bdb226d8f5618020be35a6ff5136daf8566c623ae6fbed7389f0b9b210f42b7185c6a86f60dec2edfbd6c9a5bdb3fda43cf02a414fc80b29533acfa8031b53282d498bac25942121d312bb62dec29747144df05c4938cb20c2096fefea6ac90e33d0ae707f6401becebe2ebd7e11d986492a92d0b88bedbe0a053425ed454545a500df790156e00a49a5dac2fb3168a35a225c0dc1973c1217d10052cc6182c225fa374b595f749f6d5a6c59c98c81a9d558aa73628f84dc1f321c4c49f37ffb2ec498bdd925abc09459b3b0c2358f79e2b7a54ac3b1f6bf2bdcc66ff34c23d1594fed9f3453184370d8c70cb8bc970d71250b2e8309d56ed128de9f1cb96f294b20f053205e784b5e630519ec0b09e31b3ed65cb4bde7f93dcb4ca13c6d55b4228dc5e1179c88a499f7e9a2f38b8a433069ba08157a768f93293227b578ed678fc325b96fbdde3d780fde812d16c763ecc68da32c3ea9db2b161fdfafb1232717f042f9527591f4253ebc14c03438a13fa0e55fceb4e5ae7148f5d28113eb104fd100d8df17a58a5f67e758f788695926288b732908ccce7017040274ff13292dc92a1f03e0dcef4a0ce52b45e13b43880b940c5a7978c2c76b7335f263e164300697331699a258ca65892f3d7608b04e2c9f96ad201c99f103e9ad90b867be45eddcb7dcdbf11c08afe16fed50371e5d999de92ea16820badaf8a6dafdf509b8a1620da0a34162aeac241d95808004e6c45a5f1ddf7cd162e61cae8f62405bc4893f318fd03e5cb9ce590e21eab990738acdaf71934d26d2c6c4814c30a696d3b65522ad12cae6b068e23d55cfdc4c291b2d5517db5932a3b80759d439c2bdafc811fec67fadd1d0ab1ad93562190861b2e58fa419720d02b8bfe7ed343af0eec89b764fe2a05c17e0eb5aca966719660cdfcb56cfb87e09daf26b8b8283b583e850879fb46d8488b9c73011f8a427950721f452d5f5591ce300514ec6e8f1401f051a29b9734f571c294a7c1da0fa386d4a09bdaba9faf6741470577b97c354600b45c521a9d2a26f4727311867434f29c2f38b46b7e10d27c71bf6dfb53f67e0ad62c5b14ec4149d3dfd1f414e153fff5fabf3760df2d109dda94fe72953c6e1e66154691a5500f40ea1006e1f730303aa370b17bd2587ab5303b2eba9ab777c4f5ef9919a758cf25612ec7e2d53e82903d08aa03f8c4a9f55374759ea94217e3f4ebd33bdd58c49e867d1d4d8a0235c24d9c84e59f9055c26adf741e117180c7ffb532111c497f7669d9d7289b13a823504a473a0a3b7bf2a89f774dbbede2196a4aec1e59d07c2d16e4b390dbd14cf4f1fbdd01e20bb45e32f89e6968c56cb701f212574d4ee84cd73499d0a6b1889ff6387d375cad4856cf43b16a901db013097d9f9a778f9a416ff0b983eeb5fb60c8ede8b2428c302d979fca8d4f2356e38b86e8e7bdc67fe51ddc6d1456d4116bf6e7bf3abce396345de1a6d499238947eeb8592eb7ee2f751283dbfc068b56258976a9c16c15a1fea364a1077b25fdbd695577db9933d88456501a20efdbba400447b2cb1106b2dc3c8a05834ecbfd7f15ebcf12f61a46585c4f526f73247347ecc5f7aada1f2f850f013af5fbc8583fda8010509c5da1fa8e297d7ac03bb5686cbb12f246f38e71ab9110eec16de7e90e22c9786e219a7ad7bf0320d11efe19b8cc3fddd4bc04120da7d2c6f13e3a426a36aa1f7cf1815f13c39cfde9ad4f1cd619be4211b5d99d02d3cb69e6b63e09368161e37501f08ccb232b43df56909ba1a9d000d48907a22b2c73d2e8a548a7a18ee988f8381684b19c2bfd645add5de731702e04ffe7354e2b37608c613e13135a4709e75d6f637811fe035cd8b6829dcd648e2a3af763ead65a3f92f54a13c1c472140da5356bbe23d27fb6411a8971cd7baf42086b50a4561fd627c4fe2489565c9818ec5ac272b7111280e27f30ba10d3f425f4eb62f568105cab84c7cf0461f74afb01653105851d9a9b8591f4fdd96d7f13be85062e984bb65d99ed3659bce7b8ad3dfd95f1e239f525403014f81a0ec16b410ceff940310464df29b954989b1085d983296ef0e5b67980945ac31403b92245f9f280279d5f3060fb213931de03e54c6baa8a5b5d3451033ca1365ee51044971a357f4dca6fae5ef27f7d86f3669289ff95435a8f2a9dcf84283d71cc06823531428578cc34d21baa516f8fad345d05417569a6026b1f4cc2cdaa5123d5fc521aa7f1995f94abd38ebc0ccda26228894113df26759448ad899eb702366c249e7a420bb00f696896784dd44199a3d48b01e46b7933ecac163c3bc1b4bc76e81935873e12c74cf578b972f2e8051ff98b519a315e2102c63d42f5e62795c856af62418e1060b192016a254e6650f1d7a933905b61add4a03f44fe297c3b143afd63e8999a6256854b301d4f9b365c6c8eaad206da393bdbcb18a522ae043326aa4bbe53f2410f3beb5955f7e16561b968c99f637b94e71dd0641473362a37aba518e73b05ca25c751c4feb7ce4038949757a8842333af3c32e2a29d433c936b33e9ed2dae1db2eb3823b9455baec01402cf8c16699b63f3d42804d954b219ae2803288d53311e3ccea2369139a87e83f32b9dff616ca0ad710c9f93e3d8a5025ff4bc6cebd2489774ee9f7e08056469b91d3c0ee96efd9dbe8e400f68b5c63eafdf4230bfaabc958f92f0c091c27201dcb7ba0a819d06e7d403af7a1fbdaae486a9fe6c662671f871d38ccb81dd61033fe2b9e9e066c2ebed871cd54075b4e469693df5a363a94e51fd0b026895f5ecbd448b2701a57acd00a29677135dbafcabc6c4717290d025010017828642e77f92767d24d2346581b270e78fe66601511d808fd08cd99b08d2cc51879f883d277d9acd623dcb1de5f0f9eb81b10c48826917825196c71924369c62e72707f7b6afaecf57db2ec14fba5b6f35f52a9a41335b03e8f86be96c940770d3f5080d6ce7cc6fa4604775787d7ecf886f0934cea64cba276ebd60de69fd75044a4fb7f20526f447e70160a943c82f4b5eec2ee71a45855687e103b14240efa9408ee5ef25886f5f18560c1294cf4371b20df778280a3cbc6952c08521be7131e6a9ac5152d2ccb9550993590425ff89ce6e4cec8b5855308132b4c9d8df01bf904b58d60f82ed9281805263bf0c6d2b1ebbf1dc8c832ede94b45251b4199e5a628e033d6388617484c13402f912e876fb6b95c70b306a2d8fbb60d6a5f2173624623110f607332e62383e9bae8fbe466f842cd5ba861e3365ec6d62b5308c2b67a3cd34ccbbedee03f4c20e70f0f9fe4f01e997394a288290344bc76723379855d9c870b319de646789e8c73375073d3fa34be637decda570fe55214019511e8e21a33fe7c315faaff4eabc38085b3d81d7774427c18112363830d5467409f5668fa7f3603c50e63908cf71e13a02c6857c34f37c1bf97ff6c4c6406537d547929c12130b8484bcf70a780f64ac4a82fded1d58d2d288f6a12ba56ca15c005e0586d7473fc91abf3a7efe47b9aa33f151a7afdd6e7827161b6c1c9cf28c2844ff63c5c16b14413c6051af2e8ceb2c0365703e370e06312ca43645b88def335a0ed145453858dbe34d9b69e3ff83582f54302452c1405590d37faa53a988b313f2cd8fe9dbf210813f1c249f2d5ffbcb30092d281b2cbf843e9ba2b01029da75c2db5d7fa4ed2046c09b828538618857ed496c779cc07276ea5ba370b7c9a49af8bef9a32f1e4c493e5d12c62d5cc5c3be2bb9fc2245475ff9a2a448a33c881413b311c06a3e412965ac7d91c4697a72c616a0764831416c1a894cb7616106a9d9fb10dfb7be972239d72968cc564a9dee00034b1a4eb09cd4bae8b48bee5e242aff6b20222d8e6351a6880c277e55392934b905c4dae588d857e483d7711959a3fbbc9bc80d38a6fb974ed0e31626ea525f36b37c6ee0ac28ad01b6ab9e3273904bbdcf68a8bb3b4202a48ed5eb2c7a3a423030bb7cb48a6c7b67a851037401772d365df90671f3584dea8a477ec04dfc9221c0d288997d108e233c8a87978b3651f8b3235c9a321cdd96e74d02ec172a2893dd250ae7fdaa1001ddb854cf8eaae45780b336e4dfa62d5d010d498057a775f2ed03e04669b374713127ada00863fedd21df0260f7ae31e14887e82994cdbf911af06afefdf512f1195170cce01db4162209ec9010e375cc5128a4f8b2624ae998aea5d1f95b51dc36095f936c2935c9dc82f616f89e093f243f97c3b6850cebd402efa7b7097168ac71774f661a09e53865ea8672bf7ad4fca8a2ed9806cee1d1de94c07558fe1aaabc1813e8a1fdbb636a44fc34947c2acc4da0d04fbf4a0a189978202151494044361ca1d8c136fa8e19ff863c5581b38294a9fdc0ebce16b76a17a2a8281150157d3c6b770815bc7452a87e238ee96dcc7b42fcd1d7fd01fb000f1b99ec0f60babe78a8b9822412814a2548cadd7b67e1c660d2cd54c4ea1b11fd32a608d36119c87e6afac42b621075eab51c8ec07cfa29182aff993d8973f01357fbc09d82678a73c89ea79cfc34badbfa78123531c1055c60641266d2e53f1a9e50f2fc98237c508e15359763538ca1fd489bb900c85a14618d46bd4d9cc99c5850173885a3c1d344332cd9dcd083d8866a0064d7a5dfb261f8503796e30a9f3dc3f68659e509a4683811542403dedc4a9f171d9a0fa65a2fea6c683d7dd5b086184ded94c2a113ac958fd00397e18ca4c4aff0981f77827114eb0a4f709644ced50e6d18fa9f964c695d186a4cb5f65af9b55c2bd1adb49e3f5fd33a45cbdc15f8b3327f46d10cec6fbc9425e80755d157e5eafbc2cd9080f35466a6ea9042ca4b550909af57eaa602b6b5e1de08fddcf3444cf5d2fbcbcb1db1213b842b46a18e73818a1158a2e344dd3d918f9189c74ba560a802c6abffdd6739353e505d092118f4730cb6e67441a1e8254d89cb7ad513f8840a5995e7aa5f7d7ca37f1e8764f99fdfd0f6a95442d363d45079fe1778ca9983f8fdba049d4b3706ec7a0d89637ab00e75ec6232c28cc9ff4bba28c7faa0dfcf66c3c455369d4760b3d10660e7820e0faba8732465c93c44b563bcaa123150e993946edb25d40aa6fca9d8ae81d7eafedb4525c51c246d9cb3964ac5a752947554d805d81250714347985b81540fec52fa64abeb2d831cd46b4f870ceca41ebc610c7947f6d911a675c96d0bd98eaa5b65575ab24fbbeb200c7f71ce9508ad627bf01e5af6cabe0f8e6701ad32f0034bab6cdb3ea8d628092c18bce6c3f76bdc51a15a10063b88203672700a7adee0973eb95d575487cfb545a50ba8df1e4bc48bafa4fb979d6dd7c614b8ed2fa2f3c483f7d399042eee5790a7a330012d6595acd1c261a2eb1980d4abffa5b9b98eb3daddb7ccdf4e10caeebf28d1942077ada0b6af7faed13d1024b42831f6d35c277acef8859774fc8baccf6d8b5f19520c0cc84eaf0c293cd8b442c02f2e1fcc647c062716b4da0f52aaa6336aca1ae1bf28d2e8267c2b2dc5a5f447055a647c8240fc17c353c776e03ec9fe1fe6317b2d34545338ff9a77b740c32e06029d8a8e10a0cfcdbfec7934ba8cf084262d8eabff9f7a8b29d2ba28a3f067a36c199d487bc4a6acb2511bb0f0fbe6bba78d68211d1c2e204ca99a13ec6346caa41445c5b2bede589f2dc66728410b3bf0a1f397b1c9313f7a387450c085084cd60371975bafdceda74d17b572ca757719be8d5a6dbba6694d5527243c77cc5c4dec455fb86c2591758a403a41fb2859a8be716d73d0b4f3fe9fecc557ab0080539577f9016e5b223df5b3f9a516924da899755056cbc47615730bd15949d351239fb69d2e4b2fa46cbce6bb3fc2d4e1f853f65b4789ea45c96e00bfdee419578a2ec156bb6858352f2f1e782dadbd8c7f7f40039d3c67abe2bc3981b57bc8f2e1af743a3cc8787ac6a6c1e141d73e246fdcc70b6f05f40cc91bfb3a7d36d7621edc3a6a15539b1ae95742c588dfda41c8b0e00237be61db0bf3ceb83666584218065c4d7f8f7d7a839c9e2f84d7116fccf61880e62276d6d8ace18eb67dad7dadb6589c7b68c83dc8672abf65866096ec3dcc24000bfec8ade54fe113202bb1790e1b81354a0a79cbf7bd03b726362e5b265e16315afc61bcd5de44609662ac807bf9549d016476eb59b942d5896da74bf1f0c593ff793ea3de19fc043f9fb41433529a113cf51b7ba800a9493518199e288c73c9aa189dafb955fec93dfbccb87e0f62171bfb9959809e8f11ed417f6a70ea0d29618daa331d2b28a9261a47c0c949270fc818c40c021122ac8d2be7d9d25653702f6792ae7e5adb11d2241dbd44ce5a36f59fdd23c5a2013c4c805b27aeb43470004351e12aa1387b578f176f625c493ae114fac0eee2c74d5c7520e3ce0d8617d343770c6c1bcadd21a31c2037afad9925a458b8bcd588b4f8453be631de360948cfe9cbc4c8218060f0f010ec1ce7916d99ec78b4666cd7abd63219684a752f776d1c1ac0b53664f232ab6bfa6724976398c63f6e6d0b2b72d46428c97749724aad296e413ebc359e0225f88bd8fcc4e4ff9ecefe0be681c0682f7b6301464758ec3fd8f4b58706f7e8d3b527020a5737cb79c5bdfe6d3291ac35bb7a9706edd1cd4255837c058cf18d93be971b65cfc58d85d27b30e636f75e0ba718e38eba60f93af2956f4bcb08291dd75fe407e40c0a03cf6fb91c01e6f417d5fddae600132918ea6058a349079f4e3c9e9c0c37b4b465821e7f456935d3322d63d8c51a9796bcb44b6db5d54be529f574f08dc251aa05ece693d2aef232c9628a0798ac02d908000b6a28c615be9a2784b1e595a02bf06290f27455dc8496f37ffc6be9ef13e64b6874cfe47daec954715b1567b9b5f78d3c125eae021811c16f4602fef053a9191e93ec25f92d766203fc93a3bd596516097f5f2ea2bd08aee25c874b30a2a4c46d0a18d8d7b44ffdc0f6d3e2c8035514d933ddd7e68a58781819a6950e63590ee49eb5c72521fffab6ca03bc7603399d0615b1ef90185c7c5c74b5f2c12f7b5d6dad3f94d9dd4c3e0a715395ec91f63ae7b6f78f0450ee7d7d8eea40628e3632a5a2af44143e17d4f21d8bdd25a8072e1f86adb1c4b6d23d271a565d61dbdb3c958c0900d594d2f5ed2608c5826b4832583f2a693a3995b1a5656985a25033b100e60a88f0b28d8b0ed00b4d80ee2d0164c64b9ad9bdf8998381ac03b9cd3417490b909eb5dfb1b58ecb2f30a88bef7df199be86aa6c14f224a7abd29a0f620fd2ef07938e70e82449b5a921d16a8e37c1363800a1729635dc2d10e73a03e129606bba25dfd9fa6bcb57623599f949f0fd9a76608cbb306c0216655f27e47173c5dd325da778c608ab0b691cf0a05a2b8a39d400c42c0d13f46ad37a56efb6c6a235ec0f6f279c4f0dfa853d86bee2e0d4eeca2cb708bd2a7c52114daac1223cd711f9cbb0aa26b9006a95cf35d126ae8163b3a2be12c1315af9dc58cd763e491eed077bd88a31f0bb311f518d0d396accdc3b07b92389c329f614b8db47c3d26473cd30a78861682c1725cf5ad6e6d09db51e1c35cca9d9448192285577c6caca58e7d38d8c00608a7180b376df3ebc2ec54e94f574d63a55df8f038893299db7f1535f623844bb514f7ba772a978b9070d8e0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
