<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aca16ccee8076dcd167a63d86c3739b34ed91dfcd999ba47cd63515359b25cd8bb1d50972d4c895d1cf1f92e58d3eb333b055b382a1a6f491b01ebd6bc4d6bf7c6aae7da8a9439709999a91651a272e3c4e6e51bcd8b1345d517e9b782d3ff943b45f01ce547d0a6283f228c2f091e8dabd5c2138e94ba86dd236c2b90862bb6e6d03d55b915fa9387e600d454a6ed2de9b29c13d9733e456f9d0524a02c45dcad878eae27b569c372a354f566c328e475aeda1e93a99c5bb4790a4421cbbd6c53b67c19c9b999a6796146e60d9b07908b2cf111bceee9c159f51a2cc8d3101bc95346f55803534732178a27ff0776ef63d9fa77e573a305547354cd0c03ecfa4779610e0e604d020ec2f5ae6ea678ff61239d10d40e0f5c0ea9e14273fdf471dba3c6cbfbdd81107da5e66cad2d3ce56107e44dd5967dd73a47fafc9081d2133f4f6427cc7ed808c7deae935cd0fdeb4bcc9391047228f8f3ad969060db0fd854271949aefe3354e57404dd7b8dcbcc6e8786df9eb8dc9339edcd5d0ba882ef6299881f8013a7d1c68e7bac479bb73b9ddd03ccf0e20c20a4afbbc4d14333411d15eb4b730ba1607d1f01cc7fe0f276c942180d049b4c75e30a1581ed5b6b154f1f6afac5c4cb2c99bbb5b5d73c05d7138cc271caee860a641ddedc6f74a1d2641670302363df6212dcdad13ba9163937424a62d7e4212f0cf9e7c65b69e7782efdfe4d7431ae28f323d2698a6e81b1bb9862a4c783b9816754895cd360a0d9d4342dd32477149aecee5acc701b54482e01e3609ed602917a11ae26aafef40732c3828c72e3e09de2bb47dc6ea7a01cacbdb6fbcdbcf22b38fe8ff4b7b7312e77b1e389482e653a83277844b22f7532d2359157ede0bc861200fcdd4e88ab071870bbc395bea79dcdc30dd6cc5dd27bc7e825983eb76b451864ae0f259dfdc02a36ab6973b45749c867438b3ff5663aa59e90db619a83c6b463f70ec2877f9de04ccebf6c37dafcc56ea73ee9447515ca754f7f70d7c747798273c1185d8163f263c1c45dbb230aaddde5223d3841c057cad2b8b90891174d30aacacfe4e613c3aee4bde8e289c9829db04f7aa69013db968873472390fe422e0be78166ea4d23b22f161c84d11e763e2baa2fb552f5b975823d2c68d8b6dee5687bd330cb4741d43aad10e02ddd09adbfc65c3c999620422f2648992e28b51b4a0a4951f243be00a7ca552bceec9d7d730f2e0778bc820c6aa754de5abfb8ed3c43ed844cf8aa3754c7576707d2d4761f571d41b35d067b3e47a4d61af7ceadb8207066ca7c038d54bdbdddd6fcba75310a9338a7966bd2b76e60c38d044881a5287f8ee7e78fde3ef704f46b1e46cea7098d864d63cebd16e52944fbcbc9efc53217be14116a37f35943b1e1c4519c8b62c5460d615e4162c4e30d7616553f1848633ba61d6c44288cb9c0ef491a2631614ffc4d03456ec3f3822c785f17e00be873276052c605b2ecab9b3d5eb6737c72ae9372b92964194d42c3dd78868bb018d6404790620522bb2258de8cabb795ee04943a342d9b1b0492d202a30daebbcea9714b7e47177e928b3f77c1be892b5632a331b8f09d96b09293e95310fa93aa650d34d080cea3f9f453a930f5ec5e3796e32d9ffb38d935b6ef62eec91c6b97964d019b523196fdafaddeb8826f4832891036a1d9143864c998772d68c42ee8c74b2cffcfc07eab24e69bbbe8691d412cff3a6d89979de4ea6cd5a80c504f438d5357cf2a087a55d7ab3e4f38136a81fd09c54e5455bf08b7695b34f09e9c689545f3d59a4bc0ae9ddf706d8175eb74cf76d2328367f5c9f674812230b0f9e8e9223d59b13525eb329389a5d1f52b52e89bea2dbf8bd7d9e1f6e2bc80703673eaa3d6cca7e39828ff89a1aa650e9c24cdac971450e70953912ca0ebc65e07810df1ede1257978f0495b83168718af7ae2a647ad3c07c6bbdcccb5df36b81543239afff9d9dfe6fd1f0a43f0b761a6d3ec5ee09c78f19bbb26edb7f2a4f6d67ea26746052ef6f46ea6d13769b0b84c225c5830c5aac7e442059c1382022599a4e735e0689ab2e59ef7d2232ba75ddcd10551622246caa8622cb6bb510f290fc3f2286dce5c45993b1cc543126852d433ea56960bb9785e5713e307919ac33cee3039747ea293e0d9f75ce77d6d66e53f9f378bfd45fb91be97f01652daaa061d85ba7f74a3fa305ebc5bc2cc0d5203663754cc411ba1bd50581ebcfb07f92277adbd94704f85085cfef421d584f726bbea817650d9d38785bd519a23036596e5c685fe3593713edbb968f420b94076b315145522b1024a393cb2c8bf216bd3d3a9a62413ce74f9b84e3a25128018040eb72ebd10183af2669426f09dc1cea487711cb2d4d4187c6ef80ba97f202777f826428f9dfa0f5a49787d1791fb1d43ceaef0be67fb189cf16fadf493dc3e58de70f233883047207da84955183d08459af7509c87e40bd5614a3a02778e9f05b3a10f5d7a8b595f3b92f239c8c410b751aceed293f9ec9c3b5252bf225ad4b2e532c9d141bde47dc32826157a2f923448c429ac7c3ead03dd7d6af646250891607422a4c96ffe9b9f4e409a5d6aed0fe40d2185cc014de14f17b357ff5ecc58c613800fbbba714db6db980d0c6bbd2c1bb1c3f43c55c5a2d055c4f48ff145aba1d7bcc617b7d9e6ae8e28ed2dcde86b3e0c16da9bc327d1109bc854711eedcbc86ed9c18d70cec139fb97f5c07c6bc11bbb26c474d3dc6bb78fa44d785a509982d2a9e558a2ffb8421934fe8ad59f3dc687bf407c6cb5ab909130906959a24c5fd66439e2e055ae6ec67de001f057d6eead6cb5eb0908095d8df121a2885deefae91287d596db678943780b9ac1f158020f4a195f3139b10b79746be50dca5a0cb9d671b7948e84184df124531caac3a5f4c989a1f25958ec75c40fabd13dff3aedc6bec041aff0ee3e7132c64b454fcd07549acf140567f14f0b1398fac0b373b60760ee3b44d829b6137e1155f7f0660139f1b395e30441ebe9eb08c004dad5f48525d38875aa5e588154b0135aed0765e61efa857471919ceb420c39a82e704a488f84f69a0ca5e707eee0a60926a684d1974c8713023376d268a7a4cf20684c076abbe6e4b762c004ddf4ea45ddb5586b459f6c342c0ddd032bae433f3d50cf4d8f59df333e259f4c6c284bb74f114305f5b0bd1d18274d4f71bfea30cd07e95d9bdd4b578c00827198680b5648ac98527ac6900dc337959e90172e5bd123bfb319837b4f8b86cdd7223c9dcc5833a4f2fe7931146aca3fadf73e6ebf0595bc063e72b42bc1f91ec03b0b8523d5d72fa68e533db63ea0e2ecd6b989a6f0f535387debc3bdfa6b80cc26877fc76cd7e295d160ba1004c2637fdc6b90c95f1253a7ae4be95b80edeb2c2ed79231e047b23e1380f688d0c47d6d890f467a451880424478ae2bf8f2b41b3e266795f2e46cbbd45b614f9e810cc8de313b7e317639bdaeca0f9b3f7909e6c1ae83d2e3da2db9a566a3c265d6e6c838ea1cb7ea84da63c7aa8a6c951d5b9161d901a855691445dda20d5badcef70ff0ca65cd385ae1a81b487ae01a79e0554642bccacdd2bc74f3082ecf7482001994019f2c042087a36acc5fa9d5eb5c73b29480d26ade1a9507ab790b8619125b006c1a983105dcb5703c3b677d028b1270b9b154f3fe5707d09233e00a962f16f6760e8dab595473c5a484dcb3818decf94260e4630043c2ed76eaed109b25cc58599b4985385a2757e3273d26e5d3ad1430b9edde28a84241575531a5b5dcc6f7ed37e1d31d74abb8e9d777d3f24f1ba39222461a8a4e210a5fc39dcd132e3afdd3d943b3cdbbdeb3f970433124c3011b3f5e07e0d64a04699ca0b8ec8cb61c89f64829471479ca94a362b4354946fc92ccd1444fbf3a4d91efe6add3deca0383016321bda10149b8e9b4bf2e741961caf39fdee080d4d662eb2924890aa482b8980fc878091201b39ca0087bccc915fc26e2a5877d1622789ac0e74ab4a7f9a4b5b95f11019f956b5aa3e5b0d5939f1115ba4288df3e4215702901c283f3982bc71fd39fdb612d4391b269dd4210a50f7620ce6f2e736cb9e040b2b1dfd8c3e688190b091ac22c1083a21d38a846d6a7474754e459a26d620412290769459c3efa86f7fb7248175f0b887ee2e3aa7f8fe3744ada054f8a86cda8f94fa4f02f63f3c10076b8ea492e90f2e661b37c8821cd0843fbd5738a9bb5fd197fb85893eee2183bef2e10583bcf606dd65d57979befa9ee97e4cd3b8c18c256880178678c212b379905a2bc65a9803cfd60e3afa139da8451773df39ec7eebc1c7efe87f6e6ced5a1621da6ac41a7132c29236229c55ccc1e26be1c89acb67b42ee1db743c3120ddb6bb712e88f98ba2068ed7a5731f8327d74f3bc455739c6b5523c1c9ee501a0309982092f1a1df33c042fe372dcaae08e565100135b8a63261e0ca5dae73ea03945fc6d03c09babb8b979c363cedf12cd9b2022bc8399600395f763b5a1b4b9d64783e39cc94abd6c24e6124bc4a0881da203813badfe29bee7d72dd9f2de61730204b44d8ae02f5050c01daaee13e2d533e2b3b5ac756d1d29068222d4838904875b6569421944ffa10f806b1fa6d1355a63925e76032e5d17f5efe37624b210b8946f07562596853c47973ec98bf196f45bd0f53d7f8e02570160c3a397c44bfeac86b0c2f3bd5e32c5a75d55bba373fff5b9f6dce0b2e8dfd55613d0e6018279d83510d01f0ca916a7c43aa563b8b7e187bc298225acc88bd7e320f47243e72fe00e7a92b48cdfbb68e7b1a28ee3e97c749d678c5d2b399bc960899f70777c3cd18cffbf97812412b300eae9fb8a0349d5824509689695d80523656ae9d424268969a1fa4fab485e8f3cefbafb63d4f4e1f07fdf4e7f9f50b52803b8d1de398b46a1da52a4bc84d82ea5308dbc927587a8e63c78182b5d4f511884885a4c9fdeb4bc038b7ffa348c98df4b43cdd8d533cab37dbe13c672ddc43e72683b1f75d498e7356c68b3aa10fe3443b35b0cdaea739cc1f9e3c65ae81aba325321f79f70c3b950c2fdeb21fa9494a42cf2f0c55770faa228cfd91e6708b9a353acc11e44818179ee9c284ab248c160a86c69adf42daea0634d12af84446a025da075fd8886f1bc05441b27dea54feeb8d4e9c5e3db7f678d9f8011b400aca12db47c1277559a59f1b8c3ff1ec6c62e183e59bb0b6ec3153d1fdf4e7634dd4926ceca13de9555bbd717173b8fce0dfea5c7dbee3314f21ed5c3dde04e6aa1c8fd5f1a33f5022bee77147361d5a98e7ab78ab036b2f75ce922e23c565b9b89575430e082c3fe33d05d4a592c4a29530a9335db8e72d5858f630b3539d81aa7b8e937e6007c946cf145a6908eba8014f388306ceddfd4539c2b39f1522405961427e3234db7502a2305c1c03fa66d3df481af7332bee02bd0182994afa4e9fe12afcb82b0bb0ccafd56e0927db4f4f9324f085ca7ff2a8df7fac6960a021ce671648d6a5be13551a107d48c0420f0096390cd6881f42b6d6076cb784633bb85441cef078602d7335100043f30cd9aee586e88656060ff1269544a85151d2a6a109e9fd2cf14fa77627fba5a5fac5685bcbbca43eebff6489c7e0e5d3061bdb254097147cf25e866908c82767bc7be933e047e14979e8abc9f0b8797e5303f423219af596813c54772bfa50b3b83d6943dbab564f3d3eadd6e8a691c487e0560eb3b25aaf3660d1b24f28b9fe8ba8f7f6e9f59de4d49530656f0dc16127b2fe40a6109e0aeefcc2a8619814860e1b6fea68520bf5f14fdc9602d3ea9274a6addc3a325759b2b3fa2a5998a1060b503e7d12bb79e4c6bd90e1434ba679847b94422f1c423aec1652aabd35aabf5412d115941930a7e401aea00e56729621359c71573185e9f0fdcea5b87155d2627fbd0bec99de7808754d841c3c9c2d03308c8ca50d3bc99f48a3c9e8ca1757d6183187b63c38893c3440c67785562e8d6bf1d658c7f67fa6b71888c79ec7182439cf673b5c1bae0028ae36cc21c51521495529538f9ae7abcafbc76d421624686b621a71cdae048ce1fc41a1fb263923e07cdbb1d92beca96b6b20efccbb950341375f374fef0233a1ecb199c49db6944947b7e973c775fe3ade08e072b18f6d745c4bf49247875edd9ea497c94a296841d4b0d21b0c0816b2b18fc8211a9315b2e515b566e47bed49119f43ccc32dccb33bfa9d9315d9df8d5f48afd339b45903f8c0a814c63f4d2cb6a6041429626378fd09f2debd2b601ef1d9bbfce41e98686768bac46088d7744d3d4ea56b1005772b29b558ec56ee779cf0007fa6febd406f49adf30be1f994f9f7301ca153bda430ed9556ecd2448296b25f1980b8130fa53f6ee90c4a42f79d8da85131153c98704833daa125adcca3e7cf7f2c15dcdee6e4db252d519daec0cac109472d3449267f0b091ab095843a6f7343ba0d5cbaa3de45755498f819f95c2b41e3d8fc6e3f05141e4a73a126d41d0d21f8a0f5bd9833ed849c21553d88ee4977a69e9fc97c3a531abf3318fa161d3759e5a68c23cf8093f85ea5cf44e8d11d450ecc5b13da23a711415653c573cf3fb513f3c71ea6cb38643a3227944135194dca236080373c10c0047fe42794eafe19f5f69cffe2b10fe7a704c49fd5aefed322440a720de1704fad90b479d65cde270352ddee0601b4b6bd3117c52b7a591027fa5e64e6b4a6928deebda9d1adaa1437e194a32728d6aabac0599f84f2f36a320390e61e9132e618a11dec067b30e048b807da1f2abd5d27f6b744fd90730cd1d81f4ecc17275d41f9fa319ef69d53c77ec8e426eef3207794a5af931a83849f9e94514bb6415e211e8f8c6f6552db2ae4f84fdf0fdc702283b9924fd85d80cf70ff00173986f6a2a1ec9976866d23734cfaad5c79a4620db173aab1990d908aa18487b22d1e626495e4e622bc312493729438527cc85d6f45e93dd1f132c15d14aef4b1a029c177a11062bc503b63b465ed552bedd60b3327420f9f956fef2d8971b7381e63e525295194221c7d7b85975591fa9e172215fd07410cba2ca0566d4f69eb7565275501d5f338996692e676136bac3553bbcfbf534a7964dcab5826ea849a63cbc5633c0e8289d1912eaeb430b3ad7af86040cb2920aed985c9c90bd0a452c35c7803a90c0f8533e8be420dfc88926a2968e07927a0499bdf8d3e8afff49d050b7726ab7c9d063d3fc1493db8c6452e3e8a35682d0a47dfc0d36a8da80a105bea492bb4b7540b816ebdd81c26c588d9d74c5925a7482b358ed7e3087abc3aa88cc9a93b211429b123b7bd2b3675d903c4d80d856b8994ab2a15c535147183bf63e341fac509d05673f6367d9e8a4cbceebf7924c84c63b7c7a718c277745729ced0553c81f3ce1450be8881e1c3d8cf4ba5e2c1865dec56a49593870bbddaff7d774098f2ab74f828376290d54ab95c29b00a48aadaecf0f0ded6c395f21be07704a47afa900d9d67f72724431a62ae135fe683e9b5641a59ba5839658a4f358b7b189787fa5206d30d52d07088311cab423c848f739ffe58221e24fafbcd138888ef47391bc6a03a7b6c0039d8d48d882768350700365c5330f5b9e308509598c37e02ce2bd10ef685cf75c41688049bfbbc3cd1789dfbd27a75eadb9442172ddcfc602d2c84c544bfcba3c77da061797089ec78600a373980566960fa546e60ca094d1709b4e8f299ec7dd97163aa5b4bc7a1d089cbbc7ff940c911ff15acb690ef7c4de79126be33da2391c72bcd136fcbfed1320ae3db6ddd8864d401f41c920851a1b48904b58875fe32e28c280ad4440582fde488e646115ff86cf0edec95b12b5fa21f8f2d33d13f4327ae393767a68ee90b574306c89aac329dc6c1a675e1924003018bb14b55abdc8429598fe485926fbb72a0c6dfc86a7ba1312ea7c0bad7ebd3894dad70971dca3950a8de5cbb9efd89cdbb31620ca0f99b3bd0ebcfa9891493d6c536e4e41cdc3105b92e731ba00048695757947e78558f3196178245d5ca4a80e37ff8d7f5b3f472610c42b5425f6f3f15eec78cf44cfcad5fa8b127b3dc09a7a06069bb5cb99cff7445ac4c9f512c33d0d0625ebbfc54c479a066cef5aa74aeeee1259fe25a552445b4c8baab1f7dbd8de6aa3f9ca945ffd99865f1ef6a422b12d179cdccaf86e863e47d3cd37b7eb3c0230cba3d53faec2f9977d872a0959626eeebc3803e78bc984b65ee52cedb12ef65431aea1f052e03a15d97a86a3356ba7691cde342eb012e600fe866d43362d53b423b876fc266a67adea5809832ca0263ef7763f8d569e8636ff2109047955de2df958a2e0dfe507887be398f3ea900d08460fe4a991372f0151f7913afa74785e84656d139fa99ecdb036da8d2fc0bdc66027bcc194a5406b357bf50721f02fdd9b46baa5a8cf0e45ae1dc6b4b145121b68b7ac5904f2ca3b3d2551737cdbfd38fad86dc2304d2d4557814e528289530f3f208662e614a4ae9aaf0d312b16dc1f53e121d44f266cfa03f843946696d24c8e7964916911a1f2b2a5e4c230390afd9133ba22b071fd251f5dbc2690c6f4392ee654973a4dfa0614dc9ccd3045f4c2697a1e3aff08bfd72a8b8a1af3aa24ff91019c18291613581386b5ffa6b81d4cd39b37686bd41ee68b0df413e155b3ac3fc311f1ce87086fa8b7621429a94213df1a0e6b9ec6c309d4270521acd8583eca72bd66ffcd2627d9615ddb37d3a045e198e81f13ea27e41872256f79e666fc91c11292f8c3bc2ecb536998b1fd12e475e74605ffe485aa840dfb9753501298df47ba5d8f6b5e8addb775565f87cc9f45b2cdab93d04ba310e6824445dd68bb524f622844b76e89ea15b573e0c5abbec8a3f6e311f2fcacc6c4e57ea5182f011a73ff832b6b7aaf46c3361f058d5739df34e2f5d459f3d8ace462156db31877497057c3a1a337ab49b4e80a31a6d86754f5cfc30c7bf3b772a593bc47b259e2288f11137852cfe6429a3d499f931ba51f5983b3ce7f6a0f587706b04dcb9eb2eb881a010651b4c7aab013a43524cefe1f6d37025bf09c02948df2386c88fea60db1ff5fad69e1d4e20eff9d9a8631dc1d63ebb382f2a9d82b84727b6f2f4661e250c96b170bb6d2be341c883b9c23bc81a5888e10d7a44824d86514e30738caf8d5d97bb9bcd631d15a1e435f61f12e1c9994927b014d785da891559c9823a17003ce88b7dc4a88dc78e8ca018b482b3804f15d8796e19a8a2f44813e0956b0b8ad925f76569021bc1295b9d4bfdd6aec833f36a10b14b0c05ec104c6dc0fffffeb0483be237f2290c0583e9095ca20b0dcb06a795b34d95d7888a63e27e2e0419645f5911ba8ebb02425db4b9d96671fe5634e4f4f3ae22304a499c6d34988c74604d1243a4c04e71f31c9ba18e4f06bad66c2ccfd6d8f958acbc5c7c5e34af5b6560bc4f12cca41c61d6824a701ebedc4566ba53d90a3daa639060b022148194de5fc75455db57fd6683af69c6e36c1665293448f9f127f1c85af6adffc833f3b0874ac051af002e2b3a0b571544edf9f128046c8de751c4d4f7af2dddfd7550f5abe1ae30352925fc3fc9c76f2ca82fd7b3e6a13ff2054831d0fb2b20c11b99968c03a9509037301dcaa20153a45279d8335d35cc0dfb6b88137a48aef091019578856903dabe657a8cb52611e80a9fa4292a24d4c95d78dbbc5b184fdc1b3e339c704d794f40b2590f269a6a4626371a0f21e87d5beeb1a6193baba91665912c9eecd441a141dbfcfa05d329d3e22bc3435b0adfb9a574d3aeb7c8a3ae2561ce8b8ca78f9981aa01546d4e9a565a44b80cf04b4c07a09e569995c0d9eeb46768c09f93ed1a2794be526d5dc1eec4eaa2212d7918e3208ac0830332efdae9d3d7f4d57e218e2be085746b1e463c321acd78f1c7e9ce17e161faa244a8d8d250866571380096a7b424c868e69af737212980ec320292889aeccfb0a36803e4c4ec9a7b8c525c207396060d5126785d0517076f87b57f6976018f7e81b4fae92635e1764333c2651a88147ca21de0ac25b13779135dbfd10b1267fe8347dabce17f7b14cd0e7d27bcc32530d396358f93078d87aa7ffc18a87d024eeecdf1b145167fb16cf350959323868071e815672b167d6504dd01beb2cef801bba33da9421a9dcd739d5c1e9470f8ad124ebb05f76ef821c00447d5ac4ebad75388038ad2769a909321591739acbdfba889b6558a932536f7df53240849582dd405ef857d1a55ebf94d10deaa829f57e9bf72efd0e49da9c26ec973de337f6777fd419a831ce9e7456b60bf513031490b128eefcbe04e2ce2710b798cad8653966b0ae3107bee8d2fce60bad720f874e4cb8d7b95295a8ec59d9b82c0bdd04faf1d49e04d3f7f345e87f728ff13bd5038b34de9b841a4cbdb121c6ca3026739533101d1200b90919ba5900939fbc03b402b1258f70c88ad1055b34c55bfd28653deafa895c76e5c3b63e36fc06a14b6670510dc48e48f8cbecf118c527c95096d264829ff30cd2c1d21ccf322e73f01071b9cbc5e29617a03ac84e1c0ebc8d123abbcf5aeab47d4749a89f666d894f7e49a7f43062a5884caba429cf9fde5202d1caceaa67d542064654e01aff1b9cbaf66fa486da129d3fc2aa0db3f08f525c2c5d20d686ef351b32c0981f3e541003d736c413a80c35084f109efad8325a844ddeb3b70711512ee3d4dd9e68b4fec51c5f82ae4b63a455eedef8b3fa593f7a74bc377f52256a2ec563deeb009200e6f6cd501e8205ac5c58bbd497e577f83d2bdbba6fe19814e54c0105e3b5ac90a56e96a34eb4f594b12744120c835560cee82ccc40ea2f312bd639b7d05c08c22894bcd9da5889a9a11c32b094e11aaba1ee275ddf0fac41836634b9fe7eb2501ad7d42e62e659e0e61ba1176ae1c8e27f57ca7d2e41adb3a795d2e188778847865ee7fdacfae1027779a2b7cd92128f968b476c1e3ebc691e44b950ec801f902233a6456a0e75a589757a94cfb6b1f049f1bf894626bf5a267e7217f68ad6f1a8fcb78c31929439732ce70b3a474a06302ffb4d2098c7815cc8c4498b129add00d622c4df8dfaa72b1749d35e7b479dde001dda4cdcec975ee66000e36fbb485f48f852ea5140a9eeaa371e1b54fc37d45e6239dd7f4a5c8146dc2b04b83876684b0cbea08786218b760e662f186b44f4fe0b754090fab127baa8261f0e2819e99461612f2d9726523dc2f5989b130907a0b0b67e7d7bad69a8ff7501ab9ce4f1ef305dfe2d2868a8c78e19928f073c46525a031b70752997ae83b36cd63d45d1d20cab17c5c4853fd221e5b84f5b81bfa7056fdfb836e6fe0189e36f9218664eef9f5514c096b09d2e79ef9665732708bf5eeb76c633035b71e1d5383d5d1d58f40c7a780dfa83d135492b225518bb4d8231bd29c589495e6c055d1380adb3e5c7e082cc64f5d3f9d5c569bd656e32a0bcf9ee13573d70b1ed35b50b2e05ad0a5bded5ef4c7eb6a58446bb9804f1bac030acc0ef53ad7155a91f5f2b580792c7c2e0408738a7215ba341290366f014c932d7cc83c7640726ec013453562b1d17bbe96671a074d58265d7ee616f37f00ff140fb9954de97c96d0adbd0ddbcaa0d6ff82b72db558aba26295164721e8e95c419c78eb5c60ec166574ec6610d23c9010d96ab6337877c07f7b9e61844af4ed39c7606a6827de59f987efab2f4e7aa65832e85de8938fa310aad5c37d03c0404144e1f9cd3b81d8df3fb4553c51de6b235b7a3fcb678c8215c520f8d69a922c54ac0fe015eb4ba08b15a8d62fdd09a777794ca8da9c67de7c79693742b1e99bb86ac985f71d5e5735115791afca496e42046bdf80cd4cff9ba713507f83b10b973a013aaa9fa5aeb4683c84be147c8b9f334c0692f1748c148121ea0cac9fe33d8181386328b494b32880b0394c93f0a4a309ea58fbff24930c56544cdabed7a80f5bc2902e5e0891fe341e50358f2769c8acd14a7d4fe0ac1b64c216aaa4560f39dbcbdb0330ac9bcac3f0ad08b77462e406c9b4d4df27fa8763662a9c28070a224339a5f39f0c3945121aaf81b012d72e408e101d008d2438d439244bbf08dea3c2811570aee25b5c46e4ed4423bee85525a09b8048cdeae13ab35910ebac1b69aec8f5a1e0bfbd7758ebd5d1122b4e4b99fddcb6340892ac2d45be32ffd3a04155e6764d185322b70c63678cbcf5a445a7248a934c903578a42d3741160a5b060148a38d6e85bf6024b3fd36a6daa4056af526417fab0b443f66af7788c519558ee69ef9172355fabcf50db76215c5372c3c19476574e8ad58eb9a74a73fdccc51d46ec95c4e7e098b209731960f7b3b4de77b9799b1462d4870ffe4a589b7077e50cfa4078cb353a2cacc39b8a3d82b4d46f8329b36d9d2786ee414b9658014b4f398a2b6d842f89e5b4fddf9237d69f5e3200d909394aa4a8d0529822da47a15fac4d05dd21437a34b58a43660076352f5697ba1871fa93027387491ac82b8bedcc993cb914198f89f87d49ded16be2eaff18a82e4e8a32d474cd721098bc05070db0d49d95b9adb5adc51de9b66e5d92167273e34be7fd437089663210e7ba03c8435cd1793ccc953999af3e14591a55b023bbf302ce19cbd4c5eabf076b359a56a999a4b411bcd7925b46eb4996d487fbc5b1ad7bf74894e9c180b84c8a25b4412e771ac5890253c2758c5056829006bfa7734081edc5e1674b16e3500f701bc9ba922942f14ba63511d458ea046ab6709a710b49dd57a2e6a7f0113429c387e1cada8f30b3862d35fce0fb3e24f8ac669ea982070721e4833152e69481eaffc1315f40219dfd4acb1e39f94f4313f24273b8e357b84221e85def75430db1dfada09a138b0c54e1bb864a45a152b981bbd2b22113ac3e27c6892c6e0ffafd2f6d9e9a99e7fc50b52adec795f861162dfb710367713cfe7b2990bc62157c0a795c648e7f800b36b2f9cd946720dd5be97098e5a7879071b47f1590c846ef7040b9861c6ea75be31e2b9af4fb06d50eae29e874e81c024a390fddb0c47e94f80a94b10b138dde8f03b7e9635612034e422add96d5cafec93c8036f017acaff2b445c2a20043af7a6834711e1a73d235b1a381cd00dc2e6ee46c8d69e6e2fbba898c159136d302433028b1964ced922d28478600bd83cc524f78d64960135abdbf39960008dbf2c82c131673099a610a2930635fcb499709b715d26e46385be7ad28e481f67e8b35b62c650ddbac4734e9156125fc50bed7449ea6cb5451d654bfa7f96f5e845b030799d3daf75203c2ad08524765ebc330ff6cd7d8d6b34962bbc934739c077610c461935b5f2b1279794839a2e46a854e73496f61cb84798fd8d1a4032ac83d0338725c5f5dd05dedd83dd5f6e618af7958da9f36574211434faf029339ca9ca16ab8364f8c8c088e253f2ceb633c8c1ab43e297488e852eabbd0d6a236dee99b56bd84afad898688e25f6ca6f71335d2f712fafcdbed1b80d634ad12507f8dabc9e840f8da2efa8687249089ba6daba9326356043fc884583ae1067471569e2d6a4648eb9dafc7e63069a812b4064a80b438b9bab67447e8a89b335e8c0b12c9227811160b3dda16f6e6dc78f7459f80eef071e2260bd8a5e55a1f694a9c3a08d068fb921f38b93820c475c2c533bf80f19efc9337bdc39b226c03d11c96b07e98dc972efdb7e105cc1806f624a5756ee6834e3fd680ff19490e55932f4516cc27fac3319bbbe01acdc60c58650a24296d72a2e4510ce750223e0b0ee748e8f1c318ab4eb7621b1aa54a4aa0966ada8fda73b57712386cae6dcc0b91917c8515ad79528a198dc126d7096cafbef5d1cff08c82f3c27ae717dd1f32fb61e2a60db9efc3a17cdb583174df7b685d34d51e5c11c1cad507e004873481faf3ff3501a5665d79ef59f5cc1fc06ba1edc1d9086737b8b57354e021913d630827540063098c912e4860a9df5697c67d5a7b5e0433ce4556bfd1d199b1889bb0a3ddd5f89bcf1db9847e9e4f300380f2428d5684f3ede5c8dbb29cbd3269d05a7d0eb59a2ad61b0ac16e8d9568d2c43d055ddaedbe45fa2424def35878577d1545e25bee9db33de1ed505191582d21b2fb6d6bd58bc30819c24df6631e123cd16af7b6e50261c6e79e25ae125ec764e1d5c28625e6bb349b48679da20b88ea369f19a55ccca115390ace5e866a05fe91e937e582170dbfd84bc67d922a351a2d1314ffeeb8ecd6d1a8f2dcb9b0a79a4b02db580bb4cbf52695e482d900657bf6d8faf0c42e94afd03e57412b42b68de78bb9937ed9e1ee3b45a3474ca7ef5ee9dd1b86aa82bbb4292ba309cc8a96e154037e1962ff56c37afca98e7ef489ab8f89f599720d0ec10cabcf3e807f8b3efb4b4687d8035f57aecbd459428c9027566beaa0144c408da293bc3ca43d58f26935064520956c7730e747860a221d0aaa0ef01a89400628cf32fecf1d29599ce350fc907599d5be9fa715e175e756652cf342faaa6cbea45d0de04655c162e7942864feaba545e57cfeede50ed31da25fdb8ecfb46a8a0f9144fdb831af214b59834b1262d3b7c3ac6e8b7c7fbe70e78a44b2d04b22c262c561003dc99acd547ee4000dcd29f2ebe4e04fee6b2c69d09dd27390e6f04215edb4bc79c66e43341aae7700e7849b5c4ec7eb4d307497f03c5386a490106e37969d86a45a6363b723e47b25b4e4fd722c83ec929dd0887a5d269f87a13280fa7365124cd417c255ebde47ce92e0d1b538c2932a2cd057f224a2002c824a369b02b0fcc7f0ac52f421f2520df269e5857e5fcdcae2a884f155150ab2ad0aa9828401cd6c1a43c96f8ca7c148af45f39590c37e61bb95a3d1c2e013c38aef745a8ed627b6e031443521df367d48f23ee6f61b809edb5b9232e130942a2e77e198b6a80463e0d36d959a712ae153b574aa529bce003ff2235ac815e8eed1b125b5996133ad3c22bd433ee34a0938068ae134a8c93509588fcd86d6d1acbe93da1b8d0096cc851ba86be4132a66c89db97a21749d2b15d8e9f576bb2f950143be9c2fc22d5e760c3a4eb5372be784b9f94128f197c72aaf31267c26607cc6ef5110ae8311472d074113d1ac8a092619bea2c6a9636b59dc4d27d4d0b4664f3442204ed6119c68a663fc6f99dcba1e867f8a539e83878b3a94653a609b45bf31b6b6e2de8a47b945646a1c3516e280802831ec0fba39d14a37af7b80ae25290d1a2158058d2eb5d2db277766592886b2d9aafe6e26e54a810415d57d07cbcad312adcc263f801cc9675e143bfee2849e8fc0118982bc8adaba01f50e2bdeb59547deced4be2f6b9ff2eded8f5917e143ef12007fd19648165df687510e661e6e359141d4ae53b7e65decaf2a7241579ebd26f7fd3cf32b6540a037c75e2bcb00657d07cdc22cc1cb5adcb0e826350e1c2e01276526587e040066ac754604f81ee1972c0eeab15f00ff8f881448ac9e449c580ce846319fabe5271141fa813c04cf3d9d8098711d8d5771ec31f0df106614cbe2f6f8fffcf154ceef8bbbb2a6fd33a45252451d5b0331a8d064295a84d2b1c922248215b50e61783a2ce9a130b1b6d1912b54061e5c0d84f75fa5da48fef139c0bb9193eedcc1cbadaed4ab19debfd9ba6a58a13905d398333462d4b00b1678d1cbd1066a36c1ac926010db978a4872f08fdd157b828e7ad4fe22687081d0871326f4f1a60ace2ff8fb47696cdbf1336f3a7121194cbc8b9f4ee52a23c6c7449a4e57933f8a6b6a98a0c7f3b62db131656cba2c91124d5398c83d9cb475a00f4733630a94fea447f50b501828faa99b8ed15ce0b48def15143e232285caa624422e4a393ce4bcad5595a5c8d47a1d78b56421adb595a43c55b1bc18558c928bf3b429e87fc910ca69bd93a00e77b5d780b24779e98aded29fd6ac265453ae09a18b40ac212340b6ff209bacf922f952e538a1c756ca799f6d7e24edeccbc61415234e50a39a172aeddfe2699a5de1efee19a681ffa6485d7badf6e90cdb78bde4d2b0fcd7d58dcb784daeef5103ee4edd4caa7e45dcbb16e0c378e2bcc17c23069896041075b2d8817fda44866ff563265b2762f444663bc4ef50d59cb4f3d2d1f5662c81961692675323a3c7550ec2c7038e3a634b8bdb0af293b1dc612773b79b047405762a186f1936ea4722cfedf94688578e6ef413d25a6308c95dfac7417bec50fce125dc774294b4a31f62d04f5b24c436e1fd68c1e524cc715d6ac219b0c553fb149b59482e70850150fb5f9713169409975cbf45a18f6448388ac0c610f79438d1809da22514df96549b77b8c086732b561abc468a267dee59258290524d9036d53ab90161923254023a533203709c18c5e29956614a4ef7dc95aad2c8bc90ebf6a14770d2e3e7475d624cae70674bf2752c9148606d7352d1b5b6b2b89505ad6d1cd7be1abe556f4d6b02e59982cb73169fd73b0e45f24543b06d8c3e170e38092898928e85627ecbbd2bd18aee1a373e9e0c5fc62a6c6d80ccc858b4d47c9fd7d9bc5d5e9e0ff118dbd521935cdc461be87b7b55fbd269c1a0c2189f6beebbf27470bc11d3b26d163b76a1897941fa401b311bf0c36fcb36d6914bb8aad2f3361a143d4bd08b105c15b75b2fa42de44f493bd0382c791d879fadd6788c93c85b25d11ccb3102b30e4e008f877f939762fdf351d70825f91d73edf538d85ad8878271709d389ab7ca9e9282baa774e2a388572ca09dbdc2edfa79c899807cebef45f1e3a287b6c21673b9f9424f0fca59ab59924bd586d62db91497f2364ab13dccc363b4c1a37b116172f05a5b7f1ba8fc74e8ba95675222e725f9b5b93d58e88389eca0f59ced3fa52bd64ee1e9d81999368c7a306a8a49d593665679658dba080a3a924f0030a0c847ae4cc0596a9ded763284478e8b080f0f323043ef91c9dc2639897fab771fddd1cf50600f1e744af3e432a2cadb824c936f741044e4921d08a2cb292334e02b5c10f627d845601585af7b7ea54d8a8cc660d2ab1819744e4ea9d905255cdc9d8b36f33bbea9a07be78d30d2f7793fd33a14f10b02726cf0dd4e1958930ce978f245e2c6f0a5d3cdb984f5c8ce6e61f3d7d56fc058178159cb1efb6ae9f06ccba09a467e89113ae57a826bc344f4f46c8452edcabdbcb392bea66792d9bc0bda8a91e8a8dcc8766c45fbd7698ff97b77f5c6702edc42c5fdd776019f0675d48008fb112eeaef01402735ee96bc0acb63c9fe9d2a5f617ce3d5262c54dbbadcd8d9453b5809d4a8eaf78c255b902705603ed86c4bde8c45db58757a698c112e4052fef3e5a8e51e73b37509e3cb66ccf26f9935cad50b1b1c8e427aba46e054cd5b2370b29debc64af6293a0be12703b47e7e84375c15894a1e96f26f9ace02d5892a6d426f17a68579a01144446d25f57a269b376f5d38b4627fc44a8aff448367a8b815f89188252f79fe643d1fc7f85b3709b9efed812ce0f14d3e09e0f77c747b55b7a42e14dd8e12949611ee1c8d0c5058c854adcad275ab3e8024108e203730afe6c248fa92abaf5b88b731d7a3382419ce15a3f998f6dcc3045ec3c3dafc156b48ef888c0ed0c2eced8a28e32f29bcb555c35e1591912b0251b17b7549a7cd409fa8460816a5525dad977c2a34a35cb128a327a1ccc7c2abe7de5ba2b690e52d5c68af0204f74226d2d624909e11d6fd45a09ac1788b62110292c98e761cf1d49f9168ef5d7700632e2fcb3c1338ca37ec2eb8d82b8df04f348fe9fbea4ea39c0f23e51fa4e5d05a0602d8c90d0a5904f93ea32b5f69918e26d35afaa2cb5135b128f8bb84ef1620f7e7e853ce9a1162c260ad5eb0478c87d0dd2d9c49be8abec492c89682a8cee937e3ce5b56ef2787a08ff6a5fa81bcb0b960e7dffc1281f121dbcea0cd54d34318f2d67f736e1aee573c3c250b7e5afbda860d69e926d9f9932fad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
