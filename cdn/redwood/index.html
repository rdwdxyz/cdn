<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"036af97db53aec3cc2c3c210eda628e8a3b7cd9bc592fff071e75321cb4168cf5d27d2d4fc1ff05584272dd0f824911d0f269efbca40ae30c744e1689425424287c9323f5d7e4b9ef13231244df4fd4a39f9ee157f4ee249a157801acfbbb7845c68db2a75f47c2ab8bc3be7169d5a1de15ad76746b6772c07ebae31f346a088f912d64362535ab8fdc8b847b5185cfe833308cf8390e0a8d0d4c2275c46762c3d2022665b98fbb13c257cd0bde11ac295520d5301cb26d91e8fbe009232d6453d62005f8da059ebd9627a4edec140ac6e55a529afc7ca2387d287ee67df015d4fe5262b06943a47218c89cd76bc8bf4b63826cc372ab0e1a5591815332f88a6a25f3028ef20ae4154f65ecc625889c42c7940a3b11eb9357ea28c3d22b0968a8a9eb9d7e776ba3df79c82950c610d5de2d98ef81d12e9999a39ad80c0bf93b377635df6d034534c2426ea38adad62037e7b07c34f327f68af785f35b260ca63b6ad0c94b2457fd1ac6dc800b8074db3e92972ef193457eb51b5d13d67f7e8aa31d3934b9d2fd40c024010c395fcccd61b12dae543bce098a99942d2f8a1b0c41ac45ec30112580fe26a8a18c27962acbc6bcdb911a65ab8424b522f07be0df878efa1c3bafd184de048e1534946fcd520d17ec284ab55909c347ff6686766ff1525dd06404d81c8226357ceb5159d685c7d81347cb1966872c1dc6ec4482e22d35c43dcda757dca84c0d07416289a858c133dfe97f90980de58491e7098a4cb052ab978effa25542c5ed39b9751b28d3cb6d3f1ed99355dc94fa14ab748e7025bbe434f3a8385c301c312a7f6fdb2cb6cde805a6d08be1e13d08cce9720f16edba2f2be88ac3a06481db87c9260d97af41822f0206a41fe297566992e912f764faf0da88ac1989e46143e7f177ea57606b926bc7e90e2dbe9e4e5f0b31c7402a398af93a336874712146f52a823e087f5858512a9ddedb7e48afdf58df7e01a2e970dd61d61ed40b6aeff5fec461f3cfdccf1a9ce6cb4c668379b3c87a71a83322e805c7b2d945fd0f4dc691a28632d7d3ee991e52ef1759eb22bc215e82c75572c33d8c3f11b85ff9aebfc1b8ac9ad0c053821c99b487ef31004d6dc0847913b29792ce211f3eca92b9d9e6e7700b3708c079a25f47c6cb1d08ea6736d63ca92a298c34f0fd290fe658208e8c04b0ee7a62fa707a96cecffddabd09c1236e7af2e792e41cf81d779e373b58f7cf6ace2298fadd0a7e704eb51c61c20a05c7c238efcd42c759c3f7fe620f90fb4aa04d1b74bda37a6753736b39f335ce4e0d9404cd7a3d777845c7c5451bcb86a1e0c9127b796eafdb3e08287eae6223e66343125de0c72150910de256b60a90bf69fc498c626fe91108b10c94685546e7d23070e2b9e975a0be4a211895f27874e55d573be866b1cec899d73a7854b1b4278313f443078cc3d00a5f8093e0c7b224df7da16081c983eb1a46891b866777d4094af81de2dd2dbd76c7ee0272c798bff879708b6d9bbd3eff7dbde003a4f14f937773568555231159168bc8b7ab61f71b7841733915f56e50baed3320e42ed3c66c755d0aeb464b78db65c2aa0956dcf88d0abf26946bd230b091e2e13a2d3d4ac27a742088c3e6a4037e22409a234076f95f7cb0ff8eed819c2344bd482c8297b4e4d8fc3ed64c93892e1eb52f3ea9518ed56f9f4af16cc7d55bbd114b09d4e1cbc12181062b7cc95e00fadf320cd3390a2f4392f9a5b6a07dd1276d907447651dbec3f4f45e86d4e6fd2a208fd5feec9755de14d1bc9fae7dcc5e2c88915ce481c1360c19e304cc2ee9a06b1512596c61f7ef32d73e5476efc6d2de1a360e7a132dac5b90fc01977bb52de6c048ff97ba76b68c0340ffa873112132fd1ebacbf2b8e2e3eaa133f58e4ce52cfb0bd2ad87e076a6e66e488ffb0f5bc229bd35acebe4a529ac78191ddd209a8c4eb38ccaa04834a7e67c079d42119e107ed4e64e2ba009089d7a40b917009f49ee35178457d72709c390ebc35c40a038be173085329413f5963100ed950a1f6bded661227ad885b92b6b744a2809b68ecc147a67020b076c22e176d3d34db2f49b396b9b776b84a0ce04834e9849323862b7d8e5d2d9e191ba2315f6da0b854a1a5ea8fbcb58e7338632251f12fe4bc5c9d678fdc1337493c5ca1d7486be7572b16cb0c514348b064df68f2e222c500eff218367936e82f0fa0ccd81e244d0c70852c03c954a4a2234885123887678f8f2e63bf46035626ce43e0f95672482cba3a263f127c84029f04c4984656ad4ffc79bf2b091432f6c5be3f3c79e7631d3ba63eef73a1c60df232ecaaaa13f96f8bada06e78812845f7dd1e1a5a8c3aff62da27a8990466ad3491ac9fe92ec544257f76a161e3be50669864f60ecd2767d5bb42eecf1d645884248657e0ccf518cd30baafedc80860a4f5f0fbc2d79076de85f1f608b298864fbf10de5f2f438285bdca33e3fd4cd3ad473df505de2b2f9e93757196ee67cb5fe11729ec6d4062eb3d1ff2dca70df2e9c06b8695fd0f77fae452377790304d41f30c867bc191138fa543ff518ec9990b4f0c0a97a50b78da1b047d82abb42cfb76056001c7000513d26c0afaaf2206631ffd516b7139d95ce8d391a28b414bc737c173d6a93d54e3d8bb49a7abc24562f460306a5724688895b0bd9dc0713d2237cc2d33de0dd0cc750f52cd2bbbf72cf0ee1b26c24c4d03a8cfdd895045df00acfd47507ae8e1067b1f5f45ad051b7255e4a05950119a51982ee174b58d2b34cc21b15db9e85ac79674f9e5d47c2eeb7d838ebd08cc775190d6c2cadf1c1201798ee9295e79797f2dd4133a9c9ef613a896d08e31e5d9a24fcef4170908cadbb68ce796c99b94097fbd2a5c0f338b4a6b6aabf52b3cf846a4d9d85f717304590c4c458bb4cfb1219d04a5494b6a15c8884441bcd216b74c4b55c338744ceec31b6e633ec335bcdaa6ef9792e55a414ac7479ec6219b4f7c2a4085ae8d620d4eb827108bea5def32df8546731ca8302addd2ea895b7bf09e519f260a46b4daba0b3785749bce0dd99873db3e7184c6bd39158f646bb311523493f30c2780d508b602823be9caa4804dd59e51be6bb16cdb8a070319c3e446e783156234487fcd627015c9dfc975834f518aa52a1306274410dfa304e5abbd81c0b4763dd5662d0ca55012ae4b356afb1b1020d64dc30256ad3c182e1e0c36ff012936c76441f8629269900b5657081d726cce037b0b30fe347acfdf0a637ffe8a9315a084a7468255642f91630e42ee0cdd393df6dd1a59185d07c56305190ed2f83df39e11530bc6dcf60a40a95cb08b109a42bd3941315caffe44eac406c753bcd10b880c35bca318fb3cb526da1510f1d90bf2a549cbf50ee2efcee3a981bf7982823046570812d248b370f6fe6b983f06a84e753fd7be322817fe1017a0461f2a6b284704698905dc5e6c59995e342d4b13792b86e209ef3a395790ddd19d6f26f73e34ecf41d05f6c703f2176dad7ef785d3bac0ee7bfef1f4e65f7f52b8fb60436cc995a8362f6db1e0c693885e378784c23e00b68af1cf4e4adc8f889672811088d0fe9da4992c889924cce2dff52fcaa11885d7613d9416a962c39186a65bda60769be752159e0d3474f8a7f09d554e9b67b237aa9a43454736caadbeed8e906accfd78a5aee460704a9ba4dd55abeabb47ef60c6ac854e6ac589672fceef4246fcd8fb4d236d62456aff5be03a912b02ca25befb5115475fce9c548210404bf3174cfc777959aba9253eea633056c7b284e5d43e37ba2eeddd86907ffda61db2fa4dd0a1941cabae2c689316cc991d4309f97bc7fd3c6a1c075a58e2e719bd2110dacdc15c805045b17d3f6556902a74053b98e2ef8ebc9baab95bad4fedd6f5d59b2e08fe016af5455c30e5e64dd4ae28522df087853d35c90bc7ccabea3736de1b57328294b714a10761764f27c9797972f3d3cfae596c6b9b5aab7d5e089ab0cf13aeef5a62188d3ebaab8cfc288668cdf20c174c1c51532e8778a95ef4874ce7104b97095e6286be573a4af5b1de4e5bdd4f6d8d312ccfdb78ee9c7ee782bd96b4a420cea4df4e417d2813256cd91669a950450f1b81de32b4e6ebd64809afe6ca0ca68ff61ab8d58ecc34ff23fdaf0ee571027c242664131f3545c959e26fc587a5ab6e225da6998b587a0b8baf6d712861e3a5ab04e5713d1d9e5c9c02b6aea5e107a7aae6962c0affb0efbe248d0a9ab528f0e6528761c555faf2d9f71928bcd161c8cc590d4c9a442d1ff3f7bd04bbc87b2036c694779a20fe908f02f76c5c2db3cbe17aecfe0c3a0073bf08cf561671f6097544091438f5640ae4834c1eae2cc91eb7d3d17fed94327913e46434d775df0b0c64761706f141ee4c3d3b801618ce76be725e103a5d0d4495c989e0017f7b7c276ae8533486e750add0f387033a2ce046593f51e1b1410b4e7376d4b9939e0afa006b1598c9a8b15bc945d4d5450cb27243aed04d684be10db2a90a05bb199b31f77d0e02e1a2728070ed59e3416a512804058fd9410fd0be087b3198a1544ba3a28dd4a34078b8d892327efdbb57f6ed1498d0a8fd7f3af541d134fecc6b4d029950fe1e08c4457899ecfcc41732a830902fc2a30a191b0f49add9ab96d272ba738a3a34c092b3c94a5e443fe80eb380857b8c23f0190f75d2b1e8e32886d5f0f8f8a3da2f9c442a89e68205368ee70d4aa5e370b56ba072968c9b4fcce958c3f536406625732f829faed9a95a97e9b4b275defa04eab173c613c5e0ab6d6f3c65d0589361180626a3d88cead1edd85137a0840f5d0dc0afde8499c5ecf167ab76a3891360f38e75e53d3d50a28191b01e91b089957e929db70b581b8fbd0ed5532b1ee4c0d32916dce4d17d8579e927bd5d2d5debb28fedf720fc79de13369ddc58c12ab5ed3fe386503a49e8a9f56ceea7be7549f1a53320990296945dfee600cbcf506abf2b7320e0e1f88996df24ffae68308c14dec835f1283c200e700256a697bb3b2c2a4f1fb6d03de81b7b6441a51b7874ac6330c9d606b8c47e816749acab0ea50c23f630097fbfa3f08cbad56aadf70766f4ab4ebb8a489db704a439455189b511b581e031ebf78d43a8bfed6f2950526371abdb9709570c3b486acc674e595c464427289060a35a8af1cbac33f6bb1e4851978376f2c4b4e41ef73c5498b789a26eed43928dc171edcb720920fd62d66fef71664cf490f3f2681da8720e762f1a896b43f41d37e32456a1e86d788ac7185c556facf6e68146bb3f2c7796df78988896203ccdb2f2d08eac8a6b1225ba688f2388bb744516269cd584564c8d01f8709e5415b03b78967fe017e08cab00c38a422085206a02b457f20021fcfc30c23aa3e9a266748087e36053073c331a8d5bcc91163151eb756cf0eca719a138727b3f111f1d657463cda915f26535e73470bbf5a2064607f5b512a9f0b451cff68b137f57b6fc2ded33a4b774d499f70f090123c2e556c92e7baf98b2d4e44096f249fc0b1ce2366e543ada34bc268710faa786ae800d358a123eb83127bc5524f0217765babb53a0f3f411d8208146cdf306a6baaf722884f11221aea6860040847dea438326a74576efe265a280120a1f6a638de518fea08d88a2ad4dc38e60712991f918d7b508fcc42eb34cd906fd3dafa408a64451c8bb7f4219eb445860e8a209e4e805a53561bbd1edb3de9d45424242435734fc4cc340fac558d54fcf4fa7a9b528b782eb2a626ec16ced20f704b84370bccd0390e26dbff92ef6a6eead95f718632ba853e5885a35dcb7cdfc39d16fe3ce442a883016719001a7b75d2d67c19e21ef8ba3eb865e75bd8e27ad1bb9b5c671e05004e9696c20f43a2c93b760c380b702d6971806b44c252fd6b78424498d5a1196a8e13e0d43e294626e60ae6d7985b34952cbce943201eedd26e7ab6600d582033b3fc21206eb1641ca883a7ee65ccab0be5b1368539497724e1feff39dfc4a7694eac916a0ef6d6251e48550db497ebaecc2b37b0176768247cce08a152266af44cd55515ac6903a2beb4439b565cf2d410cda2785f59d44e88cda8dae33f0154d29f2902f39fff5ee5121d43a86fb3e087cdb94a68f8727e42b157bdf74436254aedd12b559dc087470038875a9ac13644aa533d06c4f2e0d7530e3614c55988e4f1bd6fca85033b9e67a52d82b289085dc1aaa1cbd8553e21120c7ee6f73b63f44619ba80b25311967ce13aa455063e7deb2bd954c3bc82650bfe63f31469cb54d86a4719d0d0d199245cd597efae658b7cc90a1ef1e86cb11043390ea1bfa9c3ee19a407d4bae5bbb839e41838768d5dd37a2858151e74d8498417c05843da847f646670f393af22626c72d8be7ac2e6d56520afd111fe3d5007193010a69d3f0b7acf1cbb0a66ebe88702ca9d1e3bf2c48e0b3a1d5ea5865c7e800f918906f730d3810193a845e2d8da739581f052ff9c472203b498de5b9a29ef0e37e92be3efc91f75cbbf901bd46a186cec92ef95da3c1f8a222490fd7467429792de44dd3c9fb397472c1da235d434633e60d813442e398a90964e170164aff11c3f48f71439d7128e3d20b5cfb723ce15cee41f46db64ab4322d8f46d1d8d85698c0b4a4ec1517e71601f4aebecdc3f1416b1688393d2d23f1026ce6df855362cdf83ba0f79c53447949f3e08002ced59d537f967037cead32e6e17d7152c6050185e6583b9d6912a8d3b71e39902850d2007dbc90d9dca00e79abcb6bec95fafc75fe8ef10ab92f3253f03b6427e7e44b33e5e28429c845c2c4e3a527b2c47dbb3d1b3ef089d72239a61bbb1763e13d465adeb301f69d1104739c72eec93e1a629c7837a5b17e595ef24e1ecf61312acad8c443d987d2c8168dbcdb8f0785642b5ab38519e5b5ed1c80ecf1155ea042ddf2119d1a7be93e35fc351cbcc5df7006eafd807fea672b01ac78f6594509fa42928049f8364c1a6a43d70cf278f856992721e71379eac3f7e73a968b0f7747aac0ffef32b7689b23e1c367ef7c40d09a1b689ad752cf8cce415a28da9152f80c1e024361c4ef84e71c8f9c5e353b60f3a90b897851bfbbf48c3a0bf057516d2342ad09e7bc56c3918532ada00eb47b8fcd95afa1fbc671b50f3c57b9c2a6412382c9527367e50db2013bfafadb7c56d56b33be6c1329e94fcff29470c28ecc42241dc69bf1f49b16a735af84949c785e34fb7b704e82a4d9f5e7f7b2d24bed51deffbc467ac8feeb84c686ab7105347fce8c28b23549171a4d0c42982682c16f5a5494eb74789d30555e7276e7f50fb7787ece5032fdc84c8fab060b33ce121aee6cb8de61fcf1f71e4569ff02b8f2c79073f7678880bbde1a79a3b00740346395ff2e67bff7927019560689a18785db23cbbd52b303da2fa4f5acf1077a348fd0fc9650c1829f0543b3e4bd6dd69a5dce8e2c1cd2c5a7163d04b57b91454093b800b24191e9dfceda7f7ad406c7a5c9dd1e71551b01d9a8e1feef1cf0155ca23e9dca4e7cfdc3f429033e0e6c55b74712c2b3f0253301472199e54f8344a9b06c81395cc3baf51b6c6d8c0ccefafa92aed6d882c2c2f12984e211e7429925afe2f584da2fd3b562b37083422dbb199048f955f8edddaab436b2ac6057edd4a277d6af4df05b8538d6eff93299ccd96257117bbe4019dbf632c3a5067411ea3180cbd0944e358ff417e090c93f53410434f945f90618a1a8e414c64a3cda2d4f790382e9795cf7bd7d4e6fc2950b58b08070ab4709fd4a435854c9fe9f41374964425dfad5835d0c1da7f7c36258ca0a4f9216f0780e79540f634a621b8201b6122c16283468894e90e3d0643690d47527f176392a265cb9a196f4890433e0b733d1bf137a3676772b68f211d5f54fb27249a4c615c73b05cca337706826dd3b6c38aceff6300ffa5f65de2a0104ce1d8fce7da3901260be2e5b3ef89d4de61905861511d941077b61bdb8f6cf969657f168ac0b1cc86a3574feb686fd2270fe46e00391a1316c6f28de4812235e546e2b7a6411037cde4d79e70a2b5da583d7e37be96dd17eb21590977680c29877139d317bfb495c3d63b2f84dda9765febbd7102fae8ce0a0a80ba1e6561999f2d1424f422f6996d09a0c38b3f29382c4ad4332230345bf239415d1a444c2d81a15c183dee6a4edca348ea9afc4e73f225b89f606669367a9b27d9f6b87e3fcfcf8a4cb62116c0abb036342ffd1f3e2c283775f3eecbdf95989f5f66b47a91ec5bd72d6ec796f49ccddf76f1101353aadcd749e5bb4fd46b8dc52a1a9ea3105af666664bfc4a57e2299be69598d75e43abe55d2c732b2811c60527f26506ef477efa4d68ae72be26e3e3ff1d047498b978e890aecc461cfe363bb4833d3d88b6eb1b0513552c13d60185e9cdf85dd896fce93bb3d46932f5fef69c152d1db9cf56907cc7104a65e4c30acd28fe8368e06ef1e84f00a909500b7d820f67ee9009de0118c4077d1c8053aeefc4ce39cefdbe135cf02fea68bf5879ac6ec2964522d22bf1c8788ea81b4d10dbe83f42ee0763ebaf7a8a3f87ebaeb87964da6c43a8e8499dedd6a06f506b898883faab99295b999355ad6e30d48333f192f7c0733c8910daf19678b10f637c30099419fbb9d296c4335ed98fef1b74e617be0ad2792717ea278b25be153cdcbf85825f128ad42478af5fc81454c35e4a9cd4284115be860ba676621c25f75d15e975b7d61e8c53987c77b141d3c365fe8191c534eb4703a9e23c26b58a2889469cb322f641618970ade82fac41b6118eef6b9a53fd4a7c2f8978e0367adf945fe3ba612180d7c616aafd127d5bd282d39504726f1ff4f8b011c98d95e60239eae908aaf258c117c5bf070eda11c6a3c533598456f11368225743c6b8d0a7301b4002de7d3995683b35dca18fbd0a1a7cf6cc358c92c0e45ebeb8d6b6616f552c36d2be00ac4faa3460d4ecc6caf0b6a64b3978ef467292c63cc24a5d9a9883cde45bda4906f895697d54ca88a3bcb8e9aeffe3f1ad7b7b39e15a7ba93c1ae7a5b1be4cedb1aebec693e56584bba0c625156f4f9eb41d6702588eaf03ca2bb884fb3e07ef071957b46ad692cc62f24bc9696a7e2f5d330cbbf315d85164106daebac9ac058e277f2e2bfc412b8b70481e903e947063dc45ff97b19dfa405b392001718105a1e20ec1c1989191fdd4c1246c01090b7170a64b54e374c1dd030d890d64f53afca026612f447d521ebc59d698cfbc180020ff7043116ab0612ec17de6130f8bb7d8786d8037e5934afe621a1aa691eeaf57aa465ee9c09274539670924b701eee9c65ebeb03b070869a4e9130bfbe72af665e2b1f86cfae8bc084b31790e3c3a6751e31bff5e3fd196c29e16380614bfe65e47cc0185f258eefd1285be1dc644308d01b4b4192f9829f3c22d1792936c3d23afb18aaf5f50ce7c1877bcaa4efcadc85b6b00e749780749eb6ff044010a98e4962a2f32332efecc5d7faf010239d24586d1f5bd22ddae26f51893586950d58e3fdd3c1416ec505534a713ffb28e0d3b03ede795719c7fca7755ce91bd0ff8c21b56012463050c4b2cb9edbbdee9682c6378f383ffd55199b6d459227108761b946ec0cf2df5e96a0d1d58a0da2de4e2bec0c2ea7c5c4f1c743b6871dd20d67a8671c4c5e0aa5d66990fcaf7bcdab6fda58eee03862eb69c6ea3c4446d016ff6e7b99eef6b6dc90c84e8f0551e55ce732533d2786d44de417323323523c41a5723272d662078457b0c8f8c68d25e325896f73684cd89970db841f4e4d175f69b81bb8489af49354f5e9c22474eb32c7d664e71603171354cd78db47e63be8353823b2f68f78f94ef884bdae8f6ea724049d6a87d2ef1ef4c53d1b9faaa7bfd49cebc70ae09bab7a3e09bb2cdfd60f2fb1ac38e98cb850b9af9295a51c09496aae851087990c5618c1593b5bd5f013b54276192ec6d2a88570615e9572c21642013d09d654b8f7d1b0301c5132ec07fe81503caff14ef39551277f2d9787728eace0c1846f51aee87af76278f1b24fb40be77e85af74c3425efb5991a95c9cc1cc1dd8496937f95133241e9bcc9aead3652143f2ae7ebac03218a9c4144ddbb96e207f9ef86d469c600cec20b2fb55c319020d870cb44ed33abeac6cfa416fdbd1e0eebc1564c91a345220770d9ffa56577cb30c351fe6504df238e2d382d123a9e7b9646d1f4575ec5bd975dcd9075595d58beb95f6fe795930a616b2bbafcafaa1f123f2459cfa365488c77f69a96a5d2c0a274c1520aad368779fe8a306261bde103676c129ad4357d0f092597646ccf7b7a1365a609b03d76c6929f7473c6b839dc37be33da0fe17a260ed41230d7d4b0321cb7cb04bbbd62c28853b8ec81db5253a2a025531101d1ea845943c542101e8a76970ade7d0bc3e30c6bea25a5a2e65fbdf34ee9cbe4a19a48f06da184e4e8f5aa419168e106637491f4db1dfdd1be8de4905eafa1b98e7d259c275d8b166084bba57a3683c474db0acd3743b4b7e9f6933cc9c7ba506ead4597c9fec6d1409fb9c7fa103102424d28758b28e976c95d3be3a01991df58b080a0856ffe26a0f02c56f0fd7e089f2982afd2cb700d5c94988854cab876a345e436c666c8e860783069f5d58047de4ca760180099aaa2ff6d48deb383790f67429c1624f8c1d8a5a7a8900eba0f3a0618d888c19deeb5114b9acd1c51bf5dc92bc708f7e593a773ee1bf6edb2dba14c1f8cbaa3c291f9295d909702628688a16e81bb8e27f6ff4593f753bd23f63b7a7c1249001f55347ce47146a44d8d4a26832240a52d970d881b4aa2d0f0ce7c77c789e9b1ac56d10c7152ec2c37b53e128775d08307078ea7853c8ca114e97b880c0f8ac6c304563be32896378c44e5905a1efac7d6e6b37ae8887bc77f38a7aacbe5bb4119272a4337311ddbf760fe6029fe18c37b49c79ddde3ea94d481ef67d9d7f507e0146367e79baf65baaa1b52483fe1ed6e701d5ece237859c208b1697d2bd816163cbd02173fc3ed2cb26bac2ea0eb2ee378f2592b30b9bb2eded9b52ef0782c7f12860420da74f7ef4940c600635caf70dfca32e2d2fd9a71d576d7972612f2fb959f4ec92b4232c66d78e7582f9a335f0f488a7f24e60e3897a97b7ad6c21e3c543884f67ac20bbc3d21466a83652e59805efe24b8c32900fb131f32f5d5ab1fc033177ad3746b5e198f6fe2d07c761ecfafe4cacc102fa779420839775c44b30e6cdd193c97ea1186c9276778a31c9f6a1b66a7c86058c4dc7618d5b1f706827f039234278b0e79921dcd044bdea96ff9f99d3ce2467cc4a4fcb9e18db8715f6556fe0de8bc151200e1dde5642eac2072ce9e4f1f071b72cc521068e3d575fe15074ea6308f2cd39185cdda7443918c13e6b634b72d61a86909aead97a3e7597b9c175e20bfbec7de6b9c2becfb083247081b3401f49a65a73a578e888aaae27ee973994a5e8ba89a304946989b65d0b9de9dd4931f07bc5d07120f601177345bb6a683991285fda560c7f0681e934d64d6c8cd4d0c7c61c20765f2701b2a04792025a171a5dd51a5af7b95c926893ec523e76722c5173c0e6bebc835fc6ed4ef72e29d5d0db0a655fa4c9e8d47ecb5312f1a9608df05f94007532e43a69e396845458a491d9a2014198b09c10ab62489e3eb6bd4d39eb4b4cd08dc092cc85b5c808c06a0caac31b56dda32f4fc66d1224407532f21c5368c212073ffab3bf6b0b52eb26f5b5f90c2c0dbc592493d55ae7657f6b7036033c6b5b91f27c1ccfb3011e0d2e28494d39b251d3a3648edecb8136e89c4f0598e23029f353c78a26f1d98ab2ff63d87cd7a6987a74b147d088caf0888f6366fb222119d7896b6217ce248e3f0ebbe3f73766ed6d24200ab7b61b1c0f0d8601cb09b67e2a710842c7db3baead21cb428ed9f8f56ef8245a1f8e25776fc59b3f0ab04ba512fdca9e98a687126d84697dc4c1b9fa60acf90322180b6be6bb508378d66d371243ea122a5ab0c1d45375fbc7f129622449f9e7b311d72a6de78b49b57830e16e876636bbeabdf4b3d95c469b4a1f6092cb8541356bbb6d40ad0790ceba9007137c4e9de8c9e0a4b236ed866383f99b82ee86f4869e783381458ee3049c89fbb8e17c67f34d265d0842ddab9c067f90e067f7960a2c5f4189d6e6b0d59a97dcade4a8667eae20597c15b2791077f3811c6d5d0123635ea40c38454a00d8319490f09cda85f8f41db8762d736f45afbba60dfeaea218b83cefd6619f35ecf6923b6f3f0683e36f2bf65f4031db3540a8c5e8c5b9563a8edc75289d11bdfbc48e18e0e6b58373b82c421319ea3969861dc8ec9102fff637e7f296d981d00d9e3b546dd6ad660e717220f429dab2a355c49e640c546a412509ba1b2c9a7d65c370c3b14335d674bd0b0f2c712ec9375d9b8e4bfe2d5a9db5ea0b5e0e24c5cc163d7d1a31fd87da344ff44e0b8a14f71d85a163f515f06378a22ec6d82b1f990946669e9b10cffdd9871303b393ba285c3037f7b90413955ec5e9a3d70e11a7a9d9084b0e36d6738d3597deff79570eb59ebcfc71fbdb02855e62ddef81bd1d6351fe63ea370fd6edc0262edad9540d4bba2d833806a144f58eb00d1bbdc85ae52340a64c671d89217b18d26b23d811babdcfc153f24e3b7b573b825c5b473b837cf9669c2eb651b6d29c56c20b4a082ba5128324803157013ec95fa929d5f9e39d3ccf7f6e88d839b199626669c4bb2f4409c37b9ef591c18e79c2d9dc0ab5cea38e61f67073aa811f18f0692f2aebc4763e770dfb722a14729f54188ea6739c6c0a925e89ad9973b5e10d94a330f65f95bae85bf479df9f904d58d06a9941d79987edfbdd78cd0bd082d2a59d13c8b7e79abe1dc38d9f2dccb30464688ada8495833034f395a500d931c89784f148f044813f94ef9c8ea528eda9f8254fad0af782c65b5f9d8b4eacaaaf2f4365e0a0345dfe13240f648e42116954485efd81c43100891d951b5e573c4c00d1e3636dd23744709b470e2925cbc11b8cbaed064b2a2ad918bd7f09449c8c58f35bfa23a79b1e1dc3245cdf4a18cb5af0cdacbcef341ef43d2f229e7215928fd98d3fb3813de4111702cecbff0334de8b5c17d3b000a8c5c10e1e46d08b407f7fd009e938b5a80f1935f4187950bb9f4efcf4a80b91cfd13da5ab8dc8a309dced561ba7c3ac7341a0e0750b0e4cadd2a35b8bce4f40db49c20ff4aca339ff27b5ae57882b604ab5ece472df4de93bd479d7d702f4cd42e3c1a81617e80ef130846f58494da10e18c9c7819d9b1567b875059ea988b65384c96492818bd0a8bd6f6df47ac52b19c28ac19a6e009f28deb833d83dbfc40303799618c5b3a19fccef4f9190a2b32ee1a86d21d6020742e217b9e4d7818f85f9e73e2b20b1b4753f4c27149fa52459fe5cda3194d8ce13485e441e2c9258aeb831d869d9cb09011f07b9b86ecffc1ea832955abac13b4cb8db824e27bb7a7f7f3b687df0be796152984e19205e1f5e8dbc4b1d744b51f35918838f2582ac107b9687da061f7cc593530a8487e48ff814bb0cb1ccd9de8369b65eb168ea5c6b847faceff5ef0f4da4e37daccf9d5da586b5a50992e34ecb58bf09af50731e4b7b8a02cb5838196ed270eb1646868ca288764705a3b4847a1e08cdb2d451e6d5f6e4878713cc20eb44424d8e6e72e150d2f6411873bbb9e0634043a89059b3e78c87df0a57a3047953e7fd5b0764b5b19c935908f173429d2153bf2236522d66748b637081b3bc60f044206fb2eed019416a1f1ed4cdd3f0e8386b4de779362bd7374163cbaf7531144ad30896086aa51e112c743fe29af2aa1aec1a807596fcbd1d24074d105adcefa01bb2a2e8fb21b1f0f7f25415cb299721c9a06041883be5c9c0514168b2a250cbb050e4382b02595f39f15971c6ee2ffdf5766e40219fb2c537d4ce381bb5659f768a30bd3b5b60a921829450d10bde963513d170a632f4ca460f94c3b93ba15f2f4e5518ee62a9ab3d4aa171ce660d35b4770b0ab591701628ef883abd286b368fccc4aa5ef410721ef45bc64e1f0caf19743f059220aafa752127a08c00577f47372907f5a91d38096a26ccdea0349e751776fe5cf1d4ec38c36153cc800d26f8c9a20e80c671b3c5bfcd5b1f192f4b59708ea57f58e8d566c0bf0ecb83044b8228b1e2c656616a3e2f267636f1b322ccc19d89c819ff3417e634d362d7814f884ecaa179b094e4503c559a55f75c4244057f853780ae19265cb6b7b72e01d812dfaa83dac6cab3abcbae3c0914a37a273de08c63556714c701819e323ab0f5a59fdce156946e4032326e76a02b9063dabf279c580a942c39ef7588670858a33a27fe85554b8af2f2e3800aed7024d5018b2a62c4b84d0412ec085a3aba1968a7fbb65a8d2dd1a20b5201abd0b38476078823ff066b8dc9885826af88d866be7f29e5416146c8113b9061c7841d7afeea9e582af1242db1b57d0a84302f82802c8b7189da4dbd92125f91b77bfdb2142c80a8ca89e702d299ad9b9299278c13935833ee5e9b8355dad3652a5cc48a78014e5b2200323e3fe569941f0177c77212b056c171db17b58a19fe10f89b3c6968fa7e51af050ee064fca820dee6a7d42a9928d605d0b2d705b1d00af4f5461ea95f80726b1f2169d99c5c71500f80d48152781824a74e72f52d47ff335d02b126bf340e41b6d4b8f7164e20f4c400aa68c8e3f9e75e66cc6d0b97ac25c51f8e52eeca404fc094e67ae0f4ef9aa57bb085e101f6bb30f67719433d09f3cb8a196bf24403c7b3a73f84a60ecebdf9e4dc96537a2afea124e940c79a83e4050333aede65e79848b29bd86a4a10285dabd5137e6cdcb7621b876ff15b5d1ed6d1185d8fe4ae93353c567a1f19af8cef4e8704fe8ee7c850a0a0705e221ee30f56ba63fc229683a7fb236b6c235aa7ee953b879de83ac41d0a9cf8f8dbdd14afe647e55613e9731dc27d496cd8ef64db19b23d28cdcb3149d8c7f2f6caa7289d7d29a4e57bc181bee9999f3b074568cb337f1f1b0315cdc6bb12762177a7467042fe7840be9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
