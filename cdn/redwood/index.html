<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d028a4e005392ac51bc4239ea92cc4ea8816a1fb1d7bc9468f03813cf12aca2a758272594ad9c10044fad60afe449ab83ff1e841d2e798cafbce605f08d1c64fc90519dc993937d4123537a3b264bd57bb48cb0f77d3a719499640c2bbce60b6183a0bd4c6f005b88a727d7a9821f40affaa85877497d04039ef9f04008cdfe3a73b8c296d05f31811d56c3d1345bf86492289fe252e52e7389178a4d2f9519ac795827ecf43c90779ada11708046818fbc38f7cc3ce6009536d107bf8a8dba6d930d5d3a1a159e0bc7f8c1aaf985525cb230d896271dfb5ec5dbe44b55d70d7ee7cd24b3fcfad27fe90e78f93367d53c5c0b09e2d7c92339374cbdd1fc43ee2667a7d79e1c88780cf020909ac8590989fcafea3cc55954201837ee6d6ea838e760592a0c9a1c5362a36ea1c7299d8152ef8d58652e60592ef77bfdf04e85f4c562a6d22a604f36befb0de697256e1ca121beefcfdce0353ab4a454c3df73d5af1dc796bc30555026442a887d1d9cb16f446be1560ddf5db8145482121d27c68e2831022290115fe4a22328f6b8cfa413f6e3b3ff4393a696469cf4a56dc517343674c85e178b88e68c3b89489cb5c050c7cb247e025d6f22691b02c692f187c0076f3d8d88f5308236fba9e71d3aa76929a7ed14424d9c1d4bad31e5a1468e9fc9c5a2dec299b74ff14b1cf075b6ab6c9ac199df2a5a0d973ddf8117cb29cfb9a08960af4fca2f278b3963c041f7ed68a57a0ba17ef613582772eac3cac6d9a36747ea94bffa7dd6f0af692c21f966a08957d9d930b36f72ce1b7af394a9e991a733bacd10849ad7dd02422eb16b296c6ca540459fef611c2c11f68bd5d9bfab0570ee7e8eb71b62f38bde7bfddb64cffd484327d600ead427d91bcc2979f85704ce3027510eeb5288b2d5f2633729564a5659e210ade9f9e1fd639591f59945be5b4606c3591d72a3f251b58decbacc169754b2057f027004db91bd88dc5c0ea974ced21bcc5bb89664828191dbdccec215447124f1f240d34a033d7b83c30c74897d3b81c89c8615f8307d26658dec2b1c5b72439f7619ca6cbe8728b01c27decec0da04bf5fcf2cc547d2c02976ba2b83b4031523dc15cdde60842be4331af85c799082878eaaa66dfba8f93de2ff9c1927703d70baea62cb3fbb4cea5c48a75299c52d03ac11662e47d9bab92d03277d024e95d7152c575785e202624fe0359999280e42cc21f1bfb42dfa2856ca97597ca7006850f74e8160a11aea48214dc00aa6d7157d7038c8c2dcca1868144e9af3adf503629ef02bc80dc043e4cc5a8f7f5fbca4aba48c94e9e5a2db76663ff74cd8747be0a1be1fa6bfe33accedb229081dbe790d16ec1753d958b8e7ecdf959372b7f7fe853125cd21a73d61c7c38c2868edbbd34ee0a3d6c40bc33489509515410188afceb438ffa35863e947b28e0f89cc519583ad6e2ad79db4ad580dc16be5da9298b33b587c4d9ca4e73cfff0e0e2052c89576785aca75080adbb8d30c891c02cde74a67ed9bf8eea8eda96e1d6759b9f67c1d48600dbe583833f86274da5db0ca4dbeb20b62cb67d9006b0a5eb7674af1e562516dc9ee301510e67bde89cdb95098595a4f21d0334e2bdbbc85308bea89dfa2ab3661b35bc2bf97a7bc55f8bd5cca50fe5afe8ce064aed3228e6f5d1979351631a46137b7914309bc1dc1fbdbf07152220ded3844c98518ee03e1842915ce2624c014d95b7ee79388b7d547549c8cccaf5669c9dff2314fb1b20f435746cb5d12e9e89e42e04abd3ed879714e7d0371b4635a34ec31800e4ddfc583d36a28812c246dfc4a9cc658cfb537f8e872a9b390f59469af3e7e42aeb5c21e1de24f835d922ca4fe1e1e55f065655fbc735f06a272394b5469ffb8977db8337b77944992f5c60678bfe5aa21fc9ada7b0de8f64c213d08014e882bb2d702ea82ad9a3641779c175562e94beca269b14fc6260d5037c49341e22837b7db4bf67dd4b7a0b0bb25ba06b7c2b6b5b01783f088c325f21c0a10239bff7b3131cc138860f311c15ccf2d05089ab918a3eb78ca965f3b6732309a07910217a99da7cb19e45fc72ceaea697cae87c46b845e34bee4afbf28d17ccacc3d7458d01efc68056d1abe963ca017bbc22ca5c890e0f6704ddcb8ce1ea4391e8fa9eb42e443bb8822da7e5e63748e3026ccd7732ce9dcbd3e7cf271596a9a0e74feffcc37f8d56afc59d6274d61cb976ab76b20db3511aba22b0b3d14c2ab47d57bed27a3d63735bf410de60dfa5d7329cd6e334e1de6d789cb858e404699aeccc50f8728d4a14ba8da375e7e500e9fdec55bbe509a122fb3a0c2313af2b0ecbe29b0e787254926f6262f5d02b4596ca52e0fb2c5fb9248b575f168728d1cc28df4a03971281cc63d7fee3f32880885ce79779d4f579f582a8d1f4d2d094ddc1b5a4b38080d55a852a5c54b888218461b3d3632ab2d58fbba482878045c455c40f202314af0895401bcaa7f08ae81039efbeeb0e40cd77c55f9a1a23cec245b9fea9b8c7cad415f7fc498b8fe57a241f2b09759e4b8276364fd1fc56a0ab724972205b82665423bb26fcd93521d5582efd114bcefc0ac4ddf9850121fe7cf9522e08b592a17f523705205eba598c92ce78e45f3f38a94b6bed03d8c0c0046b8742a88cc31a3543aea6839af08cdcb86440ee01f37425a2fcbb7d26e2e871b91bd2ed726a4a39637e80502e271f1ca8feff8b3f652284784be7dd9f1a488769eb0a04ea18f9aaee3c9352886ccdc64f9ca06140c2ba1b46447ebe7ceda2b7ff3df6ac2e9ec3d5d4f9f20c65dac8969c9b39e7225cc1d1017132497207df97bebd8f31c4f95ede9e006718cbd3f00197a5ffe11bd9a689ce08a7d4544063bee5e877e34b4ec1332d619d9b93096ff29ba325be531b5ab74400b1ffa4532698d1139dabcc99df580b361f3e7ba4ff4e5360c2606d1512838573d9bde3c957611931c5dcc46190d45bdab7634f5ccf985333c89dd0ff232347bde17c8e02890546c9d2fbf1837465abcd7b87204788bf670dbb24f56079f9f5a94e93860f340b3646bfbaff9c01d7fd3b2f97c771b1f08ce02924464b03767eb0f3e1a76d3b5ea54be0be2c656628ea15274ab27ef8a892627d8d428355cc1ad52b9cf146e7564b92bbb4348d86935380685555fb66f861ae35ef2d44ec9371f983dd74d50b04ae167e018072f24838ddb1c535b4d478cdb524af427e47d6f570148cfd0825415a769436613eee3d8ecced81f4d32a32cae90e5f9ebe766e11a0856b65c71af6633d3f45011432b139c42a39aa547b8119649fb14ce531ddb4bd64053013699a1d34a64a8a69adadbda1b91a1666c1a5b0cb92311a73deb556e54619ba1ab094b4fd76f74bfd06c256ce2030b50d6f951d5c7807aa6ea22396fa474a864f94129b77126bbfb98000ba0ac2b6bd3e4471265a38cfd47d2d6cf63596b005a3cdb13c2a53d12f09ce8e1925e43caae26f26fc1cc525e6a72ef8e1ec8b9c9067b41ec719e78f796e08cd9e217e197dc3d740d908facce034a4043da75bcd7e3b8c3fb238e3ca55c6064aa1ed8b90bc9a658ba2e06e1c506ed80516ece9a01b3eca6c3a06c95e339a856ff6fed6860385a4ee24c5209f5793d441a1ec68956378e47d7c931654d4d08fa6f5cdf86f538b47f79286aa58c4a6b7b048029153f03405c46be427134ba4af42a9af37b24fa2b86aa0e57c123f719ad51509743a05c4fb54f012081cf379f654517869042f4fd5e8f8226db1349eb7c2f581b773410539ed8eac1cca08bdb202fdfafb20b56e0dcb7fe345bff538c9e9a3cadd9258825d29f25de1966b6bd2e378ea70914042f621d652e1a35db4d0e3f93eb3bb970c62764692961d2dd6161e619ea505ee970ebe234b0e1236022683dfc6be0811a5ce08c85f4966e9141f93dd7e33d0db8ff952fa358df70d2f95ed68deac3da66c60e1016bc2c83af872974aa90aaaadce7c6ed22fe2399dd5cafdae10ba096be676a2e27663bf5aac77d751e6493cfa608bf5ae1a08243b8933ec26bc44bee5f455325ebe5c54c51805e0fdbade1dfd32afb9fcb6af046c0e167e1c02e5d0874903a939a4fab24ee70f60987b247e9951efd0a49ea2d04220070cfc480fdbdecf8fea7e40ad4c6aeda16d239d3b48621fa17c658b8c2fe804bd573ce3550e50098aabf6ea989a80207e3b6bb8e9e4ddf7be0c7df026fa60d3d6a7b4e66b77a11de2f6c86987ef9c01a5a955f23df77b44834c24d3ce68c8009e2c979ad36033e04ece935d5a85b80301737f00dbbe94192099de317abd35ad679c3fcd57717ec52b123e77cb8199b61cd9b26380e38c1871a9dbba01bdf14fb5bbd9c3d6a453ae425484f8dab89edd06a839091d5be025acc30bed5fc2eedfe85628a553911526c63b4526a24896ff6b86586d45f7812696e9b94e4fc771e9bc6429a4d1cb3c386c7d0cbcd3676779c2f22397f199e1a5413046b3792fd4cd08a817a834c8beccb49264a1c756f1ee476d75622558f2cc0d3d30d5c001bd2f1efef0139eba09287bd72c27e4639f97bf7973d0b331aa50a9f6b24ab35902db296d2b0eb171059cb02a687160202dd176b618de51d916c414a7c77e4ee17d32fac9aded056c5c9cf17ab30378560b11dc590deead060cecd661ffd81a0519fa41f344c5b49e7ce4cc92f83a1008f403b05d134dc4a28c2c63282da8bd2372af6265cadf5bb0ddc3ea3a91d1647050fba13885e3e8b91499267b0d64538949eabd4fbd4286ad312104e20d9fc4d928f2a79475587451dae7826243d9b403013de08764eab3f11828d65dad682a6af4fc97162f629c036d07ab6d953ea123024ade150a87eaef6697c0f79b6dec01ab88967f027abcbff898688b99526ff4a716a0274ffff37263ee0a79f74292403ed6283ac648cb17f1d6d9e4a889958aa6d6c6420783b3bceebe03f0443c4c8696e6bf05e7546a71223cabdccd97371403bf1d023d3f0c22fcddb8ebae335c9750e53689fb673d9f04800082fd708d3566f729af4c9b9cbc5af2ef2bb5fd916108ce9ef55542a3d768dec51975b0f67f9b7fb21193d20b7a150ee7b776e6637999574ce8941db3033fb887854079186ce1d284af45b590b9b1381ec60e89ea6a799398994f0ef2bea314e7bf0e62fdb9aa3bf8fcb6d57d0bad979a56a7839462a83e1ac34aba9d67da19c6d85ec02c569bd0d9ebe2d6f36582e9ab3e66f2147021838c337ad8fb4f126fff677511b08d6219cd5987364301f3042eccce04bd252d419c8c6eec477498de3a941dae92e065bbf840124a8cd33673fa4989c44c923d27bc7335fc822eba79524b112ec74d9ca82b725cc874f152c6a5166bc881a0569fed2b421031c8a0a4ebaa10f862e3c745ebde19e7b94822dfcb63debed8b448b5fe2858b71200a32a7482d5f6aaf6159a0ac09658570af86463b953316ecba52b08a93bae6156d06711c60ba633cf3c70372f64d9e99891d95ab2997aeff1fd5eda1d9a0e9c112ec3d25b03de541bfefad3eec3aae5ac0ababaa5d4126340da408eb36bc25473d11221bcb4ac2127e86628315923f5591f12588436419572c91470f86db5d058db742e287f931cedcc69f86e350f598a7acd512c65b364d98204aaea0f06138c1ad8d344ee0fdece5091c0248103270cdc4a9787d2b7c0c556f78d5b4ebe7e7e8ec9f4c3aff12c3fc3acefc6a51627f63486cf3cb9882b46da32cd69239e7ff654bca9f513213c9b680262996119bc005fd1b9a823b6b40f6cdf99e8274a66e34103a440c966f669633fc1667fa81c9311b7c528da66ac3458cec74d127771e02adf7cf960135e7af718b82f32589bc45d8c1d3080712f2dbe81deacf8a1b305596ad15641bc9bd740a871660e0a37852aa27398da9df7b249a8c90872f98d2c947ff8a2184ea97ca5b4c13e6237f3e2e300e5468032c87ca38014fe106b8825221f9af0985bd1024ac46752d53ee1772315957e6dab761989043d0f79c26f4bb9a189cd977773302cfcd0fc9ee49347d1a331eafc935175dc0f2bc21d15892dc071e5904f0478d67a14301859297135c845741bf5ce0ff93367b19188c0496a3a1beda38a1b6d6cc04e525d87ab2a4462707099d39987d2234998945f7b386b3cdc508e4a0b75c51422699795ccf4890b68d973096a3040410eca4d67ce913da999c9343a18aaf87314d6761bc531a2fd6bfc43eea833f4b3727fc6b7dea8fdc6a74ded654f9d892bf9d938773e81737506892aa26faa51db1ba538192c623c78e5c576c68c66d25a68cf507d7cd3175da7cc8f3cb3b85eccf34ec71bc05114605986c14d2e38e0c423c19d020da48c3927c4cd66ae9a93fb2bb0adf8bf662a49b24b8d564831b55e7f430d0f5a9a66def3e93d52527dae0a977436925bcd96e83ee5b92dfaa79e091ee7bb192048ca877a6c56b890f328c7cece398145686e9bfcd117ab8bb1fece0ca3fcf0f23f4997048d9bb38e74654d215b8ba7e0a3bdb9185c9386ae76548cbcd5a12d9d7dbc1e50f627ba8a5d81ecdb155098e2b2b8815de0714d331fbfdd6c46858540ad2f5444fe79ef0cea775b6c4438d9403e07a1aacdf7e982de926d3e4509eb5f25eaf0deece1f83fd4f45f6ddd2c8351ccfcc348f7f8fe6e2b6792bbbcdc8c07e9498b029ef44d8258ae1ccf849dbe6c5b84a9c5ab96ac54ed1d591723d2f6329a45ed990a3d3e8ac2b6efa17d0a6b66694826ac75f22199d5cbaccbcd01f3f3679c777e3e58d20d4451c319a30c2c075f53fe1303a7c3327640893c2cd39edbede530dd3937be89bc1d678930cdaf860d3ad266a64b87e06e4d828aeb27445c8a735f2793e1c77291fc06217d008676d976f2c7cba50cfe61517bfa2a11d9a04e7270d0ca7f119b072f6f32522eb168913069db061369b291c1379f48e6109ab8a172b00987281f0337f8b662f0f9d1b56bd3014868de28b1443c2862c10a2aa6b5cc073c37c747d633801bbb1b82497907f70774b96a695467745f6ec73c39ddb5643311e17d6c93831948aeca1eb68228ddd47b282a839a4f77b94bb58f424cdfbc89935ff5cfb9c61519d4a76e2a7622a3243ac5cee831ac519d130af688e007ca5e7e933596d89a52f78594bc5f2689f6c7006f6406e9c653741cd9c71fb23fecc8ff61f4e63351573763082f95f8554388bf9221a38ec4c8d95ca03a09cc210072476e4cc0e20a370b54ccf18d22e15cb94fa0636e495f7c36f471fbca242bb3d57ad35cc4283aff1a3eef9516336360a266e27c8e200788d0d0632c132541289b5648e4be07b0aee973d3d083106ca5e6d0017376de673fd74ad5da15a8e7dc70d6dd695cc6f8703cc713509797ce91563c2953d1f34e21a951fd4eafc265036e673690b253ee65a8772fbc66fbe78234caefe49b21469b0d04fa5f77ebc200c54f0032ca49e1a7cbd58ebf123f2d95d0fca1145381c1e63f5e0049574aa5e867dbd05c2f70af658b8c221e510062d78e8a1e0e59ea40ed91627015f6167bbce35f339c3e09ea48aaebb8a90e24b5f97369d17ae8c74e566ec3ad969f64a1a282bcb891daf7a26fba47c17aab86dbced10a12b77e1f1d9dcf7de95b1193f69cb06f998ebc1172abbbe153bddf13a59df97b151105d0155ec9e043557ded6b03ad38309bc4b3c1849454f85a8ccdb37eab3937e5ce7e3c9c4f3e067e13a36c9f366dd26eb6fcc42b8f235e394a2d6eff969094f341239548fabecea0eac670d336e065d96a20b19f9ba6e580638cdeb1e94b75a580ad890d0b8f919dc644645d04876d5449c5ccda8ca8982d494ad04689a93e90299292507c374ccbb97f3af4e22d476c1d45aa3057da0d95fdb35f0b5e819a6e0bec1028c237066ca548d97a8d65d5703ad55a401c7921362bce470233cc723b5fe81556b27ddefc9f496aaf1c295a1c35c5dbdf14c77f13e9abcc273989130e088da4683fe30e5a855c77e5fab6f61ba025208ad94cd8bd90db57e30475321034bb4fa3dc084c10f2d96cb974c48cc46cf471188cd11a41e207c71e57eeb8ec68073bd06c9541254c45e0880f62df566f1c3163c9f4653c0d506433bd69c4e83c5d9c5a2ab48740ced717e914ecafbd2d11b508b572add642f4daf648b5c0d843aee86fa38120a0297cb3ce57fb1ef947488287332818d53d08b200009ac5e09e51c202653c664ce7ee4db0ac8daceb2a8c7ef62fa9eec3ee8318e97bd4f1f16186217133c7cce126430b1f6941bd776e9dc7fef1860b48d98dc5bf6ce8161d5ee938a3eafbd1fca4420b1d9d21bd7af7b4e4ab6c81689eba26f9f7b5aef3b17295eaefe2cb6f4ac03a7fc5086bd370a888a0395cbfb0e5f90c8038d47ea4b513ba2abe314c7bb7a6ad5e5dd525b4c52a3b9cab7650c18caff85907bb0da0c5bcfc96f4d3786f9d12b3588dcbbaef62c2f2b2ffc40cfe81db97881fe2fcf5d7f1f83dac5c4be167cde9ffa83c493352ba009586caa4c3e00cd4a8a734eb6052d1cbc22a0059826d1f54fcbfcbb7312e29b26ad1a09ea5e26eb4d288e35571428c844ffbfa97b0034eadf3b3759e0e93c4a16031144c083b8239ee706a1c6e40f684607e6d128428300ca1490eb3a3b448a2cfe9b14ade5016d619cfee53ed1472f694969efc02d68866f24c099267c24503a35608a266e327d5bc5459e6c6a2e388ba25c353f2bbed5fbc60ef9db20236abc74d49e37955b4feef0b604bbd773fd5bd0e1e80212e912bf412e1e79a095f8de57624b401d9f51ae20756debb05ab8a2337490258b40531eb6d7859df01ba5d77bf0012dcd8dc29b38da4f6dcc7282e4db8de7c07b77c8c39a0c6222dd2a163943e41b1d2513661bbb14f3f595666ca77ad3054ab6154d09430409c7e59370ae7ea2b5e82fc7ce9d73fbbf531d90bae11e512bd921ee3f45fc28ed744239e721b8bda27ba91c9f7d8b77af4d7067ab9d0e857f39b135420343f1ea4f7157d93e986d8d6462095699873c374ff07f089ac5a503700a1c46174b6a5539691aafee49fa8ffa6c7c691899e959a60d85e0718b09013ef15b32e180c1ba638c67ef9b58abf84edb51b71b97a089b159db79a53b3b41cb11936e617ca6dd415f497df4d767054f684e021cd04dc664cf8829431d673981f1f0255b33a897a12047f955bae7e0162485cb96fe90e63ae2cc04ecfd535230c4ce52e16aa15d39e64dd55d10e640bc7a7f7d3fd8793adce1c45e677eac2390a2a514952df73d651e1a2b2de14eb40d29fd6bdc3db7b7da325490c6a20c27d8cac437ea69eb5f87885a0354cc963e3cce0f76e93524e2402ede09148da0aac42fd486c109784a9f90dbb1e84fec005ab12d7566dba487577f8330f6b8b9920e209b1de4b32ca1dc5c8314ea5c330c3a19bf91f54d44ea7e5941a551f5c9d80fbb58ea236e7f6de9ecbf8c4d7eecebfb9a446a9a1f2b90b0aa0316263140286234b9169325e8c7043fc3f6dcb4c5bb68f7bd018bc6faf8a29dcc930550979b141f08b3483a395a4ca62a6874d39c8052ed0afb741c1618d3c0f535ca94cd9e11f1397184017addcd673ad90b0f2b9ff51f7f85580ef51f73fb6383aa1cc7e81f906c16fba6dc5be68eac3b63499a98e50d367cbab47d42016aba59b6793959eecc97a7be14301fe9d90a21b98f5c2fba85ef262be37a79a596f69ccaf4eb8f172702bc29ba03c59f3f80b841cda29f10c5a41f91ade6451631427fcd904eac0fafc6e9a57102f18d3a08fa71a41940aaf67241d2b45ebbc5b7925d81d673c92471022bacf36ec031e9c0e486b158cc8e49d9263fbd6e7a7b93994d9f62939d73e9e7b0f9ead4ed237f5f1295e45cb3c65f329107992f150a886db590bb2d663db5c6263208ecf10e0a8e7a38adbe6ebbbeb24a2205f473d8867e667dcc81296ad8b3dae835c1c2feb48afa3828b1958dbf52161ad69e99a78261570ece2b4b50929872fc3202bbb843c3ba3a8b6eb796b6e7e0e844b3ae8bfb981f20ef2ca2c206b6a0862961ab37fb3065c75dd876c796e213a68aaa72439a0a89eca3357f0efaa342ce56d1680f9d114462f675b79e95b3c28cefc7d747d9b09bc90ebe57e066842eca4a0636cbca820bbc4e371171a8237ef2137abfa4192f2553d6e57f7f11575935e2e509ff120d15eb4174a5c2709d3d8bb8af215b2d1bb612273f4cdffc83686fcc38f8e1d9bc206071a15b380f3e1d680626372e50eecc7f8d3ff1d2b97b8bc1252ba4f62b89f01380622b93b7bd49c6ad67e672618c0c4590c54381a811c510738472c1e1b72479df7e9f5b90f5bc5d14a8c325d118d3d2436b8f622250df6257cc46ab9ecc959c94517748c4ebd83a6b3fc21e35d89948dd439f80788ed1ed4032bfd9aa2f636a6cd17fdf6f3b7717241bb247e0ee383d512f275e09f69eb27c93c03a4cf9ee6e2afdde61a44a84b89a7a774a34182762355e150d2424e9a1dcb16ce0ab8b07eeb367b7af3557db6a983fc2a11d1b44d2fef0c0a79000d2870957c261acfe41ab3a881025f3715fa48ed534edb6e80702e29b85986c174cb47301c6ab3cc5fb5fef53a5aa19274c5b0e823265d2b3900d56c1c617cfdb47d6e808eecc7a899e6a206e8c1c89add6a79d7b7d4ad924ac227ba8d3dd56f1df0542dcda53dd5025fbe02c15212f16058faa6eeb0c2df8f0f46a3c83e67a956770dec2057cb3de472ae6c6fd20a2d44ae7362dda69a4e2fa0a469ad91bc6402c525f5366769cc22fd775fd4f351aa02c76903ec1132f41a46f85bd57e6dfad980008b48171c6c029e753cdae9b40b07f7b8f167750d181cd4ad62bc43f911d2e15e34005146d9944f20c34250278b8732f3cc301184379e135329a7393d6c5b34dcd3fad699feceadbfba57305a915510ebd9e3a49d22f61938d386ab6a59743139d9fa7155e93e59f6b708e2d1a6348d2b5a515792209455ebb75cdcfe1e8d31ca3693bc4cc6ddab1c3a0ba64744a8194617ed95037f3a65a417f66a4ecb31a90bd188d60101036677060379de315adbda008104d22234c0f8a081aef5e48a54a688d518343d567370c385fb10fc2eb478d5a2083c0393ac534bc926f07c72c82fedce807ad57bd234d31b01c18bea2bca916abb6143fee40b66ebd8a2f9e95a924810a96de03e837457f65fcc402162352f99ed76644c915d370ec5d29e081bfa236a0246650a6aeba7a1a30a3f9b733cf63dd6109fb374cf60bb97d51fb74b8e0ec4254eb975992996d69e3b864d1342c1b185357023b4703636b92495d059853dfb0d20e26a169215460214efdb76feb962186d85192e320a784b5dde661716b34ebfe431f0da9180e1044524c7590ca3e377e5c26380d63645d4c245b245c29e739b9093801a5f8c8d8705c1eb88a85402563be02dc498447e127d9ee0e69855ccad165cf0a5f1a14eab77e31ac13981ca7ab6197d04ec7feb0a2bcb43cf1462d84ef45143aa48fec4540dcb11700e549bcabe8f4cfa9754c30d267da6e188466ed07305d1d59f8ec9124b86a4f7a71ab9e2b225df70dd692511a31bebc00df832cdb47ee29eaa369fe2d50d8fa308608a62ae7377e80d7f969184a66600b2f9a25866d91449ed2392660a616658e290258cf8d4e0b2d4d5a29dd2256fecd9e3865313229dc40b6c5823406aa479adc7f6381a0b1c3696ff186d1bb2c9c6090d216842535a8c90c9ac1a324577f236cb9f677c581cf91d983cc79832152ef6e8f2ff1560d67f678271ad264f3f4d7c92b10b31449ae94a4c8da1cf527b2fec7ef82dee4eb772a5de9a92c36d5138ac8a73d84a447b2fcd8ee2315af1f548bfd82c85693b0eccd501aeea9cbd179f631298214b5d16effc6d46c59aeafba15e1de5031bb42979ff13751dc186dd69be5db6d4b14d4ea4767de55ab29ed56053febd854843e0472b9639875d245566e3237449fb1d6e3ac8cb47ba648242ff559a635d1068b1cd368f03fe71878efdfd17b04d85b76be753dc1a65293d3cea559b6b9802598e0ddd8f162a7e9cf4145ecf7a5e1533dcf6b006c9125c1ed56747d583ebadd6c65e134ebe09f2d0cdc19bada867e9bcfa43d465c7997d9707bfa1949b6a6400e203bf2ae5d299cc6dfe50496f42e0745d61265d405308a836ecc3a4f61348315986d6f9d2ab34ee31547ee57033b00072d36a70d98c45abd57cba0a0bdf895e1b68ea4387a54026734cdcd885b04b527058720b0a739060cb55b47d75a1c31ee232e736494538c4a3c52ad96713947f70305857edf114cad0a55efe8d7b6a282b6124dc1ec628b1cfdaa7098c25e25ee9f2f1dedbc254736f7626d885e5edb49ad9b3c7c46f8f8348a78001a0b0ec9989c03371b7c33f0bb3c8e61fc393d1aa0a636127b8f4d53cce9cd3b902f7029f422eb972c4488a4d54fadd331b008da2c42346f27fbab88996eb1c50e7724f2dd477b286eb1a98d13448a7e818b1575a0aadbbd6f34a8ef0fee5b9cb173b5c6c185c8b432de4f78a01f85d0d1984a352bf51d6a53f00a6f2c132d2dd3c64e91223e4513bf0d68fcbf8aac4c4982b036ee62c1bf7221e073d67613db06742758ab0c2699a679fbf6dc7d57990a3e5342c58b99f06bac899b1f68ec4f388457bd95298997866779a40be5785a327a95591679bbf22b49dcccd4f6e513d21109a22f728ef7b944d7fe1bd4d4b6ba9860c957a6fb1437ea88f451459a39f6fc9c404302b024992359e3e9a67a28873d2c415700d0409026acf4631895703cd748a5014e619a7bd8e6a53a35de17cce0b186c0570af62d5a356d6f20e29ca783b07e11a2503f05ef3edac758d7369ff2e8795a9848a808faa5c8962ce2a79bc6a14bcfd87cdaf16f73d1d8909e4d9af326b3b57a5ce2593c167304ca1c83738c108cec99fa79ef0c926fcd8737f535b5f508e578033bcd4cf5b26bf27866cc7159dbed8166888ca1aa11981411016b0fec9491907baf65d76c2f164a0f36c672d9289325a43297c40ad738462150679605cf504590a5cb489b1c6ada3e41a580104ffc5cdadf725d1186d928291c6429b1d3f814d65dc0cb5be2263e614ed54b424ea25826fde0b088e6f61327920ac7a132d4201464edef88b692b7e4f9f5821ae415b3aeb48c3311793a5d23cd9f9cae275b536096a3df9ac6befcad37fc7c183be1e9fb80d85ab58330ed30e9d532e30407a02b69adfb60a4f0bac0b8e17c3c9316a2a7ca6feb6e5dfe8c3655027b9bb9fc0ccad7fcaa3adbc967d59fa4983dab2023a352f6c9b1f861097af8fe12e18caab9a4969246b1af33378b16278a377ebfcf1c3c2607e62677560d700c37233840b5a81665bafd512a7d8314b4376073cacb22777446cc8ceba02c8cb303325e726e33c72f94aa735480ecae99684adfdb6956140cda1087d328aedbbb4a27b547ba092f355cde007f35f3c293f9cf40a876212d77918704b841b64ec004ea24ffdda09cfc8344127bc56379df8936a3298b8251ec31780fb8ea664ee7df36d3ad7ab01357d83610ce8854c4c2d9b6afa6834df96c30957fabc1b8e59ef779bdf4dff2d8eb899df62885da368c06fea75456832fc6824790987438540ade94c4c4274f2d89998d51a6553695069615c65699e0dddfa6195132429bd94099c967710dc138aa58ff3b156c6cfc87ee344f5865c1d76726ce2bc44f6ae76ceb3fb50e379437a1adf42c1cdb7705daaa07c6bf36794d06d4a96574d6f018357e439525b24277f189aa39688b38de299c79ad0f321dea067e108b6b108f74c99a3a60eacf07e18bcd28bc3f36654ba4c1dbd1d3bea7a1e212e55877eda8e163493b2a17c39ea554f67de16a3e096116dda0e160ec1700b81bb9ba7e01070f54ef684f23d77aacd39a26177f59931d624a791d49cc83f7efdd7247b24df8e4619c51ecb83bb26d3abcf7d8832022555a7a04865a80720aae7146f77be559f28e945deb85cf7f305751e29b5bce763cb07a1939c54e922626b81c820d7fe5cb94df6f38726f7c9484d058748a6c3ea4c0141e680776635f5270d45288ee87fdb8604fa90a6d0234923b412921f0cdcc7f529c02a5b63b936d805fd428cfd501e3e0a071e93dfc90680dfd83d419c7597991663a399e7581f3dd4f8902b368e02f6c8c9105acf96709b58d628d28d1067fae8331737636c71b76d66ad1a78fe6e1675bda52b8d61b0dded1f43d4a582910ac112c1e77713d204ec549e9bea8a37bba8416abddb1d9f355695208cb7e8c5c7a65ac22dec5d8234c2e4a1b829526d8a19b317c336b6970c6da4fc8e7ff4fa33c086a23fefa7cc9034baa97c4b4d5524de2080d74147ce0d7d6181b3e48363a7d1b188ce171224c194d7df5b1aea1b2d08f729055b790496b23ab602d752313009080c8746cdb7d9244a4f72f78697bd8f4cb83975969a532fb3bcdf77827ff771e7bbf966ed8fb86cc1bd120700d891fdcf26448dacf798f81673c294e2c71f2e5fe64ebee368ac5b93434021a52a7eda67e2fd7839daefdf7fa78d6ee62e0e7ce2f30c48a14cd8a00bf2a4743c056ad2c6903ee63289caf949b5895b12602792d9ce0ca865fa8962687b329f71ae48270e73c03dec672112688d856632a6775fa5970e32c6cd7f1494e1a53768affb07c48edd20144326a9d494814386c5be10b181c454b14b78656ff9ccd622eb204359ddc68575c44828b0317e235abc7a8c2de2c0a57f98230d10046157f3ea79fa202085b1980b5da66ec8d878af6c65906622769baae3f87382657056b04dc7173d653c4705c12818268a148fa5db67fe23ba393734524267620adab0b22d01b7d3bbb5995a258b976d8a17f8efbb6b917aa28824da47ea20036213b9acdb3ba3698d235e41fc16402c868833af7dc812412a1a2d1f1bcc2696f4e407d37302ea6a0709808f862e3e27bea37186e508032bd6db9094b1cd49f86c454a5e4dc3dcdd03761bb8a6f422fdb2da3fb563e9107aab51cad4c01924593ec7a34b4ed26dae08911decd36768d3eb902e14667632f95f894dc6041275b5be8674f9d8272b5472a1d04cd0ed95bed52a539b2980374252fa7410767b1709fe4a985f653bbe78d5aaf5520bcb80551aa1952fd5316b1ae5e76e0d5a2e9b4747bf66c585021fffb7ccbe5249455ba2238a1c63fe5bf6d93e436d92f564db8ffdddc7b76cb3126b01b2b26616a936954ea2ed56e580486e3c91e06a0ab0cd12c610db315975854868929a589f2ee64b2331f577b3078e505c55672ed095afc1768ccbd24a5b0b04339326c875e7d95bbabb0534e86bd616a278b9164e70c9505051c2aaa1bfd008c555f9b842a18c064f08f07e683fdc28f0e7df55633b7dbe6e7c296c602531c9ee5b51aa0a6b198ed09baeba357b065097d174d893a8c6b01b6ca809c1d8c577002e87ddb71df70ce0e28e2a9a9f23c9aa6affb74a0954eddd9373675738e72b35ad426f0bfcebcd8006f3fc9e45b4cf266f4514f5786ce4a15d018506530bd1efe4ac1001cf67771ac05f8f1640cff5be87f7420f24926d38c854e56c59c20567b03ccad763d898b9582abe848a61f36b16349043d21e674841259d1d6775392a887aa53280d9c84588e13f94502e6ce39c40a22f4e4e4bfdba0a4e84cab0828b514cb027ccd878e23f2e7bad6882c8eccc0812b72453102ab2e94a78aa31dabe6112d5a52dae773e840be711af6b29a37fc47db1450630c198521c15000f134239360cf3d1e9d40fc57572dc1b1d189b8ee39474975fc6b0fc3f57276346621745bcbb8a79821d2038db68a67ff59c62a815d61ad18164782eb06373b1fe410c9a611d674b3b6e4ac56cd87430b6091626688eb5a02f397a87d4b732e1f226093858d05a487e6e96f3894238365e2399598b7f26f724d0188d9fdf63a1b6d0a4338f90aad256e1d1ad78a8024d033bc3c73a9c63b7b1e1a3e41aa12e4555d358cc8f25e25f0a302dda0d8cf22b3580a71eb9ba2924cf45f8ec1e0287348139085c4f92fb9df0806855930fadbc14af9e4ab9c47fab3bbee36495af078794048758cd1413103fb40d5bfd9f142f47ff353e96ea5a907bf6e1fd9406e46631545a5a2bec58f2c22d9af0fa19d2e20f7d8f4e8df37554e7c58bee33827e2741890ccbba677cc884014c1d3f6fb4b491dbc234586a4d360e2102ecf5d2d0752d14c658d6e777d094be2919470f792442535b910e71d2d16ecc1486923cfc3cc656e8f78c7a42d31d13c11939526a2b68a0dedcb49106d101aced21c065b22289081d87c34d4a3a3c98435c00e01a03ab536357397ff778f93ba4c612ba0cbf5982628ad3b7215a462ea191e49afa54a63f5d54cb946092c8594dd82b0cb6de5dfe8c98de30a7ff57b6276d321ddc457949b21eda10a996b0d1f376ec12024e5c95782ec521f467c0caad0f220b933b6313e9486d871bb7e6b1f7fe3d37f349bfa65003275b9afcd7f52d7d6953354fe6fda3b0c7a1b0c00bcb5ea62031ecb1df106aa195e786145314c823ecc4fecc503fbde38f83b85f9051d311d77ed6adcae58e9fc8fb904accfc8a1fc58ca432e0cd349d6dfcd6307cdffb424053048f141cabde4382b60352cf01f63baf63d0699d94c06df6738c967a711cd0057954028987b3af1b6d9ddc97c190984f2350cff8c293d16ddfd1b8394522471ad9c86f3d4e490c458955b02be2eb379bed03477dd4fe5c239825b0d55bb0ab4300320c967f18134967c664d53c0048024ab59064c9f918309bca6eda205c16670421d7942e2e2a96d3da38cd5c57ed7ac4e346e3c985ef87889d6c632ce7a3186287bd92b2269ad3ec9a83261e812f89d2c2a63bbc548c91c317e949998beb8aa75a4d544cf7b112583cec8a44a5f7092b5594ce465aa3eb4cb994999af9b5693890d6de6077cdb0f6d2e8c369f5b72937f3ce4b304e826d191848c740ade8ca5f1d717077ff0324e6a040618ad9196eafd1ada07fe34a939cb2a74e63501186157c288a68fd3fba9e61b63370dbca7dead2221487c1170d133ed0c6f6676c930102fd73563f2dd5e677b2c00c5d1900ecf95c91d7ed3a30a35d1104de4c0870fea4846e642357edd9f665df6235302792c0f3740cdeb57485f21e03fc42848c8be4090ef32bc9fd7037590a919afa806ae96db30662f9407f6ced20856edcb67cb2cab990ea6697b6129677bb887bf16f02c8b083c1292de43dfe5db2ab3ed7f543ecf5c5b111fc40f3717fd0d5d77e0f77f21faf1c1b7be9354cf823cf7fcae0d7dd27f7a5c1e06c3c41c16dee73fb49ad5dba2f571013c6de01dc955880b569ebbe559bdb0cd38bb31c6a4ed06b1ba74d780119dc1ea757fa5d02c00ac6000d8894e75ac1faad4f8288f57b5772f2528ac1f378a33372b3c5dd1a7854ce0020c10e8fb7bebde022e124619a3c09968c977aa70fc3340c9d7c93682e8128f14c731199924fe76f90ede1542693a45136574b03768aa368dee5f4bae86eb46aa6cc35030bc9d2e2c88536e83d0f7d064555c0f03eab3ed9726c806cd384c05fce9ba62736bdfaf63274bfc8d3c30f95fea16af6df90d2c3cc26c749fc4e670ec7962659e89dd4daddb92be5406ccabb70346da40362435ef72268906ec5be4e45102b296668f073c543b1f1792da9a41accf5c944c0eb8eda009a21f61fef573fc30a8b704996b60aad46c31ca40fc15ee4452d873be36ae3f6b6081c45656220a0e6561c5af394a79e90886e6d52d647b76bfa1eb08d52f064672aba3f54b0754771c2a21a1fafdb8234c8da4112c12b27948870d5d52cd5ab59527773d5c7c01ca85ac4b0968e8b545b1de58a8945e2c2cffe70ed2216c1b4fe8868ce1c5d963e03d385ebbf4645fdee721faaaa2588530272b1bfdafe9675577b6252c75e6924cdb09f2e9278fd67565ed796e4926caaaeb627a27dc9f888bcbe867eac6f238cb1cca7ce59aea9e06a0e94175bbcd652be8d3c700d3abede85b377d6e395175b13a26eb889f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
