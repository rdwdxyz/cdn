<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"645a4ffc2c74fd01e66f6f6beb15d1eb21422b01648a0c192c2be9e5e909a996b9a7bfe5d583ef351eabb28428c6e4e986aeb189e126d00f8b69b7a88dfbbb9971b901be193f486ea0d004f4e002ec05b168dafa4b0af84aca5ec00142ae0175182d04d1aef9851fbb87fb8e641baae98ce9acad86512e4043872617d8c9d36dd373e460ddb9c28b87061eff2c400759c4675103d54403801b8495b7b44b2f3ab5407617f7878532f41d97d8d8ff318886584b4f6273545899e67f7e49dd5a7dbee804209fc6650e16d054c61b5dee50286c3a6f59703124f635e3eceb0c63ebb3956383eca44c09fd9b99747c3a6045c6f8f8a540e0b95134586b0db9f1815c039299c78a219fca8d9709bbcd8a4f5022af53671daface47179958be60f5713b7e2b719ade6996911dbe29a1e0ad67de4978ddaf8529fdec23bca209d82be091f0178ab9ea8ae8ca5578337bd745e61c109fa2b508934a3784ba7fd9e2f28aa51268c0ae009e5ce1033d95d85bacf044431ae6c9bb88ccb95b1b394792ad99eb238596178a54491670b556a45292361a30f3e22c823312021e521fbe92f428dfe21d808fe436ce110ced5de59a91ab8afff5b90e6a277812806932d413d3dd4bd368f6ed9630e8b5c67499a0452842f1d439a3c2fa6ac1d2942dd92839babcd281646d9bf71652407dc902b0235d20740e2dbc253950d0defa7cd3f1bf44c0d209f689326b0032f04f5d378cd0842e7f4b776bc9f65b6dd0963731ddc3b953e5f4c82729e1d5858e3d3ae306a1a435a6a31a870fe73e5ba9ec06494d0c621d22695e83f4964ffa688f463c419b7850724aff3c66e939650a22accfd7c9a11bc3f949ad6dc567d15dd53c40bbbe79db7dde427b75adeea9670f9ca183937f029fb57dab2b827ca780408c5cab4c06edc68273088cc9fbccb36682231341381dafad6f3039c351d5b16c78606cd922c32172ba5bc0c811debdba0424b2f41ffe872cdc89ae6138c465d4187c31cfddb29371684ba7f69e9414379149112520d13bf005e904de07521b7e99534d3bc801d3947f558bca65e8aaabcef623476366c6314d5fc05554456cee6aa6117f34f0c404da461e3a6505fa897a4dda9eb9de257378a35ce04a759fe3e179ec0d83821e2360227c8e7d23139e1c9725d72679baa2a7eb94670e8f595529f7021db4c6973ff607150d9ae7c1f1809703994eb0e8f3c45d6251fbc0e86e156156ffc2284ca60f3a67dbbc0ee201a3a4c0a4acb1f2d9b87d73011218920152715d0ff1c08e119590416af94147c404655700286829d3b147a250c862bab15186bbbfcf28301863c3fe1f4adb36bea82748bb1e613cb559744d4d8f8fef33921f9a2c8bf670ab0cfe2e747110c1cc98bf14b227bc32e3b9579a0440657fd0a7ad836ca9d06a5a578bad9d6d075eefa9433e809d1ec136f97aef093d06a2cdc4864a2afe39fccfa3187c1d77b8fe398bdf9e7e48a4922451c2c421fd85be0503a46cb1a521575f6c9e4f0c42d9f7be866f8f7e51dd0fdbb663c5c38de7e8e7f395434338fa5e3648c9709e36431fbf9a0a54d4f8a6f350629867d7f539dfcf176b70681c363a019b949493eafd46431dd479aa0d2280835528b88c978e1550d202db4165160e2771c6a04cee04736614b8a96e189d2bc58880f8377ff3cdf58f1291bca85d31ab2684c0fb5e7d9dea858be1e660f6589a1448486ba5384adc657baea63caaa8c97c81dbb76ad98ef8bc53560148de5f56aa7dca0840f754d3488dbcee06320023361f2584547346dfa5757a86d321bbad1076cf2d34092ca596ff6a21353a1d5a504077efde8f6b72c1ff27bd5fbf9597db50580f8507001e0962246bc829c6a0e1d4b65aba711d0ba6b6f1fba88b2ab19e0feca16c3e33761930dea85ba5f28db2e5e5d20725462ef3fb9656992fc9c805d3f3b82824672c3262aff548dd81e58c4aef1c661603170b7c81caae5e9c26a758d480d09518f6bae00aa030219d6fdc069a9b0317bf09a848be5d30486cf418dfed27f97c035bb97e2dc4a27c6d19c86aa52dd0e43be0da2adcb40e853679881a0fb1b384ffa3eadfb3016c6d3e17a0c454e0527f919bcc070ea5fb3cd1d8ca64e759690ce0620f3bdb7f873134861cb1cfa4d5c939cb2d22df6c5b3a42c268deae0adcf271729f46db9eebdb90fdc25416e2f4c44d1a3548366d1bad16bafc1b5afed0f9510a458be8ca84e8148b9b545270fe0dca70b0ad5f2f3c886dbe927f527f34702e431d39e5913d3218184405fb4fd41b79a5758ac21ec880436fa10d17533312e9cfc9cf9ab216463a0834c83de93f2626814cc3b3624bc6ebd53c3b160499b0587d27543c0a9dc603446a0d4728406162c6577ab66db1c4a3f729f6f7e3fe4a68e9c973cc384d4860ffd71e67c8ef2832708c9f6962d839eda9dbbbec1efa683cfefb58746e1a8f9a03988a6f20f609d4c7cf687bee39ea5579344055964a33a17f0ca651541852f2e84241bce8575aaed6f09652fb01a61c6d5428bc10d80082e91e73ac9c1ea5ba8704c10ca719f866ed625872157ee9afeed43cb7b4eb93c1cca51beb052af25e6add798d3efb7d5bf381e815d2be30aa060e3bfbace85fd8293e92333466f541a13fb68e914ad0bdfd190f290f03c6d6cefbcf9319ea828614b64467f793abfd7138a17e1067d9cd256791bccdd1a2571f93ee896883bcba96320104b911eb393545d96b182e3181701ca909fe1c7ac6fb840c9815fcd36c6e3dff2224c2c4c53299582b65aeeca208e839bea4c6715d61aae034bd8c6925bcb1e3f65b73d8e3230b1782e41dffb9624149583c2c26fd63919767099ee6fcf6ae3bde29d37f347d5c0c95325b7a94516276200d97192545a9553af347e1539e081e4960bdd5140b78fd9aed079a29677b9894744a183f4f876b0ec3b33eff21a6f9578c0aecde4cdf4d3ba8331729db7132cf94eaf4526590e3b8878cd30d272db89ae9a9abf271cb0f4757602799d1fb7bd62261d34512c022953fcfd41460b130055f388e5c91987a5ee43e568d248ea57580b3d7465fcf3da75aadec118e8395151b5426b68ec95f37f71bc47ad04a1a03f43b067ea92425088e65e8f01ac01a6de6d93d19fa33567a6fa02c1c71d8a9d851bcf95d439d03b2fcf89e785299c020acddd3f43d5ddeb2bd16ea2f4709d3ed1c63a681631b63783a83c281356f849924bca9d7a156eb18b425c6733d1af2a477f338f3d51333a2d152e6fc4c07e55de4de248f1228a47c8e1f7fc6b1eca39860649f32600c3e31f25fcb7890e10e23e3ca539a9ad239cff92a6ca13787dd17362b941527ca09867f706f3bfbfba4c2fee691eb4ee539e4147bfd429147440b87e58150eafa6c68bb393d31de9a70b1f16a5ce820f6f16e2be2bfcfcb0201fe11bdc9f4e59a0f2bb85d549247191db26772d312947e577dc183d0de35e6b66d5583d66e194fbdb5ed4a0e8f3028d6e72f20726077d560921282d5a5263e9e8d72adfbd01423dd420795c7e04619164d09de33fea755652c2fbcec489b2584c4a14aabd2ab5b0660c757e1d6be59a5d75ae475c107f73bd206716d9a7ac23a4d0fe17fda7d886d25b20b3606059399ff68162583479b2bd3da7078e4d1d5031136ba3d0b0a224c8621a44b8a15416691c637a17893730b0031f1a0a662a0b97c63bc59e8e77ddbc475c462b3ba4adc81652002a81912ee75ecb81cf1aecc9c536fc26d06a02435a1c2156c49f410afade4b9a7266016584a89e83db9cf3b56cba0dd4536fba1758f0d647bcbca25c29ff44a28b683a5002c0f25fc33fed31f3003c3664a6f4600359fd4306d0826ae0fc2559bdcc78695efda0cc604cfa886bcff4f95101901d25c56d32b24eca3d5d0f8bed39f77e370342e974d717468a70e0a0b7a606e261897d39d091fa38af11a43195896ad0924ec5787456d7dd168a0c83fdd5558b10831f210fa04477e71010487369ecd3f5a575a3ebefe41316733c9128feb875d058fde8ceb36a6208e07cd1f16c599a9a3fd383239d2003929cc355c4ec7217c9ce26367203ebef4ad85e0466e1c2ace143f6fa49754e01b4fde897cd2406cf63d05cd5271de3a5ee6d3aca5c2054df07849037bfd2b0b02345fd2498044d8c4c37c0dd73915a85b12c6bf856bcdf55dd1bc76d667da82010e4c513277201bb1071809d05b838f2bd72b5d805556633e825821bddf7ba5fbb89ab8d70f2c6691ad6b0c38ca68549be6d867051cd8acb19fefc17eb12ebc892e7e94e3e95a61ee58d425cd9ae872af56036af54f0e97bcc84ca027eff71372b14dc7939bcdba8606d5cf7d7612ff4bc780cb457054becc1c29a937ada9471e2aaf05a174d12a2c5acccf493e905517277ea7d3ee4343444f830e37224e3713c7a71f1b5f1cb098bf7ffa54af5f1d632123dd5d549e6f41e9daefd5b69dcc86d9ad19724276e5bd4582eb9921b51b315ba0efcf62d87129298a53d4a2844af058f26f1127551db6435d44f0e8fb89ca7ce57bba1c8713126f848040ea7bab469fd49b0e0548bbb096e724f9de368147d4646fc5707defb603e4ac1955077cf5ae3c386ae1e5a9cd5692cb9d54b04cef4882571f2aec0803d442d270971e4a8eb0736534bc6601a2e8bb343559e3ce6de65cc5946c8114ce2b36ef1a898d42d91e635651ac10d73d38629cbeaba4a118f55075fb15b696c696e74af34cbfb671b9d625d42eaeba6d873c307468b0de73cc4ed87f9a5690c37d4fa1a9fa584cd4d73bb832a5d794492a04e72a6f2075e53c20ec29ffcaab05b2c98f5ab2178d473f2ac1be9313577faa77002ce13324a53d00a0e4e5112798bbfd4d3bc2d36a8aabdf7ed9adf8dbf8b1a5dc5662786060a523285c0791edde52f00f0d293f63f417505537dc145d8d8999f239f58c398a124ccd2e26f8618a2421b89dd1320541afd2799cd9ecd3ac2c4af8ec815294459394b7ebaecbd9192c2aa254f4d959ff4a23701aeaee676a582af1726c51804b32d08d4801a94883fe3d602c6adc451a0104c6f3386b9e8f0e7691eb2098d1e5472c005c1d5fdb7f3e995c078a4b79378038d3726206b02e70935b7c619fa2dbfa77fc735b4888f97671b06c708f64a0a8fd753a8bc8ea7b15eb87bc7517fae05a7956d8a98b022b8ae2a997ad93dd6bda3b5577029aaa78bd3ae5fb8de3f437f03f20be77b5c6fff1c398e08674d42a33292e74278c15c89682755e9bdf0b4fe85b9377dc89762e9a0f1c3524a99f3ab1280fb3fa329ae044aa70c377099eb303c273252c627c662f6ee0f1499aac1eb458b5980f09e203b930197cf4d083eea98020e26b80f43cff53af337d0fd8e0308b507e8a5b5e2b0f4fa23c1646bfd1308cad21590c78564d7c49b8ab3e1471abf7fd4e9ee4396a476aa4c08976ca1f076e896bc0ce7bea044faef05d7b2c06844761c1453b66ec4612345a7d19d560f59c36535dcf45ed6e4cd455b0703b6bc53f9ddc761711da4c3fee49c883858e63e838e1b725b435d62584cb3ebb28f3db0a61f0a117c60c0b5367baeb5cdf25e07db49a8984ecf64b1ba845ba2c32545d74944672f3ab70ca72a1a3a1ab2afa98756e51fbb06ec71455df05925480e0eb4d8c93d93685e99d7f440499a08a6c7efcfad96b76f19cb713bf9e4da42b9f37c78ee7700e32adeb854b0a1f302b63aa8cbbfdf6b87ec0349e2990b79400e97db07eb8457fa11e105f8bdefedc87af6dcabffe497df42904af5e8f0c85325dde0d76142025e924612903f154b6b499f866a402113f2b583862d8858929682128603083730e1e8cd0c413bfcf2108d9516e288a3dbcf01ef1f07b513748dbe14907f324d2b54d1d6303fb32f7b1661989d64828ced19a8787ad8e9421321114edb0e34c3f7f82ab1740db5c46381b261b16670c75258d8fa30363b60dad93abe9dfa6640205575538ecc63786c7fa11f0a492928ae5830bc91263761efa427a8a293f67d46d3b908f0ab0d5c60057356e250f8fc0a5a21ace274ae976d9a06a6cf242f2268e16f1c8cccf500366fe730d7ae8524801fc64c63d5d5f2d7e10bc37e5f0828e43ac4a9fd0929e05e242fee5a43476858456ebb4ef62de346ad49c7557218b77274351b214df7b8fe3cb9d6e385c68ebfd9e3f9f4f2340960995428dd6c3f5787871ad219df9321901d369a8327d8b4e67620fc964ab0f5159281400d0c572e3af7a577aac124f2bf64e35c6c700b49957b1dd0eae99703ae06e803fec2114d813eee507261f1cf6a4e2c299b95f894d3e1d86fa35d493a2bda2d23f19a061ce3ce7401f14c0e1741378ead96c287b05392d7ab9e16fff372ad68b37dc80a531ccc889ce019ac8b3fa5d566d46ad74da86a1ae2429eeffde34204ca1cd0ef00863b1de0e6a41a86591b85d598f55d6240010250bc4be7bf0af5f513be2030cfdba268f5504c84bcb704c4c71e3f4aefc72307c24915a2a72f88f689b5028e9a229ce411b1f5b3bc0ad3467a0993de81fe938d4b63495c4d049f21ed7f3f3d66c067afaa6e0be20c647b1c3f14db529aaff5a3dddc0dbc880e7513d2a599d67b81aed4b9f4c19b972ed22001cf152941356881924b288862d904648532d5a66721219c4fdd2c989eadcbbbe87d7bdb32f95f5d2722a4947cd8429c7eaa896afcd9e2130c49df6edb61082d080225f7fbac751d80257b60d563058ee0484f99806365d8c71092b4c24dc5a6c698def5f928ad47f5430f7194efa0b3448ec04a131c0bd0e7887915af574e0b6e05258cfcb2bf75244f61f5c86222a162eb713777e2a0e6fc546d038b4fbbe757ead7ce29dccbfb575d352eeafdd25ade5e1d9e4d9c44ac28ea50e91d7ca5a436b2ad3d524854e0df683dcfcc008ff30cb1c692a46d56709b72dc7c8b05ac082c721298f78d2b8985d793aead60f8917d6a148469a4c7c8d08d4952f5e24938edc3ce4bd45a704df1f52df288f2654ff207f3420dc9721d6c41e7011b917efb7174e42e58fc2ffa5ed542180e84b79e97c2b1d25704513653a6201167ea587be917b0536bfd2bbf7916ffa68c45c82dd2f3696627ab655a0d0485b7412aab5d0cf065104df2500b1608ccdb48dbbf4e0d9fa5b4ec7e75e62c4104f790969ca8e786c48ddb07461b99806bced45a985cf40364739fdb5b6d970cbaf973ae3ccf8caa85856065181676163a7d06cba200afb7216cc5c4078a420558d01a0e7d699ad6c7f6b83d8b64017e6f8b7458aa13301e8d52609ed969310341d40a57f063f3b3146265bdb63a73c148f875d8e89cb09230b5cfe5229bfd87481a37fd4995e4bad30c53fbc724957d0479af8f92848618c899440adac637a412e5b138a1d2dacd630d6d7b198f23c4e9c3f2ecf99ab3a073da1b6704797db9ed682bd849d28ac9c0f9f6c5f301710a650cd03ad275085cb44d5ce9728d7afbc9341e1e47c982b585665cdf8686ecb4c33f91aa68b8657798434641bb109f98c49add6a17b79d7cfc5471b1b1f66693134c10a38d19e91adabfa27562c01e1bd73cb78915e26a512025f03606045bdcaf8e750cc4f4bef2f68e4a1a1e1907243428e49777a076c41784a232d8f95906bde5fba9228b7e9f2885610efab97b5da9dca45cb4de66904c9e99cdd1233e86ef7c0db5490fb347a51ea16598cf98e969dcb4e99dc255bce42fdab21fd7eda59e0e134ebca1300f37baa7febd0b97fcbbe8dae55277408cf4f6c49fc0e7a476ab2c226b1c7798ff099efa1afb3395d02f3e9593a484b911c0f833c8c3f2a133978c03c18441997f5581aa4ec74608f5c8b226a9da0573866e76c40d8362248e9ada2531bcc3b49bd49b63e99605e88b0cb6766f47db93e323a3614ba9e2b9a4bf46fb42e36b7e8f8ebf0db4191026237b0430ef80193253ca205a314c83fa2a0e6696fe557ee65e63802d25f76bba44bb4696140145956b9e6736395ae124ba7e6699436318ee2088f2660c6767276be5e3ce571e9afa35a438edc4eebf028c83dc315b84c63266b3276bb7f8761c2dcde505ae3a1ef59382f2cbef7d4495ce3e6fe04d77b917d60d1fc61b55c71a222e28ca5136eaf28684903832da2dbf76587f6e8200ba8b49b1b03a62c4c93913de6664b5d43ef992db268f94f98ec90d62aeb7a6864231673a4272f4b6fd2e0649b7f7015494f785b642b566c752df35cfc4a4a34f46f4ac028ef8863559d3f5d038566e220b4643e32c9ace722505b884fadbe237e3e559be8f899550f3da70f2e185c9c71159013051e64523a55dbd047af453e37b7b4218dc1134d6ff3c475b6074ee33f5d3a6853b6a225ab431c686c5370ff456b914449b85ffd27b347f79baf2146dc02d0800bd928c27c28daa57ba0c56f76cdeb8fab14807792f3658003a9eccc66b8e81ff69d5032719b5c252cb7d94f927336f8f5e985008fe62eff4ebbd97d3e5fe0b4a1ad08ad3fc968c5a428223cfdfdd0c4ed2fc74ae146c021112a1762fb1bf66243b1ca08872aca6b3a0484e4a122a7f72f902c5b7113d52d9e09ac14843207dd9e06c4c800cfb222ccbddcfcfd2ce524909c70fe423f7224a463bc0c26b3ebc8cd3a5ca0eb36961f000918d868681e654ac526b12d3e1b127c31c09fa3aaeebbbc652d8f066d33c3d9121f2685a6132e03e26cd62a34c332276cb5072955a5e700eb69fca807481392660658680b86dc7edba704a39bf79363640c0ee5a491c96fbc7363e0657a05837b35cda32cacad6fe243f4ba3e771b75997eff8b03df710a23b0b079ef2f724a69a41e0d8b2dbcb831513e52ffc78826e34df9ba2e4af8919f307feb2de26bd3a65fefd4a93781565f2a9b7c823632686749ad73e8060962ce73e7fdc3a250f6179fa8d19845d51545fe9147c34c0ac340bf094d1c4e4a401ed27209b5acb24095e70e03df2a865af634ad6b3003a71cd519a68590b1944d619e834b1776d02125dc3acef40fb13f2eec7986ef693f975d42a53492d7e84f68772ac192805166011b4da3eb40fe2ddabc5e9e2522b35cd14e9a532b5f264510da3ee5738722eb5d3309e4baf27a88f74a673f9f6c669de20e42e6cca7128e36926dde5c359e56700ab5c6f61ed1eb22f0717ae9103294d9d8c0b4306bb456782bd99ca4006bc7c168f187e4a402a41296e23b73b13f1095feb7bba0e972b8a8c1cead62e843d57cb3be74817cb972eebcdad04556e4b23bef958f8eab2810f4a359219f01a9358a5904610654169f5d21bf939afa86eaa74ea4a45a1224578b323a27955dc9539ac018639a692478e2528a610a666533529cf593854fc4d892c2f5747ec766de39f460361894046a803513c59d4887fa02281eff9ef094e17f8b652dfc2f08aeedba677adc8b1da6862918e6727cf3e9ad4bc21c9ff1cfafd9c37605f9172d7fdce3d6ae72729d90fb115375336e9ed11986766cb439634085aac5df0e35d78ef95e7cb231f59aa88130456840e79df96b0cb1712d3a711bf813b4a7111a57eaa5985647476152ce8ac36e82fb3757e6e69d7dea411beaeb9ccd617275423d0a36288fb4c14ee3ae048a6941f03e9ac9809596816232965e39376f9076692c3ddae8b4959d9e86fe7aa2da258d178b62896ef8c1b450160395e0d37f24d23c4342912f6ae1746d0c144b0263e475336ff53a3dd7c343c1a0cbb2931713a95746a60bcf99f78189a88a1bd8197b5122bb0ab806cb9934b24a77b713d45f12591b60d2d76738d179da341cecbff6822c61a42dae0b08946d62e9f81ec5c708e43c61a11f24a4b69420f74d375731be1a9ed72d2b1b7e639a03fbdc7c7ebeedfe7538ac69a612e717fa06b6684224b431e4fdd10a7a7202877fc51b0e8d759ef10e459c51c12b3a4fddff3f49604fc13f55583c03666f7f87775927340bd622e2e21e9c23c651222b783281cc30940b02c760687f47d101b2e6b774d2bfe0fd74d289d536710f28ee8d3b6a3fa564ddff8a0a34aac834bbe2b8e4e471e65b7f25c12cb59fe55dc949f9feaf082ef2fcf088be9b331e78169faead7601ec0d8a0acab04c4fce3b787c132f3082d556c8acf9963189f296aacd97b78f760a8736506b3bcf1d9ea061b666c07505dac0ae9fd1de15e999cadca204c918cce60fad53f46488198ba196537b053e5079ec09ef98d7c779557fda73d4b588481c4b6280990b25d86a5f64cddd573eb9a944565816c0056ab671237c39df5eee472284a6d0f4914cec003a2cfd543cdaa5de7763c0db6047018fc31d6ad9b4b3b79b44529fab470b92319918c2cfbc0fb9ae9abb8687e06b120f630aa2bc9e78bb320f757c1d3388fdc049d3c8f7c9c60c53ac73a03877fda38b865406fdd42b57b73001c2ab700f1a793792a26c82b11bd0182ed9058b8a4d88c1db44444ea1ffd6a244c72da6e9c95d64b50cd48992798a4208ce355a3559c9aa29e648e7256ffd011880c0959b82535b9319a9157320d65bd1341110e15232c5c3957447794fbac6b8fe60bf090bc19da948eef5f23024e6b6e97214d7ba7d221985904291f7fc1fbdeb87a527629c6e268eb0df23fa00175aca6f32108ee4f5be84823c0c4073b7450af2eb989e3a36003b069f1c61467432270aa849a2611446889d8b4ba84ba232f200f6785758e21dfc5576202ebea1ad6c915bdbcf476443f813271cf207d7f84b10533e381a06ae50b333d6999e874ee4a095c05c3b1e2a9a9a40673079a83b3ec0d8ad90741b05ca5457aacadebaf7c810e64a2134dfbf52e0d3a828bbe127b531cf69897e3bb93c944f3688786801c44a038730bd652744776f6841689c8fb2a8ad7b236dcd06fe183d41fd46a088cd9599b2097cb03523ca2d4ebce0a3b72c006c6823df960bca24aebfefb8d4690c01e76b2fc088f6a495420befb406463964d546e3bc051b265d0a4c852161e08da65189d5fdbbc7751d1531d26ed528aa493864489cb58013b4211d2a205ad04ec9306cf182cdb621237bc339fdbea76e0a1f3872179cac30752a49895f2e9ab929dad3da019054a2ae38192c9986ca1720ca433c76f74f4ae3de599993dcf4a0135da6ebea9b8bd681b597e70889c4e244cf894852cfa3f1c0a954ede0087b4ba9f27f9801640d50a856ad965087f265a3d46396c14b23396703cf5d5c8a97ccbde577863f451dcfb9a965b839593a6ad5efb5d4e2f5af7101134f9e9f36535ad95e7c42bda0a777722c2dcdaf47253e39bfaf4a88b40c04e1bca46e54e3d4f6db123164f7c0c3f0d41a925260c1fec1b453cb4cb4e81cb391cad4b6973765e76fed7c12281daad3f20e3ad5f5f4be8564c0cc149e3ec370d8c32cd40da1619169e48bafc00d7750d836d4797354086f76cb710fbdf8edff0ddc8d9e9d230fc93fe69fdcd7e2ab4dc998eb711ccde98ea797988bffbdd55d710e22b4fd07e16ca247cec47764e5740dd3293e49484141119d3cb4258224a39810c8970955fa44a74d1b2e6a29e0aca139a67062b8e2aaa7334940122ae9b92ccddc9c25213043115c262c7ef3edf1179cfa7ff242d7c00b9144a6e2a83d3b579574a86efcda062fcac1afadc1be5dd6c8d4c68550e3ad3ebc2e22bbc6c28541ac1d0ceb5a233aac30ac7f78b515fb4ccf610bc983d8a0d8130a024eeeaeb687f13c2eae809697117d1d5d0e087eb3ceed919e6f28c5ef88e5d0da7cb1224c4e24ee5cc7a6b23342e7ad4c6ff5555ed7bdeda941a9abd1a176c7e03738ce9fa2d609925fcc19bcab852fdcb0ba220b12d2c496ed112bb072387b2fd5ffc10519f8b39f301bea3c83ec4f5bd639fed11a468019a772b421b29c9b8e6ab879bd60a7a103a9e14a1645f65e2f40a34c1568677f7683691d9c7f89bfac7be92e56c2d17bb5c5a4f0cc9299c6d163c89d7c4e911eaa577a8ffc25dc1fd1029fc1bdf4af721c9261fadf5f8fa78da8c65b3f70f0d688b1b43ab83f049c9380efd3c6541ea7a664054998c584e1320929d7d4e53bd6fde2f2873f4e1d3b9eef900a9ed42c93024ff6c34ed6c83d4d189ca3f71c75d5d34e0e09ba1b5b79656e3a146ca5b84e0b51766a86cc998c501160fd9483f41ce7b0ac3df42f3470a053e4c0098ae94fcba9fd85e7250c8e31119da4b8cb71d373cfc670cfdde9f6ee88945a42f5909c6301dbc43cfb3b56ca8aadcf3d1e51d702dec25aca2df5a8104ff558bd424becf1c5bf866c7eac4f01eb6b160c16ad402a9f91fcada1ddbbff86cca2329b5f5b82e7a592c05e700e12142e3e6c52ca212f23e205a692b3567cd0d19b38f5e21dbbfb64314fecf0f4bde71484e9f1305032808fc867f435fa8482e006c08e3d14b453ad082b3561ea70f2429480d8e1a1a5fa071173331a627e185aac031b8e1dc22b9e859419d1dcaa7619006709ff392674c05bd33f8f5aa788284378d4438a153d20d12fbf211e053d8baa984ba5990be9dbb7b2589738d8c4a21c027fbd697ec00ef647132bb32c3f45fa1a5ba50f11e3512e69f5f1abe8c9bf7a92e9740dbee5c1be4906347a350c706325239ff0b7c3058d7440c78298e44c9cbdf07d312540a296575bcdd1d6883d0b7922e34d9717a83340c802143a59cf337a07dfbdfb25fde1507ef3f27c5b664e175f37e7b4cdf0cfb5e6b317cc309b5c22f7e2b49c55d5cedc6a643c5e3bafa2e97a8b73a2343ed25803a011e5dea025bba945ebb809ef4bd138297f696dfc00538d2a490ff97cb8b1bea70e6605be4a8e92d51cb2cd0fe9fcb0c41906125c6b4faad6bb775ee5223abebe6534aee937895ab566171de1c23112079a2c55b5a3bd5e73ef7efc53246044b2ee3b6753fa6911cd3b638be0ab11de146a4ae577e858be1e623dfc8a6d605db092e27dbc82a535496c1b121c2759edc4cab72fb37c5596e70bfa25677c2da2f5603956d88711047ba351ded5f384f89df608c8f4a4028f1c8ac5a2d7ead4593ecd8a1a59f13e3240aee37d7e38bddc90e5e2e171b7b8cb04a86140bab1e7c9e6704fd720dc584da17e9b539240d98b65aab5e5ea5d86e47438caa1d4b4618a7dc1731a7e64909813385546c42a2a5b7cdc16aa1172c39017a2a29ea14e550fd2efe0b19fd7ba4a8a5799c0ab96278a64b5326f12851e8ceffab67a373332d27dbae1d09f24bbd219b49e7ceeca174096e9ffe925315c8260a34aceb2f64bfeb67ae51319cd4198c3ac96688ff9086f5d6f799e7a288282e2faa17ef84c158e2c5f5f12abe4b26c85eda52344c57447928fb822d759e1604f7a8354daae59649685e6a17a41c982a0b4d629c5ae2a15310928c0795087f0ba420eb283d49361fdfbb9f32ab6a1f9c6c35d70edc653b8e2ee30dbaa7f782792e6f8530e568a3d363c527d0cd0a2e056aff615d8910eb911b2f2f50121354c1002c439c3399ff8ed2b1e8fc9cf6740834b855d6a3684174311008c3d7c08ec7aba9b166b743199082a0f6fb0902baa556ccb979902ad206c70d3af8906641dbe35652e1413331c6714d3c213217e4b2300e1e5a74936d73de64473220dfb9361d15809a627973fa7ab4d953541b7c6afb63b0f92c9eb8065a844172d487922ce76bca27f8f7dda60328d3cfd63320e78fbc0683b162c48c73c3342c903e4880747bd7352e1eee539e56df1ee9c48b1fed6e8b83b2c65d93548ab9839fa8412eec6e344d36564e6ad3419ada625c74cf82a2cfe71cc1afcf669b2f0e7cca5f818088dba6a13e71882d3c5347f16d206b5dda2d394d8085bfaa5be0e42df11821c079c3d847795b1949c96125348022530324e5d0935fc04cd97b4ee299a3f04623c145d238749ce1b35a5c7b7547aec2b52e7a39134057111bfd82d9b06dd1ba467c98e553cdbc4d56e8c3dbccd1fae5732c7e53eefd6e51e47c0bd4e1734530705725742c62e7b953341e1976cfdace72185b35e3589c55b94998fd7caec4454def654d689dba60bd24ea45187effc7b6365e7cb8b914f4e058f893b0c100e4e6e9494ce0a8ff87e9f52cea0a347a61ab2a1093522a6847d2c2f0f2a43128ce96877b1df6c5b154c5b1c3d5333af51dd28423f1c539a2267389a114b03fd60c324059ec612c98db5235b8525e07e1ce414369a01c2de2b429277c83310d05edda446f2eb0defa3920d6eadc6f26a41632748442dba289ddb2ffa617cc39e20cfb8c05f712bc51948fb1c7502a634eb724c8a6e125b51768ded56ed0087c74a26d6c67d3ba6f4988ac5b4e642665df9cacabce1779bfd2c44e0bc29237b43e9cda58d0d27dd0267fb09f11d598de4e91083865aeb23f1f6f5213a9b5cbf4f990bebab3328bedb739da2b5fff256b5ee5338c97c1584e83bd0c696931a93c32c899ccfed7500ee95f0a52211f6764e74669f4026a9288b245c2a67d462b6de8fb639d75b37ca59b6eec5e72fd1c03eae8c84b4d0ea1a062029903dfa8ea02400be856c7d93ef2ddc78147b8499c6a3b1d25eddede89dcbc5804b37c02aaecc404b4854cf1898b7db8459df224cdea68b09c5f8fdd270bc5a09e2ffbb911eae93e5df1bd1e1903b18ab2945fbc2a9f6580948a5c66bf3b4fceaae89599a8d15b3ade5f180860f4ed2487c08bf2549c960d64262cd748915a1f2c5bfcfd8c10c5d9775c3b2e31e4d83f365af5e6b0325e514df286c89494ff898d32a53a135cfb1ae9fef3b00077c8df681b62c6b6eacd7b1a201545a53086dd376b418d86aa947cbbb494e841bccbae368faf66e72bba527424d3525e75928c1541e8e6943d5460318abf7ddd7b4c4646c643d391c6e8cbc213a4608fbe2909e74bb0dd1bb803a10fe21787c9a3946e8f6c3b80b539de54a8ff2a924cea0604dea1fc122d307a76b12b22a379a7c0f669b5d2aed3816ed78d818635de404da84fd487161188b97afc319d264927f6c1f5cee3f6d4242e9868f1460f39030fa04cd8c99807826799048241616dcfe88c3b15aab3593218c513a511636d86b454a9a64dba72b2d9b02cd0e900b44ae984f9340eb5a42286005ea34e0a28d8e9bf7e8afbea0847775cabbb7a7ae640990bb7f6a8935ba70679bd4becdd3787c51a4c5e3b50f862800e5b0d837d717d3a7166eec237aa742c72a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
