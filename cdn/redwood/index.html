<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82bc776fe70bac69cbb49d495bd54b3d32c5a9a288cdd86672f0ff1f8e900619bc601204d4a1cc64624b2f712cdb2ba7a541506b7494441b68d325409e871ed6f8b0d84793466e2e02f6ce379bd7a5aa96d70e0b98c59fdc91c56e19ccc40c039668fdef816b4e90ae360979b051b2ef825bff43b95d4aec861346bd2ee9b59a6ebe1dd38784cbcd2375eefc168b752f7196c6546d734c64de434ee8747a645e452795e83741f8b713173ca8f2bb490a1efde561211ac92153cf1637b76de7eb348352499923e322defe5d9a398b3b2f3ec755b8e7de8998f725672be97d1112956a13e9a62781124cda2ce3f987a33c8fdeffb41871bc76a0f20a3a9325e2ef4464dcf63781deed874000a1742a5a64f4deb9550d0966121c209c185a498e4029ae6f613f94bba11d7e94243646bee2b8defe8eadabf44194145dee74c9819b5852bc90bb22ae3d4d01710381ac73af0822dbeac3ca7f82fed31365a12ce0fcac24d3fc3bca5bc847bbc293f4523dd6949afdf788764e1883eb3fa385be680447bccf50572d7e5668f05436fd31f84aaa41e1b5ffe29ddff312ab6ba28dab3224805e26e50771bb95832fa48b4d962c9a1f390b00e042a3d122b2b65b3a1db4c0be8f8936c6ce3a2a0e99baf2cb7a4af153cb69ba870141bd8ba28fe7b37599367a7a7cce7648c737b40865f4b0b2caef44a7f5c1281cc95ab1709df6fb1e776299a8f51081d1d3d37c80469ccc74d0aa592d6ec36893f8427402bb57b86257454b3a6777c156a0d170ae0856d1bf75f03357b211d49b4ccda6cc0b4738715e6a5d3471e85c6dcc2673081ac051d5a4563dc3e8786a8ff4861dff649f2ec2f792143b630746b9845addc079436b498a9de596d80119c7bcde0f684cf30dca6a5aac870d0cf3a571400763dccfcbc782e1f61481dc5ffe3ba5b15f16a7c44d33336ea710d9a4ea90f09fe3bd8fad3764938f0ee6b58eb81511a3731a6d2fbc73fa82effdd8256a954d40a2150a2a608d093ea99d461554538e3c876339e3e754dbaf527313ca8944e7ab90bbdd9adc3e0cc3ce41c05a3bc1a16af3636a591bc155a4622b472dc664e7aca27099b34f0a071debac7f981cd3a085155ab71cb2dc9973dca4cafda70430aac7679dd892047fe18eaf3cf997ef818e3d9207351082490c3b4a1a661e83992b88dfa81209959eee257cfbeb5b1afcb8896c400636321de4d80153f336b278c00d619a776a636e316973448c7b7bcb0abca6de4362e9152921ae37ec611e11039cf043cc495903016dfa558f73225fcbb64871f03e6bb1c373117dfeae1e484ed3222086ecd397459708ef7fafe6f3ee3eae79412c7fbfd3a509d93746c5c43c0e64484ff1b719917dd573f968069e2586605fe9b72a8537604aa3822fe619652e799f8b0d8f063b7d73ce7c12e23ce6a50dab0455fffbb41c31afc0a4a76b5e542b2f8d6ec0bc6d5830eb2f6d664f1591215f87f9c16202eb6f61f0f8edcd3b926f08ae30d9b6203bc67792babe630fd93e6694951d75d8f591cf059c6ce160616ddf6eb81f5df344fcdbc334ffd1f756422dd70de40882347194450b65f1f74256bc9922b8075fd4fb354e8d70bf46f41fb5dc61ca84ee91f1e8e2ee4187e5ee7d3ce0604b1abd6f4e55c6ce56574b0f3746fa5bd82733aa4b9883dfc938910e8fd4cac00893b944a0844344289c80bf7bd600a4b342bd2d58feefd48a4c5b78d6c530f8c3ecb8b30bfd1e0df253c53f476e6f0d74b80d2c1e4525f608f9afbfc2824156bbc95d59e87c6a5c18cfb1322c2d7d6541dc4e4f990e105a72a4707f14748785dc2ce649a9e633d63d6f5ee68164ad93dad24b3b10f89a63fbad0a46e8e7a52c41284e80221ebe0398a1e61dc4e4464c0025c6521144240fcb27db2f38fbb178e4a3e238d2ab769ca5a622d5d8606c13ebbfd6c24577d41f03b107d29179f70ab3760f5c3a91701b5f3876cd19b3f02f5c3f56be4417a0ea405a38e410de27c23746733e53ea8dedf7beda05953be03e278b3f1ef94cf6466f6941afed34fc0bf1d8635a442d527a9165cecdde600a2348bf9bbb92232aa361774964f78ea1e17a0899a56aad9b439219760d697cbde9d7eb09077eb16f7182228a38fd9095e443b5a5cd42af698a1ab38fa225272c5aab4c17771460b42b72f7ac0441852704b2fbaa5582d8bbaf13fd90e0fb023a32ec75587c4e8941dd4a1d54531ee34dfcf8aa368a6504f9be10e938d88a82ba9f7d199991556190b7d8879b75c512cd9bd1a7a071130c365980b9793c9c704b671f4ba5ebac44c08eeab94ce2f3875b4df366fce93b6cba4f38356c3230bb9a53ca357a8537bca8c7fcdea682d68237d6cd647a40e73c4d2ceb6a7e76aba551c07071358e5cbab352be3c91bb8c46d1775658278f261bff34a1b75a7cdd2754fccd09e8d9d40a1494ebde112679d7563f4c9521e668cb9dac8c8cfd80f5167f41a0fb59536aec97b6c7b44a78ab4845635b182574ffcab182d677e6a1bf126f195919a27d5d7b629bea77117d1c6a1159a37d49360a9a6c2f2e39db767b4d6bcbda81e9167a14ea0d8fd3b78e955f9b03e5c62314d758089b72a01d7cbeab0a00e662a5a50946e8a1658effc8b408e5934bc1195cc4a6e2b276e8cfe0f27c84aac08e7aec29727a2bcc983d02ea2f33370f4305430e32dec1888848d67177eef18f1e3bc6f68b1989a0ffb839e634ebb9bbaed7bae9182846e61ca53ba9420781b5b722cf635b0fa34fb281b1ccc8c31cb42e75b56070f8de6fb128f75495cb67fbb6e91418519307347161baca3b61ac65c19a33b76e03f8d522a469d9d0b1fd296541982f902ef072bb51d15cb5620c3ac548b0096ff5687daf50579eac272ec485f6a3735690de3ad587a1d4e41daef1aa3ba1c0f3d8b4913cbe29a48383869d424c6f2346a1a02d4f536cdd505a721012c67091b77572ddfbaa291476bb51164ea312b8a9e516a4564857c28ab2ab3abbd85fb952e72940df357e223c290d8e7bb139f534d9bed6cafac99325650debda91b8e4d84fbbedaaa94352bead26575c0d891ed72fd008d61deb13d06ee0125e434b71319b0be655832eac74c2845be57d961683a9608ab65f44593cb19ee30d7f1421defa656236cf259d480f37098c631abe630bff773ba7fb13c4f9965f03b417abe1f0b31eb1df58d7a3046370eda481f033982897b59e549846d1eaf4e535e24e5c989a967377b2ca80788aaa189b72e7e2190850da69f6a79d0792f39301db2b4d835491b33abba9cd5069117a9c0fe2d34a60e3f520d631c8b8f6241a222def7b470e34d1c0ebe937b7d1783ef7349c66b3e4c998ac78751875b0e9242285f1fe31556daf3134f22d7e2cb5372b834eb196028708fec917a59fc18e392b4f39e88cb90ff0deaa5bd760e8332e340a89452ce7ff1f14ab416a71c7bd351a493bd4c892fb9f83506851a9cc4b5c11022d745cd75efebb559d5c7566d89634c1bdff119270c3bcfeedf0f36566e9bf69bee5d13023d04fe79e59c997746115fd2f9658709c8f6d940c66b8eb3ba020c5a421097a9bcab2b49ae8ce26f744b2a07338b03830614ead430b1ad3aeda880d87abea66a83dce1965442a12bfc6c2062133aa08bdb1fe0ff072281ce62eeba7e84d9c94fefadb50fb522783fe13e1196158861a6cda663c5109760740d0953bff8f5debfeeba7506746fc5d1bd7db4164e97799ad5c849a81eb54378786d8198c92259c224a30541b279db1bbc1320e2d381018c9362b80730a0a4823f759c5456a995590d78f0e6811f6c17a2f7120e22905757a9f32c76780ced217bfba190a48f016116ae97c6fcb4d2d90fcd00387f810dc7a8073bb53de3275289956795c1e3f87e8e2c1ea297d5ffa5446ca51c8c5fe90f20703d58796bd8087ba77921586fdf8c16de32d1d1fb5384b8bb0ec22c0884a10a73dd5eb6fc6a698b07e39b9cd9260523e76133b61bc91f246412d3995c0a4785895ef2f61afb3283a1c2f693b20f3ebc8b997dca5a6189ad52099ed987ec2aab29b696f19225dedb33be80758162b5571d85bd7d66eae3d612835133885048a0d931f7239bc316926cfadfcf317067426f60512820e9be667321cd9ae170fcc579987df2d6c426a1c928b27dda4324d3faeb9e23184002c1aeb8fa654b932426ba42418f15818610c521a0a2c98a09dda70bec76480db1c90f6f38da440f3ea1157e6b3a2bc44b3f1dc0d583bad7b49006f699a8a28a3356ae02fac25271aadb779eddfaa3e637dda73772c12f0fce9be75e8529a377bbeb61c14babd66fe0a7edbd7e01f18ae975b8f2dd210eb9a48e71d1c36c2ef31b020c5c5c10c22f95b8a76fe52b92d069670f7ae4439d1880083bd3327ade80ba9ddf41d56277ffd867e306c711ba85901ae02c49d729b227663d4ee6ad161d70c12ed5502aa817a9b0ec0c17dfcb64fbfef3416b0b33e16722674887e8a8df386106cb26bd3c712538a82becdfd5b4abbd6968ef3c08b7bf9ff7ce72dc88a33b4a5a0018ad9dd8c77be24f565fb4115a67a95dcf6db03d8f1b28b50e376a1a41429cdc3319cd72c2ae69377867b17901563e7ea92009e08f60255f848a6eee733bc0ac1dca0e7215dacf21261dd35520c66e165ab224f81c40ad9af57a0be9e8a4a5e011953815b56fbb42024203e47b8fa58de6aecee33e06668f6c9d3df7276c7d122eabb049b7775b93f4bad1db2cf295d9d899c54625aee0b0005e87cd870030f17b4227632a2b129d3fddd840a3faae3d2420a11f77d03aceddc60e9eabcd6ff98fcb6e99a3d9f962fad2d89d11372ab5453f98346ab00dddf0734c959827b0cc68d6b5cfb74de9a1080296327b2683378a0d34418d77fc39869386c15aeeaa2616ac17357f97a77f6b455447e734a08276270e093b0d46714a43238afc225acb14b993e6afdbc8dad9543fcd1d46ebfd06a9ad13cb543e41330f0ea7f537d799f9923984c244d4bd6f3bb6f4e0c34fd52a23c1656978c275fbdec0822f0afab556ef6b882fe597d8d9dba7dd7169035d23976515141884dc5f3e839c354dceab97112672df722c99792e90840dedb4505b6ff883b7d6bbb042fe57f0155d7365a6ba3d30d4ae6e633699dc89c9d94f759cd34675abe49743ee27f5ab48fe1a89b923706738caa8fffa7ac5766cd542e783d8d5e6c497f2e8cb7c7aafb2edb80e04ca4f7d7ed7471a09a98a091ff179502d5172f2e0ecf3993b11a264ff5c0a609155d9e373029e11aea41afca797770e7a971cfe0ab10ef3eb323ccf256d7341250d9cbd95c8ad42cd2e3b326a38dfe6eaf8182222785c6a3f69b26bb3bac04f8c5a7db785bd23be42320fbb602c4d8191b0cac6944eeabe25be9719609316f1ae8be05ca70c1ce087b9a2f52f3a5a2b72e04f0b639f3c211f63f86bbd9ce356d165d073786c39c8459504fe93f23173d3db3e6a47ef5617559e4582014dff53609c14d2078ac4848974a381032200b250cb6f904be5deed86893c67b344be02ea6390a87dc1bae85448a04312b266b7e1e6730f93ff6d7e05f2a4b63d6b178281cfecd14fb88fdc4c11aec76a64f06b035812a58ef71ebebe8ad6af18176b26820ea71d5f3976ecc3d3a444ce37c9d8fbf82588585d754d2d03f7171ee2cb8b6ac7a889fb6c76b0bc3c4173fb179900b67f8b78f35d624ef8c2610d33fc81b08716ef34f3bebf368fb6019408663a6f2ea5d809f188aebb1f99a5f8ab0f09742fc6056cfe1951784a8f5f576a7281277c359fdcc34ff635d14cd7ef8edc73bd1547c05b4443a1d95f6f9a4ecb3ec9443ea57a91bd9633dc6ce4e3c0e7583ed2e7e8da4fbaf7e0a84a8ad96e07bab9ebe9d6d0915cca2ffac529c8f1b63c07fd87f28275fda9f13189340081f41aecc4c02494e3fe1a6f9667636ef32b810b19cd4161f9baf52f27486d28e68d9c4a16e39052a7114e21456e5fa01d4021c30622e06b6ac3ea4aa9a3a9a7832feed94b33ca9f0d4a4fcebb5ac9a4353489f8e8a5ff600133841a297c0faa7a482354c21de7665706724c2ebaad09fb34a5be5f3886fe8c2b210c94ff60f97a12f879fecd3eb04553353e9c7485b89272b6befe0a3c56bdc51946117ee32280bd87f2d612733ad0818d4202a2650c6f5dac887dc3af6c11005da65537c1dce2781c9c73cd2647c20d8f14822f050a363bbd09ac65efb83b8151ad90cf1bcb1a57edfe37c5b08ad0d7f1a7c102db262b92563bf0189c5842f270634f7b310005ef56e2c7bd88b59d1f3936b00ed01448bb9c7846b8cdaf90af6f0938444d6b59be3cee4c3084c7bfe10270ff63ba53ede4da03e1239e06c094a683d06ee2564114ff4c988487128a1003aa54ba42b875e4734a0ae75d9d462fdf172f50368ed4d1e3af6456c68b958decd023e886caccd7c6fe68aeaa4e5144ecaef6c045fafeeccae1f2803d142598a2cb61f8b2742850ef53ba3461e8ea2fbcf53357c4268b8476df96967c44900d10b36768d688a34df913ddfff0093cfcd04cdee3e5de7e0bc6ffdcc585460d3261ef268a58dd7c755bd3a5a2159db6e88feb6614f201269825691ce32140bad95c0cbc899c9eb4118e26bde4fe024fe59a983b9b34272abb8c8480eba24918110446f90d4d8333a5e34c1d0919e9a546747a4c2f52d5460bdc006076061d1be96c4fcd2dd117ac6b61eef614a2cd26adbd2039dbf0ce52fd236f5d2f48314c179c6a3c1cf96b2e98853463e643bd694e0d4da6d81c9aa7700a571f7842cda6e202677b754d921dc84616c47df580750d84c82a0e03d96babf17150457bd017c0c79aff39069895d8e6d15227b763d76d1ce5dc1793f727b39c92f1cfe2a3bd2616047896a2360e8694fbf73a6ac3700ebdc5b019a00cdab9fa58e19052c144fd072bd9df4e00a4be45d65f8e17c137ac8840fbec4522ff34a118e42105ccd2f10423e0b5f6d8c07c75ec6f009cd116a081274d1af9c75bf00938719da19670e3364d01fae0c4a9ee65b690d9ac3a313a7187d582da3d9f5cb78ba496ad2514b05395981a70f729ba841bd684decff704f79ed54c1378430f440efa1d1fc433c41a574712063aff1e1bc9766843552472fc155a5f7fc7fadb7b357fc8c65c934e02679442a8eea612ed73229eeb72a7f73b714bc97e4109fa9b4fd8a8449785c02d2852aaf533dd192fe508179c29a1922c9d9da81d35fd7c3368846a55ae7991a9a6b7815d3db64210c9106579e0154758cf75be3ea2d67b7bc1e293f4a036498cd648ff49973c1f74cfa908b89894d816fcd301485ee474edfb30ed4ad59fb5bdbea118de809efb172e03ec1b18c835880836312a70ccf06a6eea39e39deebe7f836d4ff89e2e7e02b40353d55b2f99140971ffa928c3b02628e8cd4e49072843e70b13c9941a3c7d91df12f1a42123aa0a789a6b4d4a077da6c21b144728afbd7b372c0d8050fe423545f961f4cb8c06e1b1f180f9c4de93c53ed6d6c02a349e46139aa7a7683020de8bccc850aaa20879e32d4b4a64cca3fb13bc87b8146395eb97b2120cf77dfe8dbc6dc6c37a7d6e44a611f29271121512de9c915740435c29d71f1cbd0dd5351c0ade23ade358ca8e33e67c8bbfb0a6c6d6ce53c52c7a0797d2d1396045738fb3b30015fd665484add554c1796b18e1d1cca65efd7a0d2e901743fbd589ad903e1ac8de30cde605c0c5401c61cc579e88eb860d742965a1f37871ca0e055c52222291bc0b610a2aff9a101ece32ecee798c211fc71c46e70c535566a4776910d31f251f2c26b5b49fa1136784e10d725abc8c2a2dfcf02b467b4b8cc51422cd0b92e4fd0d2c28b9e884b7c978e200527808f7410e3ddab0119d4097ba31c11741e28ad62810f6240a9849b5c8984052057c5e1b17f59948d92b2d9957413e19b3c59c2ccff21ace57138539f2e0b8242500d134ad3bef0b380bb38c8e005a80dee49aa6e7bb7ba299b131d3415cd6a9669e158f6aaf68a7490f6cc338d90ce48357a8a109ae4707ebdb38d8044fe5f3354e5ac17613ce0b0f876a39d7a956ee13148d3ed0b75338763c5010986543611fa97e52db3871b6b190d2eedfb38f978c8673ca5dccf2256ce4e48c7133b76535163256bd5e398f09822ba47e099a84682b3c4a72d600198bfb440b83d199e7cccc95938d0b680b5ca55ed2f480d522849241712a3e5b431f344d846487692c02773336eb30755b38e6e78cd41fcbdfee8779c50df7167e35313c8c8748c7fde65cc8ffab4ceac5f20c91194df77528ffea3e5e65382f85152703d5603933026178f80897c9342d77315ffb4abb8a84c182bd0800412d0326e79273f88a9b609b828ff35b71cd87362e377cdcc90be2d7f762b46a2815ab8d5a7f16404338a97d7914b724465722bb2713c3fb131424764ce85942c5d52541b00d4a43842b05d2144bae72c55b9a4e0fee9904fc1d58eab232aac5ced2be2f76b588d73ed890d267071b7156b3f77828a89b6938fc7a2f9b261b7d35ab4d5de68870b5a62a627ea42f2de2c4ad5322737ddc43a8467c5e7067c6b43b4989e60c587602936c3256bebe096512515e23184b4ca32997c7c5bfc91cacd053fa094cf3d54b649da8be954426942fe617831ba3ec5bf497b50029bbcb1cb2b059f4f8425cd6f0c097fc4a609c11aba5d3e5959d9694edd92542bb28d099f2f1a23bb8be0fc4d540732cb3425fd4cc11955936d6b1164c107c9c7d0bd533ee40ff107bc70e28340c62f18cd9c89bf70da2be7b9ed7e6d021166800148be8da6602e55f313498b485d00e216e98c9e7d5548e34df6086e2b6b91d5c7b401cf9aedf47aabb9deb09a58acaf5d397671a1adc93c25ddec6a1625f514e6e405d2748c5aeda92af84111330828085b80c069cfe43a1738280e62c647fc7963060da75e15a4a84d2d170e037637c155fae749362ac7dd24025233cfb2a64c082c58543798a06d5c42f2849aa07dd42367a14a2e834b02171f55ff75e052a88fe85c589859a4a460a0109d1b48fe69dbf9e239591e0997ef2ee2b0ec8920db2e230b02e6cee0d7a3c6281186ad3d0fb4ef80818da0a3efa94af8785dd2c31e2665a2be2531e5c3d701ba7a807a1afc6a6e80edb0147ed35d1ab117ace1856cc6358bfe68ee90b2d3f0515d8bfc5fa0a745bd063c106424aff65f92868f79abdb95edd7d1e4fd42f02eb13d43975d12bde676e2f1921bd0a8c972a93e69309a63b3f28d1d3a7db03c40ead0850459e8a66f2a0b4bff9ec4f0f9f44301be282e55c55711657eba7835928ae311bce78b91d54564293955298b91d97cbae37f092fd3e26f8323f567ee0ca0c5ea5eb8f025a0c2287370926f4acc1c21e6ed017c0474999c05bda9dc8adcb5d24b88a2969221f7230f9f1883fe679c3f8d41e223ec0a1e50a97f9e2465349a1b3191164d30e161a91634b60db0ea489df004267addf0bdfd0af0d811b38dbfbf155a7e8f7c3eddd10cce7b650f2bcab7e9675e5afb81c20bfd0e7f78b09899f5987b2637af264683e0a3595ee953fb837e2f51575ea27dbd12655dfb8bfed24367d23add130df1dad122f7236c686a9c0c67efdf0ac4f2ec9921c1c4a3b8e3b2f0554fb33aa8ffa28b248443642caab58afb6f5b8de20f735c4dbc4f84ab3a82283626d7ffd29b7bab094eb719e8b2bc26583e14cee96f283c3b37f3add561780cf661ae8c0bfbe31d4b81c7f5edb9b3597e927baec6f473dc658f2ed69c16c8e918bf1634f736e1cf64ce4b73c7bef0f24b57244c3b6c67771d8df73475d80ab1603402923c5163722b53307e4ff64d033edf709b2f64389747e599bd8c4961ee53dc4c319d723fd645da9e28894107cfc55338e128dfe737cb257458488d4269552358b556d22ae2b3854ebf404a6ed96bd59cb88afba0bf874bcae237ab7c4cf326cb4efe5d708637c7151f3c6611964616857430e03d91f6aedc6cba7015fb0c0e2e088461b51683338949f009fc81b5787d6e9a4d60d1dba95db4ba5f06e47088426f6f142bfc67432fb6ab8c8ccba3a1f24cee7115e00f85a6c027a1777dea455ef71a7c5a28f0c910c6f151c2dd9b28a290273dd66fa448d488dc3da4b4f50ffda206048e3b2b2b73d9cb0f74a92e357ccc2bb47d5726bc1547cdc2796081c127f7df20f86db8ff3bf787178c4f155201473c4e2d0de63870d7b3e122262cc82ab6d81dc83e9c42a6e0460128cabe4706a2bcc4b9a98adf0074fadcdc959ec5c7c717ebc37637f8200e8aa33ea723bffc49eda582c1cfbd1857f1cce5921ea7a3a7de86a42f3664f719a4dc1e388b6f6b984e13a315f602675dd300ea3c9af39e7862862401d744067c658dae9b37471968d29021609afbea0052600f2c9103014d32083a19b27c9dc904797ab90c96f5827f234a2e613a424cb2925cfdfc3dd8ea34a4f3ccecfbb20dbab57216a78b3817c1fee14c0b34fb0fb2a677f15cb27f244413ffd17bcf5ec0330046d9167a3e7061379732c8e1ddabae465961930bcacdb7e195bad0f45999f6356d3127014593007eb080083d6c9b44ad42cffa9421b57aeb968f6d12147a154d0c97bfd1176e6f4b0d32faed61e44af58cf0fabe19a88b349ac4cbb4b03d937c4ea2b4c57e565986e57a8b717cdbfea6d93ea9176d9e400f3897455ef7c57976c2041810e33f04b9145a766f28ee35ea0e573f2e54552c206e1e15df9f3206f068f8493fedfa6babc1a83d8e530f770a75c7e3e050b31679bbae484996753c4f78fe21cfba9d1418fbc009e8e8c7975a0d4ce5384a9aede2115cdfcb8eef22154a89b7be94ffcbd23a7b3a4cba8db914a517506c3b7f8f462336c105226e4d29e1f5150a8148a736d177d6000a92031a77205afd080e7f11d0567283ae861325aaf3a00903ec5e04a2c5a2dfce9fbeab81be900a9853d57b46bd33bc81b9dcb987bad7f8eb11c14701b1475f26a382ec98e00db356a0a7896bc6d9a88e582912446f56f99dfdf0b5de54c76444738d225b95afe1fe91d94a3d091a778cd0931f1f1872fee3f846d4cb40ed223fd63d99a1a6124b13f3bd5f31d039275ee4272e280b327767f4149ba0df99d7872a493124e37866c910bb53846a1b547c9e28a97a21bfd98a6ed3c99ee3a90172839aa1eb3a782423c2cfafd634c9b72dc70db1c2c7107ad0572deb6877e2dcffe07bbf64b2c9532a2a6fbbdf6ba7d1e9e8ea368b74900e0d43e8b294578d3552d54b8e5a19c7349dbe097e2ca889f09a6b56e6bed23d2b1a6aff6e5b2787933c86dcd6c5183df95fc7508d9e6365f39461b6f6681f36761a77fb6e9a8ce7d21f9bdcebf70c7f12eef3b6bd138d4e2616f8774634a05cbb10488977af66295d1345dd34755125d7bb62feff81a0831d33ee20c21dc27c8e3b2f3661f6ba84c37e61059abf63393bbcedff4c9c105b508a6146dbd869852b8501afee93cf60b01768fabfbcd8acb2ac70d32fb4d2078ab7af5f67ed30609ae9464d2c02de7bc9336c3e5a00a7cc1a8f893a3ade7deda89635740ca5b777f4e471cf45c90a9466098148c5be89acd66be4bfa471adf21bd7669b3c5ac11deb019ad7ae7b5d53a7fc1c48959edbe53e3be44d279cc4fc776da2e5349370302d4bac90fcae9b7c67b4e6327220ea75d5f5e2ca0c05447396b082daf352666682ea2069ec165e26b9a4f469996236a346f4e5d57bee2a7625066f59916c5d4cbb877d7996eda6446178cac2beec263f48672c0b89336e6f6356acfcd68ea57b642b961a27e74a5a60f3334600f5e96ec0e54e0b6d6e597ddda4a476f4b1af8a2ee9e3ceb1e962c5679f2abd66c62ab02ed9dc83e1b06aad3d5b8a4ef9d682a20edf6e28d8c6af2d001eade46e6445a2db30866178e8a09a4de969877944118cfa68719be7d82a211f34a641669aef7811647e74b886497c21bcecd592a670c211a74d3cfb8ad91d6e745697aeb6e2772fa7183c4b8e3c2e9791442ced5dd0f7fb3ea4e6fa0f68ecdf257741e8a4c2877cbc1cc44149fd00bf3f779739c173cdacf58ecd204bb3484e8d78a703395bd791035eb26577fe2607164a7ab174d06f2a531d27a749d59369a147a55b9147ae8299d8aecdea250717796b4789c3e0aa1228fe0820a87fc84398fb6c1fe7591810ebff0dbc274cbb164536ddfc00616023b41e11b26298ad177cee561548fa71293d2c9b06243decadec75a9483bc799e96632844dd67d4bf8cb8140b92f2b6c6bf8fbf7a9a58d419573d250eebafdb56177fd8f00ff099f70af0f61e741b332af0fc9805797712aa06a43c7077267a8eb95b4d1f04b8d959226acef42e84d7fe5c4b7a1eaab0384e6ab44c6799b96c25f9d220ccfc4fbfc67e9eb820c9e81bf43d87fc11335e56c166248ee4fcc296e827263a3de11325f6481d2f923ebc7a2609fdc842f00b73a4716c01fde7fbbdea2d76e0368165c07b65f70cf2587a5b4553a329d0da3ccc1d38827bdf7d165c6a5fd8f653bddf7433c884143af8d6f064ced256fd32504b9de9051d8e57fd35a2265a89984d8a7eb177c25603517d96764667e04324a63b22777826080deab13bfb7d4dc3231c283a9335b14bfe5efc17d04839bbf36c94e1d31f7c3b89df060ddc53f951dae5397b324f02973814817b537aa565a0c8a3c320263ccfbc3966da9dcf725f19863765f8468fddc339b81f71339268d5d7d7eb560caa87a595f82824bcac92f4b45d0781826f659fa56e7051d5a31009b3f7ca9e9fa16c26ede8de925c6292be3efc622f619a58530db554eb78dd68b190e44acfba2aeaa546de4de438cad0c14a82a639ea52956b19c1d3dc334f6afd76ea5e89ea9ab3e4115282e7ad1e9f9cbc51bbe0e376800971f7c0005b47ac277102bd8ae19371f1da67f1c2a6f1fbf44aa311c98f16d2b60b9c1a7de48b1a32e4d21e38da45081678eef006aece80bfcd596b410e1e5b1f145ff6887a2890c80194c3a80dabc1021ee4149b5397a5a9632ca570169890544f60bf33637f5e9a272f89f4fcd64acb804d8ed3e96d1e5d2570d4ea66bcfdc064724c52b2dd75c650a0b3c96ad3119a354c8c57f3913ef23b24ddd9ec3f057e00ee3c93cde96625e79b72b19b3c8abb1f476f72d7f043fc034c4ce215d8f73421e3cc69071dcec203664ddbdc3c5b8aa4d0b562f22436c80d2a1c1f2d15a6f105e14308f8ff189b067d2df7e4d43b244c6b6c94e788b4aa07f140fc1b57911b26ad999cb28eb4847be13228bfb77bc58bb970643455c7dd66362953a2beaf107f7537d2fa9a4f03c5203c5ab919769d7e320bc98a4db0d0f488738ab3361ce7e1ba54361500d10a0ebb6e2a5ec4753521f045057e8c70221d60a9ca7180e9447559d102be1624b9edb75e3f1715751e0870146f2d8e25fdfd2e60c0f090cae88af8f866876a95495349a72a7c760ef70fe47a7bcda462ff0f90b778b3748712937d0dad28bf5430b2ba6a645dd19ff80f52acebe620fb2450e4fc186569cd750b0e3231dc436e354231bc028120d09141398f8548af040f8b68d1dcdffdce1bcb8b714737688e9893b289c99f384809ac7a8944c0d5d20ee784176257b0ff0d0646ea8c2e741263d6b2add7ec80458a66f7b250097a2102ed113b150a717851c830968932d0bb823d50091e8ffd6da21f62726e0aab6c6c8f02cf6e7e92c65b17148ecd186670120e358c5af6344dff7b9beedcc638c2618621e2ef2442746ee3e73032d5dd5124a494518188ae8e8996e5e75d72af16361d6c73ac0ddea268138f9e4c3f1ff9b5b6774bfb3adaf5b926684ca4afbb45b591856cf937a71cd926e8f18a1d9c3af3095a03390f0dbb638b0439ae931b842022839c74608cd51660642ec8dbf3b12be36dcdd58f0c4bdd821e52439f1716581e93465b627872616760fda6efc6e858cfd8dc3b3ad6e79da6413869ae481580ac48b9ed56d5335c31d513c782d7563f87f38202965e79d027e6ea2677d019dd9d350d3b9b1c66e49dc6f78d52942676e756dfb20368780af0864d4c621e1f126176d80dbd8414bf6e8a37172fe48feb50b1d0bb096e826071d95e1667308e15d28bdf4c2fd656c621631f2f985e67bd7aef31d676ae190dd8509d1ca640f70783143672a148b88fa456116b8acf0c5955f4a6a24027a5c0f2a2a7b408b9f69cc274fe5a6137055e2a0b0b3cebaa5b497801f8f370d7242f3b204c8edd84b884aeab55a265ea9e5d9d119940653993db85d08f5fdd46c69900e6d0b69f1f6bf7f7b5c6aacb0c62c1cf973f287dfcbbd470255f9a759756c7a09c44002555e03bc79dd3d25ed8a229c8c2c1f9499bf431e8152d2167fc57fa2e24cf14b092432443534a11e13d4bb9e766a1ee66116abb8dd0ea21cd8ea1de0217e7487d8f056e6da3387df3cec235759502b14861bc459c4862006e787866877c7de864c986f78e0b5c73be3588e73f4603472920ebe4889102caa7548934b412512d3fea59b7d1784c9c85a7002177280d4db9cf804d6710cd63efe93a974f9b0525e32276fe63ea997893e8c6073e2cba87d20644a202ad079a535cde8b315b9bb50d6d747fc27b11e8fc0390c8ec7864fb60605d818160d4eb29c51f3739b469af3202ebadee9d5f85e8f68db3e7e1ba1bd227b5581ec0517a9ae417911612947b2672affd927b60f522b33fb397e787a70902ec12563733343d93570117f6dcb782b3fe4ac4108ca8f209a3b479c62928c350c5c9f8f52d61a5593fee65f7d7354ad23b4fb7284d257da946a6288aa1620cae5b8b9bcc5486a73f0e71757353d653e8f7c0f643e8c248a255dc64570768b45525ffc6222eadd6d64ab93e76297dcd1c99264bae5503adc4d8048f3a797b8181968d3f79a25e3eb2aa6655bd28bd42a9d4269c211077c9079ee802d1010fe70caa62b0944f6b909035311e9e6240db836c4f423cbe8bca2bb47d5daf20dcf76f24be32f1cb03b30cc71e23a44419b9038bf42264e0d2b1964e8a593595cba24fc3d99930a8888dd7f8fd27a3aed80735f0a3b6b95650dd7e8fa69dabf0d488fb860d3a12e27dfc6208d4bab2fb53c1cd66035f664937926fa9aaf45833be35cb3e856b5c329ede8841d0385580ddfa804a711eac50e3878add25332b08ba7d68a092746c23615aee6ef1893d8c8737db57aa19e627a71129b53d8e21daab445a4046f2382aedfbf9706c1b5324302cb81d363888c173063a8765b4ba29a1da41b306ad29315e49a247e48de4bc33fe44c4adae602160bc3383c5d546f9e74ff6b2c7a072d5ac6a101aea5490c4a749c6f68472ad7a86bf0d9bc987765dfda7ce28ae70079a2277f0cf4fe37fff8324603a2c9aaeb1faba616687d5b1286fd9b893edf2d84e6430c1bd333058d94e499374ab11617106f3e5241e9c24e52d548f3bead5c88337a6b3e655ff6f2c552be6109585f1af66793b54be65bbf2e772fa26a1f67b927718215d173c91f75adf2f0990582e9f23de7025b4fdfa42f8eccecad56e48554beef3e6899d59dc7731624a3a017b4a006ff0c725e54a38c5b25b7bd923057f0a6c83f9895d6d8d2ddbc4aff45dd807717d2de6c61b1aea858346560817ff58e5e5c1766ba1ebdb63c13ba5d959cf380d10dffe9328ac914b626145d02d8462558b063a96314478b0ee15b0a6b98f8419874e1275795e5fb4fb6a095fcb1c1a4e55f829c6b9bbf1a204b0dc9e79cd0d884a5989eb28176225cd3804bad65257dc9d771f925cc4ef7192f3b39110490a20a4a745e789fd662acba5dee97ba6fb3503e38ff86d59d134c88cf6af4d76ac9042deb48e6c5e309991585fb7649a717e7b564eb448b23092bd73b2cfd8ce5b640d75a386d6a0762bf5d232059ce969d4872dce3a0defc977c2eb9a63cb5e9c23b0dc610da0484de959fa56760d33466cbb37613194d66504bb9c47167c19c2b4ff235be8f5ac67a8ecc5c84091fdc3b7c30a8e520bbb4d3fbb6c52494536baf2efa96eed59aeef210d07d092916c206a501dc4a78a0df0aa3e7de8bca9ed7822b0cd6180a72ffdb41a28bb8146dfd959646f6211943ab47957093eb50703c102aab021b2b2842d3bd2e569b5febeffde139c52a09ac3bd136dd6e7b172c7327c4762c85599bd0056ce08fc27a622c4a82717abb0b09c5893c74472a9bcb9aa71e631d115d667a4e1cfd706f1137966b65927098861ab93c92a6a43a4c9ec0f3187e324386cfc4060d4ce4d4234c2226432e8c739e399465134b9d61660f9cdb4b46dac8a17572c33af9bd8c526ae54b10769097f3a1e2c61b1521e8c6ed63a2752df4c3d17e29eca48eb50f3f7bddcbccfd3e1f7f043b4a2ef880e9709e7a9fc10c822bcf9a42f7abdddc8270d59c0d02998541f6b9e3f493b96ff37a4e1d6ba808720077d19612396f2bc240385e75d03cf7203b249565d75b7480daf77f36b903b21f053a7ba0f3d822c15b799b2b6a9a6954029f956b45188adbf318a28092b9eee2b9c3af311e8429ce2270569239ee7fc8d8b0922e84b07c5c990cc92289469835373c22b2a563491d9bd96e8f767be852e80947609b8c89a2d5f5e57c5db3f074986ab9b9dd5b1179aed944eda1f36de2b56feafd9e606c72bb7d96c01687c0a311c48ccf32d69ae7d583fe1ddd4e732999c608ee0abfe65a2bd8f5508ab7e7e69ca97fc1929e4f2b1b3acc92d384d01290dbc8afad045dc4d41314a138da7029269783574dbf019edcef1fb2c34e11f02bbd8a26b9ace3c950cd02fbb855290a70808435c33490420afb4d17dfae257e1c95b5357449851f45058d1bf73a38da37559cc8ef89e7af54dc593c95d5d63df34ea4a6e78817825c7b11846ef87dcbb63a2e3a05ca4f4b24a077863cdda92441bb25108a919e5a58a4d7914628a45101a5bcad5be88facec091f7b58a0f7bae4d64d4bdf8aa297e8272134710d91ea6bd0617ae43b754d4fce1da1d611e88554747bf0c8196add2ed6be76de7fefb1f30d8da6dcab02ad5be3153a7863c76e7bec5088220efb42974eec8a084761c12daa8878d5f2e19d76bb06c030c59f82ef3a22b2f2dfecf55c8e55686223e8e86cbdc4631239ec71f25a7fef911a2a64b7203541d9ad355f1a74a61da091d0e488dd40766df7d1fc7bea83c1fdba1667aeeec3bd8cb537b81f142166737687840321ebf8e1ad5b7844926fd58feb500c8579c0c4c8aa03b2a27d34cec15b1eea2a34716d26f35db948954a43662bcdd9ebc2f12ca958eca3c1ca08b11f1d0f03d4276b61f49563d4751473ae2438c3bfd82a4b19fe5677d15280f0292cc41af5db1a4316b881a7b2960e7a6b3fc045ba8d5e19dc7fe58ac2a02f9162d2ebf786ed45623096953bf616a12a6ff4b4b25b931ea46ac2ba6be66e80ed58f9d61d0d945b48d763e80e857ebcbd799ddb7637e69981f37f55c5b838194b8aa3267a8487ef0e445c04c55e98d5da613475b02be03290077cfa6151f0fe1bfcebce2f77cb117b295b04857d4aa7a7d9e44e048069651680d072475f93585ee2dfc6ce5c4c66d010a8ba4844876198e3a86d3df1f55a24b4a5d50be738d440377b6bcfd19c1343d4e7964ca450803e52d4ff784c8d26301b8aed023e1890552644484a3b5f01476096132f8874f8ee066f4fb0e5a1f20ac0d450eb99e5ecf9600fbd177c71b43d9412a5ab07ec8e9b3cc00edcbad79345a5356c7bcc0b5e1e1836a97c79dfd4ee64ad829a0d841612585f1ef920ef1758dc016502f02c60bb9c66740ca94b37f2d6ce7f361c8db2b89af8914708d536b10c278e19bf87963d3821d6c4d573c5a04855e0da196cee1a4236b7217e9f813fa87484a9b0feb92176cdeea73291df4d86192f5ea130a3dff61996e56a5f15255de5d800ba2e04923330891eeeae5f2507f5db760b1f054334ed372be53a246e42932ab15f50824ac562f59f6692ef9fbaa46768ddb6aabe63b38e1d478b6ccefa8b190d61e53dcef41529cfcb1605","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
