<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"407527df0ccb99ad044a72c8b30c293893ff8c4c80c62b3159aa9691e9d570689959782dfa062c1e91540d93b9f535ad4d1dd44cd2698340694b991e0165fff6f923c4a1df3ad81b600cd9305d934d6aef6f09ba5d8ad9c927b147f19e97570933456e896a8f1a481fb8b3ca598d321bbf77d0a1159714289f70d279deffb29ce45d501cab6381357d5b8b41f5964b87437bcc5f87f5cf4517f904619efb69ca72251833522dc42a0b2f942baec5a5b9371fcf74c7712eb129a9b790b629f7b8f672a9d4098dd2a253ac28d21706d9dc881f51c807e9e8282c8414b37c669066824aeb3fcb7e845f08cdbe739a4d8c8cdc687b96149662e29b6ae555c577680d1431880467a27a5bbf76d8463c9efdede12fc4ce1ab908f23c17567f49aa4988810998799f2c262753b39be91c5b1675005a6419b542a0a367127c7af4277100042fbc5f6cfa5ecd63ac66915f92623187190096ed46a3f82e3d7f6f10f10e55982dfc682775bc67f48889dbf9406168e108c43b51d07ec4019abb56a63fe3fd387a3bbac6b2e6b214e13c2e68c4f09abf393091a7b664bbd1ec9ff4d2f87fd30c809604a231f8e6ad3d6d81151b11fdafdc9479a738d2dcc6416002bbdaf1753e488a1fa7accc7e9eb972a260401943a3caf439422d7a3a8e4144c35276933a0ccc85be9ef21e3a68a991a0035af68acb26a0c5a3c407ba0a3bff8b1376e16161453fc9d5be7c728f7d6c46b0b12b461081e16c3a702550db3dd5501eb4ad0ea19d90fb2e1366b17226ec77bcd880b5e842924968011d104ffb5e1b8cab7b3c0c81dc6fe4bd5b2644b6ca14df3071b59b8ab1dfebbc5519499d1a3defd68fda977c0e1f4a27b8e352ba4f092dfaf629e471476a3011cada6fdbe4fd56d0153c3a3ced0c46483adcfb8e4335d7129b4e11af576fe78ed64561621ac4a98286a5a31db6f38c478ffd5ce582dae3b9abe1e585a4135957def5676f4dd3e3cd8cd204082597eb2be8def70ac3f800786eb7f6679b8adee7d3221cad25fa14bfc5f85a16ae7202af25660ff8beff86ffbc2de1d510cdbf45ea16d6f356fdc5ec43f190090652517887dbf55bc731b2bea66c0277d14f43d9062d1e33c427de6acaf41c4cb290dffcfd46af3b619fc8e615df8c2f681557cbb9184a40ecfd079cb11aabac8207e9d14e9c428b4ad1026aaaa2da370aa157da3bfae39967052bcfae8c21cc4ad0b39230cde25244f0d3517939aecfe64b9da97824b9ed0c1891af507bc3806f2b8697e782aeb50595114cc1522f8a93c10516443ac43410ddaeef241a57726d45425aac2908e57d82730f4fbdacaaf3a45132a6bc994fbd24d2c831f9bef8faec12b11954f44516c32488796c905e6b3080dc0eb9b883d196ace5839435b28faa3113cbba6b4463f633892ded0ddf7f31cd5700fa358ecd5b82162b3e06d56fad591f38c513fdc81dc44ac8d1cdcdd089302bceabcf476f4a6adf1f8546889eb1aa74956296eebffff4f8e4881ce9ccedc82f707d9d8135d444809b346c56a5e7d98fbdc39940afe9790871d1e8017b042a5208b86319a24a1963641c57decbbf13214b9ecfdcc45b69d869ef8965338e12f2050eb1c20ef204535ba9151d3ded8a16ed91dfc534367c6fb6dd21cc3ac9c8874cbc5bbce3fc0ff814b2f6c3d963c1f8b7ffdd55a0deab34f1ffa275428d8bfcc5c254bcbf64cb80d5c4136755c8772822701b7734b93f35e5502ce60485d858df7c690af8cbdfb0670827b2f3fdc9a8310454a76f492dc751029b90ba15c403f7af235032e5c6fd1faa0d66e5ce665613c20cb17f6e4aa3257c0c1c3182814b3273756e641ae1ca55e2d6b33873ae166ccd31004c1dbf47339e3b80793b3fec35e5d1d27404d8adce16d984beeb42ba76bd54cf9b9720c8b228e38d0c8f980b188cd424b30a226dd20f5aa4353d75648ab43e16a84d75e865a7d0ee784cd73d97e809d897d67f9a5d31c45f21155725f2b6ab839ed47ece61d0f721f3838653e4eda8f48a18d82b15882303e069e784ad7c5f43b7c7f7ba66a6f72d2bc243b584da991ea7802379440b93b8fc9a18d9547f7e3e679678882b5143f77ce4f691d9c2a5cc0aed8fb68fe5a873e42130f5c42627639f6770eff854f1ea79e42e7f18fd448a4762af6fcb0e69c74680636967d676a08ac816c63ff8a7955296c1225814fe50d727ef3bb1ce76175e8a05094fe8b30fa9ebb8d5bc95cc0619b7f09acf8cabaad1c520fea1b4ef6ece07006d9f0c12eb6fb728d798e9d6f824eca26c835c86ce52cea2a744087389575fba0b42ffafc0eec28738b0c0e57ed80a04e8669a8f95c59171d1a73ff56fec9e44a6a08481c44aafae9d44cbdd60360c3b4e582b459d577f951abd5e39d2702bfded660fd8b77f56556aaeb14b492e4ff96c00264336a1de627005a910bd9802185cf0de823316766dcfd1e73f9b7dfe2c22fdad91c19a9929a4bcacd677a93379bf763e4bdf4c9696e0590258e5dca0c2887b6a48e6afe762bf1162d5245fa0a28510681aaceb5ec38613d744c3bea3b5a6f8b257cd1a353e9b58f0df2b6dfd865955dc584379584d7bfaf82edf5d9aa59c4154aba1676d68df1a5eed0278aaa1ccac698bc9d7022875f5173a7c1e8cfdb1cf18ccecf2e1451febe3d5a14823179e16d298c5db930416d53f02fbd5a82a143f2d8c2b5c9979bee43d830220e896199e4638f1122b25fc545834459f9a0406a696f63f93ab76aff6fd1571206df60f6e6e3e1c6360688a9339ec901c3e7cdbe95fcab398b35b0d2bc5bdaf21dfdc8a63097955d57da32061f724e5019b9aad1557f53cf6849da7992c8d4d346adeeef581586871e1a46b3a73be0816296af8a33b851c14b4dc01a709e565a72589283ac8806c7b369f36b9527b99b4ff6fd279b4ebba677b33e61e70ca699f136ee72a0775035f4728da80c518b4b2426b214fcad60f249db2dd5ff74a76831cb4567ef5a58b6a6dc43252aab375c03594e320232ae5531b02ebc78f69486e0aee10708a93f639474e2bcf73de2801c4b155472c7fa6c13960cb79ce9df826c89bcd4528ce7d13514cbe0f137c8dcc225aaf9489995eb30d77efe3648b06c690fcc2d2c24a583cbc95d1f522734d12cbb3c8c1479560ca706318dc201f8602c4de24aa6dcc263e13608e7b74e130153117294103d5d47f42781c414cc01f46b238982b690810b875eb4e2b7978047b48ba75138e6a48f8ffb5024a415c68486ed5304ba70aa5aa5725916980eb22fa3323e88343a15fc02b908519fc55038d1a37b4ded99d474016752e108062d9480ce0207cb32678569fee32966128a7a820949401d7c110bbe88d7b4db632be551a3ac7de36293ca69b324b18eb4dfd4a8afe2cb7924985d8afa0eff55bc9652a15c6530c63955ef48280231c60d26c8a9fd77419af66303347eac15e8c0c669d356f2d0aa4fe7ce4c14cac11d2240ca12cfe55f4c7200509d24e406923e10f2c0d082d6b8dd13917fd86207b39589bd4575800e44f283561d40384c1fc5cce2a913cf17d4d41a4fc68b0e8f9c66157d3c7695deedcc6dea0a3adcf9b74aba090b93f62de6d7b660da05af5f39b951041f284c6af3b29a5bf1eca505485c5391a7c8566b7bc8d8f9a949aee6ef195b87b3f7a8b6a796676d7adf0ade0ac2d4b552ee8af509395875df301b2bf9fcf7cb0e691bb7dda88a5709c4cdb6441e617427948ab9ba5795fd8ecdd8e6cc857828802215650e25d554e927fc8653f989e21a4177e436092ff083aeb6750214b397482e2566003a967fd3b76d3049a6378328bfc04de1bd7f32376a27d83a69a235e6d03357c8c74085d6c3e98cead0eb79c96beda7b7f4479d9df58264c6d20240f81deb38458f5479662fcae87d3147501a133a1d89d95f5046967291ed60a9d1e7cd91bf18c89360db0bdf9757304d0c48dd6cde88d223105a921dab8edc2a7b82b355fe8eb4fb08cd88b5fce2e0b739f4bc60e6f172cff4fad9930e381f69ab7b791a4ef2d995ca4e86c8d778e18b3deb63b58fc77cf67af1c18efbdd05a65eba415dfc63c201aed9c1e802d44f8e3b6e61f635f04b82cf612c4161f65d65bd8b157d269cdf3de47a8f96745610c2e609913d4aac1cb6838ae9ebddda3f2bd973cb1b13a851e55e54d56368a3cc4b9b9a8cec8cbeafe693b69bf7ad1f046865ffe0aae04b67ab0c03a290918719992791237bade7874be8e9ca26ba539a3e33e2ff6011922ed0417afdf996ea453a5eb2bdde167da57fa7eda98f412376122f3d364e1bc88e92fdb493bef9abaa11e129dcf5311c30617646e01e8c58f1694b0b455a637bc06b2e67e6d0959a8f19f44abff79e8a99b0b3fcc61385e24192f38cba3e38b7f7c4da593db69246b2296ea6da9e4cbf2da09d5711da57a35cf19986537252bd69a15622bdef7e18220712dc272cad393910466ea1094a6d1f4fb335094bbf8b2caa3dc00ba90e188a6080e45cd933a869d4ca3c9fe8fbd9c6ddc3f8e677a0aec43023e2ef072e5b820b4e08fc380397395cbd0d487693a0d1c5fdbd8784e67ee2c6af3e06494b41ac8b6c57866483789ea276babcfbdbb805c4e4158b542b90053c8c82c273024a55c60b4d945836a35b5276217880ef8c33d6c304eb7f6ca4885d1275d806661776c974d73101364656d89f9ad337fe48bd54af1f938b3ccec6725ae4787f156e283fc9b8ec9de5da5bf5c3e577e289568ab37d9d8cd5b518c9a2a71f141b11a1051df3da8f7d13da94faf8c4afbeea024a31fb55e3ce1805b0ed69da50bb0ad240942d61bb0da5d702f022fe89c27416d228cf01ef267be31c9f27604bdceb150b6e237e64c55ed8ab8057ff752165a39aaf9d4285f1153e018067b0215f53b2e467efb0944419d4664e3801994b04e8434b7d5cbe275130ce6de232276faca72cc337f8ce3daeb00518f1ccff188cef92996ca81351371b2476c50b03f75d6b55378d4b3dae2103f6be1267ac378fc424275ad91c78a2614729cc23390341be63096f870fcd7693f5d7426785ba0865f1a4cba57544842efca9e4636050ff075ad387d6a68a8045c7b638ad9631652f0b8e850195e450307e7fbb4dbcefdd486a00ae29dd3b538a9355cc7a9895dc8e950a7f779359e0e35a1fd95f3557fe94766598903b286e5726d0b615861dd788166b5e72dd7b24722e33e2c532922db8e9befc3caa265d09dc166041c969ac4f1e434fa4672d8a4fef84420fb9c0c6a38aa44bba35a56797e0c261e1a7721900dc6e4c3a96705be82f6010d127a98b4803529732a2e47d83d7de80a6b3696ff3cabfab89281f61c64f6bd8172d7aba248dfcd97e55d24455664fcc55cf213825634318f72712ba4bae8bc11c3feb6b8a6be3c6a69c77460aea68fa5c6d955999a4030bb7d4c826e70fae6a91a29a0654e3a8d1b2fa4ee0b0de968af798f0f07de125adc10d31237d52926cb77f2fead3d6bca1d97672304e942a5e6f574832051c55b6938847b21b893c52e93517e6d2229d78fac17a6c4ecc76ca527265057c902eaf716bc30db25726aa96522200ff2eef86772e203bee068d80e0262373a20c906ce123eff552e8aa0d9247d016dd1ea8ed443c64d0bffd70143ba35f1d49baeb1441e85298d16abb7f71dfccb0875cd873194d54fdefeb8fa208dc03a03602cf836cbc90e2cdf895afac6580fce2e641d0d609c4b09bf4dffeb82ce50345f371647dab7d2c64acc2797b79d0d68177bbfc4188f9aac5f53966c44a7c76cec721e5e16d09e9754581b9633fb351f9c385525013cfc5fa88d7fe8c6b10a7d12a06bc2b61ea78cb8b89734d123a9d435ba5a0efdfac1aaa181f70208b3a62d51594f355717bbb9ac3c1f6076217dd68bc02a61ddbb19feaa30ca21e9fdc6bf12b4788c50562232a86d7f3735447d40fd8efb2435518d0c60e0b94940ffc427027046fb2fc86f5a50596998948c441b6f510d0c892b9c05329d4727771d25f5ba3919c193ae4724a0ab6d7d5747f3300fcb32bb5f0649963db4cfa6407974e28501c5dcf36f80615d0624b4d860add9910529ca5beda2acce7984dab62290facfa02907320dae14e056ef9f165406f123a5bfa73f492874e6798a93942b5c4a0ca4059beb454387a186b94ab14a8d7e753693780fd9fcbf63e4a17106cd53c85bc5d86ddc58ea29f687523912bc820c14427eea7b389f701cc8f71899f5201a13a5170e504d8f2e8760cb75e15eff0e12ac8243078b56ed39de7d72c99c912d6f1d91775512f16efba4fd54140c9cd4d04fe20ec9985c769c60477be383ce9238cdbc39e6f690ddaba5b568b93251dd37137650dfd237e5cd1a9624a9ad114d45afd98730dab83bed4d2b749f82ef7d638ec5171ccca165ab25a43de5bf5166fc08d634e17e0fc84ffaa395209573282a1d06c02d4f244a1ad5bf5d02d6db130b341bcd9566b5169314ff6a3236ec3a3803858554e20a94e7c0c8cc8b0e33257655a31967587b0c3cd1e3176dd427038d2521e509ab0bdd391825963e255fda6b5137232733e5c5983019f81176eec373535d0808244307c71f6306ad66401259544a2c737eec4801874afa39d211406ecf144159c9463a80245a7d4665b1e42b3ff7ee540b6a02da197877ca329c4c21a3dab05515b963b97b12e4d5c3a0d65c2d5d4aff0bb04adcb8fe800bb42aacdf50f0de51726afc6ef72c42fa38543e3d3200670c4d30394d7add3facc3a927c1701ee7f0138f8688b07341c3af2ab33dc394287f6393a6f23907e1a2809111bfea3dc5af775c6ea74d3d753e24bd249db5c6d1c0703dd25ed78d0ab342aba1db7304f1b3b12892ac52b090153b11b4fc6b187fb8f516f213f813c03407b5abdc3e322dc804ab5db827fb428342502f86053c25fd8901a8dee9127dcb2877a9eca10c20cfc094e3eae4e23f6c949e47c7e986603502c48ebd1db9addf994afcf0f6fd72eb4a2907612309547f261b944a5d3ac6444b4d63601679131686fa4c988234bdbd0b9c884e5a131fabc8433f8b718617fc253210d2d24d1b697570b2e245a76a1ca491bef10147c2b24fb6e26915abd9b1fc1ffafec60e5f04a1df53b3b0097890c90c516fdca0551f6b1ed8e2883ef76c4d802e9bba582c94c2fd6d218215d45373129a288baf5ae6cb0445bce5d811f7fd3f442443a13e9c4ce70d803fa2462214fa5b5c627f1c708bfea6347d4d3a41a4e8627ceb3b41cfac9c5fb4aff0bcd299d7d1196cfa9d7ad802869b91be8a3ccfab47a4accac1f7bd2ac5bbd63b4c580d21ae8eb06f4f9f002aa710821ec1efded615af84c77a2baf9ce7e9a0677f76c06f13a0da1ede3662535f53570bca1299b1be06916d5d789e37d7e4374728340e71be56a8c0e8914abd9735c0da127d0974e63e046666b7e2b7a7826f0704f91af54824602421a418ecfa3626934e5a2cfd843643332f6061c018606b66bc1687bfa0987264eb611fd2db376f886a0456a56a6c60e467fb603884022470580c578aad1929f8c1aff7aebe3abb3a5f63999d74b8cd2b55c23c2cb4db9617616c5b6bfc770c14ec2d2c528a0c7bde9c8fb7fd1369a205cdcaafafdc98b437f3a102afb3f38b35ac5e2d0844dc55f2de90fd2d1883e43f8e6cdfc666b4610f33fc80af675d06a54d3ac79297b0aae694f8b3ee665aeb905ab93e214d520f5f85a10cf8027584e91c020bd8deebd19148eb50a68774aa04e40bc348ebbe72469bb17c2a0088e2c3cb152bdf0afca0465069fb0ba86937c0ca6635a1dde9352dd3b6e86aa5872cb698ed2fd8f5d0c70c21f63333697f31b7d405965b66bb032934ec0cc9fa038dd15af9600d46c9b85900275eaaa4a3281600a2f6d80de78b0c0831159e9b83519d1e54209530dac89ddbbe20dc37a15937ea4bd5ba47864683eadf15cb85a23566529648847ac4d39a132e13e516bbe06bd0f57fe8ad44c2214707868bd17b4f519806c58a32f26473bfad2621448330344f725f1c70b2f504d22e49db5310680c20ac18c3eb01aca5f59425226046e52bee1bef2cd9de9ff3b7480c972707a1aa716929765a7ca1c618e6e8b0eaf66da24e158025ac7ac73ac014c75d5a022d63a49d22547e97a70adafadf1f6998125eaa374585d8dd1e8780456d8f1801ffbb99cc4b966f94ee807a51d2b8e2fa9249139a4bc1e70f72a20f8cbe68ccab3e879a4273d9ef25d8ea78bb9176232c870efea66cc80da77db084c59763c12ef5e45163581aee50263e29775058cdb18c8acaf0ef53193bc2c2da48c7342ec890dd5370687069816e8867065f26f94774d09568c36307bbd9815970502171973a76249d6c34b7aacec2213fa214a68c6df600e8717110de8dd36fc3cdccaa8a05bb164e83bc8082a0bbf49650b72ea9838425e5f1e95ff4a29d4e96dd32ca6c27136f62a143f69c0af1375ef96d09f3aea6e8896f30fe18a4e63ad01b8f103272eba32c85e2ca7e75e76e645964f75813114dbdc1dad4b69816732d5004068ebbf4166d6f38d9861f79ddeb5e6c3f43715abec7b9830222c68732d3d620c711f54ad41191303daea39c5f50a4ad15c4a75113d52c04d532bf26762a796064d7034c3e7747e634463f1cbc58830cddaf9003f2afecdd9f34abd8b7af53a1a325253df90135aaf0c8965b73aac627d4d4c5d4bdbf40a87d4cc30ca8673ae94fd302f8fe9a83ec5c80336e0530c7e5734a055bc73a92c35a0ab90393208ed4510c9a984b19adb370b7d522a6b06cab032a71534eb876e269632cd2bd186b6fddf852a7d54ede9ca7dac2049c38ab3ae43f761ec256b5cb0dd57934bdcda17f2e1bd889465dfcb2c97c7a6d600a3fe9757f382d8b0e686a50087c794aee9927a8c8be7c9f7539a24ba7617fb368ea86e9af2e6ee7c63c82f39e5dd6d058b728834e1e041761913c2ef7ac281107e301af6c7acd211a3c9ee413774d70b909bda942bfeb65119a96e25baa1b8a81a2f25c4de29129e989a3e7a23b9103f678f67253b5362cd06cbd636054211c8ba5a2559f4fab8107b278fc77a092d16dc7c48c9ce37ef67399d6bf2669fec9a705f930d7b2c26ec534af40d7632807099a7b7992ad6b2ee16b2a7b59d45afba862eea40b3fd52ae1a2b87a34a7a106555a35224c5a68d1ce8c106c44b20a98738d8229605edd03d42a72f2595cb0cd93b6efa6c220b2a21889c743d5c4252ac202087093dc4854b07c604b23bdbb47c5229519a98b7fd7e5271a4cadcc423b0bb26d7a88d650451d039189634f8e3b649406567212ba514d93bd5bea587c7ac07f5e119de437b884b7c5717d9b265e09fe35aa35c2c47593125a9204fd4c9c994e542a4212a2ad5b32dccf949b387dbfa65256145e24f834421655e9af26e5bd7986f7a309408b3d26353fd1c6eb56a16b6dc82e01001a9ce0fcc1441b0d7864b651e8f77e1cec8fd5c6da3643df666f679d264d463549a8ecf57e79db9bde2682dd71bd36f5f399f4bdee15ad92cc8cfa0aa4e53cc4cbba01a552dfded8d99412c9983fb1e3d5f87e331b5c92c2bf2fc31641b759e08abc0104b1e61066197bf3b2f30be044b782dbef3a065def156d7b34d4e0857056b9463f47b7ec023c38310108e983d68db702982d2c78f0b0ec21ffad6010b8a33f2fd4257b3e88c449f0199b2346decc2b6c99d58cf332975635aa32aee290294c1b113cb52c3cecec4269f4c264bd697c8f20cc6a2d2d523435bf801310bf5ca60dd69c56c56a9d106200076ae78a5d522dd4b7804de16252170776c6db65aec84f9be6984bd906f2866881c25084e9d4166791d66cb819679693ce78134e13aaa1237e2b644d9b910cf4db1fcada5a50fe1628e486e0d87f102207c0e6237048596abde04e3b2c8511c7ef4274b3e57fa8c39f0912c70664151f838637757f27edddf3ebd4476b5de1779ccb212e0177f6693ca294eb673f21a3e9b71cada0377ad83990a7850a6d9ff025b332b891108e083cf81970769811cf6d6d367bf6e1ad247d0657766c5ba787f8bbda84cc62c09807a101b6f29dcaa899e49ada5117bc9fd9e03e7af0c16f13970f801d8cc5e5fa845fce7e1601955d88c124242cd36d1a6061959f607bd0ee05808edd990e320a93d3079ebb352819986c1f639b3f5e311e2cc7d2f149d229499b3c2ab6f0b76c38ead035e97f0b90b0dbffdf29f36bd517ef3fdc21b80fa9b7eec8d9c1fcb831047786009715d463145596075586cee1d230537b1a81e5e7c928a0c34049210cb113ed32205da4efdfdb253dcbc2adb28bcd026568ab77550d03e999a679b220651e1a55ef12855927b4dd48667a66a83b5ac7413a7ad1b82ef7a8abdce619f8a74e86d4c25587943e61df2acfe3c750a96c352a4b9e33dfbfcde9225f0d4efb7971125851d33ff46fd64b5cf00481307ab64e3931acb2edbd7eb9ee7598b71c72fa96d574fd835c5b88897259b94fc42e89fad2abf90f04bed541d812447353d2c8c0e91ca71a819dbe5eec7f6586126094f4148881c5519fb03b19116c393faba6c434517c482bde838d6ae264945a780910e7330ba522b1ccd5a71ae3f4a0d2ac8150e6d4e13c87150d1b2c37247ea58f29399f526fbcc37b3ccc19e327dc5f7ad859f2ffe4644d0974262a29cd4f10bcca4d0d876bf5f36d759abc96c8a07690547c45ff0849d8d85b6a0a127be435861025996fd8c3cce5647a25b7e66054d41cce73912a35eb3de181a33f18ff435a45468c682c30097e676e8103c6a12ac5b132379fe1ef1971e1198a47b214adc5d5481ed4b5f6f7c5df271b281e075358a468cec02ee2046d41b1613b8203ccbddd129c3017b31c8be820fdf1c70736c802e96164f487d04bd6bcaa7cbe8bff89d1e8ef4a0d90c7c7efe005ced0864991c904c31a3333c28d56e6efc54bbcabc86d1f85103123bc7ae1a9981157d0024860ac102111d4517bd5676cb4eb0a118ca541c43596a596ecf5572ba7782c6076b285ae30bed3be2ed9d0b370813112a36f2e07417368896957e510a21105ac0d124a7df77135889af62d6e96a5440060b6e83339f8a20e76febb0aecb4a13bf3d0973d79bf8cae94a572e25eb6c51e8c29862285c7e95842b13a5756cfc410eb4834689eb1cc7f4a5dfc042c1c15156b69b90552e4a1f5e77dd96cee8d76ced87e262b439714a0c35a993b205ed672d0b21882df7707dec7fcfccb120bc090fe8e62ab6adb73c075f9fa4aac4d0ead579992d759e0e2c62bc91de893b140c46c93227d60ade1bcaf57c9a0c69f96dcd1be75ed983aeea75e3b2feea4160e69b6b80502965e4aad9732609e198c89d39f2775a4b8a28f8b869be578e4bc150f5782172e2bf4cf155ae1c369724a528ad4081a2bb166714f416fcb2e4223d85ca297dd137e07710134d553b52e0afe51f00e9ab4a1c8d20ed6983194e82f31d7e415b26cbbc89beed9cea37d02f70d7e309e9df90a7456d770fe9d0bf3a6abbcdb307430efdbcac8f46590087e440364f537bb2886238b210c57c7aa007f5a16a84e9c488b50a83f416b26dcee38a75442b5d7994b6f52b835c1818c4151a2f16c3f5c3921d4a6532fc24497732cecba16da567f99b8a326ec61d0c18e79852d1496c1f55004f6770feccc5450951a889369d13cfb0b2e14c3495d8f0f654c7ccaf7253bfaa528bff077effa99521eb67cd45ccbc37a629c97301344802fe02f9026b2829aa48329624ce3547cf8a4140687e4ccf46fffbeabff9d5c896af1993ee0b897cc5947f8bacd474e9ea83c73ce759a6f9598d093edc0fded442ce39748a4a88ede987de9012c5f0257c88ef0bc9e742779adb1156d201d282cb5e95784065a5ee0ec63156bffb188a1b5373e4fa039c91b654b7e749767112fcdc4d542abeb4afaf51a49c707ce239bba60f6600645c8b3904a1326ee5073e4c034524a908fc281b74c555828c3131ec954c04f15fe933ffe4192a1aefec28732b95d5965839c46c76055f8d3a70ff1e18ff0b827d02b729057bf74359fcb3592b49e248296ce345909028e6607273050f2213004b0b259a2d6589e58ef7e1bf26140a77c509e84df7f46e1e4983e5148b0323beb04a66fe69924f85d1c6fab007c00a3c3386ec5e9c150258086a60d532ed3896d9ae33786e8761c478017aa466abdcf487570724417760fea38fb2a3c4c3afc44b30afec3c70910fa89638537a0bbf0bcd1b9498874cda37911365e2602aee092f11338b27603625ecd0585ce18313a4d7556b5a6c7d636aac53fba7d834213eb5bcc395d539dae19b09ac7c8f39ab83f64ee8dc8c5a72404af55624d5e2f22bb54e8c1642088fc2b8d945645ba3af5f9dd8491a2cf270629d64833e148e04f7ccd95516b2f44df86fba560ea13074d0d78dcbe37a82742cf338dcd2b95e9425b57a99b91d5138f2e60a78342e7a1e480a58828ecfd2abff0446a4924aa4d81581bfc0fa54788adf82c9e0131b2fb9ca3add77980c3221c8b03655505526ad90958968ee235536859ab8e42a1f8d747be38d629d6673251f5b643ad526598dd4c79ed66aa1e746ae92af6e3612d65ea13b5c4cdd7b49fcda869f63b87203523a631be19d0505bf22c8ed8e235a4b4a4928cc0e3dacb7ec5a1c87b450d9ea34ebc1d47cc93c10346ead4259f1f59fb107077f7e863ea57f0c9144284a7547cdc7f324ce469c15c5beb892ee6ba2f3484fc95057f9e61304d11f0eb922c98cbfa7acefc1609e938512e3418e9ab6b983ae6e16b84761c567ee7b898f35b3de2192a02e9a4f9fbfe56d46a07f8c1425af9a40a68647744bcf321cde5008294c8748a77e5c6af1fc32c9f52a4e84e6f17634e7fd2b0f7daabebc438dad8b1071f192f155f11d4e58486a8db2519667b184d5f016809b7fe561cd6dc2d081a7c8f05f13985caa3cc96b598c99d4f116f48cadf09beb87dc8e92ad9347aadcad334414158a64c770f3596334b1782ae14fe22820dfb7db553e3e1f7adbd19d0f70005ae06e5a3203e80ba805eb5b605b0ea8b61544c2072ed56f73518c596c21887b1c6cbf255758a3a17ea3bc437425443b0370c84a238ed095aa270b5cf59f16e814ff48f7bdf8d3658ae12a05aeb44ba3feceae3bb9e19f2f89a7d80e1d82bd9b7eb1943b79e6d2c35804e63b38bcaef382905b0c4e6fac91fccf3cff773436113145f54b92e7825af47dbec31a1068435257d80c77ed9a4c4202773a5ac4b0ee83c37fbcdc02bc0b19bceda43a2dedd47c954cded3d006aadbd45169855aa896b8301cdecb72251c6b3e7ecb3fb114defaeb0bf5e4c61b1584f5065ded5cab9f0b2d5d0bd8b23f342c8bdd53db261cf7853815ca2815a03a4b448efc02fa1ef7dcbff9c84df95ae1b1d4125fb958e6e3a978556ef445d6096011a1a6f299602db969f280c42f28828e56d7994ce94b26c8ab009c0a8e961d15029f5172859213ce9abbdd58cc9a94ae85e711f8c65f020f83f5b4050fff522db30375b669d9e96067e75d4d25cf4f0f1801bda00cbc1757026ee994fb0cd503b811015b0e96f6e0fd4c06f45a7e98e7d7529c3fe231c3e93925f82cbeb1c8e2d8e1f4bfd42ca4ce34c651110dae0f186ecee06be0abd9f4c7d284d7b63eccdae66bad03632bb712ad560c6cb20615e2ecdf874705bf99c52d819540d0df01190d5ae42573e93eee54f485cbf44df2da9df92dab692628e9aff9d596927e6aa2bb23b4ed6e3d7970e86d704c2a33eb80676305a744d9fe4da6fdec8f9aaf9684373f18e6121cf86155a0b4fca925162eccaa5973d1370a0dbc4ef7e5470fa4036478e48503bca9c5d53ba761a52655d29d4102d6b453dfa5cfd109e32701c5dfc6864f06c76ba4f8df1440e7c64eedff00c39f57a2fdc4a3b48c8e4b7c5201eee6eb7f191d771ece42334ca818d3d5b4dc4ea7add0d7a185d78251246d7c9dff6f674ff5b6adde71bccb9d5579167354e27b491d77571343cab0009582e4973fb1b365ea6e594c187a77c4ca6e352ac6ec494de014623efc5e2f6fc6574890142ce447723cea444ee91d60bd439fdd7de10435754eaf5b4426865e92bac0db7937b68277f3ea9e3087ca2d0fad9d116a1fa5f7a365ba71618e90f0efebe54d44adca60f1d466e8ef73c9860e8d875d522b6f9b3abaff8deedd939199ff32a22297a7a16e5d3c30719427a3f02371f3c8201273c802abaef0cecec06bf076cc9935fa57c3cdbf724be84d522386d55c22912ba4b6055aa4dde18c5d9d1034036287d90b49ccd2913bd2a5130b4cbded719cc066e7d0a50763286c92e7cc23e5cf53539c47c2ab59deabbdfbf058122529b07e92b685d07111bab2f612c8d4cec429d65df634a0aad2de511f185caff6e1600b6b7aaa03adf710857c90ed2d6128ad50a75f782ac8d7942db56f24218c84f6068289db99282a62e96e13e5f6d72a2f5affc041bcb07d36ec7af1cec516f6e940dee40d87c47ce71ace89f5c91c5a32c923434a44dab5d654339c199b943e4e571805cb54658ac733e9cb49bc868f386553124b990655ac3af3ee1011571211e2b78cf0a78e101dbb3723d8d33fe359b91d0f31ca7d6469e8e4d2da8903494369012eaefc6f1bd2b0256c9708e7e545355c088c759eb36c60e379a3d7df719ca30bf81818919c1e5282052d9985e2635ef9e47fe85a490e34247b97f296e852ef2dc723450fd840c1933643ffc8c0b15c80fc4d254ada7a18af1d87bf174e10324c63c53637761226c1556fc57520215fa6d00b5a9576b489fb324098f799cc7ae0087f92f1f6c2213ddcc7f69a82155f863d73da39f65f805dc19946c960c9432841e3070aadfbacce67e8072cd94d3baa6e916c827566cc1e8551203f217d8cf037481f307710498efac2a660981f77a4cf70540aaa7881720f6b5c8dc200791222760e6bd9f6df38919cc3f5d7d84b87867dd6e1e5fa81610fe5d59ae1df57d23940091f08e2d9b90f0d35732a996f9575d0f3ecd6d62fe4ca297c5ed472d98ddebe81a4419d961a9715989362f7f847613c2da8c29daca6abcddc60ec053d8668bceac5f38703d4bbc56656c46f5fd67349862174fc28ce94c6aef0ff734aec905d3ec60af774cac96242918b509e8ae2837eb3e76f9a1f69a26329a0e75444e42b10d28b55e58511004d6532ddbed7e14e1471cfb6491523022e4791f512ddc2d5b1eca8fd7ec4c59530be6852f543fd84c29eabace84f69d6fa80e444481168051eff55fb0939d3c4b9abf852f15fb51800186d44ec42a41e17216dddccedb9b26b3a2dc1c29cf7722092a2c7b5e2926121343ccf4a66fcc350c4044c982fb61bbc6b1c679e1f5a693eef60fa3fbebbf6dd37490ef0bb2ff97311e4cbcad87bb8c7f74c7c34e85b02f64cc5229f6b64177b393ca3c71dc22ea2a33bcc8677536a69b603d5ab57fbc4173e10fdb7f7614105347d817f0d671bc5e76e44c05d55ca36bf5343b533051c61bb36d239edaad1f608e5be2d5b90ab343bed119971abc89cc71bfcce622abbf69fc4125d59191c0af5290ce7a04057917d202ecd9747bdf7922d5766fcc106eea30369f4f59f6ab5dc5676fa26c9f34e3581c6b53f3211c289bf4b0e0ebc6c39839966150f2bfe31ace4050afcc63fc0d685699c3aa7992c917a5e63e4a3c5f45722fdba3b9d4e39bd8292820c8d0c57a326820ec6fad52d0a5fbd5f7d00e6a3aa8f620b49d4a74f969d4c1a9d6d484b6369f4ebc0616adcd945df285565ee238c0f37ddb4e0ef00a921e03abfbedbc794a01f96a072ad4b233cb16965c201bd0c21f8340001dddf878dfcb356bac7a2500ee2dc26776b7ba9b4ab9571f0fb385bd85d489c3fe09ed40541a4bda08482181bb573666fc345321f0dabc3a760687281b57ea7f15b2c145f49b87154c771e5d95698348839cfe41cc6b115f8ffdcbbf7f4a81b11559b321452d6b732e425c734eddb11cf4494f748bce6e3d1490b790ff6bb5579e052e0fb86ab4711fc1e131584bb77017d13635ae5b47374e457181959e528fe54b7cb3072874d58ff4912901e05765e2eaac91b32e601e4321edb32401caeb3b71e2688de24a41aebbd97355b323fa2d012341fcb459cf3f35bb0e9cf9b1093e665643a69160db8c2e15d316d7263fc7f7c6491decdf8d77bb1d14e5444d866befd4793544ab51b5bf950270823168e5c7b183fa58c628890075ad7ae3ff56a1144a8332c0f4e89feb77dd984543bc5144a686644644c3280db66355f8b23a263f7b850e71f4cccf24c3d7753834e8a890f34fb6076d0f90923744e4c90ca5983fc93830c912dd05e7341f75803daafd3d2881de0e13f6a4e6b8dd1b023a7065dd4bc30f3a14d31592c260052aed875a220035e3b37a7cdf99c2413bea9b3d8f49fcfe3e95cf6e2094046d138c0ecde874fa25fc6eee9eeb6de987c0acdd9a5561d447501d4ed43da6f5dce761a902bedc99e76b7fb50e7f7848dbb50ae809472bb7e3ff072c0328d6756b3512984694bfe19b70f57d06998e089765c554dec95ce564f4d1efc23b5b98d02e2120101acb2779d565d4384ed419ee2febcb8b3e22d682ac0bc979b55da300775cb95d23e2801f9aa970b2ec2a79842a552d77cf89c3ba5cd03ac6e8d1e54fbecd78c6d6cbb4883f736d836dbaff0cc3de8a48cbba848bf91424d93e91ed350160c0e7319d6df88920d67bb5c4f882bead1ab26de8dc2cd5243a8b5a6f9466886dad7028347014f204b5f317e7e6966994aaa28de816f0cfffa99aa7af8c46941ab61cad0e6fffd05f3595cba0bb42161b6212ed69ab7280fc4eddc44315db3f97a27226257c504ee5fc5db1052bec56e9853ebf134b6b98155d807322195cef85e6f833c22b0aaac6490e20a3dadb2eae4f0cfdecb927ca214c7aa3fa0e381eb255063c5f65d47b677fe494524a4b2043a182448e3b6b8bf615f0524b0e20dcbb77a95f94d71d4e6e15a7801f289c87f48181a3e18f5b5fb23992d547cebb67dfeb930f200f6e5dc5f6db1980abc446ff921347df31ef3017d579931af2bc231b2128a6983698b8d2a72080d0f6902167fae692587be1db2bde9fe7a16bdd9597e34f0f6d047e832003a16ccf95e21eeb9c659402a21b26d391bfec510615595c8477a4dc6afb58bc096702fd29fe404e25323239e635dca3c2a968a49d74663c0f7a27fae6ddbac544aa6a2f9d4a09665e773ae46cc5e86b8d7c9182c7c5d0a4382d0e31c51814a10bf5af00dd06968e6ca72a4a6716ae0d16b8d2f426c575b857c00a7cb26d2b7ac8f229b517a937e631c010d4a410c3ee7fdc3dbe72ada78bd38005dbbd26d97c8f090c686b2d4833a00c62b8068024e85232fcaa43d2abbdcb534fddbd210c671d730dc59408b0af9a561ee168284aa764a73b238939a804ccd9a708359f3aec32d69a75ebc809df8af28a639d7508ea6dfa1d7ce654a8218c6a1038ae913e040609b74dd0aabd3274cd7ac053457faa1a21795bc58078023f4bb502cc29ba1ec181580a1e0d63deb56b0d599f3f45363aaf6c59d2f124f1f32c319b1d947ef0ea29423f9bf9caca136f9042a33a0509363763ea9051680c77552ae88c4f69c7ec3d103566bf9e413ee4c0e090fdfc488b46c885ad3c73301777362663241b283f85bea2360c8606889c801b0995a28de1b5de2a17c41518eadbfaa50f752a838b1f8a43fd36012ffdfce37f6359faf698ecd951a1d1faf75e85a7f7050a829e6c246b174bcb586d50e44ac79b735085aa7ae5d9d540c4907709d9d95a273633eaed1bb0087d8efa103c84ad10f4a15de482371d35d68e7577633f3b40b4f0c3d02b46045e99a7dddd5096a9f6684960b6752493893242101840242a049fcf0f0966baa7e9aedb57a7b2adaed4009e3e7cadf28228409e3175b3d4b146b2434165ba8994766da058c723a0f1c1bde4afda94fb53394ce1dda5e8728d2eb2b1dcef049d2d84f1bdfecda6def41aab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
