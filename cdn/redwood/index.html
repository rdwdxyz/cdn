<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a8a5ead84f83582f90b6afa738e339c578f527624d5c3046d1ba795f973bdb826b3aab1fa62d4d931e6c0042e8e7e07aff3b29a6eec0c6d0a8023f50e33b1eb4960bf0a891c1e7655295aa1fcc7b67866311bc5e9fa218b5781c04f5f75d7c2dea5d5c4dcea6ed7d70ab69b1bddd18037493f67c66a665f530e3edb7b4d0ad8102d91150dcf67cc4ae02d927f7e47da74f119fd743df974a2cc8eb2408ae0ec8639c0e96cc1f3040931b0b4bdaffb46b22f5ace4a8c0ea8a954e82390e640b190538bc2c66316d3c87070515d165737b176f96944ce57491e365e065a271e7a6aaef940c054f8f5418b03cc691b156d07d23bf8f5ca3a792d2f9418a82f1679862daf8cf792ffaa619568dd221088567ec59aeb472cb57eb9d9df8242b4289f25a294c69fe22fc66c918f828803a948ef9487540d62adba0470a7623ca4935f5aac2244414d6759293bedfb4efdde5e3c4acbb61431e1994037ef3bd0a15565abfc8c239f731fd3e0271f25bfccf04f41af7c3b7fb9eb13488ee8a557e06acd4992ffda68efbb5f8c6d819c27675f9a0f99725cc59114ccbf2113a0ef9b1f03fdee67e140cd0f99f28ac119888bb0cc95038cbcb618ba693f8176d5906341c53e516e2b8f01868d33c649d0a7485ac5fea9660b439e1b747a197ec4e71c71f65c8f19cffb229dd1492aea9763f54ff0dd0380413e5fc3f4c4e1a05f88c30d920d5b02d4bede7f6f993f5517369b50102cfdd9213fd6e750945d6882311cc987aebf75950d7fc29aa64e27298a4c6b0381594fec92bcb66c249cdc1cfc9ba74ea3e2fc112c5cec1c72964fd77182d7dc83087d97af724eddce405c44d42528c26946e69f27034e3c9004a52e3596d4303634e1053b30d86baabe359da986bcaebb2ea1c6ef26195d858a2a858f28a38ec7cd92d658b75e69eb6afd291ca27eb68203ca6b5087d4e05aef2f5453e1a532d1c66348e56a1dc9971e5b1f675cc6d2f5335613eb34f03496861df040af77983caa6f5b7a37c8c0899197b5756b579be5a8f8a50fb3c14ab9842672877ae033c4d41b7830b15d249a6e10e78441dab366fa8a96756adb5903440ba8467af8461b9071b3b7aee3b9ec76006cd27dffad6afe79e40bbc61a93acb36e2118d22bd62bc9da59a9b445977c993ef7c8d7c7897f0cabc8d077b6bb09a0d11cf84a9c744598d9342efce25bfaa1b6753be983c7e1b76365c53de4e79a3064bb13aec712b72a21e99881ddffbac4f25ee1f08a219a0af1d9a6e28fcd55c29c5d10745ef70a2332d7edf508c8f353cf646c0f297ded763fc7e12802163c88b4a239094095302202619a94ffae7e06c1b2d0f045f53336f206ddb92468f3cb2336769d6e56c5c72a68fb4da6458f010600cc1a6c80adc0066239e0d4195f3b8d99c347434d41f9e71e50e0c7376827c7dca6ebc7fa07d0d2f0eb33a3499c417f1060759959203037654d62296feb2086f3bcb43be42303db741aee8586b4df68b005c98fe5b65631dfad6105276b0d1044d3c47ad13401a84dd1beac75a686de27bccf3a887d5d68e8470bdacda7a508ff7606b0cad84ee3ea170c6b4137ac5b26de331eb0819ae1fe51b568b164ed2af5cc660a374da34281be1f52cfc894d99dfc8bdb0f7de503ac78e9d108ec579e1289cf45709c70b85cf01125124e68af40565d96e1916e364723f88ec0390018d87b074b733eb9d61c91f13244088a9a917f2fe5dec630c09d01c303737cd7e94dbf577d34460a20fa29af20c35cf633d92b738a6948715863339ac019c3d221190fa8722b42a5a95c3e939223839b1d76b50c14b236ea861559f90446e25ba3863c953e3678ca1a681b385788a2bf038a45f0bba4659528c1dd79064604215a3e8992c2614b0a158851416e5e5cbb4fab2e317b5f655ebf890e53b2fda3f2e25d7aace49816062d4c679a19e88561cc7ae8914ed2426c855675bc32fff7696d14c3f0c2248d511877f7b830485e30b9b602468c9839f4643ac644dc132136cb25cb9c123ee9bf7d89158874d03643922d6b1e756dc38eeef0e2c7391b57647041cd8082ebf63045b16835fcb2771d772c46c631c600225f16087bc4f2522f4469148e82328e24c6c58c016efd9ee818efd6a1871e69906adc9cc5b686030f8fa249030dcce9d59d87e03b4331967f2218b1a567d471e6595f5c1e0054a14c0b48e4549518d4f92b770aaae629b1c9ca866721829997cec914b68ffb85d33c1e6b8b6e70e73afada12d27cc3fd88331674c4fb0e30d86314da6ac05bbbb380b0e0d752e1f26e430a19be303129c36ab3cf3e6683ceb1b57eb7b57540a5bcc0c090b85a9bb2ae4b6e09886e24ba4edd4db3d09c57f01934f9a7d52f0dc40f8ac25cec641c41bc6d4edde4f6967d4bed203b94a042337eafae7661464100835bad2c78d90077e761c78c66c4a334f183616282e41f6ddb449e0610cc256be480fef53862d9cda5d16ab1d7f8065bd1599966cc7a50e47146e7279d66f68d622fcfb5a02b93438e25ad152522856527515caec6036e74968ed308632c5e916522547c7b95f521fc1a6d784ba2e7cdf951357f03d8cd529eccee0162268c8c6c16ccee5b347ae45aba316d14ddf75cec481886c4e709ade0ca95df6c44135b60ece9f6622933672db4858b65ec6408a25a165a0ea72c3048e287107cf498e7e3e6fef857f8c6d43c559d20f09d8e9384cb6feb44bf7d10ec493290ce2f09f69f03feda62727a645d1b4cf63e95c4f61a018e8cb97bea35da31c64701929ee8efdc02adb3aff9b369b9ed938091a764780c34e99a5e226563efec5dd24f7d3e988bd3c4cc58249747da8984fee99c52fa12be7e28994309830e06133fcaf4a95521bf64feaf4f22df1521c80b7bfb56e701b6b8cc769544bff138822ffe6c984c3f6bd70664ec07b618a9413b404ef8993201a9910fd9444078bd856fdd7e625122b235966b83f81a8c9b03d4a9d5e6b1a0e6c196be7f23f1c9c054e3d4b04c54357646ebb73b9ca6c4977253fc9f10f9ad53436ef10f2a8bf673ed54a1cee2474ffec87f937fac8ac06ad778ae1a078a5ebf62ccc5202e3583d618f63cf585706e7919a3249be875e2d27572a4af4180522ec3b31d45b574c20e203145ed717f8f89673709c67953fcc69c377f3c983e6e33b8defc539addeca10598dbbe6dabec25c5e211da4db94e9f687c9945e3dac1ac308ebe43edb15c4d10728aac91f5ddb21de4186c16856fe961ba8e60a7a684e8b10354591721ddc27acc6f44fd2b2cb2b0d45bcae4248ad533e4c4f9a1e4a8aebda528cd1bb4beb69de50618f1ab370558a6d4dcf3e432915478c4163b07875d2535ef6876830cdb31dce437afe8e6e37b7d3d88cacb5862603201ac9c830c8f080ca289fc532ab20d9f7692635467abe949518268be4cfe1a8799d9b85a93c0b2cb2140ceb1dbc7f312e0c2916c3e90e42d6a69382fe088f5f953753f4c4455945a1d1edad9839c86649f185fbc8aa9d47bb6d8879435a05c692b898c442435e5706fc3b5e7ee1528e3fdc14a35f1912730a0412c9395770feb44d72e52a1282da16d6eddd724fc9d9a86d727b42322eb595f14338fd5e3e0a8d942477da9b5aaf9e2cfc146ac647272e1e28bc0bda84793b49401b1bd749167b907e498f1cea336a11289e22e44680218324e27273928a83afb64fb851e05f970969e815f372f977043d4e5e319c181374237d01d8257e0b049be52328c81c881fcab8c2811bbfca0b95613d9f96b133d6832f9d315dc492aa3c1d2009c0cdfe87acdb77a635f4221aef22661277535f94290985e636df0c2ff04d4dd51bfda572dcc9564e54ca7e00400162123e30864696c64a27caac9b87399c4f030fa1b70f8ac767ed5745e3b217c7a3962e28a5e8fecffc6335fe6f071ed9dc43b1a1859ed6bf7150809480a6dfa68f4b9f8f174c7ec5cb5efa11488f76f7cefcd52e1d411b44b53f1e1391012133c1b6786dcbebb44095f1529ea98f56968af1792c00da8c0a49a6651031010bd12b1f33f6f2d9a68cb53026ff235819d8f41ec1325a48c1e2561e23dbcbad8771001ec57be3437191046130662a0e3b1995cba34e6c552e44ca461d69e829294792a49c6f0c98147ab1c5f9f3e43ddb362deb3c18499c05654ebe385e263e1dffc60a3a292f6e2daddb152774c6444223dbe9c6fb664424556b5a861e09b6fd2ccb8f6562647c7d063f501b7c918f6463c2e68da254e55644d5e41645998d6079d1672ec8c624788ee36749dac47b7e1bf5225dcb70cfe608a4013a7ea8c50614d58bb3f8211108bc7c8e61e274ccaae95efcba53ccc19af11320f4749c7121f38175ad58a7a85b1ebec3f98b238d5f8d5e239df501b61c9442535a89dffa078c7926b55982c9c00edffd4e70231a7fb52e5e4450ed94347093f5cbd9e979f912163625001650678db7ede956e2d5df5f7cb87757eefde362fe410fd620455ba410f738ba67f581555e2ef897deba60b771f648e53e08855fee71c1e0636f98cce0a979f990b03e910cc75a6340bcd23c89ef93cef3d98c314f50f648d810b189071ebfb2f56a1a1f4ed00875707e5971ceb8fbe0006e6db0707f84d70136e92ea9b582cfdc003313556512a065c6f9f03c504d7af30c6c479e37069b0aab8bbcdc1f283b395236736b1af16c2dd2a1aa8126e4f03fbbdfb71c35a3833bc8af220186011c8218bf4f303aa08d762641b2244ba85549190cb07c8c4c9f38f2fe29c8bc4c234c9ecbf2be8dfad75ac905cc94b4973492eee6042a0e2d9aac62d56c644b49a20f3eb408078e40d983f83115bcdcc26fb09818aadf6f31fbaff101fa642692a3a22140cbfedf3ef29fff63049002ec96430e117558d880fa6ea58bd5b050c8fd5937934b9117732d8806601a7a7d5d6a509e48631a5a5bd2d5412c6721613688eac639dd936cd24b556a21db261fc7417ee46fb6abefd8984f94fcd12f386950529b88e277266b6259019152f78449120dcde874296be3ef769a5d258a3b93231792ee503944a9ab06b9be21f15414984e99d0c4c810d82caf1694a1e3c10a01cc63198239f16d1797ba19405828a0ee83972767747a6b2643a5cfd88eccf074642985ef4613c8741c986243eb5ad339d89ab11226a1e853ca785ac46bd8b0a48e2c3b7e3bb54904ba64af9e03a965b815153cc40deff6c8a30c52c66fa7921c837f0799d02dc5f73c9e125fe8eef51ede68ac874f26f33b3adaeeec92b881b35bfd188b072bf74043ea41cf9df6437eee902d63af3a0b0114a35fcde5fb54c9fafe20b732a8e028aa829860db63ad3c1c7148d63c03bb8843652ebfcad46f605d07a7480443eb8c1fb43e73fb894b8883f7d6711447e5dbabceaba20879841c349a59c434ff09c6247efddecd5f36813b7415e253ab2964ebcdbad983d0b91fb6ae2bd1663aea083a093e18d910a14532dfb0f28dace5bdee59c6b9568fb72b1e0dc9462657c14853426a84b3d751822cddb7ebbea53ebef723ad309abe6ba0a360865ff995b18204d65c97fe389eb3da27836676b3ed1ff421ea04b87bb2b363d6151a1f1c2d832e47ba95440fbdbd1cd573eabeb2141a4225b35f11a7700061dae9f46be3837b8c8071cfc24839842fa2b9c37e97f1f21c4c77dff264daadece08a1d532d0de611eae7458604e5abe7a1dcd4944db5ea1855e979b90a39f516f8bf7b75cba00bfbb4a37130a55e5b83ca0367c56a9ac7fa34047594e30e1d751e0a45c124cdc443d93a10de0cc25c73e6a0f75786ad7a1576d7b80b2f6102538ac76b086d3b93f57f1b483d2f5f89bd7ef3081fcfc44e41fb24c4cc028241b3f19f091e76d78c0db106ffca06ed61c5a7465e311ffaaa2c72d9adc6247c8d24c37ea33bdf0ebf7b707a3a7c5dfe1d9c03bffc3b816dfd94c86fc10786f4d1141a0608f5a8a5dd3445373bd9d667b31f1c1fc641a5faafbd156b58649102369b7d400c95e3a6303f25d2b64f3bcaeb0c86363efba03f0958e5cbb0e919b13efa4856bee1dfdcabdfa54bb776ad9850af612e66564b1f1ce69e0dc2e162d247fc77e43e91e5e0a334f83e6073d3b916e4f41e0874f2dd76c136f1471b9b1369353b9798f980c4f8c18a4df6363e8179f2b092fbc3392c7787deb358defeacf35aa48b309b0261f6d702b5889002f8d2074ae24c2ad561bcb8ab8dcb2f99ca30c8437897048661099e1ccfe62c8cadeb541debb35b1d284d6d8d17fd6999b3b18114f41de1456af5e9b88f6109357d929209445849a22aeeff1dd792bf16f5221aa380074b57ce6cac2662240c25772807fb88b86d134b56b200fd619cfea701d5ae2f6745f628e68f0f8e1fe8b03abbadb48b418d5245e192024a5dfba27cda2246ecb10a4d3f30a0b1985db2cfd4d50bd2adb70e711214f8d59fe903928dd940c33538e36362fa8dbfb6fdab3be26f4a33b17f24fdf3a7299e60aa45f3d9f7c8c729bac7d3913abc22cb0ee1b903c147fd38129e5a9e12eb5a32470e6e85a124fc8a97d7a92c02ac135076527fa9229157a464036b050937b787316b6f8f8434bb37c9557c349797195be38875a258750ca0a2709766e54ecf70670c7976b4952dcb6a32d15763f22eeb06f8887360fa78e7f649b7ec35979434fe50f0a98a3b0086c2b0291f9f93dba48dd4e323658201c8750e3a022ec8fe4ac0b58d1e820334d90769cc964f97f33ffed233fe3e1415581782dbea6d843cc080c6219d4d38d2a6b9f3983c8e7ae478c8ca008283e85dea495817cf0652954fb4ff012d3d6a8d9495f9b6e1090a69ba8bac2e81f603adf5579eca8be95454027776cf19614ec6670fde7a54561083b05c9f968b3006098e3be4ae1fc0cf6140b61f28e577acc510c7e9a4af77fb698f7c6502fa0215b7eb18ca170ead55210427d8c18bb393767d1f34488d2199f0b1108f5d14074e8a89e61eafe3a8eec76da3f6243a02cb6e2bcf4e100b9308bf6977c0b438f325daddc31f407370482e94e825b3b7760593cbab98275a2f121520cd712acb105c91ddb087eb5da749be2931a952fdd8cd760e37c2e0040c2fcd466d7007cf14101c63665383b512c11fc908269d15ec4d503dd39dc58616cc4b06588d30b3425508424095fbebfdc3e48938e29a21a4f1cb16e4c5a0e90eef7ed22b0c78b6b8e9e576dd1c846d9f7e8bacb7ad2a890e97fef7146ce4604e93be9450a43e7d3b3d6b9b679bd2880a0f56540ef3e53fd9dab16eac327c910ee4e0c9f0da50d2f13e1fbaf520ea8580ed1bc8ff5b255e89467b18e025a75338dd8a71e6fa59745afa9842ac9f60b806945bd33722660579c5cdab5168ae179713673e88a37dff097714e4520413e96773d2af80139d5c6a9d20a9cb9d3a31884e22fc887cbb1106774b73e076f067f694a5f65908da327c7267e7d21087d8f3167a3852bdb21755d8a6242e976aba6b56f72ac78f47f3dfc297c5f071f15084600c0e412c7dc92aaa0e59d2f2197a3c8f388c30c55674d1509ba9241c758c59292b0938cdb9b5ae333edbd0e5205c00006af3a8787ced966cb90253fcc72cd821d57ff541a5552486e9fdb4a380a90394f76acfb8556f7614d4d3ec612af3aa46dda7221461374fc8254af94f871f49a21578bf279e07aaed1e60ce791887befcd5a8f7737de5829d0e15127bb933871530eb9d3d5d008baa3ac5a578ada2026471ef4d541b5484cfd8636fedad11545d92da9b52515fc8bf9f410d527043757018f87ad4cba1370c6764ac0dd5d5a52289554b6e314336e2ca9c1efb7c5ba569168f8cd0b8f75398381967cccd382c26fdd8d9b0296221cb8e11ea9e3289c611a98b2063e53bca3c968a3d7f8d54840a3f662c2b54050f31633fd8f9aef42eadfc5fda186e2833999e49a72bb4efed8c71ee3c34fec849525a8872d11c86c5736c997e30452f441edd8e81cf0965d5f52770e43685881eb0027bbc7bddf6823865c4c49b85dc56f2ea53adf7b09f4bd5fbe6199926e35b008cfabac095c0b6fb1770b89716c9965298a4e9293b0c36c69eedfbc52d5cc6c43ccb145757dc0bc990dd58a2a3a8720710d0f27166c43c17031759f8e00b1462399aced97f52cd4c48f285dd1a4df7582e28b6e901027145a6c99802e6553a55287f0047c7a6daeec124797309dd449bcfad88278fd54d65ab240f9ce40b7b01252ef6de0c5c38c568236d70711979f575d70bd423368d30dadd89f1d3f59ad0a83a698d807c06edb2d9d988950b4d4f16c3624197108793c2d25eff063606aeef7a9fac0bb19df950f7096756976d9881ebdfe6675a9e4ead7d1f5af60443a68396d056473e1776f2e2043100148cc02ce83fcfefd7dc5f3109d7113d6e251a49c987795096bddc60940f9b51594141e99dfdbfdc21303fc1cb6b61f2f1aa160efa74ab62141f044e2cbe63d6903d6fe60cfc351220c54309b5521c011d907f14852549a884954b40d7a1547d505478c7a825baef6676310a6d5c45b11f38724111fb728751c8782ce32b156851396fadb9e842d5cb32a44a9c57068e32149e5fe3c4e7f0692cf779b363a9650470518352dd9dd8286c2979b4036ec109668e72b50f772070593ed150bc401a239f51ed6b8d732f76f1a4b07831e571ad7f4218c3e16f3f091220f4cba56c5d00362c24492006290ab112ee4ebe65374bd8fb303fbecadbb50ad0a31d4e42d9488905126959b4fa637beada5bdf3f396050b4bdc69252927085b91337a899db35776290e4222229b521bf3b592f6ccbccf122877ab7790c10d0aa8a029039a4aab6ee58517b6df61b6d24848d0687339e9dec669008eb606f76125d1bc88ce12769b63c58232725adf0c3408e97d15a6210a62a52361c79273c85c80802e4f1456f87d07797130ab0df31c68da899adb928c043959bb26c7caf41e0a9da20477d11618f37fd86bec18c1acde1249c030a786f82c74ccdb91bd5f61e1964b607e0531b0b1ec35cefbcdb3db10705451f52f11ef71f928f415c8b25afe2ae7db9ab51c430a52e0de188601410df09319ffea35a44564d4693e4dbc35b8abe04bd3eab107e3e8e058860fbb7801369a4b91322377613f8553db25f3d5e015d4418416f361ee191b28fe4334f2ba7875a45f7adf68f64eea2107cd6b78c0711f21fe42606a9fcf7868e0872ad42df9057e86d0f8d25031e3b9f16510c31ad3d638483323dd5f3a0024ffe7eda3604f10c07189287e7bc8bf467da6c7766ded5a9dc35708d833aec45024ce3a8b4fd3c28a9a0a52801366e5ebcd3c08369edd52cfb94ee26020b7d1d4b25bf0cfc7511c3ff14f4c7723b5b17a8c4882e4a32460ebc3a19f0e2552d85b037c92303883219e3a865b87aa2cc9848ed46feffc783a90d5cf080778371f8f436f1ed3cd0349e60a98bf6cff0065386fd04c120c2d8c91895ff9248806b03e58f3616e03857e1c87b72509ef6ef620b9eed6aca010660633b2301f3444f54eeaf47e07aa8508ab5bf8592b1f27dd1aef3dcbc934d310ba2f671cda7dcb76c3079f0189efde3ffe7b209d791f5bcb1f908b22d70dd28db0f8376be5f5c9bf52e73c90a6de5214e2facce32a0aa746769979e4c0ceb21a8a979a039d8400be405830040ac22d609871f83abc5f61d8c0591084663e3828a2dc91ca40ac934c8233b64f93ba77c9503fd3efcd7b84df306ae12d7eccb7e2161c464f221b86f3b45a20ea8f72679a85c64d4fb7bdecc32c8dae3d1ce901c71168b799f2a98a9b162c44e3246dbcde01f35842d4babdbe3cc787237e361189b1bca186d3ba307dff4098556b6dd52565b2199c57fab52468a590d5786281e323c6cadbfa38ea1284b520311e70f12a7509ce55ece1097dcda9b0216fb8abbb916ba2402cbce16ebabf31dd5cbe4f83295f155105eb01bbedebc319363e2facadd5fef77ff425d037be8e2893f040fdf948c53ef008f9a9bda9832287d352e95da8f5ca3755bc188fbedd3cab15b7353d020a43eddf4fe8a50a593e608b2b0a8dd5874904793b09f8fa9616a7c9bd4a9f78b2173326c08bbe6a18ab5873bdc72b1674801d3174cfa535ca99aef7de8c1dab63349ef1af898264d00b8f621b4fe215b2442348138208ad652384109d02c57ad4b13be38123caf111e84c914c1759adb5f701a4d2c41ea8e5cd84aec54c90eaec437c331f38fb632fe9e2e861ad78389d64297253178c923c515f363c50a90a8f1ae78cc9235bc3c9b3ea55041b8fb06484c76b79e06cf51871d17b0bcfa1d36086ee3f200027258e414c71cfd62b322aef7481d6c37575f60325edd742a3b34095f3caef08ddcba2b07f5f1dfe79c67f37c3e621ad03efded32aae351a37a1ab784b329202b9da04778023b7b647a1902225d8c5be031bfdcfafec49e8d0008cd5e62d4f2ad9d3a7666f10356ed7b71abff736093e60701ebc022cfabc2fdaadad386423644cc5190d0a2de8b5988a8a91dfa87d8c9c8286dd7bfec88eb99bbc0e14fda48fa56153e43288c284713ef0a473abd92e0caae61be2b8597a904d5543109f4c53171efa8953c9597d4877bc3b4e1fed1990a57d64f370c3f9300516b9cd242c07e14f1e62ecba85d084f71d2cbe51cf8237211abb8a03117221667c2914c2bea39057464817ff640a76ce240d0b34500b1683771bc53a8cc57d74743433b11eeda9e2dd4d89fba1fa9f6f670bdb2481907ecc7295882536a355489cbd8c76298136080b0c13efe7fe2dd29f1735544a5e2f18251eb42d6fa8c4c402c87a82a73f6a46da6819cc5d5610c99ab8991dc7faf424397895856b0b7395c62b5850195bdee6157e1b37e3f0c61c4d7a43f0f8917b3a035b04f51fbb01c60f22f79b8498ca61b135ecf0a5a0a47a7224a59f7d8e8d2dc1bcccd61079d77bc6eccb1ef4ec3e3564bfd81d4f7fe537bd98ec73eee85ba861f9b47b46f94206ef2274260c5b4eefbd0671ba4f10344c2adfcf2dae2821b31d29da050e987d02a8c46be803b09a7040d4c4857f444deb0ccd9d6c08ba153d8274f4d68b65e3557cc663c64dedd51d5b38f9298376633433aa1d6b3f5e9b9ddd2cb8287ad86c8d64401106bf84f831893743e8929d6a5bd989b52196f44ab1d894f259b9bd413afa5161cd7e4f7d199cb28df208cd051c7f7f203c96b016cb9165e7a8c73f7e1f6e004e3e055a87615bb52cc4da3e92fa4834e9ef33c8e8727de06c0331705ffeae2a4e5a9e3ac1ada808315f304b0972674669615b6d2767e8997bd62e22409cafd0b2b51aa29498c8b78b933d71d20271f2b71d3ba1b360de12d4c726736385a201a6e98c59091ac63e0a0ac66896e1e9026ba43279896a000972c167326b4d8bb2015defd49765ff7e02411cce1c43d93513be8020c51573d78f54bdaa0b71ff5a1a5738ceb346a1960b6e365d131e7e83f3b329f38df2567f5b94169a5d3d145d151e52c68195ebc54a87d7714c58c47ba325ea311b3cad3e860afd8f506702c0ac76fb24f384aa27012e53c9254b213f480a3eb4cc005cf512eb75cca91500e698438763486a1c2eeb44bb63750aef151115636ca6b4548d3274fce0c425eede38caa8aebd0f044ad1e5ee1d49e4697b9ae6b1a4e075271b079f19ff7e11655d73e190ff9456b6d5a08442f5ce753766bb2ee96fb02f865d2d18ad430e6ca47d914a4ae2dadffc6963a2b256b586dda3daed9039905bd8109417d7116248a5d90f7673b8ff36ff227dbf8488fc74b8bed1ca61e4f8cfac0c89991fe0a7d6774c7dd384dea1f4d04d5653d4ed27192f857e48ccda023b832a0a669091f526e2b9b1951956c801e705246251dca9a237a4ef04e7182eabe9430be5dc783ed31bbc9334bacb463bc9a0475b131b96487af3ace98a284daa7d9de5ac6f79cac3f95befe09ca32fb9ec075fb81015e508f3579cf8fcd26e6ff22ab94e5b9ffc81cde56382d8f88882511159e1fe5e0fa0684ed31f4b6d2a948103555c02553c190b7102f1bc38039b56dfdb458afb3ed9f42982f9350ad61503075896b82804a274235f77ee554d2453db520450222c80acb35572881713b5e7d43a22cd58c0eee8ae6dd51122031fff9f64349c997e928d0e73530ce9387d6eb3e0223946f6b83c15d9176a865d229c3c7d565b0cd4e7e4e52f7b1ec349c29dc2c5d2222671a2665c6571b3510b52fc512608a03a414a7d4efd01236f1629ca2c45a4511ab6e6d73ff8ad4b42ca8a235a80a5a95b52fb18d88c15623e516cb59e3958f1d5c4d59e633293ddfac7d6039fab7c19b815145d13091fe9842ed6b1bc8eeaa3397e456cd3468e1456a0c8535cfcf06d8847ed192e48ece0d709f2dd3f681956efbe66bae04860d91727672f0b20fd8de57d4da372aa3f37146d08a78b126700bf19bf1d8aa5954a7114a2261a841f0d634bc649d5a4d10bb32176818629f335d01a9c87ae62faf60e44088fbff0c10c5c55ff1cf8494e2b980c317bbea15fed287ae45ad64cdd91b59cee26e229c1b8434131acdf876645ba6d6819c6c62809523c5dfc8aafc165c675d225be45b6a3864194afec8781fa7aa2e843aa8b0ad9d41b05db64ff57afe378913f4dcf671c4566df1c1aedff0a0056dcd0a3cc3d33c5af065b57a45102793fce7256dbbe4455c52ba7531fdc0ce5c13eebcc5fb3f761f6a8ad95c42b108ff96a67e629d10bb5a3e1565c621330be17c408192879b6af845d455d6466331534fd0ba8783a12ec5b777e8892c26528b1df6e7ee36a1b4adf3813c8c6f36ccbeb8ea4231acc09e80c3433c54f352260a5f05616142768adb921e775de6d229c746ede3dc5051f697878fd2d9501f7a4381e82b53df675ea429cb0256b5c4cab3a6add2705a379f2f908c605f20e6d7f51c515867cdeef5e1d550f8f7780d4534b2f39407f5ee5d37c2f4fec6c14a8a7298b50ba2d0a938a413d0ebcf28019b117b4a91dfb150b00422baafb53319141de68305f0f29c1e31e9110151e926eecb474a57882f501bd1af116eae593448a0ca3e88ddf34bbded722cb6bc3c23ef699bc6131f479d349bbc016b3279a49d0207055d357cd22c2ba4ed5850da0d4f793a81c4ab2d5a567cda7fcd930602291fb2e29dce45a406b4ec64318f0119ad4baccbb89c55fa3ba718cffc895f7c13ec516eff3298f50d071569a1fe33b370e0365401d750d9b80819cb79e0715fa7c6317df41d39b42c4e9b1c31542e3d37de4147f1e1e833d181311b888acc078308690a58551e0d907188d64b4666c1127c2b9dfdb476ee3bea1e79762546759e8953622db9bede2ba89d5794184603e2ee69c19b6753f7abe62f42d8e39c7f7eb8f6237e4bb6ceca7f8f7368b492d7edc08670d059517647efd8f0eff7d637011cdcda7db5e07a00d6a65d5df361ad18cea4197bd8fa0f159cef445413b27384b591365cffe3af81a71f9b5c72e159270510db5d59082374501557d069958ab4ffc8802d8b5eb084d91853209f88c84fe7158fa4798a05d9d081aad1f0343fa48aca2202be566e77963005b51197b9de67b233ea02303d5e938b9da9089f5dc6207332e070564b4f50ae24407843c8f96cd63a9f0b44b2293a0e008314cac9d45bc9c3a2e1f64313ec3a68d77ab29397141382a05f115dbf090032b42c1c6c46ee3a3d460e9c370cab9cec8916ec80b929e32ddce1f9b404394112a2976892ae6d35ad43b76494f60efe1bd069e4e9882db5c29ec79d8c1640971236f5f2536fb24685a7436c997963b8727e17dc7e9741ac9ea2802521d40b60f347b25ad55dd8a108f9779d9365fecd9b642bc620d35a3fb9dcd6b3dd30145d0c9fc3443a3ea23d5f2bc4bb53e14ec33def1892cc82eeecb26ecbbb686136d5497744e483b5985a409d433d6b50ecc6ccda11346709323040e03ac07381071fd663e77336682b5dfa16759d0a865462e252940df3fffcf94321c5fdfc3aacbdff0c2ff05fd4c8e759f29d2f54b6527601ef0b7908bf9e03f210714eb394794cabb1e6ff2aa5eea0d3a9a44e316e33c1f8141966ea828d596c80706c05b95409ae7b0ea956d521e1f071ac5f5b301e8c761e5646833253292d9e02a46b8bbd6fbe48c8c29659d4037889a2f3fd80d76727dfcb762a9aa44cd4c933d285282653731051e9e45bb0fec84c20b0e1f79b4d4ce8c46e012371af65ec705f7883eff5a23d40f86eb330ba8f2d34fe1f6c8f4ea9faeb392796bb7e86d19a70a58489f944a72f1a0c2ee40fce44f9ad385634c882177c0417e717f967062d1ea3bf824a3c144d19ed93dbb5db56aba70c616094796e7498397537e0306c6d0bb724be92a4f168721f3be73e58dd2630a3f54336fb8d20dd77fd35f804e0c8e13ba33c4cd51764c9060fc83028861426fad8be6170e436f47fb2f3705e073d548f3fa00065389e2dd12e8a4b60d5933dcc406aa8565f9eb14ae77beedacc87b2c6d9552ea57d3e542386bec8209097c512cc3e1c1bebb456687012639cac64c5c708fc0c5eea63b416398f83999d7a52eb556cd063fa5b75127c7c85c715f6679806499628881731de36a346be510ad79ead165ef6e22fe57fdb1836bade12f75d3ef1ec694f4ae1907e45965441e6ca8703f5d6fd1439bb63cc11eae78f97925a2210ef9a8e922ef695e85c4062bc85a04f82bef98ec8b8327f014951e3466695613099ab0ff8d1801e1880daeb27451d70aded5b534116b9cb185cba13df4c662d68969f96733f12964e0c56fceb627ee3578274259fa3c9a29e4ad5e4e803c363cc20fbfcd453b85613d8a1aa4d0623f9097b95cf1fc093db98604f3cbb39c4633aed5db2c7b4ac119b7c2e41d922bd2e1cbafa3a8e90cd2ee9aa8555b9caf89bbd916c3e04c20233832f5ad4af7af342f09fbafe70333a4b2bc084e83089e8f398233e6ee2a478ee94568837637996c571a29c30d7233be54ee3ff39b5f2ece90b654e34e5b74abb6407cad2a7c579d48f61f9918fbcd1acd1913fff6ebef40e6aace1085c84896cc56e5f7095dd31ecba39b87889d52708749bb9c94d9f7732135d7d3503be0fe0c5cb79747f29d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
