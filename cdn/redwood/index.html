<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9f1e021b588000a3eda68305537313815be6a9eea68508d097f33960ed04f03a790d6d54e4e59a3c48acca372eb1702b7b6521ac40914b923351fd7d4902ee62bcc41cc817bd2246bf482fbd8cf393ab3d67b2926d2b41eada3cc98663cac0a20c9be3efb53310bd5e4308a9d929cd15ce67f0681b849394ff83df252980aa87b46501f60ea986329f4377bacf5577d55284da5d4223f94cc9561af2329e3f40379646b91c9683766ecfaa05f4eb411765ebbf073fc42b926950c3af54eda95904a40878747c81c6020b729ed692ab407ba81e0aa4fe4da539bbd22dd90c32ed836b2bccf5a21477fdfaab7a52c5287c38c88b2b145cd56c5e1458b43e5c8ca80b10a0d041ed71c4e225294d1cc34d170a532aee2ae725a96994891662cd70d72ccf8a0c640860373bbfb11b379d94d2cf4ced2842ccb77a3a1dab8553c4b79b5efafc4cd53eb00d8a8d1ca824e61921f8f8c7fbcc220e708095a5e4a3629abbcedc0a8e26db743d9d703168be7d28ab53d5392aac3c11dcdadc88c54692dc1c9e18b7876a5dd6eded77059b63e3a70fdd81b8d7b9291586297d2b0508bc1efc0d2ad61a643bf5b66e3094081476fe8dfc512ff9bb74b2db27b937a7bd3e43ae90e891d7509b3b9e5aea0370f8361df606a2fa55f2d0a760af6a8f373157c1fa055e66ffee3cb5c092561e920474956404e14d2800ca0d6df0129677c2b3f07cfb43c409579e31ea44d2842b8880eb15e0ff299d8709590b60e2220d5b1a63c95dc4d046429c053bf1e470da2ae700bec16ed8df7f1ee121a77defd06efe619c2218ac7eed2b7bb4ed6e9640fada5dbb61f8c07c5bca027c50c5d4590bc4cb73817afebc9c38694065821951163ffc13cdff3a39b7021a2a18fe49a27e20b355ec113a544cd2fb6fde6ea54d607fc131b4ac1a7155beb0ac2a6f30c8bc232ac608100eaa8e05e50427c91a6da300feef1fdce41e56d3169f7a7ea5bca84b69c974dacd249b316faaa60bd078f4141e3e94952f94ba6ce1e5ab22ab0ecfa3d7be470e102b3fd49de90fa6dc2de0034978b0255b307541677886a8bb1e2ee5d65544249dded0c64ad87fccc03924770d347e67778a5bfee77d9c5e7d5ee24e590e30d7b84c9bfe039185f0868f8bd7e808a9c4c0c026f46900174d93aee46e7469706be53a6fb4f334b895933c925939edc2c21b1a8d0cec002747f80566841659f3c8df0ccd07e368623c821563674cae0c6f73ada9c0b5c7678966d6a43a09cfdb79d5402c160794a04357e617f87531277fa2e68e20c77833ba372aba8a3c3b278399c2803bf512dc98ffac5f5e0207d38cc68647e5559be4682b931676698e1b7938692743408850e1555bb7089336d93c180f08ab4ae90f2cfd307150f7b4dff40622f2fcef26c3088ae9a7a37c0c23a45f2a9f97317c69924c78eede364a65d513f51e6f42a1e88a76414015fe36d2c6718c71f23532c4f93a03cee6bdecaaf622cbdc1fdf0c90e559d45dfc109e0074b735454fe2ee0dafe51c4cea33c2fba49282986e3911ccca92350afec9492dfeac9d33e459caab9e2a48d5e6a7aa83dbeaebb148dbe2086bca808934424f92fb23f92cbc399320bad72add26a34b150fb5590cf292f56285c926347cc04073a918857f35f787aa9eed567c083f924a09faec2aa15ed1e4fbb62291f7d5df188be1610fabab07d89f0d82281c5f1d0446e8a1bff1394627c52ac13de0aef0a507b2efbea9306cd8ed5cd02a99264e80348d59a455d31bdf3e1c8b23a569bbe0d785d2a3284576efcb84bb0a6c034339f66639fc94ff2b716f030ed463820ca59fcc9d118575faece725e420e33ddbb3a29384b87da605a294003e4313a2a1efd869842631809d918eaa900f44884cbb87a09f5a5a286de1de56fe4f98b665283d88f8419b998f1a7b376293f38f5c1181034ad0cce9800cc21b0677fbd932dd0d78f847d3fb2cbf80bda1ca29ad504a9e0028e71fdd379a87ccbc2d4a8bed199334e21b521889188d23d4dc96e52fb6e0b57e4ec90b8e5e05c76044fa44c5a959aeb9c9533ab9cc679b800e5b3177d1446ec155fc20f37d7189fb9fe9c121ad8929755a4de25de3ca4d6d4c05427e49a68088219a77248b491994d9539c100e23dfe007689fba0b10d9a1b8fa5f8657d5b2b29731e967100de8fb333b7bb615ff4e109ab656cd900c65fe3d7ae6e3fa63121117b8ed389cf7ef1217c6a28369bea0ca6a95debec36e14791f05b9be54c64c757350b298d22a2e6ad4396d69765d635f3c705c734782b10d5f2f6cf8dab1703b2f1becd74ecf04a16a31f0b76c1971a6ae7cff63b4784c66aa95e08653ae44fb424f3e9c1fbee9d37059f4bd6539e73432b7abec06a5620f4e0c65216ed3b99824c5403aa40275132babbc0d70bf0519e244af3901003d857308c7203c8c19cb7bb80c5447fdb0e44142a3bde5d495a5149e53e9e575ef17a883408bcd82408978060a4fa6671edcea254ae616852dde58ed0af7ccee9bb87aa96ad72074cf03c35e5b1874baef33086a58e6e0016862e7a83239df6d9b8bcc5b8c98b9147074b291f876f2970d2e7eb32f449b215ada97687097d0dab1765160ea3f9cc70d9b122cdec91e46e730f3ad97eb3de4f4ae033478ec42d9d4084c76b068ca9b67ce0805b99580de6600908c2c9097161a6421bdaa7f55286dd7d75be09df0f79e2d560d39da6007c1254a63a4b937c44054d824e784d85f41741bf24c05237bfa6be2b107bf9c7263510ab7b703b291b01d70a22d077bbafaf30d5aa8677e3d9bdeb1cf9b5c185c578b97c941893a4de785ce78e1ed35ffda9377f7ae399063a590070362d2f0d6b29505024d60c833c0fea7c7e50a5ce27098d1c920baf9f0c1f95fd372961f212a57c8969f23ed7b4647b4299256639a50d246ddb8465c439acbc2175d5638fca6a985a2f73145dd6945f410411ccb69136d42d70d706769299c9c533b0547eee975404a0c2186aed21712771b0d7583fce375f6e45eca46739c250f23169459673939711ca38ce930f3880195acf6f7eb51991d8f01a44d59964078c65f313aef8659ce15cf819f7a5df492c0074495aeea31e285d7d0e038d5feaf8fd479c2622f03127b37a4f2b8038b9a0f4d40b2122f927e9179e9ad546ade01fb593bdbcd87e5bf73d11ba4ca1b5b74bd28b76122d8c5efc13eac86cd5a0867e54546871c729c90345899963f57336189e1e8edaf08f0b9060c5e8685b20a2194bf2c667e392caca7f598518528b1a8406cdd8a137eeefef86fef620bb519bf18c3689b6b0253405658a68b7caba3ba4f9ed2f27f75e1fb21ccf922be15506b165568fe1450f3bdfca6f2ce53ac87326878244b1a8dfe65f6503a58172161244871ceb9979e42e1ff2142a168f39bfbffa963f6420ef6ed28a82653b2174c37457d04211044f0864063e9e95a3b9555df06aed471762c937c389d00f736966f568a8f5c22abdf6bd8c6300222c4c7acbdae3db93ec1a077ff972f349ef9079f46569d2490fc83b210a43812c8c09d01bc27a3144d0fb76294b69e1dd9a08460beaa621a0578fae0a5f79ebef1b10c1ccbffd783a153ff428935d5226553218a821930e9e8fbefe2915551421d5e694c555c98b145dd92194945a393783b1c43bd741eb16dde07f5adee50d3b2df8786c21430ec2385ee390106876a355f46518b142696e231c2f3a0c232633ecd69d084930c4b82dba6b93cf96551270accddec0ea26bd8cb380f8f32e84a4707108d9d9b3cdf59f3f25125f1e71ff38720aef175cdc6b98faeb630d80ccde92b282ed37534dfe7d9daebf5b194c7c27476f2bd82b999cb07e8365c6d441bd9810a9d092fc3e8f7a5325aee68cd63e52bbca321c8ea1594cd1c1649e5c4ab08e308b8810274d3993d5c5e93b706099ea6cebdaa88d4ccbadb2ea3d5da00922afaec75c4e50fabd7deb24bd9cf13c60c6df1c509fedc29893a5750128a25731f0d716385bd48fd0ebbbb3d4f555a4c6eab6cb3965fcb8265db9ce3e0086d63d796787157ff19454067bd975ac69c0794109db77acc4dd4ee1b077b188f22b8995f2db88b6fff9d690e60f485e6c2872a06520bbaa3eaf208dbba4cf56c426670f490b466a4ec5afc3f5ebf9878440103c836ecdf8a815fbe141fe75a33f923391736e5657b55c8ae260f2f6ef3cd1b2491d044d8628212f76f5623bcf10722c5c03019d526d53738abaf69b7b008551bfd1b0e8492803ba62755d8822dd60c8a877641206fb74f22e4968b0f55b9d69936b6ed56ba3a70c6738e4a18c98abdda434dd1e7840d7990d7fe62fcddb29e25af9a346c324150baa3cfe1176043b867d061bd0b72728f30c5cd237b01077eed96987dafb01956d20ca299e7d1efb7acbd0fb46fc4e6c8a8a0885cae043d98808d3ed9cfdfc85b0fc70028c4f6fa4fb83331734d2ffbaef4bdce0843194600c3e6fff1d967e98f5243a262c27738061c5628789020b42ef31ff608313d81794403c8c7bb718d6acfaf6d806dd5b63ea0b5453eddc45d00cdf46d6444f49c9d42c8cbd4645e6cf2942cc28a74c1a19973b04d2519fd777941aaa9f8f01b4b2d857f449ba2f0f3d74f3f38aea210a2db680d91c797625949177d497edaee3a5725dfc285ab989719df19600629fae1c5ecd060b08f3bbc2997d3f5d7ded180a63fccc5bad1010a24d5355fba719051cc274a214b6b0a2b00e27568acce4d90dcfc1716b2bb41c47cc5dfb4263e98c53afe8b2603f005e7b6133720823cc911597064edfda139da99fbcc9a3c1d2abf98d9a18a42f54b78ec6da062b4456dc5489d6bff81794df2884e76cfd5e946d2249955f5497c24586d5023d3743e2dae2839e649a115f5a318bcbe17a1e153fd377853bb0ee4b85d0099c27cd207c8fc98a1623a9eb9b1488a175ba53170ddcb8cc89d97c024a4b2730f9dc72fb4b5c37938f8609120552b309902b872b55e3d78d181140d04ce4cb6bf7d17cd3df861ccee0aa1049b8ed2237a1ba7a0b2b4752313beb342cfc1e125d71f1e6befeb654f37021e372ddbe056ee50a4b1e25074c79985dbd7d512f14000d6533f7fdf083626c70ea5d8bbc9b5c01460e1b86feb3a3751874545fec07879f118f5a2e429e90d0b989c8cc5c652b574cfca37811f7f1f441bf0b83b00e9ae128d05dd517011779131de7a1df4e54345e1f181429ef96618e1421a257870197a4391b27fe3b472f6cec4eecfbc90bdcb1fc98d9eca3169e9aaf3da93561c9b029d4f72d714c59da9e45ff047cd261966e11040b74a9aa8e0868dddeb56e28287cde92c97c489a994e54f02d13329d04dbb804449d129f28c36d8b3bb8fa2a12818cbff6404781b4f475461907d4ae2b279eae4f2ac17e251f8677e5989b4d5893a09271452c1b254f512e017d1d25233f085e87db77fcb5fc2e7d7b58f0565872a3ae899bf9ca68529991fa90a379f26592bb34bdbbe8133315957eb7c1eff491fd9923f3df63782335b1521a12d98f4e4d235be70ab957ee476c73798fa05f5bc029fc8106149add62ea1eff059408e36a1fcf49935f0745925fc8d73b0131dd1db7e8f4716e13475fa9f1dfbc997e299878b73b3bcc896079097465a2ef0419e769a1c2a812a36d0bc65b47da9e6d14ff9afa5a423a61020f6e89c9a939269bd1c8813d4a2e9a5221ee19cc06d0532da7c082dcdca603203bc83092fbd307da44bdd8a50af2ae0dfbb47d5c4c53a3770c72bdcea59edbd4637906933d62e2e3ad84ac363b2d6e98bb39f78fd3b948573e811776a69888de7131ed60a36d8b145fab9011b6a178a0e06edd3111f14c6b71057ca9640faddaca76956c52573f367d1a1bd048e7a966142954f85cc32cf009f2232b6e9659ac0a4c512f1c052e4255c54f7f436b2728c31495f9487ffb40da99656384769edc323a22298429f351a8509fd972143ccb75b3298927054416c23f959192d54afd4951fa0ac875e486e6ed0f615ecc52fd4ebef8b976834782b78b32c804c0f48a5f2a8d4b0b300f2c976d2e02d24c558eae91badc7b3dec2e21f27c7e8f50e75ed39d748b6c84ac16aa544a939e913ca12665362ceaaa30f0480df531303e2b4cc54fe298d841cff56927d626d4dead0b9f252fdffaeb23dbc537eb60b231b6ba1e22913dd1d6dd280432c8598b891bdf49c1ef412a14b1d5fcd5fa6de5e77abab094ba3ecf4684233137c666d088e1387754a92d283873b81f27112a2bef77762f6e6b5c8fc45b200679230d5355b67126be407db16bbabf84f6045dfcd0dc167b153cf2a9ade8a34922119ea2bee955615435b7080e5032ab84ac0958db669ff1d43f86327f5cddcfb1735c448fce54e65a9a5d815ef08ce460022b9ae17bd038836e7af817e6efbf4d421f3aecceeed992dc0974fd517a5e6a005bf1d78b7bd6132c4d09976a25cdb69f6aa80a375d598061e4a6410afb6aebf002d69931fd2698e3f06a8884763368f75a203c22cb8db53106836674b49c2b457b4e08a5f1d3d28c3625d0f1a1476dfbc7f3cb18d088c09d551c8b2dc3e0c0e1bee7738b28667cd538b93fd99051f9572a49e7c24d4ce928ee273b06f61c7a0878075944a6bbf4b68e4aaa6916ce59640a1e650621a14ee1601e634a848c18135086ad274f72852016f979eae247bc7f121492f86ca49147825dff812101ee6f5f3874789a135a13d29d13f7b8459879961c35e9ae743d90157e538e4692f1f5183d2200ae1e816004a84fd372730e6f643a9ced5e09d1ed869544820dd5b538d7faf78cf02aa08014ffa04ff1db360916c3995a263bb473704d12f2ce8a07697953800694defb2faa5ecd3858d7d81498870b9639c052c76616017c6c7f04db0151e923c86c044b4176c9ad8b502ca06eb17bb32586be9d0eb9ff17dcd616fa4de5583b87d1f0a1e15d31fa13d8c3c60650c062bc6b2c5a2cd22a3ff3db07701d670384ffacf9c9497ebb8f8ab0aca6362d3bb4a3bca17e75ce7120221683ba9d8a250a359e6a00ca932e9f6282576141c32c29dbdb0e174ee04690d91e373e661b48874e7820f47a3ec61db02387b8bacb9452ca06104fc31522bf45f9c4fd2794bf8a82bf92ac1c650a620e67fabb2ce333ef3998367ef01b499328ba5d125d1fe9d5fe887d4d7d4bb032e4399f6f67a66923663d37b7d42db994054731476cb0064de4e28e0b23b221f7b946614f135650a7880c39afa8069e527e07ca84ad631abc0c23c8d10d388125646643b04223b35c84e5217828443f3a7c0e9be5da78687399ac2c494d1e7a94517804c6c9483e53ddb12213cea6cc28bea5117895b0869872205be9e6abd2627f7dc3917ba7d3fd5cb938331dfa137b26649f45c91224eaf33527cbc3e1bb67c52bc2367d9c5812a6317843c7f877ec95825b02e69d5fba1f86d2aaec11ec1444a0302fe5096a25394353ad79af16d562143cf05ee0e09a16d09bc76a33bf7b004577469f17477771e94a24bab94979e652e94480eccc19ee5aa52087e12b42e75f6fddc0757632e6f9f38955c9f74e09ab425993118daadaf33783a625327e1da77704a3d263769eca12feecbe6bfac87c4e6590245885cfe6858256af4f3f62a03dfd08fb4d69b032645b4cf325949814b145ef745f9e3ff57460933738a4684e3ddc2f561e973066aa7b045ac05324f92f96981d93fa1057f7bd70d5d271a5e42866c23c7d0ec3fe0ea44edf0ac4672c512ecaf65244b75c60d869615b67c1af4620ab77755f1422eae046cd7796458c3bb33659f6753ff692377a48b7a68ed42bb6680e835c525411c0daae841eb4df7a9e1ae366eb3f79c1bcb9a4b4db5864e3618cd919f415b56225ef638254bf6bb1f68418b78b1245f36b654bc5412e4ec6b2689d7793818b98307c93164d4b07708cc9f96d8def6fd2323ece4f5cca13f298d0f811a3d1b54f074ba5ac832313ad2c97e268255994d903e301398755338d508ada600a822a4fea1849938ba2fb6364ef4b1900336cc3543aba69c1121fb0a5650bea043cc76c9e68d78eb4b079ff39ac902bedc2346dc368dd20bdd5cd4cdc2288b68e34b474f1756730ef841af856a89b07d88ed11f16bd28112e9ceb8af1f3bce1d7ba3f96dfeeb27897c6b4fa841e660245ad58a9e18df1808ea4bc5ecae3bfaee5426a025fbab683470c78c7af108f27833e43ddf9c8c66884a4449ff4262066a27751d440c7e87ab63637ebed6f6d1decc76f5834215ee6d073680b314ad7d5bd83cfaa2b5a667547551423d2cc03e293763ebcb90bfc98ca677105e43e9a63e028b53c00fc2d42074c3758e2b5626d34f541e7e1f2fb30bc4e19ca027ce755d8a6969551d4552c43ea617273534ff052d804740dd3ab022e915e214235bfe9e970acf5a42994da354e98446a7ba13387739f704fc505287acc8fb59ef69962bd91098045853a5f0fdefdfca6c160bdc0a5c205823dd98f5a34589cd68f6d16b638ae2b49a2b86cc54fe125ad0d81ab92ee8cc8721ebcd3a40d3586f8a93fb9c26142801ed66df8bebb92f59ad6576abec07e49a05511ca6abb2d79c1775c8be89e92e7c7de1de0fee514825a48c175f9c0b7eaf36b1226c44e984592b3fa1af3c3d71027004ba77d658ccff46326c67e83652dac358e9a84543c40a2a24da496e3e69812a2ea6d9b81571ff1b07442cc2d0f79e99c292925e48df6361bd8a934e6887b808649358a218d4d265e14135127fe445d833bf8f5efbd8d98d8fbb42da2d3b8224cb51343ba765ec13db30bdf1276d1a79d4f2871b5fc42b3b44c5b099d0f1b0db3f9a5f923e9a7ab9b2776e7c8f3f0ebcd453f6ec8f7181f880c36e50cc091dbcf5b9d3d35e17dcc675b2ff47c9d58892a109dd06f18c6b40af53f98000c2e10c6a690b3957c9634bd3b9e9f918c4981c4355f7ed4f061a88f0bd9acbe0d2b1e45c729b31d593ada8378fc73f0da3d9c8f5ae2435d395381296ca38429fa8dee5961d0d5f505b1611c6236db8ce304435f3c42780fa48b8add6e7de9330b9bff223d2c097718684c3f52e5415def21a3ba221f729058bd396f93a7e9ea4e76b68040b35c49f434340560148db91d37afdc7922384fc014d6fea7418383de78eafc241dbe3a8bca8680865e2f63c954c1dbfcfb56c89ddb02c68089be3d8fd2f1dc76d393d0502cc09deeb22141ca54c9cc5e1162adebdfd853f151cc1c2d874a67d82b6b5ed78c35ea26ee1c9f507d5880e4b8231f2ffed69dc503730663a1d1f3fd8e808793b5b921149b1abe709dd8ff996789d66c61fce9e438abe742da1fb559ea116cd046dcc347db92374fcfcdba839008e9aa1bd2516a74aa3ad682997cb2dfa9e529ae9273e2d27af75bdb2fceaa815da7221920663ee490eafd1458d02bf22aadf734488aab21895b7b6e116fc447820464be4ab2d70ffae6816ae5f8f96bdcbec4eaf896c6124d854e735b9b2d70064f59a6c052f1d34561fdc38e1000360f2cacc60e3015db625439ec3598f5d7582f3ebdc04ef6c392220de1447e5a402b7534c368a7eedd2e73b4f336f1c59dc31de156aa5093fc0b70011a122271c77e9f7cd7cbfea89dea8d668543da14410347b4a505df26677f2dbc8ce3a315ec5c874934c4c388bb89b9a56460c021f6451c0a9442c24e5c29a825363d77581a8fcf2c0712a96104a77b497c8107b4680b04196d559a711cdb9404a4cd4cd9f02c97d16fc7378ee85c8f21d8453b2e5431fa7f409ecc31c72917b4d49b9cbdc52d11e349b4c84fafc3cb4122515f501012b8801683bf53833cce9bedfc6fe7a1f37b75533d85b613f9660cc35ee7770e07331ae0bbc22f6cadb2ce165466a70be21fcddeb6fa0cf6e86e5a420d352de618c88eda378032ad14b73bee1db3eb0957cf8a8764e458f58595213860c7434d3b1f3087df6e29d02c4063af2ab608979a18897b801b5b4673c2a68e26ac2f63286fb3d905fe91deaf05ea621fdf53ba2e2b89db9f844eb35c5e7107a06aba413a303c459a00d2b4e20a468cfd0239b8c8c3a6b039c0f240268ba7eab58cebf7cbf57ed08c76434ae7f8ba213374953838bcc94a0c51cf3eb46d789ce4420b17d09738f71dcdda905c3eb01a2208431f44fa2705186eb0d5bba98ebb0f9ead28d87f42f4baea72efa8547d52a9f7899413bb37c233bdacb0304594f4b9f1a05ef49dd6554ed75df68b94c6ae6d81385444ba05d21c567d3d8602ea04ffae15711d3f52e6e4a00d60d54e4f54bf6f7d24fe5d4da3102bd7740fb99727b01eebd765881d6c11048c07fe7c5bc8e02a26c6d0a33e770bf84b07be847f7164fdb781c64dc36aad6bcfc00b647093cf48bd76b5b258bb3e4b12db6c203777295a1bcc3f80d2d896eaf0e1d9ee15320a313aa403491ec1570e67573f2054a8b8f89fef36e293661ae44d66a9728a02e507abfabfc151ad693868987530e71447187dfbd8bb3a41a86d96c56d87b334009846be6959879f7255c913e9d091cad4bb268b77e2976f873c103a05cdc2273a5303919cc119672db485b39b65fd43a7e6f5a724a6448d8884f44276793b9209524ece95424ce15f70ebf31f172506c814064dac823c4c0713ab19b3a80aae478c0ea1bbcbb6ed1383f54684192c2cdcb3b96e17fb6b9ada7b82b1fa036f62c85ff31ac8fc535e3fa3a5d43e50c2c0ac374ee4fbc7c783a71c0b8e480d576189aa1350ffe4f1edcf8a6d62f93bda4107d855f262d35cf970b740a48114545ff1915915d66a83ef1e088dac12f21b5d74d6b64dc64145042798c6b5351bf165a18dc79ba2caf3c6267b9cce6c60e68e7995e1e00f3fabb68a56a46b020792a82bd01bbd96c00c2e2f319c04d332b025551da421bada617cea11f8e5f4c6b81073d6fd772e89015c9d5bbee75c4e61a7bedb8df7fd538758cb97d09f2a9fb85863f7c27493430a477cb4741fb8f826314e66787e6aa9e7ddebb5d773612a4fcd3bcf34ce71ff7a4a2063e862ef6c9031c1cac95fc5ce7dc933d823effd15893196c2527b8276f7788fda5876db6a3643997d69d423d2e2fa910f0085093bd18274721b1f1f37f5218892fb400f5c3518924d1aa4c06e43c4789947ba159a957a42f457d3572d6fe6c9b1cbb434fb78288a56608c98f6ccadeb15b2e5af882cc7ac1d7669de99977dc4808261c73d8645d5b48ccf6123d8cdee1990034349d04f128dce74b4abd6ec94cf8f9134552d219e0e781a507b789f193ceb820fb99535cfbf7b58dc54d6999fe216dd2f55b0bdef52f237c0b28c03f1c95fae46dffb9ecf8ebbf399ba3effe30bc4adffd63ad7a680b5d5fbe8ea2cf572cbb8c92dbf22ed6d06124b46aaff4acd59ccb134f8f0c7ce657f792d6878892837cbd17442eccf7ca8bef81c8d89f73b1e6e79b264c949c71f57b11126870224800e1296fe8c461d542270707552f03c7153cd0f2f7b11d24f2233c1fa9b40c4431cbef53d09e53e11fff0ec4ccb5d71128a8d77bf29ce85e8cbefbf526b5c30620fa6b871aff5ee6b1cc76628127e0a31fbbba35e9b2674fc966013235feb088f04c190386d907415219c7ab5264e0558655bfbeac259c1c77ff6389722190a46cf19dd9c61e179d36b82d48006c6cc6344d2a0b9c6427842c07d2f4a44d7c200707636c2019176fecc4df38f55ca1dcdf5eaf46a67eda2f0925206b423a23ccbf5f17aaea84c888a7af1ba685541d9a20f0918167c2175c85c556aa384a3052a64acb5ee0c3c709c9f4b3964e997978c50b32f9342cb5abd0622ecd63bf85743ba6424afc8a51e3590fa1b6b8dcf4d8ff64dfb2e3f051911484793e4443e2be7caf34e3c278f250f613f6c6c67cb2aeb4223b2852bc4756fcd90e589a13b9015f6ff791feb77b1cfb7ac25e7e7ca44534b76eae1b524bffe73a409542fcb2cc522092e5e416b706c62c7272779bc6b89c590dd4399fa1aa25307800840ca538fe4e257ebdafcaa60dc5b4415a5a85fe6f5d0a49b292a077c352c2563ed3fa26a50ec604c25582072a9b6b637c79cc08fdaa351f39b8b4774174a35f9827e07a8f6ac7c4f4b42eb8688a36fe215ac8585a83763013edb83aeea85b5d871295b2189fc4e8513e0bbb664d32b9e28a3ce43a2fb358eb4957e749d426e29ef0f9b4c2de4be83691f052b801f3ca46091c6940336d6b4e9b9f017aa2b208cc66fb957a780336551d35bb3240bdb61046d4878ccdf932bf5788deb763aff0aa7984e79d89ddaa61c8b2cd3d7b63100d5e80bb24333c5d2a1893b60cb9dad964faefbc1944c1b82c8a823b62c832dc9ea4e234066baf0faf7c7213639c6e84d1e2f631f37f3a4cd4acad1041b40808e74f08a87424d5bb2ab182e0ffa74a0e0f7591a60bc7e0189d94dd58fcae480b2ee2eb73882f6e2d4c11a4e83e9b9cdb192971319760057f38823e85802f510052c19b9c0b205696e0172474045e718f604aa42c8eb26091ab1a0e6f49dba9a47f312dbf9de9d2d14f0a847c05208759a2c88579579974611506e80ca2ab16898f75190d23e9b4bf24cfd44f100e39ba9ef3238871fa63499e6197ea57f1aeba151a24a25c50fbe1cc3dd39b9c409e9fd7ea0d947dd757c2a2263b1ed7fd32dba1203c46374e6122e9a2af0a0fe1ab036e9d0ddfcb66ac7127d47ea567b4b2721d2d59b6756a4121b39751efc7ef812209b53261ac0cacb4ca83e80c43d0cddc38e13a69e09a2588b8e4871ae6df85a3772cb8e34630c926896e71b3789d7594b5f015f3af52f4e284c66e1368103ee64f177e7d0799f400359d4ddd3ab825b1fcf03b89d2172d2ed31e1e99d5887e063dd80b56639e9bd9395698298b74365b45fa606ad3935017220689e233cc6e24e3e752b582674e193698c750ba0bd127f8705a9ab3b7e5338d07515cc5f6872f904fbe1ac1bffc993d5e37f4ca2f04059c516e637708541fd5c651a3c40bb446fbeb1dcb285498f12c5658af1b5ac68af3369c3ebb2d3dc6d83ae7a7e237a34b00364e679db36a7a70f081dde34a376143ea15e90a5256026935e3b9b8116aadc94dfc618e805e589beec877a68530e0bcee99c391c1cb16ebfe958e5e577913f6cde0fa393ade65e004375d3ad48a2037a59abda2bdafe931aa64802856ee39580bde7fecc0d165ded0dc27c31c4c7a6ad57ba99f0ab3af0c191b76d511f04cb7d38f169353afc877ce773d2da5af35bdc72fa4fcb6ef5fbb9708bd5649bfd63561ab7a450ba6228dca0668e6d5a3fad3de0758e787cad9d9290319afea6165980eef7301de02248fb7cbdd880854994c1996014791862e4d39c9b737c0eda57043bd624c32e88ee09b9618cd85214c2ce95a08a1a2d6901c2ab2bddbbf4e5f6c3251d475ed75359b27a6816cc578ae62db7da3ca16b9492823208c110dcf963b8d1c945ca565117ad04f39a1ed641a3084cbb69f449e8aa301901b0457ed2f7b65be6ad4dd3091fd12aa03fcac2f5efa841c6314a867d32aece10e8e16a607377ba71cb2754e43496c867c722cacea78c919b5ec5fc20dbc87d9c8b2f9028c0df39d31b0ae7fd725bcbae2384e2ee1e3342e93f97db6af6bab88438cc3444af5c59223f9f7cc37475944ee33b74edd48548ea4eaaf99508edc7e617298ae1cad43c7d2b195cb3019afab76af37ed196ddf13acde11fd9604a2a88390eda197ce0c160984b38c3bf4841842befb3eabb05ea961934a1faaf34dd3b41465e3b75cdc321ba83f57a55193b07373d34e2b30f67857352376d2f4f79c49f0db8d45487742bfd1e2083e71b12934ba7f333cbb177853114af32cb09c7a6a277bac79f128f965bd7bac6553ade0570e0a5a214ca5b7a64d874771997998184635eb1a41b34357d5f87b4afda6cfc2148f19aca8dee00d0470cc8f94b46f6b2e3b780a065b4b9130e67ab860f27146caba2436af19df8951dd2abd92f53acba57c2c5d3ef5bf48d851089693894afb5293305e8bfcc66878e00a20982144ce22a3a9c25d51179bda3406729a4fecb78b8cadc73cf110f43cf3d15c275a207057c59c7294d3f8a54fcc2ff1a55a9af2976f99208503cd90fcc7e7f440e01a59e9d1b25b8e885e0c4cb6016aef56e3db26dc9402924c691ba792bff1b3e81b615be2ab335597f868d925fd21fcd070655c98ef91f2d5adca8bbe2883c619f6ebf85b89802a16f8fd4763ac69d6214d8317b2afcdcc9fb3347d30ba0fc981d6d9d305dd81bd1ece2dfe22e57dd3c4686b33264f0091b5531b444208fa510175d53891f97bda4b8ed01bef2e950f8859e5a5a451a66f6456fe2ec9a59f118395cc3bef5486c735bb4dfd44bd45a64b098ce825674eeb643b680615dfe76f94248c8fe8e27635f9c57ecd66809ee7353807eef7bdc4490a5ec6d592f6748de9c98b576113576d994d52f9700dfdb9cb23f57d10acd8c41c777b59aaa68da64ee4e76cb46503684742f6656bd41c1618015a1c5e822143fcdaa5079bd768da8572aef8fcb7a365c715668c5b1deb4e8398beb79ef4c474667a08bbd2c6c0cb747e83fb18600d634c49432999819b331a11169cc094042cb3194a13411c8711792733ac601d2904455234c87469f3c785214236f5765033c09b151302bfc9a34ba4e11c09615eea6aba42227b0cb2640c57c130352ca45d89519d01dfa70e0d00440f6b49d57d4321a3ada52bd06cf28d740123243b61d0033e1f21887e5e4463253c68069ab0f9df6d94bf6590e2c59dbdd4564830cfe27474e4c5411e3910be4b5cbdf40d3413bff0569fcb4e13ae285e47c572bf2811125c00e4a04124323acb85debab78d72538c5f35ff66c1e1890c4422d5e1e4d44d8ad800ef877b74deba09396ed0c3063d893acbe12b035ce99a78605945765c2084815f6cd4df37dcff9d8d86912c9d8a9802a417d35ecdf9aad4559487352a43b9365c28d6847cd8986d8bd5f00e2cd7fe9349bfc7ddfe2ef00c465836cba5cd5f63342f42e80e36ae1f8d54fd2cc30f4ca32a136515cbf9dc91887a9c3601eb820eca1cf20363dc8ca1c5fb5d7a25b9cbfdfc1d1c75c7311ae8c0cdfe2939332e2c0d14a98abdc2d39b396f80555b62e1719df7abcd1ee1858e70d7d7f8fa035040cda9f8ca549d956a70d2c38cc1b7fda07eb21bcb83e8bf3218f9cff78e0d8a18ab7bbd741cc6cca6b8084f3616444284f2caa8ea9040ff9d7820c366d6587f4085af59a088c3589095ebee85c1ae03afd02b2f1b3bb460ab28546fcec47cc9e26fbcecb41ed5d6584d26fca11a55f540c79866032fe2f829212dd8d63f5a6a632b74a34f1263d6fa82a33426eb46638f1c5acf1e389aa11ac3373c5a5555ad335fafebcfd974b1ea27db9a1aeb9c36c5d0e08bd36c2767673a1971f6cd2a15610d14114a026ffaa51d50266ba9024da6fcc656e7390d03eceaa8849a7a833c33628f2002cbc76630a33fbb7228473779e37c48a0f55eca776764a5baccc5d66fbecbb8b3d40891e59b101282609854cdf5eeedafed08130e73fca4947093de10c5126ac055d8c85900f1f39403a108d6075c64a3468533b46518f6194caf411da8be631687cf2bddc675f3bc539d50739c8805705db713f60dee662f11f38c111c7c8d26bf58a3c099dabfd6ce2572502d99eef4da98ea5966f120aeba09178ea32fd41483c92cd1df9d7b850fd733f2916a21f1c92921243572c077ba1253bf15cc8fd6ca8f3e1ad66d8c3183d570b4ee6725e3b205bd4348a63467c6901fd664c018fa7727828a0fa6b86411305305a95e7dea6a0016fea7e9b05a93b76708d771ff05aba228c1b10532b4f5e1e2247d9093475d8b7d7eee2f24a8cfa9ceb88ca6bb65231748d1e4ab49e97eb5a1fd27404cd7d40077ebbe1d0198b7448c50828710daa743490b2508566e1e2640d3e9678f52f34b35ab13898deda4b2468974aae4cae3890c350f11bbecc60ae4bd86dcdf09e25db37ded2eed351393eae17264e4de7b00182cbde82183d059738185035f79b064fdd76b4e86d351ef6ad3212bf7fe474a2c1aa42053a75226260b4d220d8d2e43ae404533695e68bb4bc7e2da8b8d849a3fa29cc9ec537b7aa06d796241d6a21cb529cb52120c5023e2111ff4838efaf972e0c1da86285745839d39b96c9d1aad3ed1e88ccebb2d140c1fada0d88e3373071480cd8a80b1cbdfa048e8fd94b815097ef2c3cd1a899b67c473e31ed9721f8abe3f9b8f0b59f877228cd85bfe359d5e007440cf9a0c514bd63094bcf6f70b0e33bf8b8cd4443291a074c9bc522a8a89fff82bfb2612209d689e523d59e3ab2dbd84d94443e19f5b67edf7bd78b8cbc2ffa1fcdea8634f4f13d1d37679dc7d29248bb866bbd2ba75a4a75a0e2b6dc2c7fc1d6ec89407e6096ee7c4178f4885c8d7b67dff9a287d5b281af03fe14668629f73c132e9a968774ee6e07480a20fd7bfd7a2560f75d3fcda1a31f0ec0510fb7e5999d5d124e61a2e23054408d194af3f81d96dec92c1a40b6e97f08534f2c762821d1f69ee2f6039590932f1f0f198806a2b924147d8532638c2f03970b077264ce13adf439d4b60ca9967474df556b97e84889a28d2ec064e3c9daf4975c21b55937c98b96c070af71ef8ad7de2ba92760ea1bd2ff7766a23bfcba74904d80b3c55c15a42dabc5e796799d8e0bea1627f3ec1ee4068ed33943fb41aee3ed2d26f07182a4444d0f2de34c40d1841835d479915612a4b0740cbb23d35029f9c4f740c6d924937fbfac4657ee5cab6c9b6d90439c97bc4b7b347bf7aba72804d82d178d9a2ad40461bab6da95e4959be1e6998d36b47ccd9231c675e41af89bab581e56fcbd467edf5d9e90349519c42ed499605639d91cc532c4a0f67ac0c3045aa4d916b9a1a2dcafcddb51c286b44eb1a5672207abf6051321e04c62941dd4e6f532795c78227e5e5b1a918ec8f3a1aaf127c5352602e2c64fca3d205b55281b883b7ee4c9a2f07272d87f14388e05c36a91e880b96d33e9871e369672fdd26172ffe3caa9c754058386c7eb982074205997102818a86f589e94a11304f5120a7cc68c547057e17c1e3b893a9655916869101cfeb76884bd34091495e082c62916b0ee11102e84326dd805142bbe5c2a71418b5cc2e8af9b1a56cc0b1ce09af1720c81d3756b6653d2f930d7c8d2e47444dbfe4a2555d2501d983539f93cc9c5c931244f6901498dd04d6b0bcc928bca7bbc4e7cde5060b2e5728977566804932b85ca2e6327c53263ab1d7393ac06a145652c03193de0f690d103e90a49ab23658ed3e044632aa66ed9efecfd5b9f84a4ef236b0a78504e233dd02fd67436cf00a9a8ca87e0012bea18a06ca2ceb6e077ab695bf17672943893a759cc66f64eff828e7afb19356e12336b7486aca699427abaeac252d03cee98223cf9d65e40c7da177870c5315d17730965f92f3e63048a5d18945bc501a9e9a386378fc6bb25c890b0982717a3c536ca2b8814bf504e91fab94e6f196d742079992c29fe101c383df64b02bf03cd0e01a045f6af0449d0e405765f438294f272df5a32e39b9dcc3f2c2af765a0b95cb0ad486b5c434d32dccb0cce77300ffc15e479e88d1490de8f4473e55e95a881ca7451c1a0f4863e3f66cd3ab31013d81b4043943748cca85d6c9d8f5a6fffa148859094f1e16ddbe8ef494f4f694908a11a0682bc2ba0d9036eeb6db7a4eccadc5937d479de50902a9b0fa86c932c0a38a86d963102d0efa34de02a5ef6ba7c841c0085e387e269830fb09f117d89a01781f33f13308d0a2a510fdcc96d3d70a53841c1600884dab20ab63f62edeb7ccfbbe47ff19c0620077c012fbb64168adb4a64670172c729f36439daec00386d4b36898af0ca0250c04e0fc4f6f62f3dce54de5d7def72882d05a8d41931ff801f02b7da7e3976f92440b40e15ac6e08b9c90bca51f053464a956f57c5455336b89db6fa5a704a086a4e44078f7f1c3bf3c209ca1f1cf00949472b66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
