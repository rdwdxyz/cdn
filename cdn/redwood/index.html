<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe334af1315866265806ee6b339531e777fbee0f602e8252ac2d30e4344c6481d4556370c49bc6b00d1b10dfd8ae797b39be81115ce50b715617f86dc61782006b185073dda5cc8606a16c62542fd17749a3047894d54b77946b1c14df5806829b7508db90d51220ed56da154f81ee92c6f2dd941b7845e076ed6aa59c3623a17a1e816e200e6ce49986808673973b7933fcebe6a02fe4b2a766aee32b121bca3d5c752b309176ca31e604e5fd10cbfa0c047aa9e7409016768f41105858c13d37ddced1a2fbdf7e54438cae165a5b9a3f35c5ec421827f277a871eee7a7d2ab92a1a4740fed6a993b22142bb7f037df866e01c87c95d136345f92446a09ee34cad965030c02770bf9c4249f535b1654159ba5d42efc05e16c28d12f53b1c882a7bd9ddf74c4b645724e4f9be0b2380cd575d5767301c4487afc03d7299b0312724677ad0a8cc1356cf73364986377761cec667e34ab58604eab832684d3f323800073975fdb7b07a42c347a8350f53c8efe2f1e6451014d7a587ed5b55501204b304cbb72b558ee45e68554a7759f2e3f7457a6d17debee34bd9e6567776cad4453af9a5f48f922153371e03caa1462b4d7ce25ff2b650e2eca8cfe80004eccea74ae17b4572cdf56871b04c3b800d0fcddeeebe06548d76d5a2d2ec017d0f0b21f68c49919511562967b8c10e7a43170583c708e4b29f725f00eeb0d9ab44ff708f36fc342fe60aec6aa482dedcf7a8baaccc1cf4ef469f2b6a2f5ac400665147e4e9793fcd41074b9cc5cafcb3a9f04d908c3b94c48e8456cf56ce3620c2b0c4e602841659e74bdcc4b3b592dc26d3f49efd0ee32b3af7f784e63449fbe44ef18847650e5f0de03430e0c37ce874a5dfa8da0025c749a2eb74711ce738643274c36dc09cda3b8f04a41c82b423a8fe69f77f3e9c281264edf3b48e6eec966edcc8258b95c2fbf9d7888697e386afbb6aa9a6fd4116f6c37cdea15a5a6194dbfc4e13b3868ac0f2d6d09996e4edc8e67f9f5c4a8e14d25ec824e4858ab2c9f4be0989b1aaed7c4b584edcee8eed4710eb46cf141bfd0330d7a62bbd2dcb9205a04fd85af129f328e2489698578b3c4212d3389193423b70ad6e2117ae5c191570d1e11fc4c4dc0085803c99bbc1d3353e28b424b3107464c238675d0ea800b6e52feedc3bb0ed2b61fa4df3976dde392143138d4845febd7f8a8c74f9bae7847b72c0cf7fc279c3d6863951de6e18a8e9eab155ac9b4f47f1eb0671ca9b820887d721944378db11200eeb7fd948d2416033563ecf4d5c7d47ddc083c2e2a205ec3fbc7efe3b9ed6ad6f9ea6ae72b8ee63ef5c5df670bf6e9072f3ba8b70701e980521888e0bfcfe6275def05c34409961ed63dabbbbbbd19337d290f8cedb2d2e3a1cb43eca031ce421378973e47d8ee11e093f1e5b55953c9332fa10e28a53c21f493e9a7bb44ffe574159ba7653de68053dbbe86fbac41cbc4cdbdd9caef513829eebaac498b38f78a5fbfea351385b40a5716f6599c4e53ecbe34135ae1922211bd774344410daf47aadd33240bceb7b514f1025ed666f33f391912b4505a3280f2522d953fcc331362fad75d4d9654e82e82ab27d70900f3b928dab549e403f24478889c5e8594a1dd2f9025528932a1342c3b66d0c3ae99513f8dd9dd39a6823a187e7991280bbffe444385761af88f777b39822e05730b00c2ec67d42d14287b90445803a4db8bdfd9d640f1fbe527f8446ebb018e5108fb16f4a973e292006183b80eaff1d7e8787dc47d1e4fbc681a71113c626692a4dacf0481f55576fae35e9ac54e662ec55b737205219b05fd8a4ad90093fac79a2466cfed24544b6d563ec76cf217c4628b96d16b2cf260be58c0ced9ffe90fa4928e4acd3a98667757e1064cb4cb3acb4ec126b634a09bf36f5b4b2fc19625530e5377eed0b0053e05dc7f0b196f6d9b148465e45662e7bf208df17853b0622ba21473b0fc5002ff897fa95c581abcee89e29145402efc7c1755c17a2e82fbecfc5d00529706061972f2417a5e421ed5dd8add77b6cec8489d5fc479e01009c39e20ac9eb85231d394d5e17d56f9c0fe6bb460c156034563f4c0476054645d9d7fc42b11668936ae33b646e192f9db1c78e076b4e5613671514500541f8ef384a844ab41ee5d50cfeb34a8deec7bb44817892428b6fe1aab32214755987af8c72bb2a7c4e6e5a35b86f95dc4bed2be61deb7ed87cbb4f13f8994a4f688028a0188d0e48d394ccf5d32fa0a8904f0a8b7199f153326b6aba811afed600ddc3c5b2cf28fc233da014726e3ae2b91d0f5347c6f85e7bba91c00ef68a29c4d7810613f71900e35d7420aebbe0ac5fd0e83235064a794fd779b2aec8e9d9df7f3f52079dab9a3170567f852cb7bcfeba2e3bcbe0525a759ab32c4edc93aadd14ed2b368609d8690f449304a45e780b7006e879fe6afc35d1a43dcc1982f9236bf5a3ce4676b4fb0cc591eeb726ac6fc2cc49d40a11d95c05213ef11cbfc8c476e541e8cf61a8abce391a5440e12e4f7bb0c01f0cc21de429a2f759ec36b08308e6bbdee1a82b273b08caae42c3efc79f11f85b4ef4610f457ee05b29c3f717c5d5ef48b3f75a93544729255a070750b258a61df77e5f98d5a983ec523c7c174a2dd83cbfa040494917ad0709af6340ef0754002dc14a7d3cc704285cc409b38c8c4ce932fa92973b077be8bab10100b45b7974c26181464b6abc82236583955e903120e447c3bbb8341a08afcba270cd561d75aabb55c53f23555e13234b291230a010bde765495d9ac196ace41220575141176d72e5d9a697cf9aba077b872523d5194b853cadf6cdcc208f2592948d7687c8262758d70d08c2e0bf3d0b5f2ff8cfcf91f73c1ee6b1eb8db0b23569868eaf56052f598ec5f0ae2ac8c4c3e8b2a273ef5f60246c46eeec81d4e036e8af7db70e7ef6aeec1ce14f899533ad5bb8eaf0869e739d89322720472bc06a65d8796861928139bcc3a4b4b36374d09b5e37b3b21223e2293b81ee1cbfb49bf86f26bbeb1c46159beea88aabefe5a278b2d27110eb70060f4f3122ae6e0bf19832d0c11dea6fb77e13feddac6e8719d79ea8780cb3c90a50f236053b52b07d6379641cde653384d4a31f98c5b20fcf456002ebb7a3e148fa7e911a262b59917cce7a4198f4d048f4236a9f62b47289b225fa8acf30973aab994f42ef6145b0ba3e84680640fb61751626f6a7250b543531bca01323db053a4a47eaf6da54cc43f77b3cb0f7e82ccaca9d11b9a67078e82a4fe11ff856d2191978b3215ca90b891c50706dba4a79ba8b1d76c69da393fbc455c7e8f725c695a1630d731c07fb3dff1fa10bf163a016798ccc07b828d4eae8cba6ee0f56c308c8e31575a3b53ce6cd50c3a7af0dc4301b5416c2e19fd6e1739574c7655e27704c38bd04cb5d5e0a55920d3ed4cdf45d82b8efcbb7c4506689d54f82f756ba96befa253d7d8b2ec0322ac89d8f47c39c206e36d0344c4e09072a572f24c5e2fd07beca808e56674bf7091c7f335520850ab0680dae744c4b845a8ba2bd8bc6c569166e42dedd52178e4e62db2d0ec220fdbc39d5271fed9d7f971e649d55763427b7eef61f4191ade30b95bb6ffa5bf49838ec125c6a607c4c89f228f677002de5bbcee50a8bbf1be964f63478303f0fc8d04687b6f3c7848261c59ae81d54d1c202d4b1be717a861f8a4a7e2faba04d82a27c137333c75a40e8432670d302f0df8aeb095e01a4cb3ea8d89a55d6c15363465fd696956b9ac82ad772eb5ffc1842be9f9497fe783d612c0252193e5657623f81f62b555e064128d9120dc5f671910ad041fa92885cde69bb70eaa386362dc5d1d7369e2b409c01948a81f40ef2c3aa4b8b5a852979781e08de90cf64571bf6140788be548cef19278dd443cfde5c822102b58c441ed65bdb21987e2e076530ccb8f6ec5320730b48e8922905675e579c4d0d7deaebeda1eb04d6745ec9d9ed7864a13bb9cb2ae8fbaaa0a3c9b36a75e0fb939f2efd7213610f4ed1b3080afdde9a1f9df11335b45d96f935dd5af3b89d761f74f58c6592aad08377bdc4620017b5ca7520e6558160d4335eb588d31c9181fad0931aee5cd33e3a97f54673fc5e764fb3780d4f7e8a57984f2dab478a906538e71636fc100ef78656afbefa4cd3df62cbde340f99174ed483175e4ed6574384ca39224b32c505d20264a2302eeb8614d15faa5b32501d037f1ee409f4379fefc329aff01954fcb147e33f2477b40e03760205916339d8d5e2974b3addecce78a740cf8eccf18324844c4e1baf627c852a76d8f67b090a0a3f76a073095842d128f435014fcdebf072b4f0b456857281cb1bc8ae73ce163d3002b6d9ca3d019bd3ab2cbf4912fc0fe17bdb39fe5d7856936cf19c19d7cb6046cb053acdb6219ed5e5a4b8cccc629f1ff87d30dc11ff459379b6300f3a37d58fc043783540b389177bcdc05573d9b876b8a432df4091e151da1a60f0d8741d52d6bcbfaab2634f000cfc40941fb8873ee13f9ecf554effd28ca886a85e2195e167f0ca5fd2286e4ebaa1b76bd3cb1a66f1f381cffa3fc637627cf0b28b4ef791038f15804f86d91e912911f64c0545ad0d700a28659ec8cf8248a090d1e1cba6d200dc1dc3b47705078d5a203db5b4a2b2c7dde6b2487b385310978dd00be9d59635dd01692a8f274a707233bd0dbf9fe3af9840ac5c229ca24b593f74d4db29ab53391b1d9615eea49884945f3af4488a098145c6946b2e21e1126b76b8dd775c7581530fd171f8da3db98207c0a94a8843d4cf522e0cb069153afe09340d2bdaafa44dad385f831a44edf6616351bd89618a861c935dcf424bed1dd6bc3578abf207d639331b8c12774c36bd42f43e87a995f41ce6d95e26a491180a17faf757637a5f31cf216788dbb623f7a8f8ea51fb27b7adb5d20f9bde8c2efd58ddb80eb8947e3028cf0296ebecb697a0ef8f57ac41edc444b7fb84edabc4ed89ec1b5e92979fa3d1f3a3028121ce7d6b19fb0e51438d2563b050225fd4d7ae85c802e5b5cddb842da248fac8c581a35c0d034f1bc15bed297d3009461b551fbc2632a9403f723dcea959193ff4abd953e723d30c3cf760ff0f5d438d6eb6d9e6fa275e7be8238e089ead90378c5b0c54d80807209fb205fe0dad3a076b171922a95529d73cfdd40cfe2acf15930eabc4898337f4298a559b67c36ec5ff2ac4fa04b3ae936a3eac4156dcfdfa6f659456f499a73aeccfd8235e2af7a26a8a36c7d4b1c63264dab950d66efe3ddd6779ec7c52cc0c1450f41578a5007600f9f0dd1f65ee295d1ed7c239c3773cca0852a981dea00f60c5ac469b2cccd01ec93ff1320cbc49461dff706e318c828f9aa36fb33192ba9a8e2e52e193dce83d97df59819ee21c03847fb98765d97ceb8753e07b74e3987ae43c70cbcd8fddee4ed8ab8c57ee04ce4ba8ccce9d78273d7688d1c7f5645208a850baadac3b1da5fc7568ee9921134e236be79f6de713cebe317555783a884dc582f1e72c04a48ba2d1189793b054f82986e3e65058073cdf86732d18e48a65872089530793323ad3a63c3efc2c697bd68a06ed6976b5cfdbf2708c386e7b2a71b636b49a4ec102d0aeeff317fb8e8109afa83edb981571cd38b3301a2eeb992777bccb7b1fa6c4597e1a9eac4a32df79ba3ef72d51af5afb4ce00b0850058ae57f1c80f59a07ebc304d1ddf39168b26f5eb2a94dbef94560a958cda04cb4ca4b45e0ed3fe8f1d1fe209cb447a497ff7cfce01a80649c2d8fead20ebb381b8eeb9d9c3214ebf45726ab78e75d4b1c54c85aab490b8e1ceb2e7db79594440191f837710abe6f5a434fe740a3202b1ae96fcb0f4994f3b77ed2d7f254a0380f10f904e7577db792a9b642d9910621338f81281a45db32c12006774bee2ea59394171d25ebb207d0675ac23bad74746f2abba8c0fa78228339c28054670afd81df16a559b91b9c207d11e1dff5c49a023cb8cca1c24fe0585bbe0c64763739b72a3eca2029cb2804a4231d99f97dc81a04cf10bbcc4d749f28893de0cbde2b8e4e118bc7325799849378f7a35725cdaea71a0849c02871b73eaac404f309b707840055f98fd74cff8556474bff59efe55cf5568085c536b3170addf828fcd117050a7933a21d7a77d068079877b72182094a0c73d186d30ca1aba3495b8611d4fa2b7c98614e3a92a4c8d209c679e7817b2b4786807672c34ba6411374f8d132ae8970a8fdea4b65d543214cfc47cd6e5ea29440dfced02482e8be55cc81ff67fd65d4020797dee060f5480a9ecc41c79cedd753290f044fa16cc29414d022431b6cb81dcdc23b7b30569eb6193ccbddcfe198f8b117874322a098a6e662b46e5f8ac0cb98c74884b17a70eb82e68e3a7bdd1bbf09a262b55e20aa5f6cc40d9c7031f76430efd60351835ee8756d77404758a331152e97237f5f8adfcec20b7a72161bf76d3d4419e7ceb62a107ddd2dd10015f295adee2ebac2b0710c1fd42ba972f656da1f61224435c0efe5d01b5fa9620c369234e1696449d64ebfa2a036db5c11816624869cfdc33eb2d1940324b3124ff4b646e9193935e4ebd739bccfc48a7ec1c03f1e5ef3fdcd64ae7773d30af2d56d0f65daffb82cc74b60c484ec6af122c15612e282c6a825601f435fafe176f4224cd014ce643d3a48d02f64a33b7a17105fb9c18d392c02ede2f481edc1a47c558329f87a029f5b0ecd41870726a43ff444e99d4837c0acd51851846685bf098e9843e70539292d7bbe216c755cb4b55225ab79c82b8e9e3ee8961aa1eda643fa655a5febf746d39db03e9cc00964dc5a5708723599a4c221a91c5eb8b1b50b9e276ae10f8f2eed100ce92f0cf5bd439a0a11c77d8e5507f9289599f60d823c3ed5f9f5718c55736a197dd960b3e7888fc03c2a57b707a5e84388593585e55e184807ab2831fdc0c0d5e8bf2a81d8cd488b1281deb1dad2961f6cb75de7249a66ddda3a9d476cadcd2f9a8dd8a6855f1d905d9c84b9be56b20d36c56db75ebd215f723c9ab5adc13ddf8aeb3bd1bcfded7b8664b657b2154420aa84af4451fe7c68dc40946b659e95b2396385c3f172a3d377a42db0e1998360e88e34fe4021e4623a305ab2d21197e945bd4dfe52327c8b4b98784b87bc3dd563a042281e75691ff240ebd2eb878f6c3819b8f6f5656fc6e071456aec6514fe49a6ec99f38ad1ad629a1b7b3788357821e1fd8e11d92220b1631df14ff500bba8fa8a0e6938103661a928db4f74af54b7b7914e72f8dd19b57771091af6d3cbfbe2658ded81a36943601e4f886aff358fb003ec75a3d7687f4790654354e8544550f748034112ea7fc97915389d26a10c6a51e8c8579cecc5b80d64a43d338083f79868f32ed0d1f3c2a4932d6b060a9c477f7a9479e7714485739958918fb5ba0f1a49935ac78d1d5b5411942e40819aecba46b606654d8212c0c352511dea99451e12a91db0276f5b24b80f69ee3d6629c9dbaded0afc8645cb4dbdc6d81e0197e61f99df66ff5383435bed8a866679d3084bde8542a465c1eb07f059f543e569ee1ddc2ab1a4e070d6914e53d9328c74736035f65f53b8f87536047178ecf2716434386f29acff4d2be97169fa214237986bc9167ab8df1d1819e5784a332540a07babe748b87f1734f3921acc510e5883323a57373f5d14e2782c34bb0294beb13e17947511a9d577cbb256214df6d7c0f8fe3e60655712624b8790feb5c6ebbb3970a38683ee646585c57a37e102088a6716b0216dfc81d434b49329d5759df6a4b8d26a8f4e9f0bfdc48416d15914449e095d7d7270d0656d371dd59f3ad7272221465150f9c2880631fb090fde95f4dd3dee44cba0ac1331906a20bcd93e5b3d2a37aa9b05569838191e17c351e7338ca69d2f564c538d52849b5d396c6ee37f44cd6daa882852aaf7889001ccda73423e05e958beb2123ab6c069763273b5779a72733f3802d24c91e5dfcc0a743fc2bf151fb83baf44a1175921c4dd5807ba7dec2ea06996cf5c71ef10633b5508dd5f3f59abc6faf6e1771a83bbc88c491bd85aed1942cafad8e8e78f964e5689b68500a2d891a4749f981d647bf8268db8a3a98077cf3942de3d9b4b8db5762f930530cb54c7fe3ec321effc2e011b82d1dde293bc4c3d147cc94e808c2862d378ee7d5eef88f7ea081662561939e827b0c974e7190f282b30a83d04f6f4bb18bbe80300bb06b83524958597509cd725c4bd7ca613e2597881bd1a0cf754aea0472125643640b0db6d302b9edf82e347b0f93487c61404d614c06c409094540af712fe4ab276768bb630a9c87f35d7b7510911c55f1a78a92508516e542ce803cbcd7b3930ac981e0dc55765b45a17606792d4236d7695f50220b5f07d6cfa6ca6bff10f88d36ecabc4e1eeaf2d37a0c9cebbe860275df96eecaf9981a206d942b10427377cff1c15188073394216075e8b48971177101951046387ea95dd009ff6638a892b64e6223b8699184b84a633b3c63847c7f4e15932f6725e0daef3c0d65c4e57825157cd5e4c0d39ee7eb786adb018608fc7913c2e3bccee3f6eee8a4f2d66e9bed1947c8cb6cc828dc9c7017655b88876b1980088b0d7377f95d1edecc90927766914b4eb0bc26171da7553c49268d5e64bb887e556272443b35793edb993db60cd63cbc889a2915bc0d5a9186056de0c37dd3f9f19a01d414f1b420ebc8195d6b797a16e3f0559414015d505d19bd0b688047e9e81b936cde84ed9a05ddbb3aaa323add2ba27b595be6d492f4d9678b238c71aa2db1b47e5a5f69c2828d47108d7aab62f4045758489566190c528333bb95202c056b23d941ef9ae40044cd7a86cbb11bd2fdb38294250b37fa09ea5d706ded69468d303d08b87e1a9613564ac4af31e4a0a0dcb6ea6e2cb5607208411cc5f0aead5f6462dd70e30db19323cab2015ee4517ee5584a823f21c9e69b97a54a0c214f2f2ce88741b6bfa831d8851102e457d55a56819435ab0e4fa7771187126ea9bcb501eab00d1f3a64067956b3770b99b47af1f9ee3f1e8da6a1bf8b4b9662fd4c632036e82725d5b43ebb4364f67402a3e0c92ca86b4e80337e4af0bdde2145c676ebbb3b7fe129a760f1abd571cd4ce4cedbbf1fd4866281ae7ebdc940025702dcb1e1fff11d818ca6b3c412ce03d0230abe80750892c2c4f9dfdc2f541f9d025e21884ed4de4cfd8d7a426e38a1e1d78a175740cfe376f820658013446581f17955b8e02545fb755d827e5856acd3e6dd34bc6fabe603c69c2d7b4c7d5b724e88a0c3babf66c99408aad617182c5e310c8599f73a52d74c77aeb69f88d66da44afaf270b58d0fbba54ab451f204f4ff8e410de66c86be5058fc903b2210b071fadc16bc6e2ec35e8ddedb26d22513be7e55e89b200ce9480d6ffbda01a58b33b7f1ef56470ef3d97eedc14bb4296f1cfa0151af620064fb7706ae05ade4312cddf988fb4e2189efc52e3ba7dd9126691edabd3cdc1f0a3115446e5a94e43d49e520cc76ec985a44ba98b43e849a078261502041f38a830adb9dc8a9a96a3bc9d805cd92a9beeda937c0ba7dab560666550095fdfb123c3c0645343f62cf8483d34a6617ddd3bbf69800abdde4c2e9473f399fc8f0a023b2bc17cb7e349940b1b09abd45d5daf8480eb0d6b4f13653182dd398aa72291c47f592acf81c3609d41daafc09cfa3304ba02ed96a9ea76395e7aa6bbff4b9e6eca137be9d272b3d6f2a58e68b0f6efdb6733ba9a4705a662d856e1c0dd5087a13d86fab416d0147a581e066929fb75d0613682bd0094403e7107bd5401bef365eaf4d825b72fab51fdea792a12503b194d9bb002f5a2c60c007d1b7c5f6d418ce8815278c11c7bc48d05dadf2791468ef2775832a1572ecce831605e39e555510aea36b1a4851125a3785213b4c4f8df63665ed0a177e056f079b57915c709f5c49c2020298e6bbb9914ab19ce546357d4f713b9bdd4e666c1b5bd25079329c80216b19ce39c71bafcc04d739357e1c1551db708afb0691c2fd7318f6d36f8645a5ee2fa4a51936e2ff89c97f43a9da01da74a9e41f9fdb607f21ceb85e8adc374b36227347c3d6309be1e93418cefef0837d1628dd8325b6ea7e6efd9a6c6c64a12bfacfe5cc6839d8713a66b06e21d9a94953e8b728f04ead357851a1409ca9a2566a572bca923be0dd8b072f5ca29e5e58657e610b1a813ff5976bce45a7b007c4edf7230b6c1c67ad6dae4cb0915a248f7b4166673635295adf9afe71fa33862a06d70a01f70baa022402640627418fae30e702a100fc3e87aea263a620b72811b5c423c9cbfa6b09a7fcbf5e760d9a533b157cef2f3356fe55489f812301ffccfcb14f8cfe4d895deab7c3fcba298e0e8f8c36dcc73449bd2e964d8542c0e09385befc2bc1a0d760dd46195f036d9c2eae943c5802ae45ba1b8d0552fc762a772c8cafd777f0b12d580ede87f2f4b005b04abc2eb43dea34bc5e67a8afe96526a355fbca7bf3c01256f07cad2859ff550f204dcce1f78143c3fd3d69ab470d7f055860e1faebf3c24503c76d4057f366cd34cba07bd4cee5fd4dd14c4dedd17e5c272a6d62356a82c778d9eb59c16faff0ded327ad05f8a29be06a0aae6752f51dd3352107783d3339223c4f698f2002f353ad69264e04b8b8537821e158fd02d93123d978f5c8acb2e884f80a14b1479c910eb641d62b8c84b9823a329e11535be1e246df51a8fbe14bce52400b11a262412acee61f8a3dda57aaa88b3b6e0f391199222aeecef49c86dbd2331fefdb876475a4b270b87710df5b3d70b337eadd7a62744cdda6c26f497bd72425af02a9c0bd6626d2a2fd3557fe617b75d701da5d0ab7599a3e95add659fdc7f15c8747a2fce1a9df35702e22d281d05ff652c1d9cbd32934d5e95d6d054bb22cd6ce72b654ddf02ac3744f672765aeb0cb63b9f12a95931cc7943f3476b2c4b429667210ec8cad8ce184ce4e8323490b15a9737abc20132c11cbebefa0be7203cd330384892469a8f9b4e00d62ac10c7c0e519a1c2eb362c66b8dd00e37aa8de877fd4390d9d7e88320536936991fc159d1ad75d22612b346275968ed1658f6a421b71523ffd125c613cc3c22b28eb634a271ea24843ed78f157fdc80a91bcc4eb1ddc4c81aa891f8cc102ee9e0c5f87f493adf44a443fad8ef4a4102535070d0fa0f60096cb123c0cdb3fb37ab23b65ec024f916c70285ddde4377c4637bbe91468451f6bf3865274afe0cfe8d9ec8a23e672bb77de96d642cc83e1cd1b8b4e964e1c9a25585e6a5fc045db665f504ce81c263ffea3ba4859a02282d16b9d113e6fe1f9836def0941d2ecc3919616c452c723f3459faa8ab29f5cb2ee59dcff8f66147fba40b8313fa13af740b242e0d17968bc6adca7ae7fee475d9549d50a056fa8e75757e2035fa1e9c997b501a4ef1ac7895d664a7ede0a595d55f56e65cd691409361aa524adb8a644b86c075e4f325b72ecac207edcf8cfd1095a0c1c42eac5d3278461a912dd20aa89758d1116aaef69229f4512d2f49c5ad5e1f61b222d69a292976c034119a3f0696612b1bce740f9d7c00588d9c2226a67e76af6a5777fc1da1f0e6ea539f6a6278b124066f8c7e112c9ceebd32a7e0b22eab4e5532217aa7b501e3707cbad8c53daf490843aaccb6111c92d1246b20e0f7f2d412aabe6019709ff22b0e7ca9f258b0af29c6dc6fc9112e90657e120a5d3541bbcf4a30df8354be2469063ca6391f21df10cc6cbb79e81d9963895e8fad6d534c9bf73599590ad35ccc2f69f6fbe7c66c51f120eb07d615bb5915d8cbe5b10d8f5e0e0dea62859ebbdc5888701ccbd3ab7620f4670454bc82b876d9a68c815cf662a0587ab281de9d336ded125a4fd353bdf03297620de5676f0771b0384e943f7d58f9cea3e7b41d2e54441d0885922e8e8ae7a1fe2ca170f49379cbf5f6f608546161ded895ded9a60721cbe6283074acfeeda6de34dede14f687bbcaadd79e36bbb4d9fc759f65ebd13bf1376a95fb70a8762d2d2794e111ac21e73222704ccf200e0100bd326a1d3fba204ebc1c490bd5b3c09d6d00334a69bfb6f45fd6108598a0211e5cae039f4447eaff760eae5afa3eb5478fb66bfe444dd77cec5f46d615ed8395376e631a72a14435b5482f43f3319d318770415f54800bf1b117176081177966baa043919b3d107b75b41863fc7c0f96be3a1c5e14c9370eb18a10a01df346130b902b73406b54b8e456277b662eaa988ab24721e9110c5fd9e051945d0be8a7b2d9d346c04edb7aacfb70b19d2da8ba620805e86c672cb8dacb9620eeda259eab8a353a5d39ba74d3d2325e4c4763b98da2423e9d6a9f78b7390d28d4c8d1e291a11ad20a0793a66c91bb9eeabf1d48a0e4cdcb68d72b5065e09df2aa48545340bbd40b7719d11486983e00163f64093c27bf25234045008ec5ac8e6c79c0b32e51460d8b955e3ed61e95aa5f78b641ecd513c0d47ebfafd6b1b939226daea407787b1f9040cbd91fea224940ef14a9e31503618329749d30c88fa21cfb7ca87222d41e1f7c674d9287e64d6854d5065ccd06896cc851010dfcde02368a215317632fa05421553f2f2473df9d880410a34c9ef4a9b32da4d6afae760834157be3d3bea5f750152d2a69de6f93e37608696702ac298b75420de0d8263ba5b22d200b136b3556d72252ec8e2c5fe1eadec6a56031207dde0f9286345c90b85d82416247d8ba66513e68928d9ca79315cedf2b61123b59ae31d3fe7de206d76c5fd491c47fb169325cb16d008533e5b6caa3f76953fea77d7cc01feda1d2086514d01492d16061a1094a66a630eab69519bcc3fa80e5d2cb604de67c7c2245c768e31068650304ba09a759fbc431d88b2d623277129b4f9bf3aa3501aeaad5d0a60bf5a22783a7ec277761e8f18e55ed7b1b6f53bcef1cce4f9c67b49aa4ff0fa530c6414cccbbf1894ff6aeb3903f265d6fd1475025ea11f71687b7c0e8b3ea3a14ad850a480cb354d6af2efac43b9cef8a1b8d171fb3fd81575c8bfaf712c1481a1a5397e99b9fd79d2b4eaeee7f25642372b35c00dc0aaff5fcc8aecb2d3d75b8cc1c787b5af6ff214f193633d6aaef2e7ea2b198ab627d0ced7b78ba1b63a3f7f741c810523850999f9cdf238c109c6e7d16d62ca1d6e00a7b128db08693e0b9f79069fbaa321c8255203c60968afb21ca06550de17ee8871f06db2bd53b803149105640339f5adb864aa0c15cf483ed6cc991d71d85045df2449c53398a774e3e8ac03b0195610fbc63f57bb792148e02d6bf60911ee54cd321fab20c7db3027ae550c3561669c6faa4f75a978110c7eaf535454a17501d85fe46c2fc458fda5e6f749ad41d330261499ae9c37a72e1eeb6ad8811901b570ef0210a3224ea31e257fc334a79212554ee919ff73696e8704c676374647151f1d6db5f3d8c9eee91361a0084175fcaefda527c170be32d7ca03ee2a3f28a62d6629008667baebe913211d39f426360b1cd955ba9e78ac5f0d723bf2d131de102ee580f106e0af2e7b103ee9d7795894d6f3d027857de6615d26da3552b9137f1622f1d7d60171926c3b1f058701d4da9107c02c18d7a7fda42d00b0d4553701b1b96d4ed477972cbe0b58833d062d8ff4a0d730aef82f31368f8133fef58c463cc1038c0d7dc6794f6b5cbcbc15e3852cf1d859853d01d671aaddce12e5f4707cc5271e2185dc5ce139ce2386386450c1c463a6f155c3f47cb899986f920d4f18208163e7c69b8cdece73e0fbe765fff134202bc64bb11f05da66b50da3ecca349bcafb36992f3042be7801db28b56f5017697b7478cc15b6720a2be7c35487db1da9e8bf5c4c04a21746d570a59c8482e8e7f28d9aff1d408e51b65397cd07dac27e929895f7d87a7110f3f0a297b42e2054ed9b41e0b6ba6ddc2de4ddc1c6bbaa7526a52cfe0175c17b61468232590da324e499072e0ccde737478d1652f66b51031b91693b062ee75234ac05b6b826964171febe2bd54f248d964d2c742162248563c54391ba06c9c74de00be47954e266884fc8c83a80229dfefe0e9423ab1f51c46c4e2a776fa6b81505a1404e978e05338c96d81a8eac86a6d5f6d6e8181fc70597b0f53e0aa6a763876c9edf83707ffa6e79995aea9329020e7f56da41bcdb98d7ca396c182c9c515c31ded41c075af1f19460ce44561c4c3daceef81aec92e362514101e4304ca3bbfe2973b9315c37e2a18839a92c533b37a4f5709be8050d6a1505d9f24b4c387acd3ae7d80ffd518d18155a60b04fff58fc26f88eab845a1def828e41b4bc4d3a09d0a6d846ac111c52d43aa896c4ac0dd460fc38d52550cfd4c7b2856349455ecf177e63bf5a7d22f535be4fdddee41f4172bb5876a7d9a2b6936a38cc6093f9d615dec15c7be32f9ad4d4769898817711af3e4808a88481e29bf7ba4822b8288b249e5af13c4b9587d2bf579c5ac860b00068653a37cae101ec1936e8dcec81e7fb7eedd78c5b2413f1135541794ca1955e34193feef5a71c30fd76b4039089bc9c577f956c2b22e4870731dd0109cc99896feff12897ced0af73b94d3c4781d75703085dceb389d9927c676834ef68238fdf703f3422338d0410fc333f56b13bb236d94e66c6939f29d3d7712cdedc52337b0b9239addfaf9e040162e5eefa6df49c18ca7386eb13bf714ba91ed0e7f6e47498c58fe8c4b81c657330053ec059460462356b174b79a8318c9ddb4b4d00a62ebc0f83a040994193cee37078ee7b8dad998f11b6ef68c1743ba1f90319169d2965e1c842a96508c545b0aadc5922960c86e8a8a4116640b495d9f76a7a17272b2e3a7fa256a7b5800a7897775a96671a7532e79ac703a2a6b63ad96ab5debbfc73f7c157775b591165950cbc05b9ede9427e996077116b3eae78b155082e5203f5fc3e12581630011bc473cef3d4d6191c209fc13754cd662c1f85717413de87a8ad86354796188141dc18b207d2a68b7ee91c6ecd741ec062c1c8860d37c80e80ed1e1804bb8fb714d75017877637e4b3ecf940b25ca2406c221e33f4848ff9bd5efd20d65e43759221cebb054452e37c7a3e6cb931606603db7cff1e0600bbb8858f2d2161818ebdc0a87f1f1d78c28252fe1ef5b7d92db29ed172b76ffdb96f8ef2d541d44c42ff214d0f5f4741a4cbd93896552f8840cd6935c8abbca0c595bbc8eb88f82cc2ca9db498cb2fd9fac4d079cc7fe6cf0e518cea290c3ac039921a1eb81f54bdad5699dd24c5579843ffa2b4228692f229dc2f30dba2491f7b9a7b059f5e9e9559c49d5d8141ffd2fe8bb7a203f0a50cac9efe16a3d48662e01389a61167c7e0960c8cb1efaa4ab88318759ebc6fbbdc26e35aefa692a8948728f58fe81d6ef59a006465c6dba1a6c77c27b43c7cee94e607ae2257ce08b0067634c615d5ac0a27fd31d90eec077482c552afb765f26695d22f4ae27f20d2cf9c929ea298b27b00b25f2d8c93615cf884ffe6412d1d5014848263046a788cca693de6aebd41d3eb10570162d552c666057e024f21f6b109fa64b6018649009d99cfb181b323f7959363f324c6cec3b49af8c7efb1f4cd0d90b65e4241f191377b336ffdadaaa955f2244637cd30b92fd07ee6aaef649e1d39fef8c7329227e5c4b2ce443ec2395f3a46711907825390fce4290e979752d16bf363254e01d75e2170e69e8b75d9271138c40086f7368b806e7822505a438e124d202375176ccf03c1ccac78fa374f5b48060b7e02dcb925d3e9ca8dad8260d1d58c5cb9270749422f2cd10ce0090e4e6ac2d56343a788d36fb89ed82257f56857182c29fdee8969d2fa7cac7a9c04c35f1fc51f9da5520659385992f2917ae8a33077ca603d4e8ac6780aaba4cd3f8bc81d5c7dc7fb7c057668f9104c70ccb3cce50f38f5bacc2044ad87722378f6d58a4977d38584cd611a8f9d3675db495e40c2b99c31220a76e7b530f9230ce76cf7c388f8b2aac90b2b3b109c48a222a24139ef1de5876d0976354f93323ae2fef7a3a533d5eb011b846c10da95eb41ae5de4896b6f3e8ccd19b6a3eb8ba404515e9ab5d0b84e3004f0d8ce2a22d199e5a7c826194595ecaa9279b4817c5e10c26d8c885511515dfdfa51e1a97fcc0bc7462eb8a57e0dd95ccdda50c481483d693c0bc36d4c901b30945090961e3eaafbaea1f1967a160f88f1722353c3ca3c0ea1c6909f9899cf9781d98d23d2e270cd80d95ec6e59998f856852a7fc7a653af2e7776e354308f00ad7a4a51df0195790b6e54ed2c34860a1f144a1dee01f5a0f555f7f4f09877d14923fd65149fbcd691345af9238130ea97371a69ffed362402a3d10260f110e1b3cfdc4fc89eca5a2bda637ccc4c12b82ab3651036dcb1113c546ad7d2d0b3c57b38d819c10bdffe33e9005d8a3d219752915e3b832530db169a09e89c3ff920b7253a64f77ad7fafd54d7cb0a5211992af78fd3121d66490dc93c6568d9118f715021fa3f49ba6410418c20483ae728f53026b3ea7a1cbd3e8a59316b32595293422c1df60ef58a68eb78b1a25b1ec21fdbfa8d79facb01779677e246f465eba5e0c57a89f7d4eafcd7c34646aed6a3c2122836b224e92356311dfa1a1773d66a9470e3078c5e383a5b54eec84db01d48c8099067b60f1ecb195fc7825f60618d86d0b8a5f3c5349ba94fb5a05a9d174b817ae132582440d6f0f538d4a37fd9fef8f3493124af7f05f8778e95939bd1cd0aaece72b1431496bbeda921f74afe0d84b1e41aa44a5bf2ba32bc4afb590b82fb89550decb8fefe93c1ed7fccc89dddc398d4a451dd9971a03faaaa00abb1f10ac0cba6e6e628299a4ccf672591bccf4fda937b50dce8fce756b422a1cecb458bb9e666895c6366dfdc0feb06641305e18dc30b42fb1a42a9ba569c277f7f959e0d7cd258292588c8ecc79d3d49258bcacc868cf77a46801584828e60a0cfe0693b9fd8191d4395b4ebb3fec2441ebe1ebc435f9b69b2d174d2d70c2a2b3c485ebe8c2c71c297fa837e63d58e4e584e8927bb28f30bd8cd5ddbd1a527f13c5b905a96967e3dba2434f3b5cc3cc5a0c5c38533cec8ab263f50f21ac4ef06adc81d7fb2873d9e38fcb12343eddd04f1f32161130c328864d35efe8caebc4b4e1b751247fdc8b521f0781278b28b1af02675f1e3606d809a6500f47201956db544348d5e38417b16bfc17ee4cfb3ca8a86c290a7c34d372631b910950ea7b67e7208303ce9fbea2a63529e291851abb0067164ef910d50ace0477bd04f09ecc66e5a8597e88884ee15432fe11aa2b2de27d505a7d4a4fb5eba0c85ffef3ea611e3366bd84f800e616257ce179e07fd280d41806c27aba338ea4981648de5b17b9f1d4b6c566d043e94bb77d9bc218da387a058e74931e6b715edc7f6d9b8e422795c5ef45c23a48eb2bd7834c3cf9915b56da3ea6068b85b144d4dc2d5a006e2a4289110b1c2daf2b2bbc0b1d690d1dee1e2a7c100a15e27989dc0a0599d81ccf63776a79edd6e43637bb750793b956fae0e22cf18e155b17ff16f0792e808535a34e4f7cd62e91a1e180fd072ef04943aa31cdaf512a6c6ba9354338e1bb3d88657586213a80043da22524b2c74f5b0dbd35d997a2cdc9f9a632d5efcc11e671dc970640bdf4854f835555b76b58ccfa67cd639cd7b9a8b97c7b20e8e65c61121bc84fa757b4d2cff29dbb19ed15a874488924ad017189ab31f61be3dd13c1c3ec6c24b811314a8d4361573a743e89aa11d124148de944cf26c97fabba44b05560cd3a870fffc43748d95d05ea02134fe7879f3b4df62a0121937710be6fcf11501df68e1ae34ddc12b18c51a828eaa800239833a43ea8dde5e2985a367aef5287409cdb5c5a34472f1cb4aa4e16fcf3571146eb8e6f9fee813d943bb96bfd7bc7e9c59c1578f29ae42487ce0d636d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
