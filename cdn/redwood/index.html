<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"659798a6ec67bc0a994bfd4e4b4d441743f9e4cce270444b8cdf4f7137e6c1d4318f0f95dd1d683e34a81626fd325b08cd22abdd65b2f437497b9b3fa55f151e05e3f4ddf240ca1ee80abb466b84adb436121ee6d2f1fab199cb08676fe55bf2d3c65f5c740e98c68e36465b981416304170069f35d91d26c47efb523473f6ee38d1bbe0ede3b517b7347474dfb5d409a2f559e4ba789d2220a1ff9c44eab95ff7c542470bdde83466a503df9df60ad890f6c73e188960860f67328fd0b105c1175cf4f57c6f00ad9b2ac45cab780923ff8c460e79cee938f026ac435dda6b9af891a91aac685f2be32d4f2a1a074d44f08546976fe8d544d9356e11a07729701e236a24b9f7e7d3781bbd9b4f02ebd2cce64cc72e52b41767c3465bafa1dcb93e3a5d751a0010c8e9d13133b13091695e29691f95422c68b9649e5ffeec125539e48587e88f839b863a040c5fc7a1155c6392c1c840582af93612eec696d8c4f2a7d07fcf38a158da79b6ce030ff499a107d997691f7594bde978167425d16a58375e485ad3fc7ddafc226bb05eb92262121d93c91424e4f2d9c30e174ee40e5a890c709528d1d72104953ac6af5964fdc5ac03e26bcd05712f306457c75e8ee047c0b66d739778ad17ba9baa49dda55e94b8726aa4c8a22aaffbddbe934830afe9f47e77fe8b4dcf0867dde834eb7de89484d55be2e7771dc9df78b22b66dd56d21b5b5430a405201f6e580909797bf5f016d049b4d77806411d090f96c95ab606ef31400f45b42c07378ed8f6cf7418b7825ed7d060a252cd758343ae6d0a366e804dc9f9dcf350937694c6fe3d836f19208498c647128a58daf240d4efed194b1f70e3329c2cbac1dca91395f95c43e85280fe12fc48b6b277f306761becd9c2f84731ce8ccbf5d6ddbd8d6fa44b3d9d9462d00e1a4a75ae49df49e1eef256bbaafb48ace494b8274216886c7fa5e046c75423f74131aa57b33f2394520014a57bbe58d95763bf78b726348f10b908495173925937321777807a4f0c55362cc88a21b6904d13d73dfdfb36983cdf3feb72a102d52110b45ee8e60161b07add0caaa335fbab09db544e3f1aaa7518e2c74ab2e8c71214af7613bddf66f297cd8635ac42ab072afdbea4f96eb63a1a80a2873e880b988bca8e3c59a5125aefa98db8ffcd7d7f4006c024dc170402dd400c8d06ca78da5deb3bca06672684eb47d51c6a63db274c85644e17696263ad70c9a6ae553de10696e2ce70929c24a55f9e908552fef75f5e63d660ae8554a0bc848a4c9aa73b2c49c932f8e2f66e54d2277bb16c7efe6cac9809348189b3aaf568fad79fc85c479d955412dc8a330809aaef6a93c03ac35214c11b3dfc2a0d1cb9854e8483a4f37969f521ad45f18eb4fc32a1f653160a094c73451b1a3026687bca50ed895bbfbf808ac57bebdbbe25efc78ff83c14c98bcaf2614dff8a83663448593e88d53459fc7741465f393807e8de77367f795c3aa5cdb58071851ae796383abf89610bf9f84f7b143c2047bf1daee97a547ba69418904fe642625dc1feb043023674830f9447a3ff01879f13d3945da6774853356e5ca7f9b0f1e4a5758e13c7bb0ec03cf18f6aad755f6e9436da62f2df559a39f0580e44f60725c1800a03d90c331b77225f1c3327aacc92e0c801e6746d9dd4ce74a5d6dbfa20352b5a99693acde75a6fce0a0d03572184ff9fa080b584110ba9ae986da7b0d9f60fc3849d07a4a9abab996a709e2260d932d428f28f50490d5a6b1121c895e25daec437fdbe04b1aa893e25f78d057a7b1499863ceac3bca1796d3d33a36e05ed4c3187d1b1d0b3cf26ab3c01d5975a1e529ec23649cfc907114e061d7ffc0eda5ea4709dc31c065bb7153c6411b5921f1ec9c5cb40db8fa40c5dac8a173b63b2f2e9771d8b6c42947a09f93ce0f6e8924fd8186a0ad3cddaff5cae38f42ce5bcc9b1de4c8b49b6783f4e3687def70fdc0d60e70d13a9b7c863a0103993df66c10cbba7f8983cc1c47d7e61fe38fe8ad41bc8f1c8e0dde869af6f8a69568ae8ef097a5c8e0a22d28781c332486b55a116560f3e65b38e1ca7ea0df0e02585675002843e1b7868c6fd8d1c21c5acc965590be18effe4d0fc03fad206a264ff63913c518ac9ddb130954fcee33876de9b975f75e9c66b1746eff990e21ce3ea34a58e5aea037fe9b495ab7a52d584babb43ae91534d04dc22753ac1b9102cc34911841bd43972ad9fc943313be70688537b91154ff5246002989790deda9d00ab5ee47a8858f83dba0e55fcc377e092e010f6159c5fc799d84b6e18443c03be704e7f5255396ce86638488b3706f0256055ff42894442cbb3f6efc87e90b14c72d621bc604705b5ecfd9b60030146137ad4a5695d7d4f4499c1526f03ac1c53d6b17a062c6512643e81c60635900b384b62378175e15eecdec2694dff4b87a2b2cfaed94829691b83e8ad84c946e75885d49568bbae9f91ba9bffdc694933fbe249a0b1d08ca7bc8ba4f4a27e3170e4d17b8f912265db99d9a04d63db15b08b8997f46c241f96cc8ac37dfc29d28b98a6b47f620852ed9a8ffb3d8a72ee770ee649684216789c21a2ed929143c457e02a366c1a2cabc21178ca15675be986f2e7a644ca10c002b01cdf63e3fb15d92531d2c45e349aca182b5be0d8bb56db9a2d44bea2cdf4357ebcd75d12ce6583762883c69448829da95cfabbab96a794dab18d4a3fba1a995f37c18da5935e0a0d3356eb6d8789ef06d12c9c5fca7efb21774476875a6e4b838dbfd89b13417a800b1f04b89f6a059d2fb343602240828d355ac853ead7654afcf735e8438172e851709155b6458dfb5501103fa027a216b700d1c6f011c45ac3fc125ae09cf840d2fb436e1ddaca81cd186d47609d749f444b12bea28586a96ebe66aa538d72095cda286751a96424f0ea1b1c6db022a69114614d9f33a71c3b3991b16919afb92570f66f5486413d5ac8a2e11bea81cfc8e40ee04c425b8b1acd11ed65d8b1ec7a54a1074d892bb02e391bee65fd62640b0cca3b3769a4bcfdd54349940393ccf4cefede28aa59359a97d95fa5b8511a9bd2cfce51755024617344671adfe240ca22b9899196af646faba7cbed6763e4912f43815c1dd9d12e34a52419e0f4fb42c41761b79ae0686768dee5ed2975a901261ace00f2d499655d201d8bea5a7a6a86a9d81e1b1b2d575a1f4311237accb890a21690ee9256672e9313bf82d8424426992666102ac112785ceb91504fec7b68ed4457dffa44903a423504f8557a7237f484c7497a54021ff440397c31b045fe783c6f69c953cc8118b15d61b5adedfd35cef23baa56e548bf266962d14413ee3bbc805cf38654efae8fd097d7e1d858b8bea7dfa5cbc453da3d91e47fd5755cb01f7c09b94ccbc37160fedf51df6d13eec0073fec3724b3411736b68bde660d628fbf3fdc0f27b244058b3c54ea6219b72717821998489d6df10bcffd22270dcca19bcc740fef0376dacbebb255213b0a73163caeede0718bbd3ee9d98474e1a3cfa5f77476fe757cdb48abc4cd33a57a5fe2a4d87b164f76d4c69adadc81561a0cb33657e355074c555265a08c99386307e96ec25f221549e1c0c71532e4a3336d98868a7baee1553abcd76e5b50129f2cd56a99bace5a172cf5e7615e546d6d6ab3c2b512a8cb7dc04e7350ea8149a5e12afbf944ddfbc1576aa33752ddaee7585aaf6a69edb239e03953b481b3a253245cdc1a552e172e6f393d64f08e21e751aae992c621068ea1f4eeb5d27e44f51772df3935691daa876c8fe50b93e19f83048b6399c9f6943e6c9382b0124c592e36d9269982e0c1b480ba0ddfb303dfc231e2e4e67b3df5fe074ae303fb53aa4a25db423a815f99708357b6c07f280f6deba0ddadefd4dde248b4cefba42534cc2d573590465efb88bae72ae239d9d1d3f1bb9e3be13070c1356c5140f1b62a1d64fa65e6950560ee3db075afb3bc69513f3460b9f22c33c4252b42741dca5163bc2dc7a1d030c6cfa08b54cd10e25c944cb09f1108c4c2185aa6fc8908cce6ede330d4b6b727022a589341bcc79bd7a11e607bd7c08aab6e9864ff5f37f83dfebae7f932747dccb75e4492cbbf12671f865db69a58969f480a9f7e4b2f713e686414791cdc6d26695e4a92576101bbb9a2628b6f3b0812697df99ea09cea5e021b4e00d9585fee8f2bc832672d4927f1be399951bf8368171d534305b43a136ed8b2fb24f87c9e2d05921c337a073cdc0f3080f05fb73ac4c9c36509872d4838915f2cfd942f1ef782e8f93441f143bfc74e80adf66999dc373c74185c91a4201fe43a597880cd8a3b1097137659ce39f2422db4a32ec0e20124ee7969353371cacb11ddcf265c72079edcf2716a587b39d252b472a4962e09c55b1cca875fbed1f6cf75bf621b15208d0b0fd84fe5c65034e664cd36785846a7a6149e0ba7cce0271ad201215cde458502af2fb18160a5725e2ce5c57e8a22be40b96e9107b01b270c25b4658cfb3b413137fbb0a97d0df650dac1b4070fb46dc9794cd7a49ab88c45c861862daf8e519a7d3dfdb57ff025dac2637d21291492e8927d6e074585593ced0cf9c8123e8d079136aebcc8c87e7ba91d630a5c603a827e5f81fc607342a62e963d4f32f35805a3b79d6205100f6466d44400a2c6202dc52abece9e31bedb4a5b746d59a0ce67084f6ad6c1167d989f04b4a0e651c776a2979820b69b377137440099eaef55076616f3a77c78e785fda1159891981d9aa048e386cec50dc77eb8e88ba0690d12cf8ee501fb6035de30257a6bfdb5e9615914ad9c1ee6a6ddf03f4af060558f5db4cd599cd8b7db94b1aace59bf79497bb8f03171d622a84e5e4209e0a0325e71dc8f7094d3af14d8e51e6ff2f8ae3aa02c2893a17442c4d56c55152ca3069abe32da8c1d73d484dbe834bd1e15f95467b50f2b72052dfe6501c3b56ece646816e91d269b598901b399c64333d91316a8ee7b2f8f63604720dafdb9c047eb8448257f7bb7b1241c93f99d47dd10e6062d937b2a1a15cd08a2be7ef156ccf23b72d13891ade741c3b3ceeafc8d7b4ce175e79686f0761697b4542fbcea2f2a996b4217d28bd04e480c3fe98867b55ef28c8adbb964ba318ae2df145fcd167e1f69adf3b44dc773b12034862a5bca53a269c0476d70fe1bbc6b8f29b2a802ac88a1932ea274fb9a8dd666f0a7ce7afed978e71099cfdb67c5e6b7b5d5c66c08a2da53d15bfce7cb1000444869353b1ecf31b1170394844a500833071d6df28f294e91c01986a68fd3f51d88adffab896007e5b370a51a55590d1677cfa5c6ef06f4b2bf0f86482291125466a8b89bd4255bb202e7c0f8b80268b07636e20f282aad4677025cd2f9971896efa7a73372cf1c7741dee7098bedbe10a256ebbaba2f8113bedcbb40a672f49f88eb3f90910a54ae647b7ffaf9ec954c19089bb98720bdbbe7cb7ee7d38a0c3c7c2d137c128a320df3c849e7abdbefcb063e2160e1d9a85957dcecce5925fe6709338aaf51fc316ae965288974ff0ce4df5c1c94867d4f3b75f5a4141df7d2b81a862712b40201ffcb7a04d3b033dcfc9aeecc452e4b92f3244804d4af9f55a089c8dda3f9d7a32bfb517f4d19f510f7a8f5a2feea69e964ee5a13dc279a27f8ab7a853758975fc5a57f8be6100e48ced0d41d58697e5938e70b576448e495189c7e0a8dfbdea04e38271a623607b093825aaa725a365d157f2343f62ec3e8e6f7923107626622d8e4c8a438bdab64461ae1f837ede768ff08af4244b9e3c78a1df634285903fa7e2964be8e44082e21b8adcdbc2fc97e0d859c5abac24b5d74d50c1beb36974db0f1a1f7822f493526799318db6b1b01771a4eb3d884143cfd656a2a95c9f09daec790b13b2c43c2dc46b4d930ade664e482f28ab909b0bf9ec0b59f99d940332da76260a207f475f3394c709551b21bf0a5295c34db8bbae0aaa6f5413c1de735d93e3d7a0215f211608896112be4ff349e23833f27b49b9669ed5deff55f129b5ef8c67a10347a89189ab00d85d467745ef36d491d255e6d5d2405cb31dd6d5d2eab58588dcb2da382d6f41d6eca3482c54b0c63daebb464874704cc00801cef89e2735a531a578962899f720301cce5755171c119252363fa51f544d1b89b2cae3bf5c6d853687a4f871dc36dd163e19e1cdb81e4583618298184016a85b2d9664d62d44b664d85980d336a0342f3ad7d7feab8bbb7b96eee72c6b6286a87550b0e45ed7a7215798644d76c7be0b2d9dc9326d54634238a24e8e3ed0936bb75a6e4929ecca768054823ce3cddc174b9979c9c92dcadd481c394f1eece9ce3790f36febec820ca87373c7d62bece66f868616595e6d089a5c8d270bf89ddfcc2a8597240771906c0621451d5b904b9c6613b577879d4c4ca4c0355d79f800e9e431c2d47d5a8543e750d5646a4e9ace0fee3bd8820995d163015fc5200b668ec80a0c6edb818e6e4439084b5f2f4685bb13cad1ec893973dc008d6a8d444bd69f20c3f0d088b14def39b54b3ee3416722d04f9b4b148b792182e170cff4d02d87de317425c1549ed874960077b39f1251ef5cbed47d63113d756862675c9c398f64c7ba7861a8aa35736a58994c966b8dac9fa9874f696dc4f855c8b9608d463f80aca27af79563f4f709fd4178974e2e7c4b44a021e59b342a65fc3ef58ee3f6662ed13bb895d61bcc59bdf30f15fa21469acb38f2b7163544741a266f504a64c554ccffc711517a697a013a70c863f92754558eb75b5459c61f7061f824a64ea3086ef77f9b5d6ad69fe297feee36e6c02c2dd5103c02ef6c3da2d9901e7633e65949fe49d91f01fbfc089e48f2db3ae390d0ca1c481672c637ce0b6538f28dacdba38612d216e8d8d0774d49997af29888f57b406cb62cb2f8ff8e94e5d8bc9b1457308d22a9e45df0e1f4e43e92ae4599329a088616e398ecd056f23492aa5d303c06548d6f68697e1114215c5774bb752ef9f2d68604fb48ccb6820d3ec590258ef9865af8edfe70f740b5f24c42a50e1d09889a25a7577a99fd5bd8762f900b76934fca65ac306bb18c0c746310d6ec033c3cf695ff465973565c41f2e372c7bf0d49c5591b7400033b9f317165c906b497d986444e536b36d9839e6fb2620a8b200356c6989a4cf76e4d6aedf5140b2be03b38fd4322feede233874372ffb7b696065f9302b8f035f91e91af2c49a7485ef6bc3b564a6f005967a4348fd180898a1125e0f85abd741eacf779d1655099ded4e7e38bf4b1d4bc950dfb7933d5240c9f8c4a229fcf5537a31768c21f4c5a4e215e853f37b2943d940e540b8796c218138a9b01f8496bba2a8dab306e53469e7407a4a8a8bbf7234ca8d980c18f503a9b4fcf5f0ce7fb8b92e4ae7454f9e0d700c0bcac88895266cee1a4abe3e15547ddf3d89c8bd24027362cf226c4935a4b0729c97847b750f7bbda5cc1002e7e547b73c2cd74d1e54539bd2fa7817c047bfcc5b8b265f8fa605be94f925ae14dd1a2220a47c16c5b1fa8846b0789db3a153b6ca984a731312bcab8dc90e4eb8462fcce04458b1b988a464170886924fcf1b1504d89374ada02422925146e2394ea17666d5c22d89713d6407fe0b89d6295e47f746d5d81a2c607618c0dc8421c1a981657ab37e12da26b597162d8b1b8d10b463a820ae882354c0d3c5f0b35e23da7da8e12d2ef50add56d12681e9f4a2da846518038aed681c6906d56d6a61ddcc377de78c373e9a5d4ce21c30e816af083aa4ade646b7a5d56b6235c89b0d8046f31e3c516dc6b4e73f87dcfb69d3cc90b674c98e68cdc9d671c2220a854d74d21788214ec5726b38c5351b228d2c29e5e6c99f361c2bf181d0cf4c07ae84f4211d1e5011768c97a52353bfb7e9bec8ab59192084ef7c7cbc16aba40d1f9ee7dc90fb7e33146f79ca0167747f99177b938c98f1d6b5081ac9f4584c301fdeb8b9482175fad2e092063850897bff7da518ca2e20d87be5e69b515a45fd6a6bf6d8810fcced2a3557fe2338846bdd28155efbcb1da9d7ef33bef493209699a4e24f1272d95a36866f1d09713a3ae838b95af7bbc5b3fcd53031083f1a651420894c3bb3023f8b8c36f4062a9fed903a2e53ae8457efa2b1a4720f17088a6c26bc510d868f31a8ac3814b91a62358cb474b8347a33d241074ceea7026b318b108e1591621ba81f323b16d2c09c16d6cae87e7ee7ce2c72faa87f63b3c5c238790aebee0a2f501de324e2928f437088f055aeb69fbdad6be2d2eddef2f1f0a5e4fcf550b63c2fb5f377ed0cc963a931088920fdfb718ae0fb46287ce1e18a5fb84c0ada23519df85ee0f66f155ed74914cfe155c4a9486d1122c2ed8648795d5ca0295ae863046dfb5aabfa63bfb92df9cce24d3acc49685de2c1748072c314ad73201059f0239e9dbf9d1f92742ca2faba086d77d7ed2b7c852810534afb275289e5630713e5575ec403ef2df00270843e53b2d87fd9857af9a5998ef27a7b9a083687857f59c65963dfebfa06f629906fcf09fb7bc1a1cc0177f6fefcf152e614b173821e0b6835bd6223ab45a1e9a9b8d843cdac10084de19963d5c84179f2b7e4a20234fb080c8114ea96faa73f0b363798db8b2c99cf1596fb0339b1d943d0a85c52bf90848ebd0351e7b0c786ae203f3825f086c0d436e1f3c87a2df3e8caff06c6a1db50e1f4ad7a87954d138f45916bb711fcb7185fb887ed4c20d79070394b16fabb36726aee9e1b5d677d83a74e0a53a62910b4d5cc4775b0c7d0b44e1bc7f72a95a95db69369a7b3a95cb63f801d268e0d9600d3ab009ace9ed308ee6b8ee960666a7ad1e961545f368f8736033cccbab11fb41ae3af217dc4af678c3ff6f94942c8d431bc97a4e8556def04a61c16b0fafb164205e9902f6e9cd3a0bfa1337f11e89919a717486c414db10d67a880ccbe04f3815fed7992141b4c2af04c172d6a2f67411c3cd7bff1a64543063e357783910a16564c501fa2f27c68f300b1d45e0b703fe620fe5ae85246172b2e23f68ced2d2cb19d0043afeea8270cd39aa7caa831f98824ab69e68c040e45aba52f5053190f97110ff5926b4b983d2cff06f5e7b5e84a2ccb942d8e1ff1b06d2d223c50f55845b4e516385560ee3f1725abddea22c642a28da2b68130fce4e8c281caf081c96ab1ac0ce2cd34dafbc2e1fde8e9320eaf12d50e2cb9ed8b3904fe7769cbeb1ace64e94740affd55f854066ca7e96be0c05565627e5fd00ce2a9b62e08d0f2a9661171f22cf323610f6de166ea8464543a4397a923086c8a4e841b06a6534f36058034030bc3c72ed16cb3eb9f9693ccf7f32ca156cf6a73762562423ec11e0a04f606b676b4f84a2d0816fadf60c9da90e797d322e97d2a067219e85c895333a9ae85f888bb71ee55009ba46e1a457cf61b4a06395108141022604c7c7f364b7058900f6141b82f17299af7c8cc8236e7d05f527aecd0b4a31cab9b6754e58d0ec58c6206e140cd6a99876b26bbafbe23057722ea7fac60ed2b795fec4c86440ed102035f63a0f41bc626399d672271e452e69e6e16f40b07149047a4350c5df3abe201727443c4dbf9112b8861d83a5bf113ff920f6b46637f5360567f82a264644ce3ac08a48e8fbbc5062298836b16f911c8cd63855cc71fbeda8f348abf1591931975744d2a04a3491746f3cbf6bf2d257e1dbd4853dc8331a869eb1e390d7d9ac7b3edc8157df52b47e894ae750433e1cd879b76e0e5f600283f1bd7a53f53b46945ac1e8ea21dde8c8451b9d007202d90899dcfd8e4680e7c53fb8777d00048d6d8d22483f121f1605d1009d741e717afb5c780f8bcce11f4a03db21f79bd86ba59d41fa0f043b228ae457f5ef9089656377acf74d65909156a6c69f9f6c1a3e5928ac966823b79dae9dc8ae88046ce595359c20f56e99f9f3b9b3c8f20c6b9c8c51e6319b8cb515f7afe73132d9902c060c81acf31be09f340c73b5fdcbe60d3db51291058bef70539329f1998d20352fdeeeabab60d5e5b5d9b031f103b684fe89e4957ab4030e2258d58fc064636a5ce63abf403fccc59a96bf1ed6921a8cdb8c4896197dc0ba01ca0cd295db2aafc8b1244be40b43330d21fe479b147727900e7db39bc508adfd6107609e0b95d7aa821c50d166653cdfde9f9db327d35b0ad85a8b823812e899cf9f5a6acfffb265301959cb931cbc4611d0cefd31bc5492582537015b21d13b368c33614dc10b36f89e1907e21775fa08734ae4ae685095ff596e56cef72724dd82b3fd6dff5bcbef09715a0ed61655495f3556d526ba39c05e1ca2489d8c5a5116e78bab49a2c49c2b6a2a34c383cd94884b3c0dd7171b48eff1d9e0e95f2c1feaf5dd06d9fe67cf5745cf2e475e206205d3ec8ef6aae7864a8516116616a0cd1e53e477b6a1b25ecdb8bcfb14423da112f403ce8954c987bb5edf8b64e8579dd30d79d6d6ff25ae0fa27bc6569a131cf61a2bf47b35746670d9fb21b255090d01b669d9c8c7d8ca021c0ba30039c57541513c9eec4b0ac62dac409053bf4a02e63481aa6850f8e065c5a5c772565eb5ec7ce569c8e0088e010e3e2fdb4ecf2b3917d178c7b646c482d07f1dfd3e3a3adb832461ff051baffaf8c691ec224dc2e5cd9479141149255cd7d3804c31c0ba4cef2dc6a52733b70a8261c00481065bb14fbcfe7c382001e72ee94fbf729c566a054149a1716bb1274b3e8d19608bf7bece8b95cc4845711496c53344d814703ddc9925f62ea9c05c4bfedcceb20467bf42adb95cfe2d81cfd49c6799cd08c079e283b3f05a56c2bbee87ac7bda343b31d8a083c0e6e31a245dee94686814a8a4e3483d678931f260cdf3af4b8ae98be4cb4afbc5f4c451633e713c32ea980c2dbf80f13b12f23e1e3d6e4e62d40b4ae24fe2e26e6d20cf80358613ac7a234e8c739b66fbe8bb94fbbdc011fb015ec1482f7efcf627d4d776bbd7a1da6372bfa2b334cdfb4097d465ef1bd198f2106b08cf1ecaac3c2aa45901d33a5f957c6b1cebb1fa8cd7d4a559d376f9860d8e2e681fea01941ec17c08e220ee41559fc341ffc890b4ab572885ab83a0bc246d8056af33152a21cf29de5b8fdc60e296305af8c84d9164b291a9b5838ada19f16449bc0fdb63a3dd7400a99cbcb81c5577dfd1f7c1ff390c676050340149a9bcb574439ce02dec1094b23594e4bdf82e9defc06153189a5a412cd646d957b01d1a922dbb30f5b0f3e2fa84ef5f77fbc4721da075f343a21c918ec6fe521455f66386014c2547441bd797fcc760cc4ba331daee1809ea46dc300e4c7bc77ad7ef101497e35a925d08c37f5db4cf7633af7d074004611ec849da7ab1d1dbbc40ca5f21775b5f49c24835b4be0fffbde5e51266ea9c34fba1a351644e0273d872420ff43198a8f8fa3fd92a19018379ec0e75a51b4ab12fb01b15ed3ef8ae55594606a12a3fc7373c0b7d0a8e717b8989004478d5a907e6dc791b2af135add9aadf27fef3c672dd8812b3f1722f3d58f88816d1c56fc46ee6c2cddf02208e38bc40790715bb5b6128a9d38da4d048389b49cd14ba9180ffbafc4b6a90ff614fc2479580389fa1b88f1cf70f826d0909ee284a910bdffe6cdfe12724f737e97c26805b27e09dc11d8c92ec747b62735eeb604707e13f13e837b8eaaf99631da2aea1d192c9fc03fb9f5e2f8ab620e29fa857ec15af19380d53310dee0630b5501e722b6010a35c65637420f31271eadfa4df4b4f954831ff5f8f4be818f24d5364b904cd226182f452a0f6f8e3c2a97118cf35942fe6c5f0b8da3a13bde7dcbb9fc7d23af53b88d9e266c9e7de5356b623e5a3760a5aaad1efe9f51bf88c7120eb3d9c43d96670805a1c4f9a8cc2976a7cdefb31eb158b3d57b49439abe632cfa34b7575a7c260badcf9bbd2a08a4a79653a64cb92aa2ad3a2ff7de2539eca2c704eb24ee2375272a3ff09743d03fad124c3a7a74fbedd9c629c4744092e0ca4b7dacc9ac9b7c995198226c2167cc687dff06c24313c389aeeb02b25f642d8682fb8200282b64d6e8ae30bc8553e139ceb14665b1e8db126c796274c3265c84737ffa211ca4716e95e9aa8e285e442ece3263d10d0f9ef3cbe32793e42d2c1c48f72e3e5b6f7b1ddf763db2998b90a575c67070ee8d55446d223d95cb2dd6747b0e20cfd1095e164516c72fa796ee6f90a3f528c5fe5851d1bfc1058daf552c28d08fee7341d6c151fde75ebd22116af90c8eb9aee031ee1ae3572936b2f5c03b6b3ed97da520d0713378aa2ba7a3fd0bfe9be17f435f01b27654a36fd7db8e5304c1cc081bf2f72f95616d7a5663e73142e55d1c2a58c48336cd10e4243595ead608c2b561f0d839a558940973e5d3e45f1c8f83a516f9546dd827e5166d101fee8db05b8d31248e5b6c89124897fb2f666ed3df37cac9874f845a6e31b77380af40a19f3a6ff9c4cff1d7e3cd1bd7efdce8adfb08a165026f93ddb71dc8fc4f3da5a5ca32575c18d33e6a0bfea389c43a237eb11be9f386c61a2b1ea63465bb0a228adad5b725fb201a18adf6bf81c3cdc66965a0f8a1ae87d808d4ceaae5aa567b6d2714ed936c925112db2d7eb48079c8481eddefa0aadfc4cd7bd60dcbb4b1ad4c1ed4e7d0830f5d8321b005f08d076715b6ff8ea59dbab47c9f407bf43ee3d834a9f0839585d6375894a2838abe50ba7f0abfcb2785fbede1342da07d761729afe39c9217a46becc7ca9235a5cae1dcb0c9c057b6a63f24fd5bb42490baa390e7f03bc3c02e216eabb7fedd37b76dc41188b1344d76774779ef1a6c258eb9cbf53d5d92e90ecfdccb11955a8a3e6ee936eb5a06280e11e78005f7b2b49d5a15488c8bfa0639b2d3c63ba12d94649982e78d846037baaff3d4ea45a85578a0a1212209eb5f06789bb34c27866f6dddd0a7e02e5e13ff6c09e9b9f56268977a307606bb1a96213543f0c73856a1f74021e12de4c06d87625b6f31db46c55ec0a3999a8341976d4ff26258ceb342937d11b886a49aad912c076d6d833eb88b63013409ca63f7bd5ece05ffe85cd2af6620980af0d99b0a6753960e4d0d69c85d6cf2d5a44822465737a3db1823be95c8370e711a13463402b7bf7edb3998fb8d7750cf11bdd7d75f949a6534e5bf2744ba28e574a724eaf0384ed40fb9aecaedca99e9a8ba715ec0a007140b48181f6192cefcc600db46a099471a45cc4596b6285a271bc645bc0d8cc143ef482241a3f35133d109a51828092b9c4c1fb3b8952e019ef99c49fdf7816e4c50aa84f8e5523186168dbd95a0814874ce5bdfa9aa4780f93511bc23d717f0b1f55860eacba304703b9511a14d223fa62bb7b247265bf98fd4a618a3bc914a86a32283b9ec59f410cc5f2f24ae090f2d2c1a4706152edfd47fae67807b798bb24003ffcbbd1f671dca03b65e2b331e8d40512af3fb18bde4d9681ff9c9382fa81f45f35dcc32cf711b0be262af19d2af99bf731d51c7ec059eeda4f5c326d089a267be9f1f9ff1d1e296c8c0948b8b0b54c0e236a9296d75128d2a5cb9dfc361c9891ece6c64d9cb5fed469878fad4e7867e970d557b6385cf173358034fce26397e4d9e6cad5aa7d9beca1542d90cd986eef419f8dfcb8ae0dfcb1119d5df00da5fc20a11f3da986c20200a071e8420b77f6db7ba4e1929870e42f77028927fbc77e2dbb2481221df8a270df74b54c8230af866698dd6297d6f567c1fdba9291f3e9f373f322aa5e90215add0f0aad546f11fe9a97b30450157fffb843c54f2f3841c405ac6e8f709c0724da62b6b0259cf761a54666d8542bd3e8f99965d9acf34a9ba06659cdd3601e8254b22424d49e16f1f2e377a85fa22fe5c041384cc75181ae35823b46fdd07b3026691d25c4829aef63990420e0ddda6fbad05599748f59be1cef4b945eb6ce27c1e1eb44692a3af2e98a9f5668031a92ec7911a54468106906057cd6c430801917bd9b9bf265821d01714051e90fac1b31a4f89d7de405729bdaa17a07eebad23b3b18639dd932dc8a248eb1177e4e3e5140a0570a835999d0b5b86ae8276462b8bca609a351da808d5c2dc9d8efda1600590fc88a0de40de210dd6b77cfe50bf5f25357e70e1d93fef37f63f21df383e0eea5d30380fcbc95928ecaeafdaa9f9bf686a4652cd82efc0c2d7106b34005b4007206856abbed2b53a43acfd06ae10fde5dd31781532a9e9ff6a87a44e08b28c16ccea4454460e9b1211f1c51ed6b9d887050ccb8dff33c92ba5e194066e3123d7948a8f70f2871f26f7f5ccbc6517a96b46b1ed3519ab7062200122515fe540bbf090bb16f36fb414320bed698439debe6399a5bc47107f96891c6d4d885f1de3c4bf991b32c840626bea357c34dc62ae2dddf25f1dee3e3135a37c43089a42f10037e516512b05bb757174576f4f1923b6fe837e893c5ce7a548e2c617257b833e583b38967a43c37c7048537994c36eb35cccbb48c2f39345ce465bede9912cd100843f56075d05ab86f5d73773398275a4a85ff92c41098c41c77c74ac7e74eec0d487dab1acb9cb79b418e987e876f6b042fbce461ac4b38d61b7acb15662fc0d1762bbb513b64b218d2c9bdc73169964d76302237ec534a20a6501f66a3ac7a1151898b57ec0a6ff6e8c8c993df8d1f878eff7d07c4ed3f82054713803bfcd30d5f193162058d3e886e9e3660b667b2449f16ee52eccd378da94a3bf989dd76cbad950134a84d64a01928a52d09bc07f3d3fe4c53d155a33e0f9a78f69d518653f1f697b237f12324ac752ee28e6985d5ef3fb8c83a3251e7cd65cea86875ca86cdaf557fde18b5cb7ba69ba640961ba3e4d6bc589f949264c7554cab6a1f47d7693fdbee9884439b0233f67fbb69283405abbcf53a0a65ffeaa4fc84661026c0128ead198eb910d835dbaa6bfc525b5c514baafc72a33196e82f9caaf8bb9eb85622026977b95c5805ff3b5a8727413ada687400ec93bc62691c2a466cc76334d5d3993710e73bb335026c1f398b0b7dc0db1e6638ffe24636c193303c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
