<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bdaaec64db84e24d3c68a803f5f59581bd831f7b8d76a712225b78466ad8a6e1aa237737503e5f25afd9fcb670921dd406ba32b6e265d259b0feac5e0794cf4169912778aae38fcb3df06640b57369965e9fd9bd11059270a104e96317ff205017565266167925c15b449eeaeef9af7e61ffb3857f2d4fc76094050808e78bbc2ded1a5a136ecfe0b684ec07de02a2808da3c02b4c661cca5919319d200bce03dc9b72f32364a3f8cec7582526f5df6ffc76eeb5e85acca0549de4fd2d75aba771e67bb5fb60d1833977274b49854baf5cd0bb9a35fb03fcdc3616068003bd1d9a9fcb7277002907be629f23f8251ef739ad52809129570b6f1ee0af71f5799cc68964cea609cbc3def081bb884da7038461042d22330dd0e3864d6f579517e4a4b6366edb2d3a6a10cca4f4db46ecb06214195b3293f107e60c5c93417895e96eea30c7550aba5ef400f58401fcd8c5ad5a893e9fc50320222b2c5e10faf1a5ab143c8ac31adadc52b08132b2265870bc3018ff06853425731e7242842f5ea243b811d125ac7bba9b4a7429273b2016024ee760dcb7438ea1b0753cf6b4e0b0b78673d473c041cc440474b4f84d5bf15d52346c76abf62e0069db580546c868b491a86134152c96914a8984d573d4376004de372ae25ebcb2f826711e4a4ba6e205faa3f9fe8878f43a2fe397b422194fd032b1865ebc689f9be4a4dc085318b4d6b50228351b12a6be65fe2e479528a9a0d3bff84bcaddec5614fd3c3f9a94047f49745b6a9d36a60b3fd2cbdfc28dee5181bf4a2027d8a6e773e2c041c6c0392275e945228d29bd085b0f660cbf0e11185796561b3994c228d878e7f966a887f7171f27f7b01f91a324c791dc590b769264d3466abb6546539b927d58ab2469cabdce5917b95c858bac8adef139ad65a4a4a82b47865b3f8cef3ae284da563fc9d193e3355dfa5f3e1349aab82d9fbb6a69140faa478368b59ff37b3f5682defa23b4f52984e93c6c2be9140a3cd3c93b04d04f4d89d085c572064404fdff8df7a7d8cba047e49ab98aeb7ab2b1f743930da5e68c551369d347ceed31ecc6eef77476bf514017518093d1add1c387a87ea9da5df2c88ccb3a319434c3bd06a97c4c4558f67651f8c5c2a4eea7461bda21b2bcfb289a481285fafe754f16df39dc5140a8eb9d31a0f669e052ca838d34a17e8ced427757f6c63c823aaadffcdb815f966ab76f4f37045d18ca32c946284038e897539d48f86433ee944220c2bc88b28ab7ece2939212dcc5000c732054a0e7e6b2cbb4006b3d9c51f36034be43eb5b742de485f5ca469cf5066ece9975504f75c8bd0b659eaef252d6a8649ea2f8aec470d71da6d627b9814c1da5e5d452c2109be1b90f7e07c08723749b03e3fe66dc216aeeec7a90bcef0a1a467036fc3d5dc864d13ca8f9b047428462e9cbf6a428a975a960c9ab1e67321a1db906ccc99ad381ede1ef0b43104a676e0f57aad013c64c229a521458de16c46c738ee271c3bbb35fd57c1ecc4e552c4fd3a30c56a3e342ecd02cf4a7b613e2820da1fafdc5aedd179383d7c6527a3fa6a26fb93231558b0d3e644e150a353153422d0c12c25176e67931bff8f37bd9c8ea9624e863d396a2d344fe11697d1e85c65dd490fc724e6abe33e8c376a1ae38067b89bb5ad1767fcadf8cc90353e1a518e89524989dcb98e7ec769e3df8828aec3398198b4b6557c5b98635d2438304b19f5629d69fbfcaaa4861f5baddc25f59c0f6d22e94f011ef1eb836069b2343e37de18250ee1b908900e0c8b151318902381c7b9cb18a49cc51830da30de09ad7a2769576326208c103519dcad1b10e3fdc75dd7d8f7f3bea055809e7b3566a2e38e659dfd5e9bb728087c73ecc2748cac6626d1bf7528098c233f5a40973db0c81d44e1275fda9eb7b2e94819f6848dc4f29ac15738c80e41235cbd8ae87d15f01f28b91d8b125570ccd2c1d3c1640972e8ae23f099b00559e1decca709f21d962516f7eab9d28ec8c99e6e0489156e3cc2e40b2aa12feb636c753f9f4635e8ad562c590c34f67f97aeb73be5c9110477594ff28123a40e176cd16dea726f0dac5f35e9672a829a20b375651db95e72fb2f7939d84134cf1d99f543df25a43d241b69459cae19d1aa7da93ed6350867192032dd8b23e827a42aa4ee5219a02898c87fef12f8317c3265b83c474fcbb8ecc63b8b140e51898fd4e0e8699405e21a953389e8b3d1bd7403c8cafe2286fb1ecb7eaca82b19b5bc327c8f3ea34386a32bf8e7e6dfe273b34ce08ca3b5653f6ff56ec193fa89ecb0e0b359fa921263aaa4f8579c3a42e3d14ef9a7e3f8b3658790d63b875394093be6ee6eeaa43fba2d013739e17b020a7b69af715c968d861501dcc2269d1d0c22adb0fa27d2c57b7490eb04f9a0721137ec8a9b4b53dec9939887a3a5518662ea83e566e27128f65c8326432f676655d664c516c46b965ed058ae4cdb8c2ef43af7ad1679d8bd1cbd9706c5730f0034018489adce8b68217b05366b2a649e8d5aa8a8fcf6f23d5973d3e2d089e9a0938a23b8c7f4c0f18b40a4b0c211bedded74eddc9c2597e364d9c674fe463c3c4ae8c31fcf473cf15805bb49bcf63a643e33eae3fbe1f0bc1d696a988548d7b2abb1b8bbfca96562f8da3b05c9e5c8edd7d057803aa6b131139914cedcbef09d60460f40bf825bb1c1d727cefdc052b8d23ce6c1bdde351cc1ed2e18341b67ba796212e36d74f328fac59f4c2dd4ca8e236c44c198f01a5cfb77aa4aa5f8c9a0d4e6663de1a568797389f17bb204ce3c3efdf6f2895337bbb99b34bdd4b85746d1912becc1750bf598cfbeee14e31b873a687192f32d4724e99e6213f346ffff38ada3844e6b86aec976a56dc9d7f53c78c4121d8e9dbfe8318555e3af1e395f2fcd5e4b5c61f346a98018dc4dd019fbff347c93fba02d36d1dea45422e71b6f49315e8cd19c03ce7b9d208e5c00c27b2060055311554997846872f0ec016ce88dd3ef9689a6857bc3138d31598af719e287ad99bdc6279b9a31a39abf1393f952ce1c52081eaef72977be6e90b1ad1942fe063daf59f6b8f4e9aa517a640095f3711c94015602d0e015043e07441e7d2fc2a81507bfb8bd3a73dbc13243f0be4d2e373b8ed2642168cfb9ccc17a1d14566ffcb0a8bdadcfadaa78c63d00d49a7844a1bf184d2dd3f15fcd655c3a55fafef2e8bb6d604d869fca416329e9d8c3408d4ddc47dd7f318b51c009bac674f5aa9cf24ffc195481ef32882bafb7b9621489a0da65292aa5961f418522258cbdf36c312e38d23db42fdd9f394cfa366c30e9e54c532eb57790b530b1fb9700f6720de2e37b7efcc5ca79808499cdd68128021b7504fcc95c373f278204cbedd461ec65f06f6df671e34aca3ecb32fd6898f5bd4d276dbea70f59b4cfc693daa6ddea88888f41391086bbacf9dd417b063938f8d24fe5b300403dac72bb214a2a4191a29c7f109b87821e9aa1b5772dc5ac10e9437830d7010df5fd7cbc5837b49b7e1df6798ee58b070eec6065a385b6c43555615534a15c615e075b9142cc9192848fd6452546a916d1c9ae96a0562cdf5b9484d722e4cb334b8ec008313379e402be77f166d65fff48682067f955993e637bbc76282d41436f2ca3d21eda9c0ee06b4b85b0006708c4dbb7519667f20ce657f4037b686f40409fd9e68d4b7d6dc5e3b680df425aaef5b98e0b9871bf2f85245f7ac77ad293c5839f11bd758466602f2dc814e1ead75baff71f36a9569a8c37757a6ecba63b0d6c603a4723a272e2c8c621a4300a826b03185db15fd934996c13a7fbc44f39e603df05f2a1c46db942aae7dd58f4730bbae4cc5e3fbac4d4a80b4b4c5467854bfc995d4c3b3ebd073021a1100349f5f23abc56ed81ea24fea933da2029a6a9104680f0b55cb35209b19f33ab35d4e1762c2f24b736e4303316daf11342126078df310b1e4555555b50b095f2f0ddd3f23455449912c1ee5bd3798a111bc674c759cdc4ce14f5e3b68e40f807192bf22da68e6d83553fe4b33cde25105eafa7510cb3d5b53a5e3f10bcf95dac41f648aefc6ebbb030b73138502ab7884c916ee117da99ae7cd99c16e26e4f65b858f3c167f346cc4e875a921cb2133775d7266eeeb9853a317bbd8b969d601c594a9f8373498313bb759b0e8db6f4a649f8903e6a4ab0e37f3f3151ed3231d729d2ac51b0666feca1ee8ad2cb719915c8b1aeaa8d04c2805cb855f89ad1c8eaa0311035306b756f3b07d4417af669c7f7fc024e5b35cccf3454720d9da02a25672cbdbb44b95a0c2a7d69405f8d2324ca9c4879b2da8ddfca6e28b834cd1a08e9ebf582d2c2eab7422e191fbe475bfaa77708ece6068de242dbafe79ab9ec707732fe7c3a8f4a970df64e5c7c5e80170ef41bc3f6ee312a5d6c4816a45a3b87b895ca6855e4c01bd1a69ae018a49231feac8853073cfbb74b634f73a5a625ebd3ff1e918ccc7b8aa6012c0335ebbe406d3555045c8bc907487590f778474ad16b30abde0cf96404a4e57642121b111b5e7d16c1b8c5653380c88738a455a636e4f889f069d64aa14ce071286e0370dc6b01d882f782ae674492b5328e9e50a1f5343c2c48d600be45262c7d08f3125a4d365a1b52043a26e54caf53b400722445c391828d163f17dae5cc1e24c43811e4015dbc59a574801c553aedba0b465083efb78e33e0555a782e33cfacf091cc258729015e92df3f90a1f5752c55838141cb3586956c7cb7ae1714358ec366101aca3a0ad8b6d36be7b8ac91abff09d269c0f455089fb925954d191654225b48be82e2f8a2705657ea1ea52ff30b1093946e19ce14aaec15289c5c9f22ae0f9e083d0a5fdc50f13ad0f7fdbcb142549a5a1292b32bf24aa3a8968c440d36166fda2372bc3f6aeebf7fa2173e8b6fbd8a883e2e929980f5aac368e1cc386e9e5bf1e8b516cb2abfff06c8dbf05d8320b9a3452066a58ec629d98c437fd8b3c9a2e2085b81994a6b3092431c58e74a88f69f503b844573dce9b16811df1ce49ed2087afd30c03d21766023d6e1b34626a3472da03a7f6152f91875434f5894dbd1bd523dea29b890c0995be7f1162b2165ecef6f2f6ba7272243756fecdfc7228feb19c3d3782618715cedc0deecb88ff332054f2aa9c87ba0cb88f30ba629f9452f0ae4444bda4aa4b5901820a70ebf437d7da8881c520f80bdfa9c42ac71c810fc63c9615f20fd0f4886572f7586792fdeff2d869e3ef7a64ab66f124e58796417585630ea44ab9fd1ccb1bb937bdc6460d5d651ba060d9cea2b21280d9b6c584702471ce027617d5c7db979a504016063b1d3225ab4bb904a6ea073e848839f9b49cd822e2cf7ba04dec9021a380e7360ba0c6d06f5041832d9c454e5e3216e1a2f0882652a27054a58b71fc2bad80eb95e3112eb134b3e429300f59f9e81233a0d3bfa92363f577a94ec6a85a8a4e5efae58806bc9464a175ed4f5a31d0c69141fc1aea7a982325d98315b6e882a53a840b6e26eb6aafcdda800c3fc7ea70ed1bf6357f68a89d3bb39265f55ac473f094e511691caf51adaaed75af37243404d652002ad30eefddb811e462d1b24713c8c61e61d1ff5af2b5ceeca8dd5af3bdb9bee5b3e3b08ea6019c0c554265ae7bab431bd25afe4c00b2062b6980d4b72cd62c9760588825c0f7a75b4da564ea2ec1d96376ee4ef928698e0ef785db1791f20d5de49c5354a11947bf5f8b40d0a88f5e1bbe3a1c0bf9e83743d8522b6fc4bfc575bb8ff5116f83af6c9d1b29f8226038e3f7594ac4bcc1341ad47bf1c7389e51a64de1ae664b530be300d087e314f180e22a04af087682a33f4f1287998675831e70aabae8cb5b89f26fa78cdb816e0fa2338b43f2fec92f1557a4e217a42162fc1861cf6f65a0e026db22bf0e74b84e0794992d6ee93a9f22576a79a2091a41e4b8036c07671c9701b00f97f475ee0b21aa374892fc18aeec6e7119e91ed1af7bbfc2f3fc3a0b148355ae74d7e4b5bc654325f2ec2518ddbdecfbbb92448e28b293bcf2ac5bc7cbe2e6e5155cc74a563e5c0d91ef7123d573359927833f1d8af89d2755ce0ba98749ce29812731c3afd3ab845691466ee034123ff3986acf6d229b62401f125ad66a6433cdfaefa9b1245f3952f5e6b2f334caa2fea0c1179dd822c43a9264160d1416404edae90c6922a7ae506d9ad49ba1434b2d4cd53ecd60c8493fee1b7b10b18b6eb7d0ad911b00a50dfcb6c0ee8f8649920b6c51cb13b5a3dddce8bb54220ba7a8e3a77c263719e3df7751b659ca728155b4fde89e37e7614e282581bfa516b757ec5316c3c3b50673a8f3374eeef3cdd7039de179ad4e1a6bdf2f10275bb0a641256ae5dce9cdebd09a15b0dcaf734d15f9f884f900578727739dda95c67179b5e05d260d7dbf643021ba89742dd194f5cc39dd2bd0a3a5fe3dcd2ad352297a92743322337070ae7787277f8ce1bd6f5265b1e1c25c0c717eef920b6a7e974a483a1cbde61fcacb0ea2584f71e1e93a41b328bc1d3dcde9f13007b702f927936354e69d778da8c5a1ec0f9430ce4a632138026edd80849c413c46ffb140587e76ce734f91e434a203e939f170dbe26a6813aac98344d14fd6a0100eb9d3b5cec227d9356e402a565112d029bcb4eb4898aa7bdecd2af9712e022297918ce8b0ff55d325675c69ac95a7fcb74a20bafacdd903b1421020202b1d087c4d93fa5c088e14d6f776f26781d1017f6ac01bb4bbb66ddc4a0794fd9f45aeb06143e012bdfb75ad6892a9dd21047f8de8bd352ac55f55ff825e8e68eca0e10154f381cc920804ee3994d2963ad1698d041353c5cbb212739414fe513dce5fd7b389862015cce20213b5a2e2a77cd723d99daf410fe09bb14530b926e2aedd14339ae8a59890a47045867cc710726e9a7169656edf85f504b2273248d2d2b18d466712da61dbf222ffb4df2fd869a1a8a7cf041fca7ed8dbaafb598c8bcf3898a847375a73f04d0218f01150b890f389a141fd8faa292c132e98e0b2ce4cd8a5e1c199c907f49b35c6872600f3f8faf0e747e0df3d2f0a717186c112bfa7b1022e9721e2a1563dca4b55ff5a996a9a8ae8bf0ea3ab2cd875e688fafdce308ce39e4af5325c98c673c2a0c96baea2dd0b05bf0334098c86581c99823c698df994106bbcd89234f3dd9fe9319fc6b573b9d1aa3821af6a2b7be90cf8e54bde786d315754334977e2c77c91eacd5c7ddc7eb695bfdc78f1a6f0db387905645c2eddc1c2436f3aa86cadc881d65c9aaaa5d3abb6cddabfb5efc1b5cbe2232f76ac6ae2304c2a9662a199ca7f788b5290605b457006ec823cb6fd63c8d94fa6162de0c1446cd28edff3a017d85d9e9f1ca2e487f9952377a25e426433a522c449f88743aee70dcbc363d7a0b91cef2f1de612d20cf1e7b6f74818dcf8b6fe853cac04e6d7e5ef67f64a484fc2bc1e0c6a3050aa4a0802bf7e2655154f89d0e3fd0f9a936ebc23116a54df74f36317f2a7a7bc2abc1fc9f8c4b9069a5718ae024f93ecbeaa28e0fc86bad0408f5720315a27092105e4c8809268b499872330dc1bbede9586cb990dce0ba61a5a21bff9682e745c56594f33839041996e2a897a13c01ffa5afd912cacb772d3308d5f8ec71022be732c25d78efe2389415170160fb63ad70b720f7c5eaaccee2a52b75de32adbeed69a77dc8486a5e091f8be9429bef66aab8b4263aa017a4ff910c24d25d54918418ac44f53bcfa55bf0ce2fe9757e37561cefbb6b0b17fc8cc795635411313520ceae9ddd163e6527073fe1b9b212ee1527963093b1658376df968e469e2f27beb127e34a8767c9a1501cfe3817d8a8c8a719151b3b7467399dc64414e11c736723732b8344eda67f196bf6e6c3d1a67ac682cb5f06a28d80de5931a1620b1b2096a76f37eae6e920c5c7524cf6bf44aad2e72b889c9bbff84b8f15e09a4b445432e25ea9f2a8f63e94989d76a70668808ac2c6d7c63b853b66b41230a2dcb49f9e17a4ca4eb1f7406a339dd8cfc4ed516218ccdddc8251a4e663f05e39ac96d36e139e129ff3bb62413dbcaf5b9ef99ea750dc803a2481144d737b99e51bede98bc6674f90b9093953ed5693fe2d665cf82f96d9cb2d88449179e11dd20bb273c860f63f5724e9c8518843698f665cf5754408bdfdb3b74bd27741a1c87d0ec0494fd30dbf6d74535feb8b4f3ae85229785cbb672c3cea0080e204f0bfc3dab7146db429f26f9e3ec1c7c2ffe550830a4e41254e0c6966a2f005fc8bee1da443101cb6c02816fb02e864391799ca6523bbbe833132b1c1e0a91e1259fa5421280427d9906ed799f2c3111e6aac4b92b97f42a04a2c895395a6cc809daa93ce8bfbf2ea09dc85809e6ed322481f1c8f3aa7e1451690d9d66fb01cf35c4eb50917b216a4fae0eb08e6dcd7e175a6fc91145253e6b9ab9d74299c9b0ceb62a01ee96bb8a27ee3fde8dc15c241c5631c573f8d220417c39afd8c29648ca477e6b8483beafdb5ba1730d5ef2019e1bfafee7a55d5f7a2706c283d41e7e7afc2c40082b302c49d95e9c9bf13e1f2986b904671bf78e295a3ec0a8b700309e875d96ae9cf6f8a63b499f6539725a5f4e7fe51ccad0ec4f0e668ce2079938ab4d68782d865dee80721bcd391889c4e6e07c0430ba04e5ef33d5cad41570634c44a6345dcdb3467bdc91c27dad00d018df5755897e711a8521cd1518def572776ab6c48e7e5e4630edf805cc1838e9f3750e50eef60903b02dbe6ffcd6e0af05e9af50b34afcdd89e01bf0351c31b280fb24290d8b4c75eff79c70cb2cd1fbea7f092a82ab502b85547a8d55ef8a98760f9e33fba9f2c80be09a9d080e6404d223385a8130ed4bf597a058db206b60e9ba577320cea63a13732a996f3751fcb08cca3ecdc9db2cb9300588ff342c28353889553f5eee01d731ff4c2fa2a9d5af5ab3eebc54c8048321b050fb7aae5a9132a7c55bf069ae8730d9883c03642453505056eb0d38a743e49e98b02d2e7dd8f9f02b86d947d4a46198997e52cf9eaf39e126167f1f7af2ea6135e5d5807768ea42206631e29af5786e84ea15dcd6bb4f51bcce92c47dcc00695395b015e437f33aa9f14ea0a0c55d02b280f564e2a1a3e479d67bd58401b7663cea2d090f92457afab35ff646d4bd0241f42edbbfc1a4c2e69a322b702575fb3eccb35138220c61c8622dfbda80fdff476905cb8560b13dded10e54b119db71feb9fd90f809401c96cf7b0e7b5f43faa2f91ab74632959387a5d421ef82a6e9286b5d86b0a4a95ff40f872a4687b69c12b62ac71bc3287cc6b3197d85be08411ca222d07773aa0d3b750237bd3f928ce31381145aae9f51dd2d4cbb65ced210b07b82345016fd9a631f5870e4582ed6e1836943ae9b50aacf8495adf4233afe19ca4c6fb833d3658c4117fe8c7fca73dfa64c6efdee9466e126de09fcc15f9475d5fc187b8a19c7bc06a6a197558722aeae3e9c4197e67a80c320e653fb09b3138f2d4d41b570878191b3a89b2767a992da86f270e0fd6b9156ec72a05653d10ff530c719be3321e954451dcf08569a7311f983e06ad8aa290c78f49ae789333dd42a39b5b5e749d968649d8f6b54f8e3ce2a49f54d7ed2206d51b2b594ed9301b8b169babaa9d4872e2768b82dafb3791cf59a7be82180132e07d2d7f456c7bd6d6daa9b8145fc913adca2335e30a3757bb9c8652716cf905c27ed3327851a7f3cee42007238ed16d539729bad17824d84a291cc3b8c7f9ff35d747b80f01725cb5416c3cb7fb4220d15ee1a7d873fb22dd2ec59365e789bf932c8f2a32c55db1de6dd62e0f418190ad0bf4fee90d1fc13c4ba0e44f453f40e8411dbe64e72e87a3c727141542a4dfebf7de5fd17d1e6f798e60671432cf7fa5cc86b9af6eec50219a3362353be90dbd09d9aa3f6100686ecd1ead34a0fc1a765040d2145d34aedab4e88e09d4d7a8d1985fc86dba286c7616c92f4f38a77f049a81ba4ea7e9e11614f9e42ed6fd7d373764c493232326f1c00aa0e870cdc7f5bba1fba09088389aed5d37bc139eda964ef4df5798a6a389a5707b63b48a28f9ddd52abeedb2a403a28c80cceabce29f786b5539f219a4b3042b1bc29ab0a337feffbdb3d19e2f546776e6f9760af4f47f4cf76f5eddb0245f7916746eeed15e936c60206be0e5f0b62823d41721ac82f60ec58dc1359572c29482cff0204faa6a7e1a2b0f6c8b970755f3e3dd33bd05383debcc09f394284165ea8709182de43627242a5ce380aaef12f4f534a5969cfe85180b25a0f32523843fed071a1e5e8288d1557a3c0b72181ec3409014f9a42688a1528094134f1a8106c12a58a46015cc380f66cb0713b57a7989a1ef905a22e45d406064f4167295bbee2156030176d605cbf443e7f30805f0dcabc4e886d787395cfb487198527e51a6091d32ca15b7f3f00652097c8bbde49f018c296a32bb087cb8f436dac9174544b8fd7d44911d4947e147ef48e31cceab27a1339f5bf57fe781a4ef98eb773339ba5d80e66187d2f991c4729d47bdbf60226ead75ffd339a2a106563f1548744283020d36019b813396c4493ca3deb82ee6649a896fc5d640a74d30016546147038a098b2f19773f07671169e3bed050731ea3ee4fec75f92e63b883ad41b0cbde291b4b9a5ea044ad64cf550cbd063901189c9784e5a8ddc84f14a77058842f728fad3bd0fc68ea8ce3b377afe98dcaf83322269806864e99304e3cfbcb24e9bc06ae7c96d8fc21336c73e00cc21fce7954241ef226bef10858817a7d5e3df02ba6be4b81a472244d246d795845bb38263b1c7d26746df71ddbadfefde4f0ce020610cfa962de5b9d35f650d9c3cb639700335292b16449af33f6d8f8f33c06f8b77c348480372d01273ca620556f73a292cc06ad9ebaa89b66f1c743bfb71aeae14813c62e7a0767ae9d96363750e5f5a349ec40fd4ba87da2d6d66eb19f2d75e554de7375bfca967acd58607b57d65af06016728c95f5f4c1f335820136eb5529329b7e1c312ba7f0f19c46ed98b4a8e3a05c163af7cddf3922104f20176a4ef84b25ddfae4c80fec4e376c042611177096d01a1639f0977c777fe4aa823ccfbfcfb589b26cad67349debb7aa825857f5997d35bad185a6be8c0e14a19cc866c5b593ff150a2e77b804367ae8be7924c7ad07538d9b14a55b26f693cdeee662a792683cad913f528f0672384894b8d66f8161e8a13447c89fba7548d9111c38b32c901627adf0e6ebb287c02037890050b423136f20840d131ebfb2f1c0fe26cb31669179f77b6f4016f6f644371f4b91b1335e2e0970dbc9d5763769fac469084bf34f0417ec1228fe261515d0f150c0e295cf08b5b44f0ba7c85638f40455769073905167deeea4ed1ad9375b8bb19c21962aef923aa000b64c6a36e8c03aed6584273b2dc8bc72c32486fe58ca89175d5c73197f5ff775d717f3b696fdf41d5c878fcd12274c8a4a5be9836584ce73578356738f9a6d1174bb8c5e668dfe6a597903eb39c1f84d76c48c7621d3a8a1e1307e3590e95a32d0ccc1c4ce7cfaac4c98db3668e008480397a6149a2669983ea4a3ff5ea718d448ce9bc6fcdb2458f65fbb17d72e08a4e00302c5cefc9c36c416d95604492816160b9e71a702fc49f3f511aae60eada0077fb5adb5b0bc574b690c6bedb321ee75e067368fe68f9f9e34dffc466ac7ee80dc349689d037654b4f6290b789456e6a2d71240d275233a98eadefb6764b81d73d73aed42df704812c49b040e2918302c506be7152d8bb81dd03577d6d42cd839484187bd247174ba97cb35e5f70b24cc6b22fc14e439688571e42ddfe65698c980ee0f1debe06b1c2fe55394f926617bf09095233041e4cb9e272ad5fe858338ee71c30f0e79fd65586b2ca6854c1a94f83c5b20046964d62dc7087e83b4f0c4473f9cc1c36ff136584abea29ca5f8833887c9542f14847622ee4a9ebb104ec1d2a4c46fbc95231956b4a6428e78958f24326d488aaa969f84448cbe2c2402a3f2d8754e94dca18952179e48db9a4066a1be78b834527cd73f68430e1e4cf869bc381f325041ced5caa8db65ff8748ebee6ddab136131c63fded5aabd56c69c4712ea4d1328dd0c360073539508796e277f39f68e3d98f7c63831fe4da2a17703dcba5ae71cb8a874599300dc74d042d2b6fd0aadb13afbb3bb2a47872938a9bb7ddf4d08d7327f649c59e43b8fbd6b9b1bd62f304480b8edbace47bfe1535ce29650c39e94644cc16ecdd2a0452ad705e7f82f55fe9ce9a8fdd9df7002b14a1a72f5c3a2d70d26e49b8e922a6a9e85ebf312d698c9312c022445052dc44d2f392976c55b9875b4c1f01b7d3cb730aeba07a93f19dac24da4ef599c132fae840853629ca4bd10e1b8db814366eeba38448278c77eb846cf8cc39830163ea9090723e7d5a0421c828c10cab7b635b4a23a856f81cd8b28b846d05f5ceab3bca12c9deaa3867c97307069508258b9c158d2ecfb865bb3c295916cf70f441806416445ce59b9b8be0fc8e728f975dca99c3a9ac6bcc42197f6c2236d3eaeddf92da00395151b63dac5a00090dafddb153aeffa75e6aca405e0e2259648c27936f21fce1d3ab15e060e24f4a42e69b2d86c508383817379d09733298af3e64916f44fea6642356fd7194c9ca5cefec7663d0b670b1d31162eb159097e1ca81736ec95896a847ae376d9777472c3e273c6abb91ae781b39900a4ecb4fb9e94ffb5db6fb280990849b782cca165be0cc47bf09d8d25006d1938fbaaff6b1d27dc3b26293a2e053194ef3d7053ab2314ae22d94a789fb9bf1215ef2b856ca50c4a7b227bc64607995ebe5c1fa89d767f970720c1f591b387e526ce2790c6e5e51c4bf51f45cfc625ca9f0b827dbaf6f93874579995ec30ce15b0469a1a5080182bbc25e179afe79c427849f22a2a095c48afaae1ab4010b445aab667ebd49fb3ab6f35bdf79d9de36450b87847067c325982ee2e37af72171850dd283876c69afc2a1302719c60372faadba2f1a9d08b134950165a979f24c071b140754c5ed0b26e413945d162899cd591b0b467c5ba7aa5088d992ec2d2c25d3223e34a4192ce22984174f22f2b49201f813ab5bf2919c2fb728bbf701a265b14b7fa8e52d4e3223556c7bf4fb4c50c4433f5cc625f7733ca9c1f340b855466e2b85e35d64768e4f50908d58c49c4b5794910f0471a6b9d876a7199710f96b42942a14db000d641c650d1cf3e224b51f810ed043e07c72ce83cbcb48117f1bbabf2ac3af62768c38dd76de670bcbd586b123e2f3e7f393f00a8b4a9e172bcd318fc15195cb021b6c36d04546da17c10c2d4f4a94ceaf945f6131dc46de650526832eb832f31c7d1cfda5efc6a5aa91183ee9ca5077d22f9c5368d17348d025ef35d354c424500e918e41285120c8c1a281af75476a44f06276784716bce429d9e9210c96ad44f1823adb81bb1c63911717ca1ec640b25803161f88df26ae9819c966b33fa410b306dc9f8cdb9a189eeb647dab98e0059c81d4d6487820470bed5f4e978de5d2071e75482945a3680de276f03e0f8ea62ab2f1a3e849605ff12d251c616196f3267d2a7079d1f71e6191fb9a920602ad1d42db7d5cc94c150fb016036a626eb7b4d4e118587bed26d0ffa8c79feedd4231c9af03104f571a717845dbb657d9eb5e481301757710f470be5cb91ce5f1d2d2c124f8203b29eaa2221651ec180fba23cf26a8631d9c6a7c90791e97e8035ae598d273ce7af73e066bb5e9919ec6bdc4596140d1b066c91375e77f59f7a4d72f6ee8e14a190b739414d92d85b049f466d269a9de61c54160e2c8e9afe2da0b5f5517b4c31ae5032fa272aaf9b3cb1737bbc1293107169122708a72004fb17731a00fbacc9b47dd56c0547c7e100973c3c09b5f57714971a7a6e4197600415a054b28a9748de915fe57cd3f3c420114cd1d52135db9a2fa40388fc2e1e2b8585e23947262cef08172bb2b726f8c35dfea98061e5fcca38ed1b70dfdcbf5c8e82854a732fe87140c990c8822aa83400674754d030306f1085f5dc2dbbfca597538b4c43cc91eca01441d732df75280bda1e615b72e001108316b2d3baa580cf0909af80abb19c63195d9cf7ec792c70bb6c6d440b3900c7c0d024f270b9920fa57de002882d2e7e23fd90a7abe8c6a01aa321638524d9a8f798fbe341a589a58ccab4761f83f2836d83b2e990d90d0cd6b712ed35c778fb6dda8fcd2df67549fcd2b7e5f30244f0f4cadcff998c4df45362fc5f2f1680442eeee1aaf8499c6b644bdc399b4ad431c044a2f4d6024ecde2f4a9d08ad0cf3aab823f32da968aac17357238f75d98059ff54c4c1f4a5aeb0de82d2c03ec15a46f8ae029e8c5c38a08c5e070d13974141b8def449b9249ebd41d26127e964cd9bc59497add479ed983eabbc76d3984505565ba2f347bdae81d5b7d5e26f596ee0a6c9f8cde5cc6f6cde6a9ed3fce211548819fce05597aef8db0b6400af37c493c7e471aa6378ee35d12685e080e2f80fe82626422cdd61978c055855f64116f967cca3aa7cd5f813695bdd11d64b8d321fa30a3a2ff9ea73146134c633b4fdffdf95d601fb8c702cabaf79b2d51e79c0c25170409fc31f74f88a09d4015f9d364288e43486eb31decd4783357294ee291d40d8e281c8018ac65520001bff802c596fe6a81e0cb44525bbd7a66e5bf89a3982f2b017da38eb5915427b186f92e86dad421fe344ff727223e8be98b71dd638d78d7aa4b21256cd1c56d9a6e6eea48bdd7ab696570967db92b074c885191f39df473e4773fdf3add81581134459e81bb85be518680926b3106d3d194678528dbd0dffeb7a8eb118cf91e7e3c64505c095a64b918b83769017e410842e0b5b56037bad6cde83949716c31315a701b7a9671fe61542212127ef43df8b771ebd5e2b6f5b3f486bd7fdd5bded86958dfd3a92646d9f49d438a212e9f1049beec6fa242dabcc8f70fe975947c80c584bff487e0f97d86e194c406f521e67d4e335528fe628f2d2a3419f6ef30bc633e003d1353bd39236aeb2a05ebe29814ef344eeaae8c4d8c53f4e8a9cd714fecc422df2bf6a2d8abc25ec5a34b1d111f5184f8f680a3744b0bc7083e86f0fe8d5d75de354f3439ddda4bf2e4bd0811a39796a1566eaf5f379673e1a10a13ec948d74ae22def05df8fdfc195e71a2917ea73a373f0df1eb915456f134c3d7480eeeba74d034ca29c8f777bccaee5af66536042e3f7461b8994a5ec43f67727b0cd28028af7695ae917b2c1c70f8df45b2f33115ae6cbf795aeee6f3341e6877d0ad3cbabda9e4d541417b67f1a3bf241a37b52b22e9d18bd185aef79ba7de2cf5a442d0226cf085afcf1724302fa3c5b8c0c77daa942677a6f28a944e84fb5a5533b9f6faddf817ef31a2e248b9ee99895e5b47b84791b4a0536b76f589eb78044d2899fefd55d4d3bc62ce595f3a04409fda22709ac43e0553c9fc31bf75bc2e3dc0429a38a8a9610de285afea6a0c115ede8d5d7b8ae45fb8e09d7ed3206e6a2e9b8b36501667a32222eda8a9a5b1887c2fc0377d6cef7999c621894e7c3ec1f647e91b4c8731251aabf22983c71e0a012d7f8b64da9ba8d33b3146fb6bb881eb2f6ab8acf40aea360432ee129107c4d1c6e5dfa970b497a49d78c009206eb551ad9b19b223f6f67b0d29e1e597e9eadd9cd9551e43511594be5606908ccf554487c17322f7a416fa05ed6a0788b480fc63715a7f5b250e420e157fe5a9cf5c2e47b15ff1775637c62505c4e732fb1e4070ba7162eec669700a1057bc0cbe15fcf3ab0cfcdbd01234d4092b5ae3be2de82e102f8ccd08f98b631690bf6ad41037c6715a8630c3e3f29e91c22d96a13e144a705f8cb9a9a9e7c742da844d5fcb1cf6dbf69f4cdc2151f066e93b8f130165b97944f04d5a2a34dae74d89453fb7d37d4cbd9c24bf857d39f1e49f51ea1a622437088d36c8191c395f6433a3e06d94489c475702d3189fe9cd734defa1956595b4f1470357fb46886efdf2349bd94c08e8e90cf661ceb580cf2fecb2f3501b433f94a240c4dce23debd8cfd1ba128fade798ae3ada67d29816c13d937a8d9bceb7750a69f647aa3b6edcfa59c3669444e493f8af7710077a269cc33bf2626c035a9ba4387ab314623c13eca6a0ac297f0e71ff93a3c07661d234f5f92c78323f4eb1304c7b2ed2e0a30fc61ad9dff505c3303eaf9ff30d95f9b10de73f03ce81cad3e3d1bc5ed1d9b2794df1d5622384373264f1853b07515ab42759c8dda3a3b0287fe37c406301ba4331d951102959ffba6a81e6c77da00e7aee1ae6d3b28f40a8b422eca4f4ff9bcb41ca47dd3a95af64852e9adb2b4d50a5e120c83709b04a014e4b24d340c2e1a09a400c9a6c3d9d4780bf603ddfc179e84a1c6561c182101bc03628cd01a37b242f79b4141727cf62aefd7017500c6d084faa5affa94c3fdf44751489f60260c5cd23d4b54a142d8a60dfe1cc6b85b794d68f903e7b704e69306b9680076222fbd2a1e98daa664b9cfe35a50ce09534afdf4fa52d53b669d4a3f309d883a7939b8264e42cbd92cdd576776024402c745d5a4b65d037e6be4ff0366b167a204981e3821594dee2d8f0217d5ba9abad9d8b4b1a3bcc4581696321f5fa6305d90e7b92aadc5ca9c986239c2643099fccff47610110d8bbf2f645182b4c89ee202faddf7e0f0175d3d8970d007bf26b863b5ba6b7fc0cb537d6de0d38f227223ba443cde230cb88c4f487b13abd64f181bcabf1dfb3dccf2a1aecb8a82c6555a175daa6eb34d00971bca85433f13188183c45d88c02c5d7f4c850bfd5ce9b89bc8a6f35a8bb4b678e6f306d3b0896552763b6e1bf30e75da4e760be18214dba4a2f27d9fb0dd10852d28ee1b2abeaad6f92afaa0d6c92b1a6ac60fb6a7ccb05e4c49adb1170fc5d14157bb3b40f3cdf9659e1fc085e4db84fa0f1e9cd6fc09c056b05d873b7edcf34c973fcccd8348101085f2c226ed6278c86c7e1d18c56a406c513d442417988f6589bb01283858e1e69306c302e10bfffaa9e375c0c71db722c4d3c7e0f91fecab11d77e6a831182c9a7119394ada646e388641a9a76f4702b3d240cc808ea62be0e864d1f298e2951b7d824857db41b5304643d9ca9589c9813219aefcc5b0f6341df14cecaca234fd8fa8d9c9fed4a30f96c2d3097d6742f44551f8e341f8cbc1f9dc4785bb6b5efdc864e49ec14187f534634413ee954e3ba83f5f4afd05ce5fee26d2c739026e46939335f093799dcad37f152aa5d02deb742ac641a1ece98ecdf021aaf20f6a2db01bda9ad983333bcc5ddbab6116e70b13edfbc1abafe8c2d8836a4f04a685fc5583af66381af73961e5cb8e359088a94fdc121e3ead1671e3f4beed0623fd48c9e8eeffcc1dd3b84a07314c087e5a3417eef1fc2866486c5992002a62ef98c794ad3008ebbe21584c76a5d557e127bae0d941c10f6c5bb60c8831fdfcb932c56771a7b3681ce7c3e0be635a02fb7a1f72dee55314f541d2831b33cd806e4971716bddd7e39ea28e0b1b288f3cd4c2814b63c565590e7c4ae88ce43d54f56ddd7c6bc510d5b353fac7c3e65cba1d6acf11301c406e1daf3b61fbcb6911ef645b6bca98d7bd00ea468e9cbf141bfc4844f6fee41d96a755c5abdb156d46336310d72287441c70e05305aff5b9fdf38f8e8287906f84cfe5636710d419393c422fdf015e8dba3594ee9b0f23b94e95e64883b674954026bbf6d227ffdcbc098fd191ccddab7efb3934cb5dc333f70236c27aa6cd9b3f30890a1e5ab9ba7435a3628aa8e48647578bd0908159115234657f71c1c794039d60639057af5cf7e844b9308ca80f7006382d945c00164889ba05551e9ed40957252710631c9972557567476a297c2354b0bca851d90d34d89bc81018e2fc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
