<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a41afb3abc05c7ab272b6266b3ad82db47fbc205cb26a7459e8dbb370530899dd4f50effed6b5593972255b613210891e53fc5e2339e106bc58d3a239b708fbdd264bb226fa545ff5d8d297e1393154943e788931878b25752e5dac69781bab913a6d82fa081a283aa3846129353fe056c4bb1df9685d312c432062348382f1f3cbaeb3437c15c07e95b362dd2c18ae043658fd80ad4a40da3be8dd0d6da9b5d64ef1991fcfb75fac57f673f4556c10a795cb8fa7cb87170b8b8227cf84866d965a2ed11dfc8d6f42aadfb72b778c8902662c7e4f65a9b1121ca0f138f9350d96e502e3a843e0814e0660fb278bef3cbf3556d9eaa5acf96b690209b2dfb854381f309068a8fa601e5839ccb7c1c716edc4924d1668d7d6c51970e771a853864522b54d89c784d6f853e35c537bb4e3b17d0338d87837206921bbbf9bc70b9f3740e0461e4c02718a19cf1a7574b5a5bf54bf11976c4dd66e548e048d34d44ba8bd8eedbb82a679dab9951d49f97ca63f3560af87e535418e931c46b6c122efc22c8a30ff45214a3d5abdebf1b5823ade5e4b97ab71a3a4b7d2e1173746e6fdc50ba729dd253bff9230f72e3556649adf7d93a3c24f198cb2ec3a9b42f99a98af274f4991be781071adb1c4bef74a2ae6a91c9da477eadae157bc9a2b526c3879358f7294503bd5e6700c97b6ca39e1dadde25f1bb76d2773909e9780f4fecbec05dd84bc99c4dd0d7d34de88d718a8d5b66afb80244d6ea200196424ef5d4b34bffc130b7d67cc563a2952495276351f4bff18674b910411d7667587d6097544a946bfdf8d15f295d4cfe6ed02e4cee5ba7b378198394a53d007422d38e8d5beda8bb035d16b36c8018fc758e51ac9de94aea5a86e96c92aecd2b080ffde6ad8ba46b8dfd0ed638298c1eb54c0f760259a24ca4130ed8b7fb8eb0ed615858ac1f56058ed2800ce5d24161c82fbf691a039b366119aed5cff7cf201a01f902dd7d5b2d8fc1aedf8c2989fc25cf8c36a46f93a745a3b68ea1ad4f82917e66a4ff98baa86c48d490af42ae7b427b79ea5140c1854a83453dcf9de4ee93b7fbe978d74a8b5ca3fa47b4651fdf9fec1390c9fbaafef80c5001361eefffc9f52c9377956f9102cd952d6960f3b1833bcb4b3ceff7e5ae85765ca8c5e2742d23ef2fde3689033c54c1b79eafae13934599790b2b9673fe7481773e33ac4e5d03c1827964e6ca0bf33429edb380b4603aafd82c07b8856ddb14fa1c837f3535a2e8be64afe3816bbda7a9d4ce62140e085b41939163dfcc5a516c3302aa6fa00abefec117ff3f10c8617217ebacab1c031bf381731b30186e03a047721e140006cd9a1302c9f95540315dcc0873c8d22bd0f978e83fbf2186b635d545fb6809b9bbb8d6bfa24b195bdef3f8a8be7c4f8313910081404d1fc871314c4b471fff74777440f4d3741e09a4464d44e97c44beddcd0cb2fd389a230292473bf77ac8b0c03353ef3abfa0d0b9149693ed0ca5fcd35ecd048d65b6187ac3cac45afa7a528ffafdf02d4ff5d724707e7b410607c5216bdb3b7981fbb7fe9b781ea87f8fb12cf59c5caf8da07ed0c02c6210236f31c769ba6e0ae6a290b32041260e5d845ae0ef10267e312b0b9ae4ee97f45a36fc50c0f4034472738217137672b0266f2202616115ced21aef7e39f3c5f329f7d9690ae2f7f738752d82f8ec286a4dbcdb77f15d95d2e1587c091adcb1e391e2f5ed4523e0de0923fe7ffbec41d4de7a6cdd16a8aa8d2aac0162b3ed3cb789e9c4e0d89166fe10c813e7241a46488dd94eabc393d58dc0f5710eb7b351af4af74b41d6a9d7fd707245a811782473d85be1c6e13a4cbc1c301151c32b3ff30fcef5a944ab73820d449b6431977aea155076b6e1e6343f89aebab6666a697066a56d1a89ceeb4c666a27eb3949250807cf4cdd12606c0fe94854ab0e94d233d1f8f0528fe3332f1b848b7d2502f77de4b34c70adfa4c62c7583f707dd06d5e23873572244854eac9ce56e75d5a66fa2c5812c04e90d9d868fd71e770a5fd80f89ce7ffc594cce612346dc431acadadd4f6a9b965429ba37e6c43266c28608a0f3f7fb6bb1853cf5e0eaee08884dc33e2b77de679534c0b04da0fd830e38ba234ed8d2d056867b70092d5ff2815a26afd0edd3f1ac38d7b28d9b3baf379bc2ca04279e2459dc272d7589fc0601e012b966c40d0bad308a8f339c22d45b073ff7164c665eacde81c926a2706e8c0834a9e0498a306c7952427d9709ae161065840bec18a7e939156a38f08ccdb87ad7d73d0475f54c5f02228213b3b526dce74ecbe628bd905150b0c7606e081b108529105c6126c952906c6435d35894e12295f6244b47c05233c1735002612633549f9ed6e2f2ca3d0df89533bcddc7135c4f1f89d416555fcbe9a61106b2e4dfaf45362e8a841c596234971b69f20e4c2fe1fa497587120fd35d47faf60ae45c60bdd5eb4f2be7427838617730f6f597c7899d9ff1a1c5b7c21b845f16c69e711067b34ec2243104515f6bfaa66e3297b5fb39a600785a00054063acd389f2ec94cf2882e6c0702f779f74669b13c7ade70dd2bfdff8c0e6a57898de347ac5725499a5aa5c0ce7783781aa6a2c737038fa968a8febd3079cb0e761d9bb2ea336e764324a078cc6bb4661f080dcaf7be835c17e60dff17cdc9877cdbff51dcfae113a7272fe11bf82bf0be4fd3c4a2f429236ce7510098fbc06ae8e142405d6513793c745b671d6cb16e0abcd0e9489e3afe4663856837706d7a3acd23253ca8726889e790bfb32c3c68047c630ab38838f2189454ebe3321b919a5f42018770b1fb019add5168223b96a0f37340e6b47e3df8d3d9ed22b10ab84c912ebb04acaa94372bb865a2a1d444eb2b9b964bfb6d6842e81d8bf5b969928682c504ac4ebd36ae48eb4ded125b97f3b4d657a6fbfaa008abab54b515ececc78fb5d8191ff212644d8ce7ea406f0353c839a2335a6ee2b86762a7e089acb1da412b4f447025f0c9fac58d1118a24dd8ddb33f33aa313e26849da510fec74214e0783ae91ee3e1cfe716bda96dae49e09ebe29c4202a46ed8bc8a1e1903e565af4b1bde42bb08c064fd14332705d697805c90ef8644d7912c5e4a9a0157ae6ea44785963c5192d7bce9950609552682520ccebb7b4c3dea41dc0f6256f84ca3a59eeb68b63907a10818bb6efed321973e21dd4f73491b8263ed8ab3abcf480b8604a07c584171e2502e92a9ed2468c02387e6eeaf5653c9a216f7b8b04965af809c37a66ad49e1aeecfd070764a23fc479cdf38583503fe9849f6c932362cced0abb1ed69c3a0920837689095820796b9cbf80c7ae04d428d2713ee93133fb034fe3983e3bd68d4559797e278ab5cb3b37ddd0c03d578640068ff28dcc08f757b2bbb9d0bd402c2ac34bfb594f203a5bb1218bb739027833caa1cf26ce201209bd6eaa4118d85ebdf442eae2adeb52b4b23fc2e9cd6a1e27b0852226f0672b2d852763fccbe3b2f9b15f7bafe9ae13eab0dcd2d96c39a4dd803abeb0ab658b7b8d783cde166c0222703205aa18935444b556e855b1230dff20de3b7b3c51ea43c2121da6d32c549c0b23a5a640c71f54e78307770714c4ff9587f1a376a42c74d4afdffa2ad766af00bd1c0c7ed3bd940144c9937dd75a95b1fc462ad4e317e8a7cbf147b30e6da5dcd2967637e88dac4ff902cb19b70857878d94e4b81eae0c396ab851fc59267bdf42e49fa6d43e20bb552c6072a78204831584ced37813c9d5a105b293b04def99195e7a069cb9174794ccfc417b5a620f7aa612c563c0fc4b38477e1d2f4b7f5a256805bd8ade6d31656bde023fe3c711a96fcf982fdb818fdba686a1625ee27b5203bc89f3fba865d135bca78aac1c4522b3e58332d4814927f89c864fd117983bc9534450d820ded5bf657567595790b34fd1f46ad39d3be7a8379d6a82ed597b40234919277f980819fcb2b970c2bf7ee695d8f48d38cc0ee439662fccc3c9bd919ce5d822755fb3a472e50da3099162b5c3375063c2fc3861f7462e920aff42bfbe216b55c2a3b36b23cb09b63145b5cf7b21c741f9d13698f7b212d7328212127c9f6dca72b939738a9cec618c212ca513a2b28b331401f01559465af83d10535f2baddbb59c59a0c0fe36e6254fa6ca140dfa498f07db0ad53cd42f44df687cdec7d10abd7ea4c1a0e59814889f0e0e5fbc631ebb72e6e3f25e7ce37372a8534206100c34f1ada98a2336d792d23a85ccfd21daa4314c75903efd5f3e06defa28ea4ba2cbde5853676c25c7e5a500a015ca942ef7fb84ba7cc58ded29db5540beb05e9ee831c299b5b17f232c4e765b636296a459bb9634167ca879373358d55e14c755966cb53b2e6a988a6b85154ef617a912639fdacb60a67e6446ec835f7c4d41b04ce1151189f1b82397cdb9afc668ceb69ed204ed341561678ba8b3e61aa1d49083e1e83af044bc3a2fe92b81559eab3ad5bb452455869bdcb17ebe9f5808f14ec9937dd1ecb2b313d8be6460f6ecfd212da04c34d18af9bc366a4035f0afaf14008a4bddd88db3254b727c10d4949391abfb55cc1bbf90476efb8e323abb8e78ebd01519e259b7b265f41a0c85aa85a5a0abbd594bd94b96c9ac857953ecdc618c48804b67d5ef267cb0d4c99961660c0e0ea2b41aa7f412ae156bacac4ac17ee69c59f48c2fe72ff548938e056eab901d69058ba859692055d364c75382d9aa33b9c4dd8a00b9ca740c4351a4da2914c26decc43825cb8ecf98beb8f14db9b258acd9d51bb88531bb1a2cb5bc76edf9a2c16f3e9c09158aa59e8100180059a9928b7e246297f7637f9c344d66d32d88dd1ee23f1b691f0f0b025336327032570eceba3fc791c8b6950f260a6ea83cddee33f3acb673ed1053fb7a6438639c751000fee22e34bf39dc5601da08118c20797102f11e30abc10aeeb208fe8deea64f18ef2ae0448f4684cf776e56ffb1c67a46bf5ea9cbcba83a43d26d99f4e8eb038208d491cae27886ae9d6ca753c9c39d3bd6912e8c80dba1c512ee88e2e8692dfc95e202448636f9c9eebc5fdade9d7cc12c8b1a995ff1d04f99bdeba45b5fe0ff467edebed896b1b947fe8a5582d05573e36491b82fc1ad2da141b0b4ecc8aef169bcffad3ab8d6851bcd09da2c1b913a32be608f5b9cce7415c29f0e94ee894652ad3a8be6fa21b25e68af817dae6b0e76a577cb9b28b6fda8b798ac7c5dd772030e8950850691656a06c8787142cf922dec671d4b8e2b8e2adc2d4f6b18352e8db05469af29df22a5d8d8943bf642316821413a27f8743cfb1536aa5dc19b0f11a561f3966aaa02295f5ff48719dac8815ce8310ca685c1b2403b064ff952788bc09ef594a228b11617051ec0d4e09880220e5fdba7a8d5802c0f25bcf1e00caa89d50bffca4a7911ae2784de8489ebd74222f69f3111c7cbc5aa8e37cc178cfcc65b3f4c4277274a0d0117cbc005ed49aa84694103de148df73c5f631407a6c74a11ef45a497adfc5eab0532fc3940b004b01c3e9d2d2902714722d4b49dc1b002806e18f02c3fc05b98f5fb43c73e7774cd85f42ba746a0aafc8966072e9a5dfb9daa25e7d1535ff01541bbd3e8b9ee05a51a61233eca6e74b000964ef8f9db110707c0dd364bab3c8e089a2699596b9cd708b553f66e76b62806d2cb8ea0c91fd254ada5e2f118e6286c72da3c623c6d131bf0ec7e8cb2e94dd515bd65e160d8475e47f8ee50416e709d34e110e8f961badd42e59a9be3057bf593b0e65ab4bb78682d73fb1eded67acccc362355a4896689fb6d50765a71553651ec09a4915976320b074dec050ab2191a4fd8fbbec31d3a705f0a37866957651de2cd39a02e4687dea1a9da82d4cdd89c8618b7edae34dd1c08063a09323796f6528b1192ff88dd692c67170c5e05a9e2726ab6357dbbd80a4a75e924422c899186c946df3fff818b8045185e3a898a67da36b2d3f091c6a8378a4c42978a67c8684b19c3deb61835330cdf3478a41a7109998fab46d1c9ccd06f811d7609de979b3082e0e332fe82aa28271586a8b8c4a76cc4d736e2e8d18e85291c9eed881f3225a9e6472d901a117835109858d2e9bf553251cd2044c554f7e3911e1f34b65d3f05d0cce35737e21bb448f9dcb7bcab673c0b9016b78b1e545d44e4ec0e63a5aacbd1a0a868e2620af2ee9597a1907238ab9e9fec93e7cf78c481d2c186c8e46e2a4d62a6aca2267a40d3ce6f2130e859854953f1fc613c827449b28085775a7b859687e81a33ee33881e8bb32efb7d5e5af7c7b8e1281e3045f4e132375337ec3bfcaee080870de6fb65c277bdaceaee763434c3e01877bae928bbda50f04bb1a668e39a25a6a044d610651b7dde2841a3de69ef5c055f6f972f06ba7fb1dd150452fa225b0cf9d0a828b64f5fb7e060cb4a194cc1022077199f88e04cbe7ec3c3dbbac02edb42e625ed43b5cb6e8213a3ee6304803ec6c51ca0a3981af436097ff8fda6f3539fd89f6029081b10ae044eb2b74a935f7b43287d01108913d63340a4f969bf2656adc617fc52b22fabc70ab6ebbc664cca61df8a834d1170af83a1798cd492d4b0f70053a8676c20df14bde11d4523687421b97945de63891cb4928dce400565763d47e96ed27e3c9f4f81d6340a6fc31b9ece8078c3c07a7950ac1c0082d0e8ab3207539fe5da376aa67af36c6a0e159e9d6179d9cc2b8f0587a7fe73c30434733c5dff41740bfa85e9caa5f66d1a3bc5ccad89e01db46aeee5cc8e11bbad1378c38b5c3ec1d48dc3524324578552ec27593d9e7e7cda567f1f8b797a995f2466ee8b32e35e06e668c9101b3b230b89890f321e69bd614f82d9fc92bd764d161b8d2405de9245da3ffd47e722ac84488dbea9bbf78b76bc386a0299e87637d33bfdcfb499f15b9c4b8fbfebb75efb91fbc24b3e34806a545e52bfb5ad6375e13a86e38dc59fdfdd56d9a3431688c1cd592489a1b6e9f9700b37ee410507a525f9d0fae1bd277836358de55ff3d0f0c113ed7bef79d662a13d77a30096b127f65ce1be48de7133901336e39a7e7e5f7fac89cedfa24fbb68f30b9b86e58b87b928e9ec2a51794571c74b99b1adca1d697e2af3e32c78a5bb05ec22c810c48aa7cad16049e09faa66ff7c974beff14b106213b97ce3383c24a1f87eb977b21dc8440f6240eb55cff7f2c133b465fcb25bbf8478843e9a34f9bc1c01b4442e4536e69389588882cdfc786a6774c7b9f0f833880b3185aea722f72deef5590d8c53f95326014781f9bef6f92fe9c30d2bd2c952ef1c1f905eb144d7d0e99fad8c71c114eb8196936172cf229d4665d618772769317c567cf001522689baecb3c7309b938d1e187b43ccdc1c27a3be613743f5256e5d217f23894f02539e5e6f956fa39c7071a57b10632b9a253c9b4f8b80057852bcfca6114af4e665e3cac4460e1b2b2e97340004f0af8ba80ca8eeb3ec28ea0c241865b292a39de6f49a3e4bd5a48eab0a7dc269c5fefaeccfb8c8164cf2112284b90406cb01b105cefc145a9d5deaa53209a21266b8782d3fb0dcb283ca6095eb42e6ba8aecf7fd2fd21971e9fcac628851990b38a74078c824c25d95b90c9e94fdebb8a9b2877f871da8610c532d7f07cde10fdc57bf29630932bc706ebb9a526853f6c9d3c06e2b2ffb380bcd5aed5d6d863b4f9307e44b15a514a2965b3f0f4ad04e581e040f78e1ca9294b277a4a2ff15e06f2eb09f1c2d519c6ea753bb2e049d9137e03d9b99719735984cea939aef26b88eb67afaf437c2cc08d4f0e2216843b4a6f72df098270b1ec04715a66521f7947766789f82f8e6c69d3f19d88870f832c37d0b3d806508706c89b98733eae344bc3fb303154ac519f2ec2dd30f8daaa85ff955b814797fdc7e81f500b9215d6877488794ea63cafebb0cb45c8437132e7c5b3cb893be27b740eda013a92cc70d63d904beb56d4d57d06de66965b9448c5800ab4b6d1458d87815499583df240931883a1b7c0cc2e9c4c97b20d429c7b7379e5df2fbe6d549d9d5772fb36d1ff06172ae5f7a12a9c16102098bf8a3da6ec7359be2e226aa80a8e0eaff8e62fe4c952a7557afbf4defcf9ac705b53878064fb384f26b3eb52293fc1eed7cc49dfbaa39bd70db72ba66636937a9a51a4c7be03d08d7a9223be5cb31cdff4b10e16280d5054b16ad4605c02fc90ce9c07775a43bce0f55afaf6712cfddbf804237506baa9b91e0848aeebc379fd51d66ceb6027f75764514a9bc3591f3961955463ae1e7184cde2c23f18b3619741bc0ef9db70562da23621e6df08d99f72af85706407fce498592f622c4dcb99b1c89243c291e762dea7e1e9c987722fd33b12c0eea03e6604df99e58f33be014a9c8a83a535047052c92039cb5028ad44fe9b3e7899c6ab3e7be0e1405227075ac697c590aa4fdb793faf261510270ab74c46c45b33cf442c91ca0f24136385ffe475ba606c23b1ec3f88767ac7affe181707884ad6282dd6fd0d6763cd7bb2826ec0926b9590d402d17fc63e413dd570ea9e04ce8af7c09eef8728aeaa64077da0145de2c9ac5e4611099525e3dfbbd3c73fc31545def5458f6abe17989aade90fa264f2380a477c9c61ba667eb52602654bd185a32673394597c376a85b916070d599cc94a5b5095f7b9b134c92a38bd62151247d96da0bb66108f9aae1deb112baa644e143c69c2662c2e23f116f96762a9e38246f5b666ee89568ccdcee8113e58b9f4582dc88cc951694615bd2ca96f1838e5283adc1bfd6367b7beadcc924584bd932b58808fff81ddc4b8fcb8594c14593567e4be59814c301b610e149819ab708f1025d88b5aa4db7f1792d0d9f6b61cfe4cb219ef9740a8b733ec2c65282f9356a2d3629cbb206b09a79eaf5aee1cd1bd8b44d59730f91fee5358277bf011cd286d21b6a495b73925baa6600e6c62e8c417b0640669e8cb83484ff67a48074cda1e9feabdd92364eb015a3051db33a5b63e5463365806c596e74b62dc4278731b17bfc9e14fdf8d109ada71c24fa78735515f7ecd2ae85b35a5910b449bc60876d4026408b9c29b6598bbb244420eb1954ce56c08cdf3e1a1ab892c29873c8013a1fc7f0e7ec91e64445ae40f317a56e8ac39df411f59d23e9e0ea472487a2e8b96f18caa904d92b18035a32066a2cbabb698e5e8edd4c069d2ce468309c4dcef2716ed33601087d4852583dc9a2ef8d3379849063c713536ebe156e8eba6d93766fa3d59350523eb3ca30a33eac8d2e712270409ed7ef178aa0f883fbb3dfce2c22017ae2055b17dee5f2c06572694cf120fcd479419ad8e0b894f64c783fec75cb4028cb5fa7e025e4a714f3eb26fdcca4e2a88895b9d28a28843ee621aa7b530db470b22c5d326906683328a2724b510a22ce1793ff5a67fde68af2bba084b456d2c9a668b9861b071a1178648e6ebca0903a5d1e57b7d6a29b4d3fef04f65bd50c5658180359c467aed1a1e7678bf627af3cf26bfb6aaa9ef4f201f6b5aefa17cc8e132286f732c8e0210eb5533f80a704abff6277a1d62e8a5407e6be9d58af6d0c2cfa1d9469e4787aca15c55c57848e9e0323f83ca5cbe77313c22d9140b1e9bbd0c575ba51446dca3eb5ab3397b35abf2cea776e978926012ae0a190b64032e8914bce8e3a32b3800ee4037c5993256b0e888f2f7ff94cf00d5e484488c0c4d4ea555a6c671f7059522bccc7045bb62220c5e2bc9dced0f8341d8b1b5d8ad0fdecb16d2f737d313ee35133733b6d8397d07b88616b6dbddfc2d0c2367c7199b31277744e4a2488e071b7dd0ff9722c8f9e1c1759cc8bbdb377bc60d3b961023349ef22fc063e01fd21d182c29759da4a5cf709e1c35afd2ed670bce6c1e30f0c206c7277aae5f8b4316f511dd58be18ce1fb5e6b0bb619056208bb1df147484049f5eaff2258a514f1a7d56e06ccb6b7832268ab4bec65ddeea1453f4cffc2608b363a168ab82b82446514e38ea55b7c91aa8ed76ddedaa52a6e09dd89e4629d7cfd4dbe5e5f0a71eb80e7694ea150576fd313c2a76c5540f2e7f73fe361499541eb92a3c0e5327a64fee96d0fc3a4cacf82944c40a42947c9d0192cb3a984bd7e694907ced8480af90f675efe9a0d6faed056b9b14fd4aa832fb806b7c54cdadd0f89ef5c67a29c19135976da318e333d8b040bcde3179a01550be8943b467374d857c47776e6f7a0a22dfdd830e372670907fb306637a8743fdef965ab908b424fd2a8403bf6bfc91a2eab45e2f4a570e32694804972552d479ca7fb6d986213ead62041d4dd306927bc3b3bc09ff9cff9c856c240b5e7ff5a82cd8c332a39ac9c75e330da9940fec284701176255fe37d34145227ae6ffef715b76e6a47f5c384e6341ec735cbab87ec864895b9c88d011a2f8e3863f02892ee070e4340a8875264b86aac179e8e5cf5bdc7ade5e6b6e06b9ccdd4d493b72ac14d76893c132e10d4b2449a53f04c2dbf09fcaace99da19a21510f941a2269f0f18a4602d01d749dc9d4310866398b52d099762a1ed2963b3d8b0efdf9cd2b6c15aca9733ad6781728fe8dae6f882a9a300cdd105ebc563fdf0fc37c9dad914fa1828a38b9bce31e5d62e17fc7d48ed2f466dafeb669df57eb36cceadc00bd3bd3a0a2a61228ec11970f9b07684536c20e2e234f89a10a1a3267c847e1e28debc1ab4ccbac9fcc9abefe032a31f23bfecd784071ba1c4a3866067accf27c0abffad0c404716a85e293c611a0ade1a6a2cbca3339d843e932997ca5a3230b5e4bd3882db07a41a135be52cd7c23c1751f291d7d4ff3ba9fd921350c41d9a4a39222964e9dfa6ed1bf62ec10b9ffa3766cb3ba70a130cd6cc5b1535ec3f79baba8fd2fcd65b969adaaee21794bce50220d37dc90cbde6a24e97075a8e798cb591ae4a9b0233d181f249d147a6269ce456f450f01d6b708ade16885af362f63ab0fbacbe1804eec27b89075a6ce979d1d58eb21e10076e205d6c44a1a4511309e998b586a3c7bb7742453a760b34dea17c758fb23115420432ef09f532fd0befe668a324887c93e25a5c7164b641a6dcaf40b174207bfdd03b45effadd4a66647879f3c8a9afab03046421456e011dde0723c3bf61cb493abb721881bfaf561043fb80e2e80b0f37602b217d8f9b3baa7f3335bea33f468bff812ca55cb51bd68393ef8db9b792ad07bd0e4af2d52cb1e6e8b8a7b29089cdbc94d4e02c1f7b0ee0a5d156f81b45d4b2994fc9f3a8da5488bf4d68bdeb660a58f230e90f3f9b5027237c4b43ae3f9eb0dbfd562619c669a6f6845eee5ca6d6349ba2ab81a99966c98ff6ad2e9e0375bcf47d0d11a670cebb4dd135649743c1ccfcd8c75f1ddf28d884e60e250053a114ef498ea41c48f49cb789136fdb4859cf201e8d557d42546484f41cea3f1a4af582b3754a6b88df0e1dc4a97e1587f1a2cb5c1c1480a5e98d1ccafe4030b76407e2873bd8a847ffaaa819f2e90e7bc9f5b83f67d94d65181228f93282721a9f3a612d734b3b97a68877b55a9e5f166eae752158eadc748f5bdb1a9522059c172011017c5390d9e08b6ffa7435fe95714a8524a839f2343ee42f3bc8394f8b5c7534678df26f1484e21db06cb1881fab6b0ddbeef34120b61e0e20b68543cbb026799a15be00fad5009dd675c0698f99d10d4c741460fb9b6a15e95fd490dd8227f3beb97fd1961f88c2cfd39de770bffa7177da11dcdcc6ef1db73143b7d322dc8c7af501d5f946a50af6c672f23c3290abf860f7026551f766101c834b7a8b3f6f1b6d5396ccbb519367777ad21abdcbf7142faf112a5f877c45d2d37d95d4cdd93261063b21b4fa558902007d5bc5b0982c8f202318b018aff4e6de84ef659926c710ac55f2bbae3480de619ca75c0d225998853d12f5968a49540c514532a2c4e73166be486c660140fc4cb4b2d129ad02940e75f3daffece73d60c055f856d06fc9dade4ab6e0ea5086169c99d6017280cd17321381d796ca5c967d02d6ff84a121c722c9d105540e84ccb1b6230300f9d3950c942ab37c1ab522040d51226bf3d909676c1b83de6c71ae5d8d0735fb5b07ae3de7554cf4077b7aceb8021413fd1b490c63be4f041c9b781514eb20d30d8c402345468a5e8e398448f2aa3a58ce6fcbcbc3ad9dbb6f420c5500eae8404b2613083de0130ff72961944bbecc62984d8b2c6d4f8f4413d65e8b32d1095a383455fef00f30987562f7026846457ffc58d3d13637b9bcc7651b97616823dd51d1d3a36c081276c62c9959f4ad0d6f05b951222b5cc297a77ab25e8e00d436de35e7f7d5b44b1a02a13cae0d51dd7a2c17d9675af9cc969b21ee4063974e963dfb888ad16c404077ebcc856a67e0deb4eb45893c358e3200ad4778104fdbf9a80be8a98f6e4febf89be49362ff1f0c91762ce943d6d1204054267d552b2d27938757c7c4067c3b3204827d6a6e85f16c9154923726a43e0021fe03d1398c6b7c6396f760c6d79606f6473c3ec9564289e8233474b54f397543ca6e3b9a66b5e9b1117c8a8d92d0fe47cbbfc43c5a447e7be7fac42d969bba07ed14d81a5750eaf7ba4d6b7c2bd68ad394475c708df6edefc19f3c1f5ddd7fc7b54e9c5879b3d2998e458d19bf60ecfb9f49483fe2043c497ab5e508c7c8e96ef83747bd7de0ad7f881730babc999e1dd93fcbc62a0fa5012ac5b9a6aef5d2234210c24bff2a5945a0e14a09828ff9920b89eeae630ac5f847db99ca671a2ce907a86e6c0ffe1c6dd29f2fa242ad3ea886bd6d846a0bd6320900c13cd08a92396cf9dc5604cdfe69bdada8e521ce9884166c4277a4162e26ebdb23802248f2218369faba95a45e8ef8ef5425eaa3cd580fdb37b6b62036bc47cac42c8bb5ddba2d6c041c6d9da9b93a7ba989cc99873d47b73ff8010da6747e5bb3f9682c850cfa1d04195db9217de620b12f24d314fc6ce150959b650fd8606673db408ffe3ed83da4e698acd45e9d839a992d6b4c2b04c16d60837d71eb1f069eda47f85db9e3d1dbbf15085f3dec7369511c30115997e7329865214c6ca63e2aaea17833989167629a9f6e2c490ab0e00e24a2c209dfe5e49c44a829145560d897754d8ec9963e4d6cb36d34b8b8b8eef3951949b11c6c4944197f882cc4b1e5a32b31b61a0e2ea682eef25f6b1cce220ec19d9815dc945fad6901227ea356d54b956c53f6d4f0d1b0129e9a67d012fc3003f836a6c18d3517f8b1944f26df569c6bc4455f83091e637eac9121fdefbe1b116a462fc845abc53df160f82eb0dddf242dbda53a6f3c9196c4be30d8b977a060a6ff4db415472c58f96678a48c3c09c5f9052b98e8df1333adac24f8ac97295419280fe34bf08c34d247a5121ccd5ea02f09108258fc440dc56178ae1c8f9e3a6f3839325b4b85b831a4798f173c545be5a87ba1db7661fcf4b3e17efefe08b21627666a4f83525394b0cc22367ea93fc03125605d982ea5d127976d499dff2c79f5af6f7f925d698d9aae610a0dade342f801081d46b14be5808acfb1ef52247a271c8b61f4f56e02e1ce79e1419485cc265283cae3883ecd08e2b9e24f9f6b9f9bd223839204d7c8a6d202e819c222165443e87a562970a215a8325b57631298e6ac553c21697381b7eab708dea5bbe46d494382bec7121c81a3bac7e7cd258ee992ba37b51145d7e60c742ff51ac77bef5ccf351d28eed69ef331df8668990a3c09cef650d75da0b78b6993addc4bd8340d53eebcc38532fba026ebd80f4178af1a227d48fdf75e1244d4c7289f17737ea567c73ed64f82f98631fec6ca1d1a07d7cfd74a253d9003be6c38170d43e1f360d9db789a7cb7ba298fb47d647c8092efc387c124bbe6e8d2d560fa82abc0df9a29ea33545abcd4a48fad8297da7876b710cb589b7fbfcb167b2e52f1e238e256e3708989f4bcbcaf4e90d2cc436518bbd26ec89365f28da1b13d6ee5289bdc5b2a13337d10120058306492002cb73946dc78a14d19297cbb96acac75dc002c7b193f7dd5b2205cb9c677dbc8dffa4f8b31db73b7951e3184cd09c7771c75359e76c2e550043707461b489b0376a925e40c0c76208f5036db04ab955222fa0e8452611c5a12a94592c664a1b15f8e3d1d835160e24c54d0e999a22565554e39e07b1c967b3c084bda774a54b912204785c0656c8033c1f1f91ec8ac0afe15e39dc321c6b7c6059a315b1c8f950941de3a6289ea3ed7d9a96d840b0b17373c000b8af3de567f4e2b810594579f4ca7ac2fba054bc5f7fc4fc889d854b2c4eb736f96a9f71cc21c92d9747269f50856b5259ae9e57b584d13a13b1ae79c71d763acf1c4d01c60b0c95552fc7e3170e5d29fa99a60ffd5327765aa88e3a823e78ae493ae6ca77448846aa944c1a5b0159cdb566f9b09689bb2448645a955fa3898b293035f94dcf303c8aee5cca8996dd59f2e33a9c5ef4f6b30ddf1bb3cb65b962ae4e4030844f93597c617fd7801ab9941945aa8864b5bfd9656cbb005066fe85c77ed800d8c3e9781ad222d1b825fe12a790f54c1007255eabab3911841c46f5cbfec8f07f5fe5c9d2822fe11ebdcda59a1485e9eecb6e2d32e3d25ecb89f0b8297afde8176739568da2fb965d497a6fc46049a087db2a9bb288b6b02a589749775c9d22d3bd986059c4203dc24b1e501c6acf66a9b8e8434cba6f19c795acfecde4ee72fd9002fbbb8eaf555c445aecd71bb2648a7d52e19ebf8e07ed76f9cef24e312999d0b432f154d32f8881f4e3b994f51d246c93045f6a26818b9ff1497d976c06451fddbc8d8c9b833d01bcddc3f06de1305d6b3809c454af45c2078ac7dc01db406002b1ba171855af2b8ecf09fd480b0cc439e400133ab3aebb647f0bac1cb0d3a68adc192e970d9a45200e6b53d0eb39f95d9752a4105b543ed338b82b0d92b14b79f61d337882eb23b3b9c158914e0189e13f085c80470cbd7bf1e4fab0a82b8823a7e0f361d88c57a9afb60e22aebf8dc062852322898581f2c2ad542e797972db80199ff9a5aaf0bdcba8ba359078097e684b8190c70f82bba029d6506e90a335d610673c57569c92379ef63b4da4da80cacc144242903fba299b70c9c5c04374fbfd145ba97397562478e0fc81cb3deed830463ef303578d57a5379d33d7714fad414933af8b3584cb0c9a07afb0ffbfb34865b784367c1f74d7879b480cae85d307737f66edacdf6ab60efefa47516a91a7a60d23ccbe5ea3ef0b1cf0a657d3e322fbfac02111fcd8c7280792bb0e63b9a5cf1a5582e59e9918a84e945228bc4a243c0920ea24bd2ed47178c24a5d0348412797dedf2a0425d8912edb882f2abd3996f88df150a28338a91f9202b56e360b60be18664dc114728fe1f9634b8a58f04f0b5822648dd2d8a802df8f11596e1229b4da346039dcfeb238e1f9caf21b623da0295327c3822f6a5b9eb9ee1841a5e38afcbf589319ab5486c341598f15524becd89c79b10dc359548ea0a0458df1b27902570da353edc1367cd27cccfb131ab1b5d96e30f392cf90df92d02cb5692559949da45be684cebb178416b72cddb9ba7046301e75111025a3ed9813e64c599b3dd29d5c5459b1e0a4dd29c72befdd5b17af1ac82cc15740174759be4f7648303bcffa6d44d8ecd8025dfd7c44eb3d9a73202b9b32a8b8d261dcae204fc8ea73bf72925b0caf52859d222c791dc1a6de24dc3e3267e32c0806a44201d9e700a657eb0c3764fd0b0f6aae6cdb8fc6189161169b4bfb401782c4f1a8b58baafe0582bc2027b752d3d90af64a34a39f3c3345051367b0e61dc333af93e54e88b33b50223d53edc983cc2bfcc2cfd40296100bfb8114d16f17fbc9f518743174f5b3bef6b7ce733e3fc1cfeff4624f0efda3f4efb8dbea6c20f26ac741b549908e867256d6a968580c3264280951ca1de659007745ec91d10f727f4e01c4b75ef4db1f4acab93d19ef106dd68fcb60cb70d8fd70e3e265beabaf4833f21675aaf1c2ac13087250d3e826ed771297de9871e6d6639838d4fd5f05af3e1ec6346c57d477b57848865687420e3744abc894cc1be84b65f2d1935628d082f68140daaf8e3153768c5ae88f72a2fdf83c037464143eca2273903b115043557c4d6775b57b83826f6ec61b55252c48352fc401d8faf25da768760dbe430633979cd31c9ced0b13140f4cff0c68d543463044430f80df123f8e177dc69610aca5ab9f98827175cbc805e03e95043b68017dff0e6bc8b210ce987ce6c2a4269833bcde689b473e524b9c9aefe4d6b87ebb87e2a27271d5344c53e6234a8e872d4656cf07091492732eb91c3bb0f9d3333762b132af3cebf00fbf5ade9718c889e83869abeef02f5e2aaeb760860a7efc20ea740368092ed27506590e2c8786408beb8a6c5a01d4890ba5a3c91353cb7f41023aec0213cce6abcd4ed92fe7ca659def2684e2e8d49b62eba354abf423225d960eed902398ba9bdbff75d5e9c6845b57c8ff9901a4f383a410cf61dd3af0dbcca39d7536d6a53801d8e61a438dc02a5f3bd5df1734279a323b89dbfc0d0a55f94e4b6a8b8d14d3f79336142aa0032f3f069ce3b432fb3e5c3ccdd653979f1413fedb52158f84b56cafbbae95cd14c4817d629def5027c418df12a475960857f54b87e3aba3c8101d1c5e84a547d6ba8ea462bd31e3c965ccc467ac91aeb5fa44ea1674e6f42e6f6d61166d78426485c40e13d7f143f555a5b8ca48f0ddd3977dc27febab11dbb77063da6143f957bca0e822248536224499394a88a51436b1c266493d10db3bf1295bcea088e433f3f66c7b1c85b20a0256f70c3ddd177620d0003f3fc1640fcb50e3413f118bb64318fd29cc2a2eeb2331c60e1be8055748a6e570f15215ca02dc06164f3306a883a0a4f770b6a71a9d4e338ecd9ad10da5a6c93df72ec047063f187e689a9adca81d8ef6deaf660a6a2fa374914080abfec248a20b4609b75b158c119ef7c84991c603f2ce4245efe599475047435018a8e2aa4d2d631a50c169060203df36d32e3a22bfa64f7fb186ac033e8259675f377e62b316568621b0c76348cf742f27b0439052ad16ea48bd474b0ead00eee002c4b7a7ba58e50f8c8bfb06e521d55eb347b64d8091299333efef3ad64c243907bd123f9e53062eafacfebf535b4f77c2f4cd9b46fcc22f7daa9869f12afe788fb30edd03070353751953b137c1608bd9f3abe2b3cb7679997d19dabc4951cfb3e8612103b0ca0a5a0b99d044b67ce1e6346897372c076150833bac5b7376a38978b57ca642aa9029dc1a9b3b33451e4180606de9d762e9c4eed8a0f1db0ce4e9f046e0368c7a58f4b5184b302263ea8ff535aa42f0bed202c077d2f8c932241ca171fa71ebff09e55e76610c938b4e950ce19ec41a37c5a08360b49073c9ebd9cbbe0923e6050214acd320e66b55d85c7c8aa7763ba5d2c340204cbc3fe4d5dac31af7913809d8a7d1c58008604ea2a9d4dfc0c7bafeb03f80b8de15ceee8e0cc885fbe6beb5395ad06687b8c6c4ecebe7fb0c1d336ccbedf5be268198c391124b5dca8ff404ac71e5754a3eed80d8c9f23d4c6858ccdece2ccc8dbc0068a18795da1b04f2896cf0e6fb174fddb62d93b711d588a948e67345feca2d8816c36d4dc2094fbb0434c824ba768a004c1f756805819a7ebd084305c1f6a44c35dd2347aeee4e02a4f93f6691190e6f9e98699b43e4e6d59ce9ca11cf8697a3277ef862343267819320ffa4b527ced7b547a446e9dc781de384ca4c4ea211d71fae51cc09da4f8454ff92f9a86f65b8fff9afa5ccc5928b1d4c277d456c6b454ad01bc8d023abd96e82c9a0a105f76cbc3b9e3e4b259bb1f6388133e4ccf0e9b687f105972dd3d41d0a0ecdce8a846911c3e498e72a5168204aa87d94ee47bafb4457a318dcdc81dbdaf9dd917b67616004cea30082a4f4a06a14ed2157c00b08d92b8c1ff7e9c917c24633","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
