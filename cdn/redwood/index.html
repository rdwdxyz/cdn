<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de3863823100fcc4455947f467474ec4bf0cb1c7c40d2ecc3116dc5fc51e65b3207e49a87c5a3acc099444932a7d3ab44f1e37e27b4627d2597d7589c11256f9a15e076e151de97d7dddd812a7aa14b2a519fdb4c0eb9f5e77659e4fcf84bca6421a07f60088d33913385b0f8a8b7004bd319d0a4a1bdfd9f660fbdbe69cf9c0c4ee9519626771743d03546473b2b5684dfb87d6be56201d34ee0fbc44a0cb367848c20f1b01f56200a44c0c028fe3a506b112d4cb94b53492df0abf1aa17d06a1369daffa7ad28b8a47695a33e171461048d4146c8effb511d735400a777015c14990f07b8d31edab1f6f115dc36dc91f21f69853f1c940df4f0f79552cb1749bfa0f6694f3ffbedf5ea404b0851f4d86a7231306cfc1b0388137ba56efa9d8e03160ac018d6116b7800ac1fde415ccb7a9d87b168033d559c8078100c883005daf5b39842d06ac9b5173e341a0761d5d17fc001cf6650b5773b8c46df019456cad4e54d7110e547a186c40e896ca8f674b938d2333a877bdb3447a32fb882f8fd3fea00155364d9a170d8d360ba7ff8e38e70c582abd927a7538788a5f1d50f9f5978b9f4d33e08c5095e4bf8e601d183339d78d865b0d18f067a9a5bf9931eb105e2f172e249d41ce9367a95b5bba9cf62c9821538ea641c8ed257094390ae9066af463f5f79e32eabfaef992f0712765b46407b10266bda517e03aaa5b7ada38384516ad67e0e76d61c6ddbee5837d65bae4a93b64f056230e657c02c9eaefa2ca95033a87ba6d5052273071e1a25bc830fec7ee14e231f7c151c335f2596e3ff7e0fd613e449fda23ca507cef80503fce7af80ae166e743a9d14624634a92191d8e339463c448c1db80fa6d766e07f304f4a3d19ff64a2702fa51f0bb7ad2899c4ab6ae9fa7ad51c3fe5ad9e29d3afa949244cb4a1c3c05f7645b286d3a05269b7902acd7bb68d4b8978a937ea38a4b93a4e7d938dcc3a1a81b0731c719e96648276b7c866eb54d90ce43c6111410f333db2c791ed50df56e489e9b735fb0c21d1b9544734887d104f3f31e77b63896703e319ece9a74d4093f24d1958da64f9613c14e71c1ec4ff0c368db63458bb65b501f08547fd46a33407359472013e025300af96b84f267e45bfad65d4f1b1ce8e1309886aa9c8259ced32bce8ef20697dce53a502265b38d4cf938da0aae4d92f554e41276cfc9a8ff47ec71d5c3fc055acd2a85323f0813d863629e0f925066d234af8ffc7bfa662f0c2a5333b0f79bde390f9b5e1e14fded184f683759b61ba92a0cb0e11a74bd58b470cf5979cdba61ea0dda8d219618fabc9ea0c66c5f6a68b98bd4857ea0388b0b6adda52a7b553fc6cc631b54e5136513a077c793a7f636b6cf8edd28214f2e3ba6cc5a26506b488125e72870a415763b8e0aec8a65d7e2bdded107f9c555fc94d932184fb1858f781660f561ac83321babb7fdc8dff8fc46bcff9138a983908c8375046b30f83c59d8beaab4d40838a8655da16c6062294adf7729140b1bf46a9842c67d322de62a09b695df0311483d3f6c5748098d2887dc46effaef93f6c783a3149e95e6dd4d7afadbb4c5f09975348bb545a9b0b774b7b7492d74c3badb842b290b5f64aff9fb2e83f91ad4f2e41e58a3bd73a92c40568519113906c7517093336d12f4262d7ad26bb82adef1e4b98c1012dc84c55673d8e23f956bf95c0db74464dd09af87fec02578b0322999fc26a75140008cadd008145e72712031ba5cdef9951dee4b56b27c49faef350ad8492a54c2b3cde535173dd22d282a1c4b337ba68ef1288afc754526df3ce31115f59b9a3282eafed08f3d39649df668c93043d4475f9286ddff439697d0bf77685913d0c6abf96cf38d1c2907890b88aa29cefaf54e24e15fc0b9eb581a65e8c8d6c50401e51f647c3ef97557366b08d64df1d92b1d61a3170fddf2187a7df1cc2c923e3a4380d700ca670a4da1de686cbd81eae1d48a251ce73255b2d3783508f48fa2621fda8de06f17c67039d2c8344d397329cb687cd11c730c6f7f9ebd86f5b17b1441fc45b13fe023ae454026d3a65c9874c60cd041ef00c9f0700d73e0936ab5582fbc3335088d88a092ea6834b402b20e1757d3ffba52df109b809a1e39f2ad328e9e1aa67f0034dd95830e414d9f8eeee8c13fddb115e20ec280774f90283c652c9ca60406d38be07d52ebfe1a7cbbb611ce29f8645442b746e76286766fc1ea3eeab8c30c424ac833fdede4f5a6ca6f891176cd46a7526a1dfc7c46ba06edbd69a4f38001e7e25ff523ce47c40ec4c7c6a43869a901a6caf6dd845be3641ff994562a2b10a1a47ea0a38d4e8458a83d248864cd4a3871aade7c067700df23aabcac3e77d68f304bc82090b663aae2e47f7f590845a1013f43cf86dc1f644360962e2353586bd9a0566dc1184500477532002422b0680398d9c0f7e9fd0981e446a574785433efc441d206424fddbfd718d2cb4ec231c01e5a023a0c9e263dd82a309f8649535c7c7ccfcafee1615acbcfb7ae340a06c077a7bc458dd7655ccef91447a12abec831b57e2a9c2b5bd620c2892dca0eba02c1357c633e00a828626e234c06ad68b44c5277cfb211278ac4dc18b5152d9f3cc4bc5260d07468eef399093f1c5ae28de7aafc7aab51bc4cb29b0179754a621a7e4105c67feb9e59fd76f55bef36881cdb65284304e31b8da98aef33fbe59994232083f4474d27faf3924046ecc562560f8f1d4f6cbe7726b3e529e0528dc7399a9d8b4f26ea38730f33a68a3a6266c0d9448ac01f08de5c0d9fd867cac977ed44755f4cd7df0ed7623648b05e9a66704a8b18f918013d1ea11e4962ff19247af58fafb3542064e70a4e191f4c07ce4a4651c8119f87945ca876189b9681ec4a1d964ad5b7df77dc770eb50f61f8921b6309d4131bf788aa251cf854effb32609a2f1965accaec169448fa14728ce6b0740166a62fb57be6d0b16c18dc3cb0192e0dc401d29a0eb9ee0cdc5f7c5b2a910ad813ccbf02ce54b25fa30d5ab6329f1a160fbb7acf9a6236d94c86e74c9c2003978c23c1e2638fe3310f9e63fa230ba5d7d6db53291b769df16aee77e018a87c6de5e2085bc4ce3a2bea83187289b3a35f597ba1641e0591d69dc0b3eacd9dea65b96ea4d06bb054126ae408de726036297a70cce3799b915b1063533347a17abd492a2a0786c2f465721e7ed6db64b86ec2b436379c29c8ef11e4628f8154f23be09fee93140309509613108d6df1a46f67df17c2061a40f0b01d0cf04882646ab11db94ff1dcb7188aec93ee2b4f13f773ff8ecfece64caed5ab3b6059aa59f831bba0db52424ff00ee565a73e5e9a32f29a59b83ee99a6af1dd4c4b7fe6ebfb9c502996e014ec150c2349998313ab9cfe375942806077bb759a2a80cdc94a1b2fc0f7451bb2cf8bb91d6f2c7d3f5fad370410d7031e2a8e4d55fc4aecbe928748aaf6df0c87ae9e732adf077f4b80199aaa239f52622e61f8805c49e5676da3c74724c700a890bdb9733bd9fa16bcdf0a10f95941a57d2dee15b17d8e7faa0645bd12d2c5ee029188d392102159bce7bea1d9ed48aa47d502c47bcad979b192d5a83394c798a3d0f626ce6e568a01880b8ccd6d3c5bf195bcf806ac685ae63d9ffb4ce40dac06a24eb4e831ec33bb832b3d7a0b237aa9d3ca26751b8484742fe86501d84c4b72440ab24063d0193238546dbbb3c1729f5efd6ea0e5eaec87606a27ad9e860f3b5fb162818a1b9aab2c84546e24ce38ae6b344fe3073c1a91693c954a3895834e2b018f48522c092d21429e65b1d93d64d79b0e9ce1fa518af9a35278e5ef27de75ee6259618f427ddb07b8cf23f6929413b8e18e33ec4e28b4d1ef2b0474b57a53c70e589050371b1ef3909c2baca0cc2e650520a3421e17aebc6212d65f467f2dd56a501cbcd6f3ddb1faaacb6de7c1d644e3cab6947c44f9984a274823cd4a88d53c07f209f2ca1fa5053e046de70a7a1f08acb94ff1d1bc3778a543cd5117d0be314c9afff9bc4fda5225cc0c61e7b1d91f21cd1b9b6aa8b753aff010b2bef4a7da035b349cf2813e8877b3581574fc50d4431b2cbeddb3d266e505fbd30b9cb66b99138cc0a6300825fd75d5b86312bd963b0570d5e3d73a909719ccfe4b7927bfe82a08c7d87fca69f8aec18e830fff6933837ba954b4fd9bf3f7aae6523a712eb597be8e9408d8baf98a3ef65eed9c0c2de2655f97de5160388854f4906ce7006803354eb7fb539ac7fa1814ad78620453fc9c7e4190cffe8499bee764a7ebe43690bf058a7ee4c03f44e450d84620e349cdb32273eb7f16bd0e63075cd22e5efa0708b4644ef85f361c41cb010c819e3cea57eb3e95ac531c8126c605bb19f9d00bce658b87b3b02f0c775a49a43faf7cda604aa7f893c99e0e8efcc50af6c7c8fdf5c6ec0358a5ce9b3c426d1faa93605f560c04e36b9395c2d62a8f20861439a4e9dd571d91f5314db083219fce61cb2a1f2f398f1949fa7d77a251f5c97b88c0ff936404af9c711af7153a6738714105076eff2f3e80fa13f4ef555d94c48739006d79dc96fc074cff4f8d8656dc7748b0f56e0074753ac907f21c3f5d1c3dd4ef7eff577591e24148ce6eb913f340ad2298d4ebeb61fc67180f736111f20f7b7244d122bf8580f21e55f2a7ab266c06fb0d9d35ea03bddbcf35d281f35d2617f1b097f3467b9a5eeb43524b69325e944d89fa5bc32872c676e837878753db176c4d03bb9e7fbace5181159a4f5197f69653e1926e18c5fbfe7e46e49dd1426cef881c7408f5cb60c1314f96574264f03ed03ee374038eeb633f0ffc23e5c7f06f4876b2e84532724c66b0254b4f3ba86a9b468b3ba91044bd2fe1a6f34778bb534803a52b3f5b41f24a4acea5637b5c3740ca24b070d06aa91b4ecec53f2ee5c14b52b80d3d2e2599e5c7227d11fce1a9651c4da1bd2b809ea2f69074d443c2dba3bda26ae95f9d0c6cb647a401477631f051ffbd74860e9a3d69c2adacff6e1dcb70b1638f02f0f44109efdb5b15a3bdbab4ecd957479dbf9362afc72b0e3f49f7756e853ea8c52871213d13586ed460e5c645fbfdb739141917667cef797b55210cb543cb13d154981d1cfff839bb9d3da42ad7cf0935f5b4d9ba3732737d26a195e7479429301b921c48a56ab250b7cf68d6e924b19ca805ed3de316979092aeb1da806a21693325bf0c5a0c579fbe70074fa06a67c7ea4040c469d6ecf93b6e687d207f33f8d83337d53af403285c67d9a5e484e4610c139d578e5f5ab108db2da78c7bac780f2b01e5f17727b3b4ac638fd2fe62c63546a82d87df1cee446e7c78a8e50e8794d0d3a9df048538438186e9f7f0fb8dc8ce2c09ca8e35f7efd0e2378c386790f5ba466f1f4a680753297921db9efc0d341d87caf6ef4e93579ca317d5226644f3c2598b7dfdc73115ade66823df1a198ad0989654f4ce706b5b0f728264d5b23daa457c7e40ba379346a076d11834d54e4950663d8bae48a67178f54dc8b6f1ff33209769699f5477b39b2554f8df53f77d593009839b7ea765400833c7e460eeda22a8d8cc50827ab7f050bb05fea00e63ff3adbace03628eeabb72dc7907da27893079181f64169da016da46d69c6340849e6f8a7c76c7018e0cd6eb6d3a8c42ec784e171e53ce039336f12864801d00ce06284e426fa0652995744bf289494934e93bb49641050fa8eedbde4a234ed03d40858341587d818fa07ed17421f22d4af696acaeb362812b6b27ad03da698fd8eb0efb3f6637b50bec16d9cbbf87c07ada7ccbe1d3d65af9d87f9eb1e2fc87208f3c0b14e6c78a968a4c44e6802e5cb7aac904c9aad23cf94f5e5cad9895caf3976bcef793a641c4882ff6f02203b590f279544a00a4087bebfe0693444d26b57583c6f8a42893c2d35714b23fce4d1131ed42c609934ced5a7bba5a8be1c329aff7b09f54bffadd7d9037b8b79c106561ce3f426cc618ae0ed279bd5a6092651ee94e99579086aac2bf9c3e52417d03b99c6d48b7e7fa582c65f9b80c978891261f63964692582b395726f73997002ed4eb269f2d6c73f241e9986bfcd76538301e823a40b92cbec4a97cd5222cd9150747a3c1febd54866ab5b46fa9fa63babfb900f5170fa41ee36d384008baf0e5f5a47455d30952ee7143853cda4bb0d5b09da16cc2eadd034dbc415537a16aa53181b281899dc3a48c0e22cf06e6b2335195c2da7b590a49706b566f9c76eedd2de1407f2ddc6f1a7538ec6b163c3d18ae57a7cb49cb47e8a9a4bc098f35554105ce823c125bc8c6b37f7edf114491d7921758e5e290833124a9db29a0c90dcec0fdfca8b6168ace350e863ab9c529114ac0b3c5f1ad4852507cb38a6c249dd9ea0790b21a5c8f0c8bd0a15e30e339dab3142e9a7e03172b37c8b108ad1be027aedb476356eabfcb3f7c55a635b15eb38c7e85de698a5cbeceb70c0b67708f57d6aeb9c9ccea49d05fae0dee234f8ad010bdd0ab3d99daa5f3494fd9a7faf6c96a1589dbadcf44d301dddb8707381b57fbf752773a5d9d7b8dacf90583cd3d7d019953567ba44226fd0508bbfd6f9d3dbb4e3bb0c2e5a1b7fcd2ef5587c640f430cbcf8392f68a5ae9af97528cdcc2b3c8aeed32da80413d65d0f5c203e90f6dd22b5f764e2a502ed7de05f1d06184701be43531c1382089b310ce518699694d7dc27a24b5d3328f0f3315fe17ca654433c40bd1187a354eb001f8c3545210609156d95a90304a51b1793bf438a231ca08a54183a1259c2bd771bbc185031023cccbd09abca6f66aad39338e7d5202ce5b83afe15a0d698ce3df7f36fc2622edbd3bc1ca0ed78a5a707419e63a01e5c367c178a56e11d1b9be17a1e8aef982a356e2f9a31dc948d45e5fbcb7f46ae7bb36679154b22ccaae81b0f0b80bb234323e190242cb680f4ab3a2eb295ff5869ea7cd2a9f431e98a894b226f1de43ad0af9f4ee98b32f27a84a8d0247ab33a6361db099676f474143d45636edaf456e3a83554425d5236cf61a05df7c1f8688ca99fc951f546d3b32a7c59b40452fddb2c36617d926ff540bab5a2873e699887aca59a9a1a85dbb5af8e5aad644912d030242f43d7af3a7af9441e3399c6da7e035c628f61ba7d5c94f5165cd6e8cad3e0ba3338a36a38be2be47156a97b47fe03caa7e89e9c87aec2af84454510c7d259c70580853f5e4823ccd10096ee7012eb91c676aebeed5f5483cfa7f41621c4074b8766e1d150a548422a77ca7af0f657d2fdd8c0db035ccffdcb76bf794731c77e2e8b432d6097015e875c2b3be664e4b5e91fd0a420722c578b1cb18efbb905874403c072c824acac8238313de2a1008730070628b215a2c743d14bc1006dad04a2d564be31c72a6c9ef9a92f231e87e97f2668d78f194008af8dacf618a86ac586496fb765c43c14ec84ec3f7f4001c18ebea62127c679992f17d0a8c611ea7f7f7b37c551185838b8f3bbd859e2bc1f26208b8343c460417c28cb33d995b81bbcb025e031b8a0562bcc9130b83d41857a7421c93d98131e9836109f603618f748ca45d11a239a9d3a0c0f1b852150fce1b90c68cf366ce354368959785e2aa4eb8dd37cee20dfd33bf536754f7cbb67da4b5ac16b898981981f6d83cc13a94975082f8a9b7ddf9fdb23061107691c39f3fa96f42a373a9ace41d07a0f60eb51868affea024d7f9b2af94674d40b80d5f39bb220e886d89ea08fa9d0941ac5320d32dcd15610088959cc0e156e30546e5db5cdd2a57af1b2eaa44a34e7da891880f170cf1daff7bdeea9b8b5cd8d6852f694ad09eb9e81fc394593b247d9b8ca773052a6fca21f11906aad59d46702091f7080563e08648d4b91b601cce81724099edf76fa365d8356a193cbb8351c8ff9f485fbfbaa77fb711b2cf2a45058d25b04445020b4293e9e8903f4da48494969efa99aeebecc5e79ae912aa61d7972b1142b46183f3064d5f0c37403691bb7c7d061873ba348818364c68e1ccdf1d7e3c3c75a7e5c0fbfb17b502f4d134caf260561f3533b0620f63a589a2b3b771ca6135f1bd10b2dce8d2ec2578e3f81dd9495c3aac814ab64cd5726039fd6ea744ff9f50e88e6ad5c1f48ad642cce99736777ebb8a9aede8cd59f3fa13e9e02cdbe92b57ba31316753e16c6660b12fef29a573087d49626fe91bae00260e755cf0072d20eaecee6ad993f1e6215753934b3316fd630bfc907a0054b114184ceaa4680c2ea75a101ba77f17b6bcdc3275abb756baf7f68b1a584d2f3000eaac111b49c09746de72c653c2ae66dd700aae60050c939fe6ea79d81e973b1aa76a72e60f534e5d7d1c454c7bf6f981ea3526d1c34d033916a2123b8086b4ca042694526c2643b02401d78607e349ffe0318992bf1f4bbd5192cb772c6f3dc3ad6518b579f2afe9f233c9898fadab1d20e6138dddf6dfe38b350f62da49d6aa8c8ff444fbf2353279b33c6030b9fc55d4678fd990b8f64088407cffdf9dc2bc00814b276da7bb6d3203c25b65816bdab671f63b2cbc2c02cfa558c4c022f572ec9a3477b03a7a0819dfa62f475e32b063989d9c873aa249843e4c67538c2c9bd89dea8536849ad7d1238b98c4c970696cffe7c28070fda93345b311eeb8491170baa959fa9f26e0e2ffb4ca74747d29a3994206cf2f1d90712189a3e2e922b2a0cf61d1905d0e3ddbfe28fd08c6b126cde07c2d6ea96be111b5ef78cb0e593143dcaef2b495e2505d36e1a4cbf36cef9318b16ed8fda3dfa8f4525acbebd38ad74fd8c3d6badf6d59d11be743196e2cce2f09db45e783a360bf6343e7d697119e5c30f40b39b1f62d0798658b78f504621040d73ced403304945154f67df49c2e3ddeb65530fa24b64abb18d7631270238ce76b05622d3f0ee1764ca52aa653c1aec75911b4e9a4dad3f5f49be6bb129e5e0c9167763697cf11a6d2979709b53e95f8b31d642754f8d1d0cae332f74835e27ba42131b3820291ebaa4da2e14ad5ce88fc01528e8b4028f2350393c7d0791d2cbf19414ab227e204f9f20dab42c3d5611e0ec3964d8735f6fb3e240a51d0a50454c02075b64d307fbcfcfc9fb2515151c86b2edcace92d8eecbc824ea74a434392becf77b18f523eb016f86a2f4896fff7600e3374bd289c627774c69a9c2da4011fd4a59931a193e83594e4c8552d7010d0ccb2eec36235b65f69cee3675457904139e6a7a20db6b6f30d40ae2cf45c3c3c5b533939951d3396f7bb1d187870675aacd270c0e62696ee98c9bd259e17cc16f34c7722933736a2a923993bb95ea8253870949957ed82f36e8d54762f80748a4bb71d4134e628bba20cf37f55a4f86b576dffadfa5ce1d9040e1a5f7bc16e1651bb9c5cd27835e4853d0d38e578a9f295d41a649dd5576719a545242224e981f2a581a25e4e1c4ae0e7ffcea85b0167e5d24ece6c7e5102b59fe4c3fe633a200ea31d946b25e2330b0761570f730546a0f806234896517bd300047be580def958ccdbeb53f164776d2a5912418dd86433e53df96fdfebf5ad6ddfc440a820b8c0b021ba3f82ebbc4bf97bb0cd126fd1e0b4d2a4469da03088b2b4db868c4c2607a23bdcd5626957b689048139ed0c524a23e5764215e17470ca0e0319ae146cf583cf35cfdce91e8c0e9f4626dedf27105df60fbcd31b8380af44a5cfc10c34893f3603b41b28c45f92452cac576dd49f508b9854c8e46ccb4bd21105a78770ee4cbe228714b84fae9cc537a46f13f4e1511befa7092aa0add1c66c27db169e84085d9a6f34b55eccaba23878f9409b7bd775575a2d592e619d7f2ceed3b2f6c0c71d50bb9bcb51ec7cf2bf832565e695cf4f3d2c7cf00a10810353c52dd9fbe24692a70e77e5bea4b71ffc95307f671db5fef748397f0b972e15626acb5c8e4ef4cc272105348f62edbbe7e750b0e8a8aa874c83419ea31ec6cebe3772204ab1a61a5c8aaf24a8404010374021ce242f2da0b220cca9ae92a4bbbd831d433684fe19b7497054c682c5446b1eabbfafbbd8b45418a1867345b613878c04a03612d2200558dcc26d6b31e1dd4ca80dd99636bc8e8ed3267042e49067e9073e85665f88cfd19819e514f07849b802b32ac0405498071f02f361b0df8edda5d7123cec02517e7b920c5f29905b8a46254ce7f11f338eff817eb4f197383eeb2aa40af6cbbf97de496b8f1607807f115ab8f747af51ca716bd124cee3195ce93979071fc515c7c3ff1bc83ae27a9f09e3f16020e42b178b9d3301527b0acfc23d55cf14674171d2bd33bf50ebfc1d83bc79721d3a95048856a3820fe50fefca6b950f144fdc84809b1fca54d9a4cb3d917ab885f703af6fade93f7afd4c48f53d04a2c951e567787dcd3f6939c7d02ae468f9aa9e279f0bfb68bb713eb589c538a4d3afea2443f6e7c2e910fdf4b22f362d8e428bfe0ea1f7f84698bfd32cf6d448067699f9d8a785a255c20b453b20322a90d721017741102fee008379f1a03fb00616e7371f407cb34982380a07c6cef0c5b19224f7ab0a450a9d40a51cf0151fad7648b8072af83529b8a39f96cca845b75fe53945f3b46af74604b81dc910e2b20636a6c2075863c8e3f3e024ee16771a047f94cb929cd99ef39abecc50fda3193265ede55337a10e970045e68f7eb4ffdbdf49a8d730aa548505df2619952c753cd6206c8a6ec161ca8bfa7877b5de1af3991ea46736393f3024e69d08a32a200177ce38c094d54a7931f058b58f58f6d782e6d820c17fbd1a56824568d9083ca9adf590e4ecc83455c4fd832c7ff8805301cf7208c2cfcc07a856bbad82850c25e9c7b5a2a238bd9549c68cbfb857452445febc33f610d91eb7dc14b074997db5b0c252d534790fb5eaf491e21d0f9b51ee4b1a0288fefe1f91e0e942fdbc54810093ed63099fcf565259f06016042a3ee7cd8aef168b21d56b3c31262c7356aa0338a846917c2fade264dc4449842c48123a0f0c4b3fd696b4e5c9e1d992c00a16bfd6bce9527c77ce5caa3e3963b059eb902511d8faa8724104fb2819820cdf73e5103c74ecc6a21bf6ce9e766c71564e75682ae1be107bbff71c95d7ff8b2061f5a10da1f7151c15d1a382307888ae8c12c55c2869befafbd0bb5c5dadb0e522b186e20b437ce71929a836409adf574ef359cc72106a03adce5285dbb7cf0d6492a8b98c4ce346229eac75275d045166c0a015113971edb8c3470eaf58d5123b1fed966088cdab8e2671056447536873d6ed5eb0a4758644ca7e6d6e8ef9e47b8da89b99ed2c77cd94d03a7389d96139c90933c44a62e70b2ee5014c38617154e0bfb47844b99cdcadcb8b590598beddd73ac90b71f847f4887f92011f0dc773a2c26acdf2439fed994847d4cfb60d3d103f56b41d0fe6421df0318fe8aee2ea5059289e9153e09b4391d0a23986d2caf20e37e4f9824739686b28b55eecce18d0646a9a4538bb45a483b4d4f9ee7ec79503860dbbbe9560f1c3f2c7bab529131388e7c848256385f8724926789bb35cee4580ba12aa648713b1f06704ff4c259200cc7e9dfa2a22fd05eb96f85163ac31ca48b12661e082222fe3c8a1e3b01fa439ea6b88188c3e16d06624d5c875601fd402a1953d380f6b6c09085f7c0545e994d5d5edcaa967277202a46796abb9a9f300ef4b556211c22aff861eea08dcd9e5b09935771173b90706e16bd226ac51e5525785640c671452aa45d0ab84a911f5ee39affa15508118fedf66572091f478c019e6a91e506a5b671de13d779841e98538ddb58dae844c5f9c07de0baf9d8c4a6c9bb65be315d50babfc15538f1cb39d569665ec36fe5ad1834df119992e74d0146787db0259743af5d9e071792ee9bcf3c8dd59ab02600470624b3f729b003d0a4ee4f8189488c10f9f292e9ab090092ff36adaab7f933d8ada2490ea6640138f037dcc6e5b211d69887406ba3006ed2b64da8a2019b05cbc27603bba62be8b820944fc11f72972ef8f9040ef30967484c73aaeda23c7c5c8b0738384079c20f7dda06c76e2d3082ac8a6cf29c487d9ce970cecf88ef160620913188d4fc92fdcd1b7942e60d9615e8d9c6a12bc231c79bfc717c593c78b4928665926ec3e750752b5502a434ebe75b4a9a744da570f97f25a36ee5f6a9fe1cf151b3f9865cdf4e069560ca6319d1a5dc15e3adefe6aa9946c039d8b5487cf13285e33b03404be17ab23d4b3b162c63947731f1efc7afbda3e47566a938d7db06b4aa0b83a7ca82f507571f00e7969366b76f5a3a686791ae85800c557cb0a498b3aa8bc9cfd2496f62c3123647783726d618500180c57de0f04b7edb35f1b221e78f361c966d4ad8d5577d96bfe11ff97188f2f3a4b16c123f2f2a67a3ed51750cd9acbdad0be7fd60e2e5782f5b19f0a86e41ed9ad916f2eb7e6818d1c5e31a9fb5a6a99726976abae8865ad11017f277ebfde623569bbc73ce3b73efb2f9d3e6f4be2038761f9773f3865de71c751625d09700c4060ea8275e400364ae9b0b72877d4ab8df46a5599be097475d7b06f0e2a66ff21bafee472770e536c46c55d1cea640b01eb1449bf49f3878d4b15ffcfcc808363ada2a368f973fe5fde8ea79683126bfc43fb45b040e62c1c214f0ec9dc44efa5a594ffab0fb76261bbfe4289634fef74c9b4e6d106ce30a7898355b6a30e01c660746e04dabb72e874c20fa488d2b4531dcb73d51d0ac407e4f44e8f5c40627074c19a845b1f3d35d8e9c0343a8f1c20362a96d1fb4232e52126ffa5e8312782280d439fa48745e7f1231b87a519c0a08ce4801286d3d849a459089565c74faa040ad56ede9ade9221f596bce235ddfef8e534a8e7e7de7f9a6e56288d5035c41010c377a882c2ba38949c47f19aff683e29c7a200e267184dc49543d60e7704cf29dab5d1c217cbbe6cbc744a9eb028632e9a7db138cd272bfb89f2f72839efcdbf491cdc361afaae46f3a1e69caacc351d5600b4b90243e65dd58873d94deb4ea87f9954568ef7afa378252f93a518b4b364446b1bb58e44fe65f724d1f213c07f6a1d6c97f1970fdae2df0f9073914bdded78b73e4d82dc09e6c85a96251df9b9ed3337c6c85cd902d0055ec163009fefb78c0df8520dd1cfed67d6badb98eb03b736c0bebd9394d5104e1ec9458615fa1f1864207306dd3710fcda2beebd1ba828a5efeaa76ef11367c0b023ffe8b5d586e42ce28b4cbb638acdfbac28e8e04bcea35c7e61dc3b743d0d0e5545f031deb483ea999a0a48e342e091e44b72ab58b665a6839dc003e81988de82e9e8e1f2d5281875c89ef081d67c5641b3941dfe2e3a7175a35c728d6de28fb0304dfd69c893ca8949f8248fc839e7dc44803eaf49de2cc4258a6603ffed2bd0f6fe5e55225df2c27d3374764f84ad38f98bc10f05353c9ebd8c07a10911b66d6b59d6e994d4b86ef40cdaf23536cae46acc149322c10f6f6501c822299d0aab212fb120fc03942186b393992a27a58f79c534a058bcd957115350fa635d8835d32729f898ba51ccedb60609b14c97bb763753f815b07b90096104ecb09d62f11bdf94ff447cf6c8cd015f44758581272bf393bc1489e0ce202666732c330f45b6a7630b2b9cf76dbe8f11a9dae0ad0bdac255d9a960427bec1e206c612909682ee1c04f8bd9c382aa9be52aa861f6bcd642f02542935837e2cb22940b96d86319e79ffc428e0291b539fa1b1bfad2bad2968ad43f707d04ccd6c79f96821490c8c081423d9f92a22c1804b102b3d4d80a756e0573f44032f11551a833f1db8ff834f740ef978e79a6c282af397968956e2313bed5b63b0e6010091d1080610f993f97f12275bee2ce550555b43360f45beb08dc5e9bd78a2fe73e68c92c65315c98768de281cea11629ecf01fce89cbc508c0f07e107818b325cbc7f022e61a5307084ea86fedf25fcfa63eac79744b00ab22e00687e93ac73d0f5ef024f42548fd38cc2dbf9789041a5db254bef4cfaeb9f3b704f64fe60bf5dee1f0a176ac303f7601f1f95099436559a03a12b38345df8a28a8ff23a487c338062d055778c9e26533c65eb91a069ad44389d17693109f04f8b5e1aec43de5d7cd53d6fe0b9ed28e9fc031867eefacce9e04c0106f540f59f6d4b263a9c9ef50eaddf055953dee78264ab27b1883ac5ab76f04f91abf35ce3a6d00f85ef172e7390d36e65f4a959876a3c9b73ef0ada8df79ba4c39d5dd4e80d31484337c1029377bd0f2bf3f10c939d52258c22c8b310accdaa568d19cc32dc9e107d6e48e387e554653bd8711943989b394818b8420a235d5d8e6e6c38dfbc113bf6bbf5e43fa4b96fb32a49c7127da8aa77969e133ddfab1c1af8a17a4a7526e5964b5317d504ffcf6cf9c485b4b362ca2a9e0b085770757291ea37eb2a3f218b0b51a459fe83a038d09a414ad3c8de19e1221decca68281fe6cdc21f11c4e9f0bd431d41984bcb3002b1b72cb60dbac0663472a2220e8490cfb9b17e8ab06d992bd38dffe38455dc10dd7c7485f2a0d6977ddc12c527a9094dad870e06a49f5b71458d917c3e345a667b61b562291a9e8f2bbf9422fe630716aabeaa2b13652d0bd2f11a0d0b7eb4c82c7cdfd557bff0d8d659d0deebcb462932529d37aea6ce0c34e5df63f3331dc11ac22eff76d9170336b879b70b3e542dad64d80c856f47c5843cf7b3b3ab7cc53088a814ea265d11475945a16e149f498c9f527de28a242bfb4320b713fc15723f175570b63e509531c414ffc3e20e916d43915149277fc1b952eb7208e312cb4e23a1a045b754dee9d764f4c6e5b296756bf47cba2ba298a67d2cc1e8cadcb38e4459c9c53aee21e0a86fd800a157da0631ae8a90f2802eedb8925ff7efbc73a742c74044c7e3c2b0bb4e80c05ff1b5cec1cc308c507e6cddcd07eae3682bce6c9a03d96f4c1856ee59f5f720eb4aad63c7cdc35558c3dc24e69ac89ebcec7ba80dc23da1c3d4793882e0eba924fd251ca2a743267967218c0f6dfff08e47c949b359c0bdd363ef8a85defe2f37e2bc98bce0923840655308892b3fc6d6d48fba9ae889bcf572619614c29d07633d1191cc1d3ec3b36d094746a8404a037b99c66bd16f92458bc88ced1eaa8135be558a20bcadfc64941973076d23aa2f1eb3340a62b89d65df809bbfd377088b3beb585b4f45c4f95c631b325382c1218ac181fa6470e51268118c9b8f77db0a1a5a87ccba7c9a7c373de5604c8f14073d097934263c0725f26a8d905608380d79d77bd7bbb6c158aea16ee0fb5fd5273562888d65d5f20a8dd10d827363233c12c8df5e24e95c18477d582a4a967fc7ef5c6758f305db3971af59b539774b037d77007e43e56d380e6d34ddaa3ca1b6ad1afbe3252b9dc46b6b4f8dc9525c09a579e038743d7c421d8ad88f2e1d8dfb954c496010f4b9d57a46899c487d14f4181a6f5dd9e64f0cd43cc316112bc85fb1b914512b577696f560c16eb09da1f5b3e17da0396dee19caba4a7dbae21bb1dc05e18d83cce251609b7bbb56e6b70f0df55bb876a277e1aa90f452a9738a48697b2de00e56aafd78ebafb86aa15ff73bd46a7163c185a8931a4d72a262d1bcc8b22b28d4356f86a36b8b7bd8e7f3f418f57f83efc5235e3a1028619d6d4289a0d28fa6f9b1fb47f0ef49d6ca79a4ff86d423b8af2b70255e7da2b69a0e50f99741bca3a87ecbc9ddfbd3659d0ae57b5a883373bb8565f813b0a2bd9013ae7260e0ef7b27906b1f7b76021ce0a123fb31eb96e37bc46627d62d214ffd6df199ab58305be8e5820be80eecda66e522d976f4edddb1d46271f22749981f1b9921757763705a52d487577aa968eef5de18bad935ced474071a0798a60da2c773ae00e82b9288b5905aef11178b3326b9e2774d49b622be5c5d3154210958cdc5fa93dd2338a63355c0f0c8ff416f0bd4b8434165ad37d36e5ab9f4a52dcd04b7a206c1b539cf0aabf88c0b12a07b4b25711925e98be21d32f5b6dd436eef705a538dfd1140525fec4d7bda0e690f8cd66523f146a7207e393dca79e70f6996ee9cd4780bdedd2b8bfecf3ff610feb46fc6ef9c15a3e18d3ad0baabf48580cf83345cdf0816603888ae0ccdc9ebf95f9060c4d21546656910d6a49897385bd8eaa9c9ad22b66a4d52ac11942fcdbae0b1a593f069a09973c0c253ce4571d9cde8dc53bda70d1e0b991dbb8452a01e765f7d329bcd9beebf803c7edceb193210bf8d56efe962b86aa9d78670a6288471dda9f3a87bac711568e33c4493582f147dadbcd1bdf70ddc2697a6d42aa26c4c6460a8b01fd8f16bfcdedce24cb45db0a75c4c3ea4e7aa4fa4111bfe9df2639f5e0a996a4b9a8f44350311c2ad39d6e59692a268951e43d40d47c13167e4321d76067819f9fb887780e5a671fb4afe91e3b93e7f70f968fad1bf1164adc64e4259662927d453645dd3438c791770ed1192948acd59828f57656226db931f21fa30fbef090711205f3911499f80eebf5873c9eb8453df6b781844e22cb8598447a6564cdfb266cedc36f971a98129ae07fc4e5a603cbb4af8eb40dde2e8f0d3b5c0fb6984c9607ebae0ac92df431410050c2468b19bfbcb266c5179787b7377450086cf2b54809854d248f61409ddcae4e034cba50c252425548a1ace7a2f9b718dcdbfffd0e29f2075fd07c02369ee037b09f87d188727078279bfc3849f5b90d5b8f626111e445d561e8f92ca60cbf968f61e333eb8e183ef611fc17bdba51beb3e640dbebf7bbd217077ab34cd5b25a5f1a39f8ee0e237836c9a0fc9bfbf1c8c1c6c1600206c9ea3a70fe9108c26f93b1c7098836354b95f91b5d47a6d21ad9270d294de2859e2334e980a3973dd86b0660987781e210702f2c07af55b09ba2fef0a6216e685220e82bda94eb10a0335a7e32f9a96dae96ab9822113becd0fea9a5f8d49a02a1414f7c5189f14169a1c630bd7e78f945fd2184c82d5637cd07e6a7b5bea386adf6eea04a1d3c6d6fe87d912e99990b7241f1c7d261da3f3f27a5a935483f1917cdf77bd51fbe23990ba31916e93a2f16020da337aa0e3f441674c139307ff64ed5b26c37ca434d2b1a6d73b7df5c2d12207b15e121e013db04c9b260b91d3016398339f944167f41863935ba6a9950fd06a027eb1e8e561a44a13d7a1a9fe954a5aa6396d478c85c4fba7d2f4cffbd08bfbd6f946c991bb3aac05bb9ba75a39d3eb319b3a21aa03717a756ee7f3016cf5b82a2442682569b55a66bbdfb65c85110ab901606cefeae2f18f98f91cd66b1f86a0b1eb116ce926add3f625b42be67cd5de2998fc8264c774f35aeccab7cacbb06a7139a0359480cd1967ed93144e6797822c58bb063d6efa1aa5b3260112e84214c6062d8cdbf512614d7dc92cf7407b7b47627b99bc254d699e398b979fe8d82f359902fbc270620c835195ae6cba3845429a6983fd783d980a9d5e5030adafaf411736b6cac7f22931dea2c3d437e55785617ff95c61858c9e6e3a374bcf1c8f57863ad211f7de165c4dc7cdd9736c128a8773dcf1c8c96bdcf0023568f92a258d981c062a96cf337a4e4b6b296778d6c3bfa9343ffa622243d2f0422714cb9dddf2a8952042c1e3a4fa6bd867cdb9c2d398dac8daec2d2c27edff81ed4b3dbc19711eb8db96ce1bdd90c7c3f34fc65fe6c23bffcfa9e1fde2f7a9766502e375386c8f21596af4240b5b6874f8497bdea6f8cc45c1d1826a7754e7781e2541a5d3c8b05568098b14db2f467a3c34a35037e5b1e13601d7a56d63d96a0b97fbda09988d3ab482ac14fee3e3450ec268f44bc52540dd6bd4c821706c34f9a4efc78e16ae9fbb62dd8016cc6d54e528366db1009b0f795c6537627c0c653d6326ba6b0b0843c3662f6f4db06dec61abfd3ef38eda9ad4629c6b5f5620f366e42b07045949b48e49ec327ec9024854593fdaa8a5f9be76f51fe52d3bd3423d395f446042e3890e6c74ae6ffe14885f6653c8176b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
