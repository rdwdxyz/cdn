<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fb5d5ad492bbbe4d4b6dfe65da5e1ca0796fadab6cdab42163ffe9f85b5f3dee5cfc9d19d20954a03f6785a6984b42a19a029374ab853cdfd8124d6ebf4de0c7e40d3aede17959f61a69bb5c7f88ac93f522e4c2112f61132b26c6872fbbcb2c6af0e76070a4c5c1ca53941708333283d03df74f4895e7e9f289a0e09fe41d21e10e785410d3399a59c078513c7e27e2fa01c06a52b74d6509139bd1d86b29cd4be81e9eaa81853c7a280c996a789de1ae4de61fe1fa7985219f638fd3352cc8342eb55c907cddc02ae02add75fd359c620c341d77657ae79ee3f502e3ef4fe4494e18665b83b77a6826a5998f295df3c9c163ecd528a8b3aa3f0ef4b7dbfbd83854cc3c3709dc1c54b306ad1f2e664cd8b81168ed7d1f5daf5fae10fb41da9457c421266c2cc31ba10e5e51d689d68b2e1729907f9e8cbaef53026f262ea17a31c879cb59f3ab4be1da84c9e0501aae819ca82e64801016af1c0867cc518ca27b6176a4081900d8d949d5bd3707a7510170c6f76dc26386ba4146686524b7caee7bd2f9e5f370ae5a7e905991c3769e20d7a27a9699a925044e00b42e9be2186ca6a37f758c78726b5c01b5a9fb1d82992713d73bc5abd0fce3f942120f6eeebdf62d63b229259e54fb08ad7b3700a461049c282f2cdbd02cfdb5cdb6a806a27522d885d37138fbe865ad770468826984e125228a7c3a962d702a84176a5b1c69cc27dac5f107289b2a0a940f39b253f28291caf733d912d796241d697f997f4fe1e1d3f67ddaf6e02954d8909a7f5e47f8a31ede5756134969fa802f7a1d3951a84084a45907c999164dfabdceba131335611fced50395b704cf9a4c39812b0ff66b59eba9cbe827a1cd208346723af3362d35322e92e613267938547a353956e39a508e567cf1e0d692de556226f61d84c96a51ed07b226e076bc3c382040a8bf3f6959cfbe51270cdcc1b0020678ed482b7354ba88313aa49fab4d6a61537590b82bebd1513364aaaaf337ec251bb162bc5d292ccd3be46136d3c646908fdca7d1bcc9dc7d2f9a6d95f376269e2897e0e4602b117007949255815856d24b0298a80819822f35e9dfdce1e930628f46670d1075e4d0bbe040ddc4aea1096fb262f25d69c7da27330959b605eb4be4fdc106d0a3b7653af0fb3fe8e0702be3f8127d396955ea65b9d41e76e31e5f5bedbc4884f631c11995277ad6e9c4746b2349af3fcb024a7c993b5851d4c9f37227e1e8e4e5c9787e4998fda414d9234ef3d7c30b8e76c2e70734a15512bbcab6182de58ba3ad42949fa09ea9748359002620a225469a1a99b6d7456483d99b94613de01007a76f89eb7e68897af6858d2c546daad129dca29caccd072ac8fa4e9afaf53c95674f96c801777db1adc799992b2f622107aeb7f86de9027c43cc7c8969f2025ba76021b9a2960e4c011157b8242e4301a4886eb68715ac1bf3b2562f3ab887054d6d2f31a756cf00484118398f850af515a11ba7d5628a786f8cc2bde166200878f9992778e5feac5d28f817ae5d511eb131b33804e3cf32d5819aff7c59fdd23c57efdfe7f3e982dcb03c8e9cd363b38affd662624edc45a9c23666973dc5830c6793f1ff75bbee3956253e43cd7b44b6ac7d8a75e3bfdd82054a4d720f90d5c116e63af0c354af08216ff9a51fbc50cbfbc8468d0b4ff4808a5f97f40208d867f6f84c28fb4a08b127b034c9296e5b3e3ad9e8727384634fe70452c4b72983898d44dbc3dfd2c60b84ce8c5a5bec411aa0073b8120dbfd26c74da09802a0e36bba1419b92917ae7b052665fcf376fed5f246f32fa9070b36d585d85b01261462687686cec52898399a5bb6a23106168cb0cf86f15682cc47c3814b880f7edfec2dd872c9123405a5ea4139b340d607c9d59ee87f407bebcd81afb538cbe21514b1192e60970179d120454807d0275290f32d55b9ba2c01f8fe7f953cc45454cf70f8e2be0ddfa7992c52fe47c8ab2e70bec8bb3b2912252685ad9e0f0adeb13a4ac6b1a9236c0eecf8f8f0d085a9be88b6de78a6eb7b05f14d92b29c2257b2faf57c6e5b056c68c70deaa7983ac80d08982a8f79f02e993fcf4800b7fd4b654afc5e5fc2d2669d44ee679b3236bfad2664247e55f767612db692ca6967c21ab0088b045c863e5542eb988f72424a73ac41f8f97054247299ff9f442f42831369c18af3780282d0c5ce745cb924d924c79ceb3dc8a5418c16e48e35337d9ff158681741dca4d6abe77b65d0b49b38e82507c914be92bf8e4311fea6c0ebfc168617c1f20d4d11a107645f5b5fcebdef92d1a048ee24f14e94594a7880864bb95f5db8da8574fce01f205e6fb1d37c9a2c9e64edbfd8f5b8c3cc47369bd4c04611f3e01099a162ccc26d0390661e72f58bec44206aba1b140debfd19924068c01ed7ed9f202778136d52b6ab3a083903b72e0cde4cf6ea5f291235a40f30af447f0aee18a7f3095cfd8790857d86204fb63c83bd357ac85f00b91fe3b6d5e82ada02b84c7f09d26eb5ec384d276855a772c84efeb15d8804a1ed04140d5940058894619e3d20cec9330f9afb7b2795e4962b46328c45795e11c7bfc0ba3d50d1379ef5d1436d73d63cccffd2d360614e463c4e355eda4ee92f22cfff45dda29ef4fa22756d728b74a87890fc9ec194677875ecf5c33830ca142d0e9af07590d8c5ef51cde468b51a0be6358b1ea014af50712d5ba2a08774bc1315e63434865dd6f59a4232f3d0d79eace2061cb51755318ca0d789d51aad48325458e46dee7fe75daed8e6e8f512591ebf085ebd69d328984b23ce0a46336e3c405085ffd2985f39c94b9947d6d816e273cf3ae8b033cf74ba78a3c26a847eb8b207189bd26f26557cb14116c62fb39e918fcf9d1713c030d9dc4b6727c02433a2ebf92cafb3c0c5ff2695e6037e20635bc27579b95d7effb276d00a35392a62c319028529fa2ad1dd46cbbca3183ae99a7b3eb7f05328338c0f1165f216415dc54e102401ab0653bf26cf530cbd617d9c187a432c2bdf9dd39cd1e0d6b5ca1e079a8ac64e8649fe24de63dfb8f932708f0c263a5b26e5ec21c3793852dcff2c29d275d432b6a88b6bf2a7e5bf9a268f150de9fce079525a11237da7c6bb6a38fc2ce8c59cdfc76119a0e4bacd165203bc6bc3a300e6e77946483a1b693159b9b18dd88ac47974031afb4503862e35938d858ded905894b9e804c0956b6c2a9b3bc9fa08dd5ee3e88f6f3b4e3530770b0ad4e5a100d9b2252ad6c34440ad6647fd86bd48bb84e5e9afe2fb052122a793d49f14f964b8c2e8ff813e5599fbc8c907bbd6d80804f481b7d88ac02f504f5a6705ba383eaafa21a70185645edb067d7b0de902238c56d0ace1de070c240570c3035e3d9b8017648e608ff80bfe5ec77747ccdad0c59b018d0ca80eb8fdaf55bfc407a73353086ab38bba7931dc969695b0d578205e0a76a78802666cb0b58b37a07bc67750ffb5305f2174a2d6464991b49299c773bcca2c13a435acadfcfb719ba2e9e1b9e9b753f72c0ade3b47fe9ea0722e7fe0b9691c44a042fb7e1d0aeedb39f3c2f442e850e850d15e3d3257a5b5f1117174654abc0f34068cf31e60b33f7e8715c8196148a08d72b2bc6f2322bc19f2f7ce952adc88463c93d1fe7ea5c1259cff3db2f00a41fabb771341c4f5595ba7e1e700312ea4443b64d8603fdf21c5473e7c6b20f7b8072435c058ba3c8157bcc55a5a73f50e67426e3d922e430d6c19f454324473450a22a4ce3582aef335fda6fbaccf637ff7e8460623bccb53afdd976800f16f9b6c610d7d0cacfb726043744f49b82e1b8fb0d6f4c94738836a4cb718e25cea15d9756476ad14ef2058f0f1892c8ebd056360967edf683c52818024c18bdcbbbb53b7e49710af15a6ea7051088197939de59ec3d290cdbf3ed02fca2ac73955bd9dc33794018dab6d54e552981983528d37bce219ab2623fd4f4efcc4dc13cf90e068d3b87745fd5ab9cdc8eb16db8a23f3515f66f846862f3826d2a4001f9a0b38aafe15ed2595c335bd14d70e3f42f289ddf3251e3d9380f406a006714669999e5191e97cfd4ce6a7a55f8783bbba078de77cac1bd642b3b6b0d8aa00329493f8e4f8052c5dda484aaf1ddc8079d9e8e55c32caaee18acad385ae4755f77c10e06b0c68baa6d25cf6260e62240f280e58dbfafe8296f2cd68be1edb854e175b7b97e5237534e9f64abf7167226c57ad7bc2c65a96b35b2ec45682268e58fa47daf6630be8af3fc3bf7ca65c55f16a0b07e7b0ad6cfd5217517f908f4ac80e6c1b9afc2eda892a6333a2e8b93feef1c44f12b040c6f45e0278af7dcdec783d1233f723cd5310a588fe5ff41bdadc79a19d1c1f4e7c74f6e937ebfb8b076233de90664f181b831fbee63870d4a94aa4d7393db7177a1a7942e4ef092cc905387b0a7ee45fafa5d66b53316f2962b27c8c57f17c65b5b72ac7a9c90d2871fa431207b7cfd9d41b3f170b55e9297d34a0f809281f5eddb5a9744e813b2201ef40d8d87b253bd7e42134340caf9e0336f930ea5e624440e2fb236b244f1be2602bfaad70c036d92925ab8acceff67d0b0bceefa497107b24e2490330e81083f5fff38073bffbbea84b83c913b1134fdb8f67a9abb21473a3ba8246eb5d3d9e36eeec93bf456e4a351ad08f338eeed1ef8b11e8f46dfccbcc65d57cad71c0a91f6af659073cada6d7ee1908bbb9d3ab1060df90b359ae6af6a31165e0add9adedb6ffe6f60e2a9c9a9ff846273d318443afc640c30d650abecf92a75aede836337d94cf5ffd6efbfc15591899e71b4c2f8e902697448dd1e233a774c49dec35a050f15959fbb4abee090c1d3969494d5447d12901c31b51925be87deb7c6474f901dcb1595e171ccba0814399c616d6f13b17d92daabfea40592d20959050fe4ddc05e62387a86487d08c0dc4ea71d176bf119048ac294508b6567fd40aa83341539f48bf14db3542cdbbf67282ee742cbe0d55a524226cdb8d3db0199823e000c7eea86648d9fdd76a401715a0b4b79a4318ab2d62f58d54155d3334f06e331d0a91da11c682e1d5f7ccea4e286c92d854e184942454d87c97ba3d03558ae09994753ff5bc0b8aea8cae34870f3d05a5afe60b4e68856f4b4d738134cc5fe6d52684ba23678070982fe4b6bb0ec2c30a18bb0840fe0d207f62b25a5e219ec26e808e4fa970a479ccb1705fe5238e37d85cd9b80e1f582c47f2fc78f578e4e7ca2d34c9175c871019832e8256cf062573301fcc2e477877025d061469cac81a22c46a7af5fe4429b0aeb4b90a66d2fed9ed24bc84cecea9b2a53236b4c97285d23e3f7369a8ac7de287e49297029e941078c82200b606b4fa29457237d59d81ed07638499bc419acdcd8f4f53ff5a56bd6364a1945d226577d508b954b2ea3af1a6b5accd72ce722268dca3284e52f63186dfcd7f9c604ef05e376402fde4d0df16f00a62a6066dc5c20b314d3c51e47284626edf9d79f9cb43f8a0ff59709c96f8f8358dd9412b8a98cd4c8f04bcdd4f41ecbda55739ab9b27d06da2d140b5800384a71af1c1213dd9ab673a2679b6bbd62da90f9ea25f8a48d2374950dacddaeddfa712f0c2032806fb0a5c2daf25eb5b109970272991d1abfa14490227c3004e3b902faf74b90188e6ff49459a4c876c570ab2de5908c0982271d3f7c37a890556a93852187c0e8b92e47c2c727add9e4d246104b14bef0f1e791ebcf0fec8347735e58ad738759cf0fd8c4ed63bdc6e39b9c2338d90a7ec47ec9cde685e0eff1b4dffe783fbbf34573868b1a42806ca832bc0fd52979a65d80e1a9ef8d7ec6d23b8e88232d573bf330df641d11bdf05122e21e9855bc9c57e27336abcefa0082d501e3eef6138b0eecfcea646e20a250d129514745a0592b7f1ec9ceed7e5f101734c01fbc5e12c83548d15f360377e015c87d5df5efc1e76803ca72f785a50d7791e343d23aa8db796e74cba6b9f31ce0960e0ed5a683e9c3bdc99c23982aa9bd500a912e8ea79db3e16bd966256c4c53b453126f9680e5f94a8ea2c6aaf10d9e5922363ac87984b31b035a7635ac7c2b202e2eaa4ad9c7bda43dd64a56e8617581054a1cb86ecf8eabee0e8dbb939c4219e56ef4a2aa358914b3232a5ef279225d8065b7e39bbe5a543a2aafcbf4af6a5cfc20f8304b3f3685cae4b4b79e23c7ff8031372b9acdbc1239e7012f00ae88938974f47719e9b494231fa00dbcc14ffad3c09a3bb13de602d81cecaee7faf22bf91fbe363dcbf21f6602749a63579a5913a84c77d1c1d2afd16aaed76781cbb0f2ba5449d1dea80d9891046260463c3635758f4b3d110b7ab549db7997f5d63da7059ad61b01bd68143973e07bf557b3466878fd687f8e1860d0f9833b25369410305fbe7d332eb123153325c5de906a2e9184bbc9a7480e87479699b7c452ad2528c95a222412ba15933ef557e922701573348aa7af5621b58127ec1bb5b31cbe7c9643758fdcfd37bcbe6858d42c5ad78559afafb6ed5453daeb694b7e7a2986c720a034e3c5cbbdd6d400661c3fd4ee172b65e5d56cf4929efb13bfc9a745bf23577f7855e431f522c1694a32220964aef989abe905a4dc92943810c1f47cdebfde9e618c577f92adefda4bb743be476184625b82140b3c4b23258b68e51153faf58e18a19782a63882da8c8d34c9add682097394d18ac98785c5b3e70f345ad89e1c9400a196250a10ef8088205d0c838feb02324a1d775ec9d441ebf157d56da21f59294e802e5e81db9d61481a0d0437b1998185c9c740eff267f041d601515162f52e0aa41947ffff11399607b14375d6d5a1735f4544bd0f56418526850ae688d6ad0f6ae97e15f522b6810cb733bcb3730577dad91d6dea923bc70fb27d4ef47b2a24e503b75564be99f0829b9a381b7ad5508d5d87d463311d88efe62939b35ceb15c80dba91aaaff4fd0919b4759d49b4a95a2505b0b4c56970b75fe62c76e5470bf295fed1b3c7a04dee70f13503a13be143fa7acab4a9cb07c45bbdf38ee8ffc527a98bcd902e831002c134308ba1b17fb92c7913627fb355f024daae0d72153926b5211a1ab99a949c20467072301d1adaff1b4cbedddd7dd77ed629e9c01de78df1ccb1c22e28628f48200801bb8993b61b137cd8eb74debbfb110fc8d00ffa657c97767a4a3a5d504ae323408653b981bba07c1ffc5e7d83d2ec487182b0e901dc14279aab44cc045a516f59dbfd66943e1411cfd3a8cc11c898538119d8aae1cd82d3b26cd5703a387bf97c1a8d6821c9067e9fd8c8ac36c234592920026775403285db7f55510545c64ea62ce82b366c8093fdd102ac13492964a495f7ed0b706c350619a0d384dc7b3d720173bc10ffc362c8234ff4d2f6efaa8c107e481f09bcd9b170569da363362f5b1dd1aaed7fb54d1cca254b260136303d68d8a6baee4238af67b363c2bf67c92a856a09acbe9b67e4b8c8fd5389c8069aa32447010af0ef442d3f097047c756f86748adef8325a9e570e398dcd673a446b30697dbf9580b286a788a5b7f4b59737ceb84cf75940d385469a213af1e650e8a2552896939049b3103e1abb61a86bb9fe141bddf329d8c87fe0cd27c4fd8a7a8e263ae7241b96dec70027fe91c45b0859e7d1d6289b104c665e726ff6c35e7745b29b6ca6618f5672f943755ec21ad872970626e23987557c388560d3b9f8beaa0563bb47570695e5f12b99d1054ee6a9abc708881d4bf2d4860d77b0ca25509b76f96e6ca0fa8d1a5cb195fe8793e575a89a15c18328e31647729ed4f2680b5a9d97cec62cf5525a76ab6922061d64fd2bdb148d90d9d47e783b6c9acb741e5782abc777b6ccb391031416ab22a0ecc6e42054cd76d3afc31f2ef626d3afbbc1fdba7a0c7fd4108ae3030145d1ee40180d3948c4f8498ef0aa4257d26c9df4c9e478d8d1791a4dc99c07f4e0e00bffd5072de742a151c1e1f5e770750bcb7a19bb54365ea70c7d158ddffc5d730c901302c5b2dc264481f5b5fa20eb5398add21c752b07885e81b1cfe38e39e40b6972a72aa3474a515e920aad96af93cb7073de45e8b22b50483490d6d22a6a82f34f3b2734a2e3159db32f5db2762d504d02d6bd6bfc2b2b3ac16ec9a3e4f9603ecf9ce7519a77cc06e20e5752a0f022dc9b652175f05648c7f2bb0676a4403ced5df87ba756755cda6a473bec7a916c42c5d026f1f5efa0796b5f5ce58e0e243e732e609efacc35be4e166e376a913de62f986f64d8b690d01fae5745ba1743fdefe330d0a558ae48b8eebeb7f97abf99ad21aae5520b5c828d9266df2fbc8b4297f20f4b50d73df5a1112c6f789939824bc0c0dd25e8c4086c1ae0f04ee56c17c97f7f7153eecfa9da1071efa8ed1168f3cc993c97f42032ad9d33b8fd8d1ace0f813cd110c87b385bf3c3bd14842736e400904056d51a1bed312dd98b3d6e569d886d682a8cc6382f221df73c3404f2f985ac6dfde4258d8b044d79644a66f2512cf262c9dd54069bd7c069df0d462dd468f1c2f97258f2a559894b3cff9f534efe7129962db7544f500d1e91f931c724f47b4416f7436618bdffcff97d1c6eaf4a704886383e9e23e5742496a094aba3adea587086e61559ba1bca1079806af5c67b59c8cfb93f203676ec8ce9a263039015127f96c7a123b03028ac459c2e6b66d0ad39c6db8ac4cb60a96376d727ef8af92c2b780bba5dd0b5a7767e24fd2515de0bb1109a07bb9302e0c5ab08814a2fca1d80089d91bbd4c4a8649cbfbf2954ae3f9e134900edd5463e086117e85d2cf888aa70a5fae67b1f48bacdb279eea17cb3fe5bc83ae2e9d333ab5f0aadc58b5c76534515efe36c1b3a6e338b42b2768ac973cc03ef28e1807c0676454a6697d5e381f46cbeef38f00cd12f2fa5bcf866c26086724689c36c33c857dd682843c976070efa930cd70bfc64376e1e7ca01065da8ad952bfffbd3782f91b0ce11558f9373dd05af1db5b2b42336e725c39ce50776895ed860f537535fb507992baab10660a880de777a6150c379632485f41aff7c6d68f4c7357f4720072e28d57c70656fca7ee2179b9eca278a6f20cdb461d727359d8788c1975da1875b50cdd4a77cf7497cef96f286d28ea497e5a32d6ce37f5e2302f5653f3a78df14be7a1344c75efc642a8f38b6362f09db9c50c04454da9654940135c73f6282a71cbec1b7aa40235c1422e6dd2202e57c293aa6f2faaf18813a87c81e0b38bcc9bd54e91e55faeacc7fb6abce55bdc51ed60a4d7bf3d59edb171cad6fb6c8ec242a6feb4a5a9e32b1231789f587f45b9d933e28bb715c4fda37e8a0c45a614c52474dbb8c649f23bf68a9ef284d53d316f2e608fc8afe191db5bf7c7c266de7597d75beaf2f381ad19e62f5e1dd824e93792b3a95e381992933576e7c1abb2ab065aa883acdf4f419fecef4c64ad0503846ec4b015eb036590f512d81e80e4f2b8bc560815f55a5c81d3d4a8bc7a72894bd0070a46e4a26b3aa7c3c5486d2c74550b9cd03675bc6ea39582b7ac49940aefc567badb7948364477af72e280d4e63f60b6ab8ac7b9e8ca9f9de1e6e6b19587d5160cb55cb649c0ca120450714dba0cfc657078d76cc4a8ef9d627feaff7081e21d5e4c273b7981abbec8d2f796354cc77fe7add1accac38481904cc37a5d46214895de43058ce2e08e2b9949d3462d2b8cfe01888c4e9b9f93f608ce3769ad10e58bb584a28790fd10994c6ed5d6cadc51228c693a59c51ecb88ac0649108a8738ae566bfedda36faa756bd10edc34b8a48b15e199b7a2735838787a30a1de6f556ba59cee72339ae4cd69f1f87e2a36e343b4a533c01b6b2c9c2e635e99956b38ea7e0805aae05086c34ca74bf375d0bd115a1dd37e2be9b1f547a90524d0796cc1eb28a39f9d7a7ffdaf959ccab0cc5ba6ce857f3292994074b358909644776bca00fc36553da9f691ff48b484fdb6829f04764546f5c54eb36c3b494acd1c5778af2dfffeb82d8030f1dce01d5fc7640201ba844d991a947c60191e0862795ba8c6a888d18b2a0c17d941b0c45185b75df04db1efdf3ba600d76cff58a5571c928ec0c3e2fb2106a9293f6b4c229380e30fc0c5dc9b1a8ef5690cadf1696825785312f837da133fc672ebc448800dd195b68304be7e9610806a39ae85f3dbe1342119871dcb50b1d143cdcecd89db33818d5aae93f76593a30a86869d1c83001ee3adcbacf8a562b6b93025466ea853cb6367dc05cba0ecf3c590e286a7134bb44e8269708a2d58c7ec81e3d0716f0c208a2c0c68183e487b0225d1c275e9ae59aef38d04d3367ced71404fd4705fbf39ede0b4a8bf0e1142555b29f434a2875c7023d44ad9f49a954591dd0ccfa2423f4d23814620a6341d61e1e4de840d09b2859b18ed8683afcd10878b6f7827fc62dc9b661b3e7aca4d90c547bbad7d7dff80b4a8e523e3bb052a6cfc755582c638d0987bcbac390bab9489baaf9ecd994716a5481518b24e1d7efb0006af72286278623b6199a15a8f6dd903fc6bd4953a8ae0526e5c0f5b4b6f94a91b0ce9187e66711f371c38a1c3a95dc072429ca910dc0371523246e6f66846e9d45f7ac3847dd8ad7195aaf0c982ed603d83c27e09732403e4deb8052b0d81884354bebfa7df30847116a43749c588bfb4639beb9a00773ef8a0482604e3b9b7597e8037b9c0917279eed2aa8d368059e5116d027eaa75c59417c68522eaebe6b33bbb98876d04fa1bbeb9378936cfe943f51c5724510415c4364dba7f3bdc338620f588d07d24522eb37e61290bc0998cc97be63c3083bf9bbb180cd67f89364a44cdccdd6861fa12a9ed2663f81afc1d1133178375ea058822d156187d893dddc3edafe57319d6651730fa5b4e4c386dc46463af64fb2361774a9cb8693b87a4f471c2d3278713b465c61ea0d3835aafa1e1b11c875bb2eb46ecc05f493c686e66e272e9eeeb27a769b9e188b00aab6b69469b697d8beab4fffd8ff086f4dafab2cdd950232beec68842b400201ef9d6dedf9eb6898c7d515cf0a441ba3b03b17519f01186598526223ff96f82cb5e55ecddb21e0718c0a239faa51d8b3517b3181fe9f730db631419453d4eac5dd00948703b6a14a24f75f74189a4928b0b22aa92fa889657c86054c848a1ed3079affef87062d26b4877a6b1cc1a580b291f12e474f65cd58212e1f4454c1b497e8fc48723ff43b06b90d249a445581c9681cabdb4b861d02b43fd30bf4a1b6e3e08f2674d70abb6fc431da2c91295b39dc465c68a0feaa92da931b04ec7539c8aa902682e26a764cf925400e191c4f6798c49dfc9eba63a596257a82897d89670c6d7aaf11f27f89b817df72a50d93256238dc4fcc69f74669df1e7349bdf3df3aeba3bd15ca6acb4d5beed96b69724bc2668b230c966d05b3bd76553512cf7f515e232954b9d7c118a1897e7ca4495e9d80c52510392ebcdabbe482f0a4ff2987d02b9ab315de238d2e644231844a32c01d801babd061eccd56548b1fe1da836f6cf56eb9097dafa5d548d4bc42a2ce480c0991fe53fe6cae31c5620efa3c240556208dbca77d98156d07c404bcbc53071de4e464c5c6c567c206c8e04ecd4d57e93e36fa70a27acc7356d33a2d72601a611df707b1c388a003014fc26a18d1fb7255da89f67bf299e34ff1847da48274ffdbe7baf248035fed42316807b8cd8761d7f5e119cb6463b1bd192ba2a18724bc6f311fba3fa1f35d7e405610133ef777229cab308dec070bac99d8bfdf4c8ce8f53961661871bb8c8db0d3753a68f7136ab5f50810fa217d3527b2267d18bb624170b15b556e9ecdc5e7e7f12e4147f893269ffb32d15a0449f8a33af78be90618956ad4af4632e124d8b0bc0cdc7f61c30bb9ab6d7232a8d58eaab20d11512a2417d87fc19e2350485699b6e2b53b78b58f5df8244cbbe708c558b069296d348c3f231b6cf126cb4fdd2d90358aa72a0a93ac143576d52185011e6aae80fe35c53ca8fc0bd05d62e50c4590d25725bff92f21e92f37fba72c6aaee7c69886895ffcf532534dfeac35b920fa8830d9f5733516eb4967c9f33ebc34ff58eb6d29eceac1dbb54c69423575d5f2374488b9a6d2f865809ff3e2c148057a83159b516b5d73857cfd912360f9daff43f52bd27c22bc3915c4b130b11f096041d6787b04f9632d8e99197f557ba4b2c994f38f4eeb27c8aaf64e50ac0ad2e5e8210d1a9c234bacd90a526a97b519484d724933b85ba5df7813e681c02e448e31ed90702c5da7d18c85e59591e426f9baf332fe36b3a4d0f5bd7d5506e70f6fc4ec70a08d7af34eebb392e5b62c387a93c66359c70e433b5d32b44c9384ba6982785a70016918c57bdd9b72128d19d9e2ecff6f9d4cd13594bf64dd92637e893c36c8ef6186616251a015795306de1b6d2408ecfae0a0f110e9f57c73927d9ef187d5d98d3e6f8604dea78f4769d3fe68c4db19f129d036a18f142be846ee801b1266868ef1ef81e502cdb7a83b3fc39cad2ce36d4b5f3048c2a6657d57152f0df2c4e7722079c06ad1b4596402ec3fde8f26f88e0a023d6b40d67430dc5633a743f0d5866a7bfcfb8bb117868ee552db2743d6f9eec9aa8156ca3ae26c1bf6b19940101c341331bb64e0da9ea2bdc71da5eafbc6cf8aac2325db443595cd5671d528db140241bd1f5c5c3feaac903ef81940a7c86bcda48ecf35ed95cb04864d676fa4a4da4009e30e08c2f1dcbee975b633e014de600b25491d9edb81a70b41e325405033fba55418bf0a9d31ad1faf0e094d2256d7b24e1a122375f36d358fb3394510ac91a41c2230d8877d03da35e778621e060ee8697b766a77363eb923dea77fd692633ec53ab44d14be20e950050dda3b5bb1e33faa303492e4b6cc92fd1897fec4075a67f5c2df198167c800afe18017500c21c22ae3656fabac1487a48d916f5a5049696bdcf74fb082b3d3864781ab5a8b75903f0188dcd9702f36b69827992f90186f6acaadfd4716cb75fef04c35002a473ab7b5d7f429d3991b9fddd9873e58f7f84f018b7d902e7485effa157ea6b0b755bccd3d8deb0eb04234126bb4cf4c659514551b9d93ac99f8ad75f0f437b60a35b2693e54b6d142bafa833deb2a7f791da0329cd32de5a3a81b3a838ef015185dfe97c5aedbdb4d2a7c6fac856bc8c079eaf1773d16242e483f12476dff785f78edd072f4a52d2f1d316144a6c7d607c0f25e839e2d933b335b9dc03e86916370e686ffeea786ddb4bf11e0900701db7d5e66e18edd009038fdfde14f330220dd6ac09cea7577c922ccc5f4a67fb2fca9e2b116a1f1483e2552614a548b13c21bb530ccd7bd9301371e8715a03b18c70b9510148405c77b89ed20049a7fe3f031f3a5b5be2b988964bba338b028b231ce8b0604fa4e60da826d5ac5a6cd91c33f4a823a2c125eb0570dbe787860b5987a84b38d599309e36a2716aa45ba136b0c07d8a0e400f994429a293fb19f21598b726bb59ccbbcc1d804825153d4279735ae175957a5673aab3ac29eaf46bc3e127412391ea1a1b0f36913e89aabb95818f4913fb2164f42fb095d8bc8e67fa5af19b9121ed4084f4b2e013d409d981f050985a533a34912169e4a2a455a82d3d0f4e72fd7d18cd7bf6bcf264aed83ed3061583055d208188e60c3f8819ab13cec34ddcc9fcba2b2ac02277c1461ffdcf1fee1567bbcea7fce33f961a45a5e4c30e5c86ebaf1f3408cbc458f5677b58e82a2da5fbd33402861316187642ef322ed1ce294958b5c068e85b583d40546abbaf8a5ba08f6628944f24b603434ff81678309d39fdd4569bed155c570c73cc8898101fe94f60d142c89baf7b0a4f888e6f480a25da05d0a7590568a524b31f56571dfb9f42b5d11ff3f457ec84a5447d80307fad5b2560305c8931207826cd06ba2aa00796ab16a5bbaebcb5c62b29d8c59af5e448ecf82bd0f12cc8ee03cd53e5d339aeb981c1d503116fe792017db7321f65bfbc43238b60eb7cae381f738a1e877f3da853f3d5f113509ea2b130c35b0cf4d10d28686a3d1f1b1c44c74e4331d117f1795a55d35e2b8e2c4f3a439bf3efe7dd4c587ebd38f72b23827424f4cbbae6e5686c6b9b1cea0297bf8f55041de12ecd78f63752dfeea2dd0abceca57f84783a070e5ff82955227c3e48ac8dbce646b2141a8f5291f2d9c9581dbccabddb91c49d0d3d9d188fc27359d1d7f3a9630ab2be237b5968d58bd23764ef2178b2cc9e4e86758642a4d07377e3ed625e1fcbcc1fea76551b18008bbda3312c783d5dc888e47686fe033d7c60e7b5b45fe2b5fa0990008a44318d0b402b0529d9072dec667ba730d443ef502106df6395c0ff644755625acf1ed407033738c575d5dd28b769cdb134009b26c52c8b2aacd95485b3dc741910d536b6f1ee4587169efb2a04083f7f771e3f66c1c475db4a4ccdd02896eb5f7e5c1b6938fbc22906def4a8bdad6da4e650022fc82a04067fb7db7238ba8dae9e27bdb600f19486d2f5a5e1246ef7701d9f513279b9032c736041d5ace897392766102bd7069045d144cce9ea041e344dedf52d06c2a8e4ee2b5ffede5a011e4ffa761691e0ad385a43e76cabcd37a20b5d63464369207d6f4d3f80645ae8831e82e2adc4f39f85475d8fde66650b601bd343538eaf441d05ef863ffa844b3fb3800046d53882e57ccaeebb4695db18ce6240461b8741b4c5d58ce36f1ac6d6870f2ada2e5b72135fbc271059def87088476b224c4f0107360647de065e989116199d87e805b97e378811267fa88f496df2fda9866f03cdf357b04083469f1856a5c152ec2d602800e1c6582de8e9c29eadaa571992d687270dfb793b8a197ae5bb51f4bfe4bd26582f9cbd09fe139e1e59d05e2c891cca338aee11ea3193baf7d52f28e646449d3e53641a3f9d801c850593a371f01aba74d058485f00fe09300df3318c2213e88f8f14ae6c44aa94acc6e18c0adaa01190da371b770759773677d39a54d31b0043620001ce881c5774f05afc12eea31dc9492a77b4a3a234cc9d74413cc708189a75f01590b78ea63de4868cb717da609314f446ee99320c66ce5b7c942cbfcb7d4c9c114ab0b8f1eb0b31da80ec9f018f5acdf871ebaf46e23ae7528d21965c75765049103348420fcf57f0e04ada67535e421d4370e9f538c68f0f23d97c623d3fe7a15f79ebf8b734ba2f53a373a7f7c2176377a0c7101bceff31b8d1439f55639eade1d1cb3a889119f78294cd9b4937399a6d2bc51b28d47278cfe05c0b29dccbf36793023cea9af48f9aa9aaa4dc9f1473683688742e37264d28c3abc9a50a0f7579820053e7d60449d433af820ac747a547058290bca2848c1645f70f3128396acef7bcaf30b1be800ad15625b68a8550e9633419872ac6443dbc8f733c35ace920c0a4d61ec9bb0b3c65765036838d68170e0edffbbe92dcc5eef3f68577a3136062899f70d3798191a0e850c81d1d79a9803cc5ceab99f2280a2ba56e2066a35941b08156004055fe5f355f849c3f334cae12999d43b8d7135cca94862f6b40a08b6d1d703283307920594106a1ca76af4e8a71e9d84d49c193e0898fd072cab3809191cba8ab3102541a2a86bb325518be9ce04722acc1086c76f430f1170c985ffceb6a9d5c96b828c373fd2a83b555bf203c0ca1d56209d7219b6f186ad3dfe04f8b8751bb5f8b1473a7cc645a3e2c791428788b51d6557e3183d1edfa175e7ff0c8242c1e1d60f4bcaa6dcdf85ed5caf02a9930684803676bec36bf394e4a462954dacabfab5bdbd6ab18b664d8553adf187fa6c2be4143426c81d2eab96969f8ce2fa02366974221540e193235fbcc612b528f8f785322b2ed8e6e767fb46c666ac410d2f50ef6b5b64ebc1430202a8b7cd890f3222f135133a2e4dba4dcfdd4fcf22506ccc43ddb61ae3b63c80e46cc006ef4dfbb160848f9959b4e3fbce6c354690c1106099bed56d756401f87301af8d1ec6cf38f17c3848665e6b643b52ecb3564083620147673d064675d52567a2b2c11892f3ea3d0b4b7fed771ab185867d351d760e7346abdb5adbad3fc5a677f8c4353beafb79165c5c18d607129d6d48f4b3476bc8ecde823e2326b38efb0bb495d0c16eaf81cee923fa0450b6ae7823de6e53bfde42216d45dff6feb25ade8e59be7fe384a4ee4ac3efc1199304cd50ece2e97f7df38c6a0448f0e148e2510b17768aede912eaff054c7ef65a8c927593becfd9f4ef7c81191ce4c0525d5150d10b22adb2e167764a39660c1b5e846e51c9b14298c99438378402c27f1b4625c90279789a1f8401814dc3449893da5c91996c7756d6135782f748f354a347fe5d6f02d80a70abd7e552a77d540b4458bb902df51470e2e75082bd0cd122213a0decf7830a1b9bda56713dbb8f335910bd44dcaf888e3ae6906150ad0fdbedc680a5fef26d0687684268561637cb276619a92fbf5fd9d4fdc1a4ab8aaa59c26be428de7af42e1482f47f4f6803efce343a31896741aa2f66597159746bf5187f424de770940480b5f2b844ed196e89e32e9cbd051cb57d320f05fca610863e17c02393d5c652322a08c1960256efde4e058761074b74b412bd267f8843305b1da854a7280d6fe90b94b15f26b5eb13fb25bf2c39cc64e0036fd8cffcdfdeee2a2361a32469d1024ffd5e31962b7d1df4db2951b361c28da0f6a0a7914560e23e4b0c21612e54f4aae6ef1c0b096c2e9af2dbcf71d779c5f66be0a7ec25d6225d8bd86b09a99ef32943463b0665f2dc14abcb4957d6b2d72b2545720c28377a9a6b723a1bbf67cd5a81188da3a257b4af767afbb86e076f3a7c92a4f82a076b96e650a9c580c366454a77efd7fd883f1bc8a2a8d7fbedbb5a0189b4252e82dba7cbbf50a1adb6c66be96e38c5bac9eb2883dc854b088f88c44af5339d5c80d161c93c0f73a6772a897983d507dd6c0c6934d9a99a2bf0538e483eaf901d620ba90651a5c8b39733f29b03e52757a4fe61bc64faf2944616bfc64cc601171e37ed3eb0da58da14781c0608bb7946e96ec3f80486753e870f3441b919fd530c4b3aa513d1f891c4bdbb1196563c6c89b65f163cc5d733c3bedb7ead56469329863fe15bdf879827ddfdd54cb792a54d068d6d7559b1b4c55b25041b483310272c10908408cd1905dd06db6a9dd43a6fa75413347aee3517369cbf0d758110c2c6ca78ab0ca2998b6418ece4988966cdedbe871dd9dc92377a393d9e8c3fb11e423d1f7ece789b3c1db289cd8e66459794ff6addd4ebdf3f016dc7ec206e892d1ff218b0484822eeb7bb5e214ac812cbb1ecb4573537e870fb99cc1d8eab33207aa150cfc2c2f52b14c2393b195b1d4ecd238158d0e7aa0d171cc61bd5a599672d1b53b57f082392cb2b8f56b8bab5b0cb603e10e50493d0b580b23d3e47608743a16e8eff2f820d2a20ad3f7eaad5b7201a35e7a65753d89d1063f5d8ca0384e1b3bcb360fb9eb88ca25f7bc8764060b6f8f1f3549a95afe1589dc4968f8fe6066c8d7b9ed55c3d53fb31afe849be96ec4ccdcbee8981955ba9c03573c4b9ed11bc9826011fb66f31c0cf3c9c063c8e1dfd2241f2804919734c20d7449d548a8478c8f1689199e0f80369a107b0ecd2e8b4a5f6be652c2f5fecb12969b91fc0577c7bf1aa5e32fdaad027588f1492f8b19dd5276a8f48aadbfb9fd6fb2b9abe57e424d18c0dd8e6d155ad5ecea39fada7461799409da5c7547d76763a1f45b5076a730a01a1e7486dc443165b8bb6216084d03f18806fbc9903397a8862b6332ac86053d177ba3f09e6648f0b7f043976caab34ded9c17577d0d9c7badbee6e6d92715d61b9dfb6068f3fef27da2d2456d32c4f492e9f520007a07162e08fa48c4fe0f03c4746d07b3add0c3aba6932f39d34365ff3f6d18f5c2a0ec3ecb6742aed652b1f5ad42b409040b1217312ef2efaaf43aabd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
