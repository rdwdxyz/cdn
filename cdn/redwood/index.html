<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fc9824f52eb4687ff421248e0acc9fd9a25a9c97d6799f5dcb03254977b70775ece28cf2faa4856647b126b3054761117055090b3a3dc1eaed0fd2e62a9c56063b0c78e239b96385524d0dc3586e739eec250f027054607dc91dfc445cf35b77428b5029f3bdb1c553520f11e71409d92ce7ecd68a5b67b3a3787946734bc2247857633f4a8f17bdf45b9c04aafbd598ac8a54976e99cfa053a1975643704dac0aff927438d0a25e39b4e5cb5dbe4494d50c3c138e30ffc86405ec2582d2457dd0e2d33129f492c428fa7353a6f43051fbdcc68503ca07e0d43311816680245d57a9c96363e86d0f98ea0e2597a73ed2066066fe06db9631497d1c500d3428b0d15da523739b9d8670102a5964086e3cf256f4846bd6ef212aca5d1bec3a9cec5939cd89d02b1be005a0d261b948501a75c7f8054a815be2b3f23832e8bc32571bdbc516dcd1038aec143d4cdc3475d9009560325851109dc730f9ce3d9297a80a2814ad318d6b167145f7f476cd521cad9e5160b1b27d69ae9675436e3eac41c5c4d7254a190f71db7889d36a00fc30737355e793514b5c4a29d2ca9875f2c72cd3ba6a97ece95c81a8ebd979328375bff30ac067ac400d7feea46b28f9c41d4f7f8c0ef793212db4abeb159d1a11f2f3d59c3aa20a9a19b2171bf274345c1f412a9bf34ced794349bcf5ca5d624fdc6a0654936fb99993eece3f0fba80f175338a8b6103ca56848fccd4dc088202500a01f3e755c5995dbe7ea36c5f36368e88f2450c4d47101aacb4233959586fb7f38241df18a7484d8550a6e1046b45a5373a2a14df964a2e687b818c8e47dad1a19d804e9cc388d7d0ce26929a389ce3ab1bf0f36402a8710babed311001dc114f24faeddb131b19a630002d7fe8725ca4a0ade2d2e5081abeba47f5480bd7824af6875e45e7a0f1ba13caee2ffeef7a2076f6e85f0e55aaeaf7b4a8501b9afe0b89c38358ccdf997ca089e07a155d23cc3928f9403b31f478cd6ba27a7506748640e754ea8c756ec9a5e26d1c23b1281461ab6988f29a2b425ec59dbe93b37cae096ae8227bb07e9c9d3ee76931e57c7ce90ecd1a4f18bba1f613efdde73dc57eadfd7abf45782b652c89da162df50a03382d2b526599c4f5cf7fe13a01efeb87fd72ff2cf5c1f76ebd19e3e18b47b4dd2fce55dc1407955d1da04eeb4029f7af62a6ee365f098f7b0300a9d30d464d4dc7e027ca883ad6309499ee757543a0572371f2cebc4250e1b6de73ef91ff1e81a80dcd3dcb8c797a135197d0f11804fddfe72729befc9130b0f5df3af3633f701cab129880772a70b4a42fe54d66b24c05acf5b6a741dfab40c23781e13d12b5c58945483425a32cca33c3789a92b771d3a72fcdc6fab9ef596cb6ea6420850183180e949604de654f6c6e23b87dfd0f8ff73acaff480e6985e560dae5c46ec3f0e5532a1c06ab3e15ef2bc8252e743872eb2a33a2f0eba954e8f3a02748a52e14b464485d1f6e7cb6a7654e42aa61e2da046dc5a1e164f1e82aba54290ed1619335b0726e5ef01907207e68e3851ce4276bc7c0ed5a3f9284838526c66f7263872f7cf4579bf6341d22c92b5a036f767389372d76bc0d926775ff08ca9de30d3be206a442fe3ecf8ae9526789ebb46cb88b18cb0dd36cf6cf375b030147af9fa89f0809b397ba0d35a83091ad49c6f11222bfb4088d65162e03a4cff89157a12cf879a4cf930a6feb2d04ecc96d982610f439984c14c4feabd1ce1f783fbb56f98a63cfcc9a646d76bb1b0472aad9712c209550734401ee937da223f744bf8dbe7466100b2afa01aa9dd64dbd2c824cc544a0ae997d4aef4583757c4ef54f4e96f4cd2aca1ae4d59541147be97439b483862bec8f4c878615b38c29cc90eff9df51ee3b6c38fd912b494f4045f261e99690515e7dce3f826ca00eaaaa8db249b4e1b6219509ed81c7267f713c69c218224b776b45879919cf98fdc10a77e4cc6f4ab7eb23a6d8599ec9f482e774948347515ee4386fc71a8b89e5f226e0ebf6b7b28d1f6803bdd638b6ff37c2aeaa7e0b565b8b50404da910c2141170bec7eb6ccdf96c09d938cd7d4ff6df302e5ff4242db1e9def28e80839fb05502637d511bf2fde053759c33bcc286f52a90b37a0bb6515a150d3c1e21987316b839a07957fa980dc0614accff37e6ea5554a5cbf019b392cf746e55a8aa409a2198204295b8306dddec9da11a5eb8671881030921ab502ebe015e8158b4da61fac3935d41063f2d50559cdff7eee0f181dee7147d30020f1b772b470e13e56b31146db19367764aff2252789afabb0d1a265545a24016e8877ba3cafd8c2c2d97321c472aea2db20b0ac41f6dc2e655b0d0aa500a1e66f1d877323a07ab875762ea8424ee5764217d8acc06ae608d5fce9db63b227996016906bc9ba3132dec4a8f2fb4bc276ce0c04fd4b44a0d163ae0d5ca597028b1305f369153740fc887062ad172a880930a09333577bf6ec597ab8c290713f2d1a66b3912656cbac00c1c0ebe03823da39a61cfdc84937662e68ff448ae4901b004c5c8706f817b928b57f072d74a363c31012fd300cc0c26401d950e9057a594c22e69854f6615f02a379e0d99521bc75bb5001b442ad22c140ee77ba3c8a7ca07ab556b0709c925b7eed815f53debb1d905351070f5957c5d22b58e02d4088557f5af40e7c0b9f2dd4e59088257128b7b8c0e54bac7b8ea63928066442187ec68b18a091c210220f4ba12c4322687685bb085e9d837248b6d32abe8c3b1ae9d52a3a9d35459daa26c24b122979329b5a4a36b721ef6ef9a67df2f12cdd6cdd5406e11b6222e08188d0fb07293cedd772774b788e771185c23633248b898f527e32747754ec1ba847883396ab1e5fda686ef1c1fdc1e29d250721c5aa58fa9cdca0b0db6482f8277a8e2660bfcd4e13106dc386e71e5b89b7efd5a6cd538a0325dab68f760cd770eb9c9ab1f6e58304b5ff8372bedfd6017bf91b7a9588574026cef9f1f58a7d72f235c99aa5bb7b963669fce20ab73f8c39f825ffc837f156008ffc90879fa5f439c6b68aadc9eb93ddd54335b8aadff1d07134d43f72a51258ee3dea3cbafa2bef90329a5b34e8ae434e96233b67d3c7c5d10d0a20fa0f15b4533bfcd103be823227fde7759d67948e0a7b02114f0e3eb52cb9cd56d4be6df6094c09974e4976c9e9628644669f49f93acf74067ebb972f6c6f9a9e038383b6d97fb4245e2d921265659362edfd0dc4d52a05dff501ec4d76f1476e81c7bbe35f838da78187391423ab617b83f7546bb11900478281bbca82127f9bef8ca1a3cae5ab68c6d6263aab0fc56976a7276ab2c88bdebb6cd6ce8a45e4678ee522fe24fe895b6e8a1d34e5e30b77e8691d4ebcf77399b5016f86a6efc36a07225f5bbb1c1bc06ef8b71639f92f885e8a150efc55e103e09a45985751f54360eaab43af943e0fa00c47fe93fb170aab2b83332502be34190345d340670f215025a6d8fa4e5928afe9abc53d84692c51f3b4f71668b82f9f4c29d136a6edc1ea10749522f7f78d210ca4d8be124a8e7ed937d648dc559b799427d697b4e5f3d5da394f58bee5d4680685351bb90911871691421ed52bda54ba80742b8e4218e8eade6e94d328c644614417c2cc2bac6aba5d9798ebf5529dc336d850494c1bd1a743463db8f9e2bd82d60a01966e120502f552c6cec24941e718ab1a059368ae3dec93e8a65541713ff2350b03a3be07029537b7a466df1b752b1debdc0b2f1b51235ba2d122ff314e6d25f894a8c9e989489ce543fc351d2fa7d5d814d318e1306c4513ad77a0014ec198083faa95ac33648d1c8ab2c1a52eea6fbc60afdbc4162b19384471ed8c7539c7cd6184a106f1a4c9f2818ddfb98f97ce0f77d426a3ff4557ccbc9450f266a3debe7e0019d55431b07a3bcaa0f59ebd0349663640e078fb68361fce000669ccf2d1e213915026da385d72e8dfbc9d6aee7aec9c3e046b59355938ff1877998f9c2a2db42c95a6d0ba97d32a2db23ee99bf8aead723da63e15733b7c8943a245268ddfc2dd27e70d1f85209648c861b67b98470818d6c3c0a4adeb57dd2e79034a230ec364cff36392dfffcfce7ed5f6e92eeeb65ccb7479363cfe7a2b040bea8e558bca058e6941ec918238581148ebec025deaa514fe3998e44f1d9cc11b4301c4bd34b807631958c091f3fc63c38f1a747f868bf8951741b97b9ce1562c9be2ad4c83bfd4a43a541ec803537d1d33fa77b9885e165cff717eb899bf17b78df2f740e921ba9976ae4cbc125716de53eb38619053e6cf96fabe749154639a71fa8b4d037d87ee08d2c4d947900c2ae55758671ea18eb06e22da53aa138c66b599a16993bd0a93610fd794f85b021c4fce1bbbcfc183ed258d6dcd01bd4a31e39d2e9271ad402896519d3afecd034187095da49de8557b29d44b4a5baa0540dfba7374ff2f843231e0ce11b8a7e2f4d9423be0e0ffcf55de8581e41128012b68518e49628ee1b6cb2742928ef36eb7cbdc398a6a9afe980392ce6ae668631f73657ea1efe1176183b409f6a224e72cea30748f1d4cf26d4fe607758a11cf2a091648f4467d21d82258b7cf7ae1584fc2e563fc0bff858c02ff942b3a2399e0f3e6a90431f89b3c70bfe17f70dd72f9f2630f0c0708f003ba6c1399703a46711ee325f25e55c4c8a0c0a6cd9936694079dd92f18f570a7b8d9a923a4c491d3a373c7b3decfb9e916efd8c6b6f31a2cfad3cbfd12f4c5493f9798cf0f85f98b644a1754692dabee5fbefcc9f66bbd1e933b191fedb9e999697fc2ac1b4016c3bf9b859b8f1c7920ec10731585e3249fcefc87d61051db69731ebdfba1184054c20f694b5c0be5d992284984355cd01a6ac0e562cf877eb50b91a4bba800dad92a9c7f1d3e0b52dad20626fb9e5bc00bf21c958b18f5035da77acdc181cda2d963ceac115d692c172d4258d33024dfb32e198268c502822d769714b81a00d9f2e6c5f988a5b7109dc291858b601f844bc367a24fe4aa5caea66369024cb0b47f5e7ffebc9bf211776ee1eeabaa82914815709257136d0706265a797542c9aa6655ae90e38e539462f6736a4eed0b67af61d979e96314a23b015ff57b4d8201fe68ebd974b08242ff236b698280d1f3a4f2ca22bafc9a3188ceba5037735e8582dd8c7a6a4a987a9947209c820a88223f0236c0a25ba087ce74f0af7ffdac08573c5a2e399052286e1477edba34a97782f0a7644a84262ee25029e8296b4ab11ccf5623d63429939497a1449e0735c4be63cae50b9b138695564f612deeb763c24fed676105e5f52e82b755eb41d537754d9193cdb9d94600e5776af8ba28310e5a5f3347d7a66fed989883e3bca4cb83af72ca8f835a9c80a0e56a77eca0d16bc5051d877dec6f3333eb0858d17feefd63ed6c36680076ea29587e485292379b4ee0c6105efdb8b5bef492d03b3b1773b869046f76f0f2cf94dd4df55efde812f167a6360e68102ff253680e228df7aa13febfc66e8cf159095dec5bbf623d5b1aeceafcbc57934aed3700a0935c7c730298f669e6dfd12a847df9846adc3cb771220a44c03f7a1507c1006a971b1417cc92933f0fe35b25794a558951f4a94b53c876763f3fef917f0e0ad72a18ecbe7306f7255c8268cb4659372804ba8c571b7cd6977b2aef1f79d8594f1334e47ec5b2ee17235d1d6967a578ab9d52253d80e43f306c07564ea26649e965d114c513a779045ac324f9d83b6ecb6ff2105135bcb684bd6424694aae9505ea223dd6ad2c8fbadd3e54ddb190e3db4965eb123f4035e225010f8b29b2ef8c31722990aea660c23ee6a6d6cab2af9d420297ada8ee4a055d7b821e5eb8ca80378a09f0be15700b5bb096d4eab00f4f32f9b85334c6713eb9e26b64d1842d33e6b2351dbabd9afbd8d23408f23d5c580218bc33655d91741b85e5d8d94d668ff619cceca0401c21d9e21f1292960d5dfd3b3c2d76b4a4f127a6d64f1875b5e34494a2782f87dba9b4d7ca2f9c76872ca9960a0fbb96da5a445fe3b01619c5592434dc578e12bc11d24b5d6ebc4fdee032eb7a9820179f711111f220bf8d1dd953f1d3b45c8a7d2a18c782eb2b9a013d5649c4df730b7920e53816cd8a01d64de8ca612cd998de28d73c6f385f98d7d1bfadb0a0bb4b4d8debf93ff4822c951f30c4cb78caa02aba6d197f7f77ddcadf45f1daa714e8a0e9b54134dd5dd2007978bb6230bafa301048fde39baace25f74a933d58b297bed765d4c47861f2f69ff5e35f3f8bf29ac5b4a3725feb3daaeb47ac47f6f40a9eb7f277a0833df96dc27701ae81f2b46301425e48a45e75e03a60c4cb3a2cb676313c62a040bd664d8ffa77de43c1b69e837883c5121f183e739060433826b11bbf4a6d996ff591b1c8564ac876d8c2dcc915038135fa17568202b1f5c5d615f07d06acc3911dcdce2111c8158721d1675ae6bedf150ba0643bc91d23924ca5e1f82917c809cfbe140da300922e7c7950c42cd4f257a80347fab60945f66ecfa1257583d72e303c6a448d1a814a08fdfa7dd2c4685b9481d757a9917784494bfa5eab0c7b089849550837929015b4927172ff33a377bcb2b0989a8d12828eadcfa15d5b7caf7acf95ac88fcfd31d3aed70d190ce40b4ff30ea23b90612593bcb42add5d13703a0d3c6cb77407b55a0b7a0911f6b853dd8d77858268d50c1f558e1b1d7cfbae45481d97f58fc55d3bbb0ba0536b2525fdd50d35097ff5976a3c9e45a0faf8f8065a11b99cf68c5024d4321d4f9c7c84a7b1ad3d1bab95057b3c687566e803c8964e52a963d56983d86621592bf33c3a972dde0ddcad394804f69f010a5f4ddb8aecf2bea8a0ebffaeb3701e91630c9d231d4551028327ab9665a78b179f356807aada9c2ebbbb0afb02964c34158157a783b4cc7f2f23cee02776c1c60e7d3c75539b1dd913201b2608c6ba0cd371c69acaf186f5c4ac1668b5e6de4c56f09071978d0d259334a0c83239795b6215d92c2bfb16a5728e36b0aeb8800eb2cf3e40272c27ea81da51f05d5cacd24162e950e717d8d4f7dc71f120be915f734353660d2bd33bc73a73ea9abaa7a81dc0ad0a46b4f172a0f6cb0f8e47066604f3c726d60d2e492714627ae2adbcd5f8b0c1c18289e627cbb862c7660b46c4c599391f528b37892520a2b1eabc35c152243614b2388814fc4105f2dedcaf57179000fc2640a3eedb65abcb72e92429bcfd86295e4dd6febb0d7147f96072689121f53d64993f0bfe9cbbceb34f14f151f8084a8087757c2b74e2d5f7f3db7645d94c6c93938430b35d7a8fca8da66b481b0560743f91d5471577d2f5922240f86cc818643fb59d80a666fd86e648902bb0211aaa20127fe8501e685b8ed96a9bafe54c916312e6df36120a200d0f69554f43fbc2906df78ff1692cd34214cb238eef186d8cebea2e850c8b71778781afdd467bf56b1fb16986ff6e588f3433d857c36e0b818d5833a75736eceff96a5cc9958b46488cba3890e39f5d875ee5c942cae405b58c5f593883ae2f292d5eba83acacf4bccd2c10ae03de6e669804518867a78221b3685336d310ee75c5231c6df347da7bf1013509bc9bc1024c3b78a97a7e1ec5d7ccff86941007a5a17f61619b19652759b62fb999bc210dce1dc2ab6de055e5a68b6250bf3d3865192df83a4123edaf63d8a3377ced179597bd4a886e4ea97e7115016eaf04340f9666cdcbeca9899190e000f36dcfe54d183b92d974787093110a0a849ed73f0e8e42e8c1869601124f7882ee54d0da557e5f7b02d9ab1ea4240c1480edbdd9c118910c338734cd026bbedb801d86cc86aa36a9bdc5668d59c7d1d702e4ad3a073d167192ddacd8ecd069fedc4cdeaab71023efc78ba3196a36183f80b0a344b4ada54fc1818a0bae916e6cbefb5c05d4c182de94a0aaa680e6434109c08247edd22a28f2fbfb5e37ce08bcd2dff8fe0784074f6a3a82e0f08babf3bacc088b1733ef37c096acdabe720da65e417b58eba167c28544088039d45034df57db0846890dc5ec7960671b33f8371ada0a70eee3739b057348e031a68bec2c58113c128a99b205e0cc7a8bc9ba051cf9c0c2a4edc6ea359181c4d9a2f261ccae5fa88de47eb103bfd7b261420e2ddf938551f491e15bac33a752c8fa63f9e470153d4646db44393e49c2685a36b3a08c88d2514dbe49963282a48ca9a24866bed9b7052291e05ef9e49e063a89b1e278a95521482b5750afeaa11f754678b181ccb560a2c9e902ceafabd17d5d864e607a2f4f17a486a1e292f1daad2f3d2fe2f9f6917c95e34080d020056d6c6f22ad9a3832a8461ea830c51e24c974e2ca53a009b0247aa84ca5439e42c5de0c2b524245b9c82a3b91cbeab18250b9424e3aa02e6ba18fc8cd792f37ebe5b95fb0aaaa63c6ee29dd49fd40b36113ab6201878062b07f2c5c1e31712b0c72bb92ec9a1cfd6abc6da76aa012bba5e2009f30b511188d3ef637c2a06f6461886da7cc08414807730ee954534fa9fdaf0ae8814c4653f5a8855700b263c41e7efca71c213d1798cda3a51f9eff4563e9a159a42f746dc6a8d82aa9291029a34d4ce471dafbf945eb28707c30f8d95b87c983e23d97b7122ac6447948562ec97534482966f9b4f13274a6f5cfa70a58a3e7ff429025a926f9e03bf38697025b93269ce153df197874d850632b3b91c6dce489eb4259481f641f890de4a141250039f1fcff2a273932f59979627e1cd3671bcb88edc4f49e88ce8de7498a91c95289aa69ef11e41d4f1cab9a30cbd8d8f594ed1e5f1c8e60be0f7553ae338589d8d6400aafaa1092429f8a200ea496e4b57aad5193716788f56b20b44b2aef3c537becf7380ae14cf190ba916166589c63658ddd30bb5c1f260bedfda589496ef5828d38a0ed98c977c6e51d916e73400aba9fa479da7365ba2961f05fd40e609cfb5a5d19a40187afb455124570c3019cb0a3536bdb916d7279278f27cb0d5020934e7e362c5b2e82ac304e3a09bf7bf04f6313df6e19074694d6bb7ee3bcaf8e659b7ce188c1b942446084ec60c36f150fc0e90570eea6cf8598d3fb5f6830958f97488c57aaccbca015b65a0686dcbea57638ed875add26bdd07262fef9baa7278e0b57f75aa672b3422afc686f898674f4b6911919139a7c2f72ef11db2eb27c9b7ab475809b61d0d1931cff6297382d890def0df9bc1946cebdbd84e1923294b3a2c2c34562183f13773fafa60062a584996c959661c133e381c8a1b43c505b38f7890cf5d9ca040fab8a26d6c699d05da2afac56e9476662f570f8f63bf54c9e7d3444c6f34b75fd0530b709e632796559f7ab4eb7d0debc7c4808c951be03599e5becb4f8daad212a639017851e38de8c7fca7d15ef929acca0e3c9ce210262d44c5397fb0f65313d78e0bd5ef78ea3b067163f7ddb5d438228d590cdaf6be3b5415ea65e22da2c2f956ed19ce3e70b1668fa787a61d12da253b4f327d95aaafd90441cc901384a15b45bd31577d6af869cdde091078d170064d54ab6ea7ad4f12f1286717c0039f2e55726ed698716a0ac57fff032f9768a32264afe12e6031a1c2d28b39146a59ae81678fb23c774c344688bd28ef644532faad95f97e835a274e153b9b88448e1fbcff0316386cf57140974414e993af8a27940718580d6d042ef45af92f253428af64357494894a214ff37fb2e5c6627813cd94d055f72c702f4f4f2670dcd2fd361dad0bccf0e706a62fbe361fe0bffb41364080f350a1d8f75fc5f18d7e1c94ffec6f20b29cccda1e2f5ffc42d9b788821d6f0c239ed280cbff70c8a7f0b55a036703d9cffb6e0f61316754e6effa42f3d3e4e5f016ebc29aebc57430b6fc6a1f3381cca99e1abaf63c3ba99c0fce9917f7e562fa728e44764ea382b90003a9fa9bb3c214329ee2896e33812c0c06c97bd8cd9c08a3ab9d791757f56ee450406a21b9068d96d6ec3818e8e864231312d6ba2e7d1d431029a3d7401cc88a5a4babc36b33cb893614f2c792f1b40e20a5c239fd55d0ded35d7b6d7d7d1b24e56a9100298c6d4fd1e76ca12dd0a08c1493fe058778268e4893004ce811e0eb411e75114b372d0653c416e0ec7575a8575395d874942492df8784b199b66c991fe913eaa8903f90ba938d45852d057969d068292ccfe03915fbbeab30fd1344f195da7885b31db17ef0fef82302597494a6f8a1759332ae83da34a2c7ea1318fe7f3090e2d941c6cd1a39c2b9b5a3751550e018f66b5dcfa9614baf5dbdffc665b22b7a82ddf25e2632f6341a5ce5d90b84f0807d89c8dee9cf927a781973c5e52e1804a95461d5015063dc0e950487b7ae7eff987a7cd238f68157e3f7f4c5b51431fb7190c3ed545a19863d1248e1c343f8f13e6c883d4c1a916afde198d90f523079a97e97d1aeaa78d740c54cd91bb3df1ffc195ab4f831be230b2fd04892d50fbf0d76e0612dcb2ef6cd238c9e93db1c11d85ce47d3f75da4b8f12340bf89c8a3a4886826f31048913d2ed602db3057dd2e0c21b6a49137a9ec631ae5209d020c0b1126119342d74ff450b8497586e2048fb04ee630a8fbc6a8913a5045b6a96dbfb24c3dc74e242e1cb8e41a8e2e23511941a1a2667d4a76eeb60a506063a463e839370850c25125757ac8e5dc874046d2dae74c428adf59e1c4f25019fb80139e7b83dd06c6742803dcccf2b9b7d148f1cd31b8595f932d61383920cc81a975d2eb1a8f7b9cca7ad728463a25b8283c02da6d48fd044235b846033a7a99fbbe5d52683627a29516f1a42615147206a6f0bf01e84a6fcd33d5df13c92a2744ce4358cab5598caf983aa80fe71e4c5941e38a317703fce65af3743b53bbc5895b49fdb401b7530c4b76323a4a1e1b17bbf82cf9fc1d999c52403564507efe958f73dc65ccdfdf08498f7722264a853a890014972988691395965fc16e77e77c5c57c5239bde79e8b367027c82d80f1bf0e959a8025a0ac14699c8b254747c48eb83ec749e27ecb835617227a97305b109b93fe57e9bf73c601fa5335e010ff2b07c2d000eca15648feeb60a275c2eef199bae9a974c92121017d89eeebf045b14102f9389e6130f8ec3649033e94f7d3f0c3d75a463ee9ba51c75ee0cab559a66fd63e215054a23ab99e86dca5665ce33be36f3e5c290ad6094c9bf98255dce5419b4a710e42c96c98f52e61468655a5310cf238b4e89f1c25611d165a7d2ac42970de03b57104c49cd9ed9ff611a5bf53e3cd4fec7f37edec371e20a8138df82ceb5c40b0b33f93eaf74e377eec4947bd17815e65208c9006abd32e387e6c9c06cd5574e8d5bfe6f4c19d640d8a960fb1f755f535c74b4b843a2d84957845a9978b29099ed6bb2083c953a8245e0c073a0423c46fe3180863b88d4f74ee0131678bd6504995b019093b1cb55869a4d2a6b345380f628cf74eddbb49b8759e10eb17a5ad364df26d77e4f86c49bea7d5174bc467b3010e7abcffa253e19419d083763c1b94db63dd916415878f668496966d3ec85b3a7b81b3d8118d6c00598dc3b8149233b41f29101e94722e61c45acd15cb5ae59f3a7aa79aadd7cd69a2df6e659db57258ff90b14bbb46cefac1e37838ac3c2363659978638633c8b755dd0ce9df6121d0a57724849395a2f33e0723db6ec8cb018882c289b1dfe800648c3a6d1199d048f7d14628616c0878c177bd55513ec700ed1818fdf5e7a377c5be93df1ec4815cbe73c87b6e8aba8bffa50f3931560fd9cd7d0b1f485234b2e608332fbe36557bdf1b8c250946894345545c5d236763969b0548d87733a41617d26f6f3fdcd0c0985006aacdc32f53949a4709ad00ff2ac0541593866451c8d09552fa2921cf58ce878e88cc7530bf8b1c6f7465c62dd2680d9af13c0367b5fd58aa2af5ff247093dce21c34d57c898dec1ac6816a536195863bcb5e589a43e302a5cfc6a5ab6eb0253bceb94145e5486851568e64c6b0776e5fefd7f0815674880834a6edc3082d2e073073d63377467fca305864ef80db0dc232ccc9548007e84e7e6875fdef41d387c18e932d1b0984f2183fc74497d383b626ce1df0a1037593fa46a565b0ba905ff03c5a4162885a2396eaa20eb92641c906209547e041450fd64633626784d925658129774f2de0ed472813ef7dd9e87309f9bfb550dbd5092cebe8b28ec870f1c0f85481f1c58ee0fa8b81665c6e59494647fcf4ba71649b9d999c2e193ec6469d9e2af7824784724a35cf4d771fbcc73c0f8823fd067e5dfedb96a61aff483a317c54624e1a1fc421b8e8ccaec9c697b74fafa83e17868305bf425c3115f066e8fcc349c1b6b1da7779ee3715c3a4366656e1d66213da56c055535ccb0a18d1b1f844f27e06a8a1af581273d5c403d8fcd30c0f10e1a5bca92fb8ea36626438f707e4bbc3d62f0858e96f53b02ec73ab61ef1ee3ec1af9b66ca3d91ab1e505abfbb8ca23ed0704edfab536c7ae669c6c42129788803d0ce4fd8adcd6cdf49936280c7c61552a7fbd0776af972bd39f01be427241949bef0c89e98fd1a292201c063d9dfe7aee301df8c00ecbf29183b44cc98181854766d8ed3d9198798bff262de45d00f0120a1fe87e2539026008ba19a58777b38d164d6a62b7c21ff01ceeabfde0da7d11f86ae5e7ec54419a7d51e5ae699f0c48f46407975fbfa049ebee92eedbd6b217c7c8ebcb65dcfa016ac6183d618d646f839e142711a056ad69062759c0e1aadc58b6260af9694ed7aa1adc6006961ff139b8276d7e0cea0917516f278a29c89025beb1bb0b09ecbd89ef2653faeb061f599c47a437dddeadfec5fb8f0dfc7a92c8d6b204d991888dfc15391625771deec118b382b00a9309bec5ff17b68da43cd0cdef8e6b01faa33a13349fe599e730fc97c4aa0c6c1b21eca91be6ca98cf74b1f129901c6687a62cbe017f9cdf12f3ddc9787146b61f9d1f2a054cbd05d9eece70786785a10e9c9f9b576405f300417b4f00c525fcb425e984c6cf27a5d2a874f0d14e84b5eaa92b4bc59d1b9d4f26e961b15187f241934bf9ff09a8c08b04026750e4476d46dba781120b20554b003051f018f890877bf0f9dfb6382c02f90f35afa38d8ee42a048469f02ab7fe7b0507f8f6a71c672db089641dbfa77495a237259a310d650d7be952d4b678ec695a8e9cac80782d73b8c74148038645d45e9dca76958266302d4eccc73e0b072a6ebfcff215875803460c22c348074dcdc6ec2a2f39bbf83e82505ada3bcfad21f4c5eb667ee985c14ec45a6d9bd12a75b4b9f73b4ddd4a931c2b16196f1f0cf32aab8ce8655b022d825b9ebe400324b4094469e16e3147ab1398d2244222b1a4c6efc1dba0dfd237b77b94296f66309b60120ab8eacc066f2c33ee5de599d06552c77e3e034e2ad815be8515fb664a12e1c693e1c869d03d5d21a9c3e1a1aa6a59ba10f21ca096063866e52c696f10019a3386b70a00a693fbf50bc35ea6495c3e23b01102968b1dc2dc7c8d45a80ca122038c279bef84b6af53476ec698a6dad5a460f7d9cc472e192b7fe9580dd6a831ad4aed5db7ead798ed94d77fb55d6c47435c6882abda29c62025bd98ed615a458d22ce1e2e354ee45c8f187c7d0fb2cb967683466fbb0c7d923601ef36514651fcd207526818a9e246e797397941acfec300de71b1423825f07e8bb726742351efaeba648a5f39b8fd58bf0fc099a26f5f6d6af896b5560008faa3423e22b75486a5bef11e7d2caa3a498356112e6aed07f65efa177ccb72d8dc6a718d76c5db3287e7ff9f999b838b526b5ba6cdb2076be70597fb1e3ab4c199899d116fc212cf158989ae5ea9e93bff376528a461fdd20989bb27bb58ea92d119d44a3447fa8e97560d73a59f88bd3f6e48030df9934d3c220c7ff562073b61ea1310b7e6afbec803a44fb7f45483c99f7cfec16d39705f42c2979c3615f4b1fad79007247f471d36c7641c14ce109f444e71e9055e1476398635292c2c0d4b85df51fe7a77b210610291933934e601cbcb7ab05d15ef4dcb64007c07dcde6a192345bd634dcc9bdd0b3fe3d40a03077f7a7d552ee82636c60145d6f9a8eb1bb5f2f117bd2885704a229b3757f3166bd97838456bd0d9cf684cb983bc4e7c78e7920ef3ca9786421cd667072a4f3651a2020214c4ed1cd5e5b9b114ef06bba106cb91ff8d550a0c6d641c7a3483d81e2784dc1ade91ba86405dc5f23b0e1852e358e6c86394be6aa917cc1f1c9c8e74c52f389b29fd84c218d085419528cfad1518eb61866c959b5455c30e75d229d41f4e84d77c615fc7e4d30266cc72f853a07ffc66d5a7147028a09dc64cf8ba0919c3b5753efedea83cf98a1a6460730eec42af48c3bcb85676cb0a616ae76124e597230b5ff1473f2f6261d6147a11b96233e9a0ce5c213706280bc23a04e91337b49ac6e4b6375566baedf2b1ab82fdca6a26aceeb88a33715d5e9a447064f5126379437c6bf8d63f41d492ab7c5c9169f2008ea390cf63d3882bae2676a1f8b35f814572a7142fe3e1620bc4d72dffb26709e5c122e7c3dfc5e926d4e4be82e421e3be226c26d56375e3fe8e21d4eafbaced0c73fba4f5112eb1f5cdb1b7b2d42d663df509a391a8401c7192d8fd619215d3666749d3a69e20cff755a5970fe62d4f7b6d18eeded63f490a6324172118d9a795be6564a9aec2cccec19af62f37d8ad706e5d1d17a7fc02140ae9d8b350cee8b665b427ff094f4d9d10ac18cdda421628ab9a46be88e26a103ab0165c96420fc76f3ca2dfeaecfbb412f774e06b8e76b2d45051a3ece4d6614bec48aed658fc774f70b7648046b1651a99ca4ba2277ac3ff640f234abced226facff66693ebef661ec0f922c9383f1235a6f6ea034cd2293a2e36f566e68c0703f2a287f70faf0649bff7f29e75730d044efc944b87be745f6acdc4fa37b911010c75742464921d27aa9e5f063dfe248b5f3cb9af7aff8929685b14bb54a7b94af244d5f2adfda53d72bb318ec4317e978b468c4bc3c2219031f8f083dd60845edb71511f9898ae7214bc290925a283ee22df286145a284c29346e946758b8a0b5aa2a152b3cbc41ea92eca724cdfbda5b288926db6d1141985046ec508f154b20373c4d750057ec8ddb23b863970d2147ca3b846f90c560291e42488ac6e7f6fdbf966ca40355834a7da065b5c90129651c48002175f4fd31b0d689eb95eab07f45a48cc2b7db78a3aa40c7b33742f6f47962e0ae1d2e5b4031c90fab5ddcccc7c14cb618625a0d44e572d272ce0fb8098cac303c6524cee0c93d5e452accb3fae5926bde05cc766175d6a92cfe0ea71b3e76d6654ff4c7fa87a0deca6d7924b4efe4e8ef8c3caf9038323887f1dbf9aaa3e0d52d3c0a7d259e52a2abed3bb9d1dcbf06a4960250c9a26a1159bbd8831219f4210989e1617c3a7413b22921ae5e4014760a8cb302301663002bffb475db246633f919934d014acf9cbdfac1329f16509f4dd7a1287c84f9d313563c2c78ba752838fa4e27ec6f92a5a38cf7f1494eaba30d707045b226a609843d4586f28c2558193d9b59a1ff1700ccd85c2aea057abcf180b93973ca170eb05afe03fcd4e0fb5978834778c76514db7c2517b9fea30b0081a62ac4b2c49d6074ca4649a3895970c76d5b0b345567fb97ec2421ffd28e8ac8f42b55f9a2a7352ccf764d7971d3edfb62635205fb524b53de4113b58f86ae8e18e3a840e39c8f459a77973963b3d1f6104b60b12f641114ffa6b30364d3c2a167809ae1ccc2ea09a4ee70fb00a29c995d23aa29c7e5a65ade1f2f779ecaf14ea90ea8f6da4458a92fbd2a7d2e5b3d6a4eedee5a7fccbff566fc160946ab379767aa0f26ea35193e6dcc5de61559f75bf4d5b9c89fb472acf7003eede713adaabbc6306ca395240dddf371c5bd63295b905d04fb4c3ddb12a56463d3a20957f107ddef014356539bda23063a6278680f202373b57208f5e63fe10d08dc32427a7560af93ab19c4b6b88c5446376ac49aa03878fda246cd967b141fb48b76f2315e534002310f9f8917152eb2c4b77e48470a6d94d96b6fd785564745769dcf212d35427c4c22b2f3b3aa256ee9a3bca112c34da3de0aece6a5808c0efb1fff57642582284f9b76f9c5bef35a5e87401f251d9399cae4f693de755f1fe2d6fbfe9551cf5f295ae2e7f38b18b830a19913de8e77decefc3ab747fd0359fa7d24fa9914424a87e44c4a9ae755bac0f38cd1756fd216955eb88c08e99dfde736aa8c0d5432f8a321fbe5c09a5057028480ac0f9302dc19549a419477d4f14741c1e667b8737e1100543e90ce6703bc326a77cdb31490c81b3f883f6c1b0dc737434cdc7c427c5f0a9f99e4635b2569af007af0e140313d5717bfee6813b418c2536a2d80984b53af3b6f6cff8ba2dafdb502a8b11813c1caca1432ea1dde581390e61ba763130f6002a3c158a182b98a156dab30f8a998c5fcc496a86a9681754c8d9afe18670c3481c4de14fd7592315c5f400d97a73e350de472275eaa47f8f2dae685c564014bab3ffb56a76f75075054cade0037d31d7244c8bb863b09ac1435beb922cceeab73c474b4098db08c30e400ea33383fd50b177f43e6cb6a610701f91c9cff90f67b1fc0f910a23dd0fa7a202ef5ed0b4ed04c028a2a5a222bc18923989cecf2b893c937801a1e377bfc04fa0a031ea29e0b40534b1e858953df2892d4ceaaeda22b385b0bdb1a5a7bc0ea4334f2fac3de637a46424eb5b89e056b4e5e889e76a4d0fc394f969d2258362b865c78f52e11d4d800cb94dd4f5cebdb7f07454360a5b22e8f25b40872f981d953b39ae32b879dfa1fd60edb7cca5ab433c0193123ec0f4ef1a68565df972f0e1537e706b101f8e61694a0781dc4a039326276c76fb70c0460792ec4a9c49f1af377bbcdba56eb32f052d1cba9dc0a88b3feddfe84da3155b56cdda25607fa2e4f01cf732275ffd2b693fc00d157033aac6b1455d7f3d5ae1dd3cf134f69d437797dd7e291100ecedf061b5270e1a493348e22cc2c3f6f99f969532334efc82dea9380bc61390bd04cf108155af6fb3cf3394843e149b406a68b11847c56da47bc0268efd4481f0c522678071b4a318d6cb974e1961948c44a59f4de392048bf2bc0b47bf591b2e3039dc74c33b4b92cbfc478bd255df6185262952527d043d8b026d7a76ac7ba6c5599299fd0f6de318361e40dc39fec64ff604b484d528b4df6fb842353dea4716b9d9839a5857c96ecd3886a1176d48c23fbbb51b352410fc0b7a372829c339f5255b99cdcced6bed7b7eee3e98c5c9dd60996b7f5ab80d3019c388a9801a2709aba82f8f1625dab73a870915a6c06f585feced3c5366f556e78baa1f1027f2065c46060e0dda83acf018b8c7a75a2de0c381b4c1773c8a691e5a262b062e2cfbd9346dfcaf0dbe1423466eff9dff3fa94cd3da0ccc95d05b342f2740d9a0499fbf7c2465765183b28d352737c8773c8c2732c3abb2243b3067adeb71d9eb8eaa048cb201f40bb25eb897de229b1f7c7c752d836b2dbd18c11c187863a05ffcefea02ca4f81deff66d5232950daf6f5e469f17b48dbe9facea7f36e4d68b7c540c2d25eab06c2e00c2bccba41008f001812acd523a4ac30f71e6ae2e6043dea8aa511f463e768a8eb39e5d9aa581895cfb9f35cf5e8b14ae8336f99800c3460e8f06b5b0b38489e256d02c2c23d701c20a18596206ec969a676382c8c7ec69682dbbf2b960c1fb1fa966ffcdb4e58fd087899439fe9079e7369b483b11baf4fbd18b4f34d374657150d48dec9bb0fca5a5df92334e5104ea945ee99c819c890a1f67eebd10ffa5010564a8783568f4d917d1eb910147a1a7634b5c9dd556f94972b5d86e768846a6802bac2ca59efc1b86eaac5a6175708071199b8135c61243a6e4ca185976c79d09e2e8c12ec2d8743456d46f317bf16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
