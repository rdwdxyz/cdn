<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ba0d04ca0a6bc227cf8a614bd23c2523f913b65b5bc76dfd83e3a6e4d6d99891cbe39738de6fc63cd51a538813e7b123a29eb7783dd5a627a8588d589966eb05730c527971be81eabb3ee3eeb41078b02688a15ec18255390f9769e9406254469e18be05d8f796f4421b78026579201457140a65f226ca3e91ae77d567fef9efbfbea7c824c1f4cc970e289ccdb9a2c3cb17f9ca5e3504355f4f9526cadaa524305557efcd232187ea2ec7e3c3d53e48768d232675150dec0cf1bf7cd125191a74c37e9b5ebc0a3c0baa411b98da9145f0827601799024749fb2cac49b8c05f26f9db2e1274482016665c846d576af3f4531ed1c48ceee3c608410efc7fe2fcd7686ee10fcd75fa5c67977e9b36fd9157f6e721454551d8895acf066940c2509b9d2d746795ea56d26b1c6ea5822ac52f9f5c8eeac4b390e67890e5c2443809f5d5cf49dde53c5de25a40e3cdfd1b6b8e0d79cf4d918af7c59d67f2f74b7f3d93e2edf1ea3e6e4c3c0fc1795b3ce94f013e01dc3888dadde54efc7a2993a63f99265accd529ed2830a994dfdc05dd31fe6faab929d2fe370f5b9f8775cfd9136690e8b16fb823cda1762eaf8bef156820385ea3ba54c07633e5012b05f70eb5991c8f357f5805c8b8cae697aa3913345c97be9e98e542f1d1b40088eaad2c47fab200b4025dd0fb52e82f911e08ef7bab189faee853e39378f35abeada7b9c5f30bbf34bf526d4aa4bd078eed53ebd6bf98a57323444289b618917d123308264097da70c5f623c2b929bc1e52e2bc87ea7c02bc32475aab462757d5ed13e47b5332d51d11819e6c6d826fcd8e7300dd866d65e820f758e720d842da70bf7e23617f22c5aa6b92b211fa0bd74b7f44f3242485ea88d7ae47ef768e036adc1b222bc2d407333477075a185038f6272ed59ef0e1f2268dbea140324ac917b2ae59beec72549aab12bd617d2dbda223d31d8a36f2e8f1e76c79fa89d3d7ac70ccca2917877ce8c9c432343c95faf3f10c2b0a9d6edbf67ff1097526d0689f13cd5cc4120ec10807a6fa1d6d427e51e0424b31f1537d03aff4464b0ddc47af5b000b905ae0dbd23c02798a33c78a338abaef413df492d4bdd05ebd259d016de3305d37ce86716f44a893f3c54dea382ab30a6db31370ade37ee027cc38aa785565edcb7ac6a1b0c432da9da542332282351a2d3e83add83bbad96c6bb01860aecd9c1beac48d5444f57afc351558354051598ddcd88c7b90576e5183250a2829689dd0fb474615d81bb510bbccfe56a2c1557b9b42f50095c1a084df974cf4ce84f2b696db80e7773f024e9ebd4cad9a3257fefeb5f8c3a54dbcc3fdd7e6a7d1f8c1bca2b669e583a6c1ee6ac84995165b1884aa05cb2bce45fb7fe5e9cb3755420634db8f610b3ec8f4ef9872a4e7a9244bdaaa611fc30b2f05d6268d862f78e3bab6292d3a2d28f5ac1022117c11f95f5de029951f1dcfe0272c08b109b7ba7b788cfd22184eef0b5eaf104b82d4fc23f9348e080a550c2c9cc9c0baadd5444188574714f2c832f0120c99e87310857fd7a593651feeb6db4151aab3ad329ea1e38a4441cbd69d53f8455f40050a5821f0b5cf388bc6d7faba53edf1e224a299e8a07ff812b246e83f38fdbd5dd0abe4e163d81f243131c370334f1c908605f4ecb037bd83b837c0bd7312c38980c47d339e093ddffca15aee8c14fa8f83e038279ffd18dbc86cc2133567d5c7a7fa42d4bcdfa2b6f82d8420d256f251977a1d7d6c44785513137ced44ea23d412dfbab5743fe73a0ec52963e2e2c52811db0f39bc84e43c9c544b96e8c324dccc1d975a4b7ccb07b722f31f5237d09991f745ceca2a1feddffa49ce5db4655cfeae21bb7636a96c7f72b97f74d11947a3c6979a49db9093acecd954decab642a419d95346d35599e39c2c09516dbc1caf537e6df5a8c1d0c41e94aff361186be8b97ea5863d724ff449bfb9ef02d938abf4f3e1be982a242e55df5648ae02fd7b83ee73b5cde8a58885d461a4d56398edea4a5efae2af33b83df15208ffd4fb4a2f6ea9c366fafc07c9707e9968707871b8b05d8ea65c644cbc23a6152aa87275144bc44c56fd32198ab4e63d57267458a691f44b97689815e08210c91a8791b66875d70ae3ea1d58502658a7aa1d6871d2c41183b49f240e46e273f389f4626fd39e9bf691fed22e7d30f91b1f19792b6856ddef5d08e91bdc640f5f636c3b9819fc7f07d9e7acd7112c078e7b015fadfebac7436b425e508320f3b46cec9d9e8118557363e8003224b9987583af9b983b93c9f334b88b1e2732360a54b6f5fbcfc130b31029af41cb9b6dab88f8155d8c2e2a133dfc5f57679423e845f7c8759c99ee52967696adfa3a33854989f411824b948e736dc95a1313f514689cc4f843335581c77df80537eca559b1e489626d88e5db228895ec4572e1699d590685b61b56259df4c1c385a70ff95bcfbf4b19342ad0b168a85c2b260613f12d9d68d8f36035719802f97df1831deb2c88109cc026628293e5a7fb5cb0fcaff0c81d384df65ccab6c0d29af6fa2c24aea50daa4c1b677e782c6293fe09d4120fce17da84d0ce6365faf05b6c027a30fa6dbe10d99df5ed37af7195ec2384f36350f6234e598b0833f256d5ba1f2219f5585539262cb05ebbe019967f7eb49c782072a348b55c9811fd52132189459b5a655c8d7a1c794068fd82ca42c81159a9f19370674c0ef25a87e5e799b3ae1c5cc4b8b8be3b71faf4a215142e57d3e38bc3b4f0ca1d65172d0b35af02162a66f0d2abf58c60b5a15f0a4b6d4a12ad241c938e7d82a1ecf8acb3aac1c0738b038c8a88ba5f18d046925542a30a2752ffb773b3b2f2ff91623087c2af39b1661888a79c0d584a28628be35788226c4f55fc9fbe83e65c4410fdc1de46a26fbec0ef46438aa83e596add07afde109c905289e5481c6e3a612c384f519d6b8e7d93cb80da4acaaa2a52f952b225a139b7d2322804b169dba9e81968900fba77880c443fec0f2e76c9dd04f615ceadc843b6680c8d5da6bc8232c123fc85de358060124323a4f2bcea6a14e70d4142ab2d3d62ab7b86a60fed5e0d31313444f5e534acb578b6bd4e9b0f7804744977ced8b11620425608af0c3b94b764e5a06e9f172087b26e89502b93a95bcb29863f5f98be8629b55b200e85f2a276f7e3748c2ca21e4d9b736c9ba752d21d72593150080f95f63113a0dded2bd5b214595358a7de95152153e3138db2b6916a4a06c45dd48bb15190acce5af7703978031a802c8ff7ac76408e54fa0595edd2433c10f3724bd746aba8ff7a4608a54d2efff96ce3a6062a2728ba4de72a87af0dd4a04bb81f8020ad6070d259c4ad0f34125e5322aa0f603472b45d8210b271977683ac1904dcb12a14ff67c74edc13c28d9a330af5e32fe361bd2e05b86dcfeefe4472233a30bda6736170edb35707761d96041cd8d277ae7f76053bf9936f140ed6636e941d44b0ee907b0661584290253d48430d0eadf369d0bdaf142475a590197df812441d36a58594ed6d9fd4f2f15b8638b7ecf206ea65168743f644466e0ea5cd3ae0154be5cc85e978ceeb10837f341360fd42da153aed062f55df09fee682251f14948827152d7260347fb81f10e8f3f85162dc78ed61a7ed0120d39d7048a318ca8af4585b9a9417dfd36a92c9954d186c1fc18380d88e6b681fe1701c655439a306188643ae329c70c264f152b5e89c027f3492a815309f0ed3f50955073babe9d68f99cb961199fa38ef445b474b53ac3e542437a40ec4812eec11e8548e7bbcebb6ee33afd94b2edeb18d5d913580e0ed015d9a0840a2c4d65cf6a5ffacbe3a5086141e27c13c961269066a85a84ab0fc287449e2a80bdcbb58a0c771e06733e9bc9d7e52df0666d9b484ca8255a4d57ed3244cbb9f8d012a97d5aaf52e1481a575368f9dd269de4c2879fa807e9ff4f179a240899c7e32a2fdfec6c146f517ddf37560443c73b228a459279190c64427b65020a21ae70c9d61436021e6e6c832c08e8dfaf167bf8c16dfcd34e272d6e741f43b31c8e967cb836e0b296f8f8ee832348d9d8f13741b5ab5ffb010cebfacbebbf2aeaff0998afb53df92b2eaf7c6473783f8b62e29115572de9c081c67de76c89d3844deefa59091421adc278f7aae7c3070db00bd63ec2e814eb5551881b9ae2b0b0f582932db9a22e6ca49a72d6fb43468ee0072e6b02b803dce6389f84564c57f26fbadca157929ce446228058f8c452bd0b37bc31a7a440347ce2500a44e8cc13a32d71d8b67093498501a4db33701476fabfd8ed93ec8416354d063040080d79c84cdbb330d664d18f7e017e75d2bebb504d78a325f09e2155806a31e10027edfaae6cdfeb263b2f2fe87c81f1a1517fcde5ced7c55e6a81eca37e42e207fdba62dcb71bab17926503554369db54c3305caae082074dd529bc9f8b64d398f7ce55c4f1b72b560a782f1692f3d4767a0f953823e8418484f5fcd30737851135eda20603f45e003764a72457cc295f31c17dfe49793ea03ddf294c3d5357fff5418d6a97ae232c3106df122e4ffa46aae400acbc8aa75bcfc6b8df21d26af01405fef09a911dd02803fbd544be3c2377467b82064c0ebaecfac6524f26d487e14882091832d3347df69019f0a6a25a2e9373276c98b5ad98058c590ec15275c859e524578c639610d415e4f42ff7d5cb39e3677713f7500feaed0bd7638f16d90800cbb19cf8912bf036c44a4044fab04f337ab140f228a5719e062d8db455dd370ce5c565077997fac84b2f0213b41945d2fce8c98a07705468d596a32b5ef74f5f93cdbeb905b00f95e54223f02873d87f3dee1a148dc3ddc9c4f53dfb85b6151fa2bebd355e2d0a34d6c362f7cee1e9ec9e5c06be98e9b68124566f84ca507f61b66ad63ca802a651b7d1688be68e4d3ad689f8c2c29f9a1eda5a642158e4cc2a30516bb79eed59f4fdbfcce927bdd0c545e6c91252e48587ca6fb923dc906a14942cf18494dd1f8c3767bb3ddeafe75b99d355cff07804f1fc0af90137f526b014c58560d6b3701ae605fc361232b3a0ecfa9d1d8674cf7493cde6de39b0cbad40708472673a218f45952a3f5a605029ecc271ad6a0af696091d850e3e6e96c143870892d12a2aedbca0e29b4948c951f5e9521593a517ac2b9e73802a9df128603bdc4655953b380e6696b23bd30671bc7133ff0fa9a117ce1872e44bd1fef889936f0c5b2f24b55f64be13a219b3c6f9aa67a190ae045d21fd70fb68c16d12bca70ed581a0fcd63ff6caa1df898eedacba7d6c574d2b11536eb7b6dba12dbb6374650b02ca5efa77a50d55e5643f6b6a9e5ccba0acb5641082ffeba1490e1b291ed6c076a9fc0550a9ce41cd6cb37096ee32003e50b4d88bf167ea683086229f847588aae9bb6542992aa4dfaf23547d736ff49f4b2d5269f16610512b053cb4d554345e5efa870b73d164b30031d883db4c96c22a29b5023775da46216ca11cd3435a0c9eaf46ea5fbdf77eace6d01c77e86ca93c8da2a065fd1c8f4051ed1b814378b73c634729aa8760391bc41dfced333157cce71f0575d342bfa8445ad56d5779117e400fb2681d1d6ff47672565ef5ec7b8961497a795e9ebdac3a5cf6e2cf5331a16a0d1bfaf98d938df94d63eda1cdcc8617182293094969f3016d60ebbf473d3c8aa5ed17842bc0ca8dc8ed36a1abf14b1601d2f909b342478d1262312fe5fa49444f201f1df739e39cc385368b1d4e73fbfeb467f56d22c6133fac05612da614289c6971ffa7a652d76470123cc925e19736eca48a49b405398af75c972c9c2967e673624d77636a7ea222e377e7ddc3ea766ee8dc8df6c5fe8ebe5d2c48b005fb66dde53674296d18fdb85d814a926218af4f99593bc6b653c6ed2f76611bcad706a4470aa16950851b2f2408b7b5b55fab6dd966e39a01efcb7b4646f87c5c7b7fc78914c7b0dde053f1cef3c25134318b84b2ad88b71563905fe0035ea78bb073d437077a45e827d685ab3fd5479e23528206f19f2ffe58861a3c121d99cc9ce19ef6aa2883ea909f12949bc3ccee50d768ba731da9640fdcc07db72cb6507dfabbca146fe4df46cac2c010d43ad6b44357847a64ad84951d2f18e0851967066aee9319a5be020c2e7b9f9d679d198c0b65d2d3771b0bb38e222ff68fedaf7cc30b668e15496ac57ce9315250df6e4a60ecaa34b586c1d57b3f89a6cf33793ca779089328a6a076eb66c5b2317897e4f432f9bbf278b16d41d8d88b425fa3b798b3eb53cc588b8711460db2267bd17c5384bc7552a47fbaf1c11b74a66a51731c8c8927284de918f2b16b7c4a04cd21f0b38b94ac16f49e032f676973c363a686fb5dec2effe213c1bab6b0431dd37a6d87c160d04dad5221eb24f7aa89a3b88cf347d9d7730823beb1becc03c4738e2e974c09faba21caf978ea5c0831b7a83a1890ff5a1fca0eddca6ae59a6b117575345f156efc3462734c2a73ac26715c26e6e977780ab39d68c78c1d7907103a298ae4a85056c5f51b0b876bed2c78533ffa23b579c4d4be7a8c26fbdfdb5af0b8fba0d4748b3656de900d071df1c98d65d41d4b8035b90cec6b99ec62df98539d49e92ce0fa9cbd4c282a3eb31e622db0ec277d549f974d66627e7df751e3cf4c7375d12051cf6631a574ae3301520d3037c56aef538e428776147c2228a8c75652c0d13ec0503d58e0438047685a80d36a0623e272638ffbbd9f1e60464fe63f04af6ea1f91b8a06b7059313765c3459036086f476ccb46f21eb27e58bdbb3fd7a79809bdd891338ca78df3a962d07b0325794470b8f0e5f4ffb6ed33611e1dece6bd2aea2905bfb0ed2439ed966c3083d8a6d337dd78200b7dc781945941a418a54a2c464273d3a432158f1992ba4f07724264de88c49a1d7fe1c1a41cc85e6772d2b1a1c73be6a81435497101c782b4e9762ee4dde7cc0bc34033961b1f07dbb3a41507ad24ce3ce8c4e6b442b374cf9adaa0598329f105cb2e1cffa206a3c8db15a255288c620ad0037005025650a16414ccf9e0a293a87a7e609cf5658df1883990b279cf8509cdc3e37932218cbd0f5b7c1a28839c6a7aec63fb756c82b786f2dd6307b221785e745e3644225636a0c397eb9cd89ebffc696d475490b58097744764042ec5629a0a4a0c7d1925bfd70f201c650b26ee849b1f2bad4e064c3843bd4486532129a74c3c84f748dfc6ba317f89785c8f7a0ebe1e0853cc40a24edf3d6d9c2e1552cd5c7c27f8c23fa18ba95bb582eec68f0100a15c4e008db96b453333576799ec0b7513d7f9ebf262dc64e961cdb5e55e55e99070d57ffaf425d1d5985690ade41f43fcb08165c4a659a8ba5fb8df3aa312fb14c3b101b0fc26e821a0034ffbf994ac5aba77e00b0234a37438c82cb1e6c4cb278ff1a86bd2a381b0a63fe0ed76c2871ed177642185971d7b14520b690b366e13b3d16356ff9aee198b350cb850828bc26ad0efdb0f4063a4d2501b8d1c854d1c5e9e5a23e331e64a7bde208fa5b0eef5af4900d2141805ea357705cef71ad4fd5b49090bb306e92822b2f98aab8a105a1012d1fb8838f85c7ecfeae1268bf5ce5cd0b1fd72c6a5140ebe6b5a81f283b947dbdcb376b7b2c55f18b98aa6cf64bf6d0e3b2b459723706eee6a23d09e01b18f5a811818f7bf216435976fb7d263d30edfc40429432ddb1effc84a1882f892657004b25e727aff286e0d879c88fe3cc6b094fe4052fb53551b710c96e6d0e646de015e7cb2c425c62087124adf78b1e6fd4adfea73a9d40d93ef00337ba2209fba221e02788d2d3056e0251acdd43c43b78e1f1ae5224d62843c2c256a4c2748685c027d799fb41c166a4c8c7d6877d8aca7eaca74b540617674d3df7d35a7b745809dc22be3623b8889bdbd55d632c4d4e55803d8e0ea41d5cbc8e0f425e0263374a694a55afdfdd7598387b88ef26eaad38e804e30c5dd2fdd28b92d7db8b558f9283412054679c3ecc9e39b049def400357482316abbb4127ebde6b72a1c324e1cc6d6f0417ecb0f2511464845641e0f1feea89b34c5228a2fe6ca3b1952112b2e37bb6634b88f7772d95c6e79ef084e57dc3157b13f394da2771b6cc18d05f9d43092c4e6a20903cda7a203a5ee5595680a50f445fe95afb22f1c095aa436a5bab03ef6367d2c91526d765d38dfe807f9dbc425524b89a4a8ea8e07e0381c2efe28a48446209c386b3ea5d23f89127fdec01b40aae33bd4c0472c50dd48298ea66f6d3b1c7d74842f989b9a14d3cd7a1d6707baeabcfe94bc27473bc723a1eedb2a27a53b42e5e3d6f8e0c2712cd1e474ce6f17c00de40753c59a4e60d7ea5712dbddc5de2147f7784151c85f44b789993e7bc4ef55f1cacf616affb3641e328a4fa22dd1d260ac51399c002de0fd60569f0c57bd8bb82dca026add8fa4d8fc7c2273ee2595a2ce7c1353ef21b516bab738677e8408b1d47f77e64411f34165b744c2efe60abe9e3ea905d11ddaa9c09102b64a3dd13ef3dd5e7db61318d9b020b5f73afa4bc1a2d25d069bf4fb11405639e6c5c1042c206d41c3f2a2a649f1ea6c094038c230a321e09f7e910038460068241c8dd09216aaceba18023cd658fc38c1fd03b032e78b576bd4c6cb5b40cd477cb818fb6104684481a24c5f07fbaa0383f1a592b88bf352674cf4b5a8e9fbe84a338e830a04b21c9947ac3ba3f5b9616cc0621da77263427457a8cd098409c8d0413e94c6dec4e05ee265a8225f2c26ffc143b385c3df4c24a5bbf45cc4c184ac3ba5692abb500bf4ef42308d9facb77e018c7928bdc043f7a6a64eed2287151374cf551d2d4c03ae49142cd128a1f037d5d5c4d035c172df22adbd66f582b3b570153967948b4492fee2d6abc0eab661733c3ca4b3b5f4b42faaae5e80ffb22690cb33660568e423acfd4507793a89b525dea933cb37e473951d2969678a6d378628d8a420ec1021deab3fc7876a5f7473e3909b5eb4b7fd841a15d218e44cbaaa1ad5802dee463bc9e151f14f6d28f77e94086ef6ad4d8f33460af26d44b0f52443bd6468a7c95a1b721e671bd101167121569cb709d49b88d8076c5a24cbff8025335f4e3e291aee3297915539538f5165ab9ba42deb5c6266a02a84850a9961354317136123d02dd00970a511ac93b629a98fe80cc2bdbe72131f92f0a400358595b888b349162eeeeb35fcd99fdce36e88805737d2eb1887bcac90501add23efbdfcf627b8078b4f106a069d21fa7dec1e5e69b614ad9520937a55cf592900404713d8398a3cff619a1067d3fe302a2ddbe0cdb7c5e1738bed56a43c36f7632209e8870a4b423116709afe65ca6aea6f6bf1e7c0eea0c3f1ea69fc5a64da7c10babbe32db691da19afd6d080085fff1f85a785680d9f4a178040cb590772f6c23d7aa6465b8155a1606bb4dd2f898855564a6ab83c2361b034d89a9ccf2a37c9b3fdf578cabc4d1ee297daedd305059a9e4f6605b37012487b675d9cf158b789b4f165eaf96ca8ce015f30507fb1adb1adae5854e6b3349028e01463025540640f9059a34e11bd3a07a1b86ef42425591654c5c6c1a355d7ac8334831741be0b867a9e7f02e92a5e0883170d0eefbda58bfab53fb48ac4352502271803dd7b43a856fd8737c8541a204531cee9ee319f860d53e3541ed4e787ed7efa20db7f4d74a1aa227d01378a83da07804760656f41967568ebe66c160846c3cf3bc20728d2658e704a70ed65036f109d790020520423c775255cedae41639233508f9f16ecc0e3db5f3cab34815e0e25c6f7ead3c3e7b1db18870ec545d20b52171ad6a26a22e47f9aa1da075941d1ac80a5f690ec3df06ac5685b22d10a29b226e9f8329e6cb1abac67b34c09a01a691aef5df3303e352d164349d649c85a542d7cd23a50bbef7a5a387be0274fc8f752777046e7089ed04708c5951244124c01b17abbf33998aee4271a10c4831ee2390fb77cd8ce4e3bd3324b2169e560bc8f458a2b7aa58bdadc329fce2118a0f449a078bee91a56b8bf9eaee86d99b2638f54341145304e90758eca023c9bf0a01b61e12cef695747e337e3d4dd1dac4aa6ac1d040d321aeccf5a5d6228888529a75731d999ac4aaa4c1843e4e6807fd793ffb2cc4c5f0d799e4cd9920b0cc655bfc1547187922b549e62fb09baca230bd46bcfe34ec24986c8483c535e6c12d50027c010e5afd504a2b8eb1a2d1bc11ab6afd4a793a0fd9a3390d5f51727de4bdac6054987568cb859870f652b45e65befe52ec23bcd39e0791acedbf3a71d674f81bece0ac051ba8114b2be983b55b43f04f14f4403cb229612033f7247a884c46c6e0281d794bc922ad0320f0162f292a4303b6319faf4aae6b51f774290eb9ca84ae937b37fcb288d5314592cc9f79b2cfcab2069d3baf7a6815162f40c4ca78ae9beba99b1a30335c7e586c00f7df7eace8f3ebd0787a7c752cf4696522b41c579bf9de9cb6df54fe314080776c5baab4466fef127b9c10c4eb85c2f0a59e72cbb9a079b389bb65fb526550d8009e68227a405c007bb536854cfde5690f92eccc68a0ff01378856ad673c250f8bfbeffc7565b420faaee2c9fcf3944e49dc2e9824cbb5c08a2695f192aba63fb89eabca7b73ee21d4aa00a9dc2773d63b6016bb3cf9b07990856d28ba3b2523335d946846c13380c024d8c64333e824112e6d4ba59c805890699a1411f9a9630f19787c86ec38e954cb1cd2999b7e16923f91f99be14cb1439c1abd617b28d534f3b0924144d3f3a7a7beb7d8fb4efee4123d7349f27987e565b4c8ad522d3784b5cbf5e555fc77cb7465d2b9646b69e680acc34036ffeafb836a21fd84c87e5fe79f21d1937461765cc14ed39e9488d1916a5b6e0057a6b821b9f3acbd676f72c620223a4fa8deb98b2380eb0cd1494852e45884c5b81e8bd27e0004d213a206bd1975db1279406c311b6874a119357cb6412322ba447306c9482d2a48105429a88d175803ae2122b3bb124dc9748d7696d600594fcc5c19c9798121a8067792bd04bcba11a6da256df1fcf34fba2e424e57b1ce036b10a04fd97cadf790480622c64440fabefb14297c81a0db9509a3a09bd531197944d5af8c3cff89af1527756c1e5690fce1cd33d5a3b1946d473ea6613ab8f231a862698ddef4c8b15518629e74e97b7a177ec6d3b9e9f9efb477a054e321d5f12203a63d94cad64dad169fddfd6bbe2a30aa3a7403b8d84c013571db4fcc29f930312a6b45b98c29c67bc078d16cabec110010ee9748e50354c53ed94c49e766f1958e5f824054c8d7918fb521ccde57477a6f36f38b28c50ec374f6efd21d633be43d627c6cf818cb7a755123ca3f282b317b4fa4018b548a3e8d3d9edb53210ed88ad6dc659fce8b9f73fe882e7a4236009099bde98cd717752d08cb2f94e7e9b04b67218ffc21a01ea1848ea94d991ebc627025d90bde60dbf9d289aeab3d0afe4a09917f183b5ee0d5f5063cc5e4421097294e24272b2446de25696e197159539e3aab4e7e022f736d77957db9ce14f58bfc9dad991d75e1b1f795df6026593e7ff2ee309928c7c480fac9e341c91936a53fdc4b8089f896cd379d0d42245e396973fb8f8122828427eabf8c3222bfb63145125d1e0f5cf769a9bced96d313d55e241304762ac88d4b9fdcdc733c5318fdc4630de5ea34d418849601e822fce98cb591a9c07e35d111444167a0b1440d86f19a697404b75212afd0a593389ab0a3cb266adadb15e9f777b3ec9adb6fd142e2b0da854f01d067cb4d23f38858c412fc2eee2f8625f4cddf3b0992fa369fa4da2d24bf2b9b985b2469757beb89a36eefaa2f6844140748dd563043a56e94077d9ae1e277a6167c0d407b67ca6e8500d3385bc0e551166f61231028d9ae45567ac3cb9e9a77dd666047a980e08a14e01870b893becfb4cbbd74e8fef4b26f37be3b604b79f27f8a774e32111195307f55439fe37d2ff9ac8b2e0f81480871a9f2e46e0764a624a71987d79dd181c249a78b83b1e406b19d25c4e922cfe8c52c7ba204277af7ca066e6c14a32b079d08c2470776b9a9af450599fb516e32403eb1e8b070044b9b6c077ee4a5919f9a22793892268db6e34cadb43ea044f6204e981120c475a125dbce03bf7c23b6ab238116a6dbb79a4ec5854f7e11757374c2e372d5e45fcb3518c1ab0f01eeaa2b0ab594cf0d9ae106b965198978abbf818753f90cc4d4b6511df6f5c13503232405d21eb0ed8405a80f43b0337af474a9ff8ab684b422873b7b853a4c96a126ea95fafb7d67ce764bec8ca9e7f71e0ee7ed528a66b255f0fda7bfc350edc7421da6ace9203662d1a50c855c6fbcba673bddc49793ba481830025740eaf2ff7c1e0247e67827ff64ef6060f6bfe3a650113c45720894b73167db35485c065de476fce277ef30d3d1a04b0cc7a020e243ad283778f96f98560ec2fa637b0e4025f2a0f879e489a949118febe14bdd144acebb6b050c2a760c6c2b84292bb77b8dcdae28c5d5e34b2918f19216de71081bdb71019b32120242ae0279ac978d7e7eae1891f1c3fe1c7379af598797e165e5c8615a9991e0270f31cb99a2078253505f1f009f2604c7bed6b95bbe101d8f13fdd364be7d6efc059fff05fbe22954d0f50b4321beaaf1355cc2c1b2dd2cb090c30bd77d9808c67f4fc1f90db685fd55ef0aafd6d425c9b7a4dbcc9b6651ad7c6e67308077e6f5e2920a5d1d5da5b449a7360b70e851a18a9bccef05e1b15568eed251f16246ccf0bdac92d0165570a2bab1ae213f1db8e25a27d0e34c2e858f9105e81fdef148f6126887fa30a900985b36d6e450ee83665850ed60d4c6c976892379e0b27f5bc8acc7041ed340711bcab5b90344157845e264ed185093dace8f4adfc4706004539919d2bdb517eb6f40b9876190c9c65a2e54978f37fdc38db412f05ba291082bbe59cd1ef1d2243b0439e0cc8eb8a02e8798ef1c890e0ced659978afa7c8546ecd8e936b1acd885e042e8393e7abbcfb27a43ddad80bb6e8aeb15fdbeabe149f25a88aacc091046fd46791eba8a3e80c3faa582bac4ba2ed45c7968b8988c33993e671b4fe80eafc834adeee5d3bda426672167152507bed71df3d556e0f2e764d1967089df282d7183661d2aef19b273e9b93c1c1a5016aecdf9542ef41fee4425a5fb35400121e3cea1242a96ce481025cfa7207f3083d8746645f7bae7eaed65a09aaddf8200f5db9a4c64999999c70d8df0777240bbe3d9f591c9df41e0bf10920ca83b4cf326fba5981909919eacf4f855d69dd1e05262f2c4af80925204fb5800c29db9a0d9475a1f72e439d74c8696dc3c86d26aed5f3b3719677deae0b9f65a612b7626c9a5ec3aa7f85a63f162661bd11314489a9732ac99c9b9de453421ba18b85984ad3c4359925847a90aa4dc52731d74b206aea70834d3104e2875012897d07cf401e2dd0fb37669fe33762670d93b2ee9bb516e7a4012aca715bf47af41305f384cec5f2ef6094a09b38907774256e04993d3c5d740ee7914bbbebbb06059e3b3e02d7e80efb14a8f986de01a819f8e327c7d41117312e858a7e0c04d0d94cf78406e58e3b7caeec460ddbc9ee1767184d524285f88d7fa2025422c5047738878c0c828e22924d3009f761415f73cb02995de99e17007a9cf7f3f747201e83b43b068ed2eb6cdd0a1faeffe3b9f6d76b948941cdca6e9426f1fd7c3037d6b0f452004854934c92af55537c803e9c27f1a39aafb07bc10ab4a9c246ed1987aa901ff7ec8ded16957048b9ce6e1618808ca813304fb765591f0f93ea96a5a03f650c5c63761874cf586cd556f2bf352492a8822a237948e0584b321dbc4e42557352bf74a3b34030aaaf8392b9d83b5a5397e442bc55da1bd4bcc0ab95848cdcbebfdc35f8fcc82e391362f7769259841235f5987688af656901655b207a2c2e3e89d695e0d29879ceada5be9e0445c94a1d88144d810e414c48e195795c5cec1b29e4de4d870f82b0d3ceea574432f96d38a26b10fdfbed6fb3c59735bc5df91f68160f35efd3abac7703b2d3c076919c33d3921d8a8175cc06fe867c44d0c40fe7e8aa64c151ce0b828d2701012e6b7a9f3b77d9bde09dfa3846d16e7d38a4cab47971ba86d339ce98d240e1da5fa34d7a80be33dc5aedf9b47b3de9d0ab877d6838e88c292f34ca2d73b4fcf5e20f85d3cbcba68a5194573bd3aa4b210b3f9f1803946581e45a30088c5624c2320344564d3942df79211fdb0dca966c1933414f0c3ab0e40772c8030fed32bd698a71db1651c3b31924ccaee4f16261970db1f7b39615fa08a3335f50f999496f672944a0001ad1ac87bb75274aa62847d51791f76822c0b9cc61dda7c070adcde5773ab68574c3da647b202ba41cee4dbcc7ba9f5550f4fe6a1ffc280830cf637e142e17bc23249bf6276ddb39e1512c389adcdf9f217d8d5564a34798eefc21d5f52dce51e23090c0e561b9d871b138b7ac2e6e19f3feca6d3329a84b863923674307addc68a8bd7545d558478bff3f5fb9919b1a3c088d71d487bb58b80b605758f8293f47bbba49165b73ed561a806f3a46a72d7fe217fd387ad8439c41cb07484d88b90c4548b0d7542860ca228ab3466cba00d191b06786d35973cec307dc3c351d8149a985bb9d96890c5ec8871319c97adc37b23909eada11b96b2661a3d05a726f6d7329b03bf7f2f185e8a47a62680cecd6f060164b092ad8f1a4656731a1ba8f8203d83dd3ce186e605a86ac538a70e761c620c5454ee10be6085598ab641c863311950351f653454f439d97affe9f3ad1b469200b7c8210b38623d7ff5d2f38fd168020a25a43711a428100c7428e51650cc0d56287df6592e9683aa1bce4948f5954141296654034e95e37398a2323f968a762832863418c2f0238024d16a0f63285c4c4e6a5a93adde50b1536fb825e1d425daf34a8f8e04e94957682358ccc3eab95976a09efb4681fbb4c3848e7bd10119a74a7dfb636f948fdec1e14b8e0481bf50734fcabfb767fb6096b416e40bf467354e79aef728b169d797f0ebff38e2b0c0e8df91cbeadf717cd53159dc384c4272fa662289bcc76e11746ccee3769652f95291bf704dd9a838b1b0c7fb9094a866a7468988ecabb609db881e87a3fa26722a101e5470429b4a38b8a5ab61d8191322b88ed109c7a69618664fcea6e8271a6a82ab1fe93684bc6f0d59165616e5df65834654ed157c68e110c5ba6f88d407d133f439269408aa94b8bfe0a726888034aa040fc5fa7d06fa97bc71b6f0465ec32d78dc1a8f549c529ab1de1202c97ce861a01623819362417db458958f2d7c1bcea7354d85b3d5845a4243b914eafcc2886fe316e540bca3c92df8abf26b85e7b20e6397047fda17276cf1933f003a034a5ce21b58bf662c9c746a661e7b18c7e5b6e60c3072086eee78ea0350a7b06efb87e086d544befadf355c011609ba5870bdcf213a6db27500663c052122a4520f7b9c999dd6f781901478a61c56062f246394933f724804991189183e53b2d811a07ba4ebb667f75ce2d984f12c1e3918c5086c5a661dd99b8d0e4aa9cac9f68c87c584b70f0c737b235705aabca7258814da3ff58fa00697773f99cff72ade3c9a218a92963db902801a9e6fc0ca5bbea42b3e7ebda656d3129faf9b07d1fb85928242fd29a09fdea21d759b4f6b5d9f59fe88f697ad80c3f52ccf3c04f728216e626a37dc38e2a1294781c6b1cd9201cd516716bfabfc8f971c3601e4ca689695ec78e53bbb8b14a6a17c1c4b9eb60c5cd22a99c97b1989f86ccb326d40874719b147cc47bf2bbc4bf4be565bd737d90e3b662c2a232ddf89e0a8f3efaae06d844d8f3078092f53f8847ea0b8b50e6476547abf2c43a81b8e3327b0656bbe07e733ab866f26446b4c3d09abe03a13f8a960fc6ed94580c7683c9a98da25f39e7b3f26f5f94663a9fcaa6df931b7ef4f2a2164a2a4b65adcaadd4c1d38fabae6714661a774790afb7f83aff16570b1c29beb9215a4ec4a5067adf1f6a6d13e6536bd3e1705fcfa66a05a4eb1c64013948d14cded621c96fa546d2f2f4aff80427d433b8f158cd931d2dba0cd5b7cbf762aeb0bf7fb3d176e8210ab577a297ad224aada9e1a895a716473aea7507da3aea96229cd76c08ec07a2ef874eaf5efb1f6821c25c350293da80ddc18127e64808be74e126493a10e1c3f77bf02d2fd3c3e3d7a4795030e2b12a566eb3e9f75b30c9e718e155e66aacf554190eb2621764a116798e96751710787737ad14dfa5b363c3dec8d7b5f48bc128bb64b2f85642566de6b4c13c47dc5640384b43dc382199fd189ab57646432da2d290e3cc9cc8e3cbf4a5e4c974859a2f0b3f2818542ba0d3bb138fbd915c9559482f4b1d3c7f4733ff335eb35cb00ca30918e699dc7ab39b971c7180df31781bf60167620c1d88a68bc43cef9eec6b463ab55d9ca2c6ba822d55395dd011654cdb572f3db83726984c7336e259f594092597f7b7d53fc49fd201dc1275e2f9bb91a82193fa43fdefa0fa67d096a248aa1aa43655480dc325010556c4c046543feb4d6c930ce839c7812398e93ed5986ffe2a3a6bce30aaf0634899e28886de80e99ff0f65d4cc9cb5f1ba0245d971217e6ec112d881a3d633daf251d232442f307d7a06a4462797a52118d9ff89fab604aaa6cea66991584dc4420439e779f3def9b288d355a9c555171379bd3cf1273950bef5f701d4dbd16bcc60cb62b41790c76f5ec26a4a1ec48aec933728a15fa91091479223800ff1636290233ad7c7c8aa05996cf8fdf8dc492a2baa9e0ec03273b62d243d844b4bf98ad0a9d5d0f99ef5db774690ae9c84c92ae7fbac95084c5fd66767dc8ed0ef219702d6a480570886383c74684cb1c220d3a6530ffbcfc9a3e11e60263bf9a82c8ebcc377864b7b0793cb63863272e96bb7604b3eb6e15e8f0488bcad2f6753f3872e638e70b6bc3d37469ec8bd39a44682255f4d7296e25428cf73e3e952c6cdcdea0eccec3330b26b2d7d04c1b49cf191445504738e566717901f927bb4622891e70bb397bcf2ed7f475b79811ca161a5cc14bbe3d8fcc54a75def81439ece8e0e5454b434619fb4c5e51ef4c4900a92c75cd83ee61623bcc24425999198dafa5929cd1556b69981b0acc154186b57f9627ccaae4a4e497ca728c5a164719ac2d91a2eb22f97e27713859793b9ae750c8b34247dc958890c9be009932daf791d4dcef768f2466969e133acfba6b78460297becd3228db6bb2500521eadfb4c36cdd5a15a0cc235f3cc4e802939114c777a93675f004e2bec8563b3d8df668766107e256f9e38a92c815cdbe696781cd63269b44d9087a5082656e53c0c9bdc05662742b54f8340c6777bd2006cc5613fca36c2e53774405f0c71599ca45bdde6014267a8c48408371f0df8d215da2b5ea7f7276b7e5f223685437856bd86ab46f5f803df875f3f7b405bfe269865133bc0c7cf4babeb46812528173cc45ec34389f616ad4a168d4ab9e2250c480cde9c3f3d1cc96a8840e6774b7318f66cda922ebd4c187d21fa1eaeedca077987c6fe1c805deba6391e868e18a72c77b1f1705882bbc89c872d307d81b0564d4bdc4f533b42cf0034e99df79783764d735d35f36dcdd1320e8ba1a0b13770eacb96efa4f10e10d4005a824cf7112fbc0ada22baa0a2109776c630cc302e340a5c5dd4b5a2eafb01dba24678e2fc3b8b08cce24dfd658d27dc3ad8859e361d5d9b571167fad6ea6607f6046341a80535c4c49390a3f5fbc644eac7e25b935c43d3e721ce5b27d00f6f9628dfe75f4473a4d2a06896b0f81d21c9a4979d8ca396024bf8128ea416a1fbfd26d3d3c2998b34a96157edea6e1a1f2cca803376e68ed91a48055a68d2994dabb2cdc4c95bea75167704be5d103397ac948f39b8d7c8ffd059d742","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
