<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"977c71f646a5a0e7d4963dc0acc987a1e10aa28d027e4de06e8df2ddeab6dd074ce1c52e9f0a503c809e5b09868eb4e1c079bb1180673dfaf2dd4cf818d5f96adc0e88f7176b723e7b7dddf8aed53e1b0b053d5ea51c9c4ff518eccb090fc2d2ee7340f41e8bd11e6ba38e3463daa30ead7e7de8721b84e297c94df92bf91d90d698edb41f4f29bd728b2894474cf5e62ed121b82b46e30b4a739d472b0a5757651f6df5edf1204bc5c2e600ea62fcf107729ab06e891670d3a34db4949bb132d92fb08c6d77a98a83214d26433f879c7b5e4b04728e6c907ac92b283d7d1ca612949b8a937d80e64dc0f28f969b56c7d886216d9cb048317209c1ab672e41560552961a9e424e2537c3d6c8a2806e4ef9cbfd370c00a000f960c65b6da5ee02abfa3a5dfb051e9a60c30fb10eabbf41a491e44aadeb7e5a1a508e964c500cf71dac8e3d12d0e1951472ae5dcedf9f76bf1d73668caa8b85d7473df31b2ad4d4b88330a01066f041aa17b468d8eb04cbc04bf1a5930ee1872e386ac43d835263cb3c16182a29acef4bf1e038907e9110be422fc07821df3d922b3aa88a2dfd2f36a44a59914c7fa565cb811c7ba705354f9d8560560ec69f27eb5b0797f5690aba4004f69e15fae09f44071ffe27e5322c965463b8d91dffa54fa12614230374f68a92d36f6efd5034467d7e127ca7b0ca3ff599ebd6f69c54524ac6b919459564001fb4971dd491c94e5a3c5b00ea7115400be533b0373a23ead5b7d8c2b5a6d6a361b1ffa31ccd16f4a019a66ba43bc8ff0287eab83a4f0094365a3e448826c61cb1e815391e79de4d9801a07801850635c6adfa65cf005fb8d4ae6a1ecf86f08e3dd3cd7d8333649818834e3abd375f0376246c89c4e6c5eea5d8f63b674a30b84db1ecf353f160cef2f454268308c12fd005366f330cf50270c8f800c398680c2278e1242b1db037e17dad6b0a1552f600b4b50528164322fab476b504666d65d821c56ede25cda12358d9d5b485dc1705ee1924aaa0b2174cedf3ebc3e1adb22b1a4912de6fdab88fcc5c60ec45c1ef7b63e8481480df710cf3d10b409734a313979c247183117e34ab70f19e3abdb57a41ea53ce5d5ec2ec50a7b0517fad2028ddbdcd2d01ebb5bf9bb6006de5c885a1b49af976a355ff26bb2d73f2344ce801d4f3bfa091562135a30b71878e32eafc1ee6780a4b49eb4e6fe97d5b86c33795fa001d69f387adb55ce3bc7d85e41e873dd7a8b0ad85a30eeb3546181f60ca7c0f7ff30caf42817433116294560244d8e48b57651dae965d5c436f50e15da8a4fdea70256cd99419766512c62dd47e6244685914af097932325c109b47324681ac1791429b3cbd5bf63c43746a850a7fc1a7983e4ab1d2b5ca2d6fb4e53ce974ab9fed1174205b786514ab33d8ce0c94958b6697a16852008c352449a0f477ef214f555edac6ceb2f95a826adac5e533940c2fc683ffa0b7df0a789097f4a5baa5a4835a9a9f53a1305e3971f1eaee406ef342be324dfd9332afedac123445a69a6f598c3d51cfcd50fc3d1c9bca8d7fc6bc993160d37731a068e85daa771322a6433b11da59d4435823fe522c7e0e5b0dbae9ab26a2e41ada2a26aa1b77f0d05a0ecb49355c1e7d7c560cab492a535ceaf1108a71946ac96c47cb13dc50edc9c878302922b202fe1efbbe2e06228396b6dd9350d4aa12c55e11c139477d966e55ee54c88d9477d7c75f1c86feae7003023bb554fc267202f68979252604b289d1df5e1f486bc7964daa0a45305b3a6850eb47601ac0db64a3b6447d5ea3b6da0ca8ce773afe419297c9303d75bb2de79b45db753ac83b0913e6315064d42fd5c2f6f37a25d7624705fc762d2f8628da78aaa8c75bee01d61f5bb6b2be1748e5409d565cf2ab277257aa8695318df4e9eb29a8a9177693325fa0b04dcef7df6fa6fb2b288da19ea0a4c62948378fb8a02f6fb74d5fbf4270047b3b3eaef3455645f570b6fbe9189685e665e5016389ad281a0ed70ca26dcbe9c8de7d71ada9c20cde2dfde6ed5a557eff493dfafb6760fbccf87324ac7d4b96a5fa933a51b91543a5090e1473a85393e701562072b41f831afd0f1211566096d8a2f35267985571501f57087a56e51cf2685d36044eea888ee1764622757c9542a5b817f0260f5f8cbaa5b08c88ab00264382549ef16eb1ffb02780e1a72abe3473dccd3c2f0bb188d21e68cab6370e16aa3692634333d8c37ae8ecd5775d97ce08f4a6cd1b621296f90676547607b1c3fea172a309f4bb624cd1d9a950626faac21b0fda6241eb0261c8f6e08ad84dc04f0d6d277ae32cb69a2c7d5a656d27c4623ba6aa68da0698a5e1d71b8929fc2c9455183f00690a33571d1ccf5c7dcf25f810823dcc51216006deeca5f2caab5818b3b9447ba69a43a9a8fc6172689980d2dc78e2f4bf8a7d2976cd08270841a1d731d8d5ae0b9af8b360641a32bf4b7c857e82db34559b28d47e1a04489075e7eba0305531a6ec831eaab5e761592c4012b786a400c2b566a990daa3a6b712570fe4959ad69cf039ed875705916b6f746a6bae236eda14eaeb9b33e4ba36c9c5ce5a52797d59deea2e5c8c692640cb6365c46c4aedf893a8bfffafe990bbba73004d07beb6c67f8a2eda8ea5d9bc133cf4d83c83972e32bf277bd36c8b081194b4de6114a476b5b2947acc62e6c812284ec99419d6f9a4d9ba3714745f324a5693a841c72bf471be10e16e95067030a784ff5f1f36187ab68dbe6e35345fdec899079e442058a73bcb0cef990f58b03a877c794f89b72c01e4f49dcfa6a18d72f0489500e071578907bea026ef369c98302caa4ac953ccb2d701ea2d6f573287abfadf0fe7eca584665d5b398f7e764d0f832898e96c5e16db74c5d7a68a2337c7f552c94c556b8f712551ee70b47a713708c0926153fcdcce5bae04adf794290846b574d7f19b383abd70479b81b0f36fa0d8707ded15e4cfd97de4db2349c45edcbca6aaf3d705b075ebb6427954a38f0c6336d6f74c20e23b86a3ddc645c3feb70bb06621ec794177296f0c2e1a443b79d7ccc967d7d5441ab9d48702401208b4b4c9f331594681fd8f4c69180c2ab42a626cc258ec3ff9f22fda8932d60256c993d43c29ca3d2a1ad2aaf33c96eac9d6bcaba2dda9a98c9af1168ac3830396f2786e5130b59fb6a6827bd7b9c0ff4f7e7d7c8b3c45a9e3749459b7e04846986a31940e4befb813a09dd58a575cdcc515ac5ea115c4ab1d5cef65436499b0372128038c62385eff5e33d6520ce06663a30e6cec944c5b96a0856c342531d75735e97761ae40315bbab32e62fd7b73178df80c878ddcb48a0e5db7b95fb799083e82dd0d1388f43e11094f7627401773f7954cda298228310d44daaac5faab0b893216064df5cfc06742ef27abb19649976bd78ad147050dbeba45bb763d84d8c63c52245643ba2faf6990a1a3688247f2727a7edb7cfcd18eb809da85af844ea60348d6290da8e27b7a2fb754883e61f8e1b0c82b833af663e8e11b8340e57270c824169c7dd2331f14b785e8ccd1152b3f8176b567e53f98a10676bf2acdfeb3233956157fc9ceac1aed4e09fd1b191ab20e4b5ca020059f373d4fce51c0479c9099501439d276f63798b4d3afa475d162b09d1892ae26757ff5fbcd11fb6205cf9331869b2aad1483e6df604298d5bd3e062ead770186dadbb084acb55cdfa285aab1ce78b84426cf6ef2e64195aaeecfc4974e963b06a6367785f2212a85810ba2a6bb835f37bf9470ef78a5b210ccf74f053ab026ff5bd7590802789c7324dd5ac1633de1bed7c36a0df8427566cf12b407bbc18a012fcc300d6dc7bd4ef59791ff68fbc039bdce0cfb6a5f707f575af95944bd47ee16fc2a0f51c2ba4c4721001682e72067f71d24a28e98d90ebc4cb61e76acf62d8e31f734d3ef8b73738c1da15c9278afba413eb4ebb6940932dbaaf4f2a95c60a8342a38c28e57f16070e9d274e2755458f2bff8c8228274c4262ecae24b0d582f8b706d92459695507a8836eed16383bba05a10b9fdf2cbff10382126336009beb41931b91f4feb7e89b0aec4115a6ce2f9ff31a9094751fbed76f8aad7ac2444648fcbcbee2ca6318e11a3919984318506cfc12f2326a44ab861d324490a56bb2544479f734d786c14e4b7dbbbc60e7fb15be18e82a72ee11934245be018d85ed4f110e7cef79cc31d35f6e3f78b9fe4a1f14198a98ebefa4144cdabcd99c6ad236d7bf9a975e0a0caac94f604f3acfa334e0723564ca4971fe8525bb3f948ea30415e12c527757b93abc9a9685a09efe014726774091bcb9ccc2fafdad0dd6942eca29ec6f8207ff139962f1399308944e27f67ee4835119ddba47b0ae9fba2ddb181109a4e137bf5a1ff9b2aafbac9ba2a857c9e6871078332f0e28ea13391b942d5cb42008693c4c01b99c4e786cec13c9f1a6036e941420235bcc2fd4a0104834e94ad4fdc1132853dafba086651242b547744c93d82fa898c8adc84f0b61ef5f58f096bde780214cba7a67f288c84604adc0e26f6e3765d222962644e1be430906af3656525af324f1690041e88d8f4e4c5f2d3573323631ab6c81fb1ce766ba24aaa1b469e59b4360696e944eab8bd46333a75ef9af477ed57827b47d3913347dca4a2bcf6865e6ee2dff87912a0214c54ce02ab7637f03f7f31ab5c1c9924d84b14d6627526eb880897208330869816dd8bd2f22bb7939269f4510d4b2f024f05bbd943859d5595897753e0040dde2b8fc5604a52f5f932ab922926c2d9318184d9780823bdf04e641457a07464416ff678dc1713f46d8f9294c540546b46aace9fad777cb0fd652612bf1fcb36e13d728ce9464072cef2afefb379e3619149248944c2013b1fcb211582556a79473ecb1524dc25d34ea35aef10ae6f2629db7e099b4771fe6fc0b4aee1318c14c04e915c5780095620d4f8cdc2848c323d4caf249402c329a3ce48ec254b2897ef5a58a8c9049bef4a3c99bc99b917376d94dbf3bc21d5f8e075cd3e98d54f3737c7769da2d389f18bd7c6cab94629906e32fba8bb19534132ae5a89cc8ae30d1af75bf0ab53c24c49a94626174359be6e19a57ebd71ce1c6a1a5cace4a22e8dc171359d18378df5a92044df75d9a8930b3aaaf773a26c06229379efc57337f105fe910f28758a6e5fd5073131a421e82147789a5ea2f87c359ddb716680e3b9a0f488dd52a846c5b3115b7a79bce025b4ae0a5463060a1f57e01ea000f22e930389522304696272e56244f9308b5384624fc18d069f20acbd8df258a168b703d7ee94701cd2c48142696c0dea139c9f28a2d95dff89eb175c15e4e48a17facff0e6d29b30b626f52d6ed98716fda225b952ed26233313af20e6d0f37c763d15e648d997eddc6a873ca708647cb3576c81fcafae06ab9dcdfa6061100051e66a845fa3e3ceb0422c168b373cfe8051c68cc7342946f4b255492d5ca3435d5986b2c971bc8d166854901a57182b964d051651ee000ab5cb5084ddd53909e26a402d48a473a24fcb50f408f8760b7e6f2692746c48a7f4dffcc15d4aa2552c904884b6b194aed1a705922bd1a40eefd570828bc763afbe30adf63bf889c939e09e7ab2e9189a02ac8ea9741793fef02931872afb1a7633251b7747982894effb89f75826c64451e8d408aa75d2e1f66fae9028cf7c29197778613dd591710a71d2aacb1e5b2b25883373f2cb699941a4beef9fce88c7ee957733dfdb9d30469ee1563bd69ef4bd5b412ad7032b019bd7ae7165724ec1d7ef8fce84c3f4a1f0faaefce89ad1906187eed173551fae90f9d657e7c25a5226bbf0172e9f934d57cec9a630e33046070b84e4bc76e2ad7b7f1bce9474844f7299d1b7890cd54fb8883f3015603af359c1b2b539f715333496dbd86cc56f2d9d8cee134988252f955210d95bb4300e8bef36654337bd0145ff9cee46abc8df89e75b7bd1f4c0a1bddfb91c2903280e8403c896cc0d867d16b4e21644cbfe2b9c00be03f480d73887694286c83dbfd65fdaa51e526aa87fba08be1dd01c75625bd677f9ea7348918f129fb07cbcfbe263dd7b599c03ea0a2ace50ba132400527f583f552c95f130180abe8bb84abe52e05208b4a9db62c8b2cbd7fbc787d9243cd5a9a496ab7917d8ee636c4f5e837f991b804f992fbd8a390170918c638f64160aab08103cb23ce2c1e9a00b224ecf9a7c5f324bd06ff6887ea4cad8676b328060a16d870512bb48f47d6734fa136c5970ac1f5dcb498d613ff958eb8d52e611a3d33075799f2592069a18689adcd3665d9deb8920315f056b8352f976c93eaebffe114f97cc3b6bac9e4b67651d137bea8fc519568d89502702bbafe7c03c1caedf5321482882faf4df46a754e323eb5e37091c097a4d336f5f5f660991c8f290c6db365effc652f3b2a66c119a77cc7e98ac44c54da1b362389c9cfa7599f923c1d96a084f64db050153b873d3ec369669c45e2202db566a48335c9986fd3c5fc61b004fd36ca8d52389650d3c9bf623dae02818d6aad744c0c66d01d568bc690dda09ffe034ef9485a2bfafde87572c04ea60469bbe6f9f9e622f47cd5f6ce7dcd473ada06cd3a41600c14c4d25b2c03b287b41ceda9096deeed2ed0d9cf9c9c3688b5a91f532ec795ede04b5160ad3369a29c504474ae2f59692fce1d5c7dfa673073df2bc5b1a87b32ae9e7378680a84066830730292736620ba7feafed569c41418a409a0c7eea22bbfbbcab8596f427c9b19f9987420d4fb8b962ed3c71819e129180cab7209caa27d51a7afeb7412cbe233832c655150ddb219f9ac48a49010131b6243b54f4f83bf70c0a7558db1da65c7244c5ee1e9388a567f041816f3938aff297e13a92c49b53da0ef94fae1a94e4ea586031d2f99260cbc2b35abc2070cf88271d20a791893f85fbace63053da728f8ae7c11ba16e9fdee410db8b40cb4dca50b2fb5758d94bab7e2006f14ebb9766bc1bf343b23dadc4079fb66d09b62178d8a9df8895cd8277f0402759cd2efa16cb120438cfb2f17532421e6f6152663f6065bc739117a468281a1093ef4b75fa4a95f01e845694f0b1692a75c3826ce0f64f9ca79d9cdc3a57336634b24a85cf7c80f4bb99e2e459b435d80c7f403ca97dc6724525ee4a65e66f6468277421bc90fde4b1a8ff53744cd0f56484599343d4b8f46e354ee0adb68d06d5648adec0d116fcbe4304ca36829061a7a6b713e0e5598ed10bf01f9b479f7e1da1f68e58b4d703854f52d0ad39f6f9d1ced5d2e0114112cb2f75cbd4d93fb93898013d4f4c079933aa7ee461e7534db104fb57bdffab8de61f694b057b1613f9c9b7ec05216e26c560c5a965b9df70a549f695e131aca074be73a863590cb39f0e443bad9ed88fc1ddcedec50aa663ca9d98501c9bbf0249df69347f3d55e66d82f74270f0eaf6dd1751cd129d313c1fb0db25b3746f3ff77105a48cab53dbca3b240ca4bba41f5e10d12655c265ecf1c4db79cd55b4d9a0bef0f7bcd812327ade86139e509b329259b86e938b1b89565ddee8e27285ab23a2783837bc22f70c6c20bd8589adf30f9dbddde1ef640311e02cc889d64f69e50de3f6e1d52e3481df7c90e40a11fc414cf3ac6976b460bec4721d5ea6c1cfbeff1ce921e411e789ae72dd9069a5e68df81fd48b6ed63ee3d9d765bef142c0f3085fc638a95db37395c1fd9b4001fff1a862b489197ecc694d950ca0690a166380672a8c88e03ca08a7e73cbb5988ff3215a081b95d8a5304cee7ffb892e9bbe119ce5051dfefbf769afd9d13661bb5feec12e30c833168ad2e7c1f8d252f06f4c500ef4aa564eb67fa7ed9afc0e2b50a6c5c1a50c9933f6678f86b333ce16080521c388c65ead9a1321f689d098fcc52d35cca2cfd0bbe9b6f8b466131572f9d52a7d95be8da255503fa138c9d2855fad1d46d1e6283f5d41fd9105ae16fa2ea7d44a7e6ad4950a02555734e37ddc2994d3a9a991e9c4d50670576e79975ecaac3abceba73d49870861febbf05fa3d44805c770fae0898bf4dd7e1caa5adfe8af9a214a2d48de2cedd7d16de6af2de1983bd393e9aeac074fad3b2af2696aa100dacc221d2c5abe37c414972f408952f281b31bff4b01f41aaad64c86b93036f4c4fc1e0993c168c0f9bc3405f0d38d2891b2ef1bbc821027b17e7ee2c5b2a2f320265d2076285aaf36ed9d79b9f932a4372485fdd5875c6383ea97084da2ef832f26fe4b524fe3073371ef2b1fe52caf585c01966a85ea4eb3503d849e879f7ab9c6405e25ac48ee0897f46a60c4c63b24faa3214c59607ea484169bda6e87442302de2209bfd8433f8f76cdeba200bb3c3a31a2b1ed157c6b8ed7b9b82d32a81cfa596983ad4460318440f379705b91ce8bf97989f6d22f888ce6488bf7c31110478098ea43d500f548bebed994bb277087f89902e1db937274b8b39c70c3f1ede74992bdec98994e51dd2ff1c9e16eaaffa21dd85efcdac9e17a2613da06c94b64a2131e72c97d714933aec86a3a05c7926f46b8f02f96f0bd600192f46f17f6d49be7b82a05524699317662241ae8c5774846c8382e701a728c13c8fe13911ad98815abd92b2e649dda3ddb90803054e135dbf253772d02e57b46681cbfb1920001015e256a841bbaff4da6c15bd668cae754cd0845da71629761f48a3e6780266b205fe9a8f8cd375016b7a76d16c4838fb9b0073bc1800a79b13fdc8408443d0e5a6ebd0a9bc4ed7a18d45549a0b63f5f5979d28868a534e874bc7f0f4d107edd3d4a9518caed43caca527d55ec20974b15766fa852e0fa8c439a1a36d6ad77c193b501b4b0c796826fc01cef8b23a67d2ae1f21338b40cbae8358d75e5a50244e2e142becf4d1c0a985ef2b9e1b27e772360000f5990e02a09e20c9d05299cc3017994e03c3f12c7b90d34abd575508ae3779d36068e68bb55b2055f58eb14e80aa0ca5ad64e3a0c5115750be7b4d089534e3b7fe4b5d71ca168d9ac844e73846954afad5e10bcdfb3ffabb674cf65bdd6e1d2bca19b9a81d14abaf566729f480b82096c378b97864b8e5eba08c2a901a85f440d1227d2cb165fcaabff25e2fb73ee80e7356307ccfb252cd356b3d88b356a0210241850179a39d29c25470e8d316f6b6a47a9a4e96a150f0d1fe593691fcd5a202b1db6ba25f9fa06b0d627b5ce433fecb494b144c86a5696eefe8367c28dc81a09b83b39c70807242f929f091f0c556a91a7fb72bc975d68ec00ea1d2a9200f289af075b2e7126f2e0bae949a702d4f943ef1d626aa0cea01a633eaac9844a6131024145902f0b2f07526c5d88847dbe2825a9e860437bb8c4f3aa828ebc0bbfa7faff1f77ace2a69859e1d7caab150742f386623f5c333d8360dd406e4b48fba011aa89c586eb1f5f9786bc2c9534b1ba6164e27ba43c9ad2ac90444f4d82ea3264526cc3ea4b18c2b5c2f078ba89e50223c91afa778b197cdb878e2ea2d3c41b656050bd420dbd39b5e895ac0b42abca45b8737783b84093aa6188549b16dc9f4a7f51205ecb9682439de87778b361de4b6b743a4e5f7a5dd29f696a66076558e77e03c2f2808e8fbade98e6f46d4f7211f2f37d3820234ff045140c9fcf4ac769dbfac0b13735b582b2baa59643223723938d496c6f4c053628381e19ac9dcedfae8da3af16f297452eb658cf990b16825f7508118f9572aea99e6075ecbe1576265e8c39ccb2991f9e548f22611bd60839e9fed8b2a140d0ed048f77598f6a302016b08160d10a250ef94182720318c1fb87e80b73b8a38b2485f213e21c86bb12ae12f9522b70a11013c178c656847ff1afc4d42b5f6ff10990fa308fe06f68ab9da5bfe26e0369e9b4600dc21ecd9332359e3307f33b1b4b51315d332a10969c3d509364fec16a55d90cf914232e8e31c93fd2927f0510b9afe3cd64ebd340cf9b0e9cf8bcb102fbddfebd544270dcf807932676aae4328212753db8384ad3b59181fc2a7be131a2f59828a97316f26d1984e7603c8ea52c52e823df93ae77a45f516bc182869083d0faf9f877419b7766f1b7cfde01aa38d0d45951f9c5dbfa4f71ad46fc72bcf89537a7ae9d9472d5208a88e30b26d02e2adc077fd809816eb3bfdc50f16d7265112d18f74870c9f100d3c36da82087b923df74768dff8ffcedb2dddffc836c1380012c641263171f564a09eb59d0d49a1a60e8e17c936c9e392cecd34dd9b67a4f5219ccbce3ec1d843065768625fb1c9f4bc4177f235a34c1156032c68b3e5185938d3e9a235851e53c313b71a7f9ec945ebb642f16de77b5852b64c6036e118020393e99bf2f34cfd96798738abca02cd99fa257878afba109317c3648960b678bddf808f28df65574f0cbf06c54dfcff4d95d488b901c0083df3b2ca5d2325861efab3214e5e52baff8667994ff0fb3e4411f582f20807555e55c44e7ae8799ff043db4a97087c2a5d1e69b6845015f2ef606c00f3f266c304f9518f4bb0a5970465595826f2be77aaa7f943b0506fdc19dbf3ff55311ffc9cdc99e788e774d38a2180d6d9c5758c2fbdf4de9f5b32c04fd4b40dc16c33f5c6e78a053bd6149cab0935f59b79d900920320e1690bdbb016d52503bd694ab7e9e5298ff2318044fd67b1a08f40916895bbd30c3d51c2fda6d29aa2d4b8629c2613bcc824af28d9039f2b1a3c0a3bb7b934e58220c825801d8fda99ef422b17cfe86e8113568376dd8c80a4bc2c78e1da3a6e3ccbe868337e408d4052b720bd95ff0a4296807fd95b836c606a8172ecee2d298b77f4f7d5e661acf7caf7e9bcfe7c15034b67179853183b41f38da569321d8ad4dac5fb0745e5d7f07ea622550f20d3918e39ad4e3aa8aaa381aa726792b7e01972e74987157d57ff6f437c2bc9a8be96a766e9e7a54a4814fd4255fb7223757f3a5ccf05b23c6d93f84ea9897dea9148e3942f8f4d9c0bf69d49d57d46d8fab718bbc61c453445c3f0a6afc1006cd09792a7238835fe30d456643c6e4e2ab9cf3702567ab541227ca103a94950c90a80b8d12fa2e24f77f98e7421a22a160252aae6b1682341f2384cbfde13d07261d22fd0c56a7e511f5c9152c2c3f8a18d784565767c3171478d66399fb55a182c13bf8d4e8b4cf85ce1da364093346f0c07024f122d697ac2e5c3f1a3d2c499c9a281d6b5e40d36e5158c86e3227abdab15d9cca1a277c4769dc3fded1eedc137909978afcdfec8db025d1852aa3e6ee2f23d02c023b30f83b8820e4d97405585f24c0c9cef967c2416c21e6ebec87f93d63bbca5f1526c41cbf22d4f6f4d12152d69f844f258d19f12fcaa2b155bc0b15067625ba500d1f3926f554f6c887af8b1de34cb696edc38d36f28084dfe84306853f9bff2ccbda46cab311a4ddd55c3d14e594b125052a16a37f1901f65817a136f62e0e767b36ae7970f0f62cc87b48761293377198dde052ddf14ffd5cc437d72e7473db03bccf5a6c8f29ef109c46a3720e78ed2327e9cad7a182bbb81097547094b1679b30b1417d3b03ccbb3c34ce30d3ba296916d71af220c3b96d77f6f8f0151001756039be107f0b2e99c104003b5f755a4f179f62142301c6fbf278e481af3074403ba7e1a86f87795270e2199573adb2ce1a70ec36ab1afd6577e8915c0d1a3c768833a3582767d928f8c0f2c0d63be46b317bf30ba39621b98815e52a1a0d70bcb9a681fa6056f7c85df8baabac4c884824b72fad5f4a488edee3587d5c2be9fd7f8abd25f53ea54cc3965c02ae42f2c1725ad0febb3d9a552026f57079560e4a493366e47d3a019d21e3b27e9ca4b8107d2ba8c23563abd8fb2e625f6605ea0cd31790cc158b232a66740a9a4490cf4a2a90286715c6c10b4e9c0972eec3a02395e4897b3a55588384b853cc7620d5cd01fc0f04ef0022819b800ce0c1003bbf01e872fca157499f9e046bf87afda9f99db10a97e617e6739589c9e58353da8ce46b79b629c77e3966a94113058f950a72eab5ad6843c98abef3395c273406a3f9b370c61f6e971e69ab4be88b259bfd2815b40951ccdbbd89239f3b680ffeece30704a8ebb38f1f7c4ec8105d4410fbf9f41d1ca3205956b4628ce812b9b728ca08a1397c6c7521232fd59909383f0e97cf200a10e392ddfc05f0773c883487b28ca7779f9c79da65017c1712701a2e1eef379ea378569589d773ad47ca31ab135c731e725717c1d9971328f01fa50748b912a54c614252f9c2534e8281768af0bbb926cd9f8132d2e031cecebfa27ac3bfe68c6d54391b8d563098638824b94ddc9e0b2801b9a382c6d81567a7333e1eb081eecca78c9a873d437d17ac165502fc9d4c079ecfd098b1f665d883267f14fea4efefa2aa72a943d3692544a5e7f4b55978ea61b5472408073a1bc0966a174d8d0ca889ad6f5a904d5244354805ef25b623e560d6071669ea04b72c369a4fad9b6e557e425762b3dc8b7c77141e71cc26b5127288cd885c77095ea9c7425cbc8ad2f6ef9aa7efc2c2f71246cc0cec2736dc2bf5552f86f9d77cd6a9033cce3f12fc265612ab279da06c450944e97e3214f367b6302c466e40ae507e79f3f9dd4834a899f6c8f592e2bdd3c009f9e62cd48aef8fdd5ec092a4ee318b3ce43505060527b252a8e5a7618178ed5d3cf7f989fe8703f02cb495117456363896f794f611c1d3a2f068ee464f22fae3aff79bb6e6f342240fdff358631178c6ff82311045f9960e524a24ae8a42fdaced9737b8469b8c7f6b4c5d938e507fb54a79a55f09bf893525513ef1cbbec4f48b6c7327159ef79452f23b7cd354bb205fbd88673138957d1b4fd9e5a17e6ab3d225ae629d2db00578f6e9de040b5747261ee6eb6c355ed572e8b17241a18f066e19a6132a22030d64f7f612317121cc6d1816da7586465d3ab33dd4201676c155109d8020a3903d60f14d36284fda9e1d2fd3270f4f5ebf589677376cda4c9e20131acbf0adbcabbbac16cb5dd45afbba61cdd1c95ac5cfde27d19aa4a77a7bc69f5b24f2fcd6733579ef42fd7dfcfa2bc63d5416e6c86d423f7502f139aa350ecf6518ba04f73eb9663d07779be4bc5cd6eb6446c5c9494df30956e56a0ea3118c793f0b3331ec5ad7c35c7f3496bfa4e8cd13e662f7db2aa79a778fb9121d9b2d7aeda2d9c084229f0bdc7eee95adf504807d95404f6985559efabb60c8c90d73f30c4465c417ea1a9b3544bf6996a09ae96c8846a9e668f8fc1e70470d72e97f46aa4d9aae17c4d261f544275dd8c21b316a69018b4aa05450ce2e86c73805571a2dadc924e35e1f2d74e4033511a801b6ca41e79d7e77ef97eb73f02f1d27db0c4d35d1984aa3c6f778a39ec5cf39b48e935128a87695362b084da8f1309b8e5cce9327eac1b22b00775ac16b25778f296a629f81a89e2b8e58ddcfab097d222048f9be76cf39973a0cb41d51229fc4290bd06c9719cdad7662a071a79ca94571ca9c63076e49ec5196a4f9be40a8f5a6c6542dd888dd4426dd7d622e50b8990f8620a021961c140db6b4c1f1c068c6fdd0351ad3eed4a5858403c56631c6f692d4ca8f6ea5092a39285b666ff9f08e85b5d03efec8607b95fc33f68547259244d36eddaee79f92b9facd880b4f72753cac72b8daf68f27cda797dc28f005f18c5a5299ba0becb30bd0090dd54cb15570d0d53bb355c8cfe5abecb085eff0c8468b31669f8c876ce3abc89279392e7e3b36dee899119dbd579f1148a8ed52d241ebab0d79c90ba8cca3c4d4d91671da20ffe15a0cde8b017b9fa88342dcf545af8cfd8b54f5ddcdd7cce04fe2a9909397c1931fff3f77b8ac57f618272f4435f35beada10dcdbf4ed13a9b56068d7a1ae68e3384d47ff76e3716cc320fc8362b2877cad775b4c22398aa44107fe5778d56ff69cd0607bc791802f0227acc14cd53d34149d7d410eb9d1d7f4701b29690b5245b5f812cbb1178c389c304b63ba4a11efb8243538a54068a4ac5995fd209ab026ca936669594f1c3bfb99f0a4cc1b04d353feafab6231534e59e0bdc5adbb3b306a2baf1e6a211d050f14f5464540197dff2cee802a2ad60fb62e3fe98ca7de9a1af0b815a34f659915afeeffb4e290bfb56e26cde5f0379cd193c189149715e6a9365efd33b2c6dfc1848a9665e9208a160408360f29e25c34ec3b33bf145d390d746e51cdcec5a898f5774a273dda52755372db2c124a0e6e1fb03af891318999c096b1ae87a2972242f6886087c16ffe6e6bb96a5edcb0edab4088608754b5413421bde62f749367b2a5aaea05e6dcb8755889e42aba7ff2acd9a0e2eb018be8f4d0951853bd6a2c1f11e25d8d144e5e17f2e45de412f04e853800af0b719ab705b8277edc35570c459deb848b2619548ab2db8308b2a23143dee7d23269424e3dbd130772691dbda6d3d754da970e18abe42eedbb0d654f008305f63252402724212f2893379f21412a9924c8509ec766084d065d7d2348fe235209c450998f8fec77439e6d1852693b9bfaf9a56a8f579195fce9258f8511ac1ea4151b865f77ac5abecc6a215c9939f96d2481b2f5f101966091ff9ba8c607fca1e050fcf4149345fe02eda796a434a86e90b88f165ffdc81777ac91aba7edcefd50dada57b909d7e886da1307867c12ca44ebedec6e1dfe7e786be74b588fcde5afaefee58ede0b085ba6d9144d92ad7ed951ef4cf3668a80a64a11fd930199afdea534e36126940e0270043333e7bb0ac70fbe8e383d9769cccbd86208eedc09b65f0f7d310a6e13c59e5ba88743a789847c46e1b1b79d41634e2649616d2973b1d8a424ecb83eea7addd3c4759fbf00ef4f3b67d577303c0cb0e6f4f8ad70bb851c11f03b5e82427a0a358db30da02dce49783808362e3dc54d2872a17e97a72a2e148b84b774cfcef0569c320d5beaf8ce4064042250a9c8d7341bad1366d4684c136d8e9ccdfac97307253258dc1f46a3cf3d427d4bdcfb2c58c944912b095a6035fb35efe12f6e8340221d929c9de96a2da1383f2d8e2cd2f18b6dcc05378038f747e6c280c74ec4d375d48b734ba7b339e617aaf538039930d1de1c2222251e79854f77f818009b875a680d7addb634ba58c84c9f690ab69d37398d2852bbd2e6c333d696fa7c09c0b973ade0dc589eaca82bb2d25dd5ea286c55f7444a997ed3b01687285771aa967f1c7487f27f3f2105fc3f8558d6fcfac16088090dd1e6133320a98b2b4dcb7d889cf061c022f3de92e47309dbf4e877e160aa1767e58a7003292435a87dceb0b2e170db5e9a85d8fe1fbfb9d43d8c3b7bb4f05c7d90d11ae585787341fcd34d747a0ea6b500516d233091a5b12b87fb89c4a6d49b6f5b6dacc1f945f9c54e76523393a4f7a77b8e37e2fdf546db6890ffe899f5ba8cda0c67f43f698b77e0788bcf4bbb71472f48d2a3ae82f2ff29516aaf95c43f6b207f6ec49bf4fa6afa9cd9316d727c2ddaa69f7467027782e4780f16074bf6d4938404f35af0ec7bb2c772817281d66ddd027ca3c1239c11f3ea4779a5a5786d552ead0b5a95894930b6dd9006486e8948764d5f26a8bde0429ee44509e5793c076a9d9ff17c6fe79c42ccb6ec87ae789d17a9f71810a02e408d87d53d04c8e20e3107118037dcbdf7de189d276c582257dd6488b33bb8de78f2575504ddbf8402b51f49c3be9fbf70a4503908c47d59c51ee4539dfe20901a62283cd4b10fb53098d76e130f6f1cda7fa4c9e335e22326720cd26ff96d99e9f49f75b771c71ee543bf7e6b08033019ad2d088e1d87038ac2a33dca3e874e4ef4b22e76de6f44cfdf66bb23b19bb536c326494c0b2fe391baad44f8ea632f24becd4831e9ffb15dc2d78e45c62945983b25b763369151798e0db0c8292e2eb06b9f7e30fcd56609d59f5c175ce8d166918ac0a43a8da0c7b7b00806d24ce6a009daedc4f58a26fe31c4ef3ca7efcccf79ac5b3aa1cf9263efb06ddcba4c0dec81e2c26c104f5f05e4f82864cf99cf59a67b14906fceb143e02dec7e8cf498b0d96bd030cda2138835f66f7d45965c747fdd6e497bbf7943333fb84669009f59dec29c40ef8953790a5d649d7f026634bd5d4ca8518f0e2e02e450a3ae81a4173aea4ebb2b9265aff221f0dd413e80f66e134a672cdc4e181df3472a0d3f287a079789d5510f1c686e207c05da28087287fb78613ee72608296acfc5b3e42e1dad8316811f4a02728292e69eb10251107df2f691b5ee700e031f371c16647295d7a61d961c5d94e687a8200adfe23e53674666ec7d6326015b4afc6634845e28f875c68afea1720f65ed268192868a0a73c80c7559a33c53dafe1d2c4019c8935fec150471aed6cff39d139c465a080f982fa17c5404964bb8d371fe27026c1253538ec5f7d027ddadd927a6da88cbc1e6a71008b2d7afa27edae7c6a0a7784b97c92edc4818f2adbff32e1363a2654d43db63e58ceea830e57c76f9374e7e7c55c5d2a9604fa7c1b6d44f323dbd3a44dae4db9f0f5985023059edfa0166c06be89412854cc26ac19c25ba84103962d6a6369fb9a754177d0074c581a1110d3bd0c88b8982191e6850475a6857fd0237506925a2062cda72e7de94fc4b1c2dc10d66f6fb1fec2876f2dc299259b733eda55b1c99f5f0205ea909c1463bafae186ef788a623f0a56c30d11827bd78d8f8fc62e7a6d9bb32201303fe4322a1041acee6eaf5f7d3fa050b4b1a34764694458bde28bd49d7b98a89d4d56487ab50684cdabec6966530fd795f68ce0d1a222b269b9913466fac6d911abaac21055479f872d197b680a2f092f359c047b799b314bf3951d60f6189be0bfa0c1daf3eb19f0c78c4a9f114d531954ffaad4c183c936fc5ecbf6a3e67953c0fb62cb78ad469e812f37a06b26a3f4438ad8988448755369f3036c98af45e5c0ae494e700828ec34f21fe97194db43b3b7a5314a875bbf41a7320d291f2984a6ff02088f7c208fb28ff876d8d13bb530fe27b688befa3e5c0f4b54a8617df09827148703c0dc021474587066a9257c2875329e477e80e3d16fc3cd8480581503d65dd5c8f87da4fee1839ce776fd757527adc37816af7b4ad8888975615ede20cdb73ed2805b7789172fb8c962ad66498151ca9dde1c01018bf9415e4022c56fea73c3875fa7ddc6a907e52bfaa004b4082dd6adb8a8a6913cf74db93c75c7ea90b7a5b8201e80c5390a905df116618a486d5cbc82acbe8e382bcbe748b916f4266534c1260e92d7dccea684617c2dbd79bc4449ad6742fb651731519d6df15a8218805a410a5a83affde8de56b029c21b253ba1c94635b88e723db4234b57483ab231b416971d080977bc16abf779a48833d4918577a5fd6867481b6e9b22f62ce6fc767a38ddc36042fbf5a8e057d07bf73f56bee4365bd5cb26a7fecf040412c1c03e0f940bdc6be48b8f0a2adba55813d64fa980564ed1039a978f40cd9286261f875b5a9a1fce10f26bff1a36642c786d89e6feffc54c373ecd796649f6a4cfbcc25f6f0dfd4a4d7e2d6ba30306dc74ea779f1344209562ceb72ed91ef54455e92f160c7296493746cc527d35534ce2337e03408fa57dceee7ca24467b6b6b984f3643740d8f837a9f9998002a71770c9b6c5bca98c6b68b2c6d99f2b8175a2dfa2d0a3f250ef853bc1ad1d02817422e8dce2627640ec46ce84a09d01d893cac21a1b9d88ecc57938f5aec0d6f1be997056858ef06865fc2de67bcc57c1e1c27616b4145c5b277b47231d48f45e73778b45ea27b45baf85f29a63b5da13285ea46699dbcafcc6778588cabee7d7b7cca6d7a70a483cc48455ac6a382fe3c0d429e2b484a9d2625e08dc23becfd4de0936fb084613f893c40cc3b64a88eba06f9ba649275b6fb490dd49962683b116a6e9e2d6f0f88fca3dc0029478b4e6bcfbb1ff2bef1105e9fca4677036337141eee2335085de6567cd5536d68db93c7b21e61f3b18a9402f0c3ac39","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
