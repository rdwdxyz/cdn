<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b1e27198bda9763e795a29b02ebc9d2a8bcaadf67621c0a1ecc08b5fcb5f339272649b2d54b8518a66d9b3bf065ac39052c41b3537f09487010627a2a4534ae4f572af48a2fe40fce4fd0d260e2cd82c9cbaa698a038d1e0f79b86a731de6dac7d72f0bee812832e1d9e2ce0f3c03c1463a39bcdc5b7bc4b9846f0175522f25f29ab1633a64c684f938f3b20738e2f42ebf960ccc4d860a0756113c9c5dfd0fdc9eba1cb761c2ef464f910383dd3f01c888df9cfa88a4e4ed368addbd6f53633c326b9cb8f99de263584f3b185583c06578d70857a59111978c38c28b6dd022d210ebc31ba8eedb44f0d11143841b5a9e67f87686d81db8bf7ac6c09426a7559a9a6af4df6cc878e3e1bef1197c7116291f0f3d1cc04b4299cff46a6491f5034756e48e8a110bb4218ca69341831ec2aee449b96edb4d92cfe723d3e6fca901af0140b0279a140858e9634dba088c58bef1cce4bb8b257e6858eaf0c7d3f95bb56b7f2b89dec2be2894fcdf2c9d59b8b20506354ca051f2d9cce4e7900900e43731b4320c9afc576ef1c4b0fd73894e491e1fd4aff976e5308df8dc9e10278fbcc16775ec40d8c272ea31b6b98b67de863a016f6671546296c922f08af2179110a4eabacb5e36e7a7e821c5e0848b645853dc334764e7958b128432d9043ce3a6f9fb3fcac374d2a3106876425b3de32f0bf6a764298a2c0e95d9b4811781fc6cb9b0f95519e64d9327221e6ed880583073ac3f5ed6393161390488edb7861605e74adeaf377c6765d67d23ba98012e0366ad8b1e4c98add296647925560a8699fe068c9aa10a5720ee3036ca18554da7671c12df5395110f972aa63bd31254fb8c49130625a8268922051f422cf00b00d0e5a20ac32bca8acb14ff1dcb9f26de498ad15286143355ebf83ab9f0433b1d6f92ce51d936abf71abbea8c5a9866558847ac2e5435d539151c92cc1042e24d7ca3d84bae2191d939e55e95d7cd285da0f599697ab354cfd98bd533b22880325a20aa7dd5eee0ec69caef227e897515a1cae494bf2ef8cc1b6321fe6c9bd8006506e711922da5240c71542aaa7c134f61529c41a1ccccc26d2ae1a708e7fdc18ab71b192099fee36a604d7528a6298a2f54e2ef5c6712e1b60a6983a9c84644e6182ceb42d685da8e1a9561185fecd1a117b46d1636521827a6f7e0fe9013285b0d8178b90c3b2db9f628720a8f3e66e3d356d749e5372e229accdbdd6720df60e6b844c3418a871a68793327436ea96260e09ba5a62ccc9c64639585b5d4f36518bf3b01aca5a705a0ee9a215d2f52fe7887d5003e14ab4fe1d2f8ca0bad56c204608f07cc53ba427aa9fa356adba1f8eca1d7554d00e43b2333ae83d1b7589f9ff0861dd5c2d0642b6f103e8afd6e47c02f697ac67d63f2e3b80bbe6d0168fb8181390378aab9d81335de9b638fe4635e503cfb4a352c8c13b7d44e20b4e07612dcb7f0790e88c3dfe05ca16900f7920f6467d94e7241458565397c595a948c09e681b029afbd639792f0d5d4b9af55616b3b390f953b52197d8047517fde232312b57f2a10e46fb975f4a46d40750059cf8a7188606561d8edad62ff5bb817632bae50c9749f74d1fb7e71baf8189af1b9567be09c2b84d74f0d40037e29d93c6fc73d1299c0392120f07f1d5806f902c6bb5e10bcd0b6f24f51c0913273e14ff3f122d8b4993c3e98602df9c9f5dbc4a634242180674cec96f127962d5d18f099099f315fc0221a391afa82ec8b4348472db0db597de5ffd423441fed71a4598d3458042f49b859dc2c711f7475cde3d64b5486a27696d39e669b793f525c61b891103391ba36e3b6d52979060fc5934d261e399c46215d48fbf202a51ae2360ad33dbea4cfe11c092a1c50859e94defd82d71afbea7af0c431c124eadce777c2fac4cfcbdf25a814ca9f477b5c02d0ba139026941a71f552963401a5053508b5c3ea97022da0d650f9be6b128fcd3c3773e93d039b585f11a058801982b001fc5915d74e39e703ed4fa14b432e7a4a49696771fa5447fa802b2dcb42332f31d914710992f2013154da8ab295a769dcfaa272c0808b07d35cbe219897e6dd588e67e769cd791b79ea117ec5482cdd0db2f2e6e91e3d45cc6d955e726708f4638b9b81c0ed82f246620461f464e7cf194d80b8e92827c03e30326312439fa267103c2e11d11a0036ad32020b784a0c8afd24508a657eb7374531aa2d75bbf7c3ca3b83d569933eaad660383c648d3f01a09ec47da4f3204135ae20925af925729bdf1b276f763a229282e7d5e99126e00947da111b33c9f6ba9f8d968bcb0f1068306181f0984200ce6b553c15b3cd104295efc0f8c51da99e4a7ddc540c9f81ee4612291c95d43889bc50e06b9b7adeb4cbffc9529af8b013b39d347a7a25c0bb9aa3c81d4b1d446b4a06b345de2e655c2d367a5d44c9773dd0d60dec871bb4be29ea4782c6b3f9e8cab581bd66860c4d91eb3bf5106d0c83d765d3e5387fa5f731baccab424afacaa8a8a1d09a892c336607ccf412d75e354ccbfd0bcd1f6241ce8989d7555449292d479e89ec51cd61cb9d27500489f31d6b85562d69e29e5b34af49008d6028dac235a0ec0ccd6d9a448608a8bbf429b85f8a07d475908b6f546ab68df14e87685c384ec44a2eb443c53ac1e29fc7da94613dfab6a74834f9405ebc6b9ebdd23703eee51058a67daa2ab4aeb76cf571c8f233a056ef5bec59e5858071ecbdc3655b7d57f3eb5587ae7dc74c68cd1dd038c3b61e7b936ffcc79b38462ad0a28d06ba2fb6412882ea2d0755b76d26bb09e609e565a3b89e584e7960d36db01015f21e5e273e740980bbd120a860d491a78af18b2570862371ea5bbff3058e398c12cf4665064a6859663ecb26423e2cc0d8cc39f5666f1ea8b489e0c849de59b98104bf6dfee41734a72511f4e9cb30cf86455fdc885c8810bccfc5461e22574469bd9b63dedb09913fee1bdfe3f937a181f817d7a29baedde7c167b6da43995d0761f1c080c91e6ac57fd263d9b69f8d5b7d2f00953cfeb4e1bf0a029abf8c2a7c497922458eccf3775936488b2f98bd1738c85a3128c723a2ce24a8fc566651a2cc61e00d7f20a027374ab11c86f35ca335a1e2ec0cc57ca744fb64eef56025656f2e94df3bbcb24bf230567bcc93234a2e0578fafccdda3bfd3a19b2b9b783786f9288a72be0858fbcf7090ec6f53198e47cde88698e331a5f8877d4d51de130b9e26f9d9018c2d794550a598bd97ada86dcbe01a117eb36db12c92769ada2fb469492a0168f318659771d6732309e317d1667330f0029ef62423ba18f4937929affe7388e77d557f3ad16149e7038e7e56c891380c6473a19c6756653d10081fc19c488a8c87462ddbc3408ef071467a16b4ade78301774686705c4e095ba4787e39bc43bee1854eb7bc36fbe843d16318791e4963eff73378ebd1e60db5b5c861056d8a630966768efee3f5dfe4e95c63928643db3fb8f082523685e425412f809206f1a5d62246bed1bd2a452f1755b729f3bac32792ce7652f7654629f588a67897b0496b521351a34475c69a4f4de0f7f8cde9ab4a82fbf5ccdd17cb4734114a2fe6b0739709c24626b24f885ec4489a399d7c94ba23314fd7fd165f89e2f790072951e3343bc7467fefb65c68fc088d97a6dcc129238ea30a0429d48c9c214f933ddd10ca6b22a45e56f5c5419aada07203d93435796dc84edf5eac4f9d4d6badb0a1280e00b3befc0866d742aeae6a408eecdc16e20d6849ed2b1f2733c4ef28a2ca748e7f046aff3efbd58b8a97efa6bda1a477ea6a67a83fb522bb387f737eeb1c3995c777ac3faee0eaa67b6fbf26896635a6fbd43e18a46b3b1ffdbeeb87c0f4ea3225484827c1b77d2101dd7e4c155e375cb7d98f46e61f88000cc8a16b98546157a4c27fb373d62407b241cfcd16cf7edce52aacb8a94cebb9f50c5ccbc3bafe714f762d2e93583ebaf6b9a9713595a320007a97cffd97c6ac3e5569bfa399e83b23bcd08584ca1d04aa3ef0dd0f299cb41e51e1c42f09819d6e7bbd4620a6ccab8ed2db3452a4a81f2bb712331a04dadef6c721420964009449c8107ec84c9cfb01ee8bafe6505b1b79df127a427afef237534c8b050b8bfd6adf0da9558c09695b144343b1cc66c16114b627b05b90e0eaedac2d91a2a9c0f0af4768cee35ada4c84e6b776a694402d35d9cfb2ad3203c8aa4716c398ce7c0f26c576ce378d045b545b55ccbb1b49d9e4e085f1bf4dea91f81e566deefe1bd5225a7e5486a33b6fe5fc428963c572b419487f36e94642a0af1e882ac3b1f550ab752ab711f24943b55cc2fa5f68cea4761ecc79467f058f64f133e06d7aa1fae14719f5ceb6c65a5b6640ecdbb234458eb91f08ca5181d6f9ed23f0b8d11b8d528f3243fb08394f4d559be33aed00f63868752d926a9f33129d0e8c575d48eb14c45e831fcd9f3eca29f6ebec81bfc5d0d7b5d2aef55199989d7bf6dc8ff8379d53b008ae9ada5728b212f66481ea08e38e5b7eb16346b7d69a6e0b446ff6dba0eaf0e722c3d818289d5f3012bd7bb8744e5406e17478dcb0aed5cba3b19708809b2c19fd8b6ea5bd9c06600946112c8cce73b99e78ec7e56703efae114bd601c570341b9e135306dbea4dc6a70c8aaa14aaac1738034f68878973ed116cb4403ca0b2e96b1593da216a05aedaf749ed81c3e022109f152edbe6b63e016ebb276e471fb27b0329ede6bc591face18843a857d6006bcbb46968a2349862526cb6af949625a051c198975872c154c6e0319a513d2969dba381ba20c719d1892d5da63a3360530ae37ca5bc15e21f8ec7c99a4f6fcc6230ac4a9a126e07ec751153083f1fe7def6238152717055be5ce9c980cc7c761988d0bda0952375f84affed40b55d500acb79b83404fa254779b9b851d3e8b4983ca570a7c3e267fe07c2f424f690e1792d957feec5302bd37eb0484292bb9eae6f01e80a417a23c4f95831993603d66093f0a915fd0e9d9105aec4d33e037f79e2da9b6803b7d78b57dfec1e4c741e056f9fa2f4815c07da5c286c87989fc42137a3bb934700b4936a20b7f72eac43baf0abf6ab1f5636d648a6be8d6a824296c122ac1348bbf4ca9efeadfc8b234bee5ae642ed3d90299a20efe57563f6485c1d39e50b08b99719c6524b1e95f30915e97a94b71409c3eceaa23a541f624180b8a05e3fe3ecc2adc733e294440c5919bbb3727d339fc18dd21658521211454d4c35ef2c6017c9809dba3e92d5f9e3ac1f84d27146ec3993eded2838353c8fe39934e17e5d928e0ff6fa26d3be02ac6ab2db5edeb32ea1131a946076af48a6e512939a20676283fd231794834591d1a1c70bf3c25cfbd6ab77ece1b1d4c39f235443e7d64a9a59e2c737e1bb4ce64469b7a4c51c8794a39c1c7107fbf0225d7770e707ec71a92a84b45e9e68d33b4ac4097b4240d1c3b7c7b56ffd4d5fbd0ecc861b94315db420173935112131d806ac59b6baa4af228b2e66855b272cc64f7cb57efb67d58ead3ce4dc6e4c35982596289fc2d438dbbf884033f6591b40a1b392c22d85d6a98fdc64d14cb94c60280574863f4609b096017e8222ec486a7234db85eafdbbeaaf9fe94cd7670cee8f82cd4e91269ea90ee2809ddcff76f4c394404af1ad2f6fbd2e0f7e59ff42a8bfbe69919a7ff1144444d905e9b25e8853c1523c4ab9f70ea49cbcc807df1674a7449d494ea2cddc2f865ce87c9d385dea60c7471d17ff30e24bec17ebdcf6a7f09d3255d5de7b63bce6b38356715ffc37aebe9cba536958d2611196c3b1d4b3bfa4fdbbcfa77831d50a371ef540db6fa99a638312e65fd8b85d6f1808cf205fca3c3cfaea6114adc7149ab428645c19e501023b8200e3a7054b457815c98272931c4dd53fd3e61b25227b75e2625f7120bd84d18b717dce34374783723671d6e7ee0d03b786c4d00f0ff650dc26fa50aeafb82462a6e380ac08e477ae030e977150a66a9eb63065984205c699bf93086cc36e9d2e46d2d68b76e7f561cd91ad814e04dd571525769f4c7af0f36331e7bfae52f0ff8e66ae7b166045a421122e310715050597536cbb5bde1f23983b04eadce8930d807c0e88dd2f4942c56a782564316fa6deca7b6cef93198a7eddd151253d069ad15681e2310998dc1807f61047b2defdfa60d11383724048330d88daee669922287fe91d2cfbee0eb0945a01191733d96569cd432e10d04d1bbd7454cc374fefb77cb9dc28bd17b12fbac6dda62e85a0b5496b534aff5f44e97b4c339a40a11bf7b6143868dd92e7ff642899ad33605e302af9af361012b57ea17de48edf333e5419ca6e0787c319668f4c4ff935c282d3761ef8e399fe7dfa80a21a74d36d9de2596953a89d7bdc32091b06dde0479511b88b44ac18dbecc84a06cf4e78f4a722a32bcc0aa1a1a89b8fd5849e6afb16f7d07cafe7e0a5f630aef252b66873cda6c9e78a9ec3c41a4d70ecfdad645181c36ad93d98988737ed2219f2ec2d1f647bc7ab0a3dd76c96d43765e56a2197ea4bd47f07ded9d969d7bca7e4ceeaf3ee49575780eb56b92eb483cc2fbea72137595c35cc2ab66613b19eeea4c18b7a07568877c6c58b763934241d610ed766a8a0c82429bfc57f6d808e72a71860b961e4db7c92d5882931a0487ba223ef0faf90a249ba4fce5c38f8b6ab987ab3070cd2a92cf1be3cbb2b07a720d2441b5cbed40d73bf4594f434c963da7e3305155e929ffeb1c3a8d17f45adede507828f73cfc1041764cd1916dbd4ac3e211ba27b244a04ec711bdead82462ab6d54f48cc9ec441677a683299b59cfe42ef9c4258654cb9a509a84311e97de545bb37847b872047955463d26be5dec4660f80116096168348f0a70d1ce16f7c527485044863e8c7dcb1ef7a85dd421c1a6eca89e2f1fe1deb828f26be1a59c34b82563e1161d721ac4ca7ff559852fd08faadce172c26570136fac3f51eaf8865eff5a179ae12231415e2a504e41d9ac8b8bea73b4ba834bd7871993ba322f5b44bb2300f1a552178ce2bfe512fb7a7d8a79257854437165e6588841d97cdd92f9897426eef2f4c4ec6c84710d79ba852da70436e34e15df79170275f8fbfe625478735265591e56d695e70c53b316635dd79c52c94ebf1e4401114ec3b03d4ac227f645943192ceb24c98c73178c9acf8f8ce338a87e705c3ccd3407894f1c387a0c8ed533cbe43d6ea5bf680331d269697b6f14a322a8a431b975463950dab52be2b70d9a15148f3893ca0700133416a90ff59c75f6a5e76da52a2185996d7fdc774e2965e12f98752e18106ca2fb8f8530fcd1450e68f0cc828467f10e3b2e08b57663c5b82dd70c24d53df7b4b30672e80ad31d1b41a6e2ed9f5b8d0d718adc2b70298f7d086a7477cd8cfc1ee5a925506bc2db8e88b50dd82729098aafd2c94c9a82d804141d72fa97c8a83a934aa2e324798ecc101aebb7aabadba001a9fc19ce89c089b81592be32b639b16fb36f1473d8137e04386b39d117cf8c7eafed06694efb4906811d0cb719f4da2e5b6e002632b2eae34429b59c87f56e7e8e33791bebb4e66ac2a57531c9c64dbfce7f826a18cf6383443d0a5d56bf627823094bfeed5570dbeb147123ce16e2574e85ef34ebd67e0bc70f6a4400de222dacbf7e9cb18b4d65eadfcbafd9855bf2764e2d15592f9d5d489996a93bd11a96fcf7ceaf273b80a9ec6fdc315ea09f656c38ab1f57ce4871f27ebab615004985abb6e67d06a3eaac8f85afb484d70ab8a50b46be70438b0126d47de65a1429743da61761873b6eedb1291b910bb5be2b0bf228443c6a402b7dc65a606dfafac8f67a037aefd78d54ed3b05573099b1c4fa760f6f25f66a35354d9f06aeb4a7101f80efd0bcaddc4ed7cf6fad8c66fc655411cc74a17781d42819182a4c740e9e87963aebd268ccd3da71616de6310ced4dbf1234ea9c6b1d3b0fa8788b4a8da62924b71f625e01918036bfa6004a6ea2b01c0d48780d0804720a3d55f8b33df172e767208fd4a824918b49fd9d37bc44661c3ea27edfa3b286e4d0da8a8ab09eb28bb194d18d970332c22bb65302fd93266de4df6b43222e6e2edce45ac9538ae768fe04b760a98c58ddd5ded56d016b823825e3a0687e65ca6f46e13f26ce1d0c45fef30e21b82ec91af66f5030ee77b22208dde0e77ce8dee63545974504744f3d8da16089b9573ab1a4e9dae2d5243cec94d574de4e8d88675acadf670f494f455fb2a8bb51f3ec67b04cde99c269d030d3b539acd68e9195288000585df7ce217d501e0d75032dd80290d37bdb176e382bbd956e9bf79194f80cd00b1cd782320ff8c39ce870bfe4026052603b763511e8cdc4a0865a6efd2d2b0f8ca70a0380ff7bf75a90093501e462c1e654abcdbde721b32b11982218a11c1399e89500f00357c42019c16cc57b11e5676ffb4236da5d43cccc9ca4c7ea3650f872becbb7b52fb5993e3192fe0ba40b311a8858b2b0f5fa3df50165afac89a468ea0eff361387b5aec2b7618bc9686288100aed526e7b03ba5d997ab2c17b7f00befae496aebc9d13f16b62138144be587e84e8832f0343f7d3ef8eaeec24d1c19a81b724671a7e197c81c2777bad09ec297b6a2946c4cd07ec20a408728d9803f04f13b15a4f39057b9f510f5c006a0bd0a69f154476c845a74322429f27c5307f226e1c5170ae8f29a3eb45e862e74d9f9740d98e588f970a702515b7d90b554e1ad839f779988544f03fbf1f0914a625fb04df16135a27cc95dcd266198f97f33c541c260cf2f45d8f57d9262db7aef16d1a26ec8099a9544abab176555d3430895d66112b9d362558381395290dd71758088383f53391e0cd817622b436196356bbcc5d285c5d5ced2e0a47fb1f43905d6dd26b73d5b834b24b0cbb0c1e77cad0a8ac79f1acf102b131a1f936d1eb089e2680f068f087c7e170c18101f1e9d329962a65472a23794bc6dc95a93eb58999399891c2ae11625a57571a324f7511255f6765304f16f941351e23847cfb673b764eb46272bfb92679ba3dbba39f91312c2761923300474647ab90d36f6aad05ee8414388e520ef5c15686f4cc2e46e4a5ea82d9bf1a520081a732375ee749ad7b78c94ea91c4b41a8b2a6d32a43acf1bb9154b21fa0cd408625857ff5a3901ccbe7895498b0a1160666f17fe9559d36f0d937d2ebf156d768d57e85c63123cf516d2230480efaeb6340416da3a4babbb3a37efabec692de9bc23934e60df94c3e2bdf9f0eeac06320b523832fcd26913cfe246af10cef8ddd54689ebeff1703a4de2f21213843a305288ba10f28c9b95fb9654cad61233776dd14fb3758a1270aa39cd04b793594a5f60514d62f23cddf18e20b118a8df5c1b348d2fe5481e96fc4c45236d4964410e109af3001b1605ae148631cef273f1a9f7d614917a49282adca3bbbebba87cb52ceabe041e01a9ca83a2ab26b8dfe367de4290777334b597c167a59356389d87c4f7194e23cb1dbab4eee659482213523366343c9fdc532512bc2c969d20c36b4ab78c627c9184bda43061b3388f1a06885e62b73fa1e241efc666944a4ed93b49d257f523c8eca69e4ec6e376a6416da3d9098048a322a5348ca5e5d979dae64850e7f37be3869631e8057c3e1d334ce81786714e40b33ecab9ab42e754143ec0566572cfc782c8691e2faa5ff3f56b29f0905753bdc914b770a1da84e609e7fe6b5fdc272a2d05f65c9f2e84dfadd5b0b6548951ff1287e9690341814a9689feb77b1f96cc9adc35eafa8d18d6e16e0f939096397b1899aa7c9b1475e40b0f92066953ed1c135dde58119b476eff204bb903c8c331ba25f71e073bd77d43a4f1e8f4dad33c3c49019727585adb1589794ee30bfaa3913e31ed8cffb70ceadfb922a3aa409f13cf782df15985f6bf63b32953c9498f1006913210bdfdc822133df567bbb7aa74e195772a94e7993771013efb5c753f733c571be979fa230e13ddfeb50ad1b9fa53a8680621080e3f810e47128ba44f385eceb75505a51eff5b2fee36822f3bad194c1ce84f91ee341fb28caaa01ce93d6711abd8622d1ab9f2b71b45918730bff5a43f561eb938d9ce4f259110f21871ed9201117904b0475b41f3499d275d400b5b9bde7ea6039e3c16cb470fb83863c490992ca720b3cec29f0abbb3e05c070bc4b3f6b170bd1e6326f2a6583bd88c1ab7c389fe7ff6038bbcb95e45421c9b185bcbb55b4e8d48555cb648d2309cb2542de50bc6ac1ff100dd30423fb03b47826903007d8fc4a52658941d67b723f24f884d1907071626668e666590b1062a68369007cf2da99bb4286bf3f9bec8a9a9767df60d467973ed444252d892076d925e7b4c9d3a7fcc103a83fefd2186db08bfac2a221893cf67a50fb3815ae47f74f94dc2cc67e45e21a1e278824076032ae354dfc73d4266f87dfb9ea62993b82df0acd31f6b18342bf9e0cbde1146b46bb9d2c0b3680a2833a1fa7018793547a6727adc1a66fc2443a92c7d4ddf9e3af8295dd60574804f93f14bf6851ea504f30a151f6405206506f7e250fd4f61a85d6e80a4c0650a4f1d200ce3ee13491e0436edc104ebfd1373c77b1075dd42b324d1ae63f0c5065fccb15fbb0cf76afc0492b1b44a6cc812584304e538efde25f33efd616511669d615516a2450504c231031e9a7889ae39b6831b3563fa0dba1a2977c7a5672e4ffa88982e7514f684ef56563e244636e491c5aad931cd0e9ff51619f2a633625d19ba2c185f91320695cc89487e11d7a9b172079e2aa27364a31cdce5b1e6ecccae3018a9e413cf046620789d490b0554b7c9a5ea9a80abc4563090ce1a44470a8763e348a9c3739b8e1a87b4b68a5a843fa842b27bcc4c16b30f02c387ff04aa35b9570836876a0358f935c5f3dcf34368a10db0be19d6e67e86c97c5f28bbdce04052ca31057d0c0705e657c03e35662db996a6b585cbe45e447da79a8c60d24bb149f1917c6b75978907de4fadd030fc0ab0b6ac03f989dcb8d266347bd835e3379b878f541b1f3dc3a53321451f24c5b68f1961b9fe305c97ec6f41ffd581d46a3ad7934c94e51ad4fab273be037b7a27f9022d90de5d1c5d6a7db4dbbbacab95c504111313fb6f2961d973b2496427d4aebb67036ad43528cc754c822f363e2acba0e88c0527d0e0215f40b1f27a498b74686ccb8a4db93696c86aa74d962066cd9cec3ffeb80a2e151f3c2c4963ce968aa59209f17fc102f0d7b5d1d05f991f7c03cdb929ba1128d8e64e9124332457ded0ca1701351056145dbd3fb7b0b69ea4af60cb19677a1a2fb344551b3697ce50a88275f34e78982e393e1b25bc4acfb1b08d29770d443a6dbf4e42cfd04a55a2c2ce06305eb27536c10ab1070e7809930a0f7fc2fea61135bfbcff675bc79346ba89e1d93bdc06cf60c2fe255ebd9d07c0d39fd0d9c3193f280f2e826f03c88c4d8ae5ab1963d8b032bf3c80a46c96a56da1880ca32b1fc2c0cdcba8b6405807adff45b3895d05ccd771fa6bf985669f271ff9f42e8ce1f9ae74e53cefdf41f830ee9db5c7b66672d9cb56a189715ae1ba49b7a795d4f27352dfea5dfe2e09ebd4cd22c012d595799d415c0da3a4ff85f3727c213ecb67571cf171a9c97b1b96515cf861f63e8a6667a90c2493be1c8ce2cdccf590b363bd4fe9c5f880df23cb793c0950f9b75e8a64ff7cf533af46a498d955eeeba88707bf8307c6d9ce52ba867751b4e6323993811503d727b1b8b8da07b858a9708a6e2411343b33d894e71918e4bbb4a39e85ff04f0cf5b20f1450e4c4514bfb5a2c0120e4a93e038b12154a453f2f96356dde39b7a3e3b0e4c29c441dcf4c8cb6902f3749e96c11a8ac7b5fee04ca14f5b233089dee3126e69737a18f74cf4382611d4ffe3ef2252b83a0ebbcec0e1f0756849311820bb4b6c9755a716b3ddd7f2ff1b37ca234155260b0d7e49e65b6e3c38fc914f1f27a47c81823463c7f6374e0dc47ad2a2d479dba32755936ac1388ef9de6b8e24c2f8d4ef75c3935b52a40df218fe717494a584d4d76b898f270d518986c318b5afdfd97add3924a83fe08adedc9f9ae3958104972789b166fa1542b9457e9745d8afd7edee5d5f08dc4c1226ce8c3257a2ff5df9a46e5719e57a551e072ec509fc87405eb3ba3a5db8457fdc44001f4972e4f2f7867ab025886802e4e2ce226e91ae60f0c99b28c69a85c535253117f3bb82cd16acc8277d259fba99371da68f3f133009c15471aab04090f140d940e8d30544697cb5f64d26c02eab7e54d440076e12dfd10ad0a824be1d83e90292e514de90fc60c58c8ada18bfdb734512bfb51c6bf346a831eea7cc035cdd69940f1e6ea63092f1df5099a9e5e4e8784f0c8e55e7fd2794fcb08a9b0c72cad21389cc6d3b7b62163ae7c448bd74d6d7cb891a6dfcf584c240d7b73a2930c4c550788a44fe8d3df267361ecc74ec0239664f9a4e71fef88f4db6bff51ea15565eed7acf19ae8f9a5e896990b2f7e0225a0edec3793673568d1a6cc5d0916c0c47579a9e85dfd3ee348bc987e092f2ad3c700340030ab5ad23f0a5f7cc1d5a83004eb2b850a392b0d3f9f15659570bef20c1aecbd332a9ec261e0cf8573838d938bd2e5e829bf6a44bd9a4b09c0e4cf3f86d0f32162a1b6c870a265f1ba52378350fcc538e82f3b01888b8cbeff7d09f175391cefcc4ca6253c7c94a78eccbafe2ee41c56d624e12727fa0adaa72f97ca655d99224d23f32d9ff52b5518f8f860ba41dcab84df482b18cc162d9ff2089ce9bfbe07d7bdce983a42d9b3947618355b6e9990998f3b15803b414601472a7b5d94dfc3d938ed41c71b66fc4bbffca6419cd72c06b42cf0f5507ded35d7877828646124433dff25af0f8f4b3cb2499e6f6016cec2755e57cc027d405a0538647667fea9cbb7da4967e4fbda4a36c95cf616a0c8d2546575a6dab3d523c20146709add1c64cb6f96a995fad4e95fe727c7e23179440856c137076d956f39512b8242f82ec1dd89e65998aebd79e817708b80dcda0912d034ece3776ea85adf3747eb23cad81767c1cee76d76e7a583880801e9aacc19d300e7c3fe804da44b62e9bfd0e80edaa37948986fca3148abfa60edcc4c15bc9cab375c72d92cf64a8cb6264f5b1956631ddb2c344c9f24d26072fc5e80fae1ff3da6e4e5ac31ab17af0ba731f4f6c1960b9ab29934e5d82612535e75d1cbed0b7f3deb3488c4283fdcc5e638d5a13d96d3fc0f45a61060da189be7469d05534db62a9859132f5fd3b37fde5f3719e389026b2856b45075f659884a51afadb7baa85a86950af4b42ada8706798ed14270c3c9ef1e236a1295cf1b689ed76eb270f720126ecd4fc4c0432d367c8c77bcbbd70bdf1e929f865fb51815fdc2931989a673124e8db163c73867ff955702002c4e0cbecc981fcf1541165314038fa95721558a817104871cf81c035b287a95c385c367d100ef5ffd465e1a85e9d3c5960a941f0e5ca69a59cec3139bb904b9b6805a48ef3ba1638addc8ed0db82aaf662769223d07553df3aa5f6a1e8b625ca50adb50693604e5100d6e0d834b9087e7147c1f89f8321352251ac3a597d1c1693f2edd9571315841b76e2f9eee514e41c215a4ae8db886afacd47fc736083aea2c1c3f57555ac71a929ce3be8dceaafa37d2e2b7ab08d1eb4fe49b979289671b8f48f3dd010334187712b25d7fe4c125c6c12a570d9d4e8b69d564b48b1d52abd87457076eba4a1c7fcf155db2a078164e4fed2f518621617f5ffe5109e385ef91923b857541527be05fe5420ba66845c2da3eb0512870a52184e016d20f9fd016a7aa379ffd59582df0621050fb44119de7a356c844e9d244f69874202353329190f7d9a8b895f91402f0a255126f63b06f1886c653617980ef709d6bcace2c8f4c62eec988066fc166e78e423d27350e9a90b881523bc65ad9bb48e44521a7fc91b039097ba011c74d09157bffe46b833e982db88009ce4efdb8c8e4810cc93f48decbdce900e2e8e70c10c131bad408e9ebb0c3f7a582bc95d6444827503b6178c6be89b276178118707826e75408f03f6e62dc6947154ccf0b363acbd9a63c6a5e1297739d10f25f871c96813c7eb4cb647b5b27dc90ef714c5e36e0ef67866aa71676c484cb841bf6f13ab498305dd33a1b10f295942c80e1cfa5d3fbc085892ebf69812dbb2f165836dbf820f2c9ab78745cbd8174210b7e05455f8b71600004ff405bf5d5ddda556951e628ae3631a6b1c2e126e3be9603cb0c6b00dce62db85f813f161ca89424435fab197cbf42e783aa4ec5ed696100273205e02dd45f3ba8252eed6b71a769b64048663626e62eb8bd21becc4dabeaadd37610cd1c322bb60d563f481aa8df377f3324f9d953434202af10f0ec143cb293991a4294d3b6ef7fcf306e5f22212e9bbf3f3fbbd7a2e300ff34e416ce08cb2fc4cdacb23cf3a10fe576ecb5540e9fd09ebc2000c30539823145d3da0ca8f834b847742b088ba446511d6fe4f16a51ca28cbc6d6bb3ec56ed39e0759a134d77c2db1dcc9217905f52cfc93d7d668c330b5ca3bb086a50af8e922e33facff3c1ebba1b7f16941c903ffa92347762e7034289330f30481d82ee9c7a186bb5a1a9629bbf8e005492d8d72cbc5533e0f51de7897289fb9694d5656ae748609d4ff20b3fb1e3693e975db4efbdcbd063f77087f7b3467d7fc05c919548c7e0c0fcc8dd7259b5ccbdb1262a168c74a1b943ffe6f0910835c252f7ed05edf400b4db3f723f753c3ae33ad9860cbac9d4e285c365c8bc26d219db262b9b4c9047f88142a5b1dd49b064c2028efb1ae2dfff2459eb05d580e5bf18a47be134429961f739f78948f258fa5b250c7a9df824b74f326ed268938624f85cc11b8648ddf6f2bf9083a2c1db7ec4d3a71a019f0242568b8fdf64be6f1780f5d9c96b97ce65a76517e79cccc588f2d1a8691772e233b1e5c5b83e06ab42527a880887e2588f50fd085a3c75242f437879865c75d54996d0ce18071b42f1b18f4fe2502e95001f19cc2613c1096b2c0f7485950cf6c20dc03e106ba8f3fc91a72c3dc82dc133e0b0f59da1a9d551f8f2b5c78193c076dd8455f3c9b7436f392190fd3ecc78cb37c4468098b7b6e964658fa8b5ec92bce0b76ffe9ba53dd4fc2ccaa8bacc7b8cee5d09f8e8d99bcb7ea5bd83cb910061000e6475f1488065fb3d88e021fe647737f37841ed5ec1a55eba17164055ad47cc994f000f5f5fd64d2c4d1aad376523b5cbc131cd0d7c93da737c4fd7eb0c213b72c7246868296e53604d92f1ab30a657a1e17c41d8ce5c4ee070509ee5f254e729e3b383eea4f12c3344c7d45fb988c5615a741757b424b9143c9c3f1faf90bc801a61581e809940df21ac7c9d07b0ac3e6708a3a0dda7b973f69ce5eb71e1837b1f999404603ef8fab577db9640a568cf12f09d8bb7c8a3acaf99e2aea03f34d97540a805aa8c72196bc3b7c2a9958112ff4678ea61c2783b0f087742dae7e09aa1e96b0201fa5044cba0a76b75b14c3317ae24b141d7ef9bb42fdbad2a89857c5447b329db533a352341d75dbb251d8ccb48226f44bd486fa71ca1b46af580a4f108a709185b1b81a84178ccf2a5096b146d93f0065e6f05ce79841bf41826ae4562b4ee71ca37345bbdde9e8709530e60a1cdc5c88590922b441f143c67e41c2fb07ae127da8c15219064865e13725b3cde4f72dfd500390506de777dde18479c67449794da644c71cb59b006a38220412700e20b4324af0963384be1b7dadb7442a3441d8ce176522b8847343197a90e1c79df1a28a5e6a731dc3dd60f9ab5d9ba2d6363afbdf33edbe4d0a1b95aa8c14be7cecc6784f2f01b406270a5bc3fe016bc2029730a33ab51c0ce0aad0a70636adb9b2815821a3d48f867ec68d2686eca82a084db27b845b185ececff8c3c0d7a97b5b8068bf6199ce90e58d15764290a05749146acba949ec2a09841941ff95919b9c88d85c1ec6d80ab338e22fd189695ec0a6bb2521870ee06ff21555049226ac3b5e580bc4241104c76b4d8fdc04db2a3986d8c88cf3c31b12d96d6b7b1d11e54ed4f97660799d8ddbbca591737bc5769a42c6b4d9b0fa43a2c3abea9acbaa8840b842c6becbecc51687f6b28b2e0f417450615b9dc1c160b4809e759ea4daefc20cf555694295c5798ebdf68186a8bc56a07a1d816ce68e9a66317e20736cc83e3e31b93082c0a568ac6e034da790ee15f6c85bef8251615d1f6b71150b6880e0368be9706291acb43c84534a89e3575293401c6477a51b462e6b687e4d13a42a0b0de4e033361b68592651a025a0e1b3f02170efa5436cf1f27ed146e97cd7b1370cdb71ed56c844ec512680ab109d18cdcc21891e4a5c5dcb7a2ddbc2892fbc60f71834739449b104c902ffb7dfc2fcd4d8be442775dc033697d091012bc26d446b76abc16e7a2b793f9bc9c2e1ce5cf186b161d2d687dc019949ce93d7069645bbaa4eeb44f1ec865289c2370561ecd36b4615d2f3575e38feeb5dd5beb2de0cbaf41f23bec55a8d9f35713dea663ffe13b711d383eb481c97d1221d1b7d2f52152cd4d3a3a2785d8ac2e76b8389bbb5a5ac270afad983826934e0faf0873557dece674542affdde090d59b774e0326f5a40941a383e8e73ce90c70c52185ee7995199dc8b474c3c7993ca55c96d4b17e9d64aab2402541982ce0c4807866e72ea3d72108e6a0b94ff21f1056c8fa52ac0c941d5b34503a1d26f6d7d6fef3bdeef59446947cd1cd81588c9eaf7250c33c1c130e35943b57aa4e613a39b8039c2c9025aaee71867e5bdf2839673ec6f88a607e0bbeeca0514ce2ba5c0b5c4dd5965d0867d9689753f04873ebc349a9ff7e35a200702d67110bd7be4be9b841084b24cc2de1c11b38b47cc2049768746c1efd8e46336f4b6557f7bf11e1baf3c18140113160bb4a69e7f104df1ec06e1032107bae71b0742f6d5053fcc46c84a9b4782534e9675df23f3768d81c597b5e54e2a7f024fb8bcf0f0fb715afbec1816f87b14ae9a765c11b21df0e823cd952f7ee886166cb8eabf661d89257da44cc3d8958a71e2fbd8ab8ce8b1b188f9ce23959ed740811da6169289be93cd9967b18f20c3333be79051c38e7f72596535a4fdc3a26e00490098fcd8fa9ca5379b65579d8e1789f9253a736cdd4c03cad3492f8fe0041600d41dd745464355bdff0d18c7b7d1aad85cae7f451e3b7b6e69485bb065e4a1875da7eceaa2c8713bc2c64139dd9e97583eb519c3ad2afb5a181781842d9df35a8e2641ac24f088be09a48c0821584a359641e1f046b4f5fbc4035cd246454343adeee370cafdc2ae41b15211c67d1085f7151fdebc41522a19f25fe5df1cbd26060a5bdf84489f07e94b351a3b85bfedbee5b13adedee5281ada84d21120c0d6a6a427030d3a6259124ded0b25a68af650322cfd85b5f3f42bed4950ca1803c7fc7a34e55391edecfe2154e154cc8cab494d17948dcc271cf3fccdc1c0e81986f03bc60f4e6301798d248f62cfed42bdf17d965a4452d6e35d1bdd9aa4939cdbc6a3b1015cd0c1adfb97a81d030802af4bfcb39a81077b375b812cb3d0dc2cdd6b0ece1bfbc51befa68b6ed742bfdb2421f32f3ac788c86562a570973d0f7156d81a181db65412805d5dd028ecddabd1b03433e8e48795388e04e1991bc5a8452f093fdc2f070f1c49304084bf7dd27d1172a8146ddeaf8136dafb4b8a7f66c6bcaa1b884e5cf5a4986bb54266122636427eb2f2f04c6c97812f109a844b086c8adfb5b39271115a93b8a4d9cc2018cfe32e61de15aba748641e17e03474e43c0e860f3fc5292d09119d18a542964758a0841ce9f22111a73d2d6506265a1386a5ce9b7fb0e286d42a282795b5fa131ef5050992ea886e66fca994479f7fd0e57755910980cde3aaf1081e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
