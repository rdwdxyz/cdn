<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e11f63e67ea9ebd884cbbeeb6b8688e378405953713fa9e8d83751ce711e09d75f5a74368b70053edec9cc3088034d6f7333fc8b70346b5ecfa1d9fe1de8290dd59f7fcfb422d7e7b24842eb97b1c430c2971f56958f96155859a2499aa528b469085838209bdf0641af7a4d0f455a22689972cb7ef21f881c1429d8c0b52537157e9b376a6b4ddf07de163f23fc59f990cf85c64f8963bb969bb5daf3ccf1d85fd78e173b629c1b480eaf8fcdd105fbd5bd63954ab2b765525ae0903d4fb3612208b0f1e01f3139f27796e77cfda726d1ba92af1a85d69ea077ea46d6e87047757a9b791be868e11c65fd35d5ee1a8a61e4b74d7153f730cb1293f4235844ae9b34b772bb34ae803d8300df37668e41e238df0c135d0f194c183cac6c1477e80b0ae5ff5b76340e1a983db7a7c6e27114429f600ce00c4fea7168e811e72509209f8fd5d21edb45c50e0793398c9d1cf507719237fabd9c3c2ef3cc72826cb946b594caec912ce4e700ed08da1dc09e59399c26ea8d40dc53d7b8d7c1e44f0450b08381865b45b60af543ebc46525ad0588483cbe1da73d41199d83da2d0165ec80b388bf964c1fb12dcf5b6c97aa2ad1337ad40df6d39515fe2057e6b2a11a0102b869af577f7e98d2075a12435c4e54bd175977a45b9ddb10cb2a6d6ff9ec0387f791dfe1257a18efdb1aaa9a62e63d6a4633d2eacb7d8aac13f5257cb0ebf780954483a24a446df5157a2bef97d64707003945fcbf2668140e5822998bbe93089b48f8f02fd434d6ae35dbed25edc9c17817ffb9831f3fe04e9cecb1ed7be5e848ebfc96530d1d5f74fc0de7d2f9134149871b11049cf8c6ef2894e6022df0ec9b687b9a0e8e70a9fd6c62bc86c4667dc2ae4d8f63d7bca9a806ea301558ba9111c266e1fdbe0c0293416d56238b8263caaf18a00dbafd4b91ec43cd68947d9a966b827061794c39aa4b62d454006be103a3c9cbd946a74300594fe79fb64882f4aa3de0e2f673fa94c2e74639229f5b94234b7d94eba6e9cdfb76030e425e8729a1e6ddd598cb96c6176953e2b3b3c27013acb7e395dcbb1cd4095f1e1005b9bcce8e1358d5045ab08c8dcce90704df6f4fb9a36c73f5892b784cea4745aab5a6c63eea11d5a212531f24b03eebf2dc8aa8d19d9e03707732b9395879e6e9fdf3f34eba0cc09299f805fcaa6bb2c13e0f121e7736012f7d7ed2e3b781299338f6574b1f486206aafdf554908c2107ac7adcd7c9c4dc0ce9eeba43be227d6baf92b6f6b1d7e5931ce856a1059e6ebb1695c86f7bcffd0b709489a882d7c37d569239b6b538e046b1580775f47f84726af6ccb8fe7bc3dca2f4847aff86592293327b510f478991f700a818579eb825a2fb6fb60fffcdfab50ed817099e3ca31bf3de473a21a10d9f95e54359a19297a6f01e84a964216715161e6142b362d3c7693223cff36f82724e3f89f4c1c43a14f0d65d9ec1ab30dd02db2cbb82b58a2a1d526dd1e2020adb660fa1bd2ac9fb199915fdd4d6540b80a15a631d1f79a9ac6910fa1e9f49160998b835d6f4852a7d12b2628c19876949fb03ce3b8bee715f4d10e557fec8762c471b7c58c987391aa85b93c4f4d897c07a50c7e650fc9f7ef1be1140d52b0f836ae3ce697ced04532256b616ff364495e69aadebdc005a020392de89e2363c91363d84f0197a26de36fb6c498e9360c9e25d9c466739b48f3638e9a3dc9bf62e50c8a6aae8354d5df4e0def19139bcb4c12fdf111480e2d42a6e707ac51f60f24e00e85c672b763cc229b5e7ff5986d46742f72b53bc6e029db44bdacba1260017af80d28ec5e3a5372fa584642bbf1e3d9ea690606fc0ec2eb22414c50251fd9a6a3ebadb2163ab3d7b45ede37735caaaf5c023d2ddc36171e7dec4bbab8fc05b6c571852e46c27b30906bcd67bd78d4d85d1ad82e4b56ccc5dac3e835bfc34924c5efcfacddafa5e3f3dc13c900a4a933ab26e35d6fb67087469767f7956eaa4ffd874612744970f2e745a0c7dc0361f7ea29eef739fd1ff7dd3ec17d544369a9ac315929848b2a582b73e4b24cc0f201342eb76c602c127eb4fcea1d83a1c3d64ee5a62954a3881cc004b64c04708b63f3d94d3aa9c6f3fbc9558719df6c0d9a4443480ca44daffcbaba82dcda2b3b703c0b619913cab25bc4782e7c2e2865aff43cab667b34508a80a7527585104826138314a09885301099c201a40eda7719c2abdcf81534142b05fdbcb9cdf3ff531fc185f6291e1c3d525b092675dfe6a12e8b00d1b08ebed47c9948fd2125357ceaf0cb829cfdb244e71d21ed17cf9bb7ad84f4d27a5c3529a82ee298d77b50329f693d5e3f40c24c21244581530efc22d33011e4689a1040c7da83bc1a6ea990b1aa5cb0ed9027836aa365d3476080fc8c6cc1540ea405551b7d5347a17e265f92d676f0bd39c0bc4a374ff86c4152c18a063d527cec1f5f00fe42985adc6e22442142ac9b85840f27c8c478e5896f5e7d5bb6c4336e086082aede61d0797ee0fc928d154649acf06e28cd38ccbc7094e64c8c939f39e3b8f4a685dadda374ef9a4abe4bd45ee5ef75b933d1c5eee98996d0d7c5744173b13eb244077ea105c29b3a0dc1a97e3ee05376314bd8174a2ff9b02533f29f474efc98e1d7dddc1dd7e9b9d0805865285161032cb430e6e4f3b980e9b9a3c93f2dfbe4a5f9183cf67c563c910f1812fa062c3bac75df5d8711d476e9825e7058f0a78316f4822d803522540241f8c7cc2cd16d287509e175cc380aaf790178d2eaed90d07349af9ee5744ba9f616d724c42268a438d4fe3084f3dad8b52fd558e218eb92387a0cda66978cf912154ad2987e702dcf23851c82cbbcaab998152efb2d528fb636170d4dcf33f47124f96b0e8e2e9106d9de94b2588de456e20daccb3cb50054dae680655a45eda6cf5768843ebbb445b4d8f298f7a4f20b2a1efcd757752c0434863ab42bdb9e2ed140cb3f9977036f688b4b97a6ba6f87ba5ac65ad6f6c750094aa630545fd6ebe16c94376f725d2a8fb8064e8940f8fcc3cf3842b746ae00152004102bd23bccdfaca8fdc9455659035e4aa8b5221a21abef145fa06e7f54bf8d707853493da1100c613a12e478fce68ba7e1daff37f6e63f034ebf4b1fc8b7a0cf0cc4ed5ec3d436586fe0821acc0f1db79c696947d13021c03231861ffb1845101deb765bd18915c91366be9fa630b8f955310dd23fece55cca906c7126295ccb91a6a74e0777ca2284a1109add9879deb89272588f36aa5da2fe6a84c7403a682d37803480cf641ed7eedff1db170beea19907412cd964f9ee3080517f90558e8c472a88ddd6d8ddaeefe89b269825c81b56fe2a53b15e64bb64efc1125672507863d5d23b2adbb7c32c01a7f60d4b7dc8d9c422cd2040e839db403aa0c85ed05ef69c84260e78bfe6fbaa01cd47881c755e6554b33a8b5ae97af3da584092c47d4eff12bab08b816e55c37aea07eede9f1d6813bd3b928f920bd43a5f1d395bcf9f91f3e16d69ee698393c1e73621a79f678e584f3fdb56a7007897ccebb98f746baf38799dabcd61713c75727a620cc491d53684f301c73592ecbe23cbd520a51f86d7befef69c673cef28120ca90a0a8f38e013ae9167db6e4aac41df84eb01e59649af0b77e77b04f555a518780c2c1a74d30a591298ea1943ef6d562670f16a45b95e1547dec85547be509531a1c4dba794dbb80c7aa4817a434317b460030ddfaaf148c06ee643fd0ad5f2a2331235f03942e9ba766dc41631374f6c3d327ef8b1dccf42d226c883e5a91b85283fe4f3121b418fae95bd796200c83192d3723c2c6078ad3ada28da634f979ca94daf15ef6545d2f66aaa8f8116ca2175444058cfc559ea2068263db4cdbed587ebb928eb56c450ef7c87d276fa290220dde3fb90b7e339f611d1e95b75559d4ce84899efb19c54e9d3330fbc4705cb245684b54b6cd5a853cc022187c28cec42e7f6fe200ce565891087be13849c6a90f7837074af4ca9cfd413d8097b8c9f5f23f44be6abfd3d66a8e58ebfed2f2368e6e02028e980c1be2547b0bb84e45fb678b3dbec59182a699960332fcda45afdf2f04875422c6e6fe90e1964b65b82fd85a9ee9fcdfd134dd36a440e69e109675be6f151deda15ed3e5005c0d07a14dfa975fb1b0d1f3e036a2f599b66116309711380b33c5d9319a06fd4c5fecd41b1b5740f8c790930268034dbbadbc524323214350fa51142b7276c495af2f3f307fdcb6addfca3db6272ca8020679fc231c12863d889318b1d7a19629e5effb92b19171978ae2801d8a3f1b240bda68df37569a478b2ff243dba3c429bb3273d757a725de6321a20969d402b0ff8b9cee812d2b55008c2202d51a9f85d56a85fdbe4857bd97a181d5c75e07bc3d8cc2db66f92990549ddd4602a47071aaafc0c443b65fee981f9ed07b5382bfae15b675772532d943e9a889398f48c1ceebd53e7130290efc32d6bf351b490283d47e8f488fdbc183b1d72c7c48f8b5886938fc761700c6e80b233d86f6e760b782f5e82f9f71c749cdb878508e304e9f1cef08478af7ec9ccc952c6fff494d3b4a647dacdcdd028ee8ac99200adea47f4aa4f94639cffd2af97d99cc62e068da670f06ba5a56696b2b9b81f605b226df3b9d7a7ba280300550675dc92c8c6502e18dbba4dbc8973404ee918b4ea46f5241ca79ee426098f9168d68f06a442e66ae728af640fbb0776f1a5d0bd4086b8997d25c85e2a48fb6f9fdca36d607b0466e16b98132c4a33bca03dcf090b81c6c63b26b52ccb2d6eff251ae92f7e257772a459be5b1c38b7eab562ee795118b149d12c9403918ad7765e6fc466883a5ed8e7b9ffe6864a7944b9b22394cc9d47834b5ce4ca626f6decd87a63da0338d11789976ebae8ce4358be93dfbe348ed2eef178f12f810b900b901a2d84da6492c6e1155da13aae13b61408305e9871eda0c07a40b7d8d183bd9c6aa2febe48fc9ebb27056ba16a983817935194e33d4320299bcb9e43931a0a138b0ec770d0b2c2d1493c3685fb9d3d71143909d82ff3c425b51a2ffb6d01faf663aa9e5a1d4a1622234fb208fd708228572dc930cb5225ad98686f67f3bff57898d836792dcc034ac3415ede1e2a2a3939bb407fe973eaae30b464d49823209e7013a8d66af68c323045f4cb365cb192a32ede0dc8ad6036d8fad064e10d25915f964833ba17b679d9969727dbe8a43c6dd754e431c0cfba835bf5968b201f6370c4a128279027991d79c61393ff5d41569448f53f956cafa97a33da727684d0145f387641feaff32fda8dcef4b4b9595a304b90944d48fa3cd3e703df668c91d35bb5656e8df28397f0000c89045cf2ce0dabb6cbb4f41f9afc5bb208411c0c0f4ff6d274d8baf9652bb1362e316d1eb251ede6f06f95e1656ed54c7f2e9fdfd471abcddfbef4eb240a2078f71b3ef9c48cbe376c741e4e5f2ae21fd5d283f8ddf7bbfe40b16d3257e3ae3f2223d6c5b592e554276868c0701f3eddd5392f8a93dddb9d09f006b196cc7729d7563d372a468670e771ef333e43df5f472a71d576576fbe99297ca2184be44591e98da77d646918108846b8003856e346b28149ec699d9562486f317e062b7e4fb72b1d82eb38a9f84abf0c594be547e5e9373f08c81667037b375ffa4a07233f7d3eb6876c8caf3e2e435ed84725753d498bc14748495046c179e99bfd96ac8cd876d47dab88347c66d17e78ecde96beb87b4a403c68cc9652216ceeab74c137e1d1f26f0e6b46bed249df89f0931f70643af8951c448538a4bd1e5eb2cd45aa08419ce8956e1059519c0fed30c8166dff7f9ace464766c8d230b00a7756a120ed2f864b0229d49934008a5b6f3f2b3433c55218bda72822c723be92fe42aa96bd0d7ae9287ccfdaa1c1493eddd7cfb1838fa72c85f12727ebff1b475766a6ccbf92b6cd352270f456f73a3393d0e38e957951aa5f4f15fc3c5a313447adcb98d11cf3758de46c2d2306c649318344d11b4de40c0f17cc4353c96a96d1f0e9461ee4c9070795f2ef40782bfe2086d3acae4249954962b40d691ff942c3a33a054a31765ca4d2bfee72464d090ef46dd4c5f7f8b45079ef26c7450c8c33e4bf96c94b51a3a9224801705c90bf44486b997f4b18a1cc00440099675465eeefb2632d364aa3be2d49daeb56fd0208ab7bfbbdc3e6efbe522c18ab8106bcfff38f14fbade5ae2cb5840e03da13ac7c7b4642cc436741aca53a16242eefb8b72ddc27f5f076436fb056130e8edd566057a536ef727c5530ab9e3a76d34d2f7c5b1bbe1c2e9d871bfc840f23b1f7d909d87db749cbbfd7a2c115c592c611b7571fc4728e7f5dcae22ef7a8f216d52ec276ba5a26ee8d9a4175d73d81c95d72d0a9452f6ea98b6532097db4182164c5fed4eb7a2c7e971c470552365fc013d5346874680faa8537a01058afa556d446064484d1b14e4c85b639b46e8e477e1c5cec2a61446a774714e29458d3bad3a57093090bd4a2edeea28f3772a51b941876793b680528a682afe06ce8dd2f0a96954929d5b7b1c39dc830d4c0379a47c5687aab02d9eb8a0fde80b88411cbd298c4df8852aab6b9ddf072d69081c679190dad9eecc8b5f6fb993de664cca7bf150d092e8e1e5bf7a8bf8e0b13a5cf9bcf46818558035487b3f8a4c4b09a9f83ab5f0e22caf26433c1db6cbd322dbcbcb357e44e438426a75b9d82505484944c52135a1824804cb84a12e81aecd9e899446f4c46ab41e2a57f44da791670abbc004305fd79d6208c65402f9512de7cf1b7e44356a9f61a08debfcb90a1b1512d7dda7972f13f540b542c6f42869ad2c525a426c5e4b2f25f0cc1f8ab3c3444703c8903f5b77e68c835a9c5a5c8db590ffa5a3e86d24aec34277260928baad3ca723be6f3e1ef2a5a756e81b8e4bf91ddbc9a4bc7e4d2b36d29653f8f731bec2345017969ff60eff14381df75a095fdeb23d5cacbb2020ca1adcb6674e46a35517505bccfe23b60bcaac92b3d4f228904147ed4555f4ff0cb27f72e522bbb9363e9d765feffc32cbf9874c4084212a996d4e9041c34d16ac60cd0cbdb2129b5f93e134934efb43a866d0dd702df59ab1394c4bb877d4e16adff58ee2c4cb6cf6d9679d7fd0f217ac460c3d38a497dae395c83baa40b0e5e524c10e4446cc4841bdd60173fa6a0e71fce4d760482a834fecbb435a4bdb211da458d36a2523a8a1cba377df5e6f20e1c3f870c7ec3a0359c3b22e5cc5c161767539644d73ebd327c023b3aa75eca6520bc3290bd8506252c721eea2301a61b3ec672f0cbdb15756d6f75bd26b1d3135b3167536ef72edacb1798918d3fb6e70e07b6563c8184e8cd2b29a540e5d45a848c9bb5aff30b61b7a38c246ef5dc4b21c5e91b6af18fddd126651a9736b7874f77198e5299f0b1209e8cfa07ba4f3e8ac7ca23eb97b8bb65ce9ea2be9d1d64fc7c04eb8c23b025db9d507b5e96abfaba69d536428f4c46b3fddaebc4cc4c01e83edb34a8900ba9004a768c2fb643122a5395902fcc59ae429649c0614be275637a7fb0a5fc9d7dbbcd6c0996550ecd0930857a13da1ae2bc33f4ece5dfb9bf0c506635c807342253546b7291ec72d77e98cd065221161d9ab44b18bdea7082b189f90e3a0e9654c0aab61b2d2296098fa40840cac553a3f97f9ba46690e065a8e0b3c7fc29e3dba292a70bf682e4855b2cf9718d67ce2406f140c76edcd5af352ff5b08868fc6c1a46ca6f3a9f94d77c3f95591483929d6e1566701f0cdc08c72aa0b6f96cd8cf2f0d0da5df017cbddcbf09e960f775488965842e125375c5b084ec2220b859bac9642c12537b47bbbc65a8651701f5508dfb630315b012333ecd8b61b1207bbaae98e89e094db89e6713c8fa25c6dcb6baa33eac1b803685bf17370c28664325e4925fa89ccca273007926a3404783e0534028eaa33bf183d68303a325677f432b3e708f02283fe2b87c908f0bfd86873ed3d10f9ee93dc50ccdb9c5a6d125df25784c96ef82a4ba6f5f6048797077c05337c42e9beb53d6c1d240957040a9033be31a1eeacd35fdadb81ea9cde4cb3f2927f94598280c35dbde8ae49396be8fb1b98afe44289f5e9f36507281cf4e13f3748fd229df5f0b40b6e77be60751b0fe0d31b35d17a6786790daf15212c85529c6343c160c1ea66753356997228493b8431112938de0bdedb4dfb424c12ebfe0709aeeef8f785906ee0891f4391564a4a15486ecbb39c2564969e35c754a492fe25e46db3ddd53edd597aff9321119737fce2d23a148ab2054f6939a50b733a5c3af075e9d14c6bcc04e06d6d4c3bffdc8f55fa4edd496969dd4092121ffc75190cd1cd5da09d5fa3c1e1ffa70a638ce79d22f2be3dfb9a45c66a1ca8d79dfd3d3b941bdc0c38bd34e286a3f1d6c0d3611f90d0054eeb8880b14661200cff6c7fba5597340ff82aba8ed8c6d8c6a4fcd5d5a5a38a63c1cb8c862a9a581c6ef9f0d520665cfcdba077cdbc731a3e14a2e6577d30ac9671cfb47153b8fa703194d255a139b973e0b369f1945b3edcdbe466c9eb01a2726609e7ba8b9e9b378f8ba9014bb528c19090a556158860674ac4ca52e93f9c768d92d8f0260f13028b484b2f3dc1d44acaed2eb86e7ab6b7142e76ef9001c9bfe4883afbb03e3282f902d3165a4c19370b6c63f838a83ffc869e98a0dcd266627a0722c098a26c50de635005643eeade586d93af8c0d655dd6686e38b699767a44cfcbea7792f2e6b8c073c3537709f90ec63a81da12d2adc91935efb5673b05f6d75de9df5bd93578a58fa21d5b462b6001ee732286aac5b938454a5dc2c0cb75d544f909635a3b25e7a0ccb7c97bfee31199c5adfa4371231790f70a7fb6cb3a27e5e08895879e5e3c0e7b5811254d9289f56e05e67bc63d4c88554e31a1a88aef9ff4afb8676c3f66bbf0c9509cf87852f5d64accbd56f206966ba639b32c6610c4a875ee180bd876fe82bb51a50687e91726cc37ebd767ad2df3e71f49c0d69c72a4bf5c3adf1eba23bc8c59ec5d52a1aa2cc74a791bb321b73ea08aaf40f506eea4bea857dcce7cee3e4bd566ab8420f06c7a6937443fe1b35f5292e6db3a4130cdfded5ea6cce5b1bf36c073105c9d895e150463a57183992c0471ce7f9985ce48411ed0f6952f7bb8c4962d6811f70009f713a56216ec1ba57ec42dcda6907a0e5dd09da9222d32ff20a1cd35446f7dc257d8eead5c05c5dcab4b8288ea93355ac4892c6f89e8faf55a5f5f5b1f48fedd083d0617b3e7ce7216537664a25cd2ed3af5e8761ff65661ba132c46a2ddc99721fc2f26332070c8f53eaf365530b5a5cd6279268ff554d468547a8f799ccbaa0e45930b35c1d9fafcaca78bce921f21098b90dca65785faa0e4baa35dab200219f3c46cc07410c8acbb15f15ae439d179bb5801ac7ba6e65a916626022b5b58429154dd1b07a2e300c5cc52fc69f0cae75058d2063ff46a2085072fdd1a8b581160ab2339e3001c58758dbab7d31038c2cd737ab8d42f6ca9943b990199696a16898cc56d982165aded99b161d523c9ddc7a252c8cccae6dce784b8eaba228352dbe12f40f8b1b538e5c0f2d2e822eb69477b7704fd5f4649d5e3d27e21713c51f755cdf492af51a9cf6f8b905cfc0961f53bc3cf85a1e85d9cd583816c8b80e38a4c26c88c7dd7a3759dd8fc04080ec8ee14d6fa67b1c914e0251b7655c1cc7d3ca5109ee0e431a581eab3f34d4766d96b823b2a6bb4a47720426bb71230127b2c9b74ca30060b915572478e20b13abc0f19bab35ebc39ab8856ca68746bc61ebed0fcc9db92da428357f3b53e80aa6fe8b645ef27bf24fc18b045c98e5544e0840b5ebb4f1238e3eed68951e33c27c2b3bc4142e980b05d0f3a2ecfe1240f0f43ea426f597da21fd2cf16fd52f0bcbf8f44fea89ea3ad82a671ae7519f0c6dd09006707c55a80098091f93d247af4e790edd9923e21aa4ed1eea820e7525a1011125ac834d8e86adc43d6af310cffe6fcb6823d7f1830a824395974970be23945f9a470c844aa1a69123b7947945ad33daeec8a4ad842634a446f4ecdf736f7a868cb2ef06824c02c2e403378efee796d0519347c6a86faa6cba48634334c7b38c19505d2309e501060323d46ba911296c6286b5bead29942d7fb4c7df55a92f67c94e19df7bdf51dafc98b211616d7aee49ba2153a3c36ef44952093cef809ff790663670b7571f6d86c3622de751e9d589761e41b1b864fb73eb5bd3803fc82c13d21206ba57c6175520839de9a1257277754156f2162757d1c697021f35a4a2f6724fcdbba17b1478b78ba18c627ec00286e7cca827b7ce11977f06fdf9de27797cbd82e9b016fc4abed2715e9b26a1e556349129a68a01831ee731a3efa9922a999b7ed369bd0af9d3ec3014a99156cfe22c450b517d4c81665da09c82f716376bbec3b59f5e18e975cf7486852b44c3ae428d44afb164ee721e01e6410fd8879bd5fc96792ca2b09973e956fdc4de3f764e05843261153e389aa3c759a53ecd2d977765db3c8acbdfc6a2c18c96db622394dfc6f6bd83e17252e25c181bc6a9effa6a63f2029f1f137c5a2bad876d90b4db916c0de3749cf936cfb1d6baa629de73b5c3cb5ea46083da3e616457ee001cd8db2873e576c38276cad20483fd634e26672c23682e6102ca13dba9f9bcbf37fb085eee93d843106da6390df3ba39c539c6a028fa2c599c03676f7e36847f70a4b1f3b79787a4026494c255b9320fe159db9bb503e949cb21af9ef364bd9f3af56e96f0e62315599363b22a1d481078308e56d5b6137d4b32ac27977625a8c2badd248964b20c2ab4e5714d6bb50eeeca299334be748ea76256815d1bfab1ccf2ee607fb8b09cca7edca79a3c21c46fb1690844d9037a391042980f9918c218d8fe793c636733c6703aaf1b5f165a896bf13bdb9dc99efe7cdb23ac79288935c7ab63fecea1ed48f518e4dbb55374aa710a93f5aee88ddfa4bcf7a9b0cc7d9fd9cb48f6fca8f1eea789dc162d998c1e3bb7bd10840d4eb17324c748e509e62d53099d1b348d924d2a82ed860a9be256af1d6b4c2d726312831fdfe9475b2312949dbf9c2d83d0cde60623cea032bcb5454937947dce6fe26198226df03c597a145531caad6e81d04a15fb606edbdd66e27757ac5ba9252584a65731894dc1324c4a51539dde76c11cf5c350f1c436eaa616475045e5c2842b82184bfc0808c6048b715d367520b079a29792e91dac6c6207745ef2dead9ffd69b31be808c78bc5e216ff3c3582cf78e24782ecda54519d69ecf7668a56343cfaab7a2f9dd4f7eb14297ee5711b504294ee65f88b7e430de84875fdf381d1901dd21ca3faba7cfd5434e0eeac8d9151b7c20f4124df6f7d9b2d538e2640b4ba15b157af801ad608e73e65f44ca8b16ed26b9d1221ed6ee3e7c4098b15c97baabdea0f1bdaad1a3febca9cc5f3e017241e42376da3827567ae4d0c6981557c4c2680a68a145ab1166989b548c67856c34d8536e44ddacdb3962b4a9b5c0a5baa22a65c8e7b7113dac1faeb90c273bb4cd0c8e7f254dde0b6fb4b3fa54e4796deed307b3c25e18c1d7fc0dbc774f0cd1e6b03f88a784fe9d31719ea937faee5840b202e8f94b0ae34003e7d7d94961df84aa026bcdd735e64c393772783ff5d4690245effe5ed8413c1a4551b36ddce5708e6a7351c393c96de21ebd8f19fb308bc3d9689850c0a5378ae37319231f25308bec35e62b60b7de9b273a8ee5381dc94ebf5cad1eac96006848ff5a46a5f6f669899b3620a860e92b6e74fdc997f441b94f51ce9fc6d51fdaba21eaca605e56767433d934b5e590b33cc87690dcf10d2a83e485e9902eecbe1fe03063c223bb04168f610dcf7e824b07cd5cafa8533a0ddd8843cd72679f37d855e18918330e582164d1f23dcb556052ad14db44b5a99a4cae73c5ad1da84d74f0243890321cc545451fed724e5c3c648825b609be0444efb1e3b638ced056ddfcc00dac0f6eb9dc627cbab0fb7435d290510eb3061d43d1f6c82626100c4b7f3cc17bf5db32de757880d33566c346c27ac2f812224bf0feb33e8ac72fd4adefc4395e088ab6c7c7a3480e4d0a9e43afa2181d4e65dbd47bead875cbf69fc251bbda8f9c86112f76ed99590f62ff0fe8043a10a8897980fea4c5a27d915f1b8450a519c0db156a6f92cd43b5ad4ee1b34334a859bd6e8bc55881cfc0d451f68276f73de8ce39b8e6643d10cdb7458773f854be4798c98cbd4769ca379683ce31ab843ff123995f4d419f4fc3586c6504634a484e4f8bc73e9539a1ea65226ea3932b70daa6e41f6abe332297e7ac4b6ef559c7902a1e3bd0d94362384af638ffbadd81488fc9e01ce2dc06a467bc9acdfce7020900df09e5eb42461e653b297a271cb4b55fb254e723961083a736b3600eed5b34cde83ba9f3ccf14178631b269742e526f1dbf6046372979effb6639950ae5f4356db025f147b3a057c34620217086e39baa9acb433d5bb37ead1ad59d219e4ecf03fe3b4a10a05d90e31622eed607ac8477811550d379812b1a9d70f28ed4b35cfcb63f2e506b4ceaf0c8f598ed834667e5eec768095eb7b8184b60ad40ba14e2b12e00f750beba92c50e25b42a82a55a7e26f508ce28cf9d4211541ebb74225507ff0dbd135bfbb4a7be44a92358c6bc83df06232aa212baadce37a33d363a39cebf1d72eb133d32049cf5abbaf00f8821c0a4fa586f7bbb75b02906d7fda8bd6cbde5d5831e78f3e53b30433af53343395f013720825edf72441cff59c572e33cecb77529012da9c9278737fa80d55e9eea4977fb7db674f4620cb122e367e5a3f9b76ea51da0d1313508dc882e66a0a37c2db8d8e9c06d1aefadbf09df3521a96ed21f002380c727b6b636ea3cf5fe81c3ecd5b1b73864837dfca69da9382a917d0dc4c2df6b9bdba02e121b19d444b0594fbfc447a556b321204bc2029a76a66205abac63ac40b72fb3935121405da45a0a85fef6725dc4d4de005ada8d5ba2119b6aa38d67972668ad41fb03cfbd1ebfcb9702f61634e3d43c431ba482687ecf20c77c302cc3b1d70cfbcf6c8c526deb1d8ac1fa0941227f89b860644230b56c34944c1407c9c139b5c913cf15c6a38478a49e2f9d668af2bf2dc9128d8850040a5ba13d0c0834a5c9ac876085136786fcb6b42996fcf94029aa02708d7c274a61084cf90f6711f65cc8e40f9d71aaf0dae612065f02deb60ce915a8d22a97d503f1bc7feab2b86640ef426d0803d074e9fdb29d316579cf6df93cdc90f1227ce7dcc5798fdac04b235e5e1d8c0407191cb1bec0dea2152be4db1568dd440e1692d2b25e373d4662e5c1de60844a29658d1a9fb0f97029e07080735d2ced2035cf93371be0c4134f2c2e13a8c34ae9bf6a07f16e65404ac787b4de8214b756095862fdcd04c335dc65255e56204ae9a18d673d0f64b14c4e0b08ed624cc60194aba2e184db76a37dcede00d07155292f08ccfdbec31d7fe7a3ffa1c21ae9f12f12534d61c575f29d055494df6b0b32d9d88929f496a62aea7f48bef0a184782e1cbabbc7962685c07594cc43a85ba79a6f569c0b7f1d20fb06f435d4c1b4b838a9ed1647b4db4acb4bbef513d5d124ae1fc34355f07fee15a60f5d21ab0c4842cc6117fd0110fd9604e05ae006c531a7f2282bc1f121289dab2ae3ec63f8c8bf1240982c61c20fb8ca4ab1c4114c7068760bc7d999405111d5ace3ba3c48c9871fb4d269b2cdb2d5ef5102a037f2e49fe87f8f9f5ce96b6349e89bb219a01625a30b0ed4066bfb5d9d0ad04ccb8c59c5abab5ce98af234dafb60d9d56aee5609fa3c2f5c776869e0933d3d3b980b8c5521dc3522b49551d14c26305eecc3f9174123ee916ec2339f934fa7b05ce02a9379b1cba310fdcabf7c7f6c35d5e140a2f771aae25c580d50c832b778126b7bc8cbff2fe604fa4c8138b94c25870b2da1f33ea58e312de0bd9686a47c691e0f721e7e69353493f1f9bac6797dc783d627846b4e7bfc38bea29ac67f5b98c5e58d12b7b14fba8eb259ceebb63576a265a0fa9c36d44d6721581c9757a96fd581f9204a90189245f066a30ec363c3bc28abb7eccc4670528e5cff56b19ab7c5ffbd976c6f98f8327d3d831af9041098fdcdebca0061d7912f4f2620626449928db4c17bef755931045bead2f62af69c1d72ec158dacf365c3c71d72d8d4d532327bce8393c18314427e6a510835e0eee6f24f9e08490bc1ebd86a0143e0d231b5c57bd49b0e6c70e2f1e107cf552988450c74b2a2f509eac3c250883b30c17bbb7cf624208ee814611c6d2f8570692b706f1f5424fdfbc9a6faf1283f902135cb11935d18bf62cc2edf671b8a0a756fc620d3136341275427c494d5884fc897badc9303c28d9e538dec0f3e9c8aa4bf4c7539bb4eaf92011cf7d56fff74e6a85dbf9bf315d5d342b20e3935473bba3d935ec086a7fa5bd43f3bcd854bd4a8533c1e96c637363868adef5098d6b3be5a1e091c1d4beea00eb374c1c0bdc4986a68d0e74cd140bd794f3a963e3b3404aaa768951062e000b8bf713d1704da55a865be06dc07589b4e2b6945d2930d0f755365c24cb9802d4b47264e2b5de9211f196911b701bd180d2180603bf79d9c9353be15335231e40f9c429b717ddf4e888461e8384d978e73d6c603619187743b812f5a498386f5aeaad3b37ce3b5253e7b864629cd64baf87a7bf76fda7d8aba40406e1d16db79ba58acacff3d8f0d0c0ca4e80238d7540cf65d5a30fa7e548317bf97dc0372cc2af3dccfa21bb0111ee030dffc94c189538497051e8da8aeff45f02cf999d2306137189d6a0b29c96392bac328f493c8d8419d21c3e9587f047d27afb473f66f1837ce6caafb688b12174558529bc6e131ddc6943a9e8357d751d516ff3e637054060ad46a9c996d9c21ddc07be27ddc3ca3c2276ca61f57db21c905fa3d487f926cb4c1adbb321c0c507275285127e017fd27f8a8127c1b4cad0fad4bded52ccf1dc0734e097d498bd6da2cb351ddf1c85c7c4d14a40540e982a4b7fdac046f4cbc2e05088e6a29862fa79ff422c5cbfd537e532e7f9565e057787ee330a34033bb77694c507da0da0c1be67bd83860b45f91f91c9954b6b589fcf7cad26b5f4c1c0f538690c7396c537c76949242707e71bd7601e14bfb5798040e02052f4dec317dfaa67c6af691a79509ebfd989b126718ef7f4197a2141def0884d62e4efa5fac7d7ca880ef9723fa5f18959b7f8f47f6ed7247e868d4b2913ecbb03d74b2dcb2040a1f37d68d1409d3a60aa0f453fc7be03c9ed114435fb16effa87dd8b3a8965361bce14394be5626bd07c5b0a03f56f2ac20b90213b238f69d5fa9723f02494f032b046412ecee86e8dcd62cd807e6a1389a1e8a2fcbaea16391d942763db9ce9117000bc1276e173da75dbb7eaa0d851fe57b54668f1fca39597c6b4d8d7abb82fe1e69f77eaf593a49d06b40acafd58e564d5aadce0c390db0e81738baf5ecce5ee65dfff4af607c2ea94287cb3c90ef39b2be795d322c5f9b5e1f2a8fc67211b0965ec92409564c8ee0de361250c685783ed1f7c607f00b299a9a7b5e0c6d44aa595e879d31d3958ddd45610a9984dc4a3370a7a759efe0f3392fc13978474271fea7178ea868f4bcbeeb84ea613394a5139cb0768d6b4e5591b0025270a3760246c49acfb64d3724f3000eff7e11a8869b2b19bff4397570a6a523da5580a7b7be6b95ea8acf7157d8801033df4b37ac0c36c5ecc4301b0fdf61ab111383e3f42fc1b7a413b25682a46cf78d5408f1e0938071adca241337ff796a604fbbf5f29d7be2df40e815b0fc8c19b171b4b9e04acaf65c624dc527551bbe4c4658734c1f09efd28f51f733bf7468aa971624f1f1556f9451d3dd97f558f8026e0512ff47840aa8ba1ebb223a1215980baa9a5bfaec217cd775d1707f83ae2b99848303b4fdc40f9130d3a59f80c53f71ebe03ebf4cab9f35b08b2a6910aa2a8c8e89f459243c8c1d4aa745763480e92bb66b9ac9e154c82a574496256b3c7f144cd652fe8b28af76619eef68c52ca791df2ed84867d9d5618595a0710db445a68c44c48b053462ae1b7c43327b215c30c9df8f909946a0cfcc7c413591b366d9d88008cf1a85accc3f0b0f88d27ff41a3fd919feaf87442b981bd73bb4c10fc3ef75838026a0aca1f35ba7be1680a2940314e76fdb04b7db84bcc7d7e9b8f419923ce6e0595c2cb49852410f9c611ffc26db8af506f28abc145dfb296e3fbf516857b0c61ade042da49ff8dc6c6ed79c3dce84fa1934d89a06b8e4eedc50fe72a1a09f1f6449ee230c26c11447184062037d67ba862bdf148191eb7ab0978b38b8ef66a71ecee969085fa0021ac00460900399438d721c6d8bf50630761d8218c4aa977834f3ba2b6030226cdd4f28ee94ad5b3bcbde32506d23ea8877b520f33d1fd3e29afb9040e9ae6d2bca17b692505c48f4e759252a2e52ae458d5d6ae06a6e8a5821e7fad61e4eca307a68abbf3e7ea9813c69befb03d80f9f83d8a71492cea489a5443965be3b82e39beeb93fd593e546f43959a446e29050fd8d36a648525df1eafd13f6995427c4147ada333bddc0820f24afb14c0508c58e653c0cdf7f1cffacad806cc45a12713de1dbbca2432bb7132bbde36f35978d726e96a02171f01343b3646d73e515bc6ba18faa052f4a871dba6ba9c81ca851518a071bc004abdc70c415fd7fe8db4b7517a7754d8f2a7ad635f9c8118a9ef4e31375bbf86815f073e1cf15d6d53b03f814ab6451978a19de3ce86f9769fae4be7bdec01f4aad944d2c93deca885a7f9a570b4a9f646a597483dc2fc61b30f729006306b7311178fd25a827f02841de082d3b679f68d2179f1b67c4956153456bb5537fee8fc8e18783679d31e979e9e6635ce9f8b76ba5d6ae17567c0c2966ba5cdb9d5721848cbd3674326a3ac5fa9830c92899eeca92fcf57f86a9332d77bf13253132d8ddc0435e4e8b8407df14b6bf7645838bac5671db5bae32776907c5cb32db85606408c08c99f12971a251b38b0e6af761089d3ba58930de0777701cfb472f11c9cb19b6d954cf2710a05d987c79815d24cc4d209688422104d8aa08b5197d38ecf42ac5de18fdd80b0c2dc311fc81a0005b8351be55598c7a343b864c5c78e5c03eafacb51065ccae1f8bb8ccc6e69d20fa8f4585ab5c40b848286b8189072020f0b8d1376ad501eca7ffa88c41dd5f973e3ab00a6e8879627775b7933ff026d7412f3634a3ca2259de9f8d6ef783963a4e87f09a95e9cec13921cd5605cd81d2d8f322aa8f487133af18c4a27b6145d6591c6fcd3f587a24f92d161845c5f18ea34d45fb43ef2f86c9a325da5ef4e55a6700566abd3af2d066f2fb4ddf6d40288e6cf55ec0bfdb98ee99ecce9e1978c14320def16e90fb9f5058079c3dd493b93024cbedd6bd55001afc474a25245e59103883991e5ba9185eafca51a6d4940cab284e449078347af67d3a476ec9a51b45407f93f882df0865587fe6ef1b25f7c1bdb4b6826441676d083dc4e640cd6b293b13c81efd361f739801816174de0b2b50ed76b023026f26bda9036a06767d13a128275ddcaa8c27934813e277325ffb4cd9a359ad28829112a776bec2351743b8f65b6f3bdb9682d82c9bf1bc3aabb7961745a05e7ce97a48a7136b13af70af3c062ab3c28906c194fd3a271891d44e3dafe9fefb857e8b9079da0b2ddac3a2a89e3b64ace01587edbafc5f146abb5af0da19a249c9cde1215068667a2d9381c1a1791d7ff9e7214d8712ba0a0c731700ed6460bd074226e7ad1bf89ffdb10fd6d11b4877352a55b8cc03fd8ee297204230eee190267787c019c5395282ceb4911074553cad605ac7664af6ac8f3ef1d1a2caac50e2891f3f628184f23595f33d21a2a09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
