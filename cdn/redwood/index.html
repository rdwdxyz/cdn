<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5e514acad8c04c4556d7bf583a159c62ba6e2681c38f1073d8ff3c2c287191e5d12e5eddf1ef8572d593a1f2fbbf4e1ddb9353b8f458c458f3a3e2087832b62ab4dd7a8a94705bff6dea099db8ff515cb90193705c1098da859f67387edb039d9fbb608ddf96b055a47a2cc82149d38df5d7f0b9367a06afbb8805a150945cd9fc00d1f960cf114485b4c41d0c12e03364cf648bfc439ee03328fc7f7d58c0a6f1b86cecbe064c0e9c951e081877eae40397ae61250977675e245ace2a11d1d56c5d5620a5d17f51ba91930e9f0ce6e6da9042c7851d113accfd01a25444532968b04c5187bb3b000fd01486709f057850290e1b5f612480274440ea87d8818d18a77ba06967376e7c00d8cf2c5425400bbe911249964fa508999ef084dabe08cb6bcb2945a1ed164879a3e3944dbc6b2510ac3cdbceef29e51f3f628dfa29d6f7b3dfa0e5de56ac670ef940b9d88a9cd5e3797bf3228578efc10b7b5f92c720545fbcbd375ab262a0a5d4fddd1da4fc7385f8f1005581b5592eb8f8b00917ab6ce6190a2f911125a48225da0c982009260eb760b9ef5e4b8eafd818daac64d75ed07eed6907c16e23e2ad732a43c877e72960548fdaf37d6a4dd984a2d17250c3dfe123912045bcad4e15aa8a109e78bd5ab5cc53fe03683c3f6eed0508a8907f36a4f71d3dde7a25c158cd360c891c5de754066bf8a9d61ca2e515d84abacdadbb0dd28d4642e5c3d6bec556040c6aece23923e96cd4ab05559ef9df0b4868e3b4cad7043b17b9f175d430366323527c86a2ae53220c7d61cf138b39ec299628d38948c716931a1a9dff60547994e15ca136985fd6a2dbd7375eb08ccb18b863295a8377884abe0e5005c485d6f1fc42e45427db641ba4122926b3af0ed54217caf4ed0f90428650836e9c5836d3f31794b90f865fc33196c8bfe9105dac584c739eb7d39a84cb08836b11cf6deccffa7e5fbcff092da3e42c363c4cc5ddbf0151b6d5a9b2826341ed4278e2b47b60fc8e8ee07f4eb1250ee6c511cb1f4c564863bc47e5621ddcbe806b14db3e884b75a98dbbe48f313c42e01408f7f359b6a5d31b9bbc02a32c47a93f9c90a06f6cf981c1ee9a2b61d48b3ac27c406a276020df4c9f9685d714a68397c46f810d194378b72eba7c88c2a843a12166cec6b6ec3c057997743796e970107681b261f956320325d05009b6684fba79a2b0389ccd57afc33068c84e8fc2b8b92f4f40968cd60496f5c9bea1de60f1d4ba47d0c6df9270a9604dc6045c87534b94d754e93811ad827c27fe7c4e493dfdf17b2908686b246813feef7f4d732cbe6058908bc3662ce40002df36a2b134eab2ead9ee8954bcc10f705fa0d7074f56d32e1a03693e2de3a233f1862c6400bcc30edcf6598a5e31c18e5a1d97234a3cd78e616d1a9db98d9f6eff92ec8dec0c6e1f0c3d5172a3d3e440713873d8904740eb6273de4535f73d0120346a9f6225f29a3868205bf4173a327da1547407027a235871ab763d8246306c2d8a7f1c8647c68aa287283267ebbd6dd51a64cdfa8afa253b487780e5d8b395ecced883a76973c90e80c9d082924ac17811692dc99dcd82d4f7be1d88ad2235fbd4190e9a8d719ca8545ff6fc78ea3b6f414e5f4ae617f4f930bffffa6689b93c7aee9b927a199a3f03f59af8a86b37ff211c5be88eca7cce735a7608fcc67e19af11faaf2cd69fdcde345d8ecfa4578fc524abef78570e38ab1fecaac993476f7268f9a021ee807f70f1aed46c70532b20b5fddddf9122eac99f85eabae794055098a987cd4ad03be6a2a47c7b76362b06732f22dffdda0be08a35834377f365a9c61cc978de914731a5cfb705b5e9492011f56d7983180061ad767e6f65a5851acfe1d5d999b127ffba4368975d3093cbc9b79cd722de6d028024e960472afa10b0f0c73e5e5082a7c6e21aecf61f3a68dec4e4b94441bbca2ed798c6431870887fb6f88c1aac0dc6c9dc5794adc00d134ce41945272d7ed1948dd606fa9b292046b240cd36275e8a03b609e082ec125bf868b5cf36ce090433bf679a057376f771ddc0fc6ead09f188ce63658bb64114404e2685c1e2388906d6d66352cd8fa2a8c5019371c43dc07b5e85f6ce07428c81cbf90d7b494be98ffc9006f6f69f6c865734381380e30eee00cbc685821e9a161bc49925f9ab0854bc7aecc8571ff7d07c1479e026fba093d896f3c72e341e83dd9066a7c2cd6a215ad05684f7f1eac34e61a1f48e53e750055b592fcbc71be95e06c26b42cb878fa42ad1d1fab7be34dc4d79f9ac440f3a0b41ab2a592561475cd99ea68ce8acca1579742bfa1ebfd51510129b0311d0763fc36d3dbd6041c9eacd29d593f7290744551c16ada17df06f6725911b5b85ad94ee742a09579a8f0d4141dc669f538d4d949745264e223f785efb8de1d0ba674c92d6ba4e4cecba1922d23548c26bc4bf12a9caa7a5ceb752262555c5ce6b4e2449c88119b7471d7b33c26932bd68f5e90ce252d9214222f4298990096c08f0086b153a1352d2739f96d42feeabccdb3c71f072d5ae02fa7512081baadc49c8b6e659ef3fff8e6b050b3c09bbe7bc02ef168ffd151d283d362560c4795253d99f71cfa2b4871984fe7f38a1ee82a3a486c89f1ec732d54c0a90e523f5667e5f2d5fa05a334c089f940464f566b92b7183b5226da395b8fd9339c10f223eb482b0d082d79c03600138d98d0ae3bf158f52cdefb5f094bdc9f2b7dd1cbb954769efcf6f1fc0d01fb940242c5f4ce0a0a1a115203949274fbde5e3ebd4b34315441c48ccabb66790c9603271d0074c18de7d85cfb54ad3dc0d30c93b2e1aa6690e2e1776abfa8e7d853f0f1730c30518cf4c59f16db89f72302ee7b74cce8503db2c9e434403b06b4b460d125544a94174a4c6ff03d701315afd900ee6a85eb9265d9c724c1adeff1b0c4c5f2680c917254ec25d9085112d7c275b8c13ab99e638a1fa9bef8c50767978857034ab3815b7de522f662e0ce148132063f8f20975baa50f97ace43cacfd179e9f258fdc48740843c475c3022980b96bc24d3a0e6999d464310373d703f8aff0547e0823400ba0f239449ef63c2a82543cff04d13ececd169dc86db9152cd616694692c1a96e2f7c1f78191cfe19b3b2540a060f8c87177ba56be68ff86008351d07a65b88ba4732ad32939df501e84c41447432c88f8b9b1556f33761fcc8f847e6893078237bd2f091c5f68c6408ee448a29cb690ab0f75f5579c791a18b268d31a57a006f16bf2849cb28ea1479ac371cb03adc7e0a40d3802a9ee6f67694035e18ddba58bf604ab548888e9b556c6b580ec0797177c9ee57e19cd91f289bfc4fc96e1e5514dc494e340ffcdb55e2b5b14a70b5ebdcabad05f4f4e89dee0b7ede03670d21b05d5cad35ced1935cc1941b47c132d798e4b5c74e728f46e6c764dfecb41382947fd9ec048ecb9d59cce46a0428f44f4d7f8d9786b7ebe25cf5ea79748e7f203d63fbb07fb8c82906936f9c2d014b2a108c3f6e13c847ba115ae7af678a694bd980a5022f34acde3261b7aeab18109d486d08271ce1ef232f11074153231a69828b988f98da0b6999893b1b4eb605c2d16d0bdf390b416621b561bd44d2ed8b8139ad42b2895aa7ef9685f6312e22da501e27c19a618e37c5e6dd47125754b3aa2889e72edc54a4773a9991d2705148cccc7bc1a14917629f491e25b9e8709f3664e7cbaaea679f6a321d66d9479aa2171e1710f2a9082c809918355fab4a06ea6664845fb5e8b427025face6b260a09b00393f03e38209f05e31d4cf5301264ee0f45f2f269257358c69296abec8c529fa6354679d91f49dac4764cc4d9fa135d094ae033b700ce7cf571cf32599b29381c5c5bd28f834cdb5aec1e3eed43788f92e91781d93c1ffeefddd18add5a54e3eb299a3a3621d8386427145d03aae99cef65a5c828965091e85724514fabc26849df4ed7ca9fa58f483add67248bbad618d21e502e9dcf73d30d11e8f06a987b7b77eec112671f4994eb21c7cefad74cf4a7b16bb2402eb43ac1afc04c478cc5c7d48d88fcfc6cd2e3cccc2a7c38925eec37d6519e6798cf17f35880019f32518f6a392676f1637b7e11292e53375fd9778a8f056d6cad6b4cdbe04fd6d180f3dcf1d0af3862332494a3bb9d7792129d5a9c99ed73ce05fdb7015efdecfe9ffa79cc39f0a08b206ff41cb2f54f95d2dab60355f11684feeaa1cca53a90dfc3ad1ad927edf6d1bf376b450b49ab25795853e96a352e5b44d3d775bd2116d7500d6e801d5736e7a459112640412509e82248d6ce947c47fc69fac2852149ae2632b28c2825cd41353a8b46acd8eec318eb7ce854bbd34ad6b5b0ff3c0dac92ee9767133f178471ef31f82507262c4331e0ba48a0125310a4fad490738b7267855b69356b3009e0af63b7fc587740b7e9dcb191c2daf0bfe895aec24f202b8903aeb8d310f46bfc8040104f28cce291e95c8fee069dcb899917cb4e0fddf1d53c09c05e8b7e4ca7766bd32b9f6b99e985483fc65982ca0b1f685f42dff0936587ecd381db6bd7b34f598ca45ae83fabacc0926018c41933b9266dc83d2a0bc3db592e0bbc22df465fea6c4c444585ad36119ccee6abad91c87c28aac833123d2c20414dbf129385c61d6d763c94692b0c63852171e5f7216b56ce7823b5450a418e4700374fd18e5a7cdfcbb59eb5c50bbdaf2cb0307c01657f7308d94922f7238827a043ece5574eea9d1bed35b4c54a84e33f28facebc6bc721ca1d4204ab7308e9f944c58ea7e58486307974d51d0cc22b0356374e86f70809e662304447f55c00d63ae1f8110bc482323c815fa432d4138a2766cbfff28abe92a9f6b375995143d786112b078c6c7544ab7a6c6cc940c70ee9a328fd67794e007d3918f391390b30ee8334340a4f6699cb9a674074d8ab39edff56e44a9967573e1b6a03520b8b1fac1573706a519285bacd8e75282561f9096882b20144cca06aa7bdedcb69924e2917b08c16479948a816269ad40f7196e53736bfd9d082cdc2165be7dc865ec64f87fde623ee783083cb76430e52b96457af18da2775a5cf71699ccafa09343b6048347a4f39240635f4e4fe5a83fc98bb825e811de12dc1d87844c88b42a2a98fd08a6cc2805ed6d04480bf6e67c55d5146e4421e38b6428589fd07b993330d3bb4a009ddfe2dfdb3ac027d82eb01ae21f08932ba9605212436b55d29ca4853b307903ccb519fabecf78b96019cd8134a49801250c0b9fea1e765ba369a86baf264b538a6573f92ed60667ed33c3864cac08cb41ce3c55e819d2752d2738724ce57a20171323df8df13e5fcf9414223e41dfad29691b7a1fe689a5c2cbdbc78ba20c5338c89649691980e3f41b0adfdc3235bd16d143bc7f73528afb4efb8e4bf5e476eced883bce963b514d7854cec4b17fbf54bdaae58928d0757bcd4232092ba6bcd23b05f1d3a128008b1ddcb09ef5d82b271bff788b65b79878256c7ab179871356522648add23b4dd9082ec55858db4178b80b160813c9233a65d3954c41632749df0106fdefcd64244d632afc1160137c733e788872f801a37f442401db4f98b238699bab6113a0cf5aeb5809761545af42d7e567fea0cf9c3e4886a1ec15837ce2dfc3705aaa6f9a17007dbdd99c4373030ec31cb578abd44b913905706bed1bc672e308dae05a7b7b817c83982962cc4eb744508ce4c7b4ccb4e65ddeff71cbebe41c67555692e891b48da6f5fdb594072c606e8707c528627c9e0a06a4c763a069bf91ae34b6b54c4bf72bf8728a48a25408c714f33d1d0cc0fbd1da995d8f63119c21b07037dd5c3f6f077a4b4c4b8f6f12b9a9d93d76835b01c9258e21d91027937f5e6678ad07ec5126e24935d1162240d86442f3673dd21b02bc988b2f7c122f5fb9d0d09e970cf01a1054e52274d09ca4be55f9a0ff5bb518516454501b464e447fd817831b48a0ff5cc5c15e433e060b7258c290d7c5d2c4a1e560ca0e365f140461e9f42ed584d740f48a7c2bff7917c581aeadbc32511f647acd52cd1bfcdefeb4a9a79afda100aff8c4a731351c5e93c8e375d28d6c819272a8b0c3f7f8293fd4cc5a9a3458d11027e2178bdd62e24ac9da9984975c4a520bfbaa591741864404d2598f0e2daa7a02ecbc75de212fef4ca04817d724f0a0756ef0299d82c304c6c4a8ebb6ef6b47688d88ab989cd4d049a455da151507510f9ed365f35a23b427c14adcc889903e9c9de1ccc8091efc9adad6be0cc8f446ce832525c12907b2e954e791c6b29b8185ca9cf72bfd2c3f4e8bee26cd10d317fea804346732710bfc4ada2869b01abe75dbff8afe5ddc65f2f99f4e1a7cb97f400ff988088d5d0dea5456b4ac51944b071590f9bd234efd9b533f6c71f48dff641d4bb398b16a3d45dfe1cc9a090a10ae926f7a263c9db388c670c92381f57ecf61180c3452ad674b24af28e54e857aa06e0c53ac59eb44aaec91c17e23a5619a060d6ef51580c4242cb61e0e6d6c26d2622cc872da3c985bb59b2bf60182958c83d85fa394933db436216e10df18a41ca5c323014bb3c2c5b281a97ef0c68d95359a6e5e1d3be4776a5b0257b582ab006de832ffb645bbe60d143c52701f0f0b68e0a75245515faeccf75b050409d46f815938f534198920e45d049e1f09387e1e30c78998c5815be271618c07477053546496ba0286863e5bd9152e07f38def5b86297388dec5dc804d04d4d3a8653b6b2cdc747e322c0dc2b8b98c9acab3948ab31d009fa9acdf8fc1727cc40427253eebf8332273c6f20de556f0f7fbe7748ffa3068a2317e21469405fdde94c3319e53f8362eea50ac370043595c4e6c1833c88f850468c5d8d63929c80f4cbb2606ba9d19d468c98943e1275ff94752d2b482b579571cf49203f97847dca89caebc6fbf258a28871c4809619900b82ac9327095c4ef41c7a7d6dd19b62d8fa158c311512294f03074c21ab6ee1267f86910fbee88b646c1e7cf37a6ddb5df1f0bad6a10c1777d20df32cbd5cc91438de111e07034d9219705e809a859c18d4b3f613f3f7892d4261e687e1c141b3b04c51c8cd3669769d50d45973b90cfd650be1aaccc949fc21150c0694581cfc22f83084ed82171e23f1a34b06155ae2e945261939a8d55820cc0a9561d9d6cb590c29517cc32ca2dce9a2f354c0c64a95d7a0bb4ee9a735d0e74c1b2169827ca4813d0bab2cdb0bec028442e8f7508720a687936413866cede8ba5e1686acd7ccb9d7ff7cd6ebfb315bf80ed57a5c5c744581b3b0d1581d07c167a1a6a4d77b00862b39e370ada6a00a85e839f59f0f72de358d69db7df648216213794d5b42e16093a338a049cfd2773597a774b3afc5f896835bb07d1225f5069dffd80d040f83732052b4422ea0f9680ac4e3a6624cda7582c9b9d484cfdd11adcf91b7376c31cef75cbce81913f13a9dcaccb8d5a113d4a804cdc378a65256919cb94dcd76452dd4baf3532fa9b897240bc27a04196e27846ae00c4322d806624f5499f72d0a3bbebfd574d859245d7d1b680a53f2c2a09cca3aa0daf69831d4a3bb506fb4f3115881be902bb12182d97f38f81ac38b21bd49b0f675bbb0f0d44defc2839fdf09b29872bd5aa8d8b152113dfaf55a05c3a955398a7fd200141f7ca2ff1a4b0151eb55ce5a1c2065f5d45eddc54c9925b5047a7072eb0e7fb3083ea5df41486ab242ba52be4e0880ef45cc04f066d235bdc045ed5ecf426d9fed1025bd4a0757f5c30b341763148545b9ec4adb515471f524bcc0235157b61ac0e831018e5a16a0d9e2d60cdbcf54c5e4b5cf2ebda03e1c5f69d5387a1b65c678a5c5a90721e8083fd1b9b05ff0f1bb940f0c01284acf24c7e286f3ee79008665eb9421b0d418c3ea1c760d573d9b941ca938bd4845f782d2eef53033efcefae07955567f76b0de946ca8b0fafbd973d2271059e585de91fb799cc41e5ab0904383ba2ce549af7187e8821a111a952fc9c5bb6971e43a13e25948101b400e41c24882b04f751a39bea75c4fc1347bb67dbfa8d13fc55e33349f33e46bb28d776648ad2dbd27d28670f2a8006d2063e9f08bdf98f53c81acd9ed639ba70d0e29fd5d35b09a000149f4ba0b105170f15590761196afd846f8516c6b798a8e2a38c9ed3d43592535416e90843f530a9f117f76828bbf432f4bceb779c6ace71d5054ae0eb6240e4c802b55903a134cf6121d2c7373de39d59a9add509c036c5f6a86ad07e47697cd0470637c31e3a87f4d61eaf09f1d78406124327e9e62dac0cbdcb953a23beda8135ca6cf2e63bc928b0bb26a0b2fa9d607402e7e3c12c0c1a45938d8a8316a35762dd9fd4a9c3f05d488a62163febacf5216917a1e396202830e69b7def7329102333a69e129f66bf1b511e2d887eddf36326c56379c79f1e6d9c46abaf8b70c55c958a8cf505d2d1d87750736c153156415829e6db6e6f1d3fdeccf77636cb9902e8a22ac01fc1f1d7d1964c5930ab8842d0abe93021980faa2066ea6b9b780774cd8ffcb41d5e71e67a448aa747d59b3a993d9a7779cc704ddec8f141055c81399b79e3c8beaf91000a4040f977a3dc4a8158d9eb423ce2f875a2075eb55dc16c26b6fccbd8b3a13698fe89f8d5fdb69729618d738d9bc175920834e1d7aa3fc828c28218575b48cbfdca4dfcb5ebb000a0b32da2045108a8a1a8fa10cd3e352f49713f02795902688a4b034b54a3e590ac9093258c5ab569ab5de411138e7302d5a74ad8ef79e3b075ecd3ba368c50a2f948ab23602308f1de6c5603bd531e070520c065c9a00f0c32a2ed152512a1afd3e09bff88c06af557ba7cab353214db0dc96223350ab175d2d6ae63331242de65b944964d9faaf4115849628da7919ca3111632cf93d4a575769a240c0a3afbe9911ce0dfa69e4fcc9b6e304d808aa1c40545ded6d3ba69dde2e5e9161b437917aa3512c9db0e2d64aecf9339108bb99a9a7a960becae62a48861af96f819abce74775cceff761fb368311a11f37426ebf5998259c1d59f8b70052e191ede5d5bdd022b9aea324d752fe2dc82e82b591b8158f5c4edcc09369574af0cb37935178ece2486866ff0234b3bc6cfa8a7f239f6a228742f095ef59b070cf79bb7e677185ecf355a164e3dcf1a8f7ec45935595d1b2b3ec68a16abacc5405c2ee9a2bdbb111df84dfd7b60cbc356bcc618401e33d45aa1959499e6377f8c4547eee87375547e17bb8ce1f5954e4d8790a995388527ee2ded24e7d48c2a86ac65d35d1f6d611879a42299a2a5a999967428cdc62be71bde7f6b55492333aecf418d0fcf9e6ab9f84ef5261b3b66dde7489813309fe22b18ea2058f02ea7bdf09a3d9e66fb94d6c6300efa400da46a23ac2e46b5af5dc97bfcd6d26d79893e2a7e91bd129b87e68c1e3e8927a1a6169ccc5a3790d6b92ab67deaa7f242576e6e3f111599dc9a61c4ca845c92e9e95c066865d2893d2ca926160859899065d19ddbef71672c667e33fabb035d9b8fc0a5783bfdfb8432c2442b8e46ecb377d24418073edbce0243b706b8cdcd0353767cd454fc1e8d20363a1e934b320513f6a3682d65360cdc43297491a91b8e12d0727d4d0eb96d3f5e5ea22cd91647df7baff83f7f7a4b2726183af5da26a5c1d7f9e33ff9d079604658be8d88642fbe6a54a1cba1622425134c6eeda41650b334c43d1edf569e52e5e6d300234a98db1129ac3dd0dcc5d96ea0d7ef4c7c2ee2882a8b8931b4567fc30981df8a64a62687c91ce26ac56dca81084d53079df2d7d9a00752db0582783d8fd2fc932260fbd4d70ce8f4f563eb95513cbed5ee8d9cc39e2ab3cc605954d17c809438c474798ffe1935636b85b7e71c0d90ac333b3cdfef19f73835e8a0d2d109c9d6eac763a4c60205d6ebb687b433c6eaff2c75e0adf73a31d8bbe7b78d5db2059b5f4154661dc9e980498b09de644b91008afb54d6f7798c7d7d9a5ecc0a979f93c1600cdfb54c5f410211f843313bbd9c3f2a058525796553b374cae3089780338fd9358190532b78ad41074a24ce96f65ab89b3714d27e13a9f271f163d7a2ff0744475b8fbf1bc679e2a52ae1ca725e8d62c253f50af66d80a667ccc2091ae4c689a8e9a988add551ba1f4a7c49a398dafd33f209f0b0bb16cb83708a2e843255819f2d3ab68181cbd55349edb7f5c509473f92b53e0daa8994638e569bc452c732e95e6d94b22b810c48df17d6d3bb9dd94f8b4b4fbe04fbd94a71af4202613f818249e1b39ab3c20d8ac19aca35c584b1be82fccdabcc0ce6908a7b50c8250c9e18e45b0c5d45c6d54ff3b1aadbfdba38bf31cc282efbed11033a21f133267cd2efd5963fd2e0cc258a677ab674a2d02dfeb2f9e00ff8c79889c9e452d7fa3e10ffae3a9c87522485f26b90723c8f9ef9f5c755ce762ca90e0908e16a775035c053c9d98eadc27812a99c472cb73c90b3794f9725868512c737bdb4a4e67ea818f3b34d4b21effc257ac0c1ade15fee871e36283dae1c338f798fea6674b336b3b253c8e4c43387caadbacfe89b34a539d93ac41ec829e0e22ca414e071f7c9af6d1dc7a3a3f6c4344078fd919b8d218571039b132fd8718e8fb179c16a3546a685dfac298433724a588c85ccfa598b43b41996ef80908224cf93bc1617a60b2d9f9b6fdd85cf3f24c0a9baf7d54087ad31659f690bca8eada352c2d82d638379cf44de251ffcca666976a651880033c618948770ae5ee3fda8c7ec6907dd4626dc6fffa5599b2820fb5469290493c366fa0b2a0a3a41d8a157164a4ff213bf06cd7da368ce8e3a0e4bae7453663c1948e0d0b89ca7d91bc4b20d2060d47e49379b0dd9d6f70eee3a4103cd54dd570066cc313f89aba4b5b59bfa0143820989c30bf8aa9941ac04ec83b5f10f563642493b266c0b1f8c4f4a9ffe9215a55493aa9d975e0203adbc20840b06751d21153a756ab9a232b4f8bb11329e9c8889d7d8b0d610561d324dbffd5ff74fa3a84de1b7f4d5a111412f5a515fa08b54f6417b6c298435ef5e7f8ad4a06f90e8564963489fea7f28ce8043a05e798eaaf8612ea9650584161c80c106bfa0beab9fa99b44c1b0ddf13c625a8d1d0f4df3a7baace4f37e438e564ea6d6bd40f80d222faf5f65d88a7539423ec3b4035634339e66e1ea4fb94204341660cd1089800b1524bee4334c44618528d21cb4129c203ed8476c51cbbc0cd11d72930fa649daf317d6ba716de59e40b1c3489fb560696277f8294cdd883fb72af245bd1647ea066f1bf19002e3c19bea6872f4796e9ebccf8ed7d2ac6a4235b8168b570c0c6f4c67e4f5a112b3bc0a6f5c4d342a506d2d28848f515491157b7a987b2142a1dc6b8d5489d3e98e1540efec79946a183a7166e9460ae1aeebcf6395f43f7ae4a554a14c25f28393b57fc62d119b3bb67181ed2735bee0810c28cc5e19cbb668181cabd11a8fcd057c62b12b8cad8fdcdb143014063872b76fd471fd9bc67ba7f1a6f6cfed61750c56e5139b6293b84c94b883c3648a692396c273b12fa9f542c5e61d63cd5a878755e83082eb46d487bb37362ed11a48887e9fb654a30842ab85357c1d65130e1a3acda2f759583c52a3d5898b936c645ebb45991c2d1bcaba35ede6fc87de811f4a326569b408681af2bbcad5c9c45c1e1ed6f8f9513cc162face58a6ed435c82f37952e4177cf6c6d724b6636272632dc7bccac3a671d1e6d4f35147dac8a19eb188c18edbfdf1faf647527502b97071909df99980656189527dc821e306052736d0304107690c54f6d48f0256524c29b6ed8ca65774cc1bc778b58c8a0b6f88608924df51c448413bbd579801ac464f6cdd914ff602584bea2963af559ff6c2bd7c62be00152ca1ff6ed1e0a92c58da77ef507e9d033df348238fd17d6c8a87277931491b32427e3795a4a83880ef2d8348681c8a8e866a9fba81cf76087749daa3c9e84e0a104913c5a6531c920e21b4c3e7d8a1a89806ebfee28c1245c8c322e61a4ae97a71d2f6ee2cbff1460763fd4808e7723ff4d556b66128e0a668f128c3718e530b35e2c503fab517eb5395812496987c0a44dca0acdafcc7e09e1b08caefee52ca1a9227911e2ce47ec323b9603f79d755d3e029781541c109b5c8f4907fefdbd5e80ade7f4dd0c1b5920d3ef0c1ab4c63ba56cce5d1074c8f341c495ee377ebb541192b8e1bb6402574c2c659674749d91162670bf9e67f5158bfe689b6526c4380376c747ed0d176410365bc298cfd6c41b8fcf64fbdb402b4eebbef168c6495a40d785347e6001c77e30302dceb146a28c9a875c05ec2f3b847015ba69a3f5475cee825a2ce1fa773679f1c58ffd8243f9d6361b370dd1abdd3a4abc7c9df78589454e909c8d598ea87316dba831ffaa3cf1d81516897c0bf25532e9baf8d745b5d034548024e0035e409ebeccd604cac0e259923a4b73cbe59b5528c1058972b7b7a1f7016b01e65a4936467e8295958c6110687a5392716db70a5282bb84a74358cc0d98ee88d94026ae32f8ddc18017e63f60cd8355c42ce41e06b4e63baeb12dcf8b8832bbf888f1e24a2dcf8efd85e9519b6a54e7a076489130ced51d530b70a70d0963d0c568f6096a99727ea39375ee765852104fa1c640651cb905bc11db7a1cadd153f993ae383dea3d76478146aa2ab65489b74300ef314cebb09172731577231eb94459136dc926680fab737be34fd3a3a3414432db0aaf05bb6d8726bcb55d03752f7bffa4e8c188c10d17869aa958bc81b8ef5bd9dc58bbc925e611cd4e13105398c635cd323bac38c8f7b4871eb89d814632af8d96671dcee50b9d38dfb385cca1414b2fe02f7db58d90ee8414cd41becd6cf29a956c4b71f36ff200d5bcea200d890f05b8ed489d094552bc8ff51ffab7c4633794869faa7da01690986bb687e7a90014d62c0c57b080031ecaf8a5b3039888c3ea8adcde3bf6b13815af2811a7cec98dc3514e0882d0f77018de4885559ef08da31343f76858cc118ff58a42dca8ce9083de140d0a55a1e03f94008cba7604fb7dc9e720e4ea130f773721eb9cfe9335af5cc295572d0c500ff344ed4aa35db923ac8ac8390470ca4bad33f4a7a002515b9187885b300f230222055c5b0816815cc20bcc57665d43fa3b26753135d517534bf937ed594b11ae954453ac52b7b30e9b36d35d3e14dae04918bc752b70aa26c77ddb01a03bc4c737bcf23d1d0bfd3b534ebe4962c8ff906ad9b3bc743edc5b9be6c77945ce9e5ac54d1f9be370b7845509027369ed1e75278e61458666822b823aec9d5ff9b32b308288700caad2a680a504997633690a1b5985dc6a00171d200f1e787a847721e8a928ffea68a68be549c72b5f5f0e00382d50a1b280931d446199723c41997bf8ce853ceb06836fb4413b37986fb48199174900cccad2c16c6604a077083bbd7aa5d44867b2bbdf6c06605cda63eb6c00ec7ab798fa5feee48c6a4930ec2002d66bdde19d31d1928edade625f8ac91ebb2a8ed069135f39636b3da142053a452dbf0a1a58c4a7da543512e95979afd670ac8351f2d13c6a947a463fa03c3e0dc04bf9dc5858f55d283b7c0b9d85651f4b22ef6c6f808f4d26a5e05d830d0ceeef2427e705532fa468b3662d9b5ac1f0637c22ae797696e8762b263a6ead40f953cb3aea9d219e0d87b428592dd7546938d8673c2d66233d7b31f4b4e02f33a7b0b60a8a327107d35115564a69140bf1cd98966133541d8454a9f30680b4a07f104e024caeb7f391ba94f5ab4f52d5589176a883c1f09cc35b9737a00bc8145c342e4c957dcf7446bbb2c0340c95e873dbe75aa02ca629d134013920bb3ca2f29383b0012fb2c0d35078c8ac7b9caed93312639189359c55ff9f8daf968cc873e9d28cd658963049b135ce03a2ee42c0943466819fd5839225167f087a79988779277269d49d807b0ea6a57dde626d7b278dc23a15c6e2e98963e369d5f533dcba53a38b3229269fe1f3758f3f64869826a5cde2a6e9bb27237a9ac333a1e6f61497ad739467289e2fce97fb961d1f3695de9d6e406e820e629298494e779585bb5e56661e55ee6ac6c8f8ee46e3acab40fc18913d1c1c1456aa4610e11bfc6f8fbfbdbe5381381b0bcabe5757496511f352e1585fa37d54e6a31d68590738b6abd4086badc8efa016bfd992e5468a81b6983ef7336d536ba9de6c958e6469070b6652c6fc05bfda8377676f3d728b992a554f37f2033516fe37c930ff230b1c1109d05323ffadd3bf1b13d957a5d6c6cd2f4cbd37b9ed82cb7efc758bf3d7b334b5345beb56857ed7dae61bdd5f97d8b3e937b5c0b655776d62ffb8a75948cc41662813eedddbde83404643a92f8c7117616a5e39c8aea33f993d202aafe09bdf4a51b9b02bdcbcf58ce075b48145ed0cebbdcc1d039eaa9579315e9bea40433a97d20d905dfa9ec1293fb8c49ffc3a658846055a9e2aa07bac10c50d02fd5be69497c3712915ece518c15230b376467b9cf0f6de20e283c956250c619207bd54049f9a402e8167088638bcab4d438d5667ce6a9fcdc818e8e8ded529b3fb094d1c81ee96792910d233b2f04c03a5bdb146d7c9cdaba14ae89b11acffda997b902eceb9f06f9bb8a1ea97c0114e9c1b18bc54867343b4f13fb6202976bf0bdc0340fa77c6a630cbd26deb1bacccf0cc729adbfe078be5f892966dc27e01c2f1da433166074c01f7970cf1ded6a5bcd7070dc7689f2febe87cb23886c36c1a957c7cad7060cfc9b50d76ca5e7aab35ba64a5f4fdebc978a2d686e90895e5d9e8064f928347eb5fe031b4eff277ccac4cce57b6295d3b700fb773e725398102cfdbde96d4694f1f1a229de6612dcce52965e0db3a2c7d3e8e0db41b41f18a46478d68fe188b97f9ecb2b4fd9de5585ac8c321fe195afd573e463d21c4b1df208d900b097465ffea759f53b09a14c9cb7cf504069ae0fb0eb6ec30e63514d1f359868806a1f54b71384be527c4c1ec25deeb8666f3d8cee46f795a7188abae9a6883482386618837707631225b577cd96cb557908e63125645d0c2f355cd14fcf67bda3c8305d6842beb3028b09d4e3769ca2bee67cba976cd24b92fe716a288d3cdd43e4afaed2b49eed61e0a1807a5f9c7c8b38e0ee592d00e1f6e11ce04de25a62e10fc834e0ec2be6cab5da117922dbdf3e96e63d32af93a4221cedbaf37e3dde98cf8dd89a79c49c14398b1c0a6f984bc94598b40fcef8cf986e7234202bb59ab3f0005190c9aa863126cc737d5ee1cbbdeb5aaa1ad66033cef2576b88a26e86ec97d731fdbbdc5534a851ddcfe3e9f1b3098b99f3dbe40e3b07f23473fb30f1fad698900a688c638092959844dc3a1c4991575b73e69e5da56e36f6f28578b9f9f2479da7816477034860fcb5aaf658c7b44f7c4863dc3395bbb7d79754b3b69893476f9c714ea07aa8f7e5d34b0e7c1d60e2745b03e07124d46e6a88229896c907573a3cdd67158c2ec4fa862efeac515892949caa37919a369e3e9ecdb2706e588fb034797c0940a6a1d4746e31457f8120a172703bb39be1d234621638b83a3b142163cc4dabddb2900e644b0ccab78a5e4369f800b65d4b698eb50571be238007dceb4d43a239bd8ca6dc84842ef8ce6b22a02152eae41c5ca7aeb2cffa1f0ad6bd1199269c64e9bd35e13326af79a9ef738b8e361681d95c4c2b7f4031dbc7e370baade05b437216595119cf8713660e4c43dd179d824b965fbe5e5090075622777b26ae173fd054c38bdfe40b1926c8a610f791459c6f3db00e0822dd763e28f0d700928ae4b026276c7c0fa4cbfb0360a64ab11d0ecf36de31429a48ccdb5d1c59b8e815bd02ae1de4423e6dbedf5bdfc4ed10021ee3ecb1a10b38f2c399abef87a8806edf47ca927d4770b1bad23c82d46e0abf7f24ac4aabe1562c2de31d125297285da252db5f690e5c935e74fbc0f7562be641881ef9c6d3be25c56cfded7c37b6fe2f83413410973cadef926fa92b432526ababb773df21fd30a982020ed6ab1f076769ba4ab64b76f517008efae041a95f8e61a6b31ca5f341ff25ccf843d5e7a9c75b27a15f943e2cfabfd01d422622bd7f77991a08bc72afc6b4f0c1551b4fe7825f0bc27132f5752c3decce4dde5d79858e993a5829deaba6b7ed6f2950b18a452e11348c619af1c6b9898121406bf8fbf6ef3f15aa8bc35238c9fdcd146c9608a290d41adb7a2f89eb55cd808185c08438e8e9dc5a6612c7f5cd12b7e003f19c32089e6471629a91620a8865693393b531c8d64ad77c3b02fc7cdfb2f0ed08ae79c1301376f09c20c9e0aa8ee440c09160ec5b1fb320576d9b0ad080394e8b4a1d68b91c7b6682add2341d26e7785994e9cadc5305c72f04a17cb879fa631e18f01ece59279607d671e4ccbc1e4d5018b8b797b92fa6ecdc397c016e75dc91abc419a37f6a67c4166dbc9d156a13897f620127eeb0e56e98206c3244ded0abd4866ebb2d098f7de7f7ac6172b85a5eaecc3cd29319a9ddb6af881919dc0b6f79bb24bad9e0f185a4e342b8aef302c3205dff80de4159827ba7df0f0c356bc27939414474d8f21f3a332b10fbc4083937dbcbcf336a72a3189b57486d792751ef6f510061673cb2f14458e76ebe08dabe8f3b53597ecd569400668257d6df3bae1f36801dedf6c3e41bf337a6796accf969772b6c33b3743b58aee32c3c3bdf582ffc9b24c4ba3acd06961885256dc2ef19793881ba4f2859ec73c634062496be5a86360e1f4ee5f78acb298daaacb2f5af95f45affbae601823161faedce154fb6c7761319e3b68374cdb71a86a992640780eeb659cd5c7da84a06a7b57d31a43f85ce40266dc1226fdf0f0fee1208a0f2713b3b37541cd38869df257369b40bc9910c79723bcb71f027abb66ec3f50d7959d4f1dc835136e913f8c1ecc72c461a141e513318da15ebd1507e4b17e48aa2c741251719d8b8294d13ac7f948267c16c3020e1c0c4bff6e07e0765ed1d4a1dde19fd31941b2dd31544ac9e79e48566d389bf963f875ecb8f6c9cbf01a71223b7d616ef9e5ed3955b992fd7259a98b0d6d095b7da8e6455693b34bbaf791a547632c25f02165000497bb584e8a70dafab11f59a41bf235a24c59d7ee56285fb672ebfaf9091857a2676a07c1e0b79287c4ea595622edcd14a66b9afbaf7800122343a600f9c7f6c4e775c3dea493a5b28774fcb17f31eadb76e2e44d10d94f873a0775985a92e02ca0c7eebdf17c5d437fe3db6cdcbef30e15d30242ad347c73d404954411b4fbe9ba4cc63f9e0ce506e98202ba62911e3ec1fc257902b93c3915d3960478ca4e5c1183e0ac8e998b3455dfe42d70501fc32437d1d79d18e2bf15304da07b84f5ccd7ef0767c4ea8da5c4592a2ee22287ed8e421e9f7b273d17da372af3bad9e7c45c91f57122ca2b49de794e382a5831b2dbebba4215e3fc54cb8281f06bf256bd15d74c8c66044e6bda984c682d37b5f115d683f546c364885656355a7508c2dd931449d74a0f90a2f8ee8fb06f4a833ad1b9c92263fdf3aca4e9dd9550ee038abcec8ec701d401eeb2100f7ff167545bc90ad0b99ffebf83da081f2ca2f5cc466642ee4462e944c83dc8499da5fd84afd8db07240d4652b1858e364e9952ba5d6f4e5e09e302d3e6d3d413eae7d917f0a7011c94eea9e4cc1a4bb8ff59dabb56113103816f121750970ef252c52464dd19b7cae2496964e34c3653020cbf75f397e2f5631720791088ab1fb0117d225ab5f55a54fc0d8ebead3f4582b7b16317af398b8fccfc31ecbdb0b8f4a0fdaae2ac7775940ec77d08eddb3292be17e7689f3d311f538da101ae29efe4b7b2c479b4d4f5812a796156c8b74cc1b27c980fb61ef030424989c8ecf097d1546d2c5d2b9609ae43f16d8b5295d91706f95f47948d5bee6ad3956ec17a3c66217e009c990a8c1f5237b93482","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
