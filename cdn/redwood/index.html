<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d370a518d98c1931c07768d0604ab5ff58a4ef040250a00873a52b750f363450da740bfc22db52c24a40817c80c336ffa0e7b06139b6021c88124526115c51490881839ab6ee3f937ecb447a183b12a48871db7dcaea84c12a4dff23b1bc7646e22cbfd8d590bf825f685105bf4c3b6dabd5a45373fb5229e76e16813f7ab2aa268c74d4a65ee1b7c99a975ac9d2e4ccb7fd482afee93f9d9f94a7e7799b947decd1da5dacbea3338c6863d7f33c626d46c1ef0c47a9db8ae5dde84a55aa508eda9888d535242aaa42b9e5c4429df1700b5af7244fe44909645856fdbf51b55efd064817ae09b117a02575d8897f6d4ab4ae03757c8f887e1a0a9e18a339ed7e20329b52a2c9bc541730afd77fe84c93535c6663554c967ca959e27c5344ff96281b96df80bbaff0fae9a20d2424246741585f6267402ba47e356cb47c49aa22262dddd9279de44f408c78e4ef641de52259b1d6cae8c25f43a2e1d4dcaf43eb08b6c6287789dce32bfc3347fcc4e9b96157c926aef476ba4951d42441fd50bb58e84804907060e3c80b2813850711829ee88eecbf5d885583f758bd39cd1a91d80f5f7bc030d1cf4b11f4d2577837871009e97dbc73f663666723e0727b721ac6479ff12aadaa6cef8ae8df81fd7816d77644610016ce721aaa88e996690ddb9c111adc7e02dec2b6653ba903af53819b2d4d74f1233738403cdf1cb2048ae16f6efc2955b7e201091630ad2aed0612ea3865f23df676a0fe42e60ce940bda424c032fead03fad82bd8cb0d7bcf1ae05dd7178863983e0b7f29ac2efe4f48695a43fbdd4b0c3f6f085b4fc9b28f34d8ceffe5d32d0055d95f523b070df358b92b137b4804ea52e57d0f7c070be9a76e6b0185f272688c2479566da1009a7629ed757630193261c3ba685141fc5c46f0ddc291e437ac3c93759df55d23304ee617fb0d44481916aedadaa3574676772eac696b21a921739ea13afd15195a47cf814f4ed8047920ddc9d346c56cab30a95b1cecd33920655b94a5636396c2e540641cb595f1101a222ef956e0470ec44696ec35e3b5b45f1bf93bf61cb46232066b831d3a8ecbf9e963485f3b7ffbc19add97f2eb8d625b8aed20ce4f2ad2b8aaf87c4eb7f6f667ca136a9ea154232a8456bc7d12a38af219438d4affc6a4a8b50806707bcfb643b6aac52da6141c306f52c9ce7253509651b3bb86b2429669cccb63ceab2d7745e54a39296a20b92a95b8885cdbcd9e63257ed8fed6e86c4c5a3165f8e76989758bfedc759559b7a1da3462a5d57a4bc59e0c9ab52545e5b125f77ad633d2e716e70626eb49a40e8eff94c39bf8f2a8c24f003eaa50c079efcef2a3df30ca0b4b9edbc4efb9709b5a036d1383cfd0f8d466fc915f0a7d822442e84c7ab575a4bd2f9cf41dd78a783fc41f2d0a6ba003dfb3719dd9a300953e4d8fda4673d1011dd41117a38bc43fb2d06c49d8f5799c655748f6aa669de49c79cd5b5d31d403626c225639ed2ab22890b01e0181032d62f2efaa222c395d9d4d5dbfc5523093af1f9e0581f2f211967dc3a4ae72a565bbc93a8e1bc256ee0d902f9801aa389a55b22a53e013f090c69a894da7484a0d344bf9aad6e660fb3c044537dae9e6a9ba408324d7cd013bf3dca1e6db9ab4396294fa13beaa43698e5014d9f4276448b40de0d50665bac05fcb9b1e475f8b6933728ec41d06975b862dc0532cf318f76847acbf7fdd1656b233239ba42f8b7664e7c43e8f1271500b23ef6fd3806acc104fab4faed32e6911bbe6f7872118bcc7a2eeb85f8380eed323737d1e8ca2345f86a4c230b9d1f41d142c468546d8248d4c15263bcfd19492949a772caf7e94d335d35d1774d83c171a5c6c8b84cdd5e44f357120a2426f3d7abbb7ab5ac358c9104167c09e5e1ae7a8e797b896c284c866d7ce546885bcff226a30a96ae3a5f440217ce36793e11b196c47cc36e674761e1ba5cf94ad5dc5d106517d48219eef99d33b8addcab3f9d82a2918c3c686dd06929fbae950fde72e800a3dd63465e36476c7dcbee65fc2e541da31ed15f4909c1241f218e9861fc07a69fcd70c84f5f10ad585a850bb1b577a915d3ce9993bbbe065fe007234a4ee064dd4be975fbcd63812decae38592d9808d7d2e252e6312fa9218b8b1d9dd7e13cbcd139033987ea48dc5c3855899c25070b8cf1be972867554d1a5032e2c288bd13ec7c71b71a6da4265fdef3c913293a925c59bbd313cbb61998c222e1b2d4a82de06e21cf97810b4e5ad48a9f3cde27da38e668389a586579c8526b3ec4a624f24429170c3da12d68ca86bb47f4c4eb6db41c53aa2bb62fe592c85644d7208a0e67d417ed74d0b1886ecf5bbb52bcfdd4c49f3283463b22bacba418c3e5250fe22ec67b6bc1d88f9da68657f20d250481a732a5fce2507709a51b0942deea5c2f7fa246d55055998e69aa8b1c373389c7fcb0511cfd6a9156311f41eb58aa1086c2298b605d7e6d4969447455be6581b3a2a84add6e441e51095660741efd9e5365d5a989b978672392580bd628a30b81b566227fef8fca70ec216cb903ef93e769f3241ff5bbd2417602f177eed22f096369be41789e68740d6e949e0fa43ddc00627118bc874734f4e13c3bcf941c327a9a45cb671d0b610e7e476e9d961c234dc68a779cb7f80672c742c1225925fdc7454f6f08947577df3d85791de9734b8a0cb23125fd06e3875f53db70de7da63c609841dca731fe9d16a5dbd86bbba9830bc735c86f921c3915cfe05bc5dd00fc273e811e0335c438b3bc8f92bbab961ac47e2462bd3feea5bf87baba244199053b9760f2ac8a84adf84e4e14702f5e16cede9a9fb01a8b8afe36a560032264a8e75cf1c6617f684592d5db26ebdc3d67d146e1ed0ca0021b8d052d2fc8e9f094c83de56de3596e9512f04ffd9db4b9953cbdb490be0d09ee5bac54fd8cefe8ece71d8a98afed57543ee14c25c877827cf3f89cf8c3d0fa56525c3f14360141edcb0e90c36a578aba7cf6798aa3d86f1ec58e6d8932c57edd335ba295c2ca6ae72865a2fa0356f9748b32142c6bfdf51d9193908f0a9c87f8f4c8709dcf25b3b6e1039577bbddcd5be55746b93b021514c524f89514aa22e780d66a0ba0dcfa7840d8d05c74b8dfb8bafe95742624c44b8aa7a6a0835aefd337db450d4215422c6905999de3e328d3e7c1aa8ef9131f9d676fec51382ea0909ceb8fffeac84f02e8914f6f1c3ea3e43b2ad39b01b54ff2111a35edd83d835070c57fec8edbf26a6b13851c5602e876b3b188b83ea8cce3a9dbf3d4bbce46bea05b725256f7bac878ae77bef5cd942998b086311576fcafb31212b9200551da6b90ef4f2cbb9d5224deedb16eb3eaf7da7789bc65a184861877e48f1ba7d3f2db8ed978058f019010e586c799a4d39c47c8f1204b7ce4395da2f53cba8ae4efa1b04a5d8755875518144ef3616e5f11150fa0116d9ce263142dcc6d26f9025e0060012345590060c3bbf1e4ee5494fea1039f38c814be2254e3f0dd0d0ec44ac78b9602525a1a4f3be524cd2753df0fa4c8ff039a1d03bb8b6dae41f216ef4e29fd402ec774d2b90c81ab0f58f15c7fbd7bc54c9ed7a59d11c0259ea8344bd6c5bd97041a636de70d6ad7a75f73de48170cdacff3d28b84ae38f9651c04a8de06b08ccbb2e69d768e28dda8c39e6152661032eeeb3d109da650f606bab6c7c1cf92a438c5657e27cb4d87a3526eaec1eb2128efeb551d31e0a31533db36af9afb78cc3b28c6c38edfe73297cc90cfc7e953d9d17bb95a460ee20c85426fe33e36c0a207c87d90a93fd40f2775c7860ddda5411a3b3dfc99e7abd7f07739e34dfe9f042966eec38015f59ced22d52b1a6aa826548031be622cb75405f2bdf8599ea93b246b2047167993455c749e8a5078e8a2bdaca9651b9ebc11e33849aed3877257dab6f1824f46790f94bf48adac6376671b498e44ea20b8eb8cc1f8d2121b38ca93e19dda96965b37c40cecbea5617444a816da0ef31316154f90a6a674727630c372e013047ac854cb5401bbde577ad1a015b00206f767fa1f205d3aec87e4fd59bada79654656e03322dae1caf36bddf09acf558093519b008abb09125841902aa49b978b83307c5f35195cea4bfcca49459eef4921800a3b5029571489d5e484902501b42c69df7f728b3930bc0e48096bbaefb936908b6afd7f9bfe9bbb3b1ff3c7d8c0cba21325404b3fe99443d48e1bec705d85a89ce2029e889ae62fada7c84c61dd6c0c5b3fb9b1eb22dbd9ae8ab3af45b30a187eac4cad3d817f2c3eb8fc74cef66eae011f6b1a598527d60cd6364ad5334d8ef66a7807e9e135894c3476f60e92ca2129e733d0aaf6c480dd34829b6afa57b5262c9c0d235ba15e634314ac927a6b30ddef62d8671c445d1ab5a692a8db0c1bbbbf70a639d19441015a2ca862d23f1f0ec6795d601c6ed82bd63fe6fb102b5b790210bad2e363254529a49eea4c6eaf4aa2feb208d1217fefb02ed95500de95f2d589a63367eaf17282e7ad7f27aefb8aef1f339f6e85b4a1007fd30528908dd1532874921f0c4b4ea057bb7bd297ef981ea16393ad739621c99b93e719fdedab79676e02077c4f01df2879aaade1021b6c3d814c09f6d8d1e8a8e918fc14fbd0365ffffc86605fd53977fe547b7ced0098692712155220e49a2ba94edb64e3ec4f13cfb13608b8dda3eeb699dfda2cc0bae3d7f3ab3568432bc75c097086507e9b63d01fe0ef344ce3eb0cd31b295909183f052d68d2764268cf0a26937684d883ad123ab9b66e726334321f34985523762f322f9561ad7ca29ff67315f0510ae43fffbe09d7fb8b0bacbaf148bf5d67e7c4273856a8a1ed8323badfb3601b663efe2fc0a14bd923e3f7b0ab88a8507ad85671704a1987b80fe21d8930ab5664e5639d3ca3f8b040b605376f7e8048140bad93dc1a0637a2ab8c63d1c797e73607c801e2d6edb2e11b683b9c593afd2dea861d3ad77471a252f10e151ec371c783f6278b6b186e33369dc12a5ff67d155242c8edd792cdd9c30fb42f2e1daf195830857e0ba5b5b39c360da27102562862e31672cb0a7d66281f155458d4cc93316e6c831c15f47853016bbc076fdb4c540d9d6a8a5de0d927e4ed5f8e0c9e6ab82998cc9cc193322311f63c190e1cbe0d8d8ececa1c56d5daa1143330148d4bf66e72d9848ececf7908a5171773364b0c2e06e9a304a71a0af9ec0bf77e2206e4deebe71a3fc75fafa08d2a544d55c8f40c4f0d9d562a972f17d9e5343b9bce7b095ec881c238ff0625a836bd3b5e5c7594a58ca4e32fa5b5ccbda3f692cf66106dab277106a4403f97fdf6d53181c513de6d483e97b484fd3dcc738b7f7ae0a0146a4a6ae35e66dd2a62bd94f9ffb765b0d4ea00a364303b9e557431ac417549b386633cc9bdb7bc14bb99052fd5d2c4a4e9ef0a6cd683db9e38c521cf4cb3986f9c62acf75506c013380f91c29ffca4437478003578956dd8a1d192af1dc9299a13c49c69a92cc48d3486fecb6b3afc7fc1e1cdf34b321f48f9d36646cc033cd9abb6c77d01efd8abfc1883d807b964919ba2810b0860493ba627cd9d630572e275e480858133c21e03e85ef7691b859c0501df807073ad31c1e33531564bb8c4889db1e7c8a44167d49da73fa73a9fe522f785ac9419f62fede3fe6f86843d8fb0ec115e7cd1e0f320119cd14c99fa6e2a121dbf6f02d5127d11b9ebef8ea3a675b768ea5152431a3d1722c52ef90fa6dd59a7483489a4b14aa8b12fafef235174d59c342c8175e96d9e6296dce76e4ecbac807be0ec05811fe4e0d742a0767d31f0a72c3a79b02425bd01e46c837a70b50ea1383917ad6b04b30bcf35d687658021a3f761bbb5864a665fee6491618baeb9829af60fb9f7ef529f06f566c5066f213d82f56714501f9b9ba2cff144649925b9ef1621ecca20bcb46c4842bc84ef8a3e2e99646b69e8951813b1e20510788dfffb2e6e025353b066939bbbd9d18a332048eeac69dd264ea168ae5ed113a58a0a69687e0355811389e8880ac5ade8a425e38f09bbbb63a9abb9a93c97ba3ce21692e6f32c03f7ef85baf303ab816ba84180ca6a765c61b4f754c9e51ec96b0edaf3ed6dd08411331a903bf6cede5a8afe72072ba76e37bfddf960b290584cc0b00df77a4d3d93c13f654e3d4d4da8ccb68860a049865609dcd9cffd5a972c2aa9d1c5830f3bb34cf4c1b931c4023a9ced0b5486e943611e16b25ddd0115eb64553dfced14bbbdfa7223b8ee9b2bf919744c86fe1855a39bc7c4cb232f8345eca5becb80f0c10e8e1f35bf528d96626ca2ca5434c8d02326070a484abc96477fb5377e6df531d90a41606f961ebd15276dbc9218ab184a56abbd4b2350b5d843d42cdf970f65d1e5a3ae63da651c43c2335dbf27c1a17a99ab0393ca5a2371a6918aa000df3ef03f7a2f832af8caefff22b6db85f6d1a9056f90cad7f9a8640e4fd8f3bdaa596d3c60f333cfbd8f05f955b7a9fac512ac677068cb0cabcaa1e682b06e2da396455908f0a790ba3d6741d1a5b9c87c7c3acbe01abddc9320cfd2741343265a5ac1d515dd249aac03207c816f05ba8ab8078b95c805c5546eca3aded0433f92b9d6c8f8bd946a2a092b53340c4324c392286a955b78e6498a7ac6af16cf77c9c5df9ff87010a51073be7f5778ba86bb77b123bbd1479e71e12f96ef527e8e5db4e9c2b1c472a6aea691925f128f963b5dd51c6a1011808b4918e6b75c6b8848faa70f17d84cb66355dd14862f05e30b85b9eb4179ad37dcbd7bda6ec72ebfbda7cd0f821ad0857306601b44ff6abfed58bb8585ee7fa7b959268f7d5ef8e60f9408f167b78db0bd7fe9170a76ab90a3934d5aa13fe606225255ffdf0e16d130a2afbb82ae8b57ae744d48c5c5fb548172b659488a2fb9a25d797afd61964cd90710ad0c328a95a50e63943d802771546ab4f8133939e648fe300ae469acd54cf2d69017bcf01fd3450b5602e4b648a2296ec618a53ce0ce91ca80b3c15f0d09dbf7f02edc6164eaf4be429a2e7e1675a4f34be49419c46072cc5642986e45d3ebb0f3176e7c5c61d4e23016e6498ab4ba744559d3806dd2c5a9b7b4e105e9fd7df2f05d5377eea8b80b1ebc36348fbe54f92a3111d928fc37269effbd9f230da597e70f9e988f3985adf94471ed8aa3460d13d309567ddd4dde87a81e00a237fa7c8458661c85309a1850f50e0f1413ea6e586543e1399f78c44e6c5d6cd45409ddaab34b91c360bc777b226112db858c2b874aadee60365de8b227ac5763cce4e610ad171706ebeceb2cb31655ff0d365f36de05b4f9486afbd7497718908cb934e693401b113e17b7b3594f4158d7da95ca980138ea06c91183ec990b775879a1115906d177fadec7c01a511ce73dd4f680f740b9dce2805a50dc44bf351e1e1631045a2e740b6c456f3a495abcc7017447f0cf0d3307ef4efd3f52f2c04374f7d9b79d3834b1f13a6293a352dc683d9b5e51631df2e7f3032a3f0df3f72e308300da8e89d1215d9cbee3e740472fded720331f557418d1ed493b06dcad14ce16fd64de5f15a6bd3a4bf65af978ce629ccd6ec3d8bd926dc9e7c4cb804ca4390d81371c806cbb4c2995ea99d7b3d0b33bf47a918c159ba7107382f7512bbd2810d868730a10684c5d1f974cfc5c5727ccd25ada405f8894ec0ba59c816bcf1bb8472d6ce60ad3f6e2261312c9b97ee6f0c479955cdd323db78f256dd5f635be711b1ddd1cb16dcfb39a65b1584c5da28a46a76b37ada9445562b9ed03f5d0789b9173aa79bf1d846f84f0e83ec40d8f707b62e80f4a06d65707ed2f722441e0913ae53f46b6d602c35ad3a8242c6d601cdc00c3b971039b6e8d39e5c7cfe4942bb67297ed23842cbc4ba42813fa347e582854e3d03c75736017859cc976243e712baca0bae389a95360a47686c1d4e9cec283c8dc35e7f20ad59efae8abbe42e30127c47c84d2424f4bc0a7c8f23ac1dfa2d48906fe3d14c0e1cf6033befd9389fb76814f2753bc027ece06942b291c28282c630843ed170ee01bef24cc2958b03364d07a1d5aa8bffb11ed9baf6899975196c10d32b7b0d24af135ba2373334946c0aa13bf8c5cdfeb1d18bc9d5726b3479ad4e23da32b674e9d73c5cd3cd35204b6ffea1389685b0fe830c2196713b2de39c020ffff2734c24c59090642bf79a06621018b44b7c46a1b7a89193bdd01bdc8e1d27082a0451d8d25f75a96ca435ff2d860462f6fd01b8c328aaea9dcc1d5aba67d4fd70fe164518ad954d63d3897d91acc9021f8fefb4bdea79f656a04b9075ff5091b44bc9ed4581ddfeb8d1d1796f681371cd21517be6754635f89df70d2ebc8915d0fc2ea9988f701c78cdbfceaaa0146d95836136a6f4f7029f8e22ed34add60d63189e80cdeb0851b82d1362936ff0e2b3ff094d12a4fc9f6aef90f1e060586e4eab067bbba14c9983f9d6176a1ecb61a860de17715fa97b80de7f2e3dfbbd313355ee3b2634dad9c327aa1a2089bb825893b47bda824c16fdbca24e97c40fceae1064cbd6e08d2cf80db578abaabbaf0d36c182631e214fc0b8fb9aeae43db1006f337af1ded1234124399c488e494714c431993d90e44401bb5a94bc5dea21b9698a71d534349903736fdd8df1a628b863006842488ebb113a6ef92374162388ea07ce456d13b09f676979be13674513bf06e4566684bed1c065afaefd69a49ff5032a7e81ad2ce6767d37dc8dfc196aca8659ab96a36e50d15849d26e9de8ba9fb6d07b0f84989777ed1c7704b382e8e1d8182762e31e2e36b0031f250a2f11f7905f252355ea38ece0b29a7c80cc6ac73130e444d136517e27b07f04d42572fa9e8363a754cf935a9be92e8d0d3256ff7f25da451885ed2f9c8f6ac41a9708f2e2b3784c6ac5087fdb55a445d3a5d98b82880565239eedf9862abe9a8142f9d6ff7b83b314197d26caffc2e801553486d90e8bf4817c4ffcd1f3d7e6706a931dbfaadd12a9766b0f11130db9ff49fd667ca2f386c3bcd0d73f055ce89b7f3454cf04273315033647a348782e4e273d9e12298382271a5d5bd6d8d725d68a5a5f9e8fa1b8ad6a633b8fa750b05ba6bcd7d526d163baee9d0227176664a415489ac39b7157a3f9d1c362888ef1cfee3ec1a50c59c059999218e13f6444bc2d8f664bfd40f13b0297a83f642b478c84d02ff2ea43062c50ac7ce796bdab2d207b28d33ae3590f9689fcf40252f1baf2e24e84ff5be34543d1b9d1774e5305b393910bb24c6c3ce6e20096d5ad74815520271c1ada8f4f69fee244c49e0c149ca5a4ca787e67f1f787e7a6d81abb9248f81792eda3246df0c85f4a929b78f6d02e09915f4bcf62c8e284ef28cb2c4451318627c75f1b72f846d5a8a117063cb7e670cf69bcd05a5817e291ac4d14383a6a554f31433d635f1293b8c2f97fbe5d093a0a8ffded5821899475b97073f293833082fe8b79c7a7d2f13c328cc8f8ba91a6ed8cbc4f671adeff83ec7d18275d31bdbd3509bb9064f909f14f8773580074c5e7402f53c1e5d306764b39fe8f8628635adef8b4ff875a6ca59f794b62b5a9b25a31515e4c2c2b0dd51c32cea256788598c76b6d87903864c2da7a8e3ff9668bcd0d7056a9d9f7ecb3a9310d70b035277c26b39ad8e229caaea4f0f0ba92fc9c6e4118a2f3399472292b53fda402bb650726c0118cca5cf6ffa3a50574bdee1dc8a964386e40a33e60f48ea856d2d69cfec038b495a5743f6a149180abe6187d587ff9a53b2ce7192b254ec4231b9eb9b7f8294e717206f4cc504699151dfff5bbe70ee3a1dd378f94cd92969878687e5cddc8aa2a5c6192908d208fd9cc44eda8eeac0c8650c269c2d45896d6dad51d2d3fa6ebae1f7f8d2ab81db09f5ea107aab82f7db8ed6cec06f0ccb3c461a451ee1dc24046cefd4d8c8358a84816413fc6d92498a2a48ade6748614c89449dee995254cdc410984dfc223a357edbd7dd298e9086cdcbbd09f48a3f0d9bc2c8bb0a18d5f7d376d3d90f1a6ac0f00352e67337eade017f996f012322e5df70cdb36b319caddf68f71bbbe6a205bb29ff6377b001779596bee12c71534b1976b59fb73b911bc2887c9becdad414bec345e1ce5e8b40e13df22df5fefcf175fece70ed95a36ddc9e5b7c0853dbc7deb23a585374284816ea2e9b61b378e73888c9b4b0ed8eb27b86e89f2281c8e342c03eb052ce38a097f19eefb5540271f8076d76aa73e89ad4bd28686a76334ac65448be7365a5b43b5e8feca0dd177bb81c297f0fbd3e50f5369721728db1c831953f6d02c7e03b57391a35307a00e914f303fa6ebb3ac7d12b2f7350f712c1ab640d583372a893cf2460ed5af3998be8f5872c4672b487f7bbdcc143e5a8d2c2e675b57e520d8ccb6897e98d63204b4c9c52b8def57b0aa14e88f7ed1c05b54f3360c70bd5cd0483c534f8a2c2bce9bfb1d5339d5735c2475bd16bd0624587959e524f2042bbbf532c7775535243c58e28a91b3a4a0b390f09b7824375ce30c62ffec1d144b16173877c7fd1d73ba4a7e474ce989388809f8588661b05457e555d7b6944608533c505c0827706ece66867598f69e8596dfbf8b901a5271a12007187f097dd77def8448d8d87936aa30a40f25728f69eda0c06c8982f50618e3fed623ceea16d654c4659781256e5ff2d1fc3b88acd9148fa75cd066f3732cfcce7baa82c4d9cdb04727d9e6cecd97e263e40a9e65627b289fccc1881c010a5aed2e97c33bd70943e7a4e2082439849ffd04173e72310c980d8a2c9da570e5e930ec68164befcdedcf9ede836c47ec80c8bc0ad2959b9364d0a881ee595845d3a4485224785f99f752f3d772b4eed02418fca589f7cacfda9092fba7b62eecba0b16036191eedec4d0ed20b359dae7b7c0474ad57a9861093b2eaefb492e08c86499cd38e89100d6b5c0542423d56fad93ae03b1571adda2c106632204e7f9881e3b026d8d8355492a1ead4061270a293c226e3b842b9707035cad6a85341f05dd995e783dd300e9d7fa859bb5840a49c4496fc0beca0fc832466503d10141b4f4f0c433f62d7fc425f85bdb5956b151abc0914d018dd3d19a7f2e18fa618b9e625caa084ccafa83b7add34394c51ef25563bb4451dee8760ad89f07cf703772c60fd71589b8daaffdfa82c83d1cc427c9a07fa83f1421affde71f556a3fb33ce3e736e0f99205f8eb7f43426c698c99707ed98d67b396628c7bdd857a98e0c7556d69a51cdfdff8fbb7198fca4a7a84bec810b74f889e7db6222945ba17dabb2ebbfad9d835256f9df8501f136fc4f7202ed99dc4004bd2d143a0b217eadaacbec624847c9b199efbb5b14b57ef575e65b077c6f865ffdf54d5acc706b154fbf7954c0cdd8cc6aed48212806a3f6dc1cab3f43246dea7ee4dc3c7ef4f5be02d133179c5a5dfacd511558c8d376845f32db228cf713680b3bccde1e9b743fc206ae7c702e6fac41fa028a5bba2091b67417921b1298952f417e8c9feebb1dd4a90a82100104415f902114c81a8eb010a49651c8e5c2ab9153425bcc25e39c23afed82b9f9571bdde02e381fa0f78b96997e37ee3beabe40df3b40413b83d082fc8d7d2875941fdf206b7c8a9888e416c60dad6b68b84ad8d945e8577b7bbe533d262de533818ee80c0a3133ee63e6355d45f2001a1e2fd5f9c6bde70f30d5dce3bc791ca3b4e710b8cb4d26374eaca335d4ee8060e3fd452cab14e18c05489c6260c645402ba0ae3f2e6da3162e9e17020d4c59120df49a2f705587bf01dd8075f8ecff5a2b03cd371a401a4b7a97fe104f1ff8f28a0f1792893929a988751e9e443f332a1c1f9dd30bfd6b5a8e9b016192bb09462c240305b5407e4248ea384aef6de65de5c81c9e2c766e3332e562f114c5313843c2cb221728a8f87f581b20e9af40e4299000b44873083ad54bd0705f89617e737b6cbfdafb66c102069598fde3becf930042035f246a0e32073265a9121b3434625201a03f2dd3cd3d40d4fb9ef6740610f61c111ab63f81c3cd0b100baa07a876933b6a39c86ee7f706eccd9839879b159e326383c3709fdb0d9a974c4c05195ade229ddc517ccf7efeecebfc8fdd7c2f1fd2f8f00123d8ae72a888c7a437a059dc89099994e81a49b9342ba65f71fda496f587bde6f9a3882de03059acba864798f05c699ad5faa05247d9a1a718290cf3339736fc9e51dc31eb6fe7eebdf9643e378ad8f7b819fa6622a93d2a8fc9fefba09ee71a1e8997f0bbd5471b2245c21f7f27338de870539a40ab134eb472df5da8d5f7b969247a9a8ba2510202a72444dc3f4768a20bed0461176f11085c9af733633d6c9ca748ac0318ab35b45a6dce9b564b3408d15e864c139692fb5e8741316d881d3b7a3009c5d4e614068d6ed009b91559c094cbeb981202d12219b74941a66fd0b6e3d5dea241fc4b42a9a603e47af9aaa8191751860b007a8cb9fb1641a1b85b58b2eb12bf17bc03da178f0192359b5b09e3f67262d4a138239ec9bf31ea13bdf71f12b74a3a35ce423975eac0c1caa27ea2b07333b63f938a97c4de2c3d92bb96f242ff8c8dbb5b2b9f0e97a9c92f35f70c3ab0c2e68f79aca3bd042ef48731b1f03a7d4538c7e9a5435c01db2c8b1b31d9be433b47e5d22b4d88252d343f72f549cda8e63198b5ac3381cc14f79846bd5bd4470e39e7b67f4b107c3324609250378d4890ac1d9f1db4effbd7eeace7166c6efd41433b8d0084c8613daca34389d3f22203354b81d39392728029638552949ccf807421c6768faa037f3d607d7e51c448daddca2bd67a5518a703ec376b988addc92570a9fb8b3f1cde1a0a16611e0108537776689dc6bea9ef0e8525bec265da62fc03dcce51a804a007f8173285412d60426e75c11fac47d843cd167e4605e96124c2eb30146bc8ac3ffb3f15243a32272a987097c67713990f185293cabb85bab8e32a6aeb0b3f0e7a3b4b638c5d8e41b8b11995f4af91ba8efa59a4b87f647ac132e5635ee5a5a199775f3d76f6b9165bd4e9e59a89736569d174dc4fac68ed7de1e1dc15b1256cb945d4dc5a5a6c7142fe26734087227dea0f3b700c925a9a59b07c7b6cf7ab51f8c0781e7234f80d8ae8ef60e40cb7accc3a4dc5e72b29e8632a67ba129f07d751f0524d05d6727535ff86b4b7753a999a17a68076ceffdc928b48b403a25862a812d90e18a418bfd826c5e4ba56e51136793174593b0ffa5b267f2591ba6b5c5382f574774dd9caf0587d981d6e18c6bc715b5e28e82c13cfd5624bbc5ac23d97637eb56a2ca522c0821c9401ec56b1a2ad68ebee74ab27121a552424b8ff156079298ec267b88b65ba55e5ab67e898d82561b487d990c9af4275ffbd0cbcbe9f02942b8c12b204f7c0d09dc2849beb4837486ca755bd8816d1fd3c5d19018c7f4bc7e1552ecfdb156f83e4012c16bb809c348c94b7b33574296d7bb3f6882c15b77b5aa5eae13878434fc1a0a9480a124e23c85b2cd4b1f359299db1fedfd8785fd9b7f6508dc0254402c71d9a4794a723c1e4bac75715754bdf1124debc55fa0c52c5ddf0522a48a42836661f6ffbb85c2b0e89a6840dcb8b8100ab1d3c127b63d2125e6bdaa5dec69b5529febf82f1f677f1822ffe5035d1252619d1c6fd337235ba48c719afda4fb6a68445b4649049ddfb6c2ed160d4d7c1f4c88674b922220d74e76d8f2f39c2cff9b7187aec38e3e290915150378035c939598531eb51263fa7793423bd9ded30862255986794a54cbf46775e09064d48d2244e25f659b5da55ed17e6c5f5b8f2f02e8a33247356981819be364eead272aed39bfdcbe34ed9862d8fa3551a7778caaf6c11122a0ebca129beb273ecefebc1d6feebf2b616710d477298fcc9fcacf1fee5fa60d5ad22f65a836a6dea8c0b1e15ab82dad81722e035b1046ce09d656253fddf0ede1c3a60cbd2b7dbd4ab23d4a3590b2b7221994aa985f6a04cff69209396c9afe527445569eaef337ff6c604d0f1958518b0bcf9ca5a69200dd99ef3507ec3c067ab7ba6f52b048a6f2e229dbcb1dc0075ec41baa01d67f68ab00fbf3baed795b7a3ec5e977e3ef02dcbe4804c495de272690dd7d87bdb075c3580dfec85b8ca48a77209becdf50d3c899a8d352311cf5d4bd7b568553b1c5fe266183e4ebafbcbf65f6f228cf55f07fee72fe7caad5d472ca51bee565af1ec5170ea8aa184e4a88c9d32b1790cb812b989bdaa746dcbcd356c89eb39d970551784b2352573ee111ece3458e8ebd8ac2d724954b594073d8914bf1b4b08fa1302923ee5d1b45e986acd923b2d085063567f1af9ede5149025d263c1cd308ef2da86ba2eb43db8e9883262d7a12e0b59f699e3b43cfb34a59f1197e370dc19a1eb724aa333650112f6b868ca81dd7c93454074f1004bfc54b25c92cc1015b2a11d8cc5e97b1ef63b4bd85fc3d1b51648169779b32a50d8591bc3805f8813032bc4291634ea8a60dad299f848b546fc1957a4a1fa98be9971bf7eef3c91c7c88ecf7f1631df7834ad8e0dc5428faaa0f66f974cfef50de6d0714691b37c329dade578d7fbe4556af0e3f3d36ffb52fa42c0f449939451a63a57c1730cfe8ee5574a96d6d2c5560045000eacf954625a8789935b8b2a6e080e2bb6b8c856fef5416bf11ca88f432bd7152d969343da852980deca0473f85a25f773f0a9699ee5f41860b478c323800a7973bf1dec7f8fa58009b2f3f6f93eba9f82bc0b577c18163ca6a13c0cbe99ce799c98bf556c283d7c234e2078aa3da9cd4a4e5d52ac4842b71733a827555882538e119987e52db168d1960e32e9f5fe86c4b995aa8a970fbabf992b958d1dbadc818be432309091edf3af19dd5d847c1aa48eede46754b846729a6e0cb103755f6d51168b93ecdfd7b4c6b5f307db2a9e20aa27d464508775008c771bddb28889a1940e1e9ec9b6bd341d00738af8299fd0c05598d37c4b1c1ed3b7e1c27def11518a613102ebe1488e638116581fa160c461a87d3adee1e1f41fd10b3654d6520bfa4e4dfd2e23137578279f4f0fa95becb54b04fd80f44a8a5b48cca1c4f6b1ab371a31e791b0e76d87942c46b33d735989561ea64af952d9ac970b2648bc3d2c2539148dbf1610038ac6fbc750d4d020d017a3bc382b43541c71ae5b773a8ce224c3c4db289c32af1c7bed93d9447c70487dd733ef2fd38d02ea808a1421bf10845f59c6f03075ac2d454022edc9e781024ecfe48fe16c6e9558cd376800ba8b1c831981ceeb61a656f251bdb98978d860b85736724272b57c78a8337b55150c781131476fda03d373f761a927cbf631d459b6b3548a397f631adc7f2976eef2bfb4e301ba9f9e751a58a3b956e85c3a05aaf0396bd75ee74fa788a0103e83e385375e4380d0d44f52c561a9870bd98295c9a7dec39b13c91e745a3f572babdfdf59c4da04bc5ec69d5409f2a6f27165e22cb8c9097a04fdcaed884da0ed9e8ac3dcb039bbbc03f4fbb4606b2104fb559693c988e1bf24fea0f06578e46d4b32a2b5599f050a449c33e94cb69e274a3f33c346bb37421073454aea7004de7abba5e660c65ba27120c939371388be2ec15f19fd72b89f5157bb98f2e3acfe8ce654bdc56b907235f370e99a194757408d33223ae30bdfc2afa789aa49943539170eaee69e47cc2ebb90a6fe765517bbe94dcf47ec521bfdede31151303a8a51cc29880c6c9a985b9ccf5d05c23824c28b471143fa0e211c398eeab6c9eefe33762b4bcb226004326a858686f9675792ac2fbd6fb87454b10814da4fd4b569986c3e8f583cd6a5a4f7147dc2ea170f9db231811af64a1b1b7017453153be255b71e9fdd965d5c1253f411eef0e4f86c8b4372ab0aaec687e54efa2d1a65c35693b0342e43eb31181832f6f231f50e2b5d031d5b1a1b7c9c1d75d200b9d29c696eac46c45bc8fa749ec1f2f4f6492ffcac3b10052268666c36b721612922e0da6056e13b09d132e50ff1c9a3eb67462728864bdca0ba7081bd98fd7af8ed79c9d4cb74a6fa6dea61cec6762ecbf726a45821323eab1f32bfbb6637cdd12a54646ce87383ca9a61b6f6a43c6ec49522e2156948834a4f09762e126e83af245673dad3013372af99b14ea776ee0a259c33cd342236dad1fb745826bffd110560f8058a9cc94fbb9109e700be773b00208ee9827f146623c888775ff456171d2d877c019e2e19b13c15a51487b80fb035011d69e35a1c1a3e4758b9c922b55bb41c5955ee9c90426ae663bfa291c1ea157882673adc96ce5da8e338ac7ace25e459f25e70f5c7f9c0fe598172d12f236908502186db9fb420ff76f432dd6265c4db71099fa2ba56e0765ee0a6dc93f105b05058daeab7ddb0b7be92de15ef464e5e745723aff0a7de252cfde192c9697ef238de5a1e1ce20b2506b2813b2ec17702f3df40dfa23074ddefc70b78fb78a24740cb3e39ee9e91482e5b3992d321174e361f0cd44f39b38496b184511f697b4d38cb20c79df00a0de53526212297c8143e2a4f69617fc7ba6b5e93c4136462db41525c0c9b69d667e81eb1411c5cbecaabf7d8752e1233d106a6cdcec77ab5c0820901139f6a167a13b45774bc5f2deebfc68c203da0afe414cb5623eefae805f049e5d85a2ccc37e0c423f128fcaf17e81dabb50c465074fa31113336635bda9454e14cfc4f48ffca6a4b5efeebe831008475fe6266e11786822eb2a7d74bd8a751635fb0e425149909b49239d457c002aa81c21f511686f272538f6dd56625430a9314d4449905b8a2f05aaa89709dfb5d12afaa4a221307ea8a0261b9c4b58ef4b2c53ec04bd37a35a8857e9b7f7a595fb9df6c7853b2431665082dfae2fca6a348f1cb588e8ed03228dc4106e5ba1f483ee37e42f6b05459b5ea054da8510f4cd4b83d1e95c84b4ddb5426ecd3f7d8381c09238666ceb46485a548800f071c59669c30e5737431331c99e8be84a97e18edd879f6c4f2ceadeebcb8f5414c47ad3936743a24e7947558f8549f87905f8b90b79653b9469c0a09c77221a3da1c743c6572af033d513fe923d40c5a2e8cb7ca109f06e278ff76bfd96759f203505e55722e27c384f15e28ffcfebd83a7a565e9b0a4fed9f3fa7491758e098faaa9eef176aaf2fd5d61e08d5de54eb8a88cbba48850c43df417fbe7b44dbcc6d0b51ae34ed1bb1da2ca00faa69545e547b36c402c16381f74d70044db2af8146935d6f22ed86d611071e41e6f53a2b4b2c2c667a8a968ea6cd68e89da1f4e947432cc13865ee0702b7c5b8a0e887e6eae31118bbf8d06e227a3bd9ccc99f32dc5542fdc5100cfbeff9bd54a12c55265a8c6c741731fdefed037881abdf956b054093c47a49e8f3b07fee2f9a98c1e31e22efbae89b64ee69202d9b630f994ddfe7ef000602e87731b734c155410108ab356bc46370b336dd6a64957d1f957d4b267b6ce4cba096e108680ea570fc12d87846bbfb3962b4fa63374b6e5dc3b52633464b35ca8ab4bd80e5a7b63fe5c8cc5509b06785dcd69707c123f8946b30f08a49c366df331bfb3094d451e6e39f3b8ef868591632e02dd7f782a1989588ac7535a7cb0698db15f952792004080db3e55469cb65d41e49811239bd0dba30a2f07f800088a00393549fd1ac7ba5283ed670af5183ada8e48b1f4e725946c529f467695752914dbf3ee58affe2e45a0cdc887b42f434c9f97acaf9e205e227b0655d2ca0b6b1cd52fa4f1401b2bce8db52cf4b81c0dc52bf6c9349958d83bf292db4baeebbc445a8f4375116dde76c533e78344e6a78c1cf3ba62317ab1b229069774797a2562d3e6479a764d41f6b966ab92557b91857ce5a962383f8422405ee3963ccb7b27c881a9f2a61f6df021de4be2c3bb27340742b342c85053a2d3be243ec01c0c02c4dc886f8f3b9f476ca721315ed3f2da7728582681ef8b9a7793","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
