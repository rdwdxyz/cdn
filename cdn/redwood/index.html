<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3372143ca16f86ee0f2f5c79b48fecfbf6a509a04b8e5551dfb7acb77a007c31b988319a603467742eaf3eaf3a4fa6f1ef77111738bac0fdf369d1a1c6ebd5048a45e6b7aa182f00b90c32527dd07403e7841d089830d1902d19e7125b23d3d567a78d852ef70c5e0fd0d01303a702ac328998415906e5d0201ee61c3d79e0f80c281894fc41359af6d441870d2f037511d46e96efdfebb3c436b22574920bd15db31986115b59f4f8e614bd990e4f3a645cf1b4ff9229b44d9cb1afb39d3c71de9a28dc13d7c2cbd2739977a34f45cf88f564c372bbd05a6ac8379c32a0d4860190e26f3822bfebbb8f3a15288b74b0a36da7b81c7d031bc5c50a963dcde49321c47b145c230727f188124ab9480285aa1a44c2f1b4c02c8f77c053b009b3d4c08c9ada6a21a5b96d0c34493d75b6bf51aa28071041b26993110244321726964f4be16a23bc16988c0ab1bbc90787973ccd86ddc4aaaac551040387ac36be0f1ed327fa7be3ce9f451916d12a9f7cdadf22445863a2bee6fc7c8c021fbfc20c9c8e83af98b3c032bfcf86f64a050d801f2c8b24c139df6f63125ac819a7b2d96d833a5ab594f119a3a6d16d53862dce1514ef91aebde123710c41806ea27a97bb8386602106d5a76fc9cf08b1fc4057f136fa8b22fa7fc4bc44078792ebbb6c24a1bb45fdeab4fe3263c45d31e0af66cce757405287d744b381b441c4e036a4d607656e0d90bfee45a2f5ccd5b88742e7544e5d488ff8651bbb0fcc8075e9a6bdc2a2d10d2ba59a2a08389bdc6a72fdf274603111d294e689490ef870afb486ff19d0c45c73e8c07f8fd2ebb5e01b678d8837cde57eca2ad9a322ac102961bf77709690ddda54c6873a4abf439881e0332802956d537980d5ff0365b8a34475916697ed852657405e2100cde20e009313fda4fa62ba215d7638f0a5c5a0ce2e9b41cd22168b92ec59456d48bd71991328eb1f54d52939c705151febe99eaa4e44dc701f638d8125661bad00ce5b8acd85b4b2041c08040631ca18b6bb3ecb1ebb51241424a3440f24b6d9bddf0d0390995106a5acda61431f048321648932e536b62bdba799e42489463ee86f224843d58089ef0160b0ef63e4b37bb81a149b559be1c0f31d0190d0aebdf5fdc948ca2c223be6f10be22804cdf219b29f8677ea46b0aea3c814bd2b769cfc571bc9445df416b877035f1a4edad7ea9ab4306d0cf186c020f372fbdcfc1cacc59ebcb3b02b4ba56184690a3f574d64d01cfa6fd40d7d90869fbc1ed713d42132674e3e204ca076a8cf71864e4cfbaa8a68c563dca2d357ff082281a166984656dab49de74faf894fcf0d9243940cf957de7898bd6e1c5c11bede27c5f8ecd8f1eb6575ce6c374c3cc9f58c3c38f4606989d7871a13ae831805d87daa772b392aee89ab983f13762cb8becf9f897a53dca0c327fca4d11373c52f03b1046fed4fbdb7ddc25d612c3683deeb7b41ef0718b31ec1c280907d0f5a748dd233e7d5e8b32fd96bc41c1b1a7153f69e0d2073b2178aa80097fd06619fc0f82328fa9b79b44df2a10bf7efd8f20cc14d9d23450452260d28655e9adc1306db79a4a89bace46a4f6b386e1783189c296d1d7341fca5af351236f029b99bded0e40eab14087c9c3be8907247dd24c19ecc7997cb858ca682057ea0b26b70bea4eb33d6aa22429ccf36a914eeefd17b7a8c3cb701b876c0cddad80e58ab9ce809c224f9d9f5997b14ad7ddd30f05e283832ecb68bf265da1701d2bc9571e4fa98b9b3ea3a9469806680619c60aa5871f4482ec8c1df365632b9cee00c0436ae043800dddbb69a21dd498f1ccd2b5f313a71c1197225fc7158ff9e4ce4d971bcd955bb5985e376193a6e13ef4bf52eff00657e084b600ebfe8990286898e9248c9dd3251e221d19a5eb344b6d8137bc484a51a832822e6c89d52d11ef3e787b83b5f34d83ae29e4e6b033cfaf866df3c051633370ffbbfe6f7d28b9ad4e730319bbf4ff712f650e928424dc024e91d6d59d23d8bdce1bbf8375ed368da63b6773b354dfcf9379889fe81601c23bab65cc0eccfd9a2c1fb73c772f33447812706904a2e49c0827fb81ab6245436bdb10a06a701a4e47b8e6f385993c891df308399f3b5b6fc4b1081a426238fcacab3f7f876e77fa175ff3073de2cf3631637e8720183802c44240174eb244194486ecfc8506685456cdb5d9942d87e87b48132617c978d11412e8da5944a9a9e7877970ef6cee0647d6e43aa15f58cad628cc73a2ee70f46dc6236f33d514e8ce735a8adf954509eea3a91eefc2d3dfd6e59e9d21323b26a0cbbb31c876bc0248d674ae0e043a85b7066f3ef757fa47ba905d5f875abb1c04c3796c04cc3f4c78c296c8c54ac97c299f29ba25ae14ded3d41502a68b141406d9bfaf42af467e9551356bd4a9e89738b5ae9c6683f5ea38b98a4bb43a512440c9da438385fa9b171a66d3cf94e20cf1236f34efd42aec576fb0d8317a75aab290d9807a8401658961442129889138a85b0d844831a2c121fbdc46a930260730db01a1ecea5c6286e5417c6c953667f069089e2765ac18f0f6ffd6b9c730cc16dbcaeeb621526eeb53bc69337f74dc2a4adf180e85bfbb52938468d03f22669bc721f83da0c9eb3d7ae0d2f100466faf69b70a2d6af0f5dc8414cab82209326a1e98097f8458bc5c3515c218341e9d22041bf6f11e0404ad3c013a74aeffefbe5ff351f19ee68a87daaa2257b58b9c615098d43b7f6c70fb3af317e86ba65bfd4d36b96a851ca6317ff09f341336c4960e5b573c37690b93cd1154a5f473a370beca760604f854a1e22e708059299dbb4c4e8ee28216c85102585d72cdb97145843772e4aa7d12f4fc715a6ade9f912fa105f5e2c7980de38f4c1462a791e6b8cca4c93f4fe5ce5624fee0244a0eb4d770621efc259ebc50b8bcc15302203c9f8f9f29f9e01ac199a6d0cbb642cc1eacc57a0d4702a94c656eacb40635cb5e551ed840cf7773d3588459bcb2aaafba534763a8b59b49b79d1567edd1067273b8ea4290bf5cea1e743bf49e13d4f9028d369905d7d5f0e9c7c7a79f8488d05611601e9c25175a3dd8d1995e2953351b95e40a78be637632b04d9d22d56740b1a8fb973f996165e7d9b1fc83481938f83e2171a11f1e05c52aa63717fa48ed58e354b30b5ac4a12502422761af044f2e2f1c5990e43b4b202a0c1d9d4b4c67bd2e286cb007caca42783e891e88cc8d626e8141c92b6aa3ba6a529eb6c3e2f124822c7d5fc05127a94c5ddf9a48cfdd71d2da56a933435bf1c4a7050e043fb0fdff359ec45279db8c0543bf76534e77d9fe1d23d3d9399ba2badee132e7d30a2cd520aaa7bbf56135034437b4a4770fb13ee60f2856ecc83c25858d4b10ce4941b73f9f503c5b072818e3db8c31f25bb20639b3720a42ab21c4fa760dc52cf2e710751216f79f575058c736b91c29eec08d226986e9c588471fc30eb667477c7dd985b03ada0620f1ddaf7fc8ecd89836e0c051bc44314a6e2aef57c8c9c971730e185753911a014a57415b69e58427869d6ec07ba902521d5362282bb627fdfc83adb8e19d0c0d697307c5d77fa2a060be10fca76d1a5e74b28893b904ccf2cb88cbe1416b151d5cc729f40a0534b1bcf52b37459d7f696b51f7309492ba2df7c5e103d9872277c3f15ad5cdf2634dc133b7987b8f4a7ea9142046488b31f432c3381d1f68c7b057df540e7b30abedd39022c48960dbdf5d12d6032afeff56c3456c217c10a97e49fb821da52636dd8f5624503d754e04cfc2d98500f493c2de1b484d8719cd895129d99549e0cb583985ba8f4fc8803b6d182745c6b5114a802fb0854e08679690c1f30127c125cbe505417ada9cdfd320168b1bb0a27ba878a987acd9d8310ca77682800ccd3eac84748ff85089ea6f8994628b68edb2e5767ca976cc309b53169ed8309ad8fc595b05ef02d8556f8a4457c29149104e8b416b5b8fb65e288d12d4aedfb23d6bf9dbfc89f2fdeb76250927d3e0dcedd9a1df91c287d208f2ae1b6e466881220f716e1420ed395bd49bc5bcc67e4b8753e30555ffffcf55ac348d3ad30734ba5fa996e1c00b39c4f32b66b7583f815ae1dbab44f9acd3713471bdf565cf51865e6a9651353ccb13e46869688ce49d890bc8e5a6b0814fc58b1008a17bfba62c8d16bc9f2faf004416498569bcb272939a280dc6d910174f6e039dcafb0b12dbe8cfff4dfadd4a475d3f0e547af7522ef236ee8ad5ed15c2ac4d393c569aee7231255f43b85e5e8e2b421235de1c47d734089bcff4995fc1941cf73381a71c81ec20106db5c9df07a7ddfe10b3010967142b55a012ab43818715f551eb697be251edce88788a311e2df3c68c4562a25b9147257dd6c3058f5d2db8b1694f9729cdbc75f8088d3df3b3150123c0190b345fc777a82a9d35cca0818e3d8ff7a1565347a89cf75f11a8d8e801decb05ea997074e4b64a12a1cd853ac8dfa5d17d8fa9116fe1c6ce11f2f5afc45ba372ff0e15e52a07921c69a4b63877505933cec43919172a91654ee2649526b8fe6cdf479ade7756a59d3058aa3f82b61de489baea98f95f8d218131a5defd925ee8823a8a9cefac6ce4369dae21e725a84cd95ef10caeb25da238aa2474305f0295132a0ea8d0753140b521c43aa1d8f5816c40e7fe89b006ad67715ea8c639d72c85ac6a64f495f05a1307bd78c91e5584813f359c7c5456a3bd2e248a5ac27ec5238e21077e21a93836c161b133071f86a542925422026b9771d0c9fb918d6b7ee7b3c412b08c43729ded5bce063cf830b3e49f8d893daa5a64aeec40e47f1bca82768fc9b11a2e8e2cbddbee233e99f0ae1b2a83e870aef1139eefff9e7005ff4f9302f72d97f6ca7069a4078b0168c2ed1accaf9ee26b2ea1f612d59730d102902b02918394abcdf14461ddae2fcb2c4e17b74fc2f3e867f6ee8687f12383877b5a595053e5963ad61cbc5ae2f4218a527412d10b07120c387a74109317231bf130db918997ef0d04db2a9778f09691cd1e29f20cd233383f6506dda217f0cd24a604f3803607a2d4e4defe1f806f2cc215a50b75ee0012b45632b72904a2a1137802f38d1b452e258b1a47780bede2a5135b04d1a5910fb3fff5ddf0ac5fb73bca79ccea47a0edbc396770977d6bd133c6b4677f17021dc596f454a3c5f26b53050bddcce885272e69fa0db2683307217bb8db72d457f240dda6452c83850fd7d942479a0739f5a5f2acb7049f36534e7085df2fb475d7bde5fe4472f1e9b02b42b3369660c9873634416a0307dabedbf3ee38f9ed694c59079d9b888e40b5a5e8d1d114aeea8aef1efc55ae2c7b26dcd382c5360f623f4e589adf82ec2d223df6573464259b14313aefc41c8dfbf0b9b265644a3c2e00097dfc071fe7f41ef8278c8f81543c703b1528b0d42cf4af7e48f00a1a0875db903d18f9e1a56c6f09fa5acf1b28ba254fe6ad36c32885a98499fdd42ab6798bc590815779cedce0740382f4eb8ce36fa1fb0769490eddc93243e2e304fdf85ac65dd6f20949e6e6cec5d85cdf5921f927e4c998f2021b495389fb2822cfd640b24a7d19e87c176bba12be3deb63c1c1a6e10cea5075f6a48a0ed321b1caf1fd4d44a050b5cc56cc83977c88b909571c484e3385f506f749c98c39753daf01d8417423316ce71ffdf53d33eae9903d38f6612f35ddb8187d76d6bcc8af4bc8e1250b3b3a3fa1af32ba8c5f66eb999a1829260052265c64a67ad8017b3cd3eb1d9b872aeb72f4e9f11023025aa5f82a0c5bb880173b7744ba87a10c6e751d716667bba3847ca49c945cd52842a35918f951cb1525dfbf3593a7d606ecd0ccdccc3ed650514f54e9589df8970a3a1406e8634fa4c010d6ed24aa068d2562c0ffe493862155c96c83a5dae238ea4f8f772fd623bca84470dda3b13363236f648f8857361259b9675bb1034f1824b5daba8c63841e74a0602bc4e95a04b03d7ab5feec6602b1ab212f90574d98e337fb1fe20920e15a31a025c5c14ef9cb6e812c43335d37485a1b358888dc2576e24d2b89a02dcfbcaf5cf7d278dd300b6528d8a584d73148e0b114c88b8295cbfd044a3156607c18b843c2af1930577bd773a95b0812585293f7f2d31ef650b8db8178f32cff885ed5426da97c830618b604022d471b1ccca6fc0c2dade3d3961deee800cdfa4f8e57c6681a52d20bd03aff9289258bfdcf06371fe9b918f5a9e5d281638fac392b23a6dd34114b59c15eafab0367cfcf267493d2ab6235643627276d51fb75eaae13a538281070886b7bf66f1e90964edee86425fcd3b349da6a445be815bbab284573a23a0caec58b60598af6c1c3163d9551b2831d2a4e609f3904cb40716da348df097089603119b8268b4dbc6c0d00db23cef32e0d765289484ea0bf7c70fc0dc4a84a1ac47816cfcdb89eaaa29919c17dadb2340bd14203c22b09f790b6458e86c5dfb12fe8f3b588d4afbaba16cd0cbd235b321887c561b199eb90a43c4830a1c4b5663aabf3fdf4956dc4f23e22835cedbec877f9f4c1d046a6c21e7e0cdd6ba18a9e426fbd3b14b940904856e4cf1b238258fe1911d9675447ec35a3b75660fbbadb087214ff1af37e7351a86c8a0da2a5377faa4d7f1ecce590e3049087fd93baba0d315063e9b47dea54d1a57d4ac0f4bef13baf4679f25032a7ff699700e51cf1860a5c88537c209b5413ae9a2505f44c30842daa111c352ffd70ec1bb2d93ace6dcaa7f22a6dc6c3fe3a8f5a3cc32f4445d602d4a90d684927043ed8b8aa94274b371df8acc9162c7495efd8581d564fd84c2ab037c549f9425def04d88ebf292db32573dd9b969278b7b6818e28dc840c06a9bd8bf8583c2541fe4c41c0afc42f745ac560ca263fe50344aed368f1c9276755df440234e9b0f44303d998a0fd61e5dca5e136e53cfde99058ce10f9f3273e64792ce0a13abd859708aa30321c1cc13f2c5119afa981dec18aea540792e21b502725d1f6e6956049419e143cb7a8f7447194275f4235f75eb0db5110fdb2dcc9ca5947ad4072e83dd7bf25a2fad0dd53bc3e1f492d2b1b069254b367814a1f2401498a7ed8083e37f2f3ca07152dedccf91678fc5415e5329fbe455223f8a6bde4bfa21e56609a6c16495d4d27a9080115cf98846e16fa673e28c16993ea9b56ad84c317a4c28d294e43aca28519f9efff4a78cdcfbbf1e0c14d181a2745e738aabdccd47a1b2e8b2e4a9c881199885f013a1b1f4727bd43827a289a83129e3c2caebb5081b76c6e38730d717eb721b97daa117ea63a40db89a5d0f0dd0d57dcaf49de1270aeef6ce47d37098369023a3448da9a402c251ba50b8d2f290ce3fcc1ebe0630e302a2c36283bd4978a8686f0a96c165c16fa7d12412caa826560fe17c1b4dbf1fdb1e678ab402f8f62914f8daed5b7526a9c4582caaf18d8f8d95b8fc394832721a156431fd2e70cdc77da33cbe7cc9dcd88c760ad5f4881d41b202d89f21b71a552e51ecf7bfdd11ccb3bc5919194aab2efd9fc03eb1332112b4126f821355beedfcd610453698353f82f49e774910737385066b6260af76b738b550f2ea296a57ba274bc094fe586bdc0ea1dd4184729b8b063b1c3b06be97ee44c3197613260bd522d1c467c1bc3532a15d1cb7b37e77541feb66230dfc9dc80a64a0b9586334315543f5d32d97a3135474c20015641e7c7e6e929fd3c18edb2ca21b6122e3393507ced3c4a70f84d7a0c0b1320a0b463f2f90967e0df419ae2c0f92a0f20f202fa14a6513035006d88edff9563f957d3a495fc01055b28c70fee58da2a81089a7230b3b4f9b0c12efc0c66f368c7e5106624765e3380f37b261d65d5387e44c595fb50a84655b94357bbf2c868807638a0bf2f7670cb1959daf2f4bde10fff095dd9a02d62d5555ccf66ff49d4e979e1f6a9f23ac316bb7dbb54feaf71932162e54588b39ddef7e507368272c6ae9f38aed47dd5d8c0b0f9087a50da6cecefe338d6469486fa5b8531633b635e62ac3979a0db2f9b6b9796a70cdfc7af7bca4b2a0d4b6406ac7e5a23d7afb333d6b4982e494dcb3bb5052228920bc4acfc102cf2fc7775ddbb3b8b9cf253534717ce0f69dad7caf7abbdeb61da1825196191d662c59cd1c9836d323f11d6fd71c38af7f31cfac32966a1db60fcd634985373afa35758966265ed559e9a0684d98987f0bfec92cf3e44f211532be59adc1e0606bb05f7cc83475e52a25905654f8303832f5efd11746bfaeafccfd92c0d84c501b616b405ee021e166b2d500885bbe9c4caceabfd9c702218baf54ffa1f17ad588be00324cb6dbe7d162c4e097b0b727ebe649d34a8e62101190aec84276f970ba7cc3f5c24ecad795a9bdf9bb1673483a774b5f9d37c17c1246754e7f4282d1d653830070ae5a1f01c9096a5c795441af6717fb6bcc43840120e5d1e05885f9ef959ef4f2ed674d92daec7c7322bed070394f59a0a67f3cf19a2296e80f2b26c7b7754a0f28f49c6304bc9a5a7afe24a505a0f25bec59d27994885e67604947dffbac59454f2c9b8a9681715151e9ed463281e0f7c0d0c787991f18c867532d1d61e69000bfe95a01a528a1fd0da5ac31b1cc3bbaeee69c1b1b7c4f2786bb41c92deeb768d0566e11c252a4b1f4ef21e27fbd44ccbc77fb786f5a7206b419d9b068f5b4a86484eba01056e515f8b5e74b7462d6b1faa276922359a4f248662bc8b8754c76c08ae9516f017faaa5d25cf13b94e14824b8fd188f899df86b24042bb72170a774c1834c5d1372485db6b559d649ef7087bf336cb58d4a6f981d6f83fcdf96feb423e8f7cc0bbf169da4ac850457b0cc44972e0b075e3c10b0c30ce080ea17f2288dda0bc70d980bf4967d520d3f2f56195815cc3ff284ff45f66aa0b34da274a546864bdb1fc428ead5cf8ffae2cea2a6a358705b815e0d605a426d5d62387ea3a9a3d842b0b044e6ad765510be0a298cadc1d66452df0e7dc93413e0fd97bc26b435e4e7f89dc4eb54ee65e95e0d1cb45755d61ae7c946ca65cc462dde2c621dfebbc35a5e12959be1ddff9051e138809e4ef4353088ad80c839a3a1d4d0df45966569ef40a1b685e64ff06d53186ce989dcc3ca7d6e0c9993c4eccd3865ae13db0041cea8db652b37d5a4d4bc4dbee88d1ba0b9fbb280b9050ccd8ba8f2b05c1a2e861fddc13f1cd5bfec6ddd0536303df181d0da909d6a23499dfc706a81a65307f703cfa092b517a711cec9601e524be2047227c6c0133e9fd518817d2188d7d05f7f02cfa7bbca72ac7347af7c22a76d20b705e7cea5d08df7d2122f737cfba0e7b061aaea6a1cc318010d9cf6e59fc528d9986add357fbf10f7974fe23e864371af12d2af7811a379ee1fd64ece57cca6374dc7dd7e79c7c275f325176d5a42eea526cc945fa1a4224290b332a73eae9ed2ee1536cec8d9c21178850cf9eb7e10bb8da87b06d9ff34d21a34fbc263ffa87f9f8aad1e865d04818bc2f575f60e90c63d22db5dba67868c25c64d077d8b6fbb61923fa36e1929a7cc2531dac78e32c703649ced6e50946675088118369e8af204d9c6f4f5428492d4ba9b242b5841571032e7af09b057d555bef976c02673878836304293c83f60bcfd98a74580eaf433b5825e481274a4d44222e19f39e2a5f7c884453435d994cb916b0fa53e36ed80ec44dc3788a7fdccca36a002f451d10b768dc56e70b4ec1f06e1c5cfed94e2beadac75ec653293225931ac353a95e96c867ee776e12b02b88206479c8b868a11a63a2bcfda08ac2c5dc5caf1113ceb985e985e3318cb1f7f5de1fefd2b8628430abd91faa6a3b5a6a24eb43f3fecd2c5944b6b77ef3ce8f2295e8d2f39ce1c20feee9e45fe089319a042a113d0720f964eda904f9749de32a74982d23b0c56f98293f5a0509a6ac28b77019eb6319dd6f9466997ba137025559a746bfce67ac174fad8125a6c8f7eb40a20776d553021ef31025960d358fac7e9da983cb6a57e2158ccc63fcbce8116faff95a865499691c129d5ab07ce564e70f8d314b05f34e91f6ba821826415d86dc5baacf6fcac11acdf424599911931d8feea449aca046f13b3c4e32efd83af96cc6d4fa65f07be6ffaa84866907458c9c5ccde24d213d00843fd9c95cfa0ac90ffd520f7678770270dab73b578ddb3559460cb14e68ecd90bd286215a44d2440f95ae2107876ec45defc147b7acef5877db3166e8952042c3f08d34c5322fd1c823b3c64a7238e826b1e93f94d031787c6ef5676567e6c8427b70f28498b3b093b958c03aa104921f811d025be4de0f3b284f5f696feebcf67671e48e7c6dfcd40834c7c2803b46ac36b1b70ac9472ef1ec138e688b98a5caaceeb931b4a5fc7e219ad5e90df089b65a32b93077da1a2851591f2afda3708d4c435a77d808600bff1655b8f08e551f81546a8c982d38afbd5a4ba1ac2e21fa00297db9219048f1c7e2d54c4f7001201958bb68dfc6ea049b5e1ce84a9b4848438ca9be09eb6ee07aef16e4ff6a0a600a7b0896c72c3b5a70d0c8f47fef00412eaf394ed7fff13f5ccadfb7b19bc357898a71497bdf443a6bb945a25b99331ea3c2ca91dfaa784d212f6a5f421bc48730f5cbd0a82598903f71317f0ec912d2f5667235ba4398c56e742db1a644b717b4bc9b0efbb1b4102735c478370a4af4209d39664a2cfba981d15923b0d21aedb21b602109c840fff7b060f3411fcf54b8ffff7907ca9993f00ef7deede1b2981f596d67149a9576b3c935eb9555742a4c73fb95136fd53b2c77edbba3122cdf20acdf872169d396480dada27596fe6f5b342b708bef7e8b8e3b0bf3def7322ebb8f1664911bf321c05202c180ff80b307c9243e212f45ba33b103b8792e6e754b78b0eb46f59121f91e4f7ab2ce2c9a8a43511176d499b7ef0f337f64d49d6711a59f57bc492786a48eea5307669857536134edf80f99731fa66dbf42ae3da923c31407bee8e4d54d66ddce2969e7abb5be7fe50b0a95830646c0566b0e79edb6e59fb4f6565d8d3d65b9a733c0c456228f6bcbd9531f0954d51bc8d55915dd02bd0f85ea2b6aeff48f7affaf846c84f9174d5fb419c189340dbfb7a04b97f99d9e1894cfa55ff0e7a372fd14b978d799ae4adbbf9a15377469b7240f3cb8593d206dddcf5694d99921024b8359a420934f7465aaaaf776f56a627b0e01b15e929008c6612a28d8561d9cc14aa3c8c1316f4d506ba051c0d1346eb07596b1bf14d6903d20addd14e7cd73b5fa80de446186ad5e485e4bcd2dc9d1985cd36905cc80413409f89a1db0dd28fe4b42987a9449eb407b003fbf3e1fd024a758736ab8eed2404f6dfda80fd58367883a949cd60e54e7eb52c30ae36126576d36b3390f4dd84e48c9675855580ad155363067b28035b6681e084a43674310e7253fbc2006dea7e98622daa374a24e0251cd10c59613ef205cd9a708bb1bcb9b507bdbd8e9793ee81cf23f6eb894bcbc0a00b268ffdb79b8df0122edb434aca6308f572d639b7e70527e2eca6481eeb49b6f663bccfa07b7956971914c2f1e00e9a0ea60ef84ea79146aeff64e5a11f60e110259ba9d3617eff7bcb4d0d5d420e670d26a5e7f523c1875d30a88f1439e95b6a8012e97d7f84bb53cb2dd5153059df58e32c0ead9fb3df109ed8135fd3835bc570f7befc08d7074db3fc00fd212f020f6619c88956d9015122d33eb5e75633f682b37ea81344cb29bc2355aa388bdf3bb523d7699a26e81a5df03713115cd0aeb03c4584e3b7d66928f0ab6bbec6e1551dadb58a38889043dc740d8120fc817a56fddf56c896cc3bfa140ede887b4a619b55fb58c7ebc81337d57c251f96343d0a42d0b67bd341c24e20291ea3b753a1905f655b1ab431526d5d57b3d70af175645994fc1562fb6aac8c90fb888b1aa3c9870b3897708629721b91cfb8f7b0e1ca7be2c353e6c1e7934c99ea880236372a76b9da21ff11059578d1876825096ccce53a3b95688ab4e27a8b239f9ac4cc7cfc0c34f24499ac2ea34b7727f6889187f65081af433128f16d2c033171e26ec730ca0a3f2f49743536a8bf25ad3480b2c840afc6f5813fe7f0fe2c670039246b47703ad96bddb0a57983ffe5e7bbba6fb2fe7c3c14598b29fd11049fd237cb56b72ee334ee2f9deb3e1f90f8714737a4d7260e3d0f7c89afaa6b9b10a1e971a897469553b0c6daccc910af0ff192098821d1533ff41dd935917eefe6af3c46cefb57381613ca60fcaad15745b52460cf84c7f5e82fc8b2dc43e6e266ff9725df4175576621d4967805ada3527d2525dd6080db036e90ab0ba0d02fe7113d515abdfce750f1fe478d549c7ace6fb73b67367a22118a53a6f6c5e291e7f404c4e12f15d50093c3711b8714d6115e299a08451fd8741f10593c2fe19ae5d4731a26c87895a818057a24c2a8f9abc043ff4c19661c8875a201e7bcf6d5c5231c23eb094c34e171a2a8e4b0827e53380ee86901bbf9e95bbb63e74a4a0947dadf15ff4689af112aec65db0a9b97f931a12b6f351fbb298acd1ea0df1d9ec26fcff5ee9ae6eb703d22c274742af55fd0ec297ade3d4ae882d221309de6c5c175af2bfe18c29ad7f895543a544fb06aeaa9fc3acccf7634fe1e891ddbc0218bfc8f02ff271c69f073c290f7b95e8c8fb1b923e10678ae039a488f4cf0652ff82e52f4dae4de26d6cd62f0c931d5d886da47648d62408c719e2c057567fb6c94d830b6f156e0cc33c7ea254be2a76da237297771d45e3e186cdf4bcebbc597bfe01df1297ffd34f99b86bcb48c85a3cf6612a481b251ccbcb9f4c491d1f07ba54fada15eafdf2a5b1385d604ce0d0d614f7f6a4a376a2ead14d9efd775f0008d7cf684273c28f9c8646225f135aafcb7d0d27ff00ce8350c23512e8515226b4283822abc9c882e785c7a4b262372f61a3c174802a8b42287ad843bad5849eaab490473ad14a475ecad46214d89f195f3f018f5131c1727148fdb99086d25b404667063c3bab772c37825ae2ad223a7def84e036781d3af3709d30b2ce7250cddba992571454427c158625db1475da80892a729eb2ce749aa61b944ca2d236d5c07562230381ec20ad8b502ce1b21c7fa74e244941160eae8d623a73e62950035dc6c9acf40b0dcca8ee290e051bfae393fa5fd873be35dd79ebc8d853ba1f736a3fbb6d947a6b486a2a5a807b1ddb80946d364e83f0c0d39bf4d900da0d280b66a8d7640498f5af10b332c493599c05ef5e7959b62c57954763b1d784840e990e2492fad3f63bcee1cec8fac2f04f55e279823624f58b3bf8f9daf3b1839a378a617fc5fe825f7f6ebc660e4e8a3b9efd5866f16cb79d145ab797d2740ae740ac7a633e24725808e1f086cb57c67c41db209e5ca57d592169e5dbe0321792cfe6d310baa819c8e554c4b98332f86f4bf4c93ab771754e55d740498cf819e821ce124ed0c964cf6b6cea568c1817e7a4fe606471ed4871805ffe7191757cb0c40a2ff84c2b87036a998daed484b510a2e78c92684464a66619c96342d3c6571697e3da8a17a827401a5f9ecabafaa34448e094377d674e5352bf05c56baf900f59c5a8f7c746df0ad4edd3b55b3ddbb7c0038d9d639f938a4562d3f69fdaa2c2dd322d2ea6eef6a08490636138187886668b0f93ea7df2966a5a60199abeae0eea7bbb6be61e95b180689eefba95f44bce02f3e04cb5934ca364338e886fb8889044eac3548286deaaa2fc9dd6f2ff87f54967bb8d98d39d9877f126c57d36135cf0038f97a1cd47e73cbe14355185b6d504576d0bf36d0301f0c05ef11c11bc75e326eedf1a1859b3d1108134932b86305a5b8be511be619e3fc7e5073a827b90ae393175c5d5300cf245ca5c31d173cbe767ee0b63c8306cfac4200616ad4e0c9c7be57379e287b393008e6a47537abd138970b8b984f50755380ced8cd7022da2ac92e3176740b4969e82711157dd75b3aff24e822853f9e94ce6eecf567975c090c24a074c77b67341b8a6b5ec3a6dd2a35579c0e903d614f217188cd0f084efb8c26bbbb54a32af7c2c7ad4fffa3788147aecd648a00eca112e62dd9569fef3af7bb909a486c5ff758e1be83656733d414ff0f4a10a82c36b1ade26e6fdc74a629d9e1fa50d3c92d97cf6712602dad05bccc775617353963621a60460bc436b7e80aca8ea63d594d588054d25f5a5e93f31eb2c22956fb1c3af1d4eb80e041a0f8f755ad8fe88dbb4857a08429e722be50e243b99ea822b78f6e438fbd7792967f98b4bb7094a8b952a6ae6730ec0d8ca8b5c545d245b5d4be014bb7d791550d9892db5022147d7b60659f8f014240ad68f2f62ce42648a35cb62dc0bd2854aa3d08d24d0f6cf81fb631be4e7db09bf1aadb9ac1b9c2847813524e20e068e92100d5a7bd54c8e8254c315c58de02e2ac362017b3bd225b6f5ffa6dd07f93f12fbf4a9bb91194711a1555211e485a912b2e21fec45b4bf2251bcd2261c8c405882b537a57faed662e078f46e0995ca6072341b260c2c249eacf5dac199f1de6b490b4773cd269851837be8e98d1fdfb7cbe124a8f98d28b283627f1f9c3596abc27096fb80b32606137e54b016a136fa35ba99df97177eabd0f8d8d9b9ef057478851f77bc74042b5e2048bfe10004bdd57d5c43e2afb9a491aebdf5f4fa3e04b7cb0d40a2dca79dd72fb27fc984b4830298614fbbe1ea1f45c87ea31b043287ffd4d0431bbebe5060d1eb579600c6dfee853fab4ba219592218acdd09b607b629e91797184dc29400983f08c5affe56f0908fa883083f5f761ea09db80d6c21ad90e992c91cc4ab8c5440fc9b928a19bb9c73b0d4846b11009178fb672ad808bbda890950110b52399ae0af6206001312a3f076577e243520e2f93686ce2de6ca4054e0ebaeda3625d45ab0e60bde1a1326db8ed6cd5fb263527268a1b738c176880543513e6f7cca9ebda8b1b0761ec26cc5217467adb06400d399d5b28b52ed55cbb6d996e79831c09b6090b4101fb2d8df6ccc81000ea9083b96d6e91c359f2af21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
