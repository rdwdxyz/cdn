<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb35cc0e816bbc463e02810eb6d02c02226114c87362b7cdd025244024ea2d4123b32c640ca7e7dfb6ee6d5c40936d5ae6fbfb7051a3ed07ebe6804d2e2e25cc653e21f0a46f70752614cc2a9ee7e93dab203b1237c8251ef8b6486b8e3ec82dfb2c22d385dab3dadfff4ef12f5504369d577897b57cc0936057f0b60e07725abcdab3ec984a26499a312711f5dbe315f0a297643b3f3dfe4aa03660b1e6954f802fb3fd38fc67f9fd7610ca3e52df1b6e9aedf0900c2359575dc50fbd83850e883869fa881fc11ca3daf8628fee86bcce6b05ecbd3b8845734957787d819aabe32b4d65e5d646ac43f07186d358cf4426bbecb0e92fd8f03379269ac7a6514e864c9a3c553dcbe2bb80a8013d19ffccdfb70294c5b32e9dc63576afd848d073ea53fe97a1438773895b74deeba76078fd9979bd22dfa2de42ef20464f23c68f1ea074c34cbfa90a76dad139b27d3d50b5aeb1bef53402ad73e6ae7f5b51ec41cf761103c05b2450d2b006c985980dc0f99d9042186ec4f3ecb02be25495bcbb5063e82785147700bde24f6a797d8d480980051c00b6ab2f0a58cd68db4adee94dc456dacdaa084e50d6c457b4c75dc20e314c4cf36b0817d29fe400d3e250eb39a363861dea51951b1783b07774e4aedf73223fe8dd98fe57f1e1c5ce64dbaf4601bd2ad013ff82c080b047a7e189ef431d82a86ac41715f8a8c20e24a77740133136df6fdb861e81d3eaa1e2b8f6d7a2a72d79c2aeb7271dc02aa325ab14c4954b044726f32bed1d02ff02884354bb5791458f1cf9801481e12d38c4bf58d984f9b47a92afaf518939fb76f822f7df2e57f67a12e70ede155b8d44a6a303d517b28db58bf0e8ff6f058508a8652e255a5faabaab194593ff0d6f5656c3cb33df1ff3feb3a95e12ad2932184de2b4852eadfd34bb1892075aa87505d7fd9806e0b7995156585e4f8e0cbb65dca6c609e12b3f404296d4d80290098b03648d17f46e630a6d705d472137afe79df1bd141ad7fdef9fe5b83f1c4084440f180371beca30e68f76311abcb76fe1bb194b9d47edfe8f22ac218700729e5eaea5e4431d53ef42ffd83ed44270f3b4c490965f235d2124f193cec086e4c4ba28604cd86f961a7fec586eb83d60cfbb9ffdde9d91be58b4c4070f2affe5b40b15e771640ff6a94163c5dac53179d9a2a9dd146fbf7207742d8909d7c490c7e3ad9354993405fae7a270706f5799703b624c28c145077d243d52702d30da9d24b75bf816e76b26e726d0864a3b8bb4aa135f776b9ebc448cbbaf7ec12242e3173110612fb14903d327970acfe577e02cf9eb00712e8228146c4fea6adf61b3595170a39a75733861d4374662b1ffe73709fec543b1136dda23ff42d59dd3c1875cbd9bdce07c78d42dc03c79d38e1800278cf2e9e6880cd332117e0b212d41d81e9770883fb9dcdf4fa4343097b3b00b4c8fb410c1996456102363c68f54ebbac8f96a7508e2967781ce1365c96ba0921d0b6a219e5967b7574245ebb54dfb43e1fcd739853f28262e2d6f9bebb7f670dcc3c9aad2defd7429ffc8b072778e46a3faee7ea4ea4a9fce1b6f9f634c0b71144386f838f409a3575e85d93b8d4a76574c1d4ecf1eeb253b7683a7500f14d605a9b60c3a1a3c127f6c22fbd87f79670e57f2dcabb8a7681c8ff996202867c9592e6265f5699f9a7af25580771daad808980fd722c4d13be3f5287c82dc2fb08010a344ff05f5734e45f66828bd8a78f539747509d238c3d9b25407c56043425288b7a461acd68565f0ad31e8214f41a9b6df1e0ef6e81a77fbe640f784b40e50b706c4282c9d8e3b815b5e9595763e7c890fcf962e2a789d14ec23455bef7fff9c578f78ba8401b2072412c262dddb3daf4d595db06d429c3746c2c1321fbeadb8c64086b41087f1bf5640969a714c25488b1c622ad8e80ed6782d470fd437ee43c604d6824e7a2505bb3ddbf6e97bed291fbe71afd7c8c1e6923d6cd78bdd8473de707643d88607a09bdc1481053d7f5e8ad76eb48b50d1f78d0dfe45c725a44e5679e8cac96812091fd5fece44afc2501e89481ed29fbd8f082dd2fbf4766c58760a88036bf174ade0d3a769925875c97879f8c9f35022d9ac94d7fe3a70313d075a0f6ebba30f24d7ac30a069791da6182d8e00b0117db022b2dcbe7f2dab58ab01638f0222562696bc98edc07d6ede541537a14851215df6d00ae5bfe2691b392cf1df23d0940ec715238430737ffb541f6e87d6f2c92885a86067b7ee7e9ebf9adfcae87f7f847a86984439edb8fbec00f7869dcf5a02e5213be1216639ddaff14f5a412b71265f3384e4b6301649b2c1ecd2a49fad9280e3c4c184cd326c3fe2ebe0c115fa7d7c70e813c2168a52068a60415c7164bb4968490ed8452574e5c6c0339335f8bb269456db1b072de96cce0d1b7be2c9d2b09445665bfd67e0580d6bbefc9330cb27d9de46cc5a0b9fdb5172b3a4e3e1424d030de63278e2a0d7b496f1605c00239b815c44793cd345dc1869bcd2c93bf3d49a735ab8df6b602c15edeb73eb1cc4e827e87e7286e86a9fd658befd96831d515b9d749966feca30cc887ece1e1b59b8cc9b177bad219a04ceebe8f909148fea51a2bc089f6920ec9dd8494b51ec239e52255d0818269a67ece1531d1167e32f4affde45bde86e6b3725575b02b0966cf8bf99333f03398707d3ba69a3e40790d8607d3f1eb464ee1d7c872e4f8316aa82a256f3411746e6b6a8123e2231e7aaf501267dfb6cef5d5cc5f85f380c9a9a401a9602ce434ff297a90e1136953688adb2969c1ea84fd0c39fa93106b7f6ae345abba1269ac37d0043ef3cb28b99b0aa1784322d7be4f262aee7e9df5328bb1211020416aeb833b8d4754c13fa22ed7d712917b6a9067833e5514498da47309bb1f76e527922628f944e789fc53fc61d90012f1af8e085f94e55303cb8a18bc61e0c624c4a8f3eef24107f9d64ef2651dc93eb8c887d835fea596582871c35bbf66d1d7a34f169adf2b4dad2465a8a0fe1951532d318380ed8a60fe190a8301dd6cc97cd3721e8f94470f33c0eecfbb31340b563ae80ce49c36e24a595caa7fbbb071564a363a6dd0ec6307adf329d1254e0aa5f9e91eb88213e8277db57e2c8e82a8b30d1f3648aca43ed8dcd8587e6ed842a1c1f060126050ca3147b5f40435e8faaa74e49675ee2bf33839f297778dd34202617942f0e9952a8990935299c7973ea7849a8aa5a6601922164fae8d445406dd4c26e5953cfa49dadab76796339d24d0b840fa271fedd66305284f76b25084369ce1fb017741275cd4db43ad09a0e3bd8fa471d8c54084817fdb13e541c4c138868e527d52b41e4876ae537b0262f8bd87a385788dbd4e327915ed402bc912e2933cca57316b0eecd640dccbc1ec028aad02256b85c46988686c1b4f55b01eb4971c07644bb92a00514cfba75ae339cab5c42a3b5bcc32f61ae8376a7e80856c1048e256a534a7ed99365c0fe6cb665b5aa632b563df0b41620f250b2195767c9a777e3aea5f636195a854240466e744c8aa7a927c0f0d4a73ff03f38adce46d5fd1fc95de8120d786d3a20cbdd333dcdbf6c6ec00f0e5e3d9689e0e7a694b64c27bdae4fb3cfc0579083b5d66681be7e02fba0ccd7d3dda472dfac7c38c54766424fc9485f92e00bb37d1c04b5a383910146ed34035711121d1f0f86f103c2ea08920d5eb670fed6caea41931c924c23edd31218596c7386329f12a6501836bb2ccdd1d70385f362d1556a81a1214cc8d96a7beb4690a37396b3612d9369f470ff64fd4e2627fbd8cb32a65be953ee37a52415e051e0fb91bddd64939eff1cfca092ed668f43a2cce132e2adf653c6dbd1e90a51a3fa89beaf2f7e5dd875271ae616157805ecbc453cdec3509c8d2fd2d6b8d243f96cfed7b59a4449a37f284f86501faa191e23bc78c5654e16275cd10a679fda644c8c10f3f21340462a7caa5165ad078f508638508f8c1cc7800dd262f824b0409d39193cf3c1575b4ceb7e5cd3b4a4217ea350b110eccc7d3a5bbaead0a04e844450c61cab80441fccd92a76aaa43e192f7c81b4a25ed8061a0e5c92bb96949444971f85d32b634564d884e9e9fd5149ab737dbcbf1e3d19c1cb2a0690540ca37afb9bcc449bbf5770b45190f756a726b33b5fa1c764dcec030d98564b2fb6bc66024308647eca13f22cd95703a31346a9caabf703c7774415748093d232942cf0e26909d1b8a020fc19dc1e2f52a1f8304eb6f2aa5ff61a1873150d457aa1ce33cd4f4536ed183846bd8a1c81354fe4078a4a0b41514536e6ec684a490db7f070cb576dd5e8ebd964e723886b1561b4132a2b1b26052ab1165c7ef9f10c5d28ff4fd07c6ee680fc42c3efe28844c1b3b115484d995d17eb609e64e3f167dbec1d2feaf7d98d06b635e4f634925588a283b97ceba3048bf0e760710b0f082fa862fe51b013cb1fe117e5c27fdc3860e77f14ef8ea344b5a4f603c3d3e59ac98c06bbd483428f080b1679421cc327655c8f246e0ed6116109a5947d76703b0b892cd0c9567ef3bcdfc78d328a1fc0ce2be9f3ee453253726145fc634e9052ff82bce14a32fa1386b327434584acd078ff9ccaba42e11eea9c27150e3e208ed28bb699c81d9acf45ae902e9743f54990fa3ec2c65b1bc81995712a8ab318b95262256e538c089b2ff352afdf4d8096665db5919a6ceaf7e1fb6b4ddac26562dcf1aad50040fe1eafb59b70e1133f88edeb5be82c128d66b45c2913f0d2281459f1ecc464dd8f74e1e48f5a7756eae5fb382d9d26e74af026d8a6df5d21be16bbce8a69f3316cdcf657a3dee44900929d99ac9ff15e063ee55cb0039ebc054457f49a1644e2e0c730d2b4e1cb7157f900886211b23b3fc2422371b92a3e8e0d7d5169dda864af69054dc8f0d4d2985306eab402af3cc679d4e99bb618801e3bda3a07fb10f0f31243a9ec6f4e6ada81ca2e98d41e37606aa8f0fa6abbb09740a167cbc6f0e50d70ecb31d7e721772d1195fe64310024f39a2afe27ce15fc7b1b401e5ef506a50b79448adfc3fba6eb3b43138813ca793233c7195aaf633494f402be48301f50237cc586f84320e29cc0040448085968a4a72704235a60faa6f95f446324bd0b7656ec577841c3b6833e05dd821a7327f0f78d1fd623f13bcee88b368077356063d0e4eb5f3bef5ed31b42787eacc79c837482932ab73c15f092796e231ae855f569ed281cecc5bc50138662c651182c5d252ffac0ad1ee94894bde804002dfbc08957a374b49912577908ed50f1661f6a9418947a796dc2e33c928ced934e5a86786d4087ea2c4b0fbd80127b3d51282649ef2631730e2e7daa55867a329b18d1a9a594da658b4e57be69801e883b470d801ebdaca65a05e8507ecb04425d9bcf3c0766b1d6cb15622d087f2fa7a5f8211680d09e6442625d0a34e07f4f28a8ff9fddfdbbce63e5a65dcfac58685827b32eaa12e8f50786dccdb8b5a105521d9cb61dee9c0c2e82a1ac77c5091ca398b895494e1e558c3b7b494d9e95b2470972929b73dba996b9ca3d600914884ffdd3230f67239acf6ed50883195605ae0160d65d726cd94e79d51272cb604c1f848dde082ed07f9ac4557b34a7f99070c901504a1cb5a24948bb01905da2a3d175459580a9e0a570a151eb5262e5332d4914ba6fe7711d6e4b9f248e68d7e82eeb8e861999f4a7881b4fd1b9c5e4bab2f51fc27df454c2abd18d25726f6ed55ef3105c72f53eec6d0c6a56be5f447eabd830cde35561e922a2b6fdac96222fdd40248f6e4207ecf2b506215ccc7988c346e98bca0a2557be8efd413acac0691a8a376938b1ea62fc0f4c0cb2314fd5c5e911e66e87305d3d20cc4d46d267a3d11492fca20fcf915c4cf92c2d58d56cc336160592bdc3a10decaa621423bb80b4587885c94122a14ab6c5eb129d60cf92a3b017bcc8f4ccea9bdc705c6eaf22d1104aab4d5bfb2628f06978d0480527eabbde99e32032f28b1bd7d2220d16029671b1fe55a4d007c18354ef1cca8a98dd26c9e4129d36c216505dfd78c073877fe0c94b0b4108acaef731ab78843a1f1f8e2b852019fe6451046f2d4b71fc55e3e789a5f15188300c8676c46335e5a40e472a12d45b2a934e88a8de08ada2bcfc00ce1947df6eed2e88deb07861ec541ca4dae9897ed0c0f747c4241315d735b82d6363cfd64b0cdc7cb1c6071f299d4577d548fb2a998d7a5396d796936d39283b9275da6b064ddfde56cbf618a495361ac927f7dc16b33dff975c64128b665c2641cecc12233ce7374fcfabc15248ac9ad20d19162f5bb88112d082b37995c635a41e8ec97d107904928264c91d7f7b97d10ca879f7ecd311289357c348c14c23a1cf2e53d694d1e1935511aab4d40716a4c138eda19b8d626cb3807a5d26883038d6e6b66c6ec67a8782199e02d5e71d1252ba3e5a20b0d7f3f47d6358d00e215af26d015291c347726ed9038c8731284d5cdb5c3fdc9a7e8cb135bb63355b7677e4f8ef4739f336b99b3bc4ee999cf4dccde9b0da88dd11460c6876ce186612b70dbecb671bfb3e770710ce57d8a1d4b6e0d416c57092fa0ed3787f642764ad1d77276bfde7f85cdfe0d699732fcb28bac9ce3f48692660477b3a3dc91f916de2de528cffc1747a465eeb8174f9f0befeab30037c3c2ea12dc126af5376ae0de202935e8ffd6c33fe91e0808e9e4b4dda8ecf09a62930cc6264f41869c99d25790b46e79d8bcaa7e1ee9576af2a8d494fc441ed6a77d93cd3272f1bea8a2e2ce620051f9f035efe2882cd4b35fa684fc8016ce13eb0e9025d1881f69d2cd4c5132975b68d31768480ee842026bc4f14e83f65d98c446dc32dce2110f7501fe22180f559f12348db18c941bb16890b468e8ee9f65bf7c3ca86f96d9dd12291b9c3b43f7e9ddb7059a09a8998a7c3f86fb25090c64045500eab381fd91a2afd7b478c1ce06b3800244a0894eff036ce0f0ebbbfdf3a59e26507828e46ad82fc6da33f37342bf205fc6b6fd10fd1ddb4dd9e3dfdff0a810ce9d146cc4b3325cc47a51f824d1fe813d18dd7f2ad0f2a57a762a82212d6a1ae809cc9aec3545b39573489d5546730945127ab41c63013dbf16058cee5fdfc77b509884329223b2839ca14e9b7e0732489037be86ad9ef440fb63c5aa59b2f4887f9cca0ab6a5bb27cb80ba219d7bebe0138e5bf1fefe9276bc10fd26e21ed3734720a0708cc8d2e7c30678eda1a406323423765ab511e75daa47d8c6ad3a7d65d33914fe49435d6f9123b2b5dd0de8b2756392c0663f78ab336b3aefca7b59a609c3383a702c1498ca0b208207757532c95ae0c07c3658f62ae04e9c9650dbbe6315ece5ada448ec41722a1689e9c9b7aa0d392e667ab0269a77c594bae3f90acdf466386dad5563b82c0b0838a2b2b4a903a1207debdb0770c3926aa58802ae09ec2932ffdf1d0793178a311050c73bf5e5536bc3a93ed045ff970d0fed9e8ca42f3d02fb2cb1ac23a2c6a85ff316be9881ec47bbf3c6fd66c08070ab295eabe08a6b592f9ed745e0d34d5706a302c8d5a22ef8de63e9d69199b31d926010e91258161c00cc78401986857544ac1a9349b847259cd1a48e15d1b72e5540ded038ec1a679de78663363d9ba4237385630e2f7320e496d3c707a91ada76d4e6c7ed86edce283760363021283ad3d0791bff6a6abc49d56c1d279c49c9509d7d29c8fee768a63e64192fda4390606a4702cf612224f1599b25ced0f15f9d98d3fea56638ea4d44f58ce5999cf1b40884ddf3e6827f86a6370689640c302a25a8306e684d13233db47219711d15c33b9866a959d17d27864126611fb248a8f48269c874c4935aba35a9b5b26e11a237a5a2454f13c79033d328c553a9d090874ce2d0b2c31d7da83bb190ccaab1d4ab52b2dd3a9c4a9a0a2b467a9798467aff67c48a6951a52cbc90aa13a7b06a98ff48c2495afd17c668213e77cba06e1917416db6b1396a2acd28798e85e36cade480c48608094a312070510adfc0977125e306633fffe94318409a8e0b42577bf6b868e03743c6aa0a9654240076d2d951993a527dfbd8c508175c8d0a5f2762c069040146839b4a1f2c4b56a60d8ed28422b9f9cab4fb3b93b072209a9763d5d37baa8da94374a1d72c66e564f18c7bcd94d67e5c560492658abda6fbb9a933016dc5e9aafeea1a02c7428c40a9e65162f6230a9361b6f39ebf556ecc32ebfc8d1c1fc7b125ea96db3dccdb19c2ed6550941ea4287da2104f1e136b7c3e78789d5848e554d0bd1fed340a02bdfc994729e12b4e4e243e4377bd92c11dd99fc1be05fbe3202728fc0b36514d19f38d865f849a37f2ab159a22c558b301a81fa6a6d62cb24ed92964adbde85b40fe1499ca3f726678d0997b4eb9d72bf836fbc8985c0c9c07132f2e75e3f132682c59aa2449e9ab089c0c549a9c9cb721020a95364ae4256c5ee3adc14bf4d61f120db6c48933a49bf569a5af9e9d3bf2f8b31cb40fdbfd0b288ed7df441d45fcde7ea6a8412ade62e9a39493541a78c547f5a988d46f30185e0e4f77d0eafd9bcfdcc2bc560f08d003172d6d48385096c90f115509ebdcd486a62bf0798ef72fcdd84282ebdff2d8d3947b21bf5ec4c3c334e4ca1420d3484ed99c9d82901cf9f460d4deb5f7e331e03b5dba79a6cefb3313b9013f0f477dceda4dad98620d4d77bf54557096b0ebcf478e5544d23a044a1d22bf950c83f219d469300722f50aab6f70fefe98fe24a527d2674d1d6c227e46dca05241c943b210fc8d0ee2cff93fc15d4a2397963eaefac3e1224aeb5b711b206182dc12eab7ce601e29375baf4a78901ec2c4dcbbab51c47d4f924b186202ae5131d33b38661887d0b6b90d7f662409f44e087e56f58746d42e27b0d2db788e50ca4c10b1c0c3ee54c1e87ecaff0ef72a2e78b97cfd864bbb5e0a9b953752d85e07fb56088876f8aaa51ea1cadb23439f1b42c19abc42e0aa656c26d56ee0d06a88ccd3f97b6270f5f5af211e9fe5d31a5fc18a93ef764903dad684f21c19aae0100dae5e90644d98a576c7bbd48274d463c30a8ce9974c8cea6253f613e5fc25987b794ab94e9936cf97ca36c734420551dbd31623a09c23a97a725711aa443111afa14bceb097aa5d592bf535a10ee70171ebd30be854e6d156f22d415f479dd67b6c0efecd4d1d439d020bda8facbf7f50e5b17e22a719702f481b390bfa7448f32c91cd48f18ae134506e060e2d3baaaa2eeb9d751d5f6348386ea3b9388de30f876941d9543dbc0547789ad50de0d3d5e6feed0b2c69b97105ab25a4817dfe9fbb81d0d5686f574561a2461801e5b7e25c333dea0ddcd6c03d2538255081a557766374703d1ecade899a9f1dabc4ca8f73a525974c090a2fcf04008280a82192776e395ad1753207cec5d7f5816d79326105d4290a9c1fdb48aa017fb42ca4e9e3edcbb35e7723c11eff0edd7ad5157cc2e2697699b570215e123f578c482cea2d9c017ae3ab7a0ce55926c9ed44b560a723ec610b64ffe3b0e339aa1a605e070f077d297a5eae41189ef9daf0edea1fa650912a73266c82c9d57a163b32de6af350fef59f9e2bfd2d63dc4e87e7ada5db2a2923bf5d13a6527869aeee7ef25643c2ee17737bf198f1c45c2689060485fb0540397b0a91d0ec92e680d06a046831183eda7921c61b3d14b38d848da4da3e89ea98017a013e4e1f55f29b9d4a7d77d1048beea16fa458b5f1a61311b8f273b93f9d2484bec04d3a6ad68257a662d83c3a30b15fff0ed3bd5c1dd24737b77b53f36e9c0dbaca30962646a9486d5a24c0cdf4ce0b44c422fbd437635e08dead3306af59e9a9562c6fc9ec2ec87f838d42e429a10847f27d28a43bba15a81f57539935dc823e2b5ddb0480f3a8ed009a021b256bf42e1d352884f65a592fcc336c490190e3c2cf324478e84f3525ba31ac47198c95780557fa8f4e3d918f3bd3d9e37cc4f881c874f9cb3a605d85a0c6832e9bee74f66b9d439970f8f3e2abb39d12e361a8187754135f7cfd3b31ee11b14e6868b5b413f306a5854cb8553a8df3f979a4aae646f79ecbed30f12be035a91344cbaedb33357da8ec234fd0eec1f6a52001c973a5d2d4c5bdd8fa981fe2ba09f1204b09885ef28c50d5293997277368af8545cb9ff814cd47f102baa5620e4721119ece4c3a76290ccbdc51cfde3cf183995d9a8dccd0c89f5c73195709906181c8db83d1df918e19d30d3ee3c23e70d8a84756909be35087f346e164683af7772059c4e3969ad89e3e0610621cd600abe13b246cd40cf390d3642e8937a3b35c879c36d4220b5b249e2f83def5261a44d75b951302e657748a1acd9f940f91d4bbe6db64449dd5d5b2dd540a7b5ae7161ad66c918c2e357a670956e0b5cbb00c14d1326d81317384b596246af6e178ca4c7668b352a3bfb1635148ef9c6307324863cbc5cfc3b1e14b925ba45e60e857f17bb87496c21eea440b713827de72aa1596dc70496bdac139f96e9f974cd8644dd452caf3a3e76fe893f1a4afd5dbbeef67def3ae96777ffbcee7a9d6ecc27129d8e95db81139e4b95530f0af256625eae48957642edf47d33adb0bc8d9269cf4bc76140c3e0338e688590fdfc7731abd530693b007bd62e4dda653c8518812b5e1d8749a75b2178547b4b02c16c89d89c4f3edf594d8b6372652ef595500c39255ebf4b34e00e6a434e0dabc811655bb2646b362a41b65396bc4726890abb6b3f734ee01c30e0eaa6c00bb95bad1a39e6be9a021a51f023503c7b462172ff25eb1d39e0218fe6c029de2dcb879a902dcb892d63bbcaaa753b9a290c2a5aa06851f85eaef8671af676112cb1724e135c50651f3113c9620e2fa80a10815305fd9d60522c87f3b15df96d6a0d51ea5da3205c5d6816a68ecde0aa4cbbbb17c4f162034975abe8e5f3991dea1a2da004ee8cad79ada901d92af7390cb2de751fe651b288cee72c5b581fd026f431c312b57455ac8c442f94b092b8df13efb92db53d83b5e4b745237d25c05cadbc3a4607d903e46f513eaa8baa052d7ac3d7f9f86ee1db6b2849925ee08f05663e6d455328c21520f832cbab053212148ba713e2807838b6a731c69368fe57542571c85f4981dd8159ca13ff47fdfd0a20974e347d44b6a397e93b1f2a48d642ffb6d43ff600df44c4142949fa247c05e3825eaaa94a19c7a676590b71633073b7a348cbb45bc199e41546f212c1ba5f11469b9f5feb75a73e06d3febf5fb8260f1af72647696c2690309ef9b59ae4c5e6df45c1af78f129c8515458dddbee34e83d28d26880e49d5757516336635d2299869273599f46f8e07c96df06d61aad59765ee55fd3abfba6d7ec3eb63ba12389d01aec8d8a0930d9d1cc6db7048c297b4ba4cff67ad067528ddddde6be4dddeb90cf1495c4605038cd4c163ac864c7267def547fecea6264827e27744f607572b42a7b2aa6b0dcd15be7064411cc3ab6e6ddd96f5a9c98f4207ddabdac7adad7d0317d5c3ab2035baf74b7799827a65cd3ac54b30b2d4a131536419c403388e997de00e7173937e3f4a3abd91fdeb21612ae40718a81d773c416cbeee8aca94294630d94ecd9372d63f777d2c2d077c07b6da1fd1bd863ef273c9c7682bd2bb9e64f0655e5faf9f9c2d768b49b6ecb298ec0cfbdd39ef0fa32481b0e118616c9734ed69e42fecbfc8972b6501f26d88ea34deb3614871d1a11a5b87bab617c32ffd00fbd7a805933b56b1476c4efdfe7a61076cfad9ef2a7774a363f75ffb095ec2129bf08e1428990c2e146a8f39668978d6a08357b87d710589ecc1f6d8380461b221e3fccb0822f02890776958065b8c28d5b6188ee379b0698c51b151d55acc7ef492fa1a80a6b81e88b5bd842c7e810d4e145ee4f8b55a11163606d5a0ddfb07761df5e54109bce935d9a9ff8a308046bb002c5a6c51ba9a92d019122bdab3ebbfd95ea3e0af87380909ddedb53f76c32a3a1568ee39d8da3ea2af4a35bab8a12206c9861c78c1179e164d5d23bd2353f89f6c076fcc51ffddb4f20f5a6fa83017565798fa0484b391d1a356ac9f8a654b4cb4106a18783dcb9080b29de3af4ab88fb5e256867435bada8748927f829e638437d037c08489c2390b333b4856961c4c534f80b1da5351a76f7024a01e63a69ec9e535370b231a3d2c3941069d498ffce86711d482dc3e5e0a24fb58cafd2232806871ebee741156e59983b918343aa7c7c9fc7eb7013bf98ec03bdb7f8db73a6e5dccd96f42d95fbf3fcfd38984330023803228e9670abe982f23e542342f648466e40d3da1ca124a1f98f296b98fdcddc66a85b5440ea344183f046e76e2419f0ec51a533cc841a90533522d6c5d30d9b33eff38f0183baae118c4e5e67a271509bd089927842240d05c3162f57e372d8235dce4c8f6dab5a6c3e5899f56b59653c3ebcf588eac8d71444a01a5ebbb2b2eab7e452a3ddc7273a316dcf119df0ed799c47e422dfab5addb556916405227a64f2e132bffe4d847c332b69d5db6f4f0781ecba0bff45e3036588423cf129d38601ba3f6e4eec6cd09c79a60463b5f711d6111b390c68009c3bd7b8372f56a58ce1aa576899efb7ad4bf55d6bf4a049cb4910abe31fbbdbe1515b4893d316432e3462c1f6bdfc24d779233f99c434cb3300476d4ccf25edd88b0ea161bfe7a89722247c9211d7a80e77efac2868ceb595a6bfda8c9ec509b4a9a59208ce121637ac01d20abe980a464d4bb4cd3d1d32f4747e392dcabe46e16f72a6ced012a5b078935603e641e54b55d4ee58e1cc6c56942f18ad37e8a655e78d6cceecd1852d60adfed5b77d7eb7c825b33d2902179c947c674c54ce7ea0099ca83e8c0929af70f49666c94daff5a5bd256518dc0e553815fff157610cc2138027152df382f472f747a2651841ce10987b8f7e0f8a1d696a07c2cc87bad4176f9ebb8df0e3c19271a033632789a170a26b2930711b6fde4ac24061734db4661b5d8c78821575a9486d93922879e1eb6f22be0455a18a9f9f238cb4f23b7a8bd24d8d79a8c77d324bc52ed9bcbca10435063c8cc91fa753e81b6bd7ef47c1aa71f2e151868fc5eee9d5ab259c4b015c7eb23cebdc6683f86e02a8e1d9e5a58c1b84be5f3fe1897357f315c8bf7485574ad5f4d339b550e86dea22cb353a22036f4527e4fb8ab37e882ea64b62f62cec1e6e94ef0b68adeddebba70402b48245031c8ddbde638aaf7d45fbbf99e6abb53e636235713f39210cee0b18f54a98801deea6020a646110642c9d6be596847b55adc952203b67875ae1317533d1bf31c056bc6a4278768c86a952dd645492d8baf7f470e1ec05f0be6e67b8edd4dd02847b584b814d79b545c816a016746b2a719012bc6c54b622a9a359fde6438856ebcf1e6bd7d95f1db10a2f15b7876c8f1adf9002619880e04f0a6c674de1c3688eb6889f3e644ca2cc255760b743766aacad02944a5932fe8e03db83e640b0c5dc8ba4c9fb936041c9b51080747b02b6c10790aaf3bd093248694ebe58734b88fcb8676f5aacbf65d8586e0a1cca5a9e4463c799cff1b5c2f59262d4a87cbf5c6c4636b65305f6a86774b9f492486847a9a023e3d9a6063f83ad43b7d22c9e001c95d23cf29bf5f4c20551fc409bdf70e2e2760e728e9cb9a87e2e786fb3db57574cbbd3c838ef3acc447e8725747b798576e86aae33af810e3304a04cb457e5c617fc0a5c47033ea62663e2d02a905d0d4ef5d228a6a26b6eb8a77dbce40cc9d2f3582da33bbe5e3c2023713a4bd5e92d876833bfb642ca5706ffcc3b3f9a2b756342c064d7ed474b24eabd362b029d5fd152a9782fc7959a229fdf138f9c5a80e79e335f4d17946a5b4309a2090cdcbd72931ef44da9c47faa5d7997d21e58cd97f795fa4bacdb173c00883cd8d5344d39114456ef0b94ec023fe85f6abfd31e263f4a832c191d9ac83cdfcd6df3f4459e426e2e3c9c2a08496365a4d3e812d07bbe6217c3d622d9b5bb59445c952b5f685a8882065b66416b466a916e265388a232db7c2e217974fd23f35264caad5390ef1e75ad278e1c5b1dfaf7c4f10e8c73541d561c5dce1ee7ba88f69fe83fb03f0c9be1acfc15e1b8b1a2919734dee8820ce0c55e7c0619636f8e5b69cbadb1f81084c03723fea8d02d155c0fbf18d281844ab2ca020f0060494012a41df0f6df427f370af2670ab9a454202031cfbe04a32947f11f7269b37ce6282cc696326b4ecc084665136e1b6c3aeefe440ad35516d464d689e976a9aa748dea3ffd194ff7cbd76b82cdd442749afb508e6e37109794905d39d926e0b1dcba47d10f491b41494244cce5c19389d406b9bb595eff3351c2970022b05b03047b8f783479b7953efa4207bebbbebf254c12f9fd268d019bef0bc40f74565124821881595ffe9f2b8f3882d16701eadf20dbb20bd44a9ff6633547a5b338a96164e383d2bb53d46d1ccfd9051081e5cf137870ffc9d75ed7468a17d836f333d7e72da82c1e56bd6284ebbae4aac6feed29d6805e5c1c76d80f56c6ee571be14f04421587f339e6e9f0359b9f1e772438fa7b61054eef22e98ce84516cd1f94023bce96e16c902b1ed31e203e0c116a4ee58f03a8d0a43f3c0112cb103345a9be5e7e5d333bae5d82fdf8ece91502baf2e83bd6bebc7951813a79acf3f76265e79a032eda1e27169133169dd00153aaab428a44a948acd930caaeb15ea1cad68669eff2753c3b78383657953029b1b940a88363131c28c4ebce03d784745b16260c5321727ead767ef997d0c3a1d1d5da6f6487ffc0ae47e4946751081cb2d991a7036a5700caba65ebbab877da6af42870647fb8cf709a8230a2d4d48930ba8af95b8dbcb91006a6ff12d5a15a0967c2cb9ad57da1a1699d966dbe7557004f62cbfde4d63be4d60f086c4591e4688362e0cc899e67aaf036d68d73dd627fe50290a176d5d193cd77d67a3dfdd5a186c2d78a085bc210001067294d2a3242c628737aee691e0528947ce060ac9843c345c51f7a905f261464d2e01f0be22ceed3bb2bbff88c696e4739bd60fe40af73b5176ef85145ddc8e3a859b52538d54426acd8635ca943d22d33cd9362375919010a18cf4bcd521d3fd1c1aa6fed059576a17eae629eb77edf47ab2f1d6cdb8094697bb394e73a1fb4cf1caa3ada5d1d3a67731cca96f243e795ea8531270fc3d68053f5fa15f7a549e055eff0e1ac5acae8cc0d828ea625c13afa7fbd64b22f275cdac7a2761e0dc9166e1d28d026997e55d483c8d9438878e2b4c141b83f26269f703007e01eecca4e54e8b47d72e1ca9352a3d6f2fce9b7d4e33ae812f3b32eca27a689287faaa0befa801604136a1304ec2a708f040a124a7223836563bb1dd0c1cdc6181ccf8db45fc15bdbbe51f1d548c032d61a50475b597c9960bf79ae97b00a1ff6b86cc304ec134b0ef50886dc085c098fca6e4474d581db391948ac1248da51fa796324c16fb5b45bdfca9827d768995ed8b007ac7b5041932e9582c2dde2b029baadb14d8a46ce21750be45e96f766a4f3eabc266f4352f47efe3cd91df88c0411edf286b4c0a3e75a399709832389abf4788aa31b79f982fef20425552b6eed2a1567ee186edcf5206208af5583461baa35cd61dd7bbc0614784c9864bc754f19abcb6532299e7e960e754ec4105e5d3a4d71886fcba00359ddea1c57f440d746a6558d50674915659776492a7a7d66c754defcf9fbfcefa7fc30841415e3a6831519dee3257fbd9bce6314e43ebf921f263ec0d0180dabd319366116935b97b0073aa0e3cd786db8b272ce37aa2f7ed7d05a42b07c982dcc81f87461a58fb1a00512ec20c618859b4c02fd4a923129e49d99745da13b2ce361d15287d808b2b5f73ea385cb38acef3d6552d896818e3b4cdfea02b6c6217318862540c371388507fe4830db5a7b10698213c70c8c051eb8a561ae0072c69d426aa0b082584e28fa14d5c678828d6b2f3dc03156d48b13a8a7eb8eacbde9e914fc2731ac8ee486dfe1bd749b9ccaea005cb95b3f650dd86e94516241038352f6f7251e3980c9189920c8ef55bb24d89a2d9c15d25d722f4f0e5a43b3fcbc2c149a7c441ef47c390c56077341c3fbf39d9b4fcfc29cfc6f3a731918a6bfc86df5c0ddac05059efd7af77f8c633d22ea2b607815e6c1f2faece14a6604d2d70fdb8d55a6c99b5788e5c30aff23f117aa9521663438ce40fd3d059b4451040762bfe36e93f7bcc7a3ddc0c83319bf65092949b899a34eae06e74e380809bb559ad07ac0445b23b6fb827682921a89242bd4f2af22365e1e8b8a2d0393c96fcd523d073f31fa2b2a880d2fdcc184f411bbb44fb5b8ee783c8c2168076f0ad883a3f5ad393419547f3a4f58aa26675efb1863bbf6b1ca3e15803204cf109dfac852cccaa6f5f6db4c34c779081187e783a62ebe1ea73902ffe0048435dddc6383a4df618490de8502700cf7a9173afb18e12eb926ec4de3aecc60870fca9f6170f3551f72a3f447961c7bab7cf1bcf1498e602902064ec068e055e0f20b11c38260dbd176c9d2f44283c53d9bcb74370a4fe59a61f9dc335a867f5b25e98b70ff764490cda373db8dfc12364327eaf3642ef5d7615625d178988677c85b7f958d10bedf17d06ad5d3f95cfb0305674fd6731e166edf2eba7c9049192b90c66709cd2cd959796fbb0fe1685f707cfd817487c543588fd5e9ece7076bfc845d7beb0d7eebf682c98e8f3009ad403853d8fbf16483379b752fbab20fc5742c13c4597ce78c6198e8d15a7c5dc8f22bec56e9220e4d37ecdb29e04679184e37ac312a3d6200ceea68efa7840d26eea6ceb8d030a0abf80db87ca831b75a715a3bed0e7d78feea16907bf5794bf7280aec24547a90e91110a717a3997148bc6e39d9ab2357f96d8e39e8d1dab6e207ccddbe3d6c59b29beeda5172b3e46bd7739303ffc86513acbeb4a13b116915fec1734d6470ce7658133b42e435d6562724b24a5430fdefe4a7d4ae16f4cd6350aca70ec7a0c83d287566b344f22de51bc1140962a438b27ba1ccb8976b19875f22869098d9dd7d0981973149277d20ec10fcb7387d6b7757bdb9b910d633cb94148d2aaa97a6ae436c1e96bef93147f59ad1177690aa615f0b78d6bb9270e66e58eed17c642d435beae7049827a8b6125db3fe59f77d20fe86855e743678198c0dee6fc7853c4fe811af73790dd966d5e74e1443d6729ae8af82b34fe92eea8e50a293ac78de387054046b137d1e7a53ba4c08d0fceb540d74f62f99ecee1d1aa2989a35a6eb489caaaba4893c498eafaebd0fc71ac0c0b91a11a5eee157d293ffa039c116bb2b01701b4d0236c21efb0b47f505845a703cb44e8a4be6a56196dca7a724f0dcf11e50cca639c018b49c8e28b572bd008d995173aba0361be2803c756cd9433b05d8fde647b903e77fd317802e4a07e9967feb4d1ca957592ea71193c252a4b27bc47b86fb3ba608e7d846f5fa1c7c251ba237d6d4ab608080895efa0dd6f38a1340829847927a1849b73f04309bffc836824bc52720f3f08f3f120902ccbb93c1621a28d7f4b9000f17c28fcc73fafd3bc716d945b69a59d99192a9ecfec2693ff990fa8f84178ff37389714eb30690c0b2bec79a4d9de747a704e1b540cfc3643b0a9907e75729826fd4974c808972df6cff7e9e3d17ec9ac499ee06aded8e5a6b48c6eb4e4258a5308df63f7e6f53f97f0576d8dfc26e7b781c0e56e214c00b363b7e4821efcc3ee06eab8ab9abc309f8882ed78d4f8ae01131b1073d7b9ad3c58b6a7dd6f938d108ebffa6b82006a5417bf919ae65434ca764fa94c560cdcd430c73bfe6037b2eb01dede7973783164217c4c93cac3f4b5c0b3df794cf9e62fc21f4d2ae9f7bcc220197608dde1ce0bba677bdb14bfbf82c135861b1b4f35ccf66b0dd066","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
