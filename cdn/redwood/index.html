<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c6b70bb01129485e6d253cc63dd7971a9d3f8827e26d8c084fcb45c28894aa68d958f00cff5f7d6b6c255af9caad9aec36206b8242b3100ffe3174b87a2d7209fcf0775ec02d14a1857e9d4aa4edb390b4887e61e7c7b0227c258c06813f6ad4d8af536c43c785c1273ed1d891cb1660d5da04ab9ea20b67880ad46c82227d274a1db0c10b25d04ac0768ea7336afd6006d4d4d11d39300a84b105daa4def266af12e14fc865bc92f27ef99031bde2491eeffab5821d46a3a96fe8ce1d99820389289a15b8a980d1518ee283e2cf1d2d31a89ffc1ccf41376ba3c65b0d47aec0c4e73ba59ac8ae01a4b0821be5fae0dd3ebf741574b3d7bfe049d64297ed4ec2242a12c22035fd62cb586be5b3ea7e9de19ff8b392dfd686c74d4e8c8d0ef809fb86b79c5e2585388eff7c272e3e672c10e51f7fb9e575f94535d589ff3550d8d0b95f5e98880330f2d211554d9e0c3ab4e33fbecbdef00fb0018f30616598b36efd7f0dca6c644223b85e8a03b11841327914a4116799785aacade36790bc4254de6db94ec4fa4468d65f4ec9afb6b5cfb42c52868a1a6cd817ab85b3a0ca08f8e91a21a584d159b12422ac46dcf39996ea32f3e132b7bbe0161a2edf4428d15f5f3af66abeb6fdc6aabf8b3d3197721999f934df18decaee1f660f48c47529fd835124bd20b8b23ebf5f8811fdaef1e387e7a72051ad0df2a79803ebc2d5bcf3b19e991c9a3fdf9a9a4b600edcb1ce20750ee71f901f36bd04611a8212952833f8def57ac94df141520f950eb5f0f31f59ca10622e5119d67eb30653c8ea85d6739317be97bfe5d3e7148528088597999ae5d479b3f64955ef2b786d62c4719141c1d960e534efc31a3239463461f7d3fa100792f058fa7d3e04f7704d832183c83cd8a6efe309c2529d8a214b5734b6acc9cdc2cecaaae555f14a3280085bd87faa3b585bd5ddb20877790d531ca46c21d1a27c3f89ce345632149280b178069d194aeb93b595b492f9bd3406c7ef40bcba315359c5d2a993492786955d5b0b3163c04f42d6a1f9ed481157a37d1a9fad69a9778b22aa42e8703d9a90f79dd0af07ccfaa1f69f39b2f53c9d263892dfbcc65e6b67c61fc11451fbd826501299f0e3f1903cf6ec14f217929a3595772097da96b9fb936aa7464ababfc69436f43684bd9675c406bbf58ebad615f85b5c13dd4272cf0cebd6f62647d792a515abfb833d2c676739620ad8b296542d9714c4e2c23195b6248fee7cb9d8a22ce84db624ba479e8d2ece34d85292aa7e6a099c7766c4344f157f29e02d60a156ca561787a2b91731f4dddd1f94e69c8f01722e853f1236a74bf69049e7c7a8eca5225806c3e655cf80e8a7df258c468886530f13284bfc2a0ef8f96281891286797bb3b35fc4a1a1baca0716224cf8c0cf1d42e755d3dccf9f16096a09fbed13428b95dfe6362a3c0102e1a333e00ad36b9d4fef42fc6985f7d7157ebddeb0ddcfd64dbaa97a1f90ffc0a6a561ed56ba43a1f9a6f3b6b91bf4cfb86084c448f9cf360ac88ffd3bd1991cced302ab5dd1fe118e2bcaaef6826463bbb38d03476e31310eb718e3e8eff7f64ef152def3c9f562ebf61c8f6ff4a4d3489322676cd14281497f146296100b8333c2a44d4af4f2cd2b34d27092df461c73f785cc491b232cd10d79ae2fa0b8048d9b0467991991b7b798ce00b6f890e5c502c4204130d0feeb70fc98eed571b9536f838233fe8c9f9c69d11328d57179c263677bed5932b5896b1e2254f504fc40483e58491c5407b24c6781c85b2f0219a0d9d5175a47c553cce058670cae7fc6b4654dc6beefbb2c0793bf70275bf6f7110223de72b3f33c3213696f7f44dda7362a9b782b0547adf3078faccb12665ec2a75fda5cf18e1a6d73dc813dbce9afab84c8375ff595263ecc2826ab690297042b56300c26fdec74bb275ce20eca4fb188c5e71a8af744e5b77b8a0d1b910caa60d8536461ced24ea72d12781ca4e92cd8329f6f9db767c0326da4768182ae764087f5d5fb06ff1d2d066c1fbefee62083cf9258dc0ae2b909263cf84cdc8c7d3a79992f654eb5f8c1b275575754fcce4e9d4b83aa19ea4246951674e282394d601178105c4a174b223a340b09e22877fc18ab13afc2c0f1773aebfd00f3d7a2cbfb2d8d9df9ab2e6526d6e0320e55175842c740917fa3e8acce0ef0ad830e68ef64ea558f824a996d5b6509652b32fc18456de43817766ec8184961862abb362db9ee893a1ecf623d48d3b02fe9bd3f74055188289da0cf4c460d0eb97d7540f9509e73ffa685f56ef216e43094f24dea14b8a8f240a79bb4e6e45284b64aaaa08d47d4fae58ead92cb15daeb457207718c5b79b7aa4449055d0145bc297ec6aa1c2e5fe5712e574522020737b84ad1af14964c2f9c0ba1db47795cd75ef6beeb24f24d35a7d6b55a862510bbfff42db2c6910f77fb76a468af99f27d95e70fa3f1a658d82cb8dad018b7270065af35c1d9447de1febd0c7aafa43411c45bd2790d47597ffaad11b3882938a422f3a6c81429a679541156e4f1d01ca6e92492aa2e963a45febf66408ec05aadd4f614324c999f1cd74f2d37bef025d692c5d352662ed6a8f374244103a4f1c13363b87a7c26258858d375001daaeb9143052c6184e42bd250dfc7bda0b5200eedd2ad7afe438486ecd6140b587de0ef70caa3842073970ee5fa09fc9f554181fd05e7e474fa1e4dc557a98bea84579f0b42bb31df7d44c70233745de54ade9a7ac04a5e3a554785548a1b7baf613f47497f3b600dd15b36212427ca4de51a657c10de39787feefc6b86afae3194e4e64ad7e7fd73b2d6fbb12284b09f10bf9bb8698b81608e50acdedc7d3c0cc47d515805ffa781f091434ae367c01fb002628f465ddb825af3c4e34a5e5665e601ea1f7cd5b11eca0889f49a73a16ff3d71a83c6309298e10a9b366774e5eb24030b5dc486835aa3dd9434f89b5c87c35660555af486053cb3c77f68f291a0cb3c19ec4319de218aa3ce5e42b9a02bec055c4cc80ea59a05cb95345311a57dcb9f0a6e6d0b5964c7d99487a66316badd284f0cdc292fc2290d53dda4a89d19eb0151e86829659b2813eb40515bb1c61f1d9158d6fe8d8585f5331c345c28e943d8d4a09237659f7dd8b91fa7bd2a6d64cc24e2b90162d49ccca35c16272dad6b6cd58cd3815cce34b0db484eac4c26c3f5924259dcadc549ec9d419f1bb79522a3ebeab9533362b684b8085584bd6e4069bac4ff2325c09d288107d268da013d01b2a856a9b946473d287cb90dc839ec25b6e79f0db2be6568d0117fa6210d8d8525da7b1216f52733e6b09853d11add2e60cffbd32134e86c27b71276360ee325ab387b91d62b7e0349d2d0684f958a47962f22de02bfcc0055b066dc918db908f08dd14cb37ada35d68abf9ced21c5c422b65b2462e1c7890c6d47b2f6c81c0b42616be22509ba4abb2be413579632690bbdc0f97a2345d0783be1fb0455d78c0fe6badc16062166dc2d14bda573150cb7f6482ec572460794cc0f2e66fa202fd48d8b12221bd4d4ed70534ad9814073ad61d7b22ba55c1d5d88b65d0e1ee2660fcdeaf9d8685984e0bf618b6b524768c885a0bafe2a639cfff7848e95923f8937e10ce59663daf0e55e61518d45a523d7759873d1a5ab11f76e6c992043dd6d69828204939e88dad99555730514a3b847ebfcbf2873fe52d0bdcfe82d426b7def593f642c329976b6ea1497466b7de57a12d66339844b301ed8fb6d61551f01b89b7dc1d61b6fdb90dbd21deed5d608c7a334f5d2c2f5e8b427be9139e3c9463467055959beeb0ce6beac4b2541df46bd5b16f2595e4913e5735c62fb533a64dd38f98d0b2095a64f228bb38f74f39aab872a9e22c14eb86a9a7eed47ac73a8356a5562b5e7ec345ac7c2b42a015ef49e55a2bda31aa95be08d79fa25b7037921c235a7ed6bebdb1e016e33bf5473c6b018a675ae8a251d7239ca9077cd3302c21c309cb254bd68b9e4627d394a5553e204d7c353e036d1efd8d0326a58fb8c8523f77d2e4d1aa3394b14269281c2da94c73e268517aee58fdc920a39aaf78ea673c540ebd394f17c669ea1c7ec402101a1ddd071cf68f78777a7ab28a12e95a916a3df302b9235fbf4a007f76234034d038e45f7f3bba33c07011d34b2a5d46ad5e7b4d82c8c9bc1936d8d44aae75c6def1f9bd4e5396d268819a1193c847600cc80a834cbe4277b70923569c5dcef6f5b13c6fae9eba4897c7d813eff16704cda384552cc89e37986d032dca539fbda7dc36cb01db8454e3de09760a6888a75d45c7e47b7f632d8fef177cc3b43c6859e3f67cab3ec8c480b7375e309013071c45b7fca583029080a283cdb15800eff7ee06a6de23e607f53a0c34ef3e7db8f61babc654173d05593181a4134fdd9e329bd5299dc6af8a7130f7a4574c7fbf682e9b87b3b7ac665cddf679c921988536f48fa41d9a451ab72667e6697ee2405f1452ea05cc6999077758519054d866220ab622747f1e6e6cc1565b44f1e26c11bab0518aa6314a8d7f22c66ebbabd17d85869f80fbd8ab39766b8be7d1e58f4408341ec1313110db12dd11b8f230c89eb123fc09826b5ef9042adf608c7cbc456e4e4efe538ad0843225ce07194c1f945a6b70e4f6b5cd0a32dc07f7b4c58e3f118d3897ec3f96d3affa32bc40ab061234322cd46b59d9f6c16926d46acfd4c88c92d24d86333601606bced2163a728f5ca970f05a271182f0ea4a4f2891df406e1ec91071dc12758147c55cfd2b8236f7a9b55f5f1c84357629a59de2614cf62d9ec741c81df87b16b31bbd094c147ea0a809704f3902288e6324d22ee03353b13af713020b79af89f7d5e120b362d1006b34f6747035fb8f91c64495f294a23a5b62c1778a7dbb52f7eb67da2695c8064b579283bcfb8890fd1f3ed3fde34ecd92cb725bb11090eca81074136b0740d6407ebed3ba19610ac95b42e2d4bd0947229f27f5c59968ed79b4fdf8c56dabd9d5cba691cff6744a68bb3f0449f636aca99e748766e5d4fd06bcee5fa3c09749ad8c349d429df425e088edc7aa9101ed98537a60c66c817d8c3af190537b3ec12ba6c64000d9e2579b9cc70130cec2293c8133e825f941f9de6eba98e6880a01f4c488786b2a28dc6f221869269084726105e43c4f790e805a985b68d401a3cc7d4e1ecd66226f42f497b2367748974589bc0be8cde2fb8d4488337e7ae03da792a1cab275cc7fa1972e0be7a206937748d759da276c51af12d6ac35a7a7cc0f75c4f2882d804f7ee27790f536861940618bbe6786f3ec8d536ff35210b7051323a87e1d09cb76f89185c6885eb1e2a1a9eaf9ea4c2f815c75ba3bc8ddb6b88cdf785282d595c2289d2d08ae9ca458cc8635bf5fac098f9eaaa119bd0e53d0f8d68adb984f0b1ea87675adffd9b7bb5c34c8bd77c5cfd2b603b13eb227fd95d6e56eb07915bbf5a99d7f9a8612a4186a7a86581bee3e5be661ee8e7edb135ba5cd1374e8bd27104d84f5bbeb513ef083567bd150aa0926cfdd58d8611b5c7f3f79ab617cc3837e63df467ba371878c662dae328010b65a1f6a1d6e97d95dbbe50c85f9e36ef6ade6047272a5a520f3404321e800e9123950798bc6b5ac697ad366386f0ab95c2782e54fe2a843b32b276dddcf9afe5b54b5d38734db34f7e4ab9c8be529b6958bce83f85c875c52a8423e815e8e0722b50b221ed14d1c8d7d0d3f36c1ee4939f293f0b985348d016b43c7171a0b07310f4cd5e85ee030660ea3761f2397fcc74575e4fba51e2c26e31050157c9abba9bd75fc18d22fcdf7b112fc5902dc4e0f24bc6ea570fa48069404f2f35f0310c3da560dbe5f077310108e0d3bbd3792caa647ee44fe2f106a8c8ade23973d5805f4c0a0efcddeaa6b14dfa7b43e312bc179276bfe1df7a0f67f5cdbd0eae9bff8b21d1909c392d55012d2e870a3258b7a71d104c747b2922dae2e7d6ccdf4188766fcbfb5d7f90adadacc7499b938b7f6752ec788e79809468c46951167a3154d90ae8c3eb27e47da746ed6815b24bfdc550bbf9fe86331ab8c4828ad4e5eedbc590a286bab6d167bc4d2ff1beee2dd9787362d4332701a11288c3283a653f74d4bb257df0ed8b73e03c526d36cdef4f944733a888bb014290290959c08c310f4b9a6f9b79fd9c71fb746e2a7ec54edb289c9f23b87799060586c948015ec17e58d6b573a5bd678a72bbb484be56b3d35da50042659d2a1f4891209d5941e789efb50b6fd75a2fbf13a2da4b4eb141f364f9bbb2be8c0c52dbcf4397e742a45167ead2566f531d5783140c3dcdb6ce24b515d657e4077d2b7b9aa53e76f448db66f6f570ea78546830a799d5e343f7f28afe65bb90caffe7187a2488e40f7b80f6bdfbce51db7b940eafd44e112b7eb13c66de6f21af2a6db1642e2d7c7413040ff61dfe8c0c0b90c9dc011e80659074e822df1807e2489d9c69586c0ef3a1754e31466d91d6544ce013fb6cf6e30899807157eb12ef711f71bba91b242b6e937414f3a5bef01c537c951ccfa0288e3b39c383fe7eb960a39a9a92d59106199ba4168a3c909cfd875358b89014bb2edbabed0346235e54c6b515fddb113232a18ccee5c38d19c0802540e5506e28762582f14f2c1bb6349dfea97aa84f034b1b5869abcc544fa8550403f50bce5e8b1ab10e9235d82f1bb7c24d078490035ab8b6e72b793e6126a77420ea7698f474f651c5a3ab713a48342a8e710a72cad0035c91cf0ae3fa27d89ad783326b23604de0763faac4da71ff02a99d23422e6887ef70e0a48c1ea701864a93714e441228c55c18f634f5c0d58817152b45eb763dd020cf0105257a279f62a559c8631e2699b904bbffcf8c769c46ca49d202699810414262c203bed71144ecb5853ff03132d13e79e80f42f0d8918ae55aaeff8779b25187c42f4d7b936f6971692d4ab6214cb2bbc3d3bf383e2d8210ecbed86ceb77c10ac726eb3606dd05e171d94155a9ae7458eca2d55552985f8cc6ede1d2ad050780d11e157e278f3e8b623d5474fa8b66cc364142b21526db864c7c303fcdb7b837816c23dea95b0cdfb13ac9b65620bb86f7f9eab7f7e2b4fa89f85b031514483b710b7a421b2dd9a64d4c9c7e2c75c41bfbf011da1b9b63c3b241465a2c1cd4d5f6c6067913f1410a5d6c14881bd84333be96e0d049f26e71bb7660eae8465297ff450e0811157d16f13a2048031428a12699da3c20ada18cf2c3991f4f3dd0eb1e1051ed677ff206ada085a33bcc5f7f9e58ba0f498b030d3f56a492db2b65bfd16b2c4082daddd526285285da0a3dae075a7c1addc15294318df0fcee75230bd8dcc5c919d1aa157076e37fb636f5a73773af97f2bba99cfe685cd223310a0c0d306cd388c843b0d2d7031df0bdc79917b59df340a218d35e7295ad856230244845d6092ec35811e7aa8c79fe02c8a0fc9df58874cd123c29be285825ea70f4632a673c0026fd1bac7608bd637b0a9cff89d52d0ed1b0819bc826cbe371bd10e8a2f7b7c334d193493b30fb98728dc4ecab6825c66fb0cc46661d5f566cafb4afcc94285519af822c46aa06a1a2b214f750bc26bf703a6815085a97549e9006f628a1415358d3bcabb16a72710128914fe48ae9049cf190af14e5a3172de5d1f5785f4e31c1a052662b84affbb9d61eb929e70721609cad61dcee5a449109e06563ee096738a73142951546549e63bc819679bcbd002f1e3f29dd5b86218dee71360fe38a5a041d862d5b869f2ff13374371a514c3a2410b41eef848c76e0e783068a487e113374d14e328d6a0eb9aa11e5431e39d6cd6c89fb8c6f5a790bb315cef9bf3cacd05de65ec5415c6cca7d9bd9d9edc47c7e653ba6d1bc9e8eff280e253b9d94745d482ad3ca205d144a6feb216c891d395dbd32128b14735b7d9dee2cdc27e991610d32caa8d4bee1fff860309798a22f32b1949d613f0ade74c38b90de272a699a90e708ad872987408a146c5736c5569f16c2261d19c2554cbf134f6de1c9daa79d7c41d87e5a0199f463350f90a0538b3c069e30c2b55f80a1163e20aaba8f8cc439eb973544d5feecf66db1cc145e43db4da88cb01a10a0abd9760386a2b66d1d1d8e01d9342777065eeeb346e3a8df23e8859247c4429484984e12d2e4d5b46e099a93115c56eded51f0a13703b4954d68846b6798deb227fbdc79e6fb80452d2d66b10bf5ba85124713e6c3bf23e3ae077eff73a58ec8d984de62d1108f694c20b96f3623a49e1c8113b457cdee130b853282a5c8b4bbf21b038476a742fdb1e186768a33d1be9a031975cc6f155c1fbb5e01ae92d0698c0f27a859bb4002d252f0b7e7c81b15db527b97fe00fde47f9d749ddee34eb1c2a13bc95409368aa820f793be2df6fc70fbad9ccf1e0355af6e6e53e6f6a2e85f9bb403e3f83cc1f36250ebd148060958afd15c0d691b43076d631b4e47210e3de4ca86ee6494c10306f47ef3e91554cc39c96be9e703fca27c8851637b739a83f6a5cfe719ad45cf2eabecdc0f268e92578da9b8b01aa1f38497ceb3d3f5a057e48315d511fb98a9a239425d8c0d9b66c8da9124891de115428fa861a34032d823b46f56fd3c4b5d9db3a7032c9d9bec34ccaf2145c2e5046fe35fea66c3b8f35d1d6c40470cf681338bdb256c0828d2aaa926824d2ba47515dd9c1a78fe7eff3e80083c9c50cd208d0082d243e516f11f9f8ac3144a733f50a1be006e6e346cd3be2aa6c70339edd4f9becc7a2b2e02b0e5a4cd7bd0d61a2bb15db38666ebedf5966b555b400fb3dadee415f7ce1290fc40b49ebc5910dabd888000e89426b267bec229ab4c2ddb038c96ad2e71bb350faf1a4a475abd3c8e821930f6e1725681fd20f8e08888065229895452d988dfc1ba66ff4ff09d3f26c26eeae2db8f71557a4d996b21b4e95249f34dccebf5880ebdedd05c618f8c81c4b74ec83a8073dbb9492432e6355d3af9ff984a28f07365dc7ba1b8cd0f95304db481243d1717dc67e10be6fa695acb7ac173148a982d7d7aa5a1269373d15a366394cf3611959a6c2e3ce7794d60c2e95c9bbfa87ccb8b213bc0d7899d2d5923d157730fa84ba5e9a53a3e4b66dfd6901ddcc375f943806c9b0896cd6782670c0e381b3f698d3abb122991fd953c9653b2b2eda74c4f8740c8179882cf77d37de0c70a81435b4dad9d43e0e801dae1fe8763bcc3ea2b9a5742a79c49b3d3978c8ee7b28c331d36786ad1e1469b03f81c0d8fb53e3181e94f04a18b6307b19a8a1823046f29fdcdd5f30c4463be3854d50f13e8b181bff6a197722d8ec8897619fabfd13e0eb7d8467425ee7c538970b7e57bb6e7512857fc942d630892a5126c89fef7c8683631ebe935c4aecfb737a7b7a98f8b457250bae871495c15534073d6920e39f454ef0cda110cf4f17b758b8215e3a92fa21ac16c098f7b527f8529f6f8df84bbcc1b0d57e34d0bed80b9b05696325f73c7b30b30958ca97ed0a5c75fc445445f6e4215cd2eaab475373c5bfce220ca48f27dbee53d1b3244731b927575d473359349d723909c7ac0d0805107e8a4b4a56c6b101599ac7877937717e3cb91872fa56ac800c2b3aa60ff38d2fc7f090201f2f2d9987de861aa5c8cb3be174b42d12c1d521f4fee31808a5a64b44f4d6a259dd47566fd61fed0c5d0587533b026847598794f72a85908502d1ac3328d9076ebd19b5d5e2c5be8fa1d22f6b8659b23ac706acd79f0123b681728f97935cef934aea448df41d5cc786e0b57dbd0822b16f78c299a90efa7fa6004cf7f453a324ed281055b9360498f28ddd79cd4b18fd3bb65d73d566c1d3105cd59fdb043c5b50a16ecb459ad84f57d9a26b57f111322ce027e96b5dc305da7e279a3c3018789438e5a9b16eea8b6282b0a6645bb7d3fdf0e98d783fc4b52e785b0f6e8dc66f06a6b2be4d634383b87bea5fe026bff84d257e9d7da818d420041325094219366db687ba94401fac029ed33bfe843c0c25049026ee5c399bb6a82504866e9ba89d1c2b2615838ecf4eca92a894c42129dfd217d1394567c6b44a3990bde535a2cbc62f1dc541bcacc5577a2cbac635f2f967f055a4351c5a3b08a93f23539986ac95513d223181f9e55d38d60d087f249cbaef90b62615da367868e0cbbd8076b5778faeca5a48efecb8bb36b2dd12f9e8bc6586036b0a52294885ee07f6a69147bb52466aad90fbd430ffd23a614eaefd9b9c1927bcb3ab5e5fb827c6db6baa05ebd358e87c9489fe32928a7245e70393708582aeb8fee8e63ac7d249f168f3957a992c0da1af2d5e9e96d371ef3c5c7f90566add078f14218c8e2c2c0cb53623b2d95afa27beb6f7a00255541b3abdb1feb0077b054506afa2eec392355413aa2281fd0354b976ddf02d9bac2bf50fe9db15b5aaac680553e68cffacc55558c97f339410459882d04a948ed6b3b16567619a2f7f75e383f8f3d8dcb4c6be71320973d9765ecf06ddc5a3fc6c9e3fb569365a3feefe5b98fb094d447ffca3c8ab37730ec069242ec6a7c6278983c567fcc1fa86ef57082cd10f312e41545c5468d72ffe9904924da3460341a889bae4ddb4ad075aba9fe8e0ea947eb0cf812c864579e992e4220d0467e565647e4e77ed92640218c7f8a8a10b8b095eb326ba8d6ef0fb9a339a801d726f1bb6b4c14e5c912e3a3e4dc20354ef6024193ada76da1cff544f2ba54b63a6ed8cc6cde7db5341e59e03418cb29a9a69b01331839a524004dee18a5a060187be1a8e6c629e3952117fb5ab9d038cadb5d30a4c9bf91f985aee2fbd132bd2cecdb77b64cd8d3fadc2ed6d35a11570bb8688edb9a7905ce6ed551584f480561ee769ddd0b2fa3eb0d6686779730c472ed20debc10a8a7e4507b8fdef1a6e354e572c39ae2c3b49ec934ed4d6033521a8bc23b5e4477262845afc3d174e9d4e732b73add7a674d4463df6451739062efed43e94ee71236d7800e66875b401ce391aed63e4aba05fddbc33a02d5263ef284d7959c52b50d77580de55057cbacd5ba8bad7778713b6730e4f3b919e6d800e2e99ce8090cfaca075ae5f2fe8570b53f61fbe86e0e2b82c5ccade618f3c0fd4ed97ec10672031914e8c5e05cc205c3136043ca267eee2fe3cab791b78e03e753791455a5e9c86264e9a49c5de65b2405ca085087ae92df317d27eb4de90e3bfa55d2828b8e4546dcc526dd2f26ce1d43da34234c57d7d5d502dc93660a098adba010377208dc67b06242915e3aca95d00f4a0a9e114a2385411b77dbac3c51e2a942c1952bff1f7c691630110b6c00a9568e31ff95f1dbe588445956f919b90c0a70c9c0e1bd135565e48f0e5d1f8da74a06ec90a26cc92fe4ce8e69cd5fe614de90703d1cef027f4e77585da0811d2922c2f05f07e8aac6f17ec05b282e0f37fdf0333272a76ec0c4c2dbdfccffbbf93a94de8e97edfc29a466e92c609e8f078e15f999b1fffc6a8ed1bfabba347938e844054ce005c3c0f40c4ad35dc41b4aa11dffb841a45dbf9b98b09cfc39a9e68fbb597cca7f4f7201cd85bdfad20b29c28a97e977163e550fae921069a3f3bd52c96c4665dad2cf98635225f4b5b8fbfd87a0acc63ded717c6d13511f82e181f5ef6bdd2320f89822983c8343ec086d6f2fdf44d701f2fc5546fbdebdf6a4be050f859e81893b8e49d404b6005d48b298391602110b1ea9eca2b3912732980c32136da121dbdd37a0fcc9eb96649b69d69daa30b91e8a19f5a12c617aea0e66f940cfa2d4c6709aa3f3c2f9d007f4e52b0baf291dc14be42c6f23460d352e45f4fcc2066afff094a444790a9c8f4e82bafb0df836602f702cc633971edc28d598b84d66527a5ee4a10bd152724ef002c6b69084c6ed5db2b25a0b4ee863856a66a12a8e1f8e459e78ef3b270d223fbb02c86097657360ad5ba3353a664d563f4b2d786b9ac9e6a19501118af4b4c682af5c809109d0a5c4ceaae01d8ef9f11f847bf2750f5676fa65c5d82843f31b7ece44a182044ccbc1741d5102da0f697a8eb014c8b62a35a3f231af04546cf20f7a2a63d7e963f1670b6ff88657f3c95de18c573b1c67bc4b47be7ad4b3b8e93f86cae9b976e54855567376cf0d8c29fe54f8c51a6d9b976615b09a1281a310b52fa9914b37fb0b7d46d66d70fe2a380cfc57d5e71adf7c394cd3f2512bda39165b67058ed3de903f1167be65b1cefd5dab2aebae277573454984ba14b1cc0c8b4fc77fd92463cd6d2e314ea95f6fb4aeacde32b5afaaacfc0b8b0b0b62d99d4be187281f2163edf4a14572f62b95c9abce1373442c84d0c6f623f331ab51fa12a22b6687d68c190c2004e24bd23fee11419a993fb3cc8f68b5e3c60a37a245a225155ffb94f68c07d9d52cf173b26213353a96d81d9e1e02a410a60b9e0089f360a61495ae544e8315de495c03d53b75e25903cbfe030d4e27c11a5319b419188058a31b19eb1e3d8d02e1b56f85ced915e3e43b2c6288091a955161bef4a17584d794be8e750f9941d110fd70b76429a537b7a6b405230271311a3d208cd96b4418640754381c2c4df19000fcee08586cf525ac6546a9d640755a9a2ea5172b2cc9a9228908159856d7a0d0835a56aa74536408de02982ae2a0c629147d28a03894cec0096a73f9fc156b285ddc865ccd8e6b1e80d567efddc52e259d7134fcd102667943b77b26dde124b71924eb86092615953f66fda274aa39536e054f1331638fc35dbacd0e38f809f09a1eb4a94f6cc4bb6e17c2f7b198313cb8524e69a21b6b6b7c2147064ee50f538eea82188dcdc37744a158d60a9f6404724d674bd5666b1b3dc68ce7500630c37a7258b4fe7fa0e5cddb6c415efe5f27d0bb98e66d5cced4c6b88afe49528dce76e87775c6ba976501fefaaa29f08036de62da33edcd71c92fcfe205e32aaed329208767fa9fae8683bb0ada819e776f79ecf5129ad15b4cd3def0c826160e827e45bf90dcbaaaae9573d051d804c0cd465cfd76b92413f04174ed35a6e76a8854a3a94624453bc036f827eb7c90fd7813341f1b85e34eccc96c8a35f97fc45d436fdc99ed4616ae06f01a0b1da9a2d1a9299b7dd0111f093c84678889e698d4161ab7236aedc93fe9a86dd760e4bc3a703eae64040d39b120abde183454c3bf32f4664ceaf4f2f9621749596f8952e0fb74bfadc1eeda3acbdf66176ac719c3145b6fddd404082aa97bdde58c9497ef58b402e4ba1dd6451d7e0311b3231b0b18d7a9c7872b32362d07f2c435cac576ed752edf6fa6e988f3891e60d85896f3ea416f4ae17aa13fbe54f20351daf967f2dde312352898b7aaf6018360e72f9ac4d3c728a799d56aa1dda2d32dff3bc6aa2623a63fc6c62f88b0a6279a535bd923a39f37883c5119f8a079e62ddac63bcff831cd5ed814d130804460cfb4368706c408abea60c472e219fc564f5699bd6692f67a9f5a404555acc96311d8ed746cd2645a2e9ce7d9460b0d1047f3ad22360784b050a4696c6d5cdbf0a40d63f6271ca2ff5a5d762556b4c625422884bac758929da1fb60693409fb3cab66f2f6f12743debfafdff6ace9c9a780c26edf54d41fed93e03b72d4a539cb0fa8775988fd7bf6aa4389e3af8b71e6a10697418f9732c2a83983a9a086da2ef240f42721ad500f9d7198e8576f15a7fadda4311445ec12c9e09eacda60ab15cc9c68541927133c30a774d54164aee28914e476bcfbe08cb19d2a5d01d13c230d07a3a715d9a99c10cf9b3032e1e5ac7ef99938d53ad5e485cec5f621b2eb1c1180dbd07dc8210927ef8a93900caae581ce94f33b964d8f3d609d7454d77a5587034f888bffaced1f4a20fa7bc73cf84d5565041566bf0967509845bc24d3cfce276caabf52e89e401de907af5f7e5067038d4a39cba3187cb4883cfe59474f4ee9cbc336dbf4dd087b511c6c25927658d503e8004603da5620675bead174135892ce92854359907d725ffe4d2343ca407e865444ee9e13dddb33736fecf95d88e5df757e0027dd62a79eafd9d669dc51a42583c56160181892d1995c55d3b34d3382dc7b9360f4a397c07979ca7eccc34e88e5dbb15b76fbb4768407a2d2a14b6ff959087bef449de014c38aedf4520294791717ba9e35b692538c5819083bc4deac409428fb212ee51f80559e40063fef59005f2a6afb531b7d6b033c89e6566be8b826b0dbfb963d2519d077bd7c347e72a8e92de73cf4023e64693f6b65f7d0e3d9c8a0154a1df636f1b1aadcb2e156c54bc692bc37e5e6e1d17e5b4c1f3a5f5bbeeeef504bc91e12e8de6aad1feca99357fc45ade50f85c9629d54e4c95b2088cd5197995dc34d59fa93dcde4174da6c39a2ee11d53473caa00559754ae14d722e65fa8ac8937df117208a4cf520c513e15c2bd06bd6cf24eaef7a46388112a0e2ff5dcf7ea3ec4ee5c15366eb95ded85fd2ea3e437629008b0ac65736b78dfbd139df3cffac35fd35927eedca68a01ec7afed547a22f1552f222303436584edfbb0fed0df49e1ae2455357c4fb047a61f5dd1e96c0181dc8bd4e84cf4061fc37a9036659e7dbf3193edd1dbff7666c86be373538aaed00e6d9bccc5e05dc3ba5e11629e9fc209c766d5f05dd46b2c8c8c80d03bee87600cd86fe6a72f03009e399cb39ab0eab01b8360be95940f446a8050631d9a749a2a523139b6bd7af5d7b967a6969282caf73bc5f20559f743236b1d91d3a64f8781a101d4233b775dbe152dc98722722ed87a128456bf4abcd8694643aa29f2fc3bf9fcc55bbc5828ae43f0444e00e7243206f60ae3a24b5765c5cecf05cfab28db3d9acec505ebbae7b43413b2b9c77af0c984b9f0890608d928be17dcba004ee1f0996c543105e40f333f92609c921aa779de1d234f87d447600c62f62ce7fc9f2a4ff1ad05c141bcd6b1c8b85335834e1e3b206598c2d4f6470ef56529e5c810f67afb84b76a97e1fce90909d7bf2e6ddbc0f72fbfa701dfd06f6c958e831fa6be1ce46883017a8150f617c0a63a8ff7124dbaabf38123e1ea269bfd61b3dea42c95b4da0a612dedd9a88989addc6c09d4ce1b7ace583a81683a9a952fe3d71f4987228d3c5ce2e30986985d5b63497338f9639a7184cfc83fc0fb61489700cef5c0b52206249f88fef68f8b6257394ca3701a2a20ded394b3addbeaee9a8b2a0aa5d15faedf936806a584c7c534c465af1c0a804b9f5067e52673885a0131114ab1de57144e38d0dfb1184253d4c5d775da4a65a2b07e0763958ba2b55b71be8e8271111749a7d6d9a09df4ae89d6016aa7a8f8d7273284f423d90cd35b6a8fb87beeef1e5427046f2914984e3b1656228e9f85f063bdef05eac01b2be24157330017af5f8ba0ebe7449028976a02116993fe119e8cc65d89e716f3eb9df720937bfecbb20b5f6cc049934df2cfc6a905fe6706b112ff60aaeab18c573fa40ef0878eb0d5ed54c8a9e045c57fd18fcc59c2266df20331123f22a5307b60fbe8ae0014bf8af4528541e4348c40e850c5a4f3badfbec01a483dcdc083fcd6ece114a946ad0ebb01ac4bda0fc2af24aef8a3ea81c70b7efec5b156a0db13eac16c50d86c4a89ed3dbda5befd8d11e4013e3a181354e3c45b35b7d0f2a1f30c57cb2e0b87a773c65cc5efe34260ffa3704384e49ce24cb5fefd0a88a3a9b3ac9a4d505b70a6f68fbeec83fb1e2c7e2b8d674b802f22de01a034803a3489d5df992226b21ff752beb9d4958b9ef76e5f5ad041f3bc53471f7dcf91169540093497871aa8f6250aa53126be02828800b0cf15fa66621b36de1323c8ef7e9bd7127557d66f90f766950eabfa36e9c9840d97e514e5290a2d96b09ae9debc12b4aeb361631661206fa58ec44eaca09f9a2f1a0d3fad8fc4c59ffdaeb578aab86a56bf497c38ee4beecc842f9d51869c0200619bea45559ce36873e5d74e9300d94c5a01465c502c739f1a8a99b6c213cef7750ed675efee271549131caf4ab4637ad0d9bebf397c4790ef550e5408d0a1c1befd7f2c8d77377c53909b6049808060e08f98f4fc249f000d51cdd06a8affd190a8c193d1c0bb3fd3ca8473ce5bb119a70877646bb2099dfb0f45e7d1ffab6fd47797d2df3161276667e82468bc9b41d5ebd324715cce56bfe43f8ff91249cacb1fe07853a37612c42a066c77f8962d481b7e00a9aada2b73efa9007e87a142a6ff8f818c11191f535ffe7a692afb52de1316d27322c6f0f2bc075d53e25d592ea2684ced1212ea235ba5dc4350a11f8da54e76b5d83e61f175f16efb896fe3e0197346038747a24dd19cac603d77c35fc5aaf754101f2802f5e914e8e3282ea1e43755b7524fd61a4bf35079a9353bb95b00bdcf84c0a28ac28f049548fef4029a8e5baabbf148f64a401129da338ffe0718a24dd0322cd32b8bd83bf2dd9f28c39dbe6939918c2294bae1c4ef39b149493198e1c0af22532f679a3d523867f8b8970215331960939f98c5f5d1a0a80eb900eca3c950ffb1ae7ded5b15293dd04c56687a1987f0a09bcc1f248599f4fc09aac1faf5ae57586304d1cdaee0ea84cc61bc56c292c91aa053e1b035b857ffe30c13900b413168de1e1fa5f9e03e9953dd1d0f75f917004e3438409502a8d970db55edb0ef5bb8e3ea54ef96481c8d49e54936c1a2b55b230eccb412933d1cd242ab4a1d1232854581c8e6bb96749cc4b23f236fb242ee1ab89f52029faa052bcc16592a002ae8ec262c8075736a0a2118cd6f150c76d58d622b8910f8fd2d262d9685e71c6c49505b3fabbadb2e8868351c1d41e7cb28a5a4af6f790d7f4cd244954a4024c21d0858bb8f84ad0ea30a910ecefb93c9dd2511327c4367226f408575e10503d1d54a50a8ea8afb7a4da38da1946858e9134f36c753deddc7642b7a9d0b15ce75ee94687e2ee1833e00630b834ac7f0dd2bdbc2e401bb030c38c6ec8b3bd56b6a40f87578d2f6a6b351df00ff4e0e4babf4a299717b701e14285d0b29062274dade73a3b041824d04ed5d56473ae9d93cca2e85d8e76f81aa84de073d716042ed3312c1778d43ff81875f3ed08c1396a922578e2a8d03148f7e5ced8fd34fe2fff0dc3fda8ae4dcbc5305800f509fa78fa874cf04c80463a94d0c2dd0b9e7b75f3e9c0908e02710f8c3dead7f9385cbc9705904c8ab1d57ec7f1fc651e296de6f84ca9d06463bbdaac166e161ea43d51dd1cb8072b6181a67066651cdf7f5950eb86ab6dde41b9b8056a7ec26a9f622336db388e4aa7a94fee4204a25fa70325ae968ee794c6e5936b8a78cd10948aa4c63a21daa28f6985bd669df640e4d77130c378fe5311d21562a381d30db0ef109b837a4392de4a4516cb7dc7bbde7e80d202750e9d85656cbda1dc326acf04b7fc5a10e975dc6b76db9ad1b85503169efc925314e6201882c3783f6bebe233f4a1631b941d0031987f63b33e743d877122c0996bd405b41c3effcf337f72233b6cff37ce636ff84dbe659ededaa6d474dceb7b0d99cd61ef2bb2d86030334a4c71e453a27d753800613f65c0239bb447a3876ed8990ecea1cbba32b3462792342edb52beaa1aa7e0476e8a92f03c3ddd7289d7c25937841e12edbca89ee8dfb59f2489ade9497926b2c4e8408ef29aa524d1f4ce4e99076dca1ba06c6952c5f33a3369734376345cf5b842f9886fd348dce45719eb9e5d1f737eb691ea70634f6481ed0ffa31fe7d6447af978eab28866aa22d206b200aa9b1484727bda3002885fc5414116b8522455937202c16cbc6de9cdcc31fb7a412faaf3f1fd986f5fd8979ad56fdee70c1103d304d138c27d11a44406ee4d98cb45d757962b8093d5731708874503419d0c102269981da159f2a8b601125e03fc5948b39a9f568d862a53d39ad62826f28ff52579839ef6bd36658a70d6a3efd12ad496db79fcfb6bbd0160630da1a72c3c6273010468f0f1159f147b42ff789895387","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
