<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7191d4ae3d9d3d62db234938e03e87a254a1f2ca63d57f9486f21c3368ac62da8e5ef9158969ac66f1061ef14deb4ba03a4cbc8a3dbedd1b6c85f16c1dfa63c8f79611199260b6a48aa38eedf20de9cea707d58049f5d523cb58b96521d3383c9978d2856f144ae93826bd1ed2fedcffa94285451042c7aa33bfbe5ce402d7c0f6140757cffee6dd29394f470abdd18a690c70b38f353057790ee43d98a44a7e947a99cdca2e960b8603e1653888b9224a8162214f51acac25f35367b4bca1707ed0168862228e68fce02030a7cd42f7fb6c5783f2fb273730b494d0789b5b1f4bec3210c8bf3e50c643836c9d15f48d75302be4b3babcf2c0805bfb0b4e0eb12c2f112f8f7e60ae8a1a3819d0a291bfbcf3413f32ae9f295b8c0bea219e964e96a92dc1f08390578b695e313ecb1ceb099bc9a70a8298559dee142c37086d9c11d47f9c0aaadb6d550a3a4049fd500ab94bc66eb562127b28f5c882ca798d97417933f5f4ad6387db1dcdd1a3ed828619b14817bd1cdd07595feae3b491a2b0048b57536a72ac17d94a95d5847cbe187cbc92ac68778adf0e689165d18c4815cb192e007d53a4865b374840fca75e2de17e327ff324fbe71385457f5667eae4a6b32942c0555b8d862fe278e687738833da84a65791b20031bbb190b2d73cd80a7ee3e98c88dc4d3e92e2300bccea2147c93372c42480831485ae1f3e03cde527301fde40c5e6c4b543e7134779ee1e4279faa93cc1b07ea766705080abc0ffbbd9fd3612be0a93031d9f8dac6a4dfce1694ec0250f96cd2bcd443414080f0bf31ff96e7f74f8a6c697c3e1098ad37679371d8e3f1f5f596e98fab7d93b16ff56541530ce9fbee1b65f59325ab2eaa2ac968696d324f47c3a19540ae8db80c6d1ff4eafe19ee91a5f5067a09328b12158cc79c7847a6b0643c230fdc0e008a20cb1d77b846ac19a7d7df659794f17c903a7244b3794bb9bec991b7b2f62263be1f70b20ef8b16a6ca1b9676db84a4e5ee334cc25829dc83824f97412c4db3e58fcb2016ead40214abb2b7cc37995d655cd335458617879f97adf73d5cd517cf9d6536d865f6c281115db37c27b8cded5b140b786e6b3c102a625b74c4400c8ac8eb77719478d3f415d0915b11170df630a00935bfb8b46511f24c6c6a1a93b557c61b6a190ad5afacb6f279ca1f662cc2ac8dfd4c61cc165ca6e477d6571842853df8efee56cd13995c2468707620bf9d9178bd83cef58d52458f647e1995130c8f57c55076d92e5e783eff5e020bd7bfb55483c2f4d23a87b21bfa9b9a98912f958ac90f0f8d27e03c03f0ebf1e1e1f1f3a3b193a9117ab6bcd0553b77b5806ab53dabce77c5b7a49ce5a71ade01e02756f2ccb134ff1267d5665e08a92091706949db69fb36d7e6e354ab5ec14c49f34a611c60b60b93f4e1dd543c286be88f966050f16d61da0f37df72e1519aa086db4879216c163da798996dc15d6ed33e8eadfa95351132264245507f55cebec82df2dfd9b3410957df7ab19a10f814da842a204f4a7e642846e5fcd38c44ba40f806136e129bf50dac102a2b5cc877fd7463122b5cf307a91290a83e6890b46ec1e8db59a696277ff0e13cb2eab2a340cbaa03dbc85542e9ef5fe758bf4cd60faf93d641415deadea417acdb8a33be6f674448f530a3312f1f8203174a9bb612bfcbba0ea090d55bba377d15eb3f5a653a6dd8093ade76136784021b134b8bb703f0c14944605282160ca02b285938c5bf5c9f8eba551847b612fd0da8cae0436008ad079654424c91598221315e428a5db019b346ff5b227c79fc833e4652024a0882e1e14fc1872bae6591ee41b1cdf3ed7f4413788754197be7fc04d699008c3996e1b949a5fab0c66ae8d8c0dbfd5b319fdee51947b7b1d40f692c8a8d3191f60076785e33bd0e370b90d1d41e222291ba7bc35d631edaa436ac99acbdf4491a1b637fffa51c569c8ec77b273e812c582c860420b9fe0d5a337eb19b91b556bfdd8b07abfbe3a14791fa7e58a0442580c8fef9a5589948d83bd452a92c1d677f67615f113e1ae58b40d44f779f1b843624fbe169e96f090ff8aebd26f3f5bd0127bd2a287373b25c5a26466c998d8585524bc4a380b2008412452257119f5475dbc37aa51e8902fe122b29d855137692d1ad69a1d10703b98034ee9618a26d3e657d5e4d74e6cbb556bd824440891cae29fba10e2c6ef056a491cc918bd1cd13bf79717a310b5e287cf491527c126d294f03633ad0216978111bebe5699b40589b7c612d20a67bb1e7754092ec976185bbf7c8f1bcef7a5484eed34c7215a626b88c9133846bf9491682f59bb5e5246ad7db0487669f731b77c51c689c079651fe01c7defead3c31b5650b2290fb5dba78da580ba20796ecc2b2536172fb0a8f463db253029d8d60155eee35cf05789e368dfba3e89c292f146adcf12f1ecbc65c96e59254b1062c3338b749937ba075e1c8813132fd8ebf5f6e7ee4caba317ecf4a4f5d815faadf8e4314a498c10322bac7665ca0d103396a2b929b0a2a030d863cd03074a37bdcabe18743970c8ec8f1069647dd46bee7d26ad1fd7a49e66b1f62a75aad5e2f640ccdbdc762dcb20a682cf19489d40c52d5af83ba8088156906221e96a3cad216e63ba549ccb9222e6a970f7b031fa7c15806e21f5f4dc104854c6d8dadd762a2403e47a981f467748cb501fbad100d316f77d72d4ba1888eb5167eda9ba1f85b338773c97095e7ac3149f5b4ddaab2b5fe799eb6786de23d143904b856ed4f056906cc5d1631c879b3761f33263aff1c1e20f9c60239a78d771581c2d00477744968c29bde991470b6827bd47e86be9f8e3911fc4cca1ed1387e349b24ab994286283f0680e888d11ac7c4e41697eaafc5903c5c989a69ab5c8606ec75bb1fbd14989a7519561beba73514b397286393f8498181c7b5e7b1caa8844c664b0795977c7b57f66139b60910583a4e2d953fcbc0badfc1de6a304d14898b87e66f75adcb98a1ae84e7f163efca0e9602e8823786d9ac8d1ea09cfbfc8e8e949c77fed30085fe22d9d35a29f3c08333057b0373744b78be1385775eee207c563a5fbf9f1d17da522d68a13b456ee8e2c78237d53fd42c1609912962a52ea8f62a4db72b1b0a94b195001e7eecab1a853a0800580a0835d5081d54151476c1ac3c304ee6244c8f82e8c08c256b2d33e112ef8164d448b0a397808f9df4c621173cc732887a7a6721a723389960732c7934de8338be195ae5534b62bc6a9d094a426f91c45743a1b61fa252975c3f065c7590ff9550c8a7a39307e5dabf7505908f8275dc25a82c75d775bd9fbd7e826535f31e837909997e3fe0dae78754c138187a1fd11007f81f114111bf6b663af944e43eb5f42b4d2bbfb2e9f3a2b7ab2dd934e021f72971da9a03b00cde7873263858b370044f8aacbe49bf9201dfc9bd2e7c9d6d2e3ab66ea3c4cb91e81474ce971b7ffbb133629f979332baa584a549d800d9034185be17e3973f8db7d7381caa3e85ee79d533e58eb106058bc175947970aa70b5e4f40d70374af8e3594944abd2acd4fbabae8bef2b0afcb2aae504d760da3d4a6f04a70478d8c80631554305edf7b7b01f8132148c5362744bd4576f64c4376aadc80ace0365eeb7f6ade20456a7a36362af449305e23a7235cae10bb92e647c97986f3d286926111b141db8f20db34a178fb3e5465179b3f29e48fed494e40b9125913c2c9465e1f2927ca6aef780bbc6cf9fd225ad1c66b74840ba2333f74604f1d5060ac856a983ea4cf9d76a1284afd132126af49c05d006ddce53aa5b89910eb26a77bf24d274a53649cf889a3a6d27700587a86cd970ffceb1263c0d47d9bcacce2faf18a22d31fa29ae67ef7646c83834e8ea6912b33d422bc1d980c24f30734e84525c885469c01db5a54c578db912a01ed9df0bec51bacf14c1228b248b2b45d6dfe0a358414d7fb1c4dfd4ef307e58a8092a07b4b360ece3780803b06cf8f6f6b598e07182d83cc1737d8d761e9dd6727ab9ce2aa9454368b6005a2fb685c9f8e5dc08f032fb801a2f79197281cd89894a9d695818500c5012010d9b8da2c1422441f25d1d37ca5f934bbb517cd7dc2a1f682eaf32069b172c04dd7cfb71af4fec900641bca1616b65686b6100b0808f9100d394dd15af6688641b0e7bfb87b695ae2cc3674f879fdf52898eed530eea098ce79f7a0e9f22f770a03f8d6c9960a75039953e55233a3ce5f722043c4f7c21ce809595ecdefe0705de75b4554794a3d02f0b81c118aa93b5ba6fbe71dbe43689a9949c3fd0fa3be6877b8db1ed8b358c581de34842c3e930ae1511b0901e253e2034ed59ab242e6a2358e410a64704d3a0e5d8197009f7c7032529eae78dad9fc13e5f7aeb6ddf0aeb4b02065a0d8f3be20c7ec47fbd1d0f8d1f927eed6fb719087204e44dfda9451acbcb32ca1dee05ea97dd851dce192bf2411ae88f3cbe424186e8c1b696be77190b96839f9513658995382a0cf5b4572d17ba38daf77becbf35c73fda92ceb8c4c1003c3dc9b953ae0c8465c0246ab5c6eb99ecfd5fa0600bee7746acee806d7dc1bd317598c871c4f50d1178a72d845bad768a0361d8c39d3218d77ec219271d90577465b6c8460bca0add169df0fadc1ff64b31af4e080eda952a0a0afea92bc3735110df6423416cc955c72254bb1a9ab7d6ac73b531fa5786989f68abdb29841a5a795c17b957cf6780b25471a49ff11ab56ff3278b62366d1289e670e2bb9c2278790b400c4d4329e44d60a02099cecdf34d1dd27a3e5d1a2e28609018ece8c26db4434514af6a5ddae1ce7d94793849bf6d4df11de4c535001b8d3e4a848ab712a694ee584850f851711858dc62da622daf807fcf701a142834572375c6315d8faf49c083c25d7990a4f6fb3f014498bd2ae6e62242da0d028987e1f59a1cbda8375a198fac08ab583976e37d407dd28261cf1ab0e30d6ad96266de0569523f933a3064329c507c4585e594cccbf29dd13ff6cd0f777d594421ec4e0ae458c017ffd41208d08dcdecc48dfd62be0763bc25880d0fd8eaca01dead3c408c8dd5be22de381155dadc0f7bd5a8ac27f44fba19cc76f6ee60d7499ea28b1c6ae3873212a316c71c5b7fd77fdd3770edc84ca55fceed0da4a205c0be9c304c7aea6de6b424621a40dc211ed62520ee5cf0816aced5b54c0617b5cb4bda8b9342d6b4cd0afc55511278480d1499d69ea5a393509b4cd54e225f7d660f37de2011c4c41e58f0691122acdbaf8ab434a585ef7742a99c60a0641e48e449633a348e0674709465ae1ee78e0c7d052eb05f4a18ef77d624eec95922df5188cdf4aebe8a30bbcc8a02e5d1d782804d2cdce19ecde6f82e419ed3cc3f91d4c8e6d3a278b4c88f75455ebc18738d7c684fd1182152f7e33829d8eb0b5909d415342640ce8646521cc7834af70c01ae3921ea750f9d5b8fccfb2c81f46d21ef17d5dfe0fb230ea81dfb4d461edb52f51faecff4ac6a3b6a0393ac956f085f487a14a4249ace27d137e29b6f21e3b8384529d09b7ab1617714077a859cd08ee37c7a4fb41667b1ab6824ab154f69f055cf76b84804ceb93dd36e7090b9ab99aa5cc5ec48768aed9717fa8a9e4244e41d3bb1e0ee02bd3d0cf69ff78aa5db5606b416d2421177a17ed0bd963e43443f3b9c8eef0a7c089ee8adb699fdd56a0184624c89e85c323bc6cb12b51c0423aee41978ca9621f999778c4219de1bfa432551e9901dca78bcc27afde806362e331a9be6548db5396780a57c1dbfa2871ef8c1b6e88e1de68c8f84e6f80c40a99d2de3be200c567256922a372797036f5668e30c77943a47defd2cd6b9598919401eaa04e8052edd437e0bbc5353600bd9f202ebed558a544ce93fe74e07fa8f65979d62951556738541ac837d8b78077c30ed6bead85840434659d67b0cb0b4a18c793b3ef680261579dc8113f75aed7011911d7e26ef0d6da76c1be8b5956d43e910025d65aa5982703353568bdfdc0254bc12211dede046f9a5879124feb18cdf99a2b86bf87ff15584210a1c8e6d3583bbd5531ecf3de521b1a046d276905d0bb2ad45e951c521f6256f879651d9a1519c1300e67e28cf1229148505e6a557768fc3080cf8433064cf6c2698133f5f1c1fa5b787d32ae6fc57b0b0c25751453c4edcb27b5afbf2df4bef09b44d1193862e386f24042640ee327de926e1548ed0576b604ea76b60b681e42cf40aa161bef8ac088f55a4a3a5615255adcfb55da7c8b8b9a8ff728b4cd2062527aa9316eb679f68c2f9e473b848729b61be9fafdbd864ed0c37823e30a3c253116f34e470080efe6845e9aee61c6e51f9c000d747c89b2d13c53690fe62de5379668d31f0ba002f2cd54b6c3ebcc4214f6be337795b35ece63fea20558becd615f4327b948d3819dc6817f7314e2bf2b4e140de25ff268a52bd7b1021381edc270e8538f91d8e647fc35bebe51dac345b96b4cd739987f63ec81e9bb61225e010a36c7d7c3ce0a7616047cdab89bfe36da92177962f622d50be2dc4df37b4449379a27d14037809e801976d463c6a185721fcefc43f9240c44041786c68ce7f53bc9608e52a944a9fcbe194266158b825faf355fe766dca83cc7ae05d00216a5ee75f00e60acc17a3a3e09c007f4894a780a431bcb1bf434b4891fd661b1417631a684ebd1261915f746ad0bd37f8c2072470a5f1ae27da5cc1edeb8a9de641be96a41d73083c5e32123a81cb50ce097dc0c6defcb45d1b479e5bbf90ed6d9ebc560d7ae6f12848e46fafa59a4044c07e18b1fdb037233dbed47e88d12e890f8081f9689b827397d9b0341ab08a8f7810e53ba22a221159aadb9def9a1f7822679a1a407ce2095bc153cc4f5f62699441d286ff915b5265671134cf16b36fda8481c7ae4eb5bbb2b8818d2798816a6cf3fd7a4f63693be1cecddf5c57749e41047f85d8fc68f43ccc832748684bc62e3a29a2f0470efb564000198877b224e7ee63c5e202edbf2a1c80f099fa06f8cf767b9725a517f33bdebbfc152b25a67e7b7659aefa245d68c5f8405db26f54e718d31a8dcaef7872596e664fb5e76436378829fc26f35625bb226d91baa45f19b483d524b599bd6b8feb8c18531c6a4836fe4c82d23488b62089629e5d3dc34589e7ef670c524115aeae7417dd243d0e9826228828027bfe8830d371143c31b7b2ad22da9185cc124e1bed0fa7db0e5a202affd5ec5ec622fa5592152878c0582ac6f4f98854b3a28b79b3820f621e4c9212c4ef73f9b73c4e25e934086b789f9eb19d18adade0d228c4ca8cfa61f0f5291d739cc582045f9fdff12b464d60b33a880485816c80c92f33ecd90f042f8a449ad0602a2c74d69c9e420d3f48d65683af82c31e4ae66c4c9edb24ab553b673515f152ac5d4aa5df39f3a77157c5e82d292672e8a0aaae322208b61ec5fa5df54ea25e93a082a25b9385eadd4086879ab51ae51633942896c00828b0922c7eaca4b7c9b513854aefc7f1556c511a6af0559bd5f0dbaf361307299b11b12166fee0014704eedb4f9cad4ffc5cb2bec27aaf4f3fdd2d7d1f0a5966961fa5e29ccf8289145ac4a47c50fa0114950f4140fe9b0a6192ba9acbba1773887a1f336b503c9426cc86d273103c229a70b20087c031b651c6b5bfcd797b95e2ff51eeb26b53607ef6ff2761f4e5b9469a1e8bb16e871022f5fda5e51e13484457c2073c49501dcaa2cb0547a4d98d71c439202725c1aae42c50c231c7aaeffa65f9d45a4b3cf8bb091bd6b773d451c4d043d161d55290d1565649b45c54a85b91c281296ed2b053dd2ba88f54fb279fe3039547d70c399613e0495b028ae53322a281c66ce7490a6beca2a974d27c6816b6dafba8dec39f823c8a574a360f078543fb728f7b68456e31f1f9549c803d8dd3285d10b9e9843b1409f2a62c287655381139b6e9e4a9b9c84262bea9af143b5e492fde824dd09e3b6ed0a7531c3423a08c9b9774e1c62c177808ae6f98a3b88b8859f7d26e0da6f86382af4b46ef1748d628f0316b71d046faea83871f5aecb898709b8719b1a4827edf67947ca6efbc87d15976e9384e9b3fdbc1c93b3858f75c224dd64821fa99b6642670c9b1530b6de20aae432c2a97a6f507f86dbbc3d15834c56a3917053448cba20d6b1d36e8a8f103e3b054045ecc436b90363c728e74e9b7636ea862075619584ff8733a2960f8cc6a56ac060276076e48d92d34ed3205c59cd9cc00c7e1292034c8b425acc2fcca2688dd18f869b8fca039451bba4f15e4917d27a892c501c85ebf2504aa6c5b9b838d0a3f2ff8dcfc85e0103f9234d4297995d86d6641d363e8de12d390925c75471d6c53e9f578da29f1185eb9a623fbcab9646ee954016df017d2b1d7fa5c64bfb47c544b1a38c99238afa8a1c91f609345e4b0c6105735b8ebe9cfe9a07711080f40a2dec9815b50eec4d42ddf4b049161abb6c6233dcb2113e885de580c86979f539829c2cda54a2aa0697f85125149b10500966994073290066c2c651cdede53892422ad51795aa6c781aace72c67142633cc15b03ff7089f6ddfa9b83548e1ecb42119d17f7438978e213977d464f9604fa869d965d5a8179239175dad71130687bf6c6fd90a1661f4d9082c6bb19e35161942627574fd36f1c82e39dbf59a3cecce236643a7244689f9048d7dc9c4830a923fec43c7fa2d36b86b63491d5f7eeb92a2ffc78a91837e37dc03de2b4b65d4b372532296e26205ba8689f673745021c9136187df7a1643b8a105e396f4b5abeae087dd92dff5dd06ef0bfc522e11794adb45ff00e2d243092b63744f45d01bb01d15885144c1da57856dd47caeee1183f568a7130ad214e2a1f26d95b72d65ea09db3ad0b02c6c7c5bd1f88b6b709f532e927233561971d5ee0ec3d7204f7d565dfa71c01c15de5803d10212288f0cb252851b627dcb0380be7bbf31b415f4ac0d0dbf72cde60509fce69044e11112b576a1a1cc09dca450030c22158c0658d1e6fbd141aa98f16dc8bb0f1d8177706284ac7d68faeb97f94e6959202123ae909419754f1d6fc30e4ce8bf6f142bf9195e56fb947bf1e33c40b69e5f658bbf44233c97fadd7d4505ed11e73bd71757123d3ebfd39deeb0525a5b57be3a3575786fcc6d86386e7e59da0fd14fcfa0ef9210a1fd39834894d28f54b2ee0d573cca22b9723f932aba14dc27c8626f9ef6084d71c91da40677c0cd921ecb1d66a87e90ed428d591b39f001485fb6e9ca7698711259153878903e8168eea1596b8b19bac3a627d3f96b13950d33819c7a8bb20656e91a65aa62102c8fd582dc3d912e89cfe85410fdf6302339a533d02ff09673a6cce7e002fb7bdaca3245675d8b9fcf208f5b31ff902a2feab3c638d788b31673d86921978cc3eeb69268799935914133b7e1e9a25e6a657f9b558f22e1cf836b625e674c518630023699949868f472ded2a0b1fde8d2730112f8ab0a373cd64fe74a0c4eed1be8717203bd5c98a55c45740dc06844ccf9e3aaed271ffb383cd22439ee20843eac7938bc967db5b5562d35ac1ecdb7c787bb2f0c892e0b193e88911718d7e4858f4b899d14adc0ec06f73040e3393b1f9a350b22c9d6353a1d53b122daaba61c919620a3767abd370d9e6d84de53d32a73ca6451ae2fa6747a56437c66fc418354f5b7b429c202b3623ec164a15507a0f75e9b55e59da8c351a43f3f9174dc230560e903e4a2f14b03235072f9d0f840d955aab2b3d252d7c110be065470597dd970f4c8f745541a13bf85a2dc04f3ff3e8bdb7da8b64f47e5f8da75c09e7ffeca953e87b1f782e46d3c24892a3c78016a591e99234c9fc654fa3daa52ca379b76d42f88cae500fc4235724f1005e5473b8c0fe639b57931b520559d38fbda32c935edf0791e779afe46da7fdc59266b5887aeb15d24843c3cba31f44674fd154436164f6f36bfe01e2926321bf9be22fc87bc7469502f4698b1a5823ef69c1861a7740f524940d36fe56677b8d5cc3231d4b4117f036c712c269d762a52e20a71382f597035fac4ee47c20643e7c4a7e47a2a863b8e405917c457cb69e234e51e440e58e8fe28421f2a3ef658745fa3bed92db9f09f6e87545f0bad071a47c29f0b0c5a0cd8ef1c667ec83d06415a31b360de4fe802f033095ab4a0fe8fc536002bb8f79a7d83dd2f2eecb2d1fc6a8aa95e42c63f9c0a7ad71042a0bb779a285c863d84527a2f51b5e6083f6ea2f8d68589499f0bf1fb5b64d36c9cba2f46224eb62e9ba408a7fbe61f513d54161964745cc44b93823400c4e1657adc075b6c69dc00472e4fa15535fdf88ac4af4997c3bf632e5d39d52be2db65d42b444ad5ac0185a21e9841938f851095865313773a2c08a8bf3c052abc6eb705384cffd0dac2a597b21b26c0c409257810daf3f84c55a63f1636e7d8d15085f27fd072d8040f8ea71ff874a507c761af07d355ac55fbf1319af560600cc471756024d22af5eba2268895b23fb3de712ea02bba4375ae5d26d42972a90a0edebe67cf42a7875ef6452b3cb34831a301fd74315392d5655717b1e3bc169c0caf421e88edbd833b2e5070c60259e01ca013d3a12164eef845f7af02cc7fb5400184f07e6ac8681dd87d98d84648cd176ffd1a9ac2e1cd5fba9be1a2545b918e514ec195b6404b778e30ef239c49628da4162b40692600a25d5e6a2e385264cec0c283fcdccc91325a2529955c11734582a329fe1f71226ce0c7ef97d3fb5ca88e74f0248aeaba301d09aa1a197f4a59b2e757b84780c8cb66ff0e70d69aadf0d3509d6b2108710d4daf782ac6ed35f9ceebceed2c02ef9066906146b6541d9cd205c4b4cc51f1b96ac2ae650049ec0fd4ae6e09aff1474b85e87160ca7175f8cc46ea1ba94c60d884d33441891244ec93510b732c33c9c395b43e1f3c21987424dfd76081a1b05c242f87bcb10b0c7fcfe88e7462c5ba38b3def828948a56e8155368875126e23bd654445da20023ccc20f626bb56de323da830077a296b313577f976ea87fa04b6ab4e2714c58479a71e23a16112dafeada6973e7b203a5c613cef1cff582522f9b463ed25bb5eeb9fe213c3c7edb03001521af25ca768a93dc06f6d201f2263e2dd1761386c6ff704429d6d491f7c5a0525d1e0ad87f8d7e7f3b87157ade9941c50d120ef610ce7c0fa12dc06e1705cb9cb0e959e308433b687313ea29d6aaf6179684853f5db3ab608b7f42804be9aa218020fa9ee2416a3fd6e4243b7cc25986338f4ea07a96dba38a62d201f9c44db6b0d56b0a4391141b7afc542c954d98a27f3428ca7158f9a7fb1991be136ad90dbc642f655fbd18273718e84d73f7af29e64d2e8e1aa10df7eec8b659e113d2d7ee4140bae655eee8aba40a1876069b9e1ab33e916d05c8407e5b4579bfb8d917b5317d98d1a4f64de69150d9ef080fa4f1bb11979767f041fa8ae7b8e316dd86ee22c0c4fc2c3ef100b202479d847f7cc84dcfad43235b58db36a721b0554e19076a53605f2aa92f2f5c598c48682f61b7625d461d5b9e8de3059acd6a69f699f8dd00c5c4731f23e9b6401aac7746d6edbbf24343b386c5ba0cda827303f2b82ec59792235612fa82f2de99fda350c4a0b691f974f1114c862402b74ad4388218c4920c8d6de1f72423e99cc2e14894b99918606199c0f8525138c157e8954cbc07d1a6031807b1e71b0a4ae3936b0f34df6819ebe36c3ca9bc0bc7bb9074709838274ae70200b9c66763b0cd0e56f777b4c808a73e4de4e08b2b31d291d5528eb3ce05f9c18e7981a22ca158b37a2ad83969c9e46a09b29318bdd4d252fc679670dfb424ac851f32a10f8139944df53a942ecfb6772d829c44f4170184a7c9e3110b4ea35ea0fb6db0a28e306728d7a20537f7b57c0842af3f7418ff8a08b4c27d11c9538aa1416c1ce605cbaf762dd1093de7bd174149d17d921a33f1b5cf918ab3848ddb5fb13956850f13d7ef3c6b9808f75f5a6bac406025f35a358b0001357c0ebc813ac81156233d43c786b172ad3bc9cf0cb04118c6b919bcf5cf7f7c0af45f1a6cfae096b8709a42cf81f3a18724d9a1f7fe323618611b87793f02aa473d1607328174612e3b71e9ebd5e0730f1d4b21735fda0ec7255d6db7d427a5500d62a2027b6f733d528081728c32799e9af23d2ac99deec7d4953dfdee9615a6feb329374f846d6f676d0eff12828453d6b6ee7d850c1084369ac0663ee721a269c6a4733e5e7167ca3a662e1cba48f67038b214a1e53e4281625e0f62b64ee73a224f1fa7da4ecc7a9be05814204ab404cf5bbda3bd1726266df77d3219ea91ee90a1dcb2ebea1a6ad621aa492a02ef06363327f9c8992d9dead3f5910467ea692d0b83806769a7212cc9155bff0f59b63509a655454e1c353f44b76a82a8bd1543d16c0e7b056582467a95b62e291c6366dca2d1bb3c4d6a0b999d3b33408fec2207a4f5aec36c06c537ac83d52ad80d02742f6b3f608c02e09f6459b9cc9369fc9c01a0dfad63c61492e6bd0015db94467a36354d9d91932729e9b82685ad7a1688ea8ca673939deb740fca9cac5486f691ad38ac915c9fba8ccd7b6970fa79ecdff634a9eb7bf5ffba61cc8e1961b4ac83d778f0ed6f8bd50832a2ee53b1ebf94e6e9668da321e4c92ec8b7586605ee8257d384f84de688bd67f881403f86c1f203c2167827a7ae8189a41e6d41f22a21404908b57d4c541487e766847d6951490e32f938a43b8e0c38a9f079d57a420b94e8a23d2a333f0f6716b5905a184f7b37f053ee4f650138bae85cc092e1c53f90f88b246ddd9f5587d617f5317a956ca77c58e7d73be977fc2f33e8e976eba559c60891a5baefb8f3229ebc2f613a3be7bf7f0833ff1e2ac1ea44aa2e2acf75a366c8bbd07b062078646ef2589766059faea00d060db9af89a7a98cc35ef2f3fa30cc11eba68e77d7e0b498e9c08818cdd6b9f6f01c4efa4278c884cbdf8009159b451f702b79e2f55cb077ccec91394ea400e27fa2ff7218a8e3af840f539cee5670990439e16d04f88774d52e72429993c189f08763ddf01f735fad967f3781980be905f4d705d08bdf651995c9a0fa71b6844ac2d1aa4377e59aacfa957363bbc8fe6f26ca55981a8380e35345fc26694ec474c507283b9da3359fbd9e0c7231efff060a6b1b3a01db3eefa0420e721811b6cbb4fe869ed55316452dbe21a1b33fafd05ca10bc116f92664ea09413ce5cc752c480e1d10330204c48adb3de48cfaedb1b767380b2bf10d7dc9de7d7e01b15cb73dd184fc40c89b2d81de197f89ef3df3e39697fe8523e58831abc388cc5563f2fbc9aee85fbd4202108f300a0d4e709937468b4bf04463f6f269b926b8d3891a7aa6113d536831c821feb3eb2163d8d53799f39f9fe5d142964108315deb38982d86a712d9050f881ee4812d464569a6cfd2cbbd50caae5c6ff09d792209b74b2611af99c329292b033ea5413f50a20137cf54e066b26365e6a602cb86cea77b5922860dde269c1d1c4574e448bc340d7818320ddc82df76f32bdab0ac5a9486a69ef6fde9ae49d07ff77562d9ac871bb210ffee8fdd62615abd3e3412b9e47cfe2608dc88b416da9e4b7b57e2093b07e0def650deb09935eeab244b89f38ac9a39c771d0ff07714f1fd32c64b670f9d4f4d85f8923a02c9c5e116a2f28766d0e0d7d4b3033f31b6bc494673dfc01a0682473cb124ebdb2b69fab95b4a27ac223f85434d05093bc9ec792d6f9ff267d4e570eac23b862eb63bce847b90a2965fc8104fba50200af58d438e21825d65837821e65ac499391e185e960cdd98c5a97b61597a02a5db8637c1288942067901e97968f02ee0044f88e3e29947de660ddeb5e4302e49bcecf3cc606a651040ebacca8e1b8b8925cf40dc9f8bdd3afb9c358548eac4dd6b0458a51d9d988ff2041c142a2b2d9c6b53c684772c082b59b647bd3aa39e22fb8406a7b56c4a39799ac2dc878bba90336c0461d39f7e4062a76e9d1f3532fe6c9ed8a1e83a4fc757f430114f5aaeaf92e21668528c4d0dddbef81d0d0b403407fba8dfe2c84ec58e9a1db1c076a5f1f7df13dc11bdcf1ce25c88fda0494b043f1be36b0aab7f9b57620fa4f80a0482bd70290d312e3fdf04529f1df2cc944bb095ca6a0c6356dbae3dac5ab888532861b43e514eaf97d6d4eb4e7b654e94e1487faedd8a9bb61c05bfee918776540193ded5ef6b66983151b4bc8cc6147fd1b01ff5509f7f8a2bef449df4effd6301e7150046537e4310b62ad9ad7d53c3235ae1ebdce99b6f858f16e4c29130b27435c00623c24b4a533fe67b0f89301d71bfbb3f3c69232896c97d6e92082dfd71644bfaa9d0ba7995794935ecd99772ba3aa6a47eef059b54831cab6d7b4c512f8ea1efd0ffeb97fee8fc52866a05b9b234582b4e243f62b27b84efb10dfe232fb204d1d4f6221307b0102042e84937489e2373dbd90f9d4899c999c70419f48a23d90f29e26ced4753a47e1f0f92687c4035ee05173f442a608e5ce81a7d3a26f238e0b7fc4a9ac199ea97901b4013694ba894ae2b0adfb7c45a33a85cfef923ce0e9629ba0890ff0f7dcfe1a1d443c4a55ecc4471292e7da7b5debf0ad850813589c0adcbc07b5dff40c674dd1b4926afcbeca492f524fa3f4cc86a385c43e9498f5144f0e01f1abf8177dee6e99ee6608c4f938ea982fcc43113c73d9b919cb8b369e62916b09909bf81633b42b67829ebb74fc6bc1dc9ffc9bb9d12b194687b52aefc0a9ae15f2e9c2c9491ecca17e0f4a68b33cad312b6c984a984fba10dc3b46554cfa06af6e4fc4692ce901ecf984f86115cdc9614e73a796750e1d5710376ea5ea1ebbacfd2c8d387d1e25fdd367aecd4053d7ab10a2d30b5562f8c641e7bca1e5f3b58592f5910e67408a69c9da4249bbcd695a5a6e7a8bee062cfd6ee4393a021b64662245404c3c4d9008eaddadb69306090c8dc7757a68e2d799f4cf4e63ee4389eb14cbfc04f626b17194812328fdb8f8617c4326753b971966d41d5c2b726125c9c98985d24695d5fdfbdc39458b285dd6d371e55d507d6c817d0059f5c30359bc4306724b5864e5d4cb9357b786127c0b943da25bfa3ad5705680818ca9c1d27e2858081ef20bf7e037439c4da9ff94a8bc093c755579dda08837c6fdcae3aaaf0b32743e40e71753110848677523d941029bad06471f2de0c6792b016b0a0e10c36072d0ef741b1166a72e89dec185c43761f9dd1b40cfa6f8389058f941851ac2c443465be58b9bd16d5cd9da5187460be441e09d21f7ddb973a80f84b5e918293b50fdbb60e052cf156356ad8007def81483d0711de71be28fac860ee29ac9e4253a31ca0c9fc2be34324f0b788483178ddc6c7a184a2cf8c574255c6f93e5c2b452f41d7f4316ce4e872f2e38f7a242ae032da5ecd9e78d16011d1099594726a3c1c02c13031282de0973ed183d4ee3c5c488fb4cfda01f5e3c404f6baf5c6765598e4b97257f547b6b4a38c7fc3cb57eb4b95c23a193ee57275ca5ec790668d7a338ac50b045fe92ba9168c335995bb088ab99603d570cf2fef37c05c878642d0b490604d4a2ed864c016fd9b0ff2ec627473e35d9050a5306cfeeaa13a151669ee770c81ee1d35b80bee3860ca4819134e278baefc0a111d1c3567580eb34159522b5f3498cb31d9bb0b03db6811c1debae09242c8f753782045292999cfe9101709e0e6727293abef885c784993e23cd598a0576087c537034b63d25903bef4c106f989c1b27455d9fac7d20346f5ebb217d01583688b3eced50f7bc5e19b02a8d2aeb0f1ad1107f80fed4bbb9ddf60d17b02f6bd72a6f13cf3f12a59a0436c68b701251093951bca148cc5786b41556c56c2eb2783a5ff38e536f211dcc239b127d86f58e51f19f6d771a3bd3a5780c4433d371b345fd7b031511493ecdac458c712d63ce8c3b3600ae62df7f573d154e2f9580fa4bc6e0e197264c1fbb550f3f1cf22e97a5ec97ae684dbccc9db8bf4ee5d488622bd96251768b059761ef6882963cce26ecedf61812ce1ae41933446358e8bd8aa12f511ebdbba84141d1a83e0f5c15f06611d1db40af5daf63dfbbc916235d9b4a210da1e2bb5bb6917e78dba0051c1a2c7cca40e113445af9134257e2e4efdf9e54cf3242c13ad54f858a46fc67cba8ba635d03c1bf7b9e1263942b511c35aaec0732065b49afc6078ed91e301115839ea424bfa70f98e3f48d8715615e76d2d52c501c5c208e17505e198da06a0a638413cfa67a60ae4de55a1b846f86bf7f0133ed63cb8cfe9784c0c6f882c232a9e5fd74f90de36ae01a87cee8e2da33fea3868c31b36d0ab35b9c0522cfd1907325245573252b05efd548996159279f4038cc07ef198c79abcaf6e35c30cc09144adf0e76b1fa55da27fab65419e7103703517c1161cdbb0bb693eab815700d52740c5916040e358c49fe2735bae56ba51640452493bb11525ac75d23f8ef3cda386938814e44ee9b6cdb9b1497fb276fd4400da07efa04478bcc2f0cbb2ff560da5f3a9a634b512c7baff1b66738a86f3d72bfe87e31d1a6987877d8044fa964c87a0efa69494275af92b0e9c886a357f67e51a767e24e0581137f0feb2c77fbb3c99c2e3aa5db0206e0920a33fd42b2ce06ec5bd662cb05c1bd776ab0420619419187f7dc869d16a9ce7e9f45e117e15cafb1192a92cedb15a77479d3590fb97ad0d98f83adfdcb1afcfee2037c193819fac6a48badd8b0aca5a6a97bb978966f1561337e4d14fe5d9bb200f53b5897106149ba56fb5087d8214ed9efd488a6b274765452fc18d0941d77f5682460e95f3ecba6bd8040e49e4859a552e244f5a9c102a85c66efdb58dec64d9bcdebbef116699e281428f5263f12c8ad48da2dc9cebe917e4d85b9cae5d318cccc3f9820c7fc7d6c88fe21ccd7e3e9c25a22d1f72547d0824f444571d6d545a9ab126430b910cc985dbe9637626a03d00b98255737a850b14026e9285c7769353042442081458f903ba18b52c8dfbd8ac0f46541ea1872012eafee2b3a0f57a9e8c2fcfbdc342be2bc16d8ff17338e67bdb196ce116f56ca4b0e096908d1b786b60bfa718f190dff470f6d157f33fc29db602deb45039b2c90b9606cc9f326d1ee21642882482a69befc9cf8c99ad4ada42b53ab93d1f0cd9b491927c5a0ba8708aaeaba406d260d7d6e86d553ffae7184cd1aafdf4577bb1144653179b4bac8ee77ea6bb89be82be3f379549add00f17baea44e2b69950190c9f316baf0183c85a9ed4eab741de53664264976e593722bb51423e0d33544e75deeb27e3152d7a4fbbfc8f7ad1bed71a07f4a6aae6435e840e7f3af472706ef8ad76d5384ad5e5596d89e731c444caec6fbbca107e259362444074ed806df4dd8f6ca56d8eab581a471b7b27aea381430e265028e47a245cbd59fc8adb3baa0d940c8c3261bde92446c9ef34be1bdb0058314de41f570ef96af3db012fc8d2c9def8587ff4a920a1607456bef9704f3b8cacbbe3f25375d0a3a9db324faa3e920fee87d5a8ab765fdc3e722841bb138c4103ffb1598f42b438be2ea27d04526ad6266a386349febc93c207b01688afb307815532550d2107d1cc93cc659429da19ddac65eba22458a878b99c08115fad92338e8400d47ba034b7feb95bc4c42c72bc192de2b94104fe1c64418dafe82fd3a44d1e2c0bea0a8be59a36d395a92333132b01b7d85fa83806f083249c6ebfca47cf846b869b906b5c1d4771614d8d3dacd2329ba16985b4ea2ee4429d6ba502e9816acc28ecc75c1befbab4ea50fb1cd83876efd1f886c187945c682f9cc281990f0d1c7874a643f0efd047f61dfc2a69a3316291668720830b6219af2c6ebc40c1052aca370da46b7ff2f722b71f98f082ef4e3fd41a8dcb2a9588371c70127159926df7d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
