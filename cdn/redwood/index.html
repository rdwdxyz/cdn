<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cc9aa81f72c41e52a5e794887433d1c6baa7f2f4b1f8a82a93c08128289dc8d37d0323fcdafec47d0901ee2c7915da8ce54ee9a43c40331557074b6b5eb44bc71b650f7ebf03bec41d902cce087c5015b420b13899fc2124d930500f06953d2d443638faa6ba4efcfbcc9492b7c9f5638dbfa7864d913e072e01b3d6547b8192129b5bea04b3e53ac420f915732d4b06f6f6db5539f7313c1c639c9cada07c3c5a599f308d1029d6b0909d677bda4f8069f80b36ed9c306689ca691c774739577f6600da9c7e8fb13dbf350eb58f4200e2bf473d60aef44e55811a24fd37ca63f0cbe5a3923c737f58f175bdbe7c8132ac2f61430ee3de3a3b8da13fd01407544e61102cb57499bd9dc79f4140ad29a349210664cd1c8226ecc2dd9f0d52acd345ba17fab525ac6b62c6cf8e512f8ec041d6e50b1ee801cdcfb5f117480e17f09a2256f094e3b16b01077b1ac10354d6b662caefae56ff49f34d8dfe904a75d787c9e7d9eb7ef60eb08fffda6919ac53cab3d46c2976156cdc101d2068a0ed7135cbc49730ea00a2203f14dbf1bd71f549ee5c754296e0eea72e868cb754cccb0eb6b3161d3a9246880a16a730da6be2c6c5a52027e1fae86d4406044e90a70c2d80077f3078158b025f7e9ff428ee76157f28e7ad311e1c20756b76f8b766ca7421be576592eb578635502ce21c5cd456ad37ac9c8e3b08f3519557ceb66f68a9a7525bc9cd99f42e9700bee9674225a5005a1c70eec2fda8ffc78dda57cf80dba388166ccb7d26fa383c5b4c30b3c41d01a75269ec5fc6d10167395724051eeb4532116e9a4429154701fcb7a58f3be27c6c3f1baba55600f928f40dfb5606729ad41e7f633dc9ab323d60030ba23730c4ba5cad54ac2bc52b1d136e23ba3070788ac9dbdda7accc51cb459a5f1f4939f0bc8a9ba5ad46cc3bc1390ed1c9e9f42ee038a3ee38ea7dccc13ba38a82712ebe9fdadae3964662f943da3714993cfd085b81a81f2d676b36283bbc72270cc878aa329853a0f11ec307c111e6ca1d3c85ae1b7b9ab5d11d2146c76c1f43f4861c78342cc46c850859589a519b045a9fc54624afb0fd50cfa615ab4b2c3ad8d3592279d7b5ed652de17efe909c90fd2210810ea95b60157eb16318c2b690f14f1bd3a57aaba7694e0f389cd32848a5c06000d708dd609fd0f4adffef7a7484d84838408d41a14b47e23498f723f3e3c6de9f42bf2b5090e6d32d2bc3bd107f9f95e55e1632393394faad2d92bc02a4fe57761f392b7535cbfbd0c2bc77fc5eec4ce5b7297a7aabe54e0bbe80361ce46c3fffa17030fd25e1444a1bb71c8adf4deb52925dd25a66b8c1fce39455ad9d9fd164615882fdf5f986f7a9efe12c6d5830b99e0d9c0fd928ef3c41e6eca65ef9e837ecfaf4d0ad63c8bc906d6ff7e85b8a482d27ac3fdf263aa91874b1c1028cd179ca0f3b599711eb6bcba3687019f476bfbfa9d826fd9916c0f2131784c2c6548f4635a0587a5a99849d3d31ead9b5a77e6b511ff2d347399e3f98c2a2db133f2990049fd6f20d7a19d83c9e756a14bef81f5e02ae059cfc115bc60acda624fa395fd437c520f4520b085a61fc49b1601534948e1eb95677ee5322ed313e55d711ab2132651f3f7996198761e97aeaafdc06c8f0437ee3e11be3a7e116453639ca0d7f859b7c168ee95c09562283e07130ef7f29e093fcd14efeb0659a144eb553a15dbc32939c4802cfffffe0522bdbba36af072452eec1c9f8d990b1ec17c1b5d91f5c81acf13c4014a70ee415ace01a859a7f19fcd47af6d70eabe368d3cc6f6df5c1786fce01176673fe527aa7a115affaf4d023c0c19029b6c1deda633b7550281640343e563eea8b0356724b6f1fff93bed0ef5f7b0f340ca1db8aed675a81b33479c805deb860abae2c661eb3ed920fb8b47226f2a29ad0ee7441782c4b13ca262dc5165074831a6ec6ce512eaa010bee026fef82dc3b13129903c6f7ab7680af8f34ca1575a8246b56eeeca81cbd273a22c0fd1e663d72c2c34bf31f67e9e8656511589e15f47ccff38b3d34263d2653c6c6fea5a7b8c87ab46569c3fb827929872e385a61ab96f3da795cce3854ab72924d4b7624a87cfc5dde82fcb5affecdeb0de3cf77826297f68815d6b5b8faf151b9c541bed22ebde339158374bd598cc41753b09275372af93b96be96ef69cde02990e00eed4e8b13ccfe3e236e550377d226d6bf891b6cf9be0e2b6013780df0192eb415153b63463ec2529d72e43c71c8158ebd6463cf5fba530ccefe917e6ca9c42c91a27e18e54930bf3257e8457c6ba67506a236f0cdc21995f27532d3b193cb27879fc6bbdd82935dcf448b8aca3791de69b640412cb913c36a85f124a04bbf265ab529badd37ed579dc1f56f16f8feb82c5df3998afbf676778b9bcdfca0446ff7c2ec6cbc7bad833af7ee7e07e6e14f4bb1bd69a468d940b56a5da85cfed1aa1956aa4f27b5f015db9b67d5be99f18c849f810b6c4df25c7bf9e7b5382d46c0a4a866fb5e3d605e7f41f30f3c62df404bc1cc9ede84d6ad07ecc625361face200736b3f115fb9a43dea3ecb9b06a72341e4f122a30b2aa8359c71e3052d9f5fcdc12797f4b06bd9782103ca4c703eb2c803e6254dff4d762119d4f502847a8c28953b63245c28ec872155b416b12f98d274a63e5fb27fb84b5a837b53697d47872fcbc38e92882aee09e353cd0becbfb17575ed0f0f806a48f2d4cc8e3fd205404b8de2bc80b2813de8d0719b7153aa95121c5aa7abfad63224ddb939c9993bf56478a3b48f82f330506580c35a6fe61ee322f5b4ef6a4fa2395e74e903f393382a72c7875618edca23723d0fd75b9023b2b3a214827b6b4249c2ee9993b27f280e31df608bfed3b4b64eef45ef56fe5430d8ce4aa6dfa026077809a6b47b79fd1c1bc790d38b8519fa82d2c7a6a1218f8188a8f82bb8ffdb9075ec86babfd545a7c4f0339c14d3791385abaaef28205be451d7f0c9b6cdb11f2b90ec9d0d398a08438fd0a7fc026474bbbb23ce73825d1a31b0a4de15302eb32beff36549b4af822680dceb9cac3481315c6174e91fc66e46fdcd5f918803ce5ad9ef4cf909801e849d80d9e5e4d0c416dd898209e2cfce566f029a1a465d205e08ce667bcce5090223595d96854da37ff1f3b7e61dcbe815a5a302103dde767c66da6f0e8e0969f907c659cc1f46d2a2dc6222f3b05f24c4605e5b85121884fec7974e033468f806749296337ab4389cc76c066da719756de9904d9e40a3e606b6e8858ff72bf3e1719b582f652eb3696d141fa22f5cf54a25abdad09c462b87b1ff0208f57dd5afcda34dbbfafa4ac3b9b7a0b353d6a78546c48491ce3bb61b42e8a4944316960c921497a1b0a3b8b693f040211403f08f8247d7cd79b1dece924da53f55b61d401c8b0fb9171e63e3f0c949b25e39883c6bc7c9aad57308f211ba0b997f3934f941935b871a621747261bc23bc1dbc3c5c77ce9c90f63cb6c20e1346e4a5b40b28a13abe0fc22274e10de8fe45626cfa7a3c828107da9ff9bf00cc0ea792c31e190cff1eca31530a35bb9d7a238ceee54ca366eb6b89e2d83ecc136980c90af968738df05d5ce4a656d691b689a9e883a0d311cec822735b15aee4ad5b2f6372e786a25422cd150cd9c5297c4127e9258cd4b68f5ccd5cd25d33d11b2ec7ba63525d6291d4313514795ed0042bfdacbe05c0077e121ccb77d73c38f6c21c0db4805b55b799310d432a68b7c084e61f544ae11a706072905705574e99ccca8c99233e078794c886a4afc6113265eb8d3638928495ba855748b1b9b1f431fe1349e70280e050e81db608651ac8743f1bf5c52daa723d92491393d160d1fb9d1d8eded40f9050ab5837cd28934ff8bcaf66a3320d0db13b3354ea7251024fe1c285dba20eb788a8e1c0f6da83c43f62a51657b20346a10d548013477207fa7357daae5b5611eec880c773032768f2dd1179919d00524e9acdb2e14a20ddea60a4b5f3dedcd5cfa066152752c77d0b6855116e2f2f07794b4d5cd763a218c2d021e2673f4ba0e42705238d80b076c7a440545abe2a1e6a502f567cafcdf3152a1b05c399458ffa2282794e9832ebb0b90d368434c7e1a1aeff9bd69e57e0cbd487f2143a5df98d83965b2db4d1be0c1878dc295987fdb4155fec9224112070669de74327aee479c0f5dd66147012080c0c138cb55282b824ebb71a6a1134bed1ca6334ad0cd75e840c38a1e8940f3bb9ecbbd74437730406c1bd2499abf83649401630232b77baac909c3cd210a653e79c35af0f5e2e6138dcebc29fb88023018682d7606594c10c8347bcd48cb0a41a03676a0290e59ead52cc5f16a5ed81294c8e999bf529ebd746009886fb51d4e08a8dc1a77d83ba650a006e22b22a91b6ff48c96661dffec13ae44943a48ef5f08a3bba1e8b1e59dfe07af0406ebc0c681a7551992c68b86039950c15cd233d96209cd736b9cc5714f6a52a8075a99e13a57fb47d64423146ada7cdedc02a487f6cace3f974ae700c043d9bcfb18d58bbd50d7deadc9924d92ff2975b8b9b7e6ab11cb69127a7ae0c0dcb27f9bcd74df16541d4b454c683dde493ec77d53566fcb8ca136509a341adca53cc37df93f0411d94bce3d5eb7f3f31a2210e9b60c3e37124aad456c71a45cf33594256e99592f5ac7ef597ded72e07602cfbb5f062f3129a85e989c1b190027d475db40c994026b76163578bb6cf742b032619d3c5c786fe88dc180c3923bd68ab1161407d8de123aada8535688772a0608930dc17ba40f54e61e5f102bfafd2a2aad5a4655735dc305eee256a924763a0fd099001668228df1e785afb688cbe512de97dd1a5e7f082dfdaa21cc2530b9449f27ea58ec6eef80316f4ae090a9ab7784d778acb93c05d09550aa647477b5d49509338a06c15c8b0b4a6791be4c7605f5956b6059417167cb175d909c7aeea0fe1f52e4cfc54a30d0a836f60eb5f3d93367524587780f40529b5ea448da12b59eafbd992f10eeb3e018611b3e1f33f5bfca64abf6e44693f6c2c8ea7e00e1cfccfa4d46232519a89f4db581a0b874751a064f51edf78c6e143705389f85974ea36d1295dad88366d33190fefe8a8571aaea713f0f4ca35d54792e46b7e5a8a81bdf226b49475543618529d83db4f511fb785e3e5f1141922f26888a334526b9547c461ef1d0e4befae980768d8bcb2a1f6be244cad32c03ba7ffab2c1256e0e5b13149e850ea028d9b8d030932d1baed2e0e051bca8aa934ea258998db26d9777acb65cadcd68e60890cb2163f91aaf100fe0568cdcb8b7b041793766a7f2f7c35a5995d03a72abbf02f87e1fba35855747ea71b43261e36dbe3efc339532e4a1f0c4a967b067f66ce1ba4bdded4fc45f3098a51cf62b04a362f1271f02881912e897321df3b1c02e1198e5e0fd196076c222aae70b7a87f93a40e36d0f05da7e892ef61ae6e0cad17d6605d3dd8711aff1ba2c53e0ef9683560cb656bcf78e33c31ab7719aa6eb206589c1b7a0ff44a5878cbc0c237f42917be03f10c28711b92143987bef3a100b431b59e56c836fbf10130f3bb51f94ede0fe8c0e9ac1255d2a4c97b71d968ff70026d3747e3f24be85973b4a1b1cee6eee778d3b5d9365298d747b983e48d9ff1c99f4ad9a70ebb44dc9aaded9134dd22337c9d1ad497edc17c872f5bd2f6523835c26c7305f5372f058d59b939bc217bbd78e52e185f1275830ce4a2c1c4b27f3e3a842e242874581b468c80f592fe56add8fa533daef13217fb31dea1257fe95718674d2aa98bdab02dd6677bb6c607d1f72bccb2558a8c6fc6d243ab80ccc0d2aba327b04fa7e0fde89e0fb7b892eeb98a3bf01692f200398f34dbd2defdf9ba7d24aae48e1ee09c466e8728a2c954e12297e5fa850957adebbd36681292419b199c1dd2953edf63b307cf0d06c6ed53f09e1beed8a73f09156d438aee1517d99f62e7696f77018a1fa3d03761bcf8320a457c098addabbe58c2a2787a32a7e4240c7ba83d628a5212f311fa11613a18cb13cba4300cf7a85fd5a38fe199e651b72b821d930505138a8e3d5fbeb6d2146535114a7d38db132b18cf21a0d68f47c9b47475438e813c8c6a21525d29308f72f6b5809155a31aa1cc6c1312a59f0fc7ea3685b483e1b6804544b61671b35bbb3339d596bb6466829eb6fdaae84c26059dd57bfda3138ba26da11156610577181bbf0a17e6c80e6a20982f07bdddb53a5651ace0483971f2ab8401ee3a4cc8f5be5f4b21b1cde2c2c55f3af86fa3da657dea888da0ffba15dc91a280e525c0655f7d50aecb993a8220e85c3ce9af9ffa6250fd493ab42adfb3fc04ccb14286080b0f9e4db4fdbe5d8b521d3d040d5dba37a56ec2eb99366f78ac1827a031b7610338c6e1400da62416b97598897bd2cc7b9cb4b2ebc7201083740a8772b0f0f6ddf25e8679ec70b47e8b7741fdfa68a009412620ded0714c9a21b166ddb2e22a9a4c8f33c63e42d66bb074d33d72103cf11a145c49778f50e84643eeabc1365bf4fd57fe4c1c6b588dd012f9859e98a92e81cb2c015dae3fdab7b51eb8ffe0c8f02e2cdb5948429fe4bddb94c54ccab4e5cf5acc88698b456af188bb13ef46a6f1af1ef1f58085244bad8d47074b6aa59669c501c05e1eb6ab8059383cbca0f81bcf95bc601258428de987b73f5e433f80c69d34c259fc1375a2c6dea3db2b97a9cf635e50e9d2ad16110211ecde32215cdea12919828d8d1098ee8ad08cf9eb1323ecf16a2e32dc7086876cad14c0c3f9f443d056532c03b3e3f757cecdb4c37b904ad07792c89c8ec1908d3298187aba60c6cb809149ae81016325b1b13ed51ff16bb261a9b696f839313b2a4efeb7d1d608c0fab2738a45cafcc1532830b9621a926e3000ebac431db893eee719d9f2d96a499984f21b3a6c62603da7b9b68bfac01739df32e032e8ddc6dcb72fd7a4bf3a28c51e585e061d3fed1551781bf847289fe8e4aca9dd308531c21b0428c209c574c32b645aefd9fcfc234dd0be6eb5b4a0c88e20e6839d2c016504aad82871dadc10bad5a9ee27131acf3b845c21ccc13c9d3edd5f91e65d8d355d0fab355744065a85f24a4e66a729a61c674779904ff3325d1fcd2f4ab5bb332715156c30f4056bead5ff717c69b66a1345f0eb40bed6a4fe97713053f0f1ced6bf102c7771ea7d52ff410690b2252373def50fab8c59e4780b64e60d1b6180c512906098a829d2eb3aebd74e26361cdef8b2efb3e3e6cdb913b3d6909725547b3c9c87d86dce724e3e00aef159eaf82f99548e7adecd268f893cdf6b7c524bdeff1ce57de57ade339226e302911994218fc30e54b8458b3aac22433e7bd02aeb753d6fe29b145a5514ccaaac5728678ba709b9808e3bc7b010137b348fe553cea0ddec3ad98e8acfe2224a7f9b26d165f5963de61da84cdb226d4012330b5a9ad1f5437273a047746b2a686cbe06457f670451e4e73aa171b25109a11d477eb98880406bfdb9e1c87cd4dda455b6c05b2f5966043dca7543fe50be528cc9817f17da98d3e4cb5233e742df4f291909805daf3b24b04b5d5fe863eff50ab7266c3160f22ae1419c50f874ec7bb8aaeb440f5886ff9f903b4f9b8ef27688a60ec2b9a81b5d6ffb207c5269fc1889650261e562e9798edff960992eb2110399c87cd69c1e2e6aa5c3d497e1af1a4a9f6fe65303923c04be31adf55541aeee834f1833e7bac0dfdf234877d4aaff31b727208c885794c127e2ba7c84dbd2c16ad4479964c98b83166a33f8cec8159690a205973ed9d683f71642571fe62aa212357c0a7d3d14692d17d45139410e910375a1ada34d03cfb567a27fc6dc9c888ca6b45d96fb909accc715e1ec81196f95d72c66dff2bddc6b21165c4afe136f2123759ca7c5b1435ac55dec264d05762b8c068517c5b53c060402117f0e3ead07a112c5982e2d99d66e647755069c7ebec4bbb1e942266ea088681535913432b8dcb662db1c2c5b2a7d5793431bdb761b0dd2e530ac34e367d9ba68e5aaaa48c5db64ab344ef22717a09cda574549663e9cb65de95d591d547c0d2e14469439fdf1628ff9b4ad5c69901517fb54aef76c24d4034b1912cbf6772c826e2e98fd4198a7e137fdc9abe87b2add815d7aee0573437fa9fe5e98cdb8d32370fb76eb7df63a0e1b9b298d6692c437d82e89d272f4e9dec471040146853bbb47edfc8f7630647bf56ee0a74c02f9f75254456c9a8ff6085d2b1149383768c2e26a48434f77ea3b2ec50e220880220a92ff0507972b2f4c8159ed648f072775fa46b73911b54827033c3f12cf2f1e281b0fad20d5da790dbe25501f52831532bcc7b6608673d38222f38fb0535f3d34bef42403b0674ce08e7d29e1a09c942bb532ad4892ba75b7f8a4a75fcf24585c53da83387eec90f6cff4eb2e3c4a42a7a34b62bc1a077c2a57251ddbdcb1095e934e49ffe94133ed28e2772f4c9d234bc21710325d04eeaf07489a173696649374ec9242ec1bf2c656cc3c59bb55b60127df8deb0cdbd84f49b517071f8088072c41244edb98cc07f2e8b0614fa545b1abb275bb0b2ebc6a6353ddc6c977648378a0ba2a96573418024aa7b7506bf164e76e39844be82757456fa0c0c57ca89a637ff7027ebd2c7ab187abc30d66e604686693c276bccde11915f561afa9d59dd3c1d7153c67dd4697c9f47438bda1387cebeb8da89d321cb378718df7454ab7f3c99d2fed71c753bd5a3a995d946e859aada5ebb952de1d53793845f5dbf911c091ac2a2ed73812d7865c4895aa161a8ffec2582826c62dd5ba43bb4c5921022e6c86d4e0ed2a2879a6aa75f95b98de83e560f6d407ad6967733808f3518df26c11271be1a0ee1ef30f0f9749d69b929e88d1eecfc05b012f6d11e92e723bca020b5dbd959e0cf66f15c80e77f8f470645e12d3b90bf9c813dbe6dacca80dbda5f0d65dad442bfd214a9f64d4d6d0f87666daea5299be1883f2895d0a6fdae47239f1396e71911f2228029a2324c4bbe1c9e595bd0a0b2d5378688df0f34f11eb6b7df348d59e42b8c8035e26f2d169585f991af1a8a5fcc3635b231f06334aac07ced399c6b4d254d7050e4ae1c7d5004505576dc3b0f0208fcd41c7e3022bcf2d5be872757d88cc21e666f531e3b35cd265c52aa99339b3f8b3648dc17b0dff96a205ceff9326e17e84672a9cc530f6485f86a84e1ac25358c646bcdc265633db55b1d195f87492af878e229c6882ac4255e183043c1b9e4311b5ddcf0a33a402f0dbffe594956c7aec29ea43074f757ad9795169e00dd1ad1eeb4c57432db9b31853dfb4cb9164dc43b8d495b93bab78979cf0963962f097556309256a57eb5c0e236ba583069bc609e662cd617344bff12161439bbafe4c00feb5f0581747cc3db33a0f9a36d20533e13816ea731a22fece5454d13b95d0713b64571af8cf2056dd0f781d07cf5505f457b0cd643e48a0a96fbdf66bad988554ef79a2acf934266a9f71020ca476c96e6cbca0cc0848d4f35519ea4ec08af01d2d6b23f1edfdfb538ba91f8da2a2e4d01253201f2724c74ec70ea9b776c2548fa825b10cbfaee1b512a4582e9854a095b9f217f41012ae127e2d348cea27b9c248526e43c61377c6dfdc8d8fc1a9e9fc919cb504a8b8b938ac49b137e251f2c3c1d3803e4a62370c6df25030bf928bde06324800d77f82996ba4c47efad2b9d5c8aad6db54725fb046c93d649b30d2f606844f80864c4cd90d566a7827375807c62141e1ddeefb3e17582c39bc141146cecc8e6cb75bd03ad39f081bb6777a46f6f3ac81dda0b3e522872cc50d794bbae7bb2c21711fc9b6772b31c2a69601befd3e59dd29092d1a9382e555231ad2e1135c6928cfe7c5fe0521a530f96995ff3736609c8e8575ad10542b79c687ea0548a4030265b0ccae5b7cb19a10a3d96fee7b63277ec8a92022043556fe830bb47878af6eb11342540ede12e30c6a9ca482401f538517dfb2ca2971e9611e178ec73ba55f67e91907c642829ef30c9364731b31bd54875434a1e2f566148b80ee6213370f9e10772b32eca044d2164ed7e2a1c3e30a44cc85a1c1a0543bfeb1e01d5d269b72d99d666313bae332eb902914e7255a703734734b81923ce39300a13bad72d41eff90a7edfd8d7306976883ccbc66e793bb54bbd418cb52f779cf5cd2fbd98a0a6097b3f3491c5fe68a55f53304d7d2db28038c168ebb268426c53f83ec24d9053421de8cfc8d9376f65ef09a924d9d33c057730cbe423f8d5c3eca564d3d6977b7a5d897b325cb42dad9742fc9ffb71096e32f696c9e976b7fe87ee35e35c718077f8b69e16c242f7d4b1b87b28c5598525cee8e8b7e8f0ef256f6c35dc79a689c3fafd9e3906a854b418cd4a5ac17652e94f53867864c0ddb8ad6146995bf5a994ac925cdfb0c680659c826972606c28a46e9a49260521c8107095646db1bdec9bde2149d86b085114f360dd50fbd3cc1a0ce0a2672fe06a6648b4e6a837b892ede585fb7fd281ee4225915c0f30275f746c837f0ce3581afc1b1c840ae40cc02d94982f77783c4eb6285e9fd13f34c8b6cbf2ddc2d8cc69ad933e3dc05b3d30e9898b0409f0294dc5afae2605e7e20f79e600ce62fe432fac3b6bd3061d151acd9576f835fa4bbea5d03e9e0f45fe70ded3a6bad4c897ca2a4725912c10a5bf76e4bdb519202049d71fa2a206cce94903d29d1a08100692cc4a0bbe7081781996798fbaa4318a91c56676a6c4d751c67af89f088e55acbf37e50fb40616a33b034abdd39abccf6141433f584b5588333ea4d57887331f1d49801011777f57e11fe24d00e5882482ecd4351abefdeb61eb9003143ad7d1127a0601659f7450d509997c408359eb9ac21a1cbe7ae86f3347c1516a636a5c2aa9f35fc9438feba97190ba0774af90414d4d76a8126d1f728d1eb9918c6f7199f71dd5ca4b0880481479214444efdeb679f99a76d2ed98805938a2b89d2bdcfcb9e0ff277e4df35c340ae4882543af8d35fd43693bfcd824d7c46d4c74e767a0101c72f2b5ecdf545e326bab95455920b4ed2ffad9e1668956606e4d258b2dd89c9e38537eda7e8e09bcc29cf5394ba07ec1b1dfb45de3488559a615d2d5e44d3680dab144575c18f1fa6efdd9b1aac7d56723450d8b07ebf6f7a7b56c86de5e7606935d4b9fdf2e31d0b838eca7b20d03c69c8cbb74f2ceeeb6265027d5128312d3da2dc5378d24c7bf959b0f7e194434d0de2d656a4ce4d5fbd6be1fd23204fbf60bba450013145065bbe48f5989af3f0586e228d4775fbd09138fb8bdc4e0396807a7f0e3dbb72ee65732e0b00210c56f8ca5c4f83aa471b96eb5fed614be92cddbdd2753b9fc4e21931afadb2ff54e6309387e54b5f33233ac623ee02f36717950c6f15e67d62d980ebbc42e5eceef191f105bfea09039b4dd4e0bbece161189fba704714a8396af9c01063861d3240b5e6a5c0bc88c2e0dc41cf03f77aa4f435bd06d3445d7c5215cd0aac261941a922b787debc3c3dc7afa9f0ce491b3514242e41c1a30522fa32cc5f27c3acfd481d307c52fdc7d6189d2170832cd85d7d526f972d60da793496de75a632ff7ebaca1d6563e21a2d7560f918b912a364b72840a0f79b0a07bcfe8595f4e575fa4eeef767727f70505c78233a95b52bfc8939cb3d2223a1c04f0395b61cb3431feb9aaecc14421a9b70bb466eb4c5fda89b1c34bc5991ddd87200e11ddf6532fcffcb4860a864f3fc5c54fd801e518f11562adbc26650882e2ecb1003b734285238c84e125873bb4df12d5d548caf488bde474dc6f53ba6c1a5a3706cab48e0d27ed45cce7b743af810d6b35dddab08b1e6dde116e26cb63a30c5bfbb65fdec810ecbcb737c8419fe5609d9427cbb833094f744ff34effbd9310aaca06030a6689014033417036e4dde785e58ce28ffd9384bea15452970d2e614f9306964d7ff262f2d308bf9e92fb3dfebbb12e07f2cd6eb78ed24643846f9de709e2c1fa9a22813badb032a639979e039d327cd741bda108b71478590c831e79e7ce962b650231a9867fc75e1766216224cf627c3546f6965a7d4f70dbdfceb7a68d1b9fdb1d883a2c7b70716954a6923f21484653fd7738f3b98420d7720450a61922da7b6dfcee093b74bdd4d9a4395a49e31ce306f05f15f2e2f0311b62102650001a0ef501b6dc12d105473c30f11a01c58747ac3e849756c32de48d9ed78c96654fe4e782ea252e25d9177bf4f3f35176f07c4d2421a290d7b86acb627ecb29affb8fe2b0e252b336cbb09d3018fbe533989d8e5078603a2e9c5744395a6ceb9a96cc17f0802c21038d74a3f9c0741456fb74e57afb25c126d863133b50bb3c0fca1ce94df610ea3d982bccffd2b38087407b1f25877b3f852026de08b8e694c5f46a031a39ed5813f168d26c2162cb93ae8d875292cd93c8cf322c5b14c1d185e97b3da2f829d7fc2b372129fb30979763e1f67f9a65a1ec1a972565ff02c1b6142cf13205431aa96d9a425fb4edcc32518c7e7828c28f49857b1c7f625cf12cd893c54bf7b207178d79735addd544ff393e0640dc757ff8d1c0e580891c9cf06e387214516d41f066e7a9803ab70b907c20f68ddee7f4f945cc5ba2df6fc3c05607f06a998fca1b8d95b2be98e56aa758974591c8813bcce2897747c8ce74fda7ea099df7a7dc1268fa7708640a801ac38130c60b3e49e9bcd58537cef981171fc0a1f017ddf467d9f843f14e7044c5600cd0bf3dbffd980ed30469e037a84d3999183b4e936a75b0b90b0ffc3f15691330591760a180a741157bae80c07c040747d21e958488e78deb1781a835db7ca9ba5f59430f1073b16746f201a645481a7aa4183ee4028b079638667b0c9b8bab5575c97b38cb0f4827d59ec17ffe075368b45ce0e6375511a560960158c47caaf0bcf6dc8e1095cf288527c069891b76f6df5289ac25065fb0586381acdc11859cb3cdc16276bdd9bc1e436dd62f358732167e338436840346dca27affe9c934f6058f7607d3c5ae41730a358a65f9cd8756dd1d57445d730e3b78fc57c4ffbaf22212fb2efb8aa1bc823faae0f318cd3cae71b0bc9167f834b613886855cea17359b9ecd7ded3e4173c1be09357b84188f2091c6e32977fa15da3419161a1b526a7d8630b4bd5c5f3c3337ca71d8bef6986082797cebe69e8864a256aaea0d13da94ec5586d7fda452c10262ca415e06e4949f660450efc4626b4c1db3ecb6a6e8aaa5b160b54c6bb9af99fd87e46ec13220f06eb7f6044ddf4c3b9c7e400de2e15e464893af9b02d9400ed4d19373104ef30de07b00d2d26021ab58e49af9d450c8299879d12c9e046da01a7a05f09d4b4d24b92abbbe3c9e13fb5419feedaa9ae2dc86de31e3d62cfc243a178d210fe8dcd410aa15c60f55d2ebfe576cb1b39e2774182d86ea4f559d1672d74decdfee716f48f04e6886aabb2b53cf0de1d1848d58c9950f4cf7840bd308684613b19f6172d1227495b616467fbf8044b85783580387c1998847232793e4a733e524138566babdd808e8c79c6898d4874da64ff11df830577ad4983535db5093cd03f66b27d3c9a55fac269eb941b698d132131a84248bf6b2353394becc04b7913b649c81b0a89b591017ecc4f648e597afd034106b847479b9a16537522565e67d6df3e651cc887d7ac367a43e6b2d2eaf0119b338fab6d69af7bc9bdcc4ad82398414f38df8c3502ee5816bdcd6d623ccc1465092d8ed250d8f17326e16eb33f5a2dbe83c865531fa361323f92531be5d4a64fb51cbc2c8cc36d6c14cefa2910fcbd62ab39addad7172c8360e69d7dcbf9ad8074f057fd925b250d768c64e702d540219ffcc7dd2e108ec70f4fe778e2c788ff39c68b2278800de7c5877812ae941e46a7ddd50ea779fa9a1532a55bba6b4902c1d59c159f4327553e75e19f68b4aa20fd23f269a2706042f77a01c4b0b36265d9e130d0b5d5bfd0dd64ec76be1ce082aa31c81af761d260d4a3cad76f4084f9017a0964845eed49d02e737b3c7e56b6c884694981cf3b489f9100fafe8f490d5cd37179546177bca4fb200a6a92e7745e432513faa28eb1491107ea5bba5067d64742c4cd1c67e39509fc3e2c2fd5b6e2148de6efc2ff7cd0f0aa36652ce912e509146f869cb21db9a470c85a0365359e5a8bd60532e06721ed3144b90e06c568f39e3856fe665f47f9443d241d59bfdcdb07fca2ccc752a143fcc52585d40a39025290eb2a7e84dc7a7e2960839aa64ee9751ba43b702cb2f598cdafd1f7979ade60daf1cab8cac4de5db25a6b9aed1fefa82c5844b052e3178a11f2e9afa29230b1868d467310a0fb016f1fe83f54c102dd1fe29dcdd068ef821b3ca7c8d79690b87b1e7fa433f295a0898fa68f2a5680809235008324f8082709a1acb89794ddcd0d4aaefd16e65d76cba963e900a6e981f1780ba77849d46ac239b175dcc92ec0d245ab4e7aa60cd560a610d04f8714e9282460619862b9fe952b9a2e5489beb0fe2f40fb378b78d744e5ab168b3cd32b3eb4e9036e8577eb34194c8b577b987d7d90d09fe8f30e484e348b74d70371d547e9001f35b004978b4b57307a27b3ff03dfff9a584459d6a74c6eb1932bbeff6c8c039e7acb7dffe1f2658b9ec036398b5770b604b9a74963bcb6d79b1baa740b32644f661cce2a66adc74cd01a8e4140b4c93fc687ba8b727c2dc34484816b63331625551830c540d2d5b16c1191acabcd8d4b1b7efbba4178850b975103257dbbf2e5888bc434136dec08ad238d373665a4034d1f5d577d59f4da885f5ccd58a1f9d0bd4d534e37a14a7335413799db46c3fbdba8d6bf437437140e1b3b089fa5cb2aff3ffce6efc3e3dc0fbd2e0ba87196eb2c986e4486c26e39508ec3387304acb9dbb7c221b57a6a15056cb43b73bd822a8c0ca8e36f6edd5430c73617c62db8937bf0880161f52526ada619c4d59030e8e85480475a9688c95c4d7137c120dbe49d88417862f5e04e9aff79cc28d110e517c857ab224127dda4b462cde1a5eaffa15ed4216f6ad3a0a4848d7b490cd422f31f3fded47a6eeeaec08ef028d1f1335c3d59d5200339e25c4d4f385cda5327e3e61f302bd1a55e7839491929616e51e734db692b12babfe40b9d037d68e83036bd2b29a689ba4e5bbe3c2f14f6d1078af1b0ceeb514420fcf9d230a944348a6cb2ad17951f7217c244eee1757badecfaa30a8a567b8d1d1225f7bf2838278a2876d8a7735d233d2f6dd3c7f08aaa8df289f9a4f88f0907fccc48de25b655ff678dccc37e4d7ed740d1210c13aa2259c7e19fbf666b14ea35f176ec07c8cf414067666f36181f5ca12c592bcef2f2d2f0a27ab86abe545e921fbfd432710f76bec1cfe791f6422d14f0c328ffb44650b7aff6dd020b837175755dc56562cbb64734a1d367b7cc7a5670649ab521d905e73053b278383c7396b784ea7a9380a7a15c1527c0b4c4561cf536728a19089b5c8c91b43cbb365e7d5e800f1afa56d09e94acaf350a26280e2416848fc3778e4c8cdf85b976bc6083f0e97659aaca3f99cd0c7cfae0ca681f7b0206393a3379cfd4f03bdfbe375728d1bf9757044f93cebec807fef69159d063f210ff717896882eefcf55405e4f3156ff7c74a8317ffc2e96311c867e1921753fcc4fb8ef180aefc115aa7697f19b73780546df6c2f9557fc1f30880a64104bff9211f0b1bdd742002f31c4d036fb419753404a81142a142c703b4077f06686e58e2e9ac60506a5fa64f23e33a7d3ee046bc08a4e4f76cd137a029aacc10d10bb1efa7ff51693b12c4113e7496488c420387fad324b8dabd8d08db1f04fdf6af23cc88dba59c4e5c89a8b100f31e125d3c62a974ac315e2b8beef10e64d0e351f8e47608dadc420d203e596100087a337c053841bb5a79d17cba08ace4cec40e80ce12d6f33fb610e268974d7fb72877a49d7ff2be0fbf754c048a0cea9b3b4acdb443337d52d4c4b3aad5ae35dbbfa496345eb5b4bb7eaa9c0a2552eb266c52509b211771f33966ab65736a4501fb29703bfecc2fbdbb50184a25ac0e401a86d6b99eccfdc506e9260a4e6a3ac5aafbaf429bb1ba9c62224d0043663857a90a46fda6b41e3ccc0dcc25f633e442dcf028961d833fd35a298ffc49e38b0f50ce66d18f58087d5324242741842b0b66d92273aa4786c19d1ff101393acfc0a8a562eec227e0236447de1a67edfc2bbbe86becf8b28404043d76761d80cb5417af0dd32c69a3fb04bd56c8f132f2d25ed84bc75071a9da6403bade07852ffda023737ac5b6f12392995b956ace7f8a6112e631d26558d20748de13fed8fdfbcee384f3de27395eaa1a1e804f736f30ec22c733076da4cbd2c44725c275ccd2c8db49e60ecb39e8bc788e570a70036cff187eb36f8690bf3d56140b0c82528602ddfee1f54a2f1a41c8ebe4e292251a79b17caa156d058fb5c8794475a2f92576323ab3e5c743cccef1c706cdea9f9128b4985382cf937afd65b21bbbbb6258e0833c9ecccfbcec12c28f28704c0af753a2125d2e3492f7657d5aebbcdb08f967345949ab42a1a766d9cbf513033ab0beb360176b2ce588dd64ab3480f19546d9a7bb6a7c3ff9f399c866a05563a83fcb7f9d850f584910c417fd979d3e4e6506f527580b0f86d34281779cbb0113b7a6faefe7b5a5fbd7735fbcc819ef5374d928c76abd4a4506641ab48a6eeb0a0fb6be878aeef72ea61fb7eac048ec6a5f5639ddfce2b34ae7ffab3fc493a7ef56b401ead7b3fcfc65f92a048fef0318ff5e8f0d1da891f84b60bea74eed2efb168f1b3246b2e570ad7d57a1624233d180b9abf7a37105ffccff2576d388896857524ee1a43e879cd5ae55be5b756e1a61dbedb960952e5906fc1f39409927f801ed431003351e8f38a7688733a9c9fc90a736a45b9d799ed70300372841d3b45a5e3312f4f7f6ab7060bc2d1fc14b4a0df3900437c068c932caf727307bab76153bfd89819c15894edb814c60c934ebdafe540e0842751ad86a9cb1e774b097ebb582a7ecac77343aedea5b215129fa818ed910c91e38089a32c173d69c7cc7e7a5b2fee9a5bc25e0975acd217599a9e7760d9edca81b561d8f97a85e010d70d70b760b4be4340fd2949b5e26c6db9af147825ebcc2994434ba7c0a2b48fad73d30d0ebeaa83380c3108564d3fc19f34b15da66a1e28187b71bae4f46b62ea4857808b4e36661da7cfbd7cbe4b0da285c481de6fe5790498412c4ee567591f0b0e7e24e0675cf8511b25183f3091eab11f46b2e8b727501e76089bf068ef83bd0a1d13f032c54a3f0024fda909798f1998b390ece97f96c5b8e2c2594237b0abea80777c101d7fa7a32b3a9efe041bc3fc2d000ffcda56b0db7e292bfa4f35f457dd59e902f4290cb6e542c5d5bae07d7bd24fb2607ecdd26921ebc7fd6a08ecdfc82708a675ec74250a8e14d25174f3a317c918dc0c7c101be7ce47df63e421951efb712c3ef31033a88369029c0ff82c9716929ef60f23c2ac9137792a2f122ff1eaf060e2b55d19614e5642f2d408768ced3dabf23953a8df95db9ba8a251786da04d090c069115e16a1b009d9af0b514e5b9a6e8bfa2f732cf26fc0c6d63455f367bc60a1740f6c1b6215917b8e6802dd87baf051d0e9fe0ebd11285eb82b4aa30037d844c10315d79e9e92cc02379ff4126e4486691decaf7e6cf6e81b72acf29cc32d6cd0e3a7e6923d22f99c78d22c84de36d99bc76d56dfff71d88d105210f849388c66210e8c6c0a14cfe23acbdd95085ba4f8250c1a4e08f2413dbc4c047072e5cf328ddd33ea66bddfd6186de01dfced62a291f7fd5dd3682f67f2af61eac26e6dfface2c879f2ccbf152c1bb5989552573e391ab27037dc04936a8fe094f12b9bf7d984f4ccc6ab20d396136a4a68d4a5b02a3cae0b27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
