<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a592a5dbf01fe61b9969b4c42136adea0cf1096e2bd9db86e5bb3bc47dc531cec2f7c5b905770bddb4ceaa355043e705b6c74a0b86f309a75ad367160591238a57eb6f97389e9740190fa020a52bed289a758034bbe887c69f9418c0badb8f3d2e52beae4d88525842c01a7c6559a93a1691ae9b93418a35a625932efeb04ef04c72b7c90f50ea1227f13d5f7cb37c83be681093f585934f644125281f35b72f79cf881c25b498eb642e7ab2455b7a30c9521fbc1d1bd1276c201c2d6c67d62978995241aac3b1c9d456c0b94f2ddaeec3f41e8d4c19547e0ad9d496fc74007a82d45a30a46d254f3ce6525f4378c0a8aa905c76cc99d5bcdb789ad5c05c034e40ff0b00498857dad238e857dd3121c15f7d69f34e5fe77af69f29c71d6bcfa9f556ca083c75b475fd7ac0faf8028cff168c5500c977fed59407532816507018b26023a0d3677040a3a52c6e3d87e8ac00cd418b55b2bf2b1880b75ecbb8d3a8c6bb09fd371f6fba710e9cebb4c8451629e62019da6b7b46ac02d4c6d69d5b156d696e877641e9dcec6f51b4acf346f1c98ef63fb071f5fce70015879aa3fe62f798f0fcdb1b9efdfc530f9712dc64ac77b854f89ecffb93fcbb997381d3c881bbb23079e902c77c34e436477c763640e17e500c6ad9a17baa1865c4934181ce134c5c0c092281640545e6ce7d49ee826a81db88bda087ab374524e99587dc4789a5e292af5674d1d642e25904a85230ea0fccd53b760708e8ccd1e0320198862c7181a433c89ffdc64f612b2b68e5ff9fa10eef236d28dae0d9fdfa7044f2319d7776a251c36b832a386151e937ba998e7fb4a254cd9473ec35a34c150625023d1d8094c0e15118e74e842081bae467fbe95c4dc67b133399556b72cfadbee1fe679cde8d99bd6d50b2ff24551c922ffe8a5c94653d3eec17faa9014c59ba63bc039b732407401baa6b0afaf65d5c3a07d98819651f9d43df28d2b9b24eb020c8efcee5ecc41b60b13bf610f015c1bf51bd568cbda69150bd3102b0e71da444f95679e318a3ac7deab8570b74397896d1073f98b417d3ec2829c3d9aea654d417096988aa68898602fd7217d367996b10b767b846e340e1985d08413cb691d6d8ebc168c9b37b38428fc60301108b5cf80f6fa89b9bdde0be2b2369e2d9c291122d9c84d2e4c2fde3cb7b70f4e8b061f3c9c611956e5cb6fc26436e22825ec8ae575165f8a4fdaf18e274087a9fb8d0d4b9e206bcb9767e4a09969487a59f05c693ec55f98a85501b7f36aa46b7313036f6f8368280f85aa3c4320a164604ce9362e8047310040c19e48f63e30dca7e84fa673d47239014e04b398cf2eda2c14268830c046564e27eb5cbc30d6858fed851f912d138a710bef9ad8b40d20b3c56c1f2c821729178975ede82b5131273ae58e64cddf8c596f4743f794b45c0b54cebee1bffba6e6e1f6a90fa87a2d4cda578d7d9a7bbb61fe623ec6038de626a0d56943c4cdc415d248d6ee781d7186565b47c72b74c8cac9a47ef0221d1beb712cbf0ba6383684edcd0f4132ec114694304e9f73c83b7c8e055f99a93209638dc1ffafd516948f7c27208df4b5d53c64487812a6c2d18a6e5d3b7cb3fed890eb0c3e959c2383fd619a90407fdbf8e33409709a1b6ed56f3748c58db68d2cb43477e6955e98747814b10a73fd99d6c9c5b63a9149f5d242cdbdf62eccb55711db3311f0b08c173219796b9837d6325d13fae45357fae7141879517174ea04b6cdd77d6a12d9c83cde3d69a66bf8d5a7545c2cce9f399fb7c212ccfbd69b1b7121f24e9b635c176a95a22a7ba343a4a1bc3ebb71f72141b06ba08918ec10f45da8edb113d98131addd95e7668c0faf4b6f7ea22e2e48f01d1a37faaff931964346e1ef873ddf867b58e9a329152bc486762d1c9fcdc9a3ea42602b7ebfbe9845ba9f7888908abf006788621b25cbec84acc2b96a918514453dd6806a1cba0139f3bffc37140b92755fcad8bcf4c86152dbd286817027a4817630e46c900afae065ce8e2e54ec57cba11555cbf8a29eb59318a89bb7d3a6b52ac9f0476191eefd3efd1a494dcb7ef8efcb675bffd78f528bf8d544650b8095754d94ed26594128fb1899e0d57c0c12b54818f613fddaf359a7ec0afc6ddef426e64c20fc16affdb919ff42d570583103f597c2743b2a6c9f2b8fb16db8008c53a40ebac98857b26020f3d2d5d399d29c953c40f49ffe226c3a718a3941ed6dbdb0cb512cc6389751f8ea15f543233bb06bee6f775b1439ca5d63ac4e6c287933f4e7a5bd10026af3a71d04245f9a9df80207badf5f45489e7eadfcea00808cfb874b7831d0f062b320eb51412202c101c3d041962d057ddf99e3a41e0be014b4f44d79ecf197bb102f8a0ed8e47a4d2afe339a63bdc1148d9ec5cde5f1fcec60ca78d99d17aa08d89013a6da99d1475661521662a31fffce59ed92ea5182719c5cd0792bdb7f1c28446c0b701fa9fca77b8fe93555c812c5368376465eee62fb5c1cc108aab6a64794b76ffb8747038f6dbcfe1b001b85023e080c1740ba5fbc03694bec4cd68446ced6f33e8434310d0231360f94bab8a782684ed7a992b701df06dbd3c95cc7d877c0788d8bda3509ce91d089cef097076b22f74af5abb0fe4030f5486e9513fd3012fc1541962220ed71de2d63d69f245a2268c2df1b307bd7eb7d65eca619bf01df327304f69ad664c38d97e0fd8360b12076de80de31cf97206fa371acf9483088c275989c33d86de241eee737dde84d607c4849ebb65eb522500340fc2f37dbb29291c8de6f7baa6c5fb67a393d0417f1c3ec73f420518e2044f28adb942f85ebde3b3d014c4b5bfe261ddacae9c95528a61fa3ccdf91312ea46e22ed253b1d3a24208af79d17ec834b0bdaaea15d78894fdcabe4df28d5c1d63f6707ebc09b1dd5b73eabf89427be99b4839ed521052cbfb21d99745f2d9a928355d40e0aa5ed1e80c438a01ad0fd395522c100eea352b78cb0466440c200cab8e5b9a63b0e6beb745ea83aa11e79430906d1e4d214351aa777f32110a50f7cd257267e7f7a343d2e1aad1b70c9a75ef14fc71fde3dcc605dfe6f886da484073daed4f5f99a046465f179376b0482d4ff059efde281b07d1380896aa862bc3f01ce3fdf03b5436018ff2881700a342b6dc3a2a0f04ab8a5c732ffbfcc8d55e3fca8e64267f21afd257b1edb8c0742cb80c62b3ec6f040ea7b8752664cddbbfa626d1a760c3321b9dba434e3e9908d044b67c17ec1de401fe5558243bc8ef5005057c36e50aa59ca267e40adfbe8f67066e4ae5ec706ea745ce6fbf11f7139c67c1a298bb249563d384d27e66d081748d2fa78311737041e2c9387b2ce8b230cb9e226c51f593f18f05bb88079f3af815618ccab14f450ba0e02d05252d972b372866506045e1c46a09f0ccb4e23d40c9cc23dd00c9fdaf5bd0a3d3bdf3e7e2635c503733deca92bbd74e2dc33dea30b4bddead6880aaf13a9d75c6994a68c5fc9a44fbdeb1c7155819e4d540f67d4418d12d391b1a5f9886e329819ee01538233490cf274b9c86d957a6412b4f11fb9d2e5b9f823e798c47e9940563d75169904082aa0e4e609906f4efdbe7d75da393cfcc9ea32275f0243ef59bebc5058ba61030ff44e240af772c1cf96573f2c523de42211bfe1acf0bd2f574b420496a08957ec7f6b2d993a8a944b20be3d7d385e593af0a0f9fbb71b1684211439b97f4908f2e0e522d5f5ef0e680645dcca6b58994513dd6f5dfb0e5d82dd941afa55c7ebdd4c85717306dcb5831f5549df43e5c09d0a727a4a267efe52efd8d060c1876487ba2929812dfee60b875270d4ec9422b8ca2a9f510b403cca430febc67b8b2d7f300f024e5661b4ec33996c3614fdff1532f0091da553c95d4d1b1a2edde0c924b19daa1d684f36ec71b1e6a55056a37c24ce549b3a94be246bb7c67c06e3e94272f2afddfd195b6053a1992287bcfe61d446659bfbbb90c3797cc64731e23033eac553debae24e51d45a85165367ed5b6797ac97a6f26f2e497166ddd65b659219bea2f2f4ee933a969b9012cdc322dcf2a343ebf51c5b0f13fb24c6c1e50a95cfcde24ba7f849e2436085b55d806965ac655feedd3019f64d0a95e39712360d3f6b478250ca4d444e3afc6ab720128ac04555d971306c491edd077a153b3acbd872f92d60a969d449c327af192022ba0f8f8e135c688b6dddd05a1b152db473577fe3cba3d48892fa3008986b9ca0f21e046bcadb6f66285b663a9e872ddc470eb7ee5e7ed4e4527a1c8b47d7df903a386af6c6d1a34e687e4ec8fb742ee3ac7d12f5cd5e449e6abe28591b19ab59d55dde8ee91b12b236e66a696500bdab030bb5558a5d2a1996b8a832ded2e6f6ad13edb24059a48f32c1b2a51728e0f6c2f50d4ca69fe74ccc2266f286f461642a503f2bcdbd4ffa106d86e9f0dec8be7b1c25d3af9230bc8325210e2b221c26bf943f0a88cf9244efced261b74fb3c5f273a7111368f6a34a27fd32a44adf012584f0a57c4e76011ca1124f045c555594e834e5c7c9ac6428093f26130c90e2553f800017160284bb5cb18ba03840b2d2f8564d020e4da68f42295d3f1c7fb0672a360b78df8141241299aea1baf0e664018cd4f42a5c709bba2b787b79f71ce169a9b636de4e55c40dcbe0ba0fccf7c2c37de69fa6ba54f9bbdfbd9a53456a379e5c28b2fb2818627dff9a14d18ae80789e1670955dfc9fe1e943a61739c9d6394e99ea686e3079387cfc006aad40c8cce5d697fc9f9efd9ea09465f422064ff0128c9d22dec2e42658486688e98dfbfc670109c3aa2f28fde740d3d2f1f1a040d42cec854f2b68b12109767a6f30e370ebe4ed9137aa174f08f0ceadaa87130036b3d64780e51ea511c24fdf3dac1ebfe4439eb52d8a74a2c21ed981c1fd3d6b6c5da00f3b85816eb636f3ba3d797d487a7ba44e9e595d2e3cc88772e0463bc2074a288688aeae3d4cda7be01a1e4d9db2ce0d5d9e67bcd3210967d4da279be3b11033aa7131df36a07bbaea97a6d9bf70f8fc256ca5b00f428bbb2fa07e3c83944e8e2f76abe22f64c55cc3990ca21c68e0e48a5dfebd589700566ca5de022282f2d85cfe58ac49538516e3e99d163bab248f50653a6c9b8c441460c0c36e01b8e38b0146a8cb1f143db2cea4e9f445bccaea0bb496cf2e8a14a4e08f09fad2605e939120b553f788622a01df4ca053cebc34ede6a0eefb93921b9b5a7a9c60f857225fad1b9a26659cc2253a5ae48c14250c81c2d8f2ded1b9d763e29ddc7e144564f47f9f7052c3f4ccff7f32d1d1c5f6c289a711a8e65cc4c276f8b9a7126eb304da00086830fe451eff293b4f07a52c02cc66aa194dbf28acb2cbac4bfad52b940d3da6bc9a4814016e0bb97a4d9ed0c4f6bb0dbb3539f82db563e057c4355c7423ff562fb6b104ee6f27d408edfb91959238f4a6b3de6ea0645b39b8af8795d7e7e6d1b185cae97ff25b206622346f4a140672a8790105402a78444b073016f701b34fce9ed932bf41fc1eff79c98ffcb1ccbcd4db82ec7186fc29f52ccb9817bbe1581e6a238f68bb31127a9c75314ffa7c151bc3e8e3da5e67ba64f4234e8ac948448019e590bb05816b1a7e4b3fb16bbf5a227ba82aa14bdaf90e854098d0a51f100c652efa4ff4bd93735ffa31ce81e5a2fdf252c29823966f4f80ad01679f1f7f651f6f5b0fc4a8a18ad68b42eb7afe0a995502b68165cb6aded01a0bc86bcb39139b0b43cbb04bd9e63160099f83a708718bfe75e2dfa9aa3c0871d91e0af8238b51796cce66471f71c07812ad76c24987bba87624f50956b7d007251e7785fcb6632cbf3386b7ff95388c1e185a2ab2df411f0a6c511e6afb2434df88945700dc3054ebb4f922e83219d68ac625537ea3265dcae156c399735a52135b289f4c3e5f30c31881972c04ff33e375dfefbffbdd04d6e5eb4942b3ab46a13c0e04230be4e308713c93cb869bf5d33410d98c8acc5e7c1162fdb9d75f2856d30422828503c465dc580c9ebd78f508582d650c3efb2ea031fb3c4be39c3154ca8f62db05ca3bd5d676b61b00690ab70fd03874b36c7427adc840d0eb607b32552b6cc4a7043bfa29c9746835276a85a00bfea2c73341d475bb1d64875d796f21d4fe3ba99610320b04cad81d4786fb8f51e762ea08c4cdb2a7997f88ac8ed336d6763bf352938646f2c3c445d5e78d3a8c909423813a9eaf1cb5e3296b611a881cb2c2d1626864123448314cbf7c5ee10448e85550c289d5c6508e4abfe8a9a36977aebf024a9acc547a459dc7d7b5e6ca81375f5a98670758f5497b9a27b40c7b3ac2abc86b952d58aa45b22e32cc60684e5e2f8f4587ad68fb9bf534da7930fa48628bd3b6f95b3407c35cd854af734d10fe7a488dfec6ab3073cf9a5d789c5f92d3b9a318e88404e3d2ac06a9acf46db92d020e7ba1be1798332419eb3083beff9e27989d183a821bece30ab56f78ebd3559f882e13521c2085cf7f5f90481aa8b0e662e0430accae33e7a055dbd9654651b704eecbf21592f845905eba24db1a6aa67bf2f6b950490bc44b0ec43e19548ca79a73e79948bb26e6fb291d7efdb176e98ad4d188806d32f17cc5bc9b00c7891c5b46335d37fd28ea6797703f48bc41be89c7add35e4ef1d0a0b417b04d162051c7d17b6b11930e1652d1c66eee1279af799491aa4c0d686c74b8a2789fddb65866a9b0cae780499ed07f6412be3e52cffc05e519a8e17b220875b85c77120c4ffd1b7320cb1c2000181158900671f7d0caac952f851814f9cbe29df6d1d20d2ebf0d183c35ee20c0b27006ab5b6ea9c285d0cd517f87debe397d2fbf0a27cff61e43efd6c9a02d2c310493325beea145b5fbff29e5bd916b07042770a413c5f9d50f98239ff83fa4d92bc320d706bd077510a1fabfe4da24b2b9bdab888725268b4ece780aa3dd0c8db2ff353e3ecc68900b1354e5e00f04f8777807d43e2be647c8a1bf34bed105b2c68c9358d4ed3847c9c062f51981c7c8b6e22c231fac42deaa89384025f28b1527b98b6a241661760d618b3d4407e62e22440fc926a74d87d8dc7ffd224c37e3c6a6c9ad747f519d9510a6b5d05d6f3f1436fca695b3112810c56fb12e5c401425e3549acb249d59f1b365d155cc4bf8df192da8b4ad96b330cdaf5cc9560d0e6a74c5895b08eca3f361efa7b77ec0057333e4ab8ee131121697fd8b0eb115a7cc0e9d4c138f55feb39fb7b7dc34a806e16d21ceedbbb8b06e167a2b97d04b945831a7768501b803a639df1dc82900f9887d834a50c23f3100a7f0c755c400199c01d1d4e6eb3fa274366da850078e3b46af59be6e743f46728ab71b3056eda78cb2ce2652366b5583cd4c88b27dfc81a7ab0df177a0fda660a18603d7a87a9a7cb0e3332b8f20d76e0f3ed26830b8930255ef55158f7ea5191a4f67d92585259282dfc8c1c4a365344173f5e989106179bc6f73222f0b7c3ccca7cc477f3d95953671e947a77f317615e73a134512e11912e877d6e0761254ef96901ced6a651004b5ffb8effe5cb10aa4199609bb7b4fdbecb4c9400287041839c5038d2d4cc7f40916ddc75e5e25347cdb8ef44c0ad9abc8e9704bd0a058205956729071c2226c8ef97bbec67e399643bdb9bd05e7c7bba9b1c27aa62345dcd4b0c7496ef7efbfa1b2d740c2f6ad83d1ea63dce2fec87ee8c90a6087497a8b5de3a44fd3037e496fb26d7c2810dc6e4338b829940a5399e0107f5b98f2369dfe74963e198937c89defcc953a32edffe31db2dedc57e13aaff25c9fbcacf224cd1b74b712a8e6d11d1d89991f1d36a425fb75d9507ac5b7c7bb6a32acb886e8688e658dd69f5c5867dcbb0e71964b39af6a678d1e63df531fcd82fb7d7d260a0198919a8d6df3e9699b09b2a48794bd7602a98d1f539f1394fe8a575bf2adcd56f5aba20097968971b90d243266725d862d35cdbc9dcdd6b8ad99a58e54055a02b049981edada1b144ab9616d762a21b4be0845cea9eb035556b3816e7a99faea8c9b092b7f3b4c0baf406e95cd1dabfac8170422187fb602fbb497277f853ec3592505f0f1b4aba64f31c62d51f72f3cf82e81b631c051757d458a41a05d3931d25511e496e96ff7b8125d63d49439f72bcb5638cc69a57d4ec48753ea116eed5eeba222c2ba608f821d384750fb527b5a94fd547edc33f4ece4af367f42067440f33550193004c3fb65cfdf350e21d0b6f1d80f68fb3bed8e86208719f7f04d0a1a123553946689e4e4cb5dc0ad7a0cf1f85bbad1ab0c95488b2712f442841563cb85047f0867c0ab80b25657c11f9a09d40d5d279c3a34d02a1185c00b8242760a21cd550a44e0b11c846725387c115b3dfe4869e923d6832239dae6108eb6a7677d719ccbb01341c9d20b137f4738a838f616a3d9e95efcb02f4df397214a3879db9c176c595178775727c376ac769a2a53949abcd34d01e6363aaa5f6a9f22d3e9297b52cd85c3f590eefa81b27ff44871f0b7b29c9c9385eea401c6d47afcaec2505d82370343f586ae697be4a7f09517112f13342c2bce1710bbf2d3ebdb1cc0d58f6242f26aa4e9f274142358db4a8dd62f35c7dd0e762a4e4eb69641a83f76749d1ae12c0e4542db3f3a9d901f45842bfd106070e361093ddc38b3cc9304f1ac2fc534a02af804e3ad575e64595e06a125485dd1f812c1398987b7c1e8ed0a9e89a1dd338a452f216a1fbcb292492609f67e549de6ba31ee5c289b5a6692ad4609dec9747aa885ea567be8c0e270c57336f1127cceb34dbb83d755e3d70bde053a93b151d6bb52451fd92d9280f092cdf9e9622545e8d8261f7f4d4399c874c034ea567221f86a770814f429b52d89a891572cdf56be310be74409efad1aad7353439e4e1369ffc4c49626f68d3896344533b6ed6a7f4b24562a0e3bae5b345d32ed8bd12c8b3508f833493686fa611d383c3991844cc27cc317189dfbbc43d669718bfef057fea82023200d292f31ff1925247743442375493a0202ca6585c7eb6ad2b16341a07dca598ef19aa1fc9dea9819e5d08077976f70fdd3d777625ee8843b65acd60673feb513cb3b62f3f91e66c30b4412a93aabbf1d02e6ddcaeb463c1325f495d3c882a7e4569f979316fffbb30bf1ddaf64e87bd43050b39e65ea50fbcdf817b619e89d0efba3739a1bb3969e137c75da3934cb687f23fc20bdfa24e95585afb1de6120ea93d588ca934b39d715469575497bf50574918a81d95b9442d10651b0748bf002e6d11b823d4dc3824bd18bec14d23f56b2025d48b7aea3a658daa0a010f400a7b5668c0494e9706f95ea3bce008277d43ac887238a1aba2db6ed12775c4c0232cd54f78a7f4eadc6ed7d7ce64dc198c23c189324ecf93fb40eca6c8fa2c5af11e01bd40006747feb618422453b43fcbacaecb905bacc8f17eb99af037619f55dbe7be737bf30f785b11857afc9a5d45c87aa909edab4a2e592f30f9dcf88ff4c4b746b147d2dfdaa0179b0889a991d532638177730b7212d33e76b88c959130aa9ca59f5504d27c124993d4c23842867ba8e3bc76a22ea2a19432d297267e7971fa2f1ba1ac25471947b1dcf8aba78c42828c3a854a8c34d3374a393d889f2e9adcc66b39918d76b368c4241511c267814b09a10c971c470f24ef71c3ce2e8ea17f1affddfb18bba354ba9f10a03222861b4d95d3bd9576eb7bcab14d713d699620a4e33dda24bdedc33c4764dc8bc791625bc805bb6f5fce8f922541ccbf1d3029b8bc580cdf0d606168f69f52e314b478b5e15d0f7d16725ae0250a0b425966f31949e940aa06413229b334962b6824c9990697d1f59df2ebd885e27c29ddda96bf1210318fe183668ee8f4064e58b9c41f9f40159000a0df3c6fce6187881eca4cfe054b30db8b4ca10aa3f7c1c5bc7fe651f81c98f09f987e0b2405deca93856a915a24a5cde68684c6bd7cf372bc2dcba2ebadd7f2bc0cd2206af8c1bdb522f90df769b92e12e5af8cfa6f9ca94aedcafce2cbc6881ae5fba718f4786c5f85cf5f68db97710a8c8da0ff6bc49926d6e458c36e514077752f10ffda8c091f5758ddd5f0b9af38b5a56006c8ec47c17842c076140bfa3a40b3cf8fb2c97952e43218080fafe1e0d0a571668fe0466911891acc7d05d5aa764f6bd943ddb73603156286755b957fb8a9e8acf016d7e649be59d4eac5615da155dbac0589d5741ff55dedb38d28d75f2f1090d4b63b642897fe90cf2640854773f4803c97421847344969dcc209053abed6e382a489c0a06f5eb0928a50aa3f844fca8b3dc24e719cd7a2df8f9319c21a5e7f682431712da9912b463285d9772ecf30c6697dcb8e6cb4f8631aa170a5a26c54ba8a8dbade93501c8afb675dfab0aa441e0f50711d665de84a88cbac8b3d19e3eda6a5fd58efac3c7f06961947ff4fde908c47f1142085a810f38de8de026737552d99d8c15ff1a652103bc819db01540ae2039f9a4ae4dca95d7541cf7f8471faa9025303276009c0cbc0d39a44acc4e0ba6f9803330d0d76771bc5d67349fa1d9a4b1473ab463813055ebc3a8eb321e8d2ae6f5a01a2b97ef1d84c4b351bc74e9d08ed7df9298efa5b26220866a2cd7bc7ebe14b0390ab2463ce023dad485d5d6259ee5348adb0ff5c5603b5502b962d73bf0e9b8a883c79c62e80c56e282534bd90b15cd25834ef7c5a8444523232527854cdf7e3f94980f157b181660c2f6f44dfc35cdfb17211d594875612e564ef269459ed8e5385568ab28e5f5bef138fde50fbb30283e377f36ccfe36257b746ec23228906512649972c95a0b48ab4635281d0b17358185407e61836fef061f821e03a83bfbdd27a0f3a96cc6d79d4a5c3f2545db509ea1a408d7a200517b245d3a3b946a18b0d740a950c7852dd1c36992e79440af65ddc06fc1f4717fc9ccf95f551c26562eaa3c9b7ff5ab689eaefe705a7ef7c2a12bad2a5d6b244739bb46008d530f4a326e059dbe77d3f5073e2167edc3c9adabb9951076230da4522ab65022821a474c41463167452e06eb1b907d6e425042f65cab7b8c78aa48e9bf1723a2fe28d5c4e6368175a75d282888f5558843dfd5b0359017f8354c0c88ad51eb57000f871b6caf033da5e3f8615d9154a7a021e632ec0f08e7cfd83a3a5c3e76c58daa3a74aa3c7a6e8ec739e686f98e9d8cd00ab6feff722b2a763255b7169cdbe362cd5be9854849433f585ba85dd537d493de4961544805a7e8e0309b78c5453b1bee203a64877f28628e69855d998a23f2eb6c2bc10b31014b7f93c0f7e7f4238e317529b152f6912ac8ba8f77b9c2b2319a7ec0dc0f7ece8a29cb45097dd9418ff0c59c6b4fdefd28e2a38439484526a7792aba8c43a56b51f54e26edab68d4c6c780c8bcc751430a5810bc6ea3923d91a4a749a2205f335f9e3511d5bd421baa8587c31f82143ae6d26878cc3a815647c4973f51a85c720f79dea6a4bd87f562810f18a3773307c1498818fe2bf130820226d7bc7f84ef4895ce552d7f1429691073a7845c827fd1e3bffffbbca2a5c15b00a666c8306b703f3e25e02a9258a1f353577b300c0eb15a5f322298dc6c6e93c4534cb62bab59a423faa3ad576d6938110aac15c38c997369de8e128052cf4e21e61149c2d77ed6feebae06440f27c0406eb6bfe5c9ba1b815ea80005f9c0737a7e2cb553410a054130d749d49411a9f85aa87c6dd90d0e2a61ce58ebc9dc4434185e48c74bfe22dc5b9f432f153a6d4a00557caf6330a7d213866afe2a5b78449837959521b51b661e713d5e94f8533a91729700241b0fe5a351f789875f21d2e8d88e9ae148601090345a4cf5ce33c0b31d49ad3a10e8b598a75eb6491ce107ea792b023f797efdef6c8d115654abb078c379c9ccc5c0866e3430095931988b76eca9b1f9d8cec4f51cf51223c4f810a91509b4a62242a2a2bd834616d6b8750ab666b684f714801b189c507204a59d80256dcbf63cab35c22a4b3e5d70581e5ace0d8fd1ebe70560a51b33da243f1011e5b640820bc4d91e75a55d1e44a9eddb5a531bbe928bd37e22d7506e2f0507976b7b2788e154d08529d94f14d285b885f72ed6ea0ae31dee027423ddaa578fbc2000e3fc82eef7db360d701331d90591d548b465df20a65f0e3f7b7bbfc311d5f8161fde3a215bc57b4c61c115cd5da425186e3c4eb4fee20f5e03d235969298ec62b93af5b3b80038a44e04553855af1b1bbaaa636e0d7cd22d5b18cca9a544f12e79aeab193ad4fe82eba6964b45e92e1c022fb04288835c7e64e514085fff541b2300a70b7bbcff877d81a881a83dc0c3c9d9f59bdfb93b93cb3f0dca3811a7136f53c98d8dd3009d0052dfda61c6895128a78edd2ba9a0946b5dcad2c9ea2b35410b7a4716dbf202e53ac9aa426fffa92e9a1bd4e4bf9717057eee2ba496b5cf9750b9f74c3deefb0a99891725cc5b4a61aedf0fcc8bffeccd1a2c33008271f9fbe4e02274a3647b467f21f1bfa9a76c91d12f856c5dcddeb2c9a4bd3dd03d177fd03d028f1c9017382d648ad4866929f743eae32d536927cda1e60eab1df67e99aee01438e4053d76a1b74dfaa3bf6bf5b8dc4179de2ebf7cc9375dbab1679db661479f920ece2c7089e94d36e265d5a4de25f6d3884848539626595b7dc266dc3ec6e2264049cd99e7f28645ca611cdd99d52a9c3d65c4da1e44b26f327c854a09c5618b9effa244c238896e10847199d9a49dcafbd01960d5a36908bad96889f25bc52d6a7416734cfd1c0ec1c174c9d41fa34c5593dd1b42a3b34c4286af8547cce703f9c4f5d701a476d2378731236f4ddab49f0a04beb94efda694c3ea64edd1989cf3c32ccf7f7dc335eadd4edc161fabad37dea400685726d3f1b97017c14998719b1d9f6dd57bb965ce58edc24ef632dda73454ab01e01c4e2d6c64473fbc8d24bd81a228d60e5dedb06c32ac77eeb442fcf1094dc00832ec87c4c07109f1031eca76fb7110366df0e246d356d940b6c949303c4092636cc33ba9efe57da16d0d99d887776eabf11aa9e7fbf7ed4a92fa2f21fea055cd80edcd15e071a97b41718c00c7f198c59c52c90827dd69f27d21738716d09d40ce63669b78667212c6e9395b2871bc3acaa57c3e864a67a5775cc4a73f343cfb99ea23c49cbd415b870308f9734475337eaf07c6c60164a0d1397e699e18d070399fcea504ca377996be88dad49886b43566f1a7b105e787e2b054a3c89b9f35ebc611f28d8d6e12347503a451ca35e9f54232dba68811f94a826b65c5271abe53b0bcf9087c084973202d494dadd954ef9c00e1a7010f48efd9649ed7070cd3d4575e706c812f8bc30512bb61bd0bc3994b3057d26652374309b7d0de7e988066b9acb8053573f916d5692cad0c18c59edf53c993b10b3c45a9a51b8c6ce5ef02713691b3f7064e7c150c808234d26cdaf6cf8ec873c878d020bacac84a048bc55a757a39e406d8e2e39814dfe3cdebc5736bb08d8e7487fd06be18f739c94bcf9a068bcb413e63e992701386c5cbb64e4027bd711731267cfd7dc78640fd22ec89758fa100ba1b13418981c5af91ad03fe7dbfbf944fffec04387c122186bbdf0e115d43f4529fde83ed153e657926a74ed71da59ea322a1f0ffff565f8ab0a670b263bc529c1b421c93ad9a93eef4dc02b1bef390456b5edb74673b586aa18197d6fe73ee48610ea6a478eeceae1f689c02c7d2a021f9980a2b44ea71793d1a274ac7edca78450456cf485cc690848957f5dc6657bf252ccd443e0c043dfae5865fb91fa01decdae0c615b3e0c0e0dac1398ca088c4b9a894f7d6f6c2dfd87bbd35efe454ed8b9359c61afc4c59cb31932a42d153e60d9933a0f06e19f4bda154d63dc20cabb3e38f3d745da7135f7ecc5f424a7d88fdab2174f65e90d81453bebd5e0e529b256dc10ba1997eac5a954f98da30bec6eb3c76fcdba3fb86655556a18ce8704d812d6917cd8c6e7f609691f703a97adcd3fb11deacee4ef9f03d6886af8a014ffb06f4c5c28252d13fd2f5a58d5f0b3ed6c27e5c3fbf7acd02e8070e990d22977ee298bbc67d97f5cc4660afe16672a58ea94c66c2255741f250b4d62e49f6e0548583d60e7dfcb09adcd004069bd7a66a3fade5ede5001d9cdd6ff333b1b444ea759bc75378275172478f3a9e58e9561b9e165c1b8c9921f006f7aec148359028e5934d89ed433d70d754addb4f36dc549219795d465707ec60828b5c2761542c02acc72f2cab6837f6231c2caf90b0024428f50d10a10f04f8a0c462d089d45c323487837a0c29806938b58df05ed9fc74dff0ea106a058b3a115a8c846ed0b7efef00f75d5bf429dee7a2e2dc505dbb74c7840ff7ca62fb4871df0e1b85bfede33635397cc45e6c7fb38320df4d8b931ba871cc3baa0af9a074e0915f99e88eb64396632f018e469f1c5ceab22285a1201c00a929f790e580d73e19147f2b2ea8263c83f04855dac3f6eb163ae4bab7af46ac0ac4d9d4e4d916c215e8f72bd8717af0c193110378399075bce5e68635ed75a799f1e1cc833501a593139819170a4476747152c18494d9c17dd791142869f5fadaa77cdfce422aa1726d4187044b409ed9f8c9eaaee072e6b7552cd535ce298542f276af4945ccdc208138ea978fae84fc045d9416a7fd117e134b3a7b395edc671c6a7159896a37f18190476a9ddce3c9aa62be6a8ead78d60d37534d251c47641dfb4ace06add401e37c7ad108c3446d21f07929902cc3c7ba444d0d6ad34c44f156b12f6d7c1d9f53b76da26d34c3aced81a163ad02ac60fd98a581a7991393170037e47e8f7ba5540c6cd1c100e0a2793c0bcc66148bc86fb2f4392d4efdab86f44efd38b2913500c173cdd77380ddf6e72a3f292338cf33cb1ce62ed416c01db84ccaf87e4a5cee411d79d3940b5dbb48ee84ba378c2e9d427a82800b61418d82d80121adaa4ee66403920ab6fc400e42b807c3a2726b67f25d3bf336f600262284fca680404e158255dd84e95b0ad431abfea2151c0712be69cd6ace002638a5a1466d929e3a4218f9e051f38bc27e99bb606756b585120109a4af09fd886637726c7e9d13856837fe329ffea9d7142c0f5909a1b79570b5e8d9dcd24a02ceaf5a1baabcf0f5f207fee92bb1a2c4ecf66faa61c287e8ba0ae6ba226b7ada8acf30abbb1f7a3cf4abbe71fb9a1138cd3bb3ae13b1d9bd4e019154f36986a23909acdf1fdc2ff7fcc93633b94964a33aa866ec85dd5a41f37417ff0e6a5087020645bee5ccfb99753758e43d3071f82e05a7ebff4803fe8e9f0821ebedc3c3515188db1f81ed53585a40c5189598ea0d828e942e51de536767e3d118397db8917f139b137c39946f2f3711916506c68f175790611c836cdd39f526de097e4f409aba0242a1b9cb08e2a23be064bd1f60f31c3383d67b493049621d6d6f9437b74ebe03303d5890b57bdb7742a274dd54504a846709d675ea7b73e8688d96a1bc9b16895a1967c2f98d357a4f628eece5f25f249ed1d9bc2b838346c6e7e89bce3c85a8f3e5cea412f7b6cba29d46416a2fadffdda68749efb7b15f3ef94a2a67d574ff11bc68d488108fd44563234209c83f1f5c9d4e0c85824f9e7c3f9f15f4db71cd91854f7e0cb3de7c8ba752cfe2165ea3e5cd39cf6de979dbddb1a0a1c64801aed30e4d05e7d88b2696e252364fdbcd5dcf656fb26b26c7cefef127807575133e07d0450ce965c5cf93e98732e0c5d756452fb9d03747e2a9d478c94c0597e002b1d1a5aba565f13b4780da4e86493a141698a5f3c424f0e7ce18cc9bbc6c8f842d5e162ca61a383cf520be829737aece951eaf98a0ff4be44d0a53da666df7fc914b1664d52d5c274030f33351e28eeba84f7a0d019fa97f53c43d320d1017c1da7f88794bda2b38a0430220d762b10e78eabdb413ecd2c72eb8dc17554a43bb9a52b53178bc1ed391a08568118c023a873f338f6b3c641d65f0360407458eb7f234eaf96854558b6261bb3185d42248ac70aee13b50e00013e113d441813c55c670f84a7c01d4771168dcc3d7450101dbfcd259fdf013384417e9487bfa7f2b58a5e0c6dd44e28da2d975835b77d56712449c7e2bbf5a30354d82d8fe73df9cf746f6c637a43ef8a388265a40e9b152b3aba815b64f6213819fcb4044493fba8c1e35c6f8346105d488e93998da5eca9dd38e934641109dd090ea4648d81ae21adabc5de011720f209d3b6c3e14fda1edd51d78487f57a66de4d2997e77df9926b05ecaf71af37ef481bdc17988fb7e3cce2c3581e4b721b79e097ac0df68d79d930344eff9eca70ef4261df346ee4ad46ae904d085408f5c38bab897bde2f7e55bf688ffbcc1947d37551daa88d8b1a974cdecf48a6cee1e76a74685fd78a647f5d509e137a8d7bdf28aae8bc31d00f0a8de886694410d5041d68cfac579cb15ceaec835faf3453a715ca8204a674cdb146c53879e4e7b10814b8650e6fc4cfb12275dfa13d215ab07854a7f2fe62bdc3866e74ecdfb141653660cf6e072ec3d48ed9e47bb8f2d20ee51bb20b7ddac1e985775dbee9408bf58b301eeba25b8130d0bae0adab8dbd3764078fd322dc57f7ae41fe4b4abaff3b0161f598c2a86ec1d056fe8b69f28c020b8ba4af1d906f0efed0e7e5b43f383127a88432a1f5718ec37d79983b307dd6ad0737be1767209c4980d3740b3e6c9d8bbf73a8ce9d441cca8e268d507cd75d84e37492bce06ef04afd78b34aa3fd9ab78867ff80fab8e8dfafffd80967e6b31b35b51704d2f45d4bdf7f8bee0230ebdff6e38f4ef412825f42ecdfcfdf8a4cf00caecab4a02311829237e0593e27325f1962ceb5833f3115c5edb683fa40265b084532e67dfbc5cfc22b2eacb1ee1bc762397315a1773b147382f1d537afbb852f71aeaf7f7d544357e4707410a10fa5782f7b23cd162f7d25002076e89a678f712e040a314d1fca88ff8a14161af6c168c101a89dabd19bd72fcc1e5bf849395eff0d6702bc4a35ee7e125deef440b5dc1d3fbf27422139b6e734f64aec8bfa01abbb3694e5c776a6e2014006e3f51801a88ac05933d080ef5006697b4c6a79bdc307580e0f1a45bf03c77fcddc12ea6e7bb39716ae1bb9c517aa2a5b42bdd148bc53f9942032c81042e3890bdbcc172d8b034a37ecbc6831dd32cb57b9f2c67635b26b25817b64a87b3d5d3009bf82a62ddbf5c41574c3a02366d832014078e960fb4ea434301a5f292fd191c33debef743dd7eaa411380f8a2a4e130584a4783b3370317418343bfd681bbd88c13b27618946c3262d860570105c8150a2757266c33e2e238431af581b2ea4872a99248db1923d99bd2f0f1d16f7bf1c4128577d4ad38e75d811f22c942231cd762addc785c8c0e6d178eaddeef1e9603169894e156dad20bd389a90b54f67c73d439683942f1d04bc50c5b52dfe9c559a9adc1f05dd7d5c76e5792d1e3948f553d6ca1216e3743918ae620003bcfa34d4aa385d64dfed891a20c2adb06d3cbeec99c21aae58f5dbe3e2e7c4cc318f80c04bd7c4a25cdf56fc8df0900ae5e132b588a8bffeb56bddcb7445b2360010e4f9afa3f400076efb3b5a854ae8b91d66ee47c66cb161d1eeef7e3d0f779f7ba01e49407819042ffe1bd3f9afe408654fa967874c8fbf3c2e45a5bdbb8467457e98732922cdb8dbfa3811f15f74dd76e67cc4866e0e16e0d923de2ef5b8ebe61594d405c8972054f2f8dba7a06cc2134941561cf0d2aa0d87e1663fbb8c510015728ef889cc6bb4f4f851410cd095f61dc0d032dd505f44e28d8e70ea533eaa87c80e47c842c27e43c32fb8c0ba2514d354418c47d0a15ca2bf1da507b128a3f3cc63ed7d18cc86aa944b94d8ee15b7775388b37924da70bb18eaa14806b227f5d8324aefc2acec43cbaffe5a8862885888de659d7fd66aee3060f3f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
