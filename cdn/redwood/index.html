<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"367c590b9105e6ce37d405a04daafae1cff34893df2dda3581200216511bea7de8d408f6651325a12eb856f37d97e116676ede94ebfc07f6c08ca05b2013fe48d0f6440a31a04ed72d779745e757242d4fd2053aaeb72726fb0e35996c509920b23b5540d17a36e2c5b33667b7c18823c81338fcf3038021dc356a3db0a7fd6737153bc011e2cba080f6023eb9713f418e3a7b571093ed9828cf26e34cf37d9fe620ab54e1073abc256fde7ac402af130b921afb272e6a36bd7e2a72c14ecf7fe9b83d4ed9f6a261788bdb3815083c472c2da1dcc9b09a9974bf5ddeed21f955a8fe47ac90934629c5626e96963e66ec2c660d8ab5c7f79f8e86ee3f0f85b49f1e6f962e91bd202e26c6a93e0774d2eb5b68d81b466b5da86569cb84e9ec3e13e51d2f2032a85e8bec4fb2a3c19f571d6795b7b17edfe53bad860c5efd05d53affb4725349eb4c4c3d6c8aed44bc4cbefb7f58d885ca3b95f637f754a6f72a5345a1d38675b2a7306c6e9ef0694068b7922169ab199fb7a46c70275f42e7e1092ca32d7e94b00a0c9019048b9347359e8ea660289b905ced2922475ca1431f19f028d6cc6547266f2b8743eaa6f23096e725890bef907b9e6c32f6827823a7d24ff5c40a8b87d79e343e030680138a246494d96ffd8967ddfb7df3494575efe442be96c6e6a88d214c604c81461be5746d555d4503bf84922cb368aa37842d629c80c30201ef8555231718d464212e714efb651aeeac91a6b9c48de3d7eb06dfb703e6cd473cb7d0877206ae8462cb12ba853a75ea9bc3d33a77728503e7dd7d64b2e6812126b405b4f6765ad11f1eadb32da8a97141b3cf2b287ce3aea91475549d8d4f3cb4512c284095668c9149c486c0cdf65f8b20b6c9fdca0129a3ddf5d507eda9b5ed54285bc517d382e2e3e37dde11d0f5c3894a047c4ccc2dbcd5d56ed56fb55b42be600f78825f538551713005fcfb6b52cc1cfdbf9975de43a98cdd842a39996a02c268cedf4a7ec95723f918c27798e5ce3cece37521052fb84f905539b7cd6a16050130de6dde352d5360df8090de85221d4f57650f372e4a15e23271dbe0d8d3f4992ea230aad0664ad0bada8615f8196c6da601590367e929833cba731ee0e0833605fb2e1d30ceb65c580ca184b72606a5e0e8dfaafa7ce33bad588774b8f2bb29455eb26eff318167cca0ad1426b9aebc673ada863385973016389b7dae4d64b4e27066bc7e97c5dac1d71ed3c1d19f6f0ab3911560dcfb3680738d0cdf0e6b85a958e895617ec441fc3f280ab533f058f8578170d6bcb396baf1b9bfc4e1ff0a8dbdf2e27d74daff7340c08aa617428aae5789bdcbafdc2b01804bfb5664d2c0727d29458c1e466ca64e557745a379bf721ca200307a840080729b0835830da5b1ba85c33713d3f2fc4cd2c722de20956193396b371e71c179650617da42844d8f1e0c30d96ea72789e28d57d85cb9a10b5b62cf21014fe83ef8f6fe1e9810cf706a456b6ffb4f6b8e79d12dab40dbf36e7b7fe368800d7de54eb1195b83e7b1f034f042cd04c09ef480f30bd4ccaeaad0b9b35e75f5b052b00e82a12758e69eee67c08ecf5b91470981a602a113d74187b21c1f28326c2243a583c2c40b8eb0934d374ba33cb79f67dadf71ee480d3919b514464092b539cf720497b153b3c2023cff97d8b9dcb98ebf29783ce607c754f4db130f4612b1ee7d4f33cb0a1f136c87118f6aaf2aae2b6ff84b1e3b9d5df380608a9a3dc25d44ecb920590e26e3dfc87659937ababa2d6db78b54eef7764471e62e90eea9b6908478dc929b7c8117a499c2c1a06df5203a1e031406ec866f430b90d871da3780e4a0b42a8567dace283de26e863bb9f0ea9c8b61927bd4deb8c10d5c4394127442917d7e8830123ea9a8b519f33a9ebcde67c9a5b730ee449f03d9bb697c785ab5f42e40d5db2199d57b5767e9bb753b9edcb948d80cc673e5b9d48d5df8a98ac5cb13fb706578245afda2ba50d55bfe76ef3638015d1ac375b413d00d14e3c39928fa95d781097e6837240b0d3cdd15819fb18cc645b194aa1f907608cf1f83179f4f2767b63671589c55311c449e3704a699d6d3c416aa5a77d177a039411207eec23a52f5168caa5e695e45ba4e48dc4f903048bedddce146d20117dfa7a2dc866438cd380108f792a651fd8ea36592636cfaa007128dd8ac14598f8a57f08c55ee0b8dea156bd02517b0fd1513d5dac707b0e916a2fb6eba559b6dc8008ed4daf3f021c6c327173d08a8b5685f520ecdf338d3b4376cc8e3d747d5f2ce4a4e7e072dfd5cd413ed4984dcec849ea866e77afa5421088a59c1487df6a33c89f37312c873b2fa36194be56550fe77501c20ed163d4937763ee029688e17aecac11b0646483a059ec9bf581d854c6f54a6a50f72187f73aacbd2cb9d164f192f7c7087c4c4f21bdc43e73f2b2776859589b689865bf9c169f66bc9f155d8252913ba4b577e31f2a9e8656dc488f6500b623f21c41c5d378ffb124a2b51dd84fc7bd48e17f22ed7dcff077b4071b042d28ea49f60e976a889d7f0513f97305365630ebd451fe721a5dbef55684be7e09d6e0e80f6b7957d3faeed4311da77fd602fd967379955f9d1b883adbb72bd1127280f0e6c1f7f97742dbbc3be83e9558914480e1b4048c20ed941b1ba86ae443c708077038ea866b44d650aa3363e00c5b5248e56760ed5a231645987ab76e37a642e0bfa1f782de58c8484a7056e1de15907efc78f1b7fb1466a4d5a808e3a1d3c7c05cdcaf69764e1336735eb8289b5b1c82daa78fbb08f78f8c1fc37d247b69260158c01b216c5006e6f64e9280dfd4f197fef55dc010d9948bd30e2ee41271570ba2401de9e265231bb420548dc5aa5ab65dc3a66b607229d807a5f1ca99ff82cf9f01bb6abe5ceae416c27be9d913cb2ff4d7845a0f53bbb9336fff2a59e7e0d0241ab56f4f5fbda34c812b38f3e81333449630469dc9cd90bc1f04694374cd4c38fdaa640d9ac457b198b0ab26bcad4d66f240e4c9cfe8337c5124513d851f9900d999aeae9c39cbadf6165fdc02bba41b01aff9534a7e396c7dc76568f8b151e5673ca172adb91160a017678451e09ae76d0107b2b88c4c555fd3987dcf0cdaddc8ecb19082d893cd29294178ecef3278a6d82f435cf30c462bb6a59c2476047eba5bc6af061b9de7895a071297ebc3199aed5c8c827ea718dd1bd80d985a9573e244b797d0be9557945ad89e517cffa387f15f20bf48e467384e17da2bc389028aa2290ad98c4653ace0825734e413f9ae2f26ee023bb173271150dae20758015bb2f76f249dfa66e75aecf2d09ec1b77914df8f88845039349d9f7a384210c27d90547cb4acd02daa0e75ac0eb172497561427d16825434400e9171b300b3eaf8908da35f78f98affcf17103189639e287226ca470c12f2d99db084456b7e854712b5d3d45095df48bed8e4af49d54f5a0a42e40c4a892575daaf85868edf213792b5bb3564abd79a3a3da26ab94aac664b840d8bc093a5d574cd2ccc941690db0904b53af88482d8b681558019233d83571bab71b734e3b2438d0cf4234f0d150e98e92f12fd0a26f742a769c4b80044add6dcd598fe1a2ecdddc66c5ce831acbf163b37b354c320b34a44e2cc84d49885e8aa9a20dfd43e81566bc380fd8b144a6a8dfeee96592720da2e7dedfd73a5ac067eb3a3906b3cc333e19ba05e394cdecc4a507a3d9bdd49159cf88ae3d55e3e57aaa1d12129d04deea8b3d843df3337da7a29afc8e886aeb6e92a81485f790cfc911e0d1d8807d7477dfb6ff147755713e4854316645483c111b2d5dedce484364bbca6d67ec01f32bf29890bdc77acdd566b40039d0280fe9d2efb81e3a284c3724e828cee1066435f2364d70a7467f22ea0c846af047672757ee4791952d7c78730c6234c85c1b56cb88fa249a30a232bf38e2d4f46bf83c6af54bb53e3a723ab8a40a58373515bbfe7d15c06de2e52efd17703cae0835de80100e320e9f4158ff4f4a31000ad3e22d240ffeba53d72cf90fb86b608c500b186d9a662c4f4f62e5a15a6165f8a81d44b96d7d0b7361ac48b98e21270027e7093316f2e752e4995de296d70c45b9e4b09e38cf8768ffe99763bf4e0adbe136037dd57cfce35aceb9ad4502070e705314a9b8ad5c37f66ca5db7be903999c84ac6865ffcd8ba5fa00822eef8dc4b7600c068c4f7f48e7865cf618f02e08e469dc60ba6acf8c4b8edd8820828619072a079324cd0e6a8b5fbe78ca3e440ac5013d55f42aa986440d891c2c9c950b001bfb68ca9570bc121cbab6c26b583fb86fc0705b5046690faa5d7fcf769a48d8eb93a2739119348b6225fb539c934399167edb01d4704b98ee69632c91eccb2b3022aa29f10bc4fc629ac658d93aa06528762bc106ac070c2f9bdea42c6bcdd9f8dd27aa8b009f0836814fa746b88d2fea1916730d9497e3dcd972752e7db36e42a37a4555d15e277e11f173f0f2dc2a06fd7d2eb13d4ae158ee52752f2e3858ffcf480147342cae9b39b406599f4be83b576da68dceba57ea9bc98cf1b9af774372b15fbbb7f53ad5e07669ae3ab4ccd51d4e0c43677cc187c9d628f213f7a27c53df1015575ad939bf652036b742eaa2261bba09c6edcf9d8a719eb62aaa6cebdf8b6a11d0f26b9e6c79eee2507a41f7ac772afa329b3eaeb1a7f675bb9ecd2e857b509731e7580163d112a24553b5423621dda19ac0f0932722f22cac3cb8b81838530236069a5a96a22a7b1d2c6aab80ca7f6817f031a983bed6a5121fd95d22da88c9fab4d9495157aee780b2c26ee7ac3b80c800d3992e814c780cb5fa1f69318f8b71d6429288d78d3b6eb8aca1a9e320ec745895e5aa71e1d5e975d2aed4213a44ef70123b0f7b0c39cfed75ed5d6370689fd1967c73ead0b658599ce4e81534f30000e25344644c3aab18abcb85a76ef16d6fc34b4f037f6f7eaf47c5f116984c01bc5e022e819c89f159052d1e4590c19d4b871341e303dc3dc1669f9465ed8cdc324f14cee1e2b94262bc143d70da81cf49c7c03c59b010edf974dadf6aff040d13a5d61f8a3ee3b00ee41ebadc96aa160680512f1e43df62907c1a9263f0fd8abdfa2cce5de3b03de42b0b294bb86bf5d0d559ed9b7406a9e0417384c1dfe7983988a46285f66f657054df0c978a11a3fa942c2f32901f1492449fafd40c00f8848426095865b173264277c903bfc738da656a4c35145ec6db7acb3eaef842184a9bfb4bc069f68c7f4533738e9cd789b378b828de026e50363208a9b12f463906d2ce12eb422bb91dc1d70c40f9b9bed7673701e8cb24031589a6a77f12c77fe7a0020e7a339f172866f57a2cc7a705693542b5db72ca19e1fd063b87b61bedb7cdb778851dfa45d174301916b38d146bb73ef995c3b1c569283466c8084a42358aff258b0eea0de1d3eea57e75c393b3673fe080b2c887804e4204e98d413346cabf6293220dd585b4d90d273092cf079f6dfae4e487fd29bd66c86ac82022f2933f52772ccd2fe13e7756f48c009b91650659db68e00f834510599feb74307e7652aa93769c750463e6a0410cbf00537ee1f0290e059fa9ff03c3b00f7d39be3133580cac8128d3b584e0ee20a211a82646906138eb8b8e0f352ecdf47df3f293b4e39b2630f8674850aba6137bb81d8e7132bbe97f612b94c3f0ba85ef871506f62cfc937419cdbb3ffb702b1e624db8d4891e7ae5b40bfd880b51745f3585893d9a95b2b30de27e8df14786035fc4d47397d5493ba623dd5d0f21a3222dd97272240ef9f5d08ef93da44731c16d565ac3c42fd60b8e932b04947c188c913ccbca7b8e7ff6b71b75b78db2da03555ca088df59046a0775ad3daf519a078c107f0b4ca08379018b8147ec65ab21dd7be4925c7a10eca711fc35be77061e9f984b2505794ef0bd93f05e487c066e33034e74ceaffed3e84ea3263a044682882bf4bc876689c668e303f849e14a84f97c1417f820986542c6d97043f8c7d7a8cd9869c303ba516c2b8d4ee65a3c6af53d9d841b70d622e772e623827a87124075199e99449845c11d73b7f7d5ce4094c06272c42cb4d12a3141ed6f323ecf2dc38abb168f0db923d470ef4a22bfa3f18eaad1efa8f86617164b66ea73ac4f60a6a7dc331ccb4da53f9bb573e3eef3b47f999b20748f1e4788449a66568491b983c98f2552801308adc2fba150b525dac43720ba9154850c10eb850621bb0745f0e01e49e94e4e1832228ce4e56e3b814944c9f0e34edb8f42361cc829ad860f9032b803081c4f2c523544c0d829c569fa20a1872456026d219cd183cb37786f7c4248a4e749054fe1a588350d95bbed746d67e45a8db17c9d3035eccf29ef1759efac480bd2870dbc4d301effd6a4916229947353f598843e8b6f0e2cca6724f53e412c254eda9b578254b84f4f32b28bfc267b895931cc458c3532a2dc77cea2ab35c3a6dd454364ce50e923cfaf3fd38a92ebe290fc2b20233c442b1bab8801b4a502d406be4666fa84d933323027b5dade0b755cfc1d3470666198c6d27492a5cc459b45c8c97ca0144736ea91bbeda513d56ef976dba5735ce66a33e79caff894a7e6d8b47add97f3f66651607b61e3803b215aab942a902e273ad89c52279b06e489984277e7e56c59d1411f4325fd5361400f443fc8efb26cea78f1d60aef91e54e1298c5f408efcef52b710544bd31e245b4aa50a13d9690faf84ee2bd5c52ca59addb539be27fc746750420c14bd2936b7563f50eb045f2ef803b605096924be2c13d13e3ea475b814fb82852c5e55ef232778816498713f94ceec81fd1983e993fb0da67914476eb6fedfc042f8aebff11efaf4dfe063577bc57d514a1b08f797bef385b57e216dbaef1a55063774ddf958d0a30d18939746cf7f61ca6213fe3fb05e3a01cd1f9236edd510271ec65f4611ea8380584b8bdefa9da5d1e361eeeb048a1b482a8a56de8db0f9bf4d275405bc9574c6574b975b09fba1beca9aea8f5d23a7dc8722659016845c7f8c2bd33a0f7fef016158ac7db8dd96c34a9d8cb6b7fef4587d07cbcc651d1092a15f9e7cc69222da8a6a8959ef2547cbc11246f9eabd959c29d5687b3ea3f0291238c15703db79b9bf1a0224eb95e92bdae1c6673241b7bf907b5e7d32bb58d48d5c3661626c17a9b861bad87d10091ae05752685fdc47b563ff570e5e359ddc93851ef2ec61838eb9d13370f8b8da866183cd6b88f4e6bc9a897b69d46293398d335885256c89b62cc6263ce92a773f237b1f667492808bcb82a28e71cb67c9bfad1845dd6163665d06f1693cea338c011fbb961e1148c0c985b499014b614a2fed53e6159a3056388c279728778de2b816d0106fc18dad1bb6ebbca51dc91d4979a5401eab5264987ca018cd15081f57e7b681db7c38b0b3b16df015fb19feddca4e4cd80f375e965804e3e5e9481c3b3a3a16e93282701f693ce90da6c0f750295a982640113aaeaa757b35d384cb6f1e1a16f68f6f0c8088d4422daa605100308d4b649ce7a90385f47b894fbf02fd1e434701eb89c428a72bc22b8d3c4a02fbcedbcf006323f62b9528b25b254f48aca3030d92a7f39c3740ddaafc51020ba759404157999a01b5f73f56894b56b0a0c5d89f854d97d6d3b7e1de1b58cfffe2b4d7ef3f442f8a84a3608eba2a426882297ce18f29709a0e42295e0e01bfd4525f5219ac81c434fef71b8f23f2809cf0589d9e3e9ad46e7beac7d6902008824c062c3c84b746ffe35b24d13cd95f93171ff745b57a213e3fe8794f670f82d0f1ad7da93bba874dd2d584a88eb7885fe18dc21ac4addacc43f759c61a573e02e8ff1ae569f4f10b6f5691dade34828cd1595aa317d6167bb92aa16c794d03f1864d55191549d50d5e630571cf6c0d434b7b31f6a085330a2d53daca7fe19b6a7feaa308c92365df70063405f7b7b43a4d57fcded29072b1dafe10e25bcab0db132872e260095bf520d603763a5dcdefa6dc2629f73c7ad388f38a0b1c3cb4d920c18d39ec72b94bedc93a4389f21c69247cefcacc951ee0dbaacabdbdd55e678ce16f8f12356e5c2406be7f183b64c44835de7652a564d5e78b3942e0d509b951bee027a7b533e0062a71b0731709a3a4bf4f5acabf3eaa1e93ca375b1758835cec550feed0f416025fe1e8430bf4d832be57340958b5510fce12c623ad77a57763c53b6c558f3049f52eaf492100bac424ec8449346fb5a81bb2593d5e8b3e53aaa29b2d9efc98a431a39ac240fedc23eb5bc457a1754c2eb267f9bc8ca403201d28eef66798229ad40ac45deb15f87a1cb2e464ff9da2e5c865b2026e94762926b64a1f4949183b373f440b1b8dff91a118ae3f0c2cb9f5240782e43398178ce912286e4c866f87816a0fe4ec5052bc11a666c3d5cba4883fa97145febb15e0371d30499a5f8c5528516983affe48e8d36d7cf777a91f94bceed4775de5ad453aef10f3211dc759cabd25cabb0827af87f4d40d819657e5ed8f39088b1f62df715bc4c1af10d10af1472b9c1ad7e2b8e821f2b78b550c97774e885c2ce9aab1998335953616774f04ad86ae5dd477bcf999e0aeedb2111fef66c97b9e949208f481b880ae41a8e299a151a8aa500d0fdeaeb8b5577f05fd89f5362b17ae8ee1905b354f5b262cf048dbdca79546b7dde3cc3f837acf0eedf41a0314d4f794824a3715651a909a514e59dc05ee826d681953a25590c7e199cb1269915592859f6f0836265165597bcc1ea1cd5c4025cf1adcaa68abbe65349b60c3a6ef5a227d2a305431dd5bf3e1b8bd5317b434b3dc047905852c1dca0048503962bbd07be88ef32ba883623f216df269070adcf5051ce1590b52af87478261b02873292952e4e14e3842e9c9cbdb1d0b00c30bed053681826b983e8db6a88e54aff083535a9abcfc0ae8b91c149873f06829ea274d75fb91b5a800d03ca387cda18d06e1a9a329faabe905a507eb6e169a42cda50916136bec41a32ec446484bd0a3d0524413700c7c6fc02cf376bd59a36cfa19d317a8a51a0aa7e6b87b7c942977da737287ddd095ad107034f233510dbaa0322c9cbf0358e78983828dfbe73cd5ae8cb104d316f5e37a208d4f518b21172e5077119169418a47abfd5d381693faeb51977925a6117ab069d28cdba2989da31680f86f5e2082e83216fc487da71dbbfad41357504637f90bb25133b216d3fd49afd5e84fb1b409f7613ea96de4a7589580bb6f4a03d726e119bf26d2b1bec04b833ae9936401d3bbd6ab001ee856f6423d7d90a97c0c12aee739ab730ba2947ed735451077619f5a0c23447172d0a62550b8bb5faaf4f3e1df7f9527a03197ef635e41676b666a8388a86af0ad6cdb09a2e4cd849ba02a0c3b3202d6088819be27b38f51b30cb539d2732ea0f3ecf133da06ce8423ee6b37a07a096c1531331e58cad1faf0f9a80afaaa1a3e82fae9a62ec38c7236d4fda586118acdbeb54fad1321ec8ea4da3b1eec61da914a7606c4914afea12e8d202929db5c80480e6d3d61a3b331cf9bfce8304f22dbcd46f769dde6940d549292b09a60498f27ed1392762a27484cacbfd90d517867d28a52a8ce69056e7d544d7f98e7b504b37558cb4d33050438017c78519eee04372815dc23e9d876acf849ecf3e8665c4ae9769065f5e9958f4be617ba86ec1b8127c937c3636068580dc750dfa84c7347f1127dd9387fb6be0b6ab8801b7c00a0731422632692ae76083e9b1fe741cb925f09d610ab809a28b64f6f5cfd5f4d557e0b8026b4e268a8557e34ee4e42b487167cfafd12ec9c99a7386cc407526f6875116f0b698f6d9e6476e8f2c63a6839fa86ad87b40d9f3880b20c618770bca8ec1e4ddc262412594f0fa04cd90e3461e99798591da021970f90dfb363998b852a25c7ff7b605e03c131a140c85f1afa5d2fb804e3d7f7c4a8e6e480345b00144fdea408a7cb6113f3f5cc07fc0a1f1e46197f2f7b1e3f0a2d0aa3670c589dcbb8d8a81066fb73e8d2469b31cda80e90699d7da0ff446931cf6d4ce9d7bffa8682c880ac4ae39c0ccd2a2d66c10924c089333589679ae3d35beee4279fbe9f0c4df50dbbe8bf2b10e859997b9cefdbd67f65546a1ba27107498a5da01ccd462b7db0c5e94d577f7d7c4cd947888a6c8e54bb823acde22eace59cd8ed7e4abc8a5e9e65bde2d1d063fbb333f11825e731bd8bc60391d6cfaf5314bef6adfce8890b7cf66bc256cbf36f212c87da5461df901233f19ef3ab9466d5e23f0f8fa6ea47af2521faa47459ee519cb417b5e0aaa3684d3ce14385328c66ef3ffb60cf3574ddbc0d7b9aa4fac38aaacc98a727fb6e58778ed6884fab2d680dfdba09c3238787c06f78e45fc8b104e96f67f278f0f6d8f6deb825b6491213345d91b33a90d7af8d9b60d8afd249d8095f3e971ad51630d2450d1953980b7a0dcb561166cb7c05dfae289e7cf318fc20635ca12a4d0dea35d21eb4b3f6dfbf7c07c81727f178cd01b418834b8b40977542e95fc293b4c731ae4554dae7c9ab240f325ecdd4e08ba441e78ba3da0b34430d839354284a53e4b83559b3dfa94644ca5eefb37ec7b90fdf1b00582e56e07b0500dfd67e2cf81ccc709ddaa32ed60636c28b01ffe4af77f4f0f8081d7fcc707b0169666a0e95e9bbe75e22639c7a18c363974e7ee72e675e6dfdbd3a3806a6d30d1fb7279132b5ea0c4000ecc89e3a5754eba3714e0eadfa86727e0b0c2d9639f70ae79e21ce175ecdfac4ce8026c5ced553af2c5b9b40705617cb80c7735966f07b43dfe076b173dc56f86878cde2a02ab3f9962ba1e85547fb0740dd29818a2eed5b1ebcac2c66db02916cce624de0971adeb632772dfc19994d260168817023658dfeb96c73c2aa13dc22ab3b57ff9c19a8b9ba028578517942f893bcf47c9ed49438e7a622471b6aff3d14c1ba97c52ee9f948ecf438f46a0ab7ebb0a268979aaa7383f6a103dabd47776e5ee0dbab7f9a07183efa6d21aa22589e1bcb702422701e433b6dd67ab12a3c4de96c55b2ac3bc7ac205dde6dd2203168a45af52df33099e52c9cb7b2526acdb1c1e494925c0c532b6126bae5b437491819b6e6308569d76cb98414290ec1f935a6b3c87f07078e3979970569ca1f638751a3337f063df35aa52a65d423faba2bd8f7b27d8e2a72c7f343ef08d67230405481156738b75afd014d3cc0136b4876ef81143c2e8dbe8478191892bda03ef83ebb4f87b6524d853ba7f5a6ad827fcb1f4a7898a68d104b92f2cf4bce9fe247d724ae9fe7993a090e0325fad0c1862d01364e504685e9d6577248de4e322bf4f368d02267be6d3af61f3ee62318e74674208eba289963d9e5b7144deb58cf4172ad4959f71fe1220913649cd2ef14f1403e4b8a169a6733ec695a018c456bd009c2a62d019f5677c7f915ba082dd99b986f187d185f7f48513684b4f0c50512a62bc2d463245a59b7dccf5b9ed1bb051bb0b3d4cb29504b01b768199353e67adecb4b58604e3d365910d5503945d07cb565188ceadfb8865d552c16af8c77c03a7f3e1ab7ec35084d9d779c408fdbc8cefbef4af0115af6cf9ab57c389784cbd20cbf4bc69bd2fd166afc5c8340bdd55ea8be2118335f90014973e16456076607a16e63346f390327b3929bb4859b50a2973cf8c60ff6db3541d88224f85f544a3e523bec90976e53f05ccb2e1fead6e4eccc9e3c63c4c8202f55b828eab72d6dfcdaa3a1ef0ebeb4d41fe94238bc09e75b033a4eaccd09c654eedd5a2562a788b674af0909f6ecec6cce33244bddd2e50e1dc3db05edc248a0b86424c110da5d3b582b72de56681ddfda48be17d1138816c3a8d133cc7b29e2253de083c3be489d00aefc0a1297b675254c84b0c4458a51f8fbcc693e836bbfe604a5704f29edf98a0c1e8be58c02562d528c522f445649af4dc3422a5d252b4735706c5b46805d138954bad8dee7749aaa5f24ee64a6951fd50f2b6fc168cf3652e5e94a3af5d30f1e1568a44503a44a938aa3ef41354e0b269119cec8bb9034769c5146906856be59bc433f87b0fe8e9ef4e2ccc4bc721bc0c5db9e1d42504ad10f61bb298cd4b3084bae8a16f67c680fc87d49423fe37883fa98ec3bb2cf3699c1fdbc7b4b904e5fbc201db37ea17c25cd034696e4ce946e489025ab81a7ae2737cedb3c14934fa6b266ce79c7188e0f89ffcf66f451f67315a510b9cb331f926a59305ca70ac702436e5c5361c08bf1f1d84879fbf682c9bda03253f5b84aa3c4103e945806329900bc34054640275642e4265316bc954f30986006e2d21ad0079f5875deff235150cc5258555f72f464f6db0ad914ad9a8717115469d5b6d72fc8872080a2ab2911c2fd8b57e9f018aa575a895674e92fe25c55e04a564305971f8c2f287863327b5d99a0bdb5f699a5b4552c95bbec0d578a69f117996ff70c75e0b2eb3aec2edf05efe19a64575908aa99a339c9e07f61dfbc10db0d41f8f0c87319b18f3fe4af27bb4ae532cdd298b1bd9ff622f1fefa80f78930dad57b53d2edd1215a6df5aa00fc90f2327af8544837e5cb78abb206df3185c7df2387725f775637967816349991252510ed7c2fadae66ac16e514c7ab489abfcd8ef425f4c23c8f41c10412ebe1f1937bac9af3126c6d2c045608f7d342f467749a3f6b03446ee2c17b1fa606247c02fff3adf1f0998f618b4fd9174a55472db89d90269c911fe0186d844caaa28341f70c002d4a5ff38ac5ca96304383d935d442ce45f1405be21682234b7b838dbb19691e16832c27b85357476578865d48f18ea76a30788241f0fdddedb3e41d3ac11c78e429e01cadd36859391145a2ae20a68cbea6c0539c4422eab0ef599ebd07868ce0893fa61975591e694e951df2ff59e5e75c7813d99c1d68c26bf5ee58e334c910f6999896e68d2f1e2496b36434b4a49d349bf0b3d19111c98555bc17c7a106da79cd6a9fddfe5a4260c297c926054d221cae710fe22979e3b93973518108ddbff3159093e76c18ed9eaa087493ebeae96b90a4b7695cbb68a4ec3547348ca669730bdfd9800fcb91b2807f1b6b02097d96534516dbca108d68e0aea206fb90294b64b692fae47a89d72146a06be6f7617c91110e7958924426db6994b8f71aa98babd1164d523cbacc7e7121bf3aef26bb6722b60e51d390d17d0140375ac7417ca1e61cc0148da3abbd1c377730874d70b484be07312ec33fc396a9b32cb30670885df470f4500e6203dd712c8922b8f2364c5ca65abffba49f1c6b3ae204875f665c0d5bd367a3e5f966af0ceb72777d0a86d3e408e2a8f821798385d712189b64a309850047957aee0eb3a0c39c7e666f227772e70d99a20ab52d6eea8598214421ff78cebddb5e138041e0c3f8f648e5349796fc59388f2d2e47f50c32837dc091b6d89a91dbf9ce4db0c11f8867845d022eb4535deeadacb59c82a1d627fb90126c5cdbad2fd9f29936864ee7f26d5369b6b18f1c9b80e682d9c7ff63a7e059e62b93f03fdd4f708738a9e5304548c0fcf4965cd0146d9dfa461eb4b61c2722501ec12c7013da01c7f38a0e82a9c8a90c2a6e6cfc9bbb9c75d00b3745b7c36103ac38711cbfd19f5098110edf20fa0af1edb2a83d1db7c01d00037f7d5de8cc8d89b1199b08c3a613497cb29b3e9f26ebc4499573b3e8c0e5aa0680c1142a0b1fc8bedf129a83171082a27b762b59add47a35a05a774173f4b3a9fbe4fa76e8799aad54bd83fb8da29d7d7fcbf5ed620aead45ffec2fe700eb6f69569ad04cfdbd8c6c89689ea6e894100bc5cd4205eb1e878b909d35b312bfbe27b528b3ff400d06a1b34c3488bab2fdcb3fddff6c75aad45f3f06c2cf477f5f518500b319d2e003fe64f1613b5c8446169b7b465cbefb7c6213e1e1f9f622a52cb734e798d75013f54b9f7c697a0420d110161b9643eb6008a4f92a97c0033df317a9bbe6845cc1d45801ebd83723a8290aa240b694f2b528fdb82cbb44220589ee299c8fb61652d89d15de83e8945933b8176535c39ba07e5fcc5f5a6f8e8fca386520222e4f36f351b1ad013a1b0aad22c1e693a48fdfb4fe589fb7e7fdc5a37b7d5217860e5b13b26b35438e6ecfbde769f4568daed21c730a99d89f8ac578ae4fed15c97808afed90ab4d8ade89992af615716f0138893b13836dc7c376c163b6c9caf8159fe3314bc6c45516b55d67faf068e50823e59778bfdb0e67eb1b2ba9d1456feb4e50970f092ddec949707236ca84c73b36acd7a56d914e80b43dcfaa043b33d6d83b413a9b780c7f33e1c6dc39dc6dccbad6afcdaaab38b071786b06de913d82f359fc93d9d8e061f99bdfe2f260c9b70184b1a65a51fdaf56f0ffe0951304b8a7c89befe840515840ce77c4ceaedeaf1d1d148dc79e3f58c1f138c68187f8c5e83c82566192f01359ae73c46618e334846a168ea916baaf9b514c21c73d156d6ea2ac5fe0ba9e6ec92b8ddb0d1f19c1c54189b911aef93ed05ca52f55112738c6ea80e941e72e2db7fc6ad8fff5f44f3ab5331cfe1c50d3dc039228d1050a07b8fddcefdf7d9358241e2f2c87e0539e4cf1e4480cd07c13aad8d52042ac86d66580d38d3c1e3be1c8a825fcdacf649b08f1254d014f4f959dde969cd12fd0b722dfc46be735a1b8a4a7ba39024b14cb66965ee7ef64273a630b3cba1d081023824f7d5681d446bdc4bdcc53b27eff52eded8b6ec84a8bd3033f9bb1ce2a3e60c0787b2881b741fb1129e4385bc1e5f219d395ed1d5b9b4c05b76e1c81b37b10c9e934a3decf57ffdfe9b46a775316bac75b4143b350476a3ba2e8aa51156ad2bce046f941de409d150a0a6cd020c4f96f0e50254fb344332af09a4772144ae958d761634444c16a180396318177b0c1bb4f48aa2af3e798573a86d03b1c7b58da33e1b0f88c165b0126b93e10298629c46d8542448b5cfc497f07dc3bb6528ee0150e3a5ad9d9f87cbb1e5e6644600894b297233249986d5cc7fb7c03bdc0264b48f631b08975127ad996d04f7cb8b735302350d6fd08df3152e191809a35bf9f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
