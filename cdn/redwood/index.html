<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35ffde11dceb14e422fa7f18abc510e1a675ada4fb5e0598f6324a7e239c0dd071bbe80d90bca70ac3039034138fcad851b1b01a732f65a31d3d28cf2306237b6e7381d2916927dac8b7ddf863b78a2387cfb046f342ae4fc5e6aa2fbee7c3995ea0d06e714f143b3264e69f867658922d5fc74ce59b20fa9314c960eafc1bd74a259b902c94da511c3fab880708c41aa4980daeb856c429284d7dc79be18b5a7f57602f9918d4e9022ced7ae42ff158a696232a551b3b6221bd1dd6ff5fe3c29779d26db905a20f9e2fba122422e0d6a898755b5162a40acaf5abd020684dfa9946552c17663cfb6269fbed7805a88d48faea94ec60b64385d447cd121dd02558f0a4b55c4293aafed715b8400113881491defacb7285aa131c8a1942e46420361890b50b40e1fa34ccc86f7ef847c6ccc9cc675926714992bfe912b4b623693aaa89faac629b50e617b6bbebe510484ba3e0ded0aafcf36eca42b5a9cf843de9d2751359da4ee843242638f155a4350d99b1bdd42d09bbe27576ac2609ff4c07214fb577c95c51f4cf079713f18a967e61120b36f9fb6d161045f5ae7a178f7ce3723d928691bd6967bf5030353ad8911bf3230bea3a4df993636c708cad6183444ebe099e2c664e6d40b6e9f77bb67fdf3240276cc7cf4212f4a992650f2472af12829b0f098340c07bf69e6aa1d2b14f17403792ccc729ee4456f8ea4695c0a40ac5522e474bbe3d4b699d7fb66fcaadfa14a849a8514a63473b57003354a09acc84447ac7aab6f7f10accace012d1496341f49f11f096f8b309833620f2002271921a97372d16a68873d1684d61918b26541ea7a39d2d1c78fe3b89365851c9b21dcc288a5322fe610346d39e266c134db123f1367d278c09a6a1b37e016415bfc064fd249e6153a62e1c4f6cd7cbba13061d9bdf4c8a83a888be85d09c9e6dd26d7b3ae9c380cc2c0597b613c2d6523a26a17a922af15dd468d4f98e01bf2e6e537e579988668b0eab3a0b13ec88a09e08ec51c875fe06139fbe386986cf7848019023adbe9abd26a661cdbfbdd4aa913d97bad8116c822023358118df1ed5db4fb60919f6029fc2e5959094d3c373ffac961253e5163ce31581112fa9f2ab3359d9376258cfbb9431e1cf287e1129066f2c385dee8ed98235f2918e899edf94883a3746ef3a74a6547870a8dae6b43502d2e8eb190cc4e9dd9ad37b8ec6ba65cf6fc7c9914cbfee9febbee76272dee91b26c0d071852164697402602fb88c1a31a2124f2d53878a7fed2bf091ffbe07a271fdaad87b88443c3bc707b362ec83c6b7fbb9412e3aa389d9a96166123501d7ef020fdb66b2357068795c94f9082e718e4da754beb4c8258ae1147341335003a0cfe8fe7e31e6a573215fc63b05c74c75ee13a3a3fb26d2159c68840e2c30eea4c408569c7588e907e825972987ce60360a055c7cf567a177adce14d07c997178fd15b207af6aac6f866484e732de17bdc956d9d2050ab44a634cdc65b2072d35e49dc5dfda6272bf38fb0471a4544a2630c67078f507df1e28c337df9aabffc5fe95f82de7a79b4ad81c64f537486727b2e3b574235e952523d1b1f2836e51bbe0e7224c0af25e4645ec2573221805b68b8c187cb47687682705b6b910e337532472f1665a7c588d3ed3f666103e8d3a7f17ecbaa844c80af64c16d7896b1194570d5db3ad8e4df989d84c8e1595d072cab3f131920a04a70825683f7c9308f488b955bc08e53d172b9544473c15bf65dd9185db6009e3581217a9b612c903f8fdfd1039900c428deaea7764c170a2514234b413373b2429d672a8618a7a8a43570f1d73e8df94f59da1c4843de443d800d2f529a719b41b94c4261d043ee22426e90d903d16bca313d26d2370ae7befd4e4f5678f77e98342d526c7f9d444a332ccc2a27c5028e4d55852a9b5156511f6a23e37572723dfc472c65c299a145dcfd1fc4e2c2041f574a3a4cc5cd5235ec035a1811b440e760dc74bcd878ea7def937ec0ac23604c4f5678fd51d9023483276e6c2256b465ba81a99368ec91a91160aaef2b520750f960b33ffd2699361a818b8c3b6ecba39fd9aeaaa01e10f307c19e8225c4b5716a2a192fe6eeebd20d9f9e842b162c4b536f59c9dc7ede3cf9caabc0219e89d5f4b0d15e6af538d6d77960bed6566400bb3c460d8d7545487ebd97c3c25f893a31ef103ae3ab82c071a904044d063e2d92de4248e623168cd3c34fc2668e562fa3e17924d82f22683eebab7301b68e3aa7c62c4e16978866102500f2bd6828cf0108c7075c93d908a12ac09ee6be208d7aa65552f93d6b3e88fd9a7ac5036290e22b1f9dfc9d7aa5adaf3e8c7639121f8c8d13257b6e3b414d303d0ed5249301660b025feaf168e4722531ead6a5edc0692b88071b47a2ffede3fba25d35bd41f1b9e6b795c5e418ea86f537dd5b3738115b29cdd27ea81416ca61fb19531971a22c0ff704a1bca7134766ace97a3ae0f5bfa57a1999e92b05b84afc805874c7f27a5eb7ed953aa664ebaaa0d145fd4e7eb3a953c961780c1f6e118f7ef4c583085ef8f51de26f202a0110c498dd9b89e32db9c9df0f7164e216e3c7990b99c80325bcd632682ef30087053927ae1372526226989a6cb4adb14fabdb45967fe19ade01140232efcb8091abca278439b799329c105b7c2e15101f040c737ca121d0a11c39f1986f3fdcbe5d2b0ba92fa3252a5c9982f0d7c5f08bafcb631736255e99a4cea0d153775d34a4482c1cd235509955e8ece384499ab96718c30e2fc34cf130c9a96e95b464dd7563508fb602d611c0d220c0431f5c1b944311a361142bec9bd7d36d44777e27b155af30ff76d43e2b880ee4ccd3e1e4ba2c5a7f39775ac986be488fe71c5db822fee2ee21fe554f1d5cf0c0c7393fc08c75d8c8803cacbd9898ae6323edea74823d336788de0b38e281bc7b22b46b1987780067537c5c5546ed3aa7d436717c408d6d223d418d4cc70b67e7adb97d09887fc96dd2755c426211a02949a156766e5b1fff082660288f2fcd84d3e5ed6c1b92d95f6815fad38e8de003145f78805cd1e0af020965c834f3f82b79ad4b66f9a1948ac269ad75d98b561e58fb63f62e9d7420daf9dc9e4cbc58ef2905ec5340f92ecad134872b3166374a2be2bcc65769ad89e6057ac903047ac404b3c76ea64d2e0530a68a05bff7687d92cd71a496f6266b397241bd65385501185c96665f1be4524a2bcaf1f12f8ed8fc82c79df74e2a9b70f81c430947f7787f9fb2fc61606cfd0a69aff1b7f745632f7bdda840e53a14f0ed2d99b429312f3e98c92a5ec8f31853931a3befe5c2609f0883a59607a25742890dcd804c888789a23e374902631c4e1730f25e5752b74ba0b7ba8a1b849be4852478322f273df76f091fec89719387ad42367f8b02a7a0471e82da2aea12c65df80cd5ca116818fdde8a54ae66c2f8bedd5e1c900eb05636c1e47e765359bce91c8cf1db21077e7ab8b752b6b9864f7c31d141da1163a7f6e99bd44a4c8d60e6958fd751704856ea6de241fbf840fb2d3dfca8e4436d96d946968e4137de85f7592f3be6b4cdbdb1632b6dae59efcfae7a6c955ece0629a22f4d2eaf11943d85bc78a7a7fa1a9bd29ae9459af337855bc7eb1fea04da8321e3ec812fafb6e2af177146f3e1b5391a96db980ce37f0bd83ee244686d5ecb169a8a608b4fd85e7a5a208451e001dc4a6d59c0ca7f6c5485e31d10e2bd66179bdabb2cef476b383713b7237fb452e8a89d5764956c3cb14d45d1233c499857cf971a9f4147f2b4b19e944c04422709bb5cb8894ea02b124403aa6ca336d8978931b97a7a41002789b05a8c64b3e8710aed8db7424134ef91b086965d714dc4bf49d3e5c5c246ac13613eefbd920e757b4d85a0d182ff4616607230393488745a0e022ba8b87b94e6cf354b7a37e5551c6469db11eca645310883acef1a16a65859905361e5c5a34c35b0a4592215035e40ba055ec8cd6da3650c1c4aa4b18018506612ae0186e70029dd6ed1bcea3a3af95c1ba58e217d174ddf5c4f89139ff0bfd6ebffe0fe6762249040849fa3b1adaedb20887223d6de9d57735b93f24a813700bb706e03d68cba8959dbd973c0155db965edc33077f4193c976964c42675eb5a1741c3ed8469582653e87d00155cb60b02e1159ede8c0c5cf56743d6df3bec1f58def83ad4f5e086115fd68b64dbd684460d343cd23bf4cfc672138f09436fe5aee76cc9f6e85d0aa6f854ec103e04b046d69f7e8bb3cb28f744bf3ddc46da308a7482f5d7fcde9097cbeb0594898f8496b80bdb9935c4a5f7d4e56e243d8c69c066296e7c007b4e5c28180d5d869b2d2c585bb82ceb46bfcd9b56352d20b83ff80e60d1ceb8b8182236994506a56a4bd4869c4315426ce492bbc77b0db005b8ebe8fb3112a1b69bff9f99b3bec9fe294b5d08d0a2c3e02b77bd81644ad8463ec66e9f51cd446b26f84a19ad9d410efb1b4e521145aa33277208904f624810de2edb04b44ef84ea6031c5910bd632dc2dee8a7d746bbb6c5a1a95aa446617959ea909225621f7a7ab2c755d94c545dee53ea6a0a563964889105ac0e3a6346ff4f1f9a1d68792347cfba2180e09a9cc047e764af477342beaf11bf2ddba235333398161285da51ab28c33990c369595cdfe7354eacbcc40b844e53e0ef41d05fdeb151c25f743960c5750c5dd38359132c921e63848d17825be038cde0cca08ad23a17dd62f20334bc531430cdc7e140894ba2d86ad8e3289d0992c77183d440ea1c98b4eff01718045b7b838376f87a6aa69916abc8ac6d2eb786e26093b7ef5d930e5aabcc76d0f17ea3397534ee872ded959830f8faee82e45fceca1994edd636910c69fa0717b9463de873d700d43a54b989348e24c593eb09d0045fb161ffdf851ec7989b5c807fde04fef7a37594904a71e10209ffc6457ea32cddfa2732eeb6fdd949863c49b8a7c24162661e80f071a3dddbe919f06b92f25570d4e02c1147310cb7715da8dd66312de0cc49071e728d5f0b41c89725d927613843f7013ce6eec7668f26c353c40d481ae0f3d07e630c14c57c2c0498f239e3c20de84c532c66c8ab3742d2ff7b4d93c088d7310856543288ef23eb77d81679c71494fea6816348c858739d93ee15abc851f32f3762e4330e06befdf38e24842b40dab8591ee24af6797855e4807e47dd73b16b630ad0925091ae94118cb335f4d977b2cf60ad6af9081e8492219f67a609a5ac4c45a4c04ca94c51d441b63b8c011b144672fd7b13ca90f5db4b242bd2474870bb43831484edea267a4b06c28ce425f92f0552bac0ce35c366b66c5cc008bfb6706016e0e01d95429e05c46280cba6b3c8aa0fb5b41baac4136eb54a7b4ec15cb025f39d5529aad9047f76df77c63095aee77ea893085dd6a88eb463d16ae4c47da15c7e255bc8c6fd4fae5170c9ea184edc935acaddf5f4c151dd563c6de228cb930a55a2ca35a94056e1717835072aec58cb301064b2fa0bdacc6fe7d9aa98850af58ece479fcfb44a81ae053bbfb7b3670ea41d5866cd71da141430fc067569d507080480261c1bc6c3840208836dfd9e12408866195730fa2287b502c2cea80d92225304d25469372eabe8661a0047e86ff8acbe2865410ce2e9488fc31e50ee0106e53483c5659e04b1d69cec6bafbdf8c632751844f84ff4dea9ccd14002406ae9a87ae6a935974cb5e4fa4aaae1afcbf89768f1acb14979e54edd90375945ebfb9efd683e48a0bd8040e3ac966004a467f837c7ff6749ceb743f6ab7782b010cae2702899b396d795cd331f8436fa4f223923666ec1395d2263b2d5b2e202819af827a85a0a0968860aa2b275b7589a78a1860ea90c78353ba4ddefe91cba87ff8166f07b14f904d4bed62bce095bb317611d46bef0b1739f86258ed3a850b8536f59705cb1aea09bae50941c3a82b3260e2f765bf2b5c50c1bb59b1e287cdb0277f192d74236855f58534924ba45cf8fc72ebec1e11f69c804984be7a735ed3cfae8cdce51a75fad712a05154b9d6fa5dd12f8918f1460ccba10b50e38d04b354a072d026abfc9d77cea28250948df00d7486306cdbe24b46539aa8e058f9cc7a98749acba2aa847c71f60ae5a735b02704390d0ef485c2e633f5846d8bc7b9802fecef3d5ad7e84927349436840db7b103729e90b01acaa26987e6464518bb16f367ca68a92def5b145af42fe3744121ae1d1d8c753a1c0205b05c44426f0755ac3a0dc8bd7c6817b7430f7ed948b52a13f0e95f4689722a0c36c59edc56157e32f4d87f5f0a36fda0bea631093f8228342c3eddca92e02c970ac69eb1e681c092ab70b865c9709a5cff78ae27614b0d7d27ef637bfe7ced2ba3a2fbf99f97e007ba593318bde1ffc12943804cca1fa743359f06245d3c31be3598cbc4001678f399ee51a0324f244e7c19f1268916462ff5029602758e1c605556b6f0b05a3278f052feb35a70304ed4920e4a35f8a043b228c04afd4b227557cc0031767d9010ea9d46eab6959e950d8df05b61075954ef6cad810de88de7fa95b0b023db38cf28ff919f11857ebc74763bb33cf4b2a63de588d73152fd19e035534b0e87ce84276958d184d1aa405a64a89d951a81d0b4604707dd504b1b4a31437761d5420a0ed71570ab998fd73915106c8954548b749f1a562a5ac8107dc028efc3423769150223f328b2d9c57ed7f04c40562d849c25be44f1eae3b4cd800a041985d71eae499722aecb1dc4c9f32b305f4435774968be7433d027aadcb3ca95ef9360483e0b1084855e114ea33ca90a1e08ffe14c66a9e32a54d2965c3645885233deb7e7c8890fc9712092f2c7dbff9f914ddf56081dbcf2f53516f7aa366d24d39d8f3cb0c2288721a93d89dbfcce9a9011f6549cbeb7f0f8cc61f147e0308bf063ee088663c472176d66486ae8154e2d3dd2af0e4cd59049126a9e92a6856d0290cb2ae5e827a7f304b7cafc028da14100c6c9b486f3abadb2227a00480f6cda8c4d1057e21ec4e68764b036626e4aba4423735cf5eee6211230e4db13d52cea0b1b02c11fb0a4a83ebcd1f83882f4fbf1fbae0385c415e2884cff33727f01b11f31b7887cb36edd1447e3e452d48a0c546793c69c4da2d55691f93f4db7c9f8f69c5025a531566ce49ab609214a7ee510b816d24b9f36d7e0dee36a05e6906a886285be99117684288a269e5b9c1b86486832f5f0658fc8832ec1ec750d3a5d7d1ea286754cb67f176b1f447ab5fa252af7479c59629359e649276759c6d8d49c6f6482f9bb9f89ad833c3091582472b6a84460ed08da2d9c3904142fd43b20f5df39144843812db94c1bb8813bfceab8a8f2fa9903812f93e62ccf04d0c8d6340cf3bf3443dc5239cc865895eb843219db962e7b5b74ac483ba1921f6b4e23253cb2f3420b01a39012a88a532afd920d09022955229845a4a62e7d79a9af9a86f4dc97e129ced459f17e222513bb04b5ea4b3228be03da780da3a3b891c3602917fbc1a0bc2b6efa23121f1302b408cb0d763b7306e6218140ee505cb9f2f402968bf7b325639a07dfeaca69942e62afd745a77b1f7471e64f2ab4843b8ce4f283e64095cd5874515bfeed91b76035e3a144b4d8173f7bb071ef9fe8456f68b532deaa92ae41505b0163e5ab5fd2b50cbcd4c6c96b9b2a06266106fb351e1b68e8ad809fcd7641c234396d18d9fd75c1a4c4ab66a8e45b6e1ff8c24cbf999144e2e204c6d55eb3ecc02742b519a2c28ba3f86ec51c8477a5115a43ba8af301bff4b685b22136bbd3fbc8fb1996ab454e9e1a2b7b10b492d4168195472fda02f68e3cfeeb082601fbf5f24c45c65896c7f3cb1f9b05eb206332e5a4ecb621ddbd0d8a5fa10b00726b3bce3864f43e260dd332b8b5aa727c766e3c77ee8a6694aac991eab8f4914f749e8a4c90ff95c8cb218ca1ea0ba0e6489cfec6ede4cb0c5b92c3281d4a77c8792c9b694c0ffe88f100667cde20abf41c6ace446215a37c1a07f201cfc00212faa850102a28fea1566ba4aad85df20926f620a9cd00a1dae4420ca31cc20539e020cf076a22a3246d919bbc740a7b53b12df183bc86b3278cb2aba919f257c9e2e59ba6d19ff18baa64b70b3c1f9b63999794277c938ba3d94e727cc9ad9a89e8e8ef932f2ec1fb9fb50a923898c16f2e83ccb48d3f88743cfb9b86e4ec3668fd8485312b8f493c332a1e7ea159aabdebfc2be478cdbc3b060424bf85881c81e91ff7205b9d6c38ae59ad08da6f593cbdbd88df7e860fff059714b8e424f593a80d00b81d2ae6284f66c39b4a240d21de97478e254e20a267f2459f58021904ceb9e200418650e27835becc86cce66f3fd53baf51feb7ea52e92e958214d8d5420903db3c13e1cb8e4ff409b0ec29331df71acf5ff461673ea90273d7a634cc4f0ccad028ae846eae6cdb5e8a8ba1bd40c706e18d0835b81d7302645d4f74d8a1cbbd0d24bdacdb914c3d9e8d9d7d7821b03f6b95f3a4e9f09deefd72599d11b1aff06362c597a3138cc6c7a0cd2834866e5ae6519c61923590d3dc02638aaf2d4cbc7941fbc608af9d6cfe121f2033e8055d7ae65cfdda45ded1392bccd33cdcc4d3b51b43e2c848a2ad7838eb483041b543c6694935c4de3b1600070d8bbeb6f1f51da6ccd614743c9e169eb4b8f4e158c2666039e275bd6d26bcf19c1078de614bc5ef128a844242fbb62ebfe221a6536950b7b3ce87576654ed3b4154adcb911447e83ac4db0b1d79f0a763aa86c7f49c853a81a428037389743a06a04e7fda203212668be4247036e70b1372be6e7e8d6d5c28c3f9a1cc2899a7d131edb1338ffebfc5548e6da375de3a52dfe4871e2383b8dffd6c114881775650339e3d9c715f0faec095b8d78033dcffe5f52528131b92e54db6a111a238ded4f9b6ea3971ca063928ab5febaf61b20e934be0eaf770944c3330b65cde4b72883cc25e173895803d63f6b1731cbcfefdf27aaeea6708f2789a11702bf9a60b1f4572a20b0df9545621d9b595a1dbb8c698bfbbcc1be4ac8ce20a72957cf17a423f125699f5fd12ff8d40487938df1ce0fa0ec749e7b50ecdbfa437661844516060fce3cb1fd080f866f8ed2c83e7995b09db0abc89c59f566c08368570f6ee32f8ee752fb3418bc59775033f1b8c85c8dce8b355fc9aa101789ff54c647f5d3bbf5bf36a2e3bb36b811e3689d287c4e733f6939d4616329085e85e2a12aab29e9a3476eb6f672ab4030e3cfdbc584957bf00d515ea3f9f5e5476a29fd282ce56d29ffd784c7c334a996569ad19d01a149f9e4d98800c327224fc80468fbea3df5eb4b9a598e59bbe90f760337e0437dc89af46b14c8638f31991d98427cce8b0de4f3eccc6b93d21a3f27d33adfff640e3dda83ceebcb4c4cc2e94e560e14ad8b0aac1f8603e5730e2511e6e7383a398b154f2b6c772617f5a5cad8b503e1109fbeae80be794c5c8ea7e1b773bee851036207bc5b85f50ddaf7e80b42b971c448065fa5c7a59679b4a5daf0aec4d5aa4e91306977ac8d114ea27e6d2ee4412ea3e53d29a768ebeb34e08a00155455a2b51c77ac890dfd0183594bb919c8846e2bc27bc7371ee14635bd6e048da2d67d178bbc598040e5714150ffbf9dd0660b13134de9b4e0179cf079fe8b1807fb459797660f47819717bcb26b9ad24772a51cb1b7765142f9316ae836f23f447f108568dc6686e6c36957a97cefcd69b39242bf061be7052e506f054258603b5caa9b05ded641842ecf87d249fde3272c247238bb767591ee49ca1bc92a2c14e2b862a18e3ec7b2123f334feb44870c0650f39185fd5fbbe3225a60815b7ff1275f0ff788516c7e1bd86c6d13bd6213fd81667e694815983c7a88e8c698fbbfd94d9edbc3c8c7e480e667a2594f96b8776efc0f652db85901bbea6b158a253c6c3b33fd2b4fc58ab29d784cf69f4b73a79992c079a40798564747e7b161a8ceeb350e0ce2440900990a53a24014bd1f6bf34398d5d7d596975cf48d361e82ce2e074d1475a2126e035ae9e8a33e9f05a25e6ef2eb14c0198c9c9c2aa88fb7c40f4ab36a385b6b2f547f05238a4d23004f96f594b169f5849d88a02f063ae41ea21384241cd2bb28af263a0a62bd726a79f2990cfbccc8ab646f05bc77500f689462656a4c6cdb7ab921c7e7dab4a5db898a2b797e621c9ac34dc93540c75d4c35d272ca79338d1b9f033ec20ccd43c08ef89ba88e465aa8882b2ec5cae6ea6daddb7d71e56c4af4f38fef152e4b8450132f1fb85968c4ff87c4b13fd8c3e1a0766effeaa522ddb508786fafcf73816b224fcc0fd72decc19c68fb1a16f36f39a0a965eedef44713d97143a5e9aa4f2eb851912424aa306d2dcc053bf1072073748effbe8b417d3e4d2d74f4502f3af9755fd9c463841fb2b14f3e375b95452ed0496acdb97903ce1ec579743d7a57db8e194e8f3a809d8f7fc94b34954f946c5ed7fc90335e4cdb626f4a7f6b82d0134631c3e5cdd858e2e26ff68663695508c5ffbffc9ffa87bffd2bbda4e6548acdb86eed7394249bf33d3229359122c1da9c7df46392fb02c251b647589495552536337b3b30db1fe6657590d1c06508b49fdf2ca0aab7c368bc4e149ae02add53374cd865e548f181c75ff22b95368fc7dbdd3014b9438d95910435874e896d7e47f9b652d694db1778ea7939cabef8cbf83c77358664ca25e8fbb3fd46ae7900a03cc380380ce54041835e72713dfbf5cd106bd0195fa213c3224330dd76436c58635523d9b551b6d777d0e544117f479f85aa5d52a2fefb3e69d476fc5a47d019e748864649a9fdb8f1cbe5b4d6ab2018d5ae462fc2c50a830bc4f7b92cf7e4dbc104c40e51729a4fc1bbf10346f3b519785ce5938c0b40777bc271c2073340a8d032a8f8bfeaf7918d6ca348915c14342075b2e11c8c3fc7ebc82af4846d460958e00c11059d835cef56c98521ef4541c332e8da9899212f84888035d371574aadf610d5bfe68006fdce54d600f7f741d55072f0fef4ce28234924cd5007970d015d74f119e002540b2d8f9c87aca3c7c18ab4eaeb6d43d9f04d4171dfdcc06ab3c57bdcef6328e3f5f167c84bc9a87d4becb67aa737dbb2c63a1060d59b1af9e4fd368eb77745b9c4f095e768944e1945a772296325c6821aadca65225a63ebf8053a228c8df9d0becbaf7548ec7dba543c274875110c508d6ccfae186524f5a47ae6757048356976fc8827816f7fee7664dc3f9289bd152bd11dc3ee46e0116b1e7521750f126c2a23f30c9f75fa8b53b905c150c152350ec5de1cd4e22a7c2db97a6828f7bff58b45008ff6e7ffd8a91d8205f1d59d1114d249ddd082e4dab71d95c82d42104903d1f764a2f1f5caaf63a64280f9e7445e4d01b206eece3987194fde812ba596673d2843645480a750f9b9555dd30574f90da25c7631ecb087cb0379d3e38ea5d00b39b94abe6e1c6f3014e36baabee5cf3d03de6bddf33be5e5296f123e9bc8b33f1f20ccd80f66a422714fecedf3f67fa581bf868daac5c22863ffcda3cc18348d347387f112166b10a29203dec6c304541fa72c8baf2ca6a5027f568d2845853dd51fa63e8e08a7e26fbc00c32cc0d52988cd207630b6f561cba127778ff3200f7606059a0e702cd82f58e47398a1aa4efc2bf11682b80251aa14bd80a7b079030c4314fbcee32563b2537a526898b5728a6409252f086e1646f07550658c370b6a805a9e9f3051b5385bbd18bb17f6dc710831f195232e58a485d4cc65f6330b563974f7bec787870bee10fe06c9e5fcfc8368b338cbcf90245d9757d50a999db2271b661abdc01d909ba47d70d29ac5e1cfd97f178cfbef2f2ac1979d928c75fb7bde518936eed05ec68dfa61ef0d26fb88fefde33ea6eb4f4d6f3fadc38d714a7beb36c0918a4c374a77631d33c47c95af5fc23123aebca5cc8bfaa1d680e825e33b9cc0b3895caba0604be60b9608e59bcf63fd943e6300c49d142556af3117bffaf9fdbcbd77a5c6b528e356d8bcbb3146a194e0467d8c0e95893da6dbe4b926388982efab7f1ddf8e547b9dfcd14dea081f7eae3d0ae7c4817828ac6ab0f500410bc53605cc89eb204f3df00293a1ba3449b7f52758f1352f24381b2d299db374aa1b7a5ff9a5f7ac4ab6a7156d781d1bce6ed62d236bb3776e790cc69d2c7d1aa9c075c29a582549860b3790eb6c3477aae251a102d582f87a233d319e120f399a3bd44a35678fa3900fa49aba729731c965930d1e1ae26ecde1a86ac056480577553d78ff37eb67e0cd870547dac4a2755fb9baf3d1c106fc8d0cf6787c26cf4f95cb494aadd8b393f46cfcd3f8baeeea6535e17c8ccdabe246025c1937f767d525c5d8dfdcd82f9128ef012c189c9cfdc3efe9cc9f517a7ad3da4587b438ef795ddcc75c01dac7474f1c46be11cc9803f98f43272238b71a3747eeb009c626bbeec81db99e766f07d5e4c52ccc165339e2cdcaf79a3cc3960290a8f3a50d8b85dfcb28ad20e1dc39aa59f3318c3fd39ea14610a9cfbdc0956b90fb336e957043cdd813901cc67d2ba31a2d516c1f2fda2c9182d8f1cb5c47d9a65ac24ceab61235b7689a68d86fb956987742e17a8a51e4756a9810a1d0f5920d4d7b523efc3cc2bb1bb8224fdc1460e4d624001486b72f2f8f91f71b7fc07ef93d6013cda9f0e94eb1056b1d681cf0708b7383da2c9be8471693eaa6c049a26f3d3e885803a40406ebc868a9bd0c5010600cc4702272b3b4ef2772358daa664e60a567c83896b07ac10b13189e8ed898d5e3b13ddb0844709936eb2be49feeffd6af8df1cf72f458b39aad6265ae237a264b9970db6c9b31ef62c162896b28dd7ffe4a25bd5904eaadae826309e9764da2d08c067fa20fda0d234ec8246dae88cb24cbc7c2c9169165c8c2551e04f19e33ef0efc1b9cb3919be038fc56262b405eb901008f5f17cfaabbc15351ccff1ff69772695cfabab0d9df862fafce9e5fb346f9442118bf55491789440b2e8d938d18c35c674567c4d78817bb70bf54bf1644bca9164bb365a076845e24d049a36e2ffcefc8f413416686d266ad289f4147e035ad53cb0c63ae992046b4e2cf9952b13d246271ac6f789952433e80866cdce89e33219570dd5522fa6645bc3a751566275b3f44bacdd5244547c73945f0e3f580a340757bbe4a6a94cb266523db2c7666f452b12bb6fee15afa89cfb0627f47c780e0c7e9d918e05f628d6990b60087c1f75c3821794546dec6720e8147dcfa5397f10d4154191bd13c60071153a085bd52af0c464bc903346728e460e4efe5f5947f7c46481fe3be7d0de5b08228f6978dff3f7890413fa9a655ab784ac8abdae3274492d2975318fbacea1d8513cc02b3ae2201c78cbd2cd4e7dd3494850c6b10172898145710fd8a1afb8260aaf6772f62205a454900cbd94ecdf9539e75422666f4f59dbc7405a3c1f703f85e907be84bbc35d707c5ae6dc3f3990fd2cc9fb9a65784ddcf1f594287230b331e96203350bf0902a751bf7fd803283196c3128164b1712df9ff037ac10f138b97a704345197a75a5ae9c392872195a0019168c2a4edc86fc0b468a394b7d2a53848c92591cacdf43d782bec11a854f1d240f262d8c6019b1fe40e9183fa1b459521fbbb0e1c71c04e90635cf5af4abe62b751cc54ff30b982a7c3563a24b1c17a0a13b4fd4c3e3a45077b74a4b7c4f8293754228596611365a8c4116276f2da9455a61cf7cdbf07f2fbb1c5ce5a96a123292b1ad92de541f38974526f00732165e1a6a51ecaaa25a32461ad66937c8f9930e541d8b57f6b70a6476c23efc921ca459177735f7a5fba1b4566734aaeb481de4dfb63890d2849929efbda30bad169dcb067469b8450b1d6d1da46f94d5701340b7eab705e132f4b9c4a34766639b2795a1b0ab7edc835af07c4ff2e06c4af2adf2e47f56e992f42e8a2cc48eeaf66e452dfe7707dd2cc7f57937bd1c9c3fbae2a336a315217c4661695632cfb2d85dbf54a306ac48cfd32efbebfd07074f1911b78bb5c754010cc4afebeaae8a3ed6cf89b96cfe35aa667c9549eadc1d4e7e0a5c08bc4a9d66eeeca3decff04b8cd37c8f7ec7b7ce6ca85831f61203546d2463dd586e27da454f77588a2574b62bd053cef00274d9bd4b89b4aa8c6f5f2b4f30b731d63512de1a1ceee7aaf57c3a6f1c9f265162c459cecd6e8daa8b9ff294ddb3d4a9b61f9016ac51b97db56742b0e6f38cde4b07d1d2d12121d682238a7613c1112a02afd50bb01091e907644bdbeb2ed29cd7fd23a6060df02c6cba315029f6f25f9be33d57577b589a8f4f436c784f6421d69ca569c3ac9c9614e650834446d23d1a076efa06a206ee3be1fbb83db5634df6ba2bf2ee05df4acfbff4dd47b9fe4018502963ae6d75145e91cc2d9c4c95ebe7abf89e8430c5ca9b36ee117106b280a06d649f9cfc29f71663b1bdb59750ed197f326af220803241627c519f05e3a3d57f714683168031ff645bac1cf58df747bd9d605aa34200177635941498fcd2f6fb55547b0dab3481267a286228aa67f9e093dbd5742c7bb93833dff510a9b6e25e05b24db2e0e2fe280d4a5f23e19e541e26e719eec509f30326b58610e06c476a4d713bf906aa55c2104693426073c5530efb86ca1b704e5a27d7aad4236106c6980193f34b5781962be7676d3bfcd17d0161cf0aaee185ea66dec7b814e48a26cc74cfe2b751500934c98e715d2733432fe768d1662fd00e3b2ca2a964bf627bdcf025c7208e66ce70911f76f86908b8b1223af6ba1552fcb917ca7e44b873c13934d2fe1f9aaffefdff6db5168ae1aaf46e833e1ad58fe6281b85e75cea1d8cdd462ba9fe7f2c0c1b4b40a7f9404dffeb9f95d7746573f2fdb9b696c0f30b2303c59d4b4bb4ec2281c2281230eaf618856d450bb418607de6e83f6727aada9bf503d30a1513a4bbdfd1ff64b88728c4b64375381b7a9150b6bb00408c096cb342c10341ca478d6c4a0f956afb8a684ec1223aca68a3ec11eef76afaddf1905bbd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
