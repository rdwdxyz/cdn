<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6824cc3b6bdfd4a662519c70f4164b4756bef375eb20d623f44cbcbda835bc86c39f7116426212b9fc5bb102c18e8d7f18f8f6c619f0a7cdd7c8e2d2579451b5dd7f5a73844da5ec084b70a90b5e506fb28633cfb20ade11468130af1a93aeff5f033e5da5746b6c6dca21b9d7b9ef7fb82197289d0b6da4217b838ed28f46bb82f22200d0f7ebe2541d94b2c7e014e953654d3d3b6863ccc89cd7293c51254c282a671819aa0ffcc89ce188d7725aed9b88b454773c92a9fb65e589379a4d778d9c6c93ff213e96e8caf5a18ec4a79dfb2c60faa0cf523457ebdf3052a74746bef3f6382ed889855371313c2e702ff834f29dce1b01ee9973c64bb1a830de014e0fbb6aa5da37c1ccb123a6964fa47b90a6e54464aad63874e8d010338cc60dce4ed8b0fa12f0d76c658b40246156f2634e29f067bf4f94fa525f2f7d5a27ccad224ce6a0779382440d35748dc06152abed22a1d67a97b860ca16394947311add1ce13d75871c2f3ef95e040f4ccef85cb06a440519bd331ad98f2b67bb9b34cf6ab63b6958f1c191113c7ae8230a22ef8b7fa9201f15611070c975898cc47fa0860d71eeea9506aa49cac9b42fbe8365e39253f94ff8a9d79a3e1c9b5f793835e3c424259e6cf251a6648e298b5aa689d67afb3d5399aa7f7e2730a25fcd129a6ff72ee0eb23774555daa752f2262ffbe867a8ae2f22188887b6fc2945f14e7dccad1bf3c23876df7a3729b56890645e8f7f768bed36fab24a5220a77eded98da11eb3d21954aab5cfde495716aa09808c189cfcc882e74867f6ce0132cc179588a6fc59ad10c01ce6db9b7f54cb02ac26a911868ebe747b92d898f049241c6eff9fdbe68e1f94e821798bcce21284c78d0fb05f9db97c03d8f9aea299b2a90762475ce47247c027be853f1215e8ec1031b344aaa5f4f46c40a52d0e016098272c6c649044aec649db5b5e8a3c9b27d6524d4af3ba62c98de3ea176d68ac7a845d4b23f435cb9a995afcdb0108776cd69f9957646ea63e8b04905656fe78a7468dfda2367a09b0fd6fb1fea0f22e2f93a29a6a6f7a7214a479d114239246e6788eba74c7e84caa9378c94190a5f2409c5a37b0562c8e3533e24d9978baecdd6783b5916fc6e6ea4ba6add7143a47dac6c6e319d490e708a3db2300b94c691aed94f93fa58ae9042a46ac34db6c0765392f5b5c210f61dc3ba6df57a05c905b0ae5464935e878d72c4f3c98d3e2a7ff5b683346cb4f766856e25635c819b87c4ccda8137372d09b03447d08293e62285c5ad7e561b0db8dc85d9be2d4110a3a6ec9136af0ce84b45223139b06247103ab56b2983fc67d2463799f7c135e9de0acde33f6120744d68962276558752e3555aa6cf970ff17a28cee19bb9e9add41a0055a9e917416f4138694195709117c245f92330bb6414bf1cd6913177948373785fe403318ebf704ce798514a82ceb9ab718ff2ea3604b430bfeaffc37b800e70a79e22a032ec9344e140675ebb9dd863f933a8ce3ef50c134167db4463c0247d9556f67d45dda471951987221eb17f2a2cd831f9b9fed4cc7a4c28a97ed026cb0a88f0aa2041607ca58ed08db4aa42ebf17856b94822d21cebe08607f2f8b4929a8fafea9ccd02fb46684a7a7be885d9869fa4eb863e1ce022f56cd9c8ec7ccef64e32f99b9086d60e3f9578dc0f03a04189053fc50a2703cae6d6ae055f296328a15b99cf9555cf1438a5197e5beb84ecfa1e6d9cd1d0f78ddb37dd6cd633553d0b3200b74eb09fb3e3ce06c49e975660f8973943fc092da333e2b3dc9615028a6fafe2923aad990647e92e513be2fffdd5eda2caccdbb6c3fa6a6c014389a50eb96beb250d4405543f5ca4d89b629ce0fb9a7f75536304edd75d782294702654fc3d732e02d6d4b0c782265b63f6a090341f0edf9adc732ebf208ace283d62cb24b371e0d9a3c10645263d700fdb98bfb0b700283a89808164084e94f640fee86255a617d8071265225270fb1dfffbc643c2be345e1a3783647cd41c7a49ced348b0e05735bedbbc0c8a23448bb97dc09c15a7a44fbbbb061e89a13859cb506d94fac1aa0601dbb782365591610d97b412d935d8b83ab71c375785e826ce9748b356414f4ebd397171d5c8372c61111edefb167d40a29bce5a3c6b1236b27051f3e0a698ce9a334af1026d22447e5afe7e9e0d6a2f5a675d3a720277b77dff8810bb457408179c08c2968e824daf9ce548ec096fbadaaadcadf06b17f59ff90003da8fac03706a56e6eb4c5c40ea22745fb52ebede8ca5cd8c040d3ad4ecf50891fe93e656b738b6a198369ce1ef44a803f129371bc6d1370c846979f8f0cb70427651de7188aca892ddc742c4177e34faab23b00fcbb344e56769e2a2f015f087332ec171a1f04f90b1ac87457b7b25b5ea4a305ecc79904440ddc9391a0776c5514444136e29909d6f04442d17967c4b0b6f5203c2c1563fcce042043c1f04065111fcfe1f7fe03d5faba8d42ad93876f2363af84b8fb9c6184c049f81dad78c376949ecb805476e4f514624e69e36558d8e79ee39e23854051659116f8d20aef7a5fe5d131aa34615c05f9428d53d7580b9db035a76475c9d657c2b19c896c21e233d4f25676e7741605c0da8258a70afadf2decb4b124d7d16a50c8cd59314a5c882a5850f2764976924b45f49b66eaa9be306233da5731aa434648c8ba3da3df34ed43caa0a9c3ebc24bf227ac310fe78fe3e7dd88e0f2a77b318ce094c37dc5400a66e55770985ec4c60005c4f7934e9c6e0da1b1bf07587881f0569a4eeda3efa70928c954ef95eea0e747301c5d04260737fdba82c46b639fbf8a93b49c084d51d637a9f9f7733018209758953b0dbd23f4473b0f0899fb6d883246ac8dd61fac3adeba37497a8d2eb4a46e3db62edcadad300976d133172157f20701afbfdd44c6757dd047a7e696956483b08143902d2716c380bff3aca70d1e551ad495e4ff0202e18b4b68dc1c6f92b58f80d635704b153c1763eb047e8c05bc776ab6601b1a0c0ffd403618f627287cf7c0f8b8153efc3fb98cce901ab397b021a37acacf803413eeb255cf17787748ca8d40b4c5e7e9a5d107dc6dc24cdbd8b0a4d5ad7853023cc797931b306e6f11334c8d9067c8d7a111620069a28fd8dfb5f20156ff9b04ae9be258c3d586028222e9808901df989dd8be0f0c4be1a84f7d56047f901ae689e9a2ca2054823acbe996937f39ecc4591203f56dba4efb5ebfeb882683aebde9e72e376d305ffb5562e225081a85d2f0c11623fdf817ff087052b1d45521a506eb1b38fa7ca54df86c87c2a2280a16c7c320470bc13b09d576c5137157cf10fdf76b2a32e6f436ab06d73ea132d994c6c7a70d226ab3209a25ec3530ee19be593c272f3671f699cc40018d09372cde34dae0988620c6331e200b21655625cf237e563c2d8205bb7abb48079b93355ee3b0ec5b43274082f7624dc5e5b98a8824d6129ba21eac0ddfddc2def4870b87a0d95d926289f5ea4ec5da28111dd0959b9c64db181f7ed1bfa1263f49f8a8edea98ecdf39e05e4288f046f19dd41c17314836e57e65e5f0d64052ecb96610921607d22cba2ee424f5a0fb41a2e0352e9d7b202de0fdff3b90fe798c773597ef02464b48c708bf7dcfe439786055bd5cde39478b1b0140dcefeea8bf65b7f989b42b4a60c46e1907612a97148a949c78c30ddbddebdff119fd972ccf0ea3597e70b72464209781137b7150de7c9679da05b647f6ca45ac329afeeec0d85e50f5232b731e32d0a2aee556b420bf5f9d50836f636d0d93a33a8ff391307d1735616b2946c3bf2f322f201d82d84fb6f5821c912c1695706ed642cfc5b74f58bd002d473baeca4d8fd3e4b57759f88b18c7b1dda90a7eb3457f6fd3ef94c35e3ae30f54673023cae4b97e3af2aff3f797ffc5c2e319b2e9490ea4de79f5882143662b8fefbac52f024d1653e4ef815ffbe702f1cc3e19721a29ac63a6ac51b439c3b5d89ed47a17aac64e678c0e67a14dcfaac85b41c91faa5c507e2e511a7a50ce63e7e1a57706a582f57a7cb0873c67e3aa6c77dae8a274c63c73efc0010337e83439e270de937bd8ebd8f5c3af26f76952dae2091ad6e0c4ed085d0ca0763f5b298a01e3458aa7823a7ddbe3108a0344d4204c31f7968fd76d6fe93726688202cadb391f228ec06e10caef6f4f48083762769ca531f899128d60418fab1f18c75496561cc0169cef54d0eadbbdb00899af91abaf96b87715a6bd90947e941a91e8bdf08ba84a10cd44b91c7deb8c6365598b9c655ba08e57077e7e3b428680ad08bcbc53973647c420b105fc4bd900d0cebb9c55f82d1f6ea42553e91be4d511fc4c0d8cf970443a7591518c5d6ec77eb89b3204e83eb6253f2d1b4c22a37459b723e1b3e737c387aaea3d934250065637cd08c5daf6da477c2ca458b7dd9fc6e454fdf6d1177a074267690f4296229b131194852bcc7c47e98442e00253887145c587cbc83b61736f7c857bbfcc4a0b18f15befe4382ba28c1a825668178c359730ff265b35832b7c0737d4024e167cefe89b1be29a4226c3b3eff81534f8f1394ab25ac4e1356a8fbf3f9846a0b3432fa7f4e6754fc445a659936f7d8e65bd187d1692ae42b784509d04fae8213395b9c5ff13f42389631656c377a43870c758d5ceb8d2f0d53a97349763517d6590543a4edca3a28a7dcb5cfbb368d5ad7af2bc539dc200d88c6d3c48977b8e8fe3bb19f50ec39a31fcd4b25c2c3be682fd4463a669ed716ee23e0f92734f48a41069156837b0b5ebfe368a38b81cd2596f5bed62f0f109d8e20ef0f8567a0a1737feacf4eea0331c332c4105ce86529dabbc1434807788ef2888ad19098dcb2bc7a0ed598e5a1706b6356e5b7472d52711d71950da4d4859b693ab5a4bc292d7cf4a5c036cae3d2913cc4bb12cc6bbdfeb02b15c886290d114036b0c434737b813a2092bc193dc15368c5dc9441c07080d1e222e12b61eec4a4d06048a45792b382b2bc3dc14863e09ad66d476aa1d9417c85a3b1a31745fb81cb8c57acc32ebe912d9df34a9422eef7c80241d455f463840c6ee5b70b39313ab3f7e3d1e9bef6fd43713da9f8f8f3ed8b1d2fc482d25e2019b2817908b1131e6a6de15b34ca3e164ca97ef14ad8514abe0e3f31bd1a5781afdecd6173b1e0de6b5eb6b0380bd946c6b34082d1454d684103dee73d4568ffc612271ef2e63a6ff9f9ccca32981d2479c13af55fc8c549058d821050015facabf8662503e9ae827be02192ac56538c5c6027660818955209ce678083d083490ed6a506cd5d266340c76ab5330db7300493792219a1cef83be1256d5c1228f59c953f9456e0b04653a982099c8121536888dd62df3e0088dcfc3cdbeb44ad2aff7b13700d3f81eef75aed80ccb0ef607443a8d57a0439c3fa0a155b65ccdc5667ec27f74c57b4789dd8aeffc1d437d1ca9e75d5e637b7ccd3cf939fea493d43c39088833b9ae8118084e95c11ff109c8d8d952730d3c15a703cc63369d597cccb4c56b5d481289dec0e56158c5fcf0d8dd47fccc0dd0ff1c481a44a1a0ae2117b278125e8f1dab9de93cd311aa9f05911f0baa6acffa1e4b18604ad3f69415bc611dfc442d0a3803403bc3f3a440278af06d11751be0636d5a652d1b132f604a7f22592cd19233dd146e59696ba4376b34b61ffaa00b3aa8ea6f3e62eb0f02bc729070cf4d74afc7ec6e9bb375ef20f53ce6a9df2201975b5e90555cf75b8fe0e0e83ee70c734e2b7e6bdbe1cc9ebd5b5d0d715423945d2cdf606e63ca891536fce60e11ca280d25fb6ce1c98f4adec50b8a0a047747b365eb78e1a3956e225aea205a20eaa9bf2f4f4b3735a76f2da0af8bfb2590e31c0eea3ac8808cc915ad86352c780c76b1705da9e1b654a634241b820409400a8d307542d34f17184b3cb3f68e356c0969ad52d49aa5a6dfb5c475e96188f38d891f685abd87911cf9a4cf4c1b9ef534f497ebf0432ab6ea73198d0e718db29531964aeb4d6637a8bfd9b93019524708b9af11a55da15d0861dc1aa7431f5b2f573067c51bc6e490f67d53b86083e54b83d57e79a259288713a87240e389d97886d36e71da59127a9a9ee5527ebf0968f444d47f99b306d9acf67538d0d53a89112243c6cb1604278bc4dad372c11e6727a81c34d4ccc0f63d023290f4fdc673c22415d9aec228e10159a9d93c4e9e6270ac30f2a626cf0fa0ecc4e793152af2579ac5325369d29d146596b75e43bd51719ab06dc395608cc57988319477047eb459e719759a22f8dd680a6111b0562c0b43c3f7a20eb7e128c5bcfb32809cd0ec1ba30f349ebb40edb3dc0416bdc1cf6b4905231d828b95b4add002977db4e0d2da764c9ccffdd4dcc139caff9e811ed5c75c597bc1d4df78b367a1cb5c048743406b2bb6d56c81cb9ccea9fed9b117b156de0d295704a7971301f18e9104af65c8eaf65361cffab446f1a6c86fd9090be8fb1459047dd1e511e8be0459c434546897d63764082d7045299864d28cabd5f4c7998411208d16762fbd7593a7bd57c7d3035c02ce01c41dcc3347d5891471f9dabc59db3fd09c638c5d6ad0648e1dc677dde588447b6e72263fc3f7cae93e129e59aa1a9a45eeb3f349c19587513202f654c5dd6fa2308b9469455fc72b4d2f38584e5be741489986782ccdd8fb1cba0a27427fcf15d834c678d417f843c322bc642539eb406d975fb4e260c180eacb1c77b12a60f8990fdd458d72af9270546e1516e10939b7d9d0b327783886c916e6dc6db7ba80f1f50cbba117429a548454837a9ef3fa635524bf459a0d8cc2cb55cc0bbbf511b41749a57be541382aabf30bfc524643eed5f340757b2b752554eb432354daeccf3636ff26c2ee6b2db239442c97110c7013857fb1720b217e05cb0ea6e13b4d479262441ebb75575316d35d90cfea939bb401203c749ed1f3435e889983e11cce885b6e0d8492370ecf69302dc87c6f9a091c65716f0b0d41ac5c473d0f7fdfa49f1ffac415ba0e04209ce9df3972f2963244109d6616451feab0c50af70930d287c35503d45d316f701d6cf3b95e1fdc29910d98354fb3070ecef3b0a032a4b096e3c899ccf528b7e3e26ebc7f177fcac96b42eded5b258a9724cc082774934e57e5959a34e2794a2b587e54939bd3a98821822fa0ef6e1a677c7ad1db3ca31e55096b8200ce3efb247e3b535a359044b1e42ea92a192b31b37e9d7f65f5b4a2898761b0f5202526171793a3cb15b14a1213230371f52e9cb28fc1a8decd667c9d47f80d35e51e367edb986bd9d81ab434397fd7a20a39b4cab80420a91209945c2b0d52246c99c17940ac47ffc2594744c34b57515131a0ce71d2c88a04aff62add22b1cce4ed338f8597a3ce4b4428b4d3fc982c9664c9e140e700649711f3608d3dcef54c118be758a524780b8085ef49e2debbc7d1cf31a0f28d8f0c155028a7a230b828a1fa51fed01616ecc4ec4ce321d598e41de6b678fce2eab702ff32b2769843d3f96df492a211bf2bc334c7935f2938800dc4980f2964b0574c6559ec118a9dd1dffa5cc32869193955739a0fc6586bba44205cbd75fae3a3f9ed812480518c938d73421be407e0c0c97087f56d975e3d4f619cafdc24f9a35255ce10916a20a8f4fdbabf3abe4422e83786766e970efe29da53c17cd00819f7872e420294acccdea74193cb6a65e9633c9c2057d175322112ad0fb5b3dedee93e9a1b7c2ec52bc071adcdf911a26bf890f8a543d2325f1a61ec3ab32dc2e2ce3051e8cc1fa6f0df60020bd217066a082383b14ecd092c4978ef38eff5d6beaaa67ba300e4f2eb241f3a408ddf012a7e4acff530ce022f802dd6dde4ea43fa4d341ceb3dbb1c4f865920b0651ce6f5af8ad1e3883b4c0e4d0cbe74a7c3697c26bebf34b7260868e8a67f045f84e5835e06f6ae69c667b62db785b1e075de1440f861f1519ac25553d7683ae80f82cd26b660e68cae8881beb1a63009cbfcef0993609f4d545127c77ea5d91401c6ef73c20bfa12d9fec6b645878070a3e5508bc87d9d68d9221f7cd3d013e432f2e5edd798594c1b3255791d6d942f1def308a3b45c24aa93694199ed1ed59ea24a926cfc196c878df562d9b17b1957d4345a2577944b75fe34cc2cda3537742eda89d295f1b4be20eec9067eb13bbf90d07de6d91731cda5b98f19d61d0850e45f2ed3cd7c4e77504ba7a6a0c3269db978c6d25a15063f314ed3eaacdc80d77f8a35aace9fd5a1ce4acfcc7cfde52b315663532ff1b133d9cf0c90a090cae5375922534277a9619929473cf34d0463760bd51e96bf5837a100e33c416e024f94d49d67c55d8309bd7ffad4f42bd6946e1df1fefe887805e999197345cb918cd4a3cb6dc1453bdef0edd74ba6964cef507622147612de1bf3a5800ddb20c73588414200fdfa63dc6ef4c24ea7c7b417bb1c2e8dc54efb89910253a7d6519e357c70ec39ea3a62f907facaa19de6b44a4c2275a2463c99b839048e0c757288c0c3283b61296d3722cdb445a2966c608e7ba62c047a37106b6ce999db929a2c8c8aa5ab8967ad07fa6d7044c2526fbcef0dff3a8157d3ab030981f3aecb922953041de2fa2a8e2365e83a814771a27ea1f765a86e59ec50c314b89146ce2902d9259dbd2200dfb277cd6c08fe546ae81ac8912308a0f43fb87d5bdc1409bfb7f13f9664e2c8feb831dfbd53136797ebc0a21b573f178bcd2b440ad537f9da6539b3c231a09ce1dd4db15a6f66c51923211f0dbff224b020df1b9955b0937d8acd8b2302cb5a3854b0c4e6478c0afc5d31c678f33b094938bb032246ee702bb702308946fd8a24445b4504e255443c82d983921737bf166f541a46ad8e18a3f792f4703000d3966bbe23b8bf3bf01d3bd4ac5296553c44de36528cdc4ecb8bdaff4b072ec81511214df4b89d26ff711a77da1dc90f91bf59fff96ac27ae6fb39969712ee884407ccb98246314856a8c444520b33d4675d6d84b083e578fc58fe80808aac3218212bc9d7d02192de2cd8b3a2a4900e1ea5b05301cb80b12839e8abab19b3948c3767506a3aa2420240b81b341b5347cba99bd61ad6ba6deb7c26a6d4cc061fb17d1f836b468ae5aacc93379732a5418f8ced57c61ac07daed67d43ebeff3f7eaf451b4d67cec7febdc885071891debed3af6655d6af45d30c52f3ea7752e28f3e6339a9afe7662aff898265b14a6cfa911243496560ca5c5d9fffaa43ba779c57ecf8104bdd1506bac6bbd227bc9360abb377bf55174d78470a1eeb82acae5f5cb7bd7a17c3d9e9887830fcbf64f40974b7ab1f3c4ee23f1c7f72fa4b9b73f2c1b3661f63c642e6d26dc526b723160f0a532eb4a15f3c21cc8a75262d39713171b7b45f1dd08acb937ad7cd808b7a37b7d9b94d7a19e098be9223ba2b0dd9efb593594d8f226acf673745fca94fd1c2f405d13ae1dd9b09202f5e264f4676eb6d44636326de8234c4722b2b1a2ff82194cd43a39cea6a0e8a09920c8896b773a6c809bae88f47baf5a0c047fd597351923a76ee9b384945e9af61bab76d702e601d13426763a7881d9a0eb378beecc843f99ee1e8215c2a4614b743f9f88d8a6f533f2cd1abd6e89c00df31dfc922e7cfe2c377ac8f55b97a4061313eed7610c930e86142a75b41d0c574d53fa917a5a6cad81941b254bcc3da4b80265a30b9a071b53f37445502cd5793e7e5602cb13ac595dd254023717b96e7268e1fef444b0f2cfdbe9892ad04c79f92366a4866110aeb65ff5a5681105926eac12c04670faabb4b37570734c4b8cf75f97f1e9e74b6a99286f02ab7a90fb7181128da1b0a1a5f3b580ea360e4081009332537bdc18b4fb82389e05429780cb91a9d42dbc2efa6b8642d148c6c9be6ee29ff4953f022dd7b847942f46289808a78ab5227b7826fb4ec0fb25225ce66f5c9c14dc7f09c04144b7253e42dda5bea3e8d12ed22122b869441c3ddf79406ef5638ed31342b9d051a38e5fa4ba8ed9cee741bf11c57fa95168f541e7481c10e4adafc1348c41382ce809fe589721c2378d31761a53abf5852090babd6719d7566d91ab459c24748d95926e857d49ef509ac26523422b2b23c6e779a58ff064b6fe2d79d911d57f07096f5dcbf233bd05be8eeb2809866a6130cdbdba25d3740c963604d4fe8ed173b75dfc35aed6f8773a1a1d35936035013b2b64e5ce9c0fdf8b6a6b1d5007cd95f08f042b5564617624b03617e5285ecb204fd87b2fab4e205f296ce12cbb1cc5cee6167c1c9e97f3b1bc20ab2bc3cdb29ed49cea67fe6f0f082a20f6f25564a1e491ebb136c481ed6d4f32a62d238e5b7f5ea3d217e997cd948a01a663dcae7033b0b682e35f80c26e25c1e2a2a91d3d87c62ab74b8b8b1eac5e7588cfbcd17fa15d2629a25febeb645d4dd27bb27b1234d43016492a42a7fb81f1a6f67946267b28f9397a5b592ebf2e4cbcb153868849f9ebfb5df50d9a39b981e14d0f02ada0f70957e7702189f62eb4e791e859b1cbf85636ebb7e98c9e200e92c6b32298824a1d9643550a8de460cb09c9fa8c453224e6ce07bffa7940a0a8176f1bbaf1d593422a9bb650d14a7a0b69496656258e1c21082336cc8d820ea022a9a5fc9b01ddf2f31c648bc8fc3826dfc0172f6764385a711f9ab96edfd7dce8f302f803bd35302afee12295507045feaaea17b5ccda579b34fc7b8f67f91ce2ac17e4752ea5e9696df1796323e1dc457219e575ba189c27f26f0d270999d04c9255f0070932943b78640b02a294a4633d7db28c077e06b503f52fdecd524743f3247d30819a96a5e1cb001f6886894fc6a65a1371c5033e1a4c91bf401ebd7e0b85c1d070355e00700b1cc92690f1bf381cdda9b443fcc3108689cfefea213feeddce13a248a8f2e734ab936985cdd2af140bfdb9f92b009531c6f93fca4f4fec0a9ef0a88f5521a9a970b44756d59c609223f09ed941c25a68e5b13562748cb5d3d122d15fd8147ea5c54fc5eb6817705b25ca8e08a42eab8e63266c63678f9b817163070bb6e357cf1e9574cce20cf4dc21e44dcb93dfa9332d6e8f9dec65bde9dca6eb4e56921ae55edab3f88f661247a15065515a2865fb0874678104ac5667aa404500eeddd4554803a9a70eadba930cb40582202f748c4c22a885261a5787a07a9f5766b1bc28fe952ea6a957df329a9b9bb7d4d8544017e60449e90ab9fc8f877388d82168d0a857dda9c7b6bd4f52f776fdf2725c406502ae3fe1b3901aeef350c38f7b4e268b158bce9d1ee1e98f94dd5371c176b3f8a7e56ef16ef8e3fce9508a46b5f4ed87816717e48e43139a636f0702512a9d4330a0e31ae049aab89aea10bc071d5c58e1a074c689b8542eebe489e8ef2d8e922eca15b1c83ffd16c3ccb692d44ae4166c3928b0c958264961133175d4fce58f3a220183bcd6f2b3fa5b12fac311e64952f1a25faea58201c10a5d109753fde5121608e4498b6b1638a6971d03f66f9ca5cbb60193abb398ac1d1ad75f5c89add2af48e2f7c6da9a04ddd7f6dac763b753a00cc26636c91f7583a6e1f99e0e19f0bbebd9b3ed08baa0c7daf44462ce332160ed6ab71ec1746ec1cf4b7a7b45584f3c2acfe507ab4ca021f36205c0d73d3bb9d445ba07fe77eaba715bfa074ca79bc84ed305e8a9f874f00f715786d17e098241f442811ca8a0246579c365c094a71c7258ed626cd81acc0a8491e3a2710d4819f2eae7e30db1b48895f867e1aa918cd6e2d9775973a509c019b06d84665c1143ec71659746a384c0207e70c0f9c21eb80362b41b436f559d3b3ccc2019adbdaf493b09342e01978bc4fe4b514a7a845d6fdb2723e4d8d9a454c9b58bffbe339c2a6517c7e3df61edd6ea9a120dfa9cb6b763bbaf6cf26e1c91244b23bb5d91e64f01091e34ea0e3631dc669d7943ef32b3df301ef3716848f854b5affc2e22a26b48b05d5ae329ec1f2ba9c37d3eb24ee57c95d074572d8b62ba5dd551799b94fdae8106b21cadb477dbd11f473c26cf8db76c2d213265f238266c835d63f6b4fae4d2f6ca465a04a22daf3283d76281bb0703e01ba147fa358df23e83015e08d38974901fcd985fe83126621f87a01dc21f4b44a88f99b8d65b0d63a773ee6f91a0d3a7349cc276a1a311422eb215fff56116f97403b58160029f942b1a4e09c93a7c152b1999b83f8141360fd922295625ba9ec69119847bbb95a78239045813fc833ec792b719402f01a81b10908cb6829303c1fb850e2d15efa15b9d6ac32b34fe91cdff9b97664299d0453423cd873666877f51aae5a6985c2ddffa85e6422d6594f35a00dcea1526ae18b794623c1993bd92538d48b07b9601a915a4f76020f16200d84a0b2e471fe91b1f52d8ec2848186e02cfbe863382ebaa8eeabb1175491a62507c54e555a718e40bdb69b8cf7b587ecad82b8c8f9b1904dd7e933d87fc48bab371a9e73431a98b9b1c335d749905318b7f3fe1ad4e99fdf1b989dfcb42aac27f399af48c2fbb7df98e0a569e9b087f787604387b5f79be6c9886a98524419c585c2a4cbff90ec5582042f53cc703171e3abba6d2a6bd87becd0b090229f18a2b465aac39c126d9a9df1e98c20e749a64093a3531a1f84b5da3a7536b0184a0a939149b2059de6827b8218d76b3a4e8f526e4f353fbca4135ac08b322a58917b7b7cb8750485bc36aea4c0833cbc672756fa3f40529593170b339ab0f325b34ec6a73218b947465f5405b935c512bdaf9e044755e6a80c4e37a215796013e87c09b06694f0b40e248d8194afb53994d644715f31646ec3b45fe3723bbd5e411475ec65c780ce794a907f1b328cac1f9810be680ed06f101065f2477f3d572446433c62d42c55ee83bff354436af930342d4f6fa6ffae39d7abb6e62e8236dd3c3782201e84f8749e8e4f9436c1f280d80f6effab9637048316e8075b6028f7359982d82d5df636276cba445432edb1a288af88cd5fc7d235da7445de919a43f50b22766e8f788f7afb1372095dc8d5f40264f8271b9bcfc769854413ba3efc3ef6ff6b829427bf787205f39d76759562dd2ad26e0daf2c65cb84a00690d0158f2feff890e08526eb876b4be86d73f8602862a4c4de17746146822e05dc29667240f0982ab45b615b2529078266b3ce80b2c69cf3f989ff2a4a2b09ef0bad9e468ca4d816168b2a84aaf500bd1e1dcac5e2979236a74b5355e4b854c8a90ba51e78da0c9bcf35bec88d42e4c51e5b70031d2a42c1437855316934ec97b383713d861e8b6f0141a631e013e08bc97f02b09512d8a2b3529dfd59793be59110feb79e84debf3269c7ba086e61abb071f7306ebef66a0c20a5620e7d5184cf4ddd689c4987f1d6ac123bdf9eaf3df39fdd05e81cf751111768de0c132c1cfc0156404be19b5fde7b5f89d57ab11b78d69047514c6fccf64de1936086b9e4bacaa9503557c191bda192fae9b41b3d9343223c2d6ac072a75ba8d2888679dfb4e4fc9e6a42e7a77803d6a958c41377e4d98b39eb6400a5592d46d76012c7a8199b5153713f7d87dbf4f75d8f473a8f32aa2fd16a6e65a379c9b2303f943cede39ff0a0f10608b4795f5d21ead250070d456a5f0867559fd4d2f912cffb1aeb6303d4edde52e1fd2e8a76b5ff541e4c6d24bf86f92cc9a1d9ee4149293f4358cdd1a302d3366f13a8a25a64cbc07fb7a2be7ecbd12cf14365460d99a82cdc11ba00f587f0809b9cd015a4701d91d1096f715d90b696b636c0f226352232a81bfd6c1b02afd0a292c8a3a379d92673612a38b3d45aa50d3fdc0802708dc7b7b5df25ecc84d1a4e3d402fd9112494d52aaf3ceabf58d4e6da8a11fbb6ebbe84dde5016219a9e89c6847452b3fe66d15744990f4edae7ac596efd8e1200e15d5c7ec6b6223809dd11c285a7ade154ee1b4c835be04d08613ccf5cb9a6f2d65774ade6304432af0cdff3290753805e656f0a272a6963d9625294b2be3dba6bc20ff59a2844758475a0521911c833aed951900ce55f8e58d947b32d596220b0e4f170b087a5d609d5775002e9a1b5dc4003c97b67c78b6b35ab4129288e7e60a4154747ec69bc89b75d4bd110caf46fa11c9e83b209afd0c9a4500c8cd518d3c8e381681b20b14cc292bce3a33a30d43d0d77b4257ef86f463fe8772bdbf7dd0cfd4e8b9b658bc72e9e31eb71919af92d99f5bb04c7a4595540601e320412c9cba02845b20933ed2afcf83099739f77ca939144e26118eebafbcde3b25bb4d94df16038dc709a7996c8051ff420d2fda89a4963cb860686ed96f596d77cbc5b4c04dcae924f390bd647b55ed6346d995286dc5d217ec26948fbb3f2347f6d3f1c3eb9754cd4df7d849c3c4778201bb4ba7765d0782f643f12b7ca48f9616f7bd5fbc555d927d3daefc77ffe3ce56afbbc91a2f72cf749474bde4161a87735acb4224699d94316463cd20aac8d186e7cec4a199ba6082e7022219df1ee8590d236eed0f4f2230e73bb86976ede805d5e3dfd07ff993d8747e528b753ccd97308c1008d6bbf3841dc02acbd8e0d43227d73db495d1e25dc2aae692d633d26755fd9c57b38c0af51486bda06cc56e58559b736e54a96a2ce585f83d0f7d68eb084858de1c607d701c62f6a46292e640fd01bb7febd4fba531f18b1fb750e087d73889ed0bca55c58facdab86bef371d9770f18d4ea3bc677bb3c01204759ff25356201ac79a5b811b4a3ad51d30503802dccb0c303819c8b8935bf2ae685db013ea83c048d2f651289b2ef7ff7d30b4fb59f03d48ed033e2970a02c0dcc03eceb75057eecaaae583e09de4a508bd57c7fe40848afac4aa596d94ad506625024cd2e7cc8449757dd182240be589c1675e7a6fcf29270f84e70c02ad81f1bb157afbfc646111a82da5d8db1b7e84c1d6c923dda12194d1cfb46c44720bd2a7c39cfb107e83d2cc66d875ef93001dbe974ed40fd970cef029e756c8df179e3457724e94af686ecf801d9c9883fd59b8a69dcd0ac9c34fc6b2ee51a5ee76db92b883ec6e7904b2a269c54e4d14ce4e1c0e8190547babd97780ad961191110253bd59fb804c5f5ef0a2a3e0f1382a38808241ba261b74ded93c654406b3c4e13ae2588a068e2fd6fe18789cf05a92152d49955ace7a74e68131ac3e4513c5420ae618b96a6ab87d6bca0c8905a75344725dfa4f4b42ebd850801bf203fc4c5bbe7c93bfa6292022bca3b9a052cf51a1eb1c8f68953ccfc8fa12a8fcfd7bdff7d20442cf1c87a5de93dc29b383718ec3f2218008f838c7736169ab1d3564b0d5de80020453e1fabe4530f8f2aba436badd9b909acef222f42846bf7afe4173007a3055163d9e010dbe7970e80171b445992ef88a119cd7f66b3a136ac6eaf287ac6e07a9be1a9994131066596967d474b904e6cf5f24d7bf558067f23a412e6ba437b3258320bef8f5f820ce0301c70be756195fb0b6bc02c829866864d6409bc551d2cd9b0be49a9b7f5c09231363e872648bf0d14b216d6521b5f7504fb26c2d5b9baa9082f787db30298b6a590fde27f291b131f1d295c4d4429bcf0863d65fd587cc1e72619c60304b3f36a7aaf882f1fa3bab8e9d0c5f4b432b4901992ad5e92e1002b71160e328da068ea11de76a2992dc658cd7107783393ece6521a54fbd12ae96176d40ab2777440deeffe5e6a1728cab08b6a4d09f885877bfcfcf6faef3085e7c1d1fd3e2683e07c1eaef2deb60b0e347b23f41989b489ff34bb400cfa5065870f9c786d8ad830af17cccfb964b17abdf2946ea1d9e3cbe955b29b0a796a451f5b8d560fe03d95d5c2f7b0e5999ed4a759a1036e2d1bc5a4d30a2cfd90507f51ee9d1c17bb0fe31dca8bb1b937e746b45b775d57f07ea53200d5201603b1a16e4fe009765c5afc24deb264ccd709aac22d294ac96fe7f861c2ffef95e35f7b90f998b10e79f8561d90625ed1ab8bc7110ea7ba12ac4a9620ead899116166fc46c4535deb9b3a01753e8ab86953d78139e85de5cb5bfcfef034de64f12e29d2bdfc8c1107ec00132055fd983b0fa984661fae69244ab941faf73243467634df64b2823b1d4380ddfaf32efbdf8b240340644ead46774a94d012ac7967a34c7b6c40e9b09d59404eccd622289eb630b1cba88b6714ae57d32d27d287b3d622fba3435e8d3ef33d0748775d7d290a3407b5216a27d486c27c3caa442e7015b6d84b7ab55ed2b46d9dbcf36c8629f0d0cd59a378c8a550a2d6e88acf614e04beed48f445b3f4bf027de6637d84a1b795db0a8c53b0b9699ee20fa2587713dfe3e736c3ebc132cdeea4dce3fec40d65cd22d689427bdbf393b80ebb9ebaf00196f878d49652e05dfb481e8c06dc917c85667eb279258e9cf9cf0bbbb869b6f2c2ae43eca6298cd1d6d734bd1328eb7355d0c791f74a391a7b60c7ae61c9753b072911c2fe06184b96c15a7d223ff581de6e1474bfd72f7c6f7b7657273f6413181732121d2371a7f480778291ff9c1127118acd3c0b1fa47894eb002cfcb4f4f89fc2445d7600918068ea0af845a13eacd60d12f889108ee34e4207eb24c528582c01fe883174d544ca7986c6cd401896b6575168009d49561f2e083ae683578927aa982ac2a018d2b963f31fd92bb173c06edcfa5b993122357fc0a89bad4e26f1ab063a818078b0a5686a9386ca111bb01fbb23077bbb41babaeb44738822bfd59eda6ffbbaaf1733f43ae5b774b3a659a8b7d7542b7bba2f2abb64a0131d423b229461247c4665a0ca2757438df303194a8266b96196ddb91752e56194cf87b0da7d3b8366724a8d973fefdea118f80603918eea603636ffee3a03f634841dbd7d110c03e2fe6a62f3da4b705d42208ebbd527adf259957c04e60ebf6e2d0b7153cf73cc09c68eab6604c1b8ca7c18e5db78ab3ec1c7003792ecb2d3c69ec3e987bfad86adb8f7838cf665d194aec8912584d26937b195dbccc811f79d04596b16311ded2a2add4fa38dae40c68da57d4e59c1307b21bc9f2c0dfd37220b12983074ba88a3980e90412783026cc7a4393d75e827781abc0476674f6a88cefd49d8fc2920340403b838a00571df723746a1743f38a640d5d6251e6911a28dbd65c15b30a87ff812a3005928dc92e89f134b126381de90d7260511ec10887a74f5770278317db231cb58dcc5313c506f0945d9c957d91ef4c6d7380bf97f42349d2f3494e15f0bf03220c1a24a5c760e4e9edd9ffe08e712955bc5ee81dac2ad3f1c21c785eac9e81ea7ceaff9625b6c45f67b93490d13e6dd939a2f5b1c555ba946b0deb09144d9c62b17aae1ff405786e1e34ab1f1fdce914c304f571ca2ad63215b775e4f34416b08457baf5eb14c976425a31d0cfe23cd79b937af4967162cb4a0941a663c0db0213cbfd57159ec8038317a4aff9a702da0778523b626cf5f65fe1a2886c18bdc389d2a4b5171348c0a859614cdf60a3491134124e13862360b5d45e0bf917c755d3723718117f9c98e3ba14dfc21c76ab5a2f7a683b54f6c40b368b1f37546e997bf2cdd1e6d53bcc4f5b1790c8c4233d6a72aff11fad03ec953fc76475ca51d73069728026c8c4302f3d2eedacc272051ea334d94d04777104a57da1f55ca5eff66dff3921e4724d959b6edb3be9992a047ec43ed088c27cee038a678d6c1d086b3332d38210abec0dcb89dc3702767d57027f491e6f381b5e4879fc437c8b4c0578fcdf8c347c9c5b039db2ff07df542750ca8f563b61af68a90b672471c8b70980f90b724fc344599eb1f623813b9d9e7de755ce948594602ec6bb1d81f07edce4349e4ea093797b1e778df2afd2ef33ee77747d8df0b8dc9b05116a02764ee024c7c6fc98887c7a0c397f290795b0741dd54da2efb50dd24b176bf3dad9af7ec2c1884d7a0b45543e44728a07d6ed6f38f3ba677dc70f97e3071abbae55a4481305e06ad19e1e6ebb5dc4d591c9e65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
