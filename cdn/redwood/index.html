<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f3586daf37bcfcdba36e8461e482f67f7f54a5c48cd3b78de4eeb06fedde0bd0041c08886c6e2d99857c43613352b7b31d6b821e0e2ae65aa8fe566f659214e2a1167a41d321bf7c2fc0963861573517b483bdea41e8dbe3d4ca1911a0392b50c9d67b81df47a1a44d35d6d751c39f56115f3172bb2ca92e5ce38458e676b12005d6832391c39b14e197f5d2e0ae254bd4b0285e2823fd0ea9e475675e786c50c2c8d8a065197c140aabdc78a9ec937ce2d3efc3ea61ed2e851e725f0baa50dbd0845278d020014a0c13f3f7c6d6cddfcfa84823ba6ef05708e7446eda606d2885eb5ff1314b5dfe295088341b1f57620bb566baf34b34243ead656e8565ccf9d6c8eda3307e4807126bab53cdeb94dc8efa0aad2d8115735ad2db3240077d12aedff9ac492475498e437eec854ad19e5efdaf5c1f9626dbe6007a51018df885ca95ce1d20a351b2a4d4efc1a6f02bdf559c48fd65cb1442364b024cfd3b130a401aaf4207d1b33be30ee408bdb193236cc14a251454e69106acb0b5841d71247a2a9fcc3272ea65f97ac74ae0bbaefff4fc6748d8f8cae443cf300cf6e2d584b754115352accbcd1af695b65633755b6159dbf6f15b3cb58dfab579fc8005f4358f387304c8088e401b65a61f1eb780c7ac1894b62cf4455d6bb9ec220e878a42a0dd723f544c2cce05a077e4b3689b9efc0c339a54df7c73dc569178ad2a343b9d9f9fdeb11b572619dc978bc26992ebea01cb19382170cc820d9f23fc024b801f5cfdb1c4517a5bf52f8932a1a77995898aaa9f17ac55db59a79b23761436d5ad07f0733f5df3ae245f70fab7fb81ff4403c07dae5de833f4aacf6e312d2c607c467f8b5fa9458592a335c4710d2c41135045538020796bfcf64313f3c99d534d6c22d789ed3f06c660bad49e8d79c9517d936def37a758091853e87970dad76c7f221e5f1711dde1e0ff48baf6958e08f896dbb2f7f9f5fe596363a92ca806f1e4491890e881780d3ff40ad48a032a126bc34b803f234edcfaef7dc30049cdc92f022da49cc3ff8329aa2b81934186d8fafedf4f832b9d9ae49cd24a12a91ade0800feab981264ef0b435dc18bbd09b30a93bed9dded3c183981f94d0c31fa5f5a0d4542e371505a17b0803470bf360ede6f7e618314a28187e6a1f3c6f3f32d67998db44f229c3afbbb05fcdd8cff5f4251899939d6114e95c0420e941471addc10a22a7ce047d39ce3a5a408e34bd44ffb08b813df0567d50640019f8c08ef7aa06e10e510d488cd7e9febc086acf0871328b822e677bd99db124345798eb7d44defe8d9dde20ccb94873a62b0a39cf45f53e5921d16f174a815d30a62b899b334424853ddf111fd710694b987f1bee39c68f8818202e95540483b44d6ba74bf9a29730863df345b2850e5dcc41933c20f81d2d3aaa6759532cc735c926565a7540e961fa160e010905cb456399c3fcd15e60b7128f2d2bcde4fac2f188cc893458d7efc2ddb814556f4962754afd6635c0b09e6eb1588c2c8ee97f532e97a7ff6233818e7e4b1e299e228452fd0b1465485fd5c831de6c874bdf2aae985a8f7c7a82834d4c9b0b2150fcf0143b3be4ef3b4d96372f5ae1cc8388e9a815b9cadebbd6beed4a9965fe4d6a68ff4d763adf2cb924c4bd4647e4b0f19334b4768fba3f98a61f5fff39004ccc8dc0c54184527dd6f4fbbf6e836e0ef05df6e06df9033f5c654e04875a6cdafad0942594ed6c765cbaf2cea47e5d4d0851872497ec1f5e220fd65eaccca359a3123a2ea5530df23c045a78f05d30b1c95ee46f3097c042787bff086b2611b976d2286d6cea5abca8557e86978bc1469f6767c30fa6a7511c46fef55aec87806a124821a7072a40a83438d0b47f65202565ca47fd8688926e4c00e22988e092b11558268de7e7fdfff046da8f1d5daf2b603d99a83ac81492d5aa7f68382b341e956054ba872726e8892b40116a6d03167361cf3edb19c05ff33e341402638cccc55d3103cff84ba1fc69de2ba11cc31c31ac0d8cb42f8a1c785a28d42550136f2dcdafb5b206f09a6ea42dc2a75ad49165aab361e1c4abbcf515501dcf58d7d931fc4990e91ef1a9cd0a9b271902ec2c04e0440cd5e729b69fee68d46530371254193c0d54ca3a8079ce4a39d6aaba04edd07c380a59054daf7a0467e1007f24abf745c85e2fa9dd693a194bb88fddbf994674fe23cc48556beecd872380ccd11d639e59e140156aba94452a9039c4e8f5dda809f0e7b8c0813ad5ad0db8258515c9fe5f05e669350f722abd0c674399c965096310b58d4dfb72aa8dc02b98936d53406eca054afb7c96c187bd22b6aa90c1e2e1623306abb1f0db499c6af901e630d4082ee967b3e9e590f5b26d8f423076ba2a28755b384753ceeead9f2bbacc13bc9e85787f15a0471544c7aa0805be86c0671157dfbb482e978f601865fd44d2ecaa29570407e5aee544f20753bcb14e40d119cb75e455724849988e1162620bea3150ee323b19b4b0e5acfd6c8108f2a45ce05c025455e37f4af7eb7c3ac4e6eba081c16fc1c4a5524d6a38933fac99c5e96acdc66074d6736288285bf190a1f70b16b8590cb25da64c0d2b7d448b7e4b9cbff4cf61b2eda1660b07efd2f0647841dd0a1b333a7f9a3e26355290e3df6e722cd67e13ebd3b2be84126cf3cbf8146d43c4372164a8e10f906ed1b6051e9d53098eac8c76eb1a2a4a9834961004a6495a099e7c2f5c231254969eee693419228246278b6473f7f98d0c8f9d3bc7a36d9517741752ec22a07078b9a870b38fc07ad255b069ac9b09b80315c2f05700116603dd32bf8e453dcfdd93736fa57e68008ad9126b3c92cad1de70cc9d79fca64d89e3667d98565c5ab740d6a0a86cb8028a097458369ce88ca48f2a0f235efaeed9c3bda48caa8a1f630d4bc277c87639f866cef01c71a0525f02a770b3a91e48517328be532367fa9440cc2073dbaa73f2fca204f05d253a7150ba672ac1c1b2a5de690b686af1cdbe43f67e4b65df12e72962b605c7ce49a73c9800369e9b0f860e8020fc33741afddf886e692af2736c85ae00d1fefb97693924d50bf3b00286f6739a70bedee9f9dda5140fae2ec83b953ea2f0c9949689d5a4d72fa65a91a73ccdcc61c2091ded4c8c36d62ae6efbcae2c16f086937d7c86533285fc12ba0c587acabfefaca29e849b8d22c4e6aeda3b48c8e86cc7d88ce57ab0bf2d4c0d32d2c82fe7dc880b02f830be23466da3c3274e02dede16982262b233f74d970850e1c7f859406b8d4ab473dd3adfc597053f63bc20baaf37099a5fd55e148c4200810ae8d8a306c2bb54d2b03af9af71c24fd8667b2ce419e5a931e9208588db4beff0238cfe01a03ce6feec38d6d3949b9491f72839bc613b60e89fedf20e64df9a76f22d505e862e35c13b45bc4abe939ebbe06523f8be8d9b8cf1ad5079b8905b8879f342438843ae6cc5c429543a6301aef727113a059b7673d0815a0c02814aa7dd25549a134b9ec1840daed11cf68020aea3ed1c2c166fdd9256e6ecda109f34dae1984d52256d0c83b2253ef15c4c2c27b29b6858b2109f5da57621f625d9b2ddab73a29ffbd73a94126f5782c428159a8a043527d0c650a0969e4ca168522decb7d5946cbbebbe73bb126f05763ae2d7cb517f4cf6cb0d2874c5ef75b3e3c2a5cdf58f738f6456c934b64b481e3e02823a6ba28e252ff58135ce12b15fabcd3b355e75a13df753380cfba5a3652453b22209200e3025ce5cd7f24a10cc4cbb207c2ea31557e8f934bd55b0441734c308588a54d618732256179861e250163dbbe4925bd7eb1a92463e4a249f6c433944ce735730711e3c5c2bdadbbd26c43620c91d826e73527d5acaf9b0b9a47777599f4e30e23aa8e784ba6f373ca44e727e41b03f536989fdd25ccaf3f2a5ba12aa6dcd03d630dd41499e55c560a801a62fdf722c39221b867288160bfb6a988b19d66be9c72922f81d5b248ea13214413074dab415a932233e8a4da9cabf2f7aa5ea5829167933d892992e47452e70731464181157eee6973f7abbad10eeb834eeec4bc132e8a9d2d5b77bf6d5c8c1b0f65fb42742115efb2ea75f52a25314d20f2c01657a6e0d49fbb3fe1128fa1b4c9c48c82e20e230aca2146ee5eda5c86adf48acf9d422083399ee067e872420262123c8e3bcb06267b668e81962e47320a3b92a904b8715de627322cb17af7265d75b100340e229dda68d4d200ce2fc2c31a31e3cc58f29baa168ecd27e0984b53d82476623e95edc5cad461dcf35e9ec3dcee3d6cb0c193b5c5ca5cd1632f36c4a2cca8f17bd7f43c6fb5922f8405a6108c881e789ef162d9e72293a2263f8de666560d7cfd8507e979dbf9ed9b729bc085907bbc8769b3fc56a966b58440cbee9cf69d8365bd81408cf8c74633d84f5f3fc9d30f34d90e0bf3e4880fb7ba4c1c56fe7c3fbc2bcf5828d238a42b23341949269a8f17aea3ca92afd6c699b15b97904ef0968bbe88312b4e79e3ca5571df5fe4f732dbe73d341a3b6a6b270fb069eafd85b6769624ce2fae47bf6a08f8c2cb07f493105a97ede2bbb73804fe68449ff0bf037d61ed42de5bed4fe3ec055e9f9a9d43af5fc8c3efad568500dc1ac151880d29342e6360ecc20385cb402720770edf767b59c6330b543cfca7b08bc09f730a2ebe26dc41aa85f27d1c3608ab5adb4f4365b543edb5aa0408f05ee9615d539c4f3b0370c3be751e518cb9f8665b1f272bda2aeae46845792f200b5cdbbcbe923eb57203746b1e581190ecd79bcc0d1b2af29c3c53ebfd4f53f2bcd6360c4e062f9c7ab4eabbd66186b8ca136389dba0f72e2615ffd8193d18dd7242b8279b91563f16d7ae0002c515a41702b29888e50619f8ce8aee7dfca9f0f13719e8c249a50cc896592e50e3fba0a976b8526d036cae73d470e6ff5af94ad1cb11a28ed0569a848cd00418da004ad214ba715de32e4018ed13e5b8c8eda9f1916504ce80c15939f3ec0d6f64b674bba9121543569b3f81a8d529a3ea92a89b3efc93ae896f7dcae161c488fad2be37e161c767f226930faa600ef3600a486b16d4f993c96edbb8a7edf4f549fb9eafdf9becd14f18c8028f3ed9b059b2b64e2f4ceb38a09d621ef93483236e1f41591cea79aa5bca332a07c1ae8477ea5b62303cd3d49d9bf5b0ca65d3746f4ed150e9f69076865f3bcda39aec8b39afde594c14aed0592928726426df80e2c2ad5a4894474619e8af11fc0a6ebc1845dfb229d0f931a3a37b14323c4d5b412da90cfb0474c1166b0faa26ca6715dfe00015434a76229691f7d074c480a10bd7cda18cbef7728141a8301dbd279cb540dbb2ec72d4fb8a02c16aedf651dbb1342a8364f56b408fc140335039932e83a775906148c9b99a2cf3033cd8f2ed9bc8f97c9bb50430615bf4fa777e8de4a763d62bd9577461fde4068eb93430829efd0e8d4e3e82505b8dc8d2af3685d2b3975f7b40b04a067d2097c12db8c9bb41953b6eb8888303b07244d9211fe416d8319b6bc5e8e4cd08edefa5927afe1e2f39d23e78c0991609396f464360382f26e59bb9a29fd2975e6e496742a759b89a02f313f7f48252aae73cde539947e9c3785db07a36b1ce4635b0409e155fb1678752ffff1899767c453d3e53ef95bb1aa809d91f3b4dbee99a5154448a81e746bf2f68a86ef2ac38e4aa719b07ccaa266f35161521cbbd51b98ebdeb546c78b30725536c55b4706449df6b0bb2bf26699785131abcfa44bf74548bfe5a3b2983ffd14991ebacc0f5efeabd078790cacf94fe07edc98259ea23df1b09e58da142f49634c20e24d9a3d8a2c9c0215c815b88b9994048992974399d1cecbf6e163ce9134118177504170f227f64547bb829a3233bc7711f54568db236251379982161f461d487238145227b40b533c0dafc538fd77d64d18cd49e2f5ceadef257d89bfa81f2807ddae17bc5423f250a461ed42bb206854c52ff62edaa48f55a62fa3c4f6afe1ae99e678bb295c1b4603012edd8806c5c42b2e447003da095fc26161232e1872a94759a0693358e9ef84ee8406846b2f36774030f8842a83fb112ce41a33deaad7ae6be72b3c7b007cc40144c9f24f727ac6b4c7e1612a3e63a202f426240e9f5a0928ef993ad67371492e4967faf6caf45cd1a889202d14d8d61f7224f9dedcbf7e1a68efc56592209e1fa445fbff80799f65d5298646b4b1959e34f46a71de6e55ab9bc174334b19100078559fab980db27f364580b8c05b9d79bf7aea8212ec6ff1870d5f9905edc35c9d3d2ee562a0b2cca0a49ee994477daaf829962bc9ee75cc361347dc1aa3393650d8d1b4caebf45fdcb2426583212b143d6b1aea5c45c580d338c99933700be1ca48850586814808906db4ed7e9191599923ad89430be47ad4854081d51e92b4b98dd3e9661541d4e6bf9c6d18608ab649b959be98feeb12b257ea9dddbc87cee3b76588494918ef25de20a26976f8dcd92f2a1692ffea743416a11d1900a7f4113d06007c6bedde118d2ccc2b9398f74bba971f0e5103ac37242657a2417a57aa12b1608b15adc1a9928e9f8f20d88362bf3d07870aa2875e099f104cb3bd82b71006f4aeb09ae8e417b89415571d12a4f37217d20a6464e68ea0c0c7054b4410ef37133dbf35747084ebf7f85d5f39d8a6d084d5b90c7a24be0deed89f5c118cce742795fb20e07b9b46d30422f12334277521262e8bd70e80381632aff0b090db00be195066557a8bb8857069c67ef6eaa9609549bb1c82133c57292ffc5545f2df6bc235dea2aabd941a1432689e916818e82ff63f8a817a3173c2dcaf8eb962ff1f5fe6d5480f9a82b9d230307c83514423b94a70ecb65e7dd7752226ee7e2860628042d8f5d3a4a4cefe5428bbe966bd83e9681aa5bbe80d16df480989a726a1d41a31e73965d11e744db75997c4428371d1336173f7c39b5c3283806a6455b0e7f49b4a9a5e47dc3f94194d82c2a6c355958cbc2b67e1c36c04091ed5629f12f48ba44fbdf4cce0e78444beb6084315315d46c71870f50c87515e59c8ec9ad241f49f5c5577a01dc8d7064386fb1a48df6d335a5ab46dac22d76f3de38becccd4dfe1ed810d0450afe232b84230defd1a193bb6e46bdba93598eb81d3fd07cc10e674238539400355b11f23b1b332de3b62e19fdeaa498ad533319d8e2dc8ea629f095a9d0fdd17eae0836baa8f47b713be816769437846cf4d6ff45b60ef10b3ad7bd242289c71285371a906f0d9b3d29ef29d887bb42df33e64d514ac0cbb15fe8466350f511bda879d63ada629d2dc43f0329329d735427407777e2b79a222bbcc3c1faae3e037a029dc6cd89dc880d612e3b9d219df1ed6a52848ed7739e19e1276c540668738b42f45098506078223c79256e62e63506d97173bc744212078d57912a0dd836f7f34c6e862dcf9178c2890480335098d76de65a4d7404c5aa47c4bbc4f41d5bade0bd8b0c0785de883abf5a6c5ed69b16f93dc3f092f592fead315cdf594a9634b54cb57dd43261ed000912ab54cc450a3d875ccf19e13833635a0710c0950d458a765bd79b0c8b90269349d20c6cfba7c2a1900ce09779293dd365f63a70252900db4e6a4ead5e7129ec434ebffe8446809ea33fe7e54c791b0c2160d983570a5a95bd3fe17fab5c571b2389eb9606ac641329ed7d79ad2ed05fe24847d36cf7d86335eb16b4c4a2a603ada430540bd8ce14e7e78fae03ef1f070fcfec5bafdfbc07b8ef2c9ac760975098a87a2f00c126cb22c3ba165b94dbfdb95c2f6d6ed73f4ce539c0e3e1501cbd8aec5583321b1fa9e9da2d22f57b86c4d146793f894c61bd6c6154b95c66540bb4f0b20a2a6baa899d81232a6b9ee013c6fba846bbeb482c16acdf278f84d273a6b165c43126a609aa43ed50de3def299c040a7b7e3f54d1a787c0768cf543f5e00a1f68e38e4347af0a6d4ce42d5320bd84c74d6891f84c268365cffc804291a595117a0bbd32594f40663e28ae6a3364b9ff2e28a2b2bbd7ad3761e17d1158b7c7cbaca230f817af279a75a6bde9d8c7545213e12b52a7fe0ea1aa64e1cf0665d50fe99e218d8c61fc444fba7350a99fbb29aa7716341fa864992c8d2dfad86be524d7ae506e1cf8540a1199bebde9ca1ed12f99fb04af8222f828f0ff214294e8f8145c46fa6f9f9efa1fedf68aaafadbb415b75a73b820b4efdd726b56bf73727b0f83a0cb859989d44e66feffabe907c909f7891fa03cc2ab18e7ba8d1ef07724036e6412edd9ede1c5c8bf5d87270558efb19b2aef74fe9fbf3207cbb3639a4992050f9f6fa4a2a039681785e2fb701ab34b1deca70a49df56ab5cdec1bc2648eccd82cfdb0c2ec4cc47a0c0a1379c99251259d09c3d3ebecdbbb0af07af07f1d761e205c00490cc8ac8c78043e1626e93a933c49a65b1f34207f538879efcf6aa63151e1a6888a68a6cb1d09f6bf8a34d865a6c156ff591247d6061e917a33c6a81a031ae23a49b0d60d91b65ed9f05e90065ddb0871314952852f76d8f0468a83d6883928a93838dfebfaab9775f8805529c8bb86dc9ba733990e2b9ed6cca62d769baefdae0404aff3fc8d7f81aca8f152a0acbe3d8ce1f6842d47a03de3d9ff39fa660aecdf198c50617faa49c465b6dc053fd4929513c6960803aa4457858bccb87728bbb7b2830024cd0d5a618e1a897f10fc8f4e1dbe8b84957859cf582e38195c0004b78367006d51aeb873090d5f5c36673113de3c8049cfd882e1b5bac3e557cb7627e6fb312fc4cc6d8e3070330b9fae234982f3ca30081982e89295111572ca3dfab87b05892575b9f3e95f789f6826e9a3f8137fb5e0bd9c82b83ebb38646c263fcc17b7581ca156eefd5f437cadb89f5492df13eebb5c18867a1776b452c30ac148974ea53c22150ff81dcdbe25e618f37df43ef80c4799abd7ccb1b844f60528f5042ba129e9016542edf6016ae8d6a3d5188e0a6c133fbefce26b1f3c39090df98edfc64f42d99f6ae3ac71f462341382ac6a903c28c2a9b6a8af85b2488e37083be221e9ca255894e9fb364b65c90d6afef21dba05c6214bc23678e5fbdfdd2e8944fe3ab3da8dadb7e8c23ffd1907c89ca2232714d26ba29b98897b4dd18bc57a10400efdcc877877ada3d3cd98507f5b518003aea101d8b3ae99b13623038a26e34e4d9a32a7dbdb59b4427dd91dedb61fa46a36d2c50bf50b773aeb4f691bc8f3df628c690805e1eb5d83053e97973daa73d112c8bab2779f60b8d909082e59ef73c4295def13daabf6fccab5a3040a80a2cb2a897c6581976ae16466a118ea6695a98dae6264c1de5bfebad63118d4bff2d531d511f6ab15788f98c1f125c59ca3d10f5e1d3d600e77ec9d75952099cb002134e6f972a58491a39f5bb6fb3d78ebc67076a987c1d1b87b0c7605e1e83ce85c9f849caea482e8e4fa6d29ad79f96f1bfd69370c9e1702c142ea7464ab51f55de4ee2d3eee3a343ab10f6f00da194f2b54b571c66de403c730e1ad8a81d7cd0d5388164ef3ee69ec1ba9539a609636a1824f4ba09ab09f1fc20fa4b8ed2bb7fa671ec0ced6d938454355dcc6d9fe8e05ed8a1028e96ec78ba5457ed9cb5100fad0c1c2ecd3ef8160792f15e725cd03da078c16e49d50f44d53961397bd9363475c382633eab17d8b3dff4916f1704e6c3f19eb1e5493e5fed314210e689efd250961860eca6a4f29e6c271e52059fd8e2a724497072ffa75e108db00c0a8ce00ca5be1be1f1d2aeaf0397b4c0a6be4fa87c3a796396d1d6152d8d4682cf69e2efaa100c228b3a02997ef2c475d6d3d88d8f1c529d3cf2c3b16f9e669a58071553e0e890439e3876c3d9c1c82217271f419f74031099cb15189d1af8637cee94fa3ab5bde516f92f52d8664c2be98e9665a1acfdbe0d738f85ff18ac22a2776e1c5f9898cd248e39f8198dc83337c29885519f0a7a7650bc0054b38336a670807097bf6fdc88711ecd117938d36f1e748310ce1496902ac52cb45ca46a78cc82a1a70ffb4342ff580d056c30bc5a3945754d879c996cfd33aa52539b1e3b8229e4e6a1a17adacd2460e32f2d730640956efe130801458e97b5c5a3f897b22ad0f7fe5cb9b6fdd05f44cfcdb0608f3646e17cf27e48b17a4e68367ea9d1c06b5a639a2bf6a5aa801b1f5bf4d16a388894a62c771a1cdf6bd3e86e8382cefd39e9d533c6ce59080c16eb289e01e386cc11a622e1e35a2e275508559c3aed9871511b6480bb779a1e19747b38ba255e7e0a52492eea052a624d708495c2335a170286b897faf6856e2f27845e113dee80371602aea5e435cfe2db4c5e155580c029f8c1dbec39af8f28f0dba1db7a0fa5105fdd533f15d12b6352f6837e20bf3d906fbfecccbd3ffc16f63b2aa35ccb7e999fc4edbfc08a26a36a6350ba21b688b3425482563542fa213c843a5fc34477824f53d4afd8523c2e116e1a04310aedcfb44caf263e076b28ae5fc52826169a837a546ee16ba2bbd0ed755a4982bf5d67f1085a9f90805d43c8d218c75539f9ad387486f380b4a0c569610148aeea85727bd6f7123a7af8b1dd148be2c49886024cedf873f854674b73656eb8bd37d11ef581cedc7ca50a4f369896af508bd6e0cc9e16c1cf6532e56805f09cbebc71baa84117db224bf2bd212df77a535f11b390ae7d4544358557c59465d9db884a450108582154b73aa7a1fbeb3576f5fcd7f5dfc0d833749a617c4b45d498d99d5b6933046f28eab947c95d2904b86ee21ec33f12e3d338aacac77a8528d2dc3c3bc7fa30b4124ca02fdaf2739a2a945ccccb65901d7dd3eaa9fbac91ecda2d696c8b4abe8235226c3fe859f34321caecab61a12afdeac0ebb87db4b393b7af3f5137639cbf90e388931d1b34ebdb062013b6dbc3fd467cf71cf8a6fde1773a134908601755b65b4852bf08ad66402e4ecb33d0ead528eb9a1cb0bcdc54304629a1766c739eb3e88f2ccae23e3505bd01e1f5d20a391d863d65f42b0b7e927228b0680bad1a2ea88fa6326bf976f04e7e29352a36cf1b987e07d3817e71a95bb2c46c4afa3f796daf51d4ea47cbc6daa0e4f8543881c63a7a16a4e7793c388e02af231eda893b7a2a22ab9d071a0ab81a462fb9c9d1c5d91fef052258cfd88604b25fb10d9854c3ce31e0d067eb816edcc8c759756e26a000ae7dc6ecee6887414400faac97e5ca07a7477c0344eeb78f2c319aa787d8bba44771b3c409825c13f2d150dc6cde042576916ffeb93998fe9c5e2df6fe18f58f7ab1c4770138c73ee42bb32a76a5b3816e776fe64608dba9781bc7b3e932ba21468007cb376b5cb9c381ab6c841d5667ce08e6a884a0ea894ffadfbfa8e0ae4882103a40d47d571a13f3b71a9568ac789ba8256540de3d923871e47860a396f3d96be7db60c286f63b463de2c4b467ae028b5121cb1426768a95d01581b03661776b4ceee718e7528b6d86bcdcd6c3d0ad4cb1f6acc59d7758ab43fbdb8bd5966420161675e42c282c46a3dd1cda46706e5bf6a91795c7c9c90a5cd8b69e1f4d2cef5c29cc0703b577b8d32b2bd012caedd543a86132dfc2155851cb08ebeb42baff2f18d5d49c4568433fabe2890a6014cdc5f9ddf0b3a30753c80c8a55814e0d1df5cb8e537d6009567d742337a79ed3467fcf5bc57dbd95b6816d4517c8ca9370e0389b6c80edb8d2023ac861cf068400265552d4c13b1d019031144d81d3f438eb2258b9a12105175f0bc9404bb03601f017d49b8f13d21c8ee224f8ae98dddb05e8e4ddeac1761c8bcf690d697c107cb868e0e5900b71ddf4d66cbbe78e552865385c3845760c5bf48e119e244665e1b6c354e4c819ed58bae2041a951eb616063ff478f1fef960e2c689c8d00859d6a8c2893233cff93dd80feae6dff7933fdb9d9a5da9ea062478c9554b3c1d719afeda4ea1b0a2283b497c34673d9b1c45f4114041645b925ea49206f4d24f056ff3d87b73deedaae99cb50ff36c1814b25d0458b59d5940e948bef84a83515fb28cc6e8ef2cd60de8f3b8ca54e1c0495b1fe7448bd20445c9fa8e30d9928803d240cd8aa1d9bdc12a8e363e76faf843837c75b3cbd9a99e208dba68f3375b10ad9ba5984f256064102adbaef11cf74ef32a37b97148e8e614ad94585015640e09e5161effdb3cd82b99b1701f99d5c1535046a88422366846e2ae757be48724b5908cf9a5ec8c8aef722497a732319519917ca8de0bb8ab8e4a9e863cd4e20145529d17f47290e007444a34f696a1c4acb0f7479d228e5a5d885a96d24d1d474e5bbee007be84f9694464addb309ea7e30550f44ea9f0cde40a9b90452be0323bf3830814e01af498e0c4834abde662cf5dbb06a9b5e40bef5cd5b2994b85fbbf311ee62a326bd95f0064a33899b3f658cfe7c0cc4091a193dbae0a695804631ad1e40f7bd955a40c7b709a505093029f46abfa21178ee17182d428d3840593026748420f85f89738d23e3c6356f18627640574883b977acea6e3065c0ae9fe91030e93142c14a76faa703cfaa5a5a4c145f2efb4f88a82e69e31453a841b0cf9b604350523620b6aeab4734bf6d94a7fbaa10c8a5ec1044efee4eab3edfd720248a08001701155ff8e630a55ef36cc69c74a39ddf82bd6f174138fcbc8e87be8c6ba60cef07eaf0e42060e71555630dfc6c830c46a36fd27cdf201e3f9f8d35e2bd94c06630e519844b30f75d671e791d4e8c2e30e2c7a9c208a9bb6c6ad0ae47d98c4294bbcaa12fff2afe1eb99b44a823d4bd3279f87684f86d87ebc2854dffba4f6c7d847d9940dc3dfbe1cf9fb294593a00e1d0bb65cbb239ae180f33802695da915d1e4ac877a6a0cd68a76991d1d54d2709817ef5c7ab91aeb54acb81e428e40f77fb5bedf8945e4873295cca20bf45666fa70b468a704c98535a7f469698ba1d9ca42a612b6cac1ae5a046b0ed97f3a71c227a26db7b920f6b29315ec8257b91167f370e96a61380f0b21bd05a267446f1a63a50bd6afd03efdb80e55a273f003faa2c31674d4f00f9209d758d048f0f5c2743e2e4056f38d3227ffd5592fcfde6df927823e1e2d27c5689a672f2c28a2cff91e5dba7b1b6db2ec1f31d5439d8db2569ef3399a2d457ee47372cbe37705b8476f506bc49c0c633d88956a299b89dfebb167dcdf4aa56eb1c32005c7940c8ec297603aeab092d2fec3cbd9453c0eeb844f067c8d31dfcff1a2b19291a820b0607ecb969b347102d9b0b3950b13aa0ea5ef47cfb6c045b0e896f98e276a1d62c06bbce010e1dfe327f74ea067d6a3b380c6fda16f07bff26dc79cf59579d07117d374b3b385a20a2f4b4c5299f012a97c9a743ca9fa062e28bc38afc430423e56f4fad7784b21f53169d97ec805ae5c250f6911762328cf9f9a664d636c2b4b45d1f348cc51809e282f5b3052da42a4e80e120124e089fcdaaf1c428c3c584e505290dcf2e220986a048d88571b9ff94e3e4201d85ef742846a6311b88a1648fe84ebeb6b254ea322ed7f40dca760dbb8c97a5560df2f52a2576981bb36bc876fc177c395c61ef99cfd9574541b311b4798b1353a28e94766cef490a30255246af389302f4d0f0f030ff78b238f3823eb3116ba7c30685dff424d6582f3c7a66aabf7a36009ccce7f4c0c751a6b41ee3d9acdb7e407bc949e7c74754548b6fba32d392a277b1ae14511e437485cfc23b7f8dbf2cbddd9c23d96e5f0c8c0a4218800f8c91453c170997a33c5fca60b3b7e3a6072bfe0ccbe301bd56fcd566c42bee2d37a98db78d48ed5dc33d9511fc9f9691f2940e71f773a403a8680a21aaf19bca2f7f4a568a081468f9333d813a7a7275169cfd47285da8fd455a05f0ff822081910b779af8e20c6bd0d2eb29b6cec13a772a41094a3a2e04dda6571b496da3fd35c3fd21fd01598985fcb60c9e9f190df988a091f3a56e1d0c69bdc4ced2c2e6c8116970e2d1d7fa16f7e0d48497ecdf629849c49e5d647fab6813fe86e5a9bc1bae57d64b3138c402bc466fd56cece2cfe0a2543a3e2f2a7d0e55315d1b565671af1f7d9b3139bf7a36a7c554fe7c5c0c2766162a9e753fa910b195618398d10128ca64f4def3c74afec10b09db02d4ddb03db66c3438f77ade8b91151e039e5db74adbe1046d24fb24bef4d03312cd667c05b168ddaa3ea200a1bbbbc0a78fe058712dbf8829527dd7ced3b9071961925914afa07d5dffce416e25fb31b158ca62d91929c3253574f264ad45c04857cc2c9884338b676bb91734177f2f65baa626969a44b09d4fcaae5692493f5f6e627d36d730f461763eb405e4599694a0ba1433bbf71f6dae1459edc1cd77a0bc4448bb0f6ee0bc6b99e99eeaa07a930477d14576706430936f41c244f6d931b8e03595e250c14d82524f7db50e04221199b54596d29547530b37c1152d3d69eb3766349a12dd380e2b46e07094206bc1dd580afe707f090e5df87b33d052a6d1fdfece39dcb0de5ee04ef2dcee0f2438c2609078c1e719b2e3cf66e1e4768e17157825327fda8ce88c7bd3524e7df490f480707fed178e1afe2fde6cb1251c0e24085654341cb4943c2eb9571204751bf4c73625e96c499f21db77f04a9d4f43c81f9891ec3e52a9e9b156365b7dc32054dc5913edf5e88cda7a242f80a07ca123c2a3e8059c61e9f82eda3a437ba2bd6fb2ad1efe75d91204e8f7f492c2aca96c9502e3c1f989863645b78b4297f23a50f9d15ac1f78168457d4f0d9f1850bd3501d352ff2f60107ba909de59032b9f79c1f18618db7d3739fd0f921eee8124456acd59938fcac8cf355182fdf43f4a7bb20e7cef969e88d7b8f44b0210705cdce2a3ec2f0e3275ac501bb6722c391d149a495e57fe71e0182c4ed4ec4e1b20e0bedddc4ed219a179856837cb671d471b5d4bdf919a59dbd6727f9d99ca20593ffd81babf46cb133e9ac791a9bc735be68107024fe188aa7b7fa4d2c72621f7c5def98de971eb2fabc2995b2a1946eece388592288859f581864f5156c753bd15c9224c82234926cac99f5abd616c1920ca12264e30c771129a338e5368269a39a53854d4a2450bc2f62c6914647be09ebaee5cf467558938d7cc587f6b500c2639851659f20e8b1b7b56a72ee93532054ad476615483c801243c7e2ef8fc1be41cf9e9aff4a63a19ed8b366b79137221f95a41ba88a3270f69e0668a769fced4aa1b4fd8c99b9fe74b608e178d8eb6a1a2672206ac2e6cf8ea3a37986b6dfb304a2bc5364ed374958bb27742b74dd5306d9a00f1b0629922f3fa28537a3f2a13592358ec41f4a89ff48162683c8b6484d8d034c90b0dc947d61143d720131e6a45dcb7de6374d1bed3a1a5e1520f48b7ee424a11912734245d42b8f72532d929fa418736e911a8b50e00a509730a62afeb923b9f0a671951db08b307c190d0daa065fa2369c2110428d65ecd18d9e37407780fca0a1a8a1f8a143fa3f9064d958f8009a218c23c433e2e1df852b35503e27bab388d6154de8c7694c4bfb99be10f620097d7a738f54dc78f34c011b5e16104bc1d75b6d820c2f2e07f9f1cb0c86e6df39d25b87ca5d379f5d450dbc1300ecd6f548966c6a09d270c39f7f2a737e0d9f2dec3fd4772adcddee8a8f1662017634dc0663c7273b88f46d4263176044e5b221e9ef8a0beed3ca37243a75d4461aa788b7a584ff5065064d419a475931e1b60eeaec2b632d30ea883ad8dd8bc36794dce6725dba0ff02951e459dd8807c188be48527fdaf2449cb1e7e454c67763d6490b8a2a3fa3fa20e537fa40d1f69ea1b44de0b1a4da1e6b81ced4a3586bd98bffeeb0d98dc9653f8e6def323383e04262cbce098bfab9c479ea76a9e111e334aaf61ec3c72f7e1af698a63cd4f2d267a67e1a1ea430a599ffee0c0a4791259db299cdcd26840464db30e8d2703efb60c415e109395edd132eb67b06457b8d08e44c64a5ae8aab2da19d5220ab0a554446f7920e4eb0a34796ca1098273f0276af62321dc75c4bdf203f737f8992f19a2acd42848c53002d4f461cfd4b1cdeb6e9e51b3ef523d988a1352f5f2a2220bd9fad1ebf0e562081fa24e3e2802909c7e62af188644c7616542a8dfc4adf5656ad3cda221a5a1206eef6bcfb44911605cd5ac57b659bd9a83adb74edf2e044835c8c8f68f1e6c5beef4c8cbae2bdbf73950b6d0b8acb975ad4f44277b51416a954e6089aed1d0eb3a584d9eca7b9a8735e3900d6a0afb431f1107218516597c0c7af832ad64b7e1bf081ef6f16859154a43dbb3609d00f0bf2076c1e6150e0ea8bc60972eab49fc953d0f74e5b550ed81b5706fe5970ab8b5a5ecefadad585ab7a16045693a40c1a91c454f5034ef2c38ba00787123efb4ddad84e0a9e4af8e55b29ae4d35c9d7b59d7902d7281892a80db73ae7f38a291029ed127f026b22fac019d0cd1b33d70a7b4e74507a97e529cd4abc5d27ba0a3e8bf82be51996ef97c3bd1122b4977d5da6f6085410d5010a47dd517952d0fa6f6b18aa86b3d9cd9779782a12b759478811e3a864383afdeffcdbe836a3dcce0d6a122bca9e5ccdb443b5ad4107051a84b9dfef65e64949a9525ca2c7c3fe0a27313eca39b923e5957f2b9eb0facf244cb2ced57420b1cff02efc562449659db3cfa41937b4865726a4f3c04e82dee22e0a2105e0e76f0e7ae14835ad784d6e7116bc04693f06a78ca824ef1e27cddb74797a217da463d2867aeb466baf4678b84d0b486455ee7d9fcbdb3705b29e5a1ba19be4cfb0efcda628166c9214ff54b1d140f81d3ffc6d27579ed3fab34615676a30281874386ce528ecf8fe5d4fb6bd50d5bd9e77ed7e178f4303babc372bf932b2b0bee744c243aeea9037f91a27cb4e323622908c055b701168f2a072614935b6682a945fb9601a3610b0389399d54a48332931006006489948f53974c6b64d9b9e2427fbc4440b9946b6decc6b2dea6f76cbae76205017bfc8c22c28b2292dc4fedc37c7b0bedf89ec86b3981b522edbd8591d7ff582903784ee0ff3d02899d6c72ee6d9ce1a6f65d9c7b93c43270dfc9db367cca8d8adce67328f7bf412e66d14aecc865e1156b562632c41193e2ddd521f717db604666d3240810e7c512d36d91c23c0802e169547292715808c198e18f0c69b9203a3853b49a3b61b3c2beda2409145395653a67a46cc31c49a2e45a064554daa4f56ab1f6de93026342b72ada3f2b246bdd03ee2602e564737c2e83310adb49589943241c4789780fb7e145aff7bc8ff3434b2f417aba2f44025acccb405cffc8d59a111ba5d8ba600fdb0e88ad6829b413a2f0c0c2f881673c4d5cb86ba0f6dc1ef10d8d4fdf16ae99c554df104ded7783af6ec7acf835cc86494f07ceab5d814e6a6b17c18eccb1afa9a3cb8b7c86de4a2552064b8575c394bd585949ca77ed47873ecb14238295400ba0b778fbcafe6b37139980edd8680b4b6dace67c1d85a4abd30dc5404dc98a84d6a6fec254ec46f9da62e544a7f4312885faee18ec3bedda82fb8c5baca36f7b153166c681e852c11a3faf09a0c0ad3d7dc47e76c328e921e7d04cb536b62383530e91ce7c98f690958743b64a62203edd6d4cf422a2f55d00e1a7498829167b66f184686a87995d288bb6794972d1d1c64a195bf22114cf257d3594d3f78595f94532496185590e0b8ca98a03c90da372caf15c9bd8843e368e00b1c9444bec06edb018455daf1def705c72b417af3b6ac0476ab70fbc141aa6e6a9e297d6c68ed77657bdf1c603f25d024ffec052971f77811597193c98e5f8e70fb37c2f338880b3b31149d8eab050948e1974730ad9b2295162addd56d9593a60ea029df1042faa0bc635120f73775538e071bba68777ea3ea92c3048b702d16c7b36246c1f2e0a033dd7b039d472caea73ee72cebbf6da09fa178030edc6bbb3c9c34e392d264560a13a8bffbf5e59f4dca3314819408022ee3d01749c7c8dc4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
