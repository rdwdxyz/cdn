<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d6edcfc94df8941819ad3d7e7c15dd615ff9eb7d4d8ad12e778985d272e8a89d325b022064183f7b929a2f05b5cbab1f85201e003128d92b848e9c3034ea76a83ea04e585f9346c3eab4dfb9e67975c0b67c8067f8eac25d83fdf39278b5374f29260174f291aed22bcb0182502dfb53b9d036274c563d97b3d834f9aa9fc546d244d784dfbdc699373adbf04a87049cbfed5e2347d5061ae76aea756a6eed001dd3513297ff7535c32879bbfcae992b2404ee9afa0c0138814095bb2f3ad6bbd431f7c622dede9d40aa40d7d97c5dcd17e11061e9b13531d8355a24b67e56aacc55ae98a6e94aae77240abc5cf0c1a14c6d1b2d03b935fc983e124c8e144903464d27c0402077aee18079b3fadf4cd7f9e803d1f3ad5bb9073fc2787961d3d7345af282cb8b129af125b47443b84592a49853b863aaf05f4ddf5aeefc109d4dd6a8a153abea01796817ad79dfadd81988a48b6b58b0e778edc1558beeefcad52100a5851b93a3ecdb77a705e8eb48780f1f8ce97b47aec104a3cfd6e35f9720fdf141cb1b98a3d540069360c785dfc086406406fda848a01c664211364b710b88528f80e0b00ceb26721b10c0673d09a5801b1d0d22db3db6890b2ed37c76f2417d0f43ad970213ea85e57b1b2ec17d48544eb53def3db1f827e33c65a740366e67fd27fcd2e1af6d47b94d616915d9c193c332be103fc212117c8666fe45507796fa94d5a504c7df312f82c0793a273536aba87882899fc408dde068d26c7775905e88838417a6e964b36473b1833c81af1989fb50bae002597fd529c59340c1185a98b36e918377ebcb2af6961a6b892ab3ffb6c349ff633aa3a77d0d280f37ebf52443b3823f4d524c2132d36485b38c617daf9f1c41ad70e3678d259a1feae1deb312dfdb77a3b72b3a0c21cb104d571936435b65e9ce63539bab633628a9242c52ddc8d7a32c02d22420624f932bbd166a87156b384d7379d2731b38fb4b65cee3c827ee5126f808aeae3a464d96e0c340edbabb6da21bfb92a1be4991e9861cdc8a47ffc2b338d151d971c453a1d756dcb28f646b43ae445174a952999587dd428c8b4a1b092ff7426d55dbaf0706455274b46b42882663eedd6acce89df44223709a749d062e3343c24f0dc65bdd92768acf15ae88d36a9c821af281e31a33137eb6abb4e1975679ac7c49b15183114136af7e41917d8e40b79269fb4e27a430a4f47438a8c41af4912456764a43b9ce0373d6c0e432ed8b50ca99c9736b014da59b288f20db658566340422292749f10587aea6320e72bb69957e628a66da4a69623939525ca662e5fdb258e7c52562a1832d299c55cafc178ad439a0e95c755e3b0ab4ca8d7f59e18d8e9048f1cef4dc4ceb684ea0c7dcce107aba268ba966d88bd03ad3ffa111f05e5af76d092278b045cd8d02023f3d5188beacae0f8bc81f649ee4b85b8dfa31c25f925db768ec6a6809c8ab532e0a8580f948068970a83d5f9d101f2e7a24466e0f937f500b387795601e12fedde3efbbd5c8749c2e3caabd4f259e44395f88defc1dba0a6fe291e168ea7690622c3bd1d807b3223add332eecc65b8405a80857e42ffd154d81f52069f624794ed128a866b1c5db9c920ca1926b7cfca2b882908c15b1d7060b72b2792168cc48eedd541eeef7e45b4c2b05eb7a2d76eb4b4155153cdb394b6504c51f1d8a820dee11ced2571621e7cae7dd65221ef2ffb9a6ca5f3993c6221d5f1158303f210a165893421a5b887d8748a75df849cb21cf8a0fd80ed9fb03fdc40e94fa254c9218383023f8376c463ff12b74be6e30ac186082735dd0ee85a86dc4bf817ffc15bed18ea1547e2df5101b556df3f6fe6f341a477524b7d0995a7c4a2eb6c2313e933b76c69f51afaa38fe49f767ba4a80772c0bf1b3d60da23d8f9b9a11cdd96cc618e2a3e344a8e6d2500535e7c3e327628efd52c612ac5e90f0fe0995e324cd9ce3b4b3c67f8a646c4753094c7a3940c9c8b927bc9025b051fba128dd878d84509ba01e4e0a63be001d65b18523c14eef5fed62720bdafbf4769b7a1e230e6014ae0a24facfa6fc1bf5bf9c348c48cc4193b92f46e69b2d004b8e09675f4f4f119712755a2ef57af8694587c7e3ae0bd916609919acd1e978ac36081b28bb1266be88e4110edee4620f1b425be95512e6c0cc32975c5cf6306ec58de2643eeb7f86e34700fc268c33b15b58c1510d0a3ff562f2ad3327c437d8f31c7381d8159037fe8d16afed33184f4a94d9e46e7745d90931eee19db3dcc2ac8c1383283517970331a4758bfa185b96a67cfb4dd55b4f8d95398c5ef0be6a6d9ceeaa5331cdf43ef1b0ff38ce25df55f11dd033d09d88b5d1416d2d16fcc96d47e899ff0dff608a7efe104b288f6cec5081e51fa85f7ccedbfc1fd3323256bda4d9b8a44162cde9add0a303ae06fd375e6e1ad3cccb5a36a683fb08ee30b5e197c0ee20f709e6c4e29954e91ccce83bb9782dd8b851b4c34b54703952df045b2d49f1b7062098855ab34d5ac0d3990f730da8e7abcb20d7db486b15a1502bf4ada8cb64f50b7ca59f03c687381f3446bd492af4edc7bdc7ad88832711fc5c5a94eb931b19b39ea3e3dd84822a9cbad2b18b619fd1bdeddf3ce03aa87f7ce7eb115c9d15d079af5100795a84d2ee922978e8d4ad7412613d8196ac7bd7c2fdd85e26c72e9769687da8e195a0e84b778507d81f6404ba76d6ca47c30bbc5acb158bcb91fab3b26dfce3bafa1c324d9f7a7dc42e4feec4864ba9eb1c52f0bec70c5c465a7bfda7a184118a515486dcfa8507d7308ed2f093e6dc840a87acb725e0e8b2eaf31cb792536b93893bb7d7c775d872f6d0399c55793d526cd8c4a078b154598fed74a6eb0633e369843c2ed19c8629f33327239d966b3917c161e39e9ce499dd16604897f32b71f82f3284964b24221f60044961a67107950acda02695d3266e39f0dcc607a9ed17f155ad7ff5deee3caf27af73e133fea0476a3f391f45b16ed17337a465e2afb8de2f2e587b03e52d076b68df18d9d8373e5b9340823e08aba0aca6bca5deb93c3fae51422cf1a2b0acf8da62d528759b7efa7da063485e7904cb397ef6ebcada4492020adee2503c58ad649b5de3560352c22d57763c282116777c2aba12f8ceb7fc0464f96be820ca5e8c7f9f062d568f8c80437cab87e4df10cfe7c556c1e40cd5194f10335d43470e93275116cde5c116ee316177d95a8ba3ce581ce5bc948c2cc8a2f4167981706a445df2ea861c8febc382d6a9f2b8ecc58508e0a739dfe1b87501ce9a33e1c70a1229a4d4a1912e2c7393026160d91caf767b5c0bf6de14b54b298a6bd9aa6fe423646f58ece83b571ebb4b14e4935b802a2b645a1150b29e7cc4685eff23452c3f5a085328d460e7aa29ef88acc4fedec975a89b9c7db0741fd8ec7d18efb74beae90c0906fa173862978d9bb1180d4eee509fdfae6fe229cb97201a2f8c97be283021366caac84c6062cf2612b89cc2f6dc9670d5eca69c9d3b575764a2d0a48a6a92cd219e8978b36a7bf7c53cf7dbdf25e243e0a50502d632c3def1f0d29f5471be4dbb4c16fc10da293e69eba47eadaf2afd3d267490f73b3353af732b8e8127d78d356cbd44d3e023d067906086e79b423337d7bf1ce1f4b42df0aec7c751b71b53d18a4fd2771ccebb207f31c0ab1b367fc50d7aae8b3decea0017782f31f6711bebadac50af7969fb5965d40a0ead34239185d5d20c25ae067fd8d0e875f3d8c286ce4f51798a5bef3b3d310521454b905813843ea1c9a1e22ee0b779587d49b2fc9ce0c1dec9bf4ae2ce00f90e3686b672ddc8410062897a24db2b17725658a5901bc40f7672a37b8ba5a03f6db73793fa269541e31698408d2c8bd0506493d20db3dc4b26bffe92995213d1a19af96d9e87b296c463b192d2aa67cf713057b90bc98a03e9c347652daeee4c0a52e90a0187735c26791d43f62a39fa8f32fa4de925440780c826f47a026132ace50542079e4e9394339733d181978b9bd02a933d16cb812e2e4050e96d91cb15d626220b7c6382f202e5f6e17c6bc19abc52681ba76f523d00d86bf64aeb5dc18313ce26ea4378f6227621305086df1262d46fa69e2c00a489f961189e8ed8754ea91bdb973839146ee14b492d0e50aaebece9ccf286b29ff85e05fbcdb3c2e04834b796f425e8a85254319aa36f4dbe6975ba36b354daada0ffa7951b3318daaec1b42062f75998ced75a9ef29fd5822d39bea510ed30446eae9dec76770f6b7254fa99ec9ed9c7395de215a6383f4f86698686aeee87160332406eb2fc140a491799874cbe09ee0f26590318acefc542a2ef464b0fdadd23526968a2fa5a12e2e7278c7a5b016baa5ac95529b978c4eede448f19b2337dc9cb502f44289157a8367393635a8998defb4d5c2cd517153d527e77b3ce247fe66667606ef83dbd01b545d5418aadf8f5cb7acdf3f65d78686070c7e47194ba0b02b9f4731fa0df54055138a9b73d2d575c7f376f944e0fec718b3d49d51684c01c625fc4b14fbdea46147ed042a4a99551f4fc3bfba5e4e699bd724ba51b17f9445bb1dc27948dd4a2120f1004c100e2b75179889a19bd9380a3c3da78f94dfc9e0e7afaa4633b1354662d8288c05735e6efc8eaec3197a3eccc403c1f67d051c21920cf1fb2912a2b6505659b0b98799a51068bac7c20d3e5215f1012da42d149301a62af8d1371a8f72cf6a7b7a3459bcfac61ec4976dae2e33f31ca168ce3fe5ae1381ebbc0330f845da523494692d78248db606dcbaf58774dfe42e76a2c7da7ca2063d938a823a43be806b1661dfb4b3f9ef8b3a3a8026330e6a9b0cbbe9d42deff09b8654ec16dd9831b52be0c505d01529e3c5d6009b2bffc2cd400e56693aa0b18c5c4e47f1c7ce38be023e83d971f0cdfdc815adae991e60af552636947f51ce958e75e19a2bcc3686e246bcc5c90d44c2b3e04f445debe3940b55c5da43ea7b0d5d1e3fc36264606dd0527695105caed8958e71d7228dc949c65c32acef0d19037a97d6af656084d84cb3f948426b5121f8aad9ae056b5949f0ffc744db6830bd22d5867e47d18d9812941f324f8d352464814ca468cbdf8c61941e93a00b68dca9e8c34ff5b70279ffa5486cdd84cb42fa92c181d5ec5965f0dd25ccb4ac54eabe4fbd356f21009a37bb6eeb8acab386addddc7d5065e570abcc757e4e3f4c4440545a20223052863c624a659fd6586cdc60e16c02b08cf2d15834ccaa516f6d6bf36fde2af4f394926f1059b42670de7dc75bd88ab2b8a7987c1d6f817dfd26100e5eea1db6e9184b0681e0f32e06b91a36da4058fa94bcff012b522cef5cc7840986d8358603c7288206c5eb1a668d15447f779c6489da6d05ce36fe8d4c567e3f02365f84d829b4299b5a2a0979ec018c43ab6ed8cc57444b4c78dd6ac9b060490cbfc58b3c0ef4f900ba698a8df97509f4d7b2ebeb5ef7890215bfea4eecb94ae207f2b799b3c2c3c58d8a5fd46b16ccb5e94ae2bde1c5727fb5c337f8bd256adff4586f66ec5aae05da620c94aadcb7325733734298e2ccfbfeb38b1e7ada015a8d1b572f8c7de1bbae2197e1bb2ce45ee73201eacfc94c87baf0b6e50bb2957a414626913cdc19edafb28f06dd840006ff50e5e81de788d43b48f58526cf1cc1b9702b7ae92be940cc45557c72330f839df338ca235b521d29d524def1b7804d3e925fe9cd9baae632f1415bf06b7321798d75caea0ae7899648bb717a28da64eb63e8117d3afa7d06960f151b3b2954f7810c9125fbfb3cbe96298f3199242b6a3baf3c7d4742b08ea7df7da4d9d7bd4add433c674c6e05aa55278353c4b0797bc5930ae4a4f30b7e8e13cd023c640ceabc4e251bbf6345c3b0cdda7933fa2cc89838c69c13b329ec989d25fd2eae446a45034a1c51a97955eae65cd93a49824576ba1b3d0ba12834f258029f129be9c6855e2fed28045b19dbf621e2c6b053c210574340f73ffbce40720b4ea3b243aeabba0467e02401825bb8a0fb02674e95ba15fba87cdd854fd46f647e4d130f4ed06c7702d2b0faaa7b3b43b243a281eefca6cd23ad14dcbe3c1089b5fe5d5aad00d5a917f5801597700ca50ad8200be3132ac5144955e8b6267ea3e0977395ae9abc5e0a5a9bf7e22deb6e1c3bb9eebcdd822965d5c9b66eba00d083c28de8722e4446e99145bd858b66ca1e28feda752b615c41363495a632ff7bc0894aa89e33238a8370c9e0fc12c27a0bc38da29f66d90f0223c43e095c23ae0083b7e58cb4d6adcdb286fc4ba254e010cdf42430cd1468de8ca8222cd7983477b15edb3576902aa9a92c5c9db8b6a004db42e1aea200216ba29553f78fb2decba83d854cffeafdc9f8762f36ba8b90e8f1ebfd0cdc7a15f8941176b2a880364501552292ecd4eff0453529ba7c458701c8e5a027b9f765b7495784cf71fefb5941ccffe284831db5aeb873f0408a1840c8f26b74b436653dd439c0e8cca2491e09244dd1cf2817c793691976c45e28b15266f13a3746158da8af29ba845159ec1b59c5dc8a115332a79464916ce16043aeb43bd0c76593bfc7900ffa279004deefe79bb8119734e4ec655892087f22d2fd927e24e31af7f625b0b03bddc83f5fea0105df9d61dbb4da5b19bdecd79988bd132cf0bae246b06535a19673c0c0164ae2853aa3f6e1e7b05636bc51fc6ca3efe00c90179c1156601368a1b09695cd1b26f3f8af38525cdf9288b2c641f6b2035dde2c93cc11af2c8c93de55d0029137c60f0d11242c5c502d71990baff1d1a883eae1eae6b35d77eb3c328b8dac514784ac7ac131a6079c7d5e1c0b4a9d338a2e055be2ea44d5fb4af2ac3728b45f1de93c4fb358f40b4c54c526eb17bfece7aff74074fa3931e3c7207548807af591a5cd48c637567ffe9b54a8ceba5374a0c978c0b78027c2358186f38cc0d92bf948bebbbeecb9558b3c9e0314e3831dfe402428404fce660b1b1ca25fb9f19213ae81703b69a7386b667d74f0551cca2cd0e17410824ba6eeed9b953bb2117f6533bbf7a6924753efceb511f1c842541f6f42c59bba0273ae6b240dc53ef254beb3ae331bd1c5efa77d69f718091da98a376bee9ebcf5b880b1748046ddc19765fb8447429e7091688abc470d797463fe3adcc545b02124a83490353ded44f145118a7321c395e30d3371afa832562d78e95e92b3548eecb0ed103d37782d5e818a5de9f366417243670ae2ee54e28789c2f4ff338a6ad2fcbf0159f3500858ffa72e54cc8a52ebfdba1092cb8602ac50b05045be957ff92e12963c7dd9a9482f9074b72fa026b018e97a283b79cb6b2187615efb5afbb4574dd6877430fa84d3b2556a4c08bf86a835ca301e1e3833adec5f2af4f8efb8b43a52b8760f2dd973523e6538821bf773ec2d1e66dbc61e7cfd23d33c475eee966db950c97edb9d811b962cdc6c40c0cae5991b030b98f1fd75718a676e2bd6fc92a1603393fed28a5dd3de42f8aba825266e57e0b1f78ad4837d9dc81af1b6f95bbd546b44686cbdb4993982971dd3502675389ee1150629c82a2218de93dc733e2aa460f492947b56ac68ee6b970b55af2d4a24d73735ea09bb85628be9e59b2f30e75b61c40fb8fb04bf9a1920d45da2286341a347e88676a131903deed66ebab1d4b9d9b67834bbe75656ee14f13c612ea6cd9be5a243228d58d38de5a1ec7755e1848352415ccbe129834204e386d0b094785baaf04eb14c7309f4c03c26e05ef6d634254a0102a8a7e08cc1e949fd4df17ed81f4bb94d0a7f5bc44e9e6f65b0815b65a95cc541eefe73b26bb3737e60787ced54fb1fa3ca861d74f4f94db17b4a4fb6734fc1ccd29cc3488ea5741d80c75414cac140e291b92322fd3f18095d0f2559d5003154e90f5e6f77a6aba7f58f43b3cdaeee02ce24ed03eecc619f9b3c10ff195b79995b6b43314e7bd667c34b6f4e55f5a4a981cf4a3959532335ac47149a504d53452e04fe0bd91b7cead099aa59bffa6438459b929eca631d394f06fe01eb30710f8a615a8c3b19e20ab7dd68c510eeb37c16e6b61c65f97200020c66261152587dd460757e2d76c03faad002231921297f573fd6a77e2e60b2a683a89508745cc103cf5f1df4018cce19bb7262a1bb6d5af13a5e3865ed235210d5bde28cfa726ae7bc67f45660b0445b25b2214828e743870b79a333bb9297a8dbce5d5a45e1b0c3f2f0814b894c63ac9a04f67c193482130c89b69c2f9f69d400874112c9943a8b12bcec5b3fd358ad640cd7258ad4e8d5fae7b8a2b7e975b44d5b403af13cc7e5eecfd2db274dd07113f7b2004f96a45c9a0fa5ff0bf4304448c6ab79862065c12f948079de04a68462da0863bfc2082978e1851877e84f096a54254b72e62b9303d25fa84e9ab51a865df6964e18a178fec37a881767a5634c72e93bd2debf652b84778eb65e75a5669be7c65f9de0f22d99f9465baf4ab7258ad237a2a185c8222d879bea495526b3af733421865d96b86865ab35250c13f703d27c97765491d7c183c9cc67b09b5ef4bfc3d527f8795d73475367a9dd92546c756f8c84397f785a148807801070c4ce1ae039d7af6e2119c0e0d56890010a4adeb896532560b250b22a0cfe98c4998ba557f58c9fea0520a44e964f6425f30e4e4cc0a3c858a505e81de18fbbe2fb4d5bc99e7a617b16b7f3ea5802582f1fb594014ca5584401ced8e2a4ab4d2929c45fe6c3179c196c29af672af75642dd4db2e5159ad5e7de6430b20edc40e899a4fe156a5dbbee63a3990e1d62cdb214b02b66c77945cbf8e3519c499febc9de2d08c679e96f1303c540cf940e479f2f9223f509f5f3efcba6ba1d9c68ec1562f9b40e9e0ee7a9f6a31b2faae11854caf50092c6eb681f1a7e65b558141c3d2f499410314f31fbe0141e4b33468510a82420db539c927e42888570d924bbea3510cb7f78d7f66986a90417eb0763801941015dc72cbaa2282a84bc1b9119e2e9972540073a0dd3eb7e8375f00f1b188951bf22ecbfc81bf6b1455a4685cec4033bddddb47519c5bb621b40825f326582df61344b0d3ae815e49b1fdc238e397d5978806ec211effd24f9f77fa29de0bbac69f30872fbc6298583152f1c7e031fa3dfcae6e8fab0d19da2d0037bdb79fe27646d0b027ab7afc54a7d705909eebe4efbed4b61df1962bc6eb5c19af541acabf836507453a1544f49832755a7c5907cdfb06d4b85273a3d9695ab4ce758047601e04eae56f3d6f0a12b500c7d4dc57dea5e5ba9e3673b85da21ea608c42fbb4a1356ec5723d62f3cb447532d0dc382393f90fc8fca852837ebc197ee6313b522baaca2c83b1f8db505dc47addc4ff9c5d589d2449399ee6ff0552acac9c6d1c5cc264404c1b5a08be676fcff6350341a1710e59d4964b9a809414f2560799e954e83d258cce6ef3e4a4bb3c8c50c702c8aea0a50be4028b2eed3d75cf406c8c4c3b850c9b7b97c649bb2af5a81b75e00dfa40413707ae96e31e0ad36f38750847d501142d3cff5ae81a150658a5ef77d5f96d97efb209f78ccf905078bb19a8255343979a77760b0255ec695262db7d9fceee98ceea864c642f6ca3520a12b4c0d972c2575ecf37e5c5cdce7042c023672951a4a72ad780edf665dde45257a86bcd52d9ad1d867b04874f95636828438809d14430c6e30c840016b8a31beab0d0182285f4e2c223d6698f2e5134d7901745ec65a2a45d74383066798b32ac0dfeff8deb88ca9a4ef3f5356a2f98806f59c70e43b4e65424e89ff4d3bba28fc6e555ae80f038450d75424803e30719cc962336f0d83d8bdf9dc9628231debf0055dc8b127d72ed2a1513fde58e00fb3b6b6158764fc12d9e592668c87541fa328c78ef45988c5775f221ec033a7dded0dc4fa56321c03ce78bf7ceacd2fd1e320b6f53db9befad80494b55cf50a946204771ae33418c20f31f23d43354e9aa1e69ddff504dcff2ee16f6e44133cfc8dbc77d228440b17e5abbcd5c0e381f1f6e095a3c3b62757a4c5e13b02aa34bb482632c51c26c67aa10a89c4b0eec3423f5d58049bca98ad41dc8d0a053e3423a1c680d806d1f06698d452207d2d9ffa7b7acd0a132e39d57135c6f4942ae4f65c1aad63d5b923e6b10b0f0cc091fb255723f683fe60217082ac9148c559ee02b448132785a1c53545f4064d6aff5114f38ae4f4ac9b9941c0ee35207990385d3408e625d49b326030cf421ab08fab0ee87f4076857661ec52c05d95ba385806d5fe640c4c8861187b6241dd9130f4609d5bb0acdb401e54824603ae63b93f6f759add36f465813d7526cb2939e0d151f66b6e2e198f3014293b8a461f639be5fb9dc021b6fd9ec7943b00c05338126890343d9b419e9b15d22f28d5ad8b02aa7680596efbc0a36e964511e0be88ba98e87d86e5d1f8ffc23fabbfb2bfaee2f969ffd3affb8b8f137759ec543d163a6a7773861026481406669f742151f07feb0ceb07b2935d4741d226270a4e319581ec024c363d82ce6b5e51076894effcd958819ad24af64bfb1f8a3da183ee7390c6ae714172a1f530e70ebd6f829b391cf8f6f7488df628d2a8e3627fe2a335215ad1cd705e6df3a155cbe8ed590cf0ea1940cf83f7320c057207f44ce4a8c936869f6b69a83ed35a1ddd81058331ad4a1dd720acd9d1d2e498fbd5204a3c9dd1ccf4b78f0df58e70b14039ae0dd28b8fab616d402d334e61fbfc115408c7102133cf975e435086c95a87d33de694b362e33dad8c04ec3060d6fceb86c88a2b5f92250d1c6fae0fe499389cf8989c13b739896c4b04c18c79ac8c6f916c0bb132b5c4453775179bcfe4075541a61927aaefa3ebbaf127cd229e6ece3d04b21cabbf4f6f57adb7587ecf87365750e2be271c4e68379b75fb4f85533a6294c9e00f480c57e700329ca6f40576e2388b41ef5be6a3704c4f91c03be84366b31ff12cd64d2f56e79f5f74c29ff9b792a98fc6b45f1bbb033cf39c67c2f68ee5cc4590bdc00a970597895eae843fe5c49dfc234e01ff4bdf177ac3187758e3b2fb10f23e2bec8d9563cbc6e2732280240a1dbca70a52a3ed7d2a331f26e01bfd8709c5fcc4cea2032dae67ab2090afd660f3c43ad785d8de7649ec6ca3a5a0f3f44c5c3a52fe4644ab444889ab9800e583808d96d88340ce147dbd6a4844f82784406c7f74db6cabceb40a68b348e99eece9ffec42e88538a8667256cefb5bb9ccd56001f12f06c8a5dbb0aa026a5a58385dfd9fe15606b05c791f9fef8b30e805ba812e7eb183ce8a85736d8b4a88bb0acbf921897c0603a5f7e066203fd828cd2f0d6f422d8020253b5f13b5b269e881393e6b0c0a19c78261d837f664277b36f45bd7d45e84a8636b6245de94fd002a9462ab987ef83253a3aed59587892e1e5877f28dcecf81abca570b418cc1927ab0f15e41dbaaf9e6eef779c3c7726c8508b079f4a17abdc573a484eff1038e67e7443c15c02ddef49d3e84eddf8f02ec3d701cfa6868f5b1928fab126a4ec5d6dece77061d85726b3922b46f00c8626e889066e10fe507617ac9711898559e50b8399c31f8d4e3211d48369c925da47ebea3b8bf7b2c5f2c1cedd7f3899e00bf66cefd65de4eea57795fc8729d9687d182b24c64730d18cd5c8424633cc32f3b1b91ba369a7f04a5c190e0051118fc7482d265b994ae6dc188d34bf428e78b1f23a7aad8aeae8690487cee69fe55c7ac1093b614693e71975a38446f2e7b3129695584f4a3af226ac2105ad9d6288e939ed8c6424ce0f7055303ddda68aa1ef2dbaed5616d6134da5a8cb3e975ec1657b1184b7152ef2f85691efed98842246ce3691ad6f6d1f5ad2e80e472ea083220463a22651135d81debeb9803de164df47bcc0cffd85024d50e94f694449e082720f66ce79ea19f867c062d95a9ee0af456f56b93c7121380887ef612e89b5f0d4215145383f48a32242a0930f84dce31de1f3317e008b6beb9750940aca9ddaf0c8aa6e36c5acba6ae29a01602ee177bce7d398b16ea049db21fa330b4fe9fc330f475567664d1bed4223c6ba4b406db1e4dbe6ff481c6209a311e6be44a129fb286498a51e3a04ad0b0514d89dc1cb34ae64bc210485ec2897db150de8d19109638bed4a22bd07ec8effef56d7c69aac3326c513ede58e0e594793ea31362ba7b87eb2abf0cc1590d6a504a90da6184e36d8f579318ad1de053841ce7184877878501da43604eae79283ca56ee8c4ea86dd6dcd3de0d6cd8265beb892bca773f282257e055274539bf3462bbef9e4f8e10642eaac0d8b62fdeb5d70144f037e2b3f72ce4ab90f44a6a787766a6db89a85057913488ea3cc4277eee9d1bede9ec7217e3d39544401dbac763222196da4ca6cc0099a495e22e0b36cc25b72755f1962911f72bd8d4ca5554e684c36185a0828ab2d51f8ad740db706b64f9f2a69ea7ff83ae2c42b77db33f1a096783a08ad809ec8efcdf38efce37459a59fcf66862e459c92cfa5ba77a15040e30c566a5b655c2d0644686dd0961441be97c1d9d2495589f8053008feea4c32c70d6d02bb4084fbad64a187fddf41763630660842230ec0931112008fc75d35398a6f212ea41af4186e65093883112a1a0e1b78dae6362e76c918c4fc3c2efdc998f411eb1c9eb32d57e7e145a8c5f5415a1cfc2df6d23f33bf214d475c00c568cafb4f1c5f98eadf475ab15ae7e6b373af4e76d2ac9dd8ba1c045f67c992c53f139eb609d336c95a08b98e4cb94e3d9155198819e05fb44c64cbcaa9c54c96b8265837e19b0e9367db03ab108d5fdae9a0e3351b5576632602f052bcbe7c395848ad829ca3bbd6a1457df679ee97650ace4641377be77ae773f75c18be2300a4213ef979bdc1fcd58c4eada674cfa763841a931ae0ec7a6f2ba138da3a8cbf25a0d2d3cad13a4bfa18bd75db8a0f0f82146cf22e57edf601ac19bdfd4335fa2d7d173a4d7b84899e0bb62fabb9240c3e9ff58ffb99f1025280e0cb8ff8c037ac340fe723b82eadb30c2993f09864b1b8f2323266ddd76871d8b9baac4f2d5c93b4b023e30baab5aa0a37a08158cdab7e7cf03c1268aff4433b52e15e660bfe976aa4901dd5bd3b265c2620636f82af088db79716f37b0082e858462a5cc66c7315e281a8856850e8360cea952bc1fbd4d8258c07989b95fee8e8ade7d2e77f98e84f2b458c845a2203bd77016ea475fd0b731130d2a9064731ee0d55cd95b1590be0d691b948b871fd3f0375d002650e44543cb6d248f8001861fab788711aa66ddaf42725e4b362a4739408b989e165919712f58c084789883894567747a7d86413595e98569961f5ca96e15e4c526b139bc4970d3677a1a265181b2bec00b38ad328fb429cbe3d437b7a266bc270e36a97424bbb5f752459836b219b2eedafb295ff224b0ff619f65e08ea7dd7e5e838624116d89b7a840f86355aa9682f0ba00bdf301d051c2ee572859992a515571cdc86ef219197b0fd1ab69088e85312badeeb8cdaa871426be3611195cfb8b719871e74e4865f49703b154b19d881a0e7061081b4ab0d452438c063d40243f72e5b2b48a9b1541e2110cc1e40161d8c1c4519f50d04859c349ab20cee11aa7aeb73f0db40bdc5a83605f7ed811c04d412b58a1733f663e42756fb5d4f64e76e2ea4c24c705bd16ee88f6b0700eaff67e30d8e82463af66c81ba69eeac5883bf89e1fd75dfdc83ecb02e14f3f18a4d7564729b784d5349886aab9b6de2754ae8b213d6e6a38e1198179bcf766f603f885b58f6efa521857ea4660d693ca67f9a3a88d53c6e3521581e88bd4b9af3aeb52fa5b54a7549677a9c968ca0e746d90c40ce70b46f061fb49ca944da8a38dbc6a7107c67f44cee5ca585f1f4180810dcb302c42473a63046e4ecab81c93a3859104216bfd6b5e167a39d6a42702f9ab1686e4f8acc1d54c7da4217e2126fd85b4c01cb34e9354ab096e3726e4693ff695633b4af3160b74effd74655b385e07e3a28077a7acfd40879bab09295272bf0dba4e01f41c8b5a8c7125fcb961160b42bf0528bb0ae5f9d58ecbcffa3be9c8a40e2156ebfa6b9757f6fa72031de7203d2e4f50d70149936a8f5d0d1395a6118dd62d320437f51fc82e7f526c660d804ba2d1e16d74a03e945cc4348eaeed10e5fd3363fa7fef10003111e4dcbd66a9a9109171a2509d9bcdd6ea7de78f72e6424e958315216299f77271f005f53e831f32b67fbd292da0796f17ef1e8b6cfb89855066ef3909fe4d2d5b10ad3a85f97598c52a1bb845bccd6a16901e39f7e5572b8f819384dbcb4dbd03f86e0550c281e5d5f62bcfde8a2e903d96e91ecbf140d10119df6f9c90d1ad0865631d231cc0120571ba89944fe6b6b70efcab2fad3cf7d34d30bf21bb30dfba88c178953a3cc8186b6aa995461b5c8f67f8cd5b05d09b9257c3437bc70717ce19aad1166539c7b6a1e9dd0830413dbae2d18d650ffc7fcddbb9c720a9e56dbe7e60f24a52b32e1e11bf6bc056deacd4ca568b2c99cdee75e7b52f5f1fa9e32574a6392eb483d953f3525142f024042af70f7fbcc739836661bbddf03d4d51402f6583c0d5029f62fdd4813a791afa79ddaeea09a77c7f4969650aaf642eb8382c9932b2a674e9d7470387ae234496f31e8165631ca0ac859ce921906dac04418b96a7948a5103f5f1fcb29e1a05b91ffd4000108e50456774cd1312396399f0829fbd73bfae127017bfe634fac3a189c0c1eea788ea1c4d1228d7b30a8456a23f6b94d5c796c8b2ac44fd66405eb4303866047dc80315ca884b94738e69b56a4e60391f6d088c7db22eeb9f8f72856c114290e6b0c4f8e5b18fc30e2771143c6d5a9e0993199b833b9090acb85baebe84c2b01b7b523dd9b9d11629d6dade3dbfc3f8d503f866a1a16b80d3dfd02bd369d83df96037171078380ea4e096bb9f418ee870eddceefafcf5dd2b4d977b80745fa22408c766725cd81cb78ebd7c65d8d7dab5e22e969b2050a0426586c95cc1f5913057afde09b263beccdb5ddf02d33d96a505306fc4e6c0c990cc8ab0af0302ba6ea16b8983b83699e718783873c6ea6d531dad43a73015a6dfb4a24713f30eceae1ffd11dca390ff963799d5803e29548bf92fb2387b8e6b814e87beba3d35c977bd86a4412cbaf4264b4e5a8c2b61236f063a99155c8479d69966b0c2cd03eb65da9ee874da027978ab11f3dda741347204a3437be8faae64cd502035ae7fef17a0255c50abd4ee0ae69ea265ec29ba41c1bfa8f4d4f0e17e23fc01929aee2c8365c58817f563214658498d15ae500506f5665a79cee55a3b030c253e2b76fcd4d737d9d80e4e7a672c75fd77ef664e9a9d208595d042aaccd7a0a7d30161016df8f07f4724f368b52e2fb6f228ab8438322f185f6f5eb1e50a2f3fb3634a811644ee05043cfdecc6893929f69e6c128c6a1f91b5380cca693ce9f69985f64d2ddcbe0ae5ed906a9015a20f62d8551f06775771868313abda96b93e1182af46e2e4f07bd48411ae14e02e6a1bfcc4c4bb9d830c34b89561e4f7342139e31f3a5237857bf318545dafcfe15376cf154cf771f9f795159aac000734a07875902004b346731334b3d22eb651d95b9f017b41efda8984bf982bcab9b0a39ef7dca65293fe03b400e341c5011e3103238c6ee36f2026bf4f8932299f1bc599a7d1f0d1c987daf099951b8fc9f910db4383512326d7ca9f957c551a515bcd450ec8493b90dd1f2be02ca19d603257d00b4333d0c21f59578dd5709900e631b41299af451decc4e91c30a682128f87063bc7d327d7cf5cbaf5d92153215460aa639012177eb8a1cee1b45ea5667259c8fe2ae691beb6d3d64302c4dbbaddabf9c0c97051224ce144b3a8f4698ff2a06373b576912d27f2d2fef3998374b5353a4391ccb9da96bf3b9d7060c198fa03ae2fcaf29421f798835901320e907dfdf862a23d09feec95e30404c6d72d5991aa8b60191da24d1eef85f027245b86b9815367d7b8553b674601d107a49d151bf476ca5e2df98bfb426a65a039fd2f9f8da1f597cacd1314cbdcb427866b5bcc77d0cfc439a274b94d19bcc9d9589caabcf8cb3b83cc7ffa5b30fce2fd02e4220b4e94fe58cc85d373b0977fff078526a67df6a39a96a94538b4154c9ad2dc6e7dac70f8e6e242d8dd3415eefef5119c2e14beffe6f0aeee43fd27a9bdedb39aa115826ca6ffd5ecd8ce8b0c1a913b9503a9b23fe2c791f9cf971c06e14781addf5f508dc990b0681ea6152cf49e8b2df37572b3e35a8a531104c5825f3ce969d294c5f8debd1fceba768ebe99cb8b8f5013c4a831e3b13d6dd0c4e43062f2bbd3d282bd244ae84b044f72fe49c6e40a7a65049caacd0f9d3cb651b1dbaa64c53fd4c23e06bd56195803256f9dcbdd7b8b50fc29341e4aca5f5db6d87c88ba81f2a791a54ab449ef19a754b01fb58eac0055eb54a6ed77bce09850a5631f3ef0907aa8246e614b0471a1e022157b8e935f3336c1b863a65fc80213af554404f80448191e608e79a81dc13e574f9412621cde8728947e1a23ef9855a79b4d14e72e510af1c77bb00fbd18528d4244b675dd52726d6dd57c82220623dc655fb5319080264afca266177c0d8701137332a79447ad628d4479d8cf64adcd3baac16affc0d1e04dfd23878f46d3bfc010ab50b5a02beee42f7427f3f6dd85269eb92f82d14f96079ecb02b34874ce7241ab5a67e9daf2ade1354221727c67d339a04aa0d126d88cdc9c71408fa54acb145d192215da8ee22b0cadbf5b92933abf559c5a014e7620c6c4f490822808f72ca5870b2e97fbc823bcd020dd1046c677cd26b1c5233d4d5cea039d13d6e2be82f03846f9d6e5f9539ee7a15818d3b797c50f7bf6e275972eb5cf3d17a236da776ecc43c5e040fdeeea9c48aea6a2584c6ee9e585dfa6943cfe1fe0cd1fb285df4637f809282d72e52d60398ad5840d563cceda3002ef53307c0e0f7f76f530577d156175ff400e0c29208e07e7e69b07f71429ec4d6ff19966cf6661ae46797c4d5898b3e3023077abeb06049d70b3d0badc74d27e0472281aa502270f95ccaca7949037f2c8089478f157ec4df5539efe9c314a30aeba1a5322528406168049a94fbd2e58772692975512190549f54a34bdaca1470f0f9d176a54f4dfb5b687763d204aead2092cc23777c4f500fcf22e4c0f7e731e92469065a7c1d45c245e44c220b336f68904898eba1d0106b30d42ce80130b8046008fd05218bbbfa4677904ab18a15c70d86135048b8bd5b059fab7cad89c492594d1c9a96f51ab67eb618857fe1e18d4e5910283db243d5ec10e41249569a25325f49710d377c85189a042af5aa6585a532dd1787d0335683b8dd492b312ceb67aa5905caf9142b5ecdb24266128e7cdfbb6b44ee312765938847a0db6ec3f0afe87cdd90f346519ad74ef147b2ddf1ad11d3dacd49aed48c79889658cdc07c77715924461cd05943fb0d7eda4c0bd5183e182ee3328c54c1cfd8897cf1a4242ccb40927410c3c9b36800e3051daffbc24728cfc98492f80051d57843fd81dc7e53a4ac5ecfbbf8ca8a45cffd2811098c1ef3619112a54f5e77360d773fa0e878dce251ec34abd02d675e1d6018a14680a4c4379e77b49cae1b6eeab8632bcd239560b8cbcf59eb8b4acf82c85cf31c88ae1d3db7d818157cc6b9aa148f9a244c2c69d38c61ae6b3d7783772cbbe9b593b3df180719f04d07f00b51f3a67a27fe78091575174aab60055c20a11c578871077d7f961eb27a85f2dc09af1c4fec064233abeef221b11491c6c79269687b9ee0de0cf065806c73f95359f80e59713106e784d76bbe2e4a8199658619c20618b681c2bbedab5201dfd2e3711f66db6b8cad99d7ed93f9af5eed511a9608d2dcb61745fb23e2351f02e0e0e2549a6f2748faba82f4a4da59775c98aa8e37a9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
