<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39c4f7504a0aa45f96ae65dfaac5d214cddc51793c3e0d78ef6c3f9bc3933f70ef3af6b04fc59428180b109d3110d2e0502063347b25f3f101c959fac5f3a2fe0fa3b8b446e2e2bfa54de629b87c9f31709d266c22fbad18c77c9edca7576fa410aaa202d8756aa1382c77cee1aa4e19b60ad946ccc913b8cfb87368a435e33c19fcbc09fb2955ca680a524877eeb2626bfb3f2e39049afec745932be65bf40f2306d9f5cc3357959f66cf8f19c032c292bbaf6658bb2d54c584f7fd6460f7ec885ac66e668dd0209abf5979a41f9a611f589760202420eb6969159c64497e7d58254679fb766dce2f7e7e915cc2aec564f20f0d831fba6d97a2c7b2fafb8380466c8eca00403ae06adecd03042b84b17a8b7fa88f9054e89374316025977aa5404716e56351b770cd8554345b208ebf5b00a34f45eff0193cb2ff17c244bb0ebedf066b73e8c1539298250031654045c96fd4bd83d26b8950c0be66389abbff76099b1fe50cfaf246c9e323c9b333e748af1dd00f568b8601f6b8dff7c8ed95ee38f89b7450b2bb0545faf2558455cb6006bcda487b129e39f499598f225fdc637f1c0267853e7ab9c8e3640b502fc96fa75387daf32469556f9487bc6b681a98d35b6001f2c0537a05e98a2ac2881170352078a29fe77c7d90ee5910ffc1d7cbd31ce1b9978622b4aa220186448f34a76fb0aacf63e528862511d73b67691b44e3353f91a56b09b8132b1891c79eb3576a937b8181fc8a389976353c2c3f567da03838783b8c130b098fa55b343b2aec056d3f28bd11bbcb5c028ab777ab1fa81dec5201b00849505c190cea74ebf401c96e0e9e277ff9ff51eb47a5aa5f7f5ed5a6367dad6a59176e02fabbcb0ae49ee04006f65ab6d50a3d131b503184245b8a0d77037353271126fc94b557ebb427a231ca9219352b7e238649d33f418d264cacb50a31b021fec59a1d64c75a345c0cfce3721842724f274d5cd71b38c93439da3f8ffa52c909e5a5990e4997896554c2bdd79d5d727917f29c77caa0104642349512b5d30746b42438212c9de7c19075842a74861defc9614a06ea83919411b0daee63867d81ba5989b8b94b3a5830898f0d54def48b1d2d2d8e49692fdf653123a9544a6f4ba76c1751c90362d6b8ee01e28f6dff5deb305b0661c28da112ae9ec73853619eb7ceda3437bcae39fc741d4cbe74d32f6580d184aa8c3d91748dcf3f10d975bf4cfb5ed605d8eb5f78053c956d4c1be67e843eb4b1143a537676b889fa4165ebe82774324a91f2f9923dc65e6356debf219809de636034f238174a5f7d67662b1ea5398412d34811c29c8b4533b9870b860bcd1431aafd2fd63013636ad6c4f02dc89b6dc773fed0b2f911de6a175f352697fe006b895015f6979ea559caff6fd70405711a57c757a3fabecc9a1be6070f537e33cf49c8b6fffee5c940a8c1d819cff9dcce53811bbaae6c6ab21415ad58ed41a8666c047a087ec4a64682bb21889a4f564b974188d8856ebb36de4486bad245c6845622bb496d751b7522b02ab48f062c8153be9a1fbf5f09809987ce81195ae47b4b0dec7eac358bccd4921fe20bf897416be00b7af4eb1d88cd164e56914245267b38e3b0c974c88f4f6f3328cf11b9529f74ceb6225548d1b5dbf09d785eda3b925e48927780fcbe9dc40ebff4c160be08298822d8a1a15e1863802f5fd0f4c42d2929fcd4c2c2ccbeb5e758f542159a1965b48d93d319470d894d7f22fa7bc4d1629e95b606191855a655d6f7edd65513b6fc09d690383b53295e7f9ce31bc38e8f378a6e083ac9c4ba88ba8789e1c84b30e59ab44501dc8874b4ead4eeed858f6bc5e3fc492da79b7fc30af5f507b3dc684c45b279b9d1e017de97456a4c629c74d5bf79b44b83951cef4a4965768bddd514bb95327b3f3031143a8ee22132670609e0a8e7cebba9fe54d362e2d02840fd3dd56d7931397879ec5e3ed3247b24e58a2340074ff20ffb2e4c8b22356fbc750b4d6ab04824460bc8f28f51141964acc82a0da6431310f846af6cc624a607ab224727ac6fc6cb7de6608b0253657e1a4109845ee139bc0bc7550f53fbb1ce081d084f6d0c91756b191ba4f503cbb185ed34a638bb3d3322c4dd5d6590fa6b517b4b5b68c7ae4579ed4e6fd274b04392730dc3dac0dc1cd412f3156447d93fcc8f820b0d4efdd433a0e25c4674616ac8233419f7fe25c1ee6fefe755cf45862870cb404b8079fba6b7c6c3dc6d99f4e16f50b6cd6d18b2f5b4c4770d9bd9bbd5bb889005bf45d3c12a56a3c2dbf2266bf836abc781e396b15072d86231ec46659de559e18a8f4c8d37abd6408ab4f1b597f20a28dd827a5bd3169bb36ebc4f6e41aad280626a89b397b325f6f1cccb89e0e8b21ffe950457bcb967e18f839ba97bc6381a1849441b53ff2d23a70cd2c896414d2f7e6381f1c5464a963010a7b7fc9a6ee22ea9beb15fdb213b19517201076963244f37ae1827e837cc395a2f5637f518dab516cecd20e440d9aa98b65abb1e5e7aa221871ac82f161c4a7c3d6b1243b8b06ed6bbf02042362f668fab594763d072065b82004e004632fad35ed06ae41324360bbfb714dccdb6c8a8b5633a945eedc2f36c177c119446e9778dc3750a4da0f73d0daf520b38cac4a5d6ce8536b8b79cd81acad641b15448f118ea4b58b97a4e3255adb611489af279837eebd67dcf30c3a0224f559e9450768d14e01487e908f4d5f510d5f55c238d1def5eda61c15f2980ee3f19e1f88c59c03a5cf2ab147bb700c6050be3f72c28e0eb94a1977a54d3f4ecb75a6f2b278821cf747a9d18a4c160e2a6ef601575be5172ce2ca1c46d999a1892a2bd18e5ae7a7e0e2a5ced73ed33d33393fbf496f02cc9ea87db2d7c5e912ab9d51ccaa31531a8ef311a86c9577f8ee80b79a2431bfd9345bd9b0dc0839570e0063a010378451e734ca1e39bf026d67426567a4ba13d29e9f3fb2b49987b53c650aa5a5d2c4afd385a563569cbf1f75e35a34145cad1be45e9724a6e4d89003035b00fcde27d5c6077f526994baf5ce81efd56464def7bfdf7e48b43d209c16440e20f5d5e36df01d181fba6168ae3ce2cf17183cbe6340db1c16a360b5b33f99d1cdb41f1179bc6bc9340039e61ae060a700aff38d889f0f5da807c8d2aee1c62fd4287eac02e993cc9dd62d626492049f985fcf9f61eac9363c24587a77bb678b31fc82776e1cb0dcdda60a9397f38a4e445ede02f16dff9b0ff58690dec7836f42dab219d063c64e709c6b5557e78c4dd8abc7febb86fd915c12114fccefde1a6b95185ea7495a795dbc5b93b57fb0b871f423e34f7477b1c927803e39e2d99acfeeda438ff0765c7c932ddca58506d30985c6b3b8457b791e4671ac7af8c07342375077459f8c5ff096fe515ec47b1d333943a41ea59354ca3d25bdbe6c0b280eee7fc891b554902a6acf1f463855d32ccc1fa5ec8aa67b2f5c1a7cc56fe3cfa36cb8b33f1f295bfe17e62be48803fab270379734ab5cf7064ad934c59514e6e46713ac4ee2dc68882146f83241ea44e45625a0c52665b847ab01b730f9b0f9a7293134a00abf5da3a86a4168116df3237d4d1ad83c0c946204026bdefe551ee2d35d120e86d736499eb986f625b707416b305ae098362e98bc10601279c65a45722ad898d4c872758848d9f3851bb2f739aebcb663909925f38039ec0c487bec5f61ce02338a99a058653ddb060f23dbb88d9e5b7100c0255332cbad43ae12110867fd90862e174d4e1a74bd4450d25c7222f1c4935244400ac0cd1b69313115538ee6fd70243e32f3229bdffcfbb2b5f7459578f301d7be6ca163bca8b618065c00c09ae562589968dba32b9dc3a038aaf6c08bd6539177084051a840840f02b70b2b5627644fc0a1c3eeb28ad9826be3ce42db965d7bfaf4e26cca2618a1f8005052b6e2b0a3bf3bdc50f54d31ba798164fd41c0432d0d3ed896f43ed48d162e351bdea6cde3957dac976ed1b794f7ce08154e7dba2c2298ef36f84ebca647477326d136421ee3f35f5282d5387976af0ee681d3ebe7f83194e76961f07dc766372f145e90b237c6fc9f16fb06933c1d3a199753f7f0997b8c8d72dded02dc28fa25e962aa9fed4886ec533d117b8bb39fff743906455f4ca71d70887a469c30dee3852950b769e3171471e73c81554f73de54f6bb58bc438be0c523a9a12951f7fc55b46b6187ec59bcd9510700011058698667e4f7b547fdf88d1e7e8a430616f023057d15a4cb67d34f30bb8d571a525b6e905181a50196e98a674a4ec8d147975d91ba1ebccea668ff252096313ce7fa2d8aafe536c25d12b53585c28d719104684e02e6928d3373346d365b5bb342e9bd07e790f6ad90150d43467eb092ef9058149e50d8ac1bb221f9815b2a48de9b62a4d01fd03c06da5bc9391acc2e25ac90395a915f06016dd22f619fb5959ddf492b5c3781b3e7d48d9f2d677ce556ddeb76d3247b1618313967ab667c2658cfe6672aeb98f5936a8a0ae77cf2500e7183774d5cad48d6517aaee40cc8574d53864bfa4f094fb32e588843a52969b8d25f5abc583b421051facb15f2d303fba83ef6c9c36bc075c6d21364b42d25da6a5ab6368f0b60ccdb507f86987601b2c0ba3ed5bbf79feaac10a55f83faf0ca2f6b3854162d1946600354d66db72df24d39654c1fa06c39bc950e8ce36cdc3c736449181bb65067ef00dd4f1df60b99a016a54843461585186d838f1417057d96a48b28840175ab5a9633d59140015da022983c46b2cc4141ae1f0fb10c8452b98d272bd249031c8ecfbbb373fcb613c645cf2b78e46a03e069523c0c5b0d7559ae429f0947e2df220681cc9245b0a56ec71b873cfddc12c814f433b31ba3de6ad180096c07e14687639d681acacf4c384fe0e638892b425ced01f13e56953dea3ca6ebdb82b46d6381fda01b0a040ce46e83f9cd5744d29c1f4ba7bdbedba06b9b8c68a446f45fb0d5b2692a43fb4678782889d4f7973d1bffa8bfef17c12b11af9bab6707897c8a34aaef16b00eebe07e4ef82de07f44518c264206bc0ebd52c3d09a074e2dda1eb7de667649e8ed6cf36d3d1c9501ac741a26210bd49f8f410cee9ef84bd0909d53546a5b6435c9ec717845045fe453c440e1f928e6e315762b7d741438d2e7113e9825c67c82d15305145237b58b0805eaccdd692475b98e448e5f4a894b5775bef2bdd5747e94cb60d78a35dc16a16d72b035ea78fe307a2e76e62797cb9b1341186ef1e6225df17f06f55ea2c16a55a7868fd59a7b3a96ba9f2657b3efe0935cbc93ceaaff03e1eb4572da020e53f8d49fd2585077f9a1ef36a31bdbd19dd158d63ddda3dbc7ea15daf6c40538270b0f384b0808542fc807f4f0f13a2ac2cbd863c1c86814a0a3e0a20f5029c32e84b42695711b4aed690eb384d12b6976750b24c0cd0924bf5d0fabe5756f4259b302114470ff3a792e222beed5096bf8b2902e8adb9ec5149b26dd0454e60a19bf89b09c2b197049ad527087874c0e48e0298d6820cbf9787e76f72c70d654d1e817dd53e6f256933e3629e8b422f959dabe4186f3719324703cdc65bf28b15de3eb6bd16e539d1c59ecf4e071859e9508036cc0464f2566ec2c911e6b7e8f1e584a6903ba2a51b6411a8f0a359d15c7c209e76b496cd0f82ed047d23aab8b63c4f9ff1cec33abddd131ee036d3c5d4e029c1a9d5158d69f000832ac2ad14348ac712503a0fc6f51f14afa0bef8958145fb9cc0f49b3972b4280a8ec38021b9eb4e6bfe7996b397a41091a6a60ac7d1a6e5a3fd8a211bac8a5108fdf3f0d300f14b732c2dab21b97304b67d70dce3811a34b39324a11f46ab654637d02e6afa158d8a84ed1b1ba13a6c6f8bb79558d4bd3f831bc2aa62af770187ab7ea24a188bd3d5e7f2a829d37452f09b984524d85e3579b52859c58e98468c9bf6c79e824654e3e747a08b9cacf5d71eb5ee731104058ab9e4b5a3b8f9858323ee636c9eb9be3bad5d5a449261f1657048effa858bfc7d973ad4c3d51599b3d3d5897ef07680055a57b8fe15d098b01815e1d20d665765343db035f453f19e6dbce12d99531416a0aea1eb41eb3bbc764755fe2197c08312fba31c907af534780f15618f9d6fd9c32795a6bd3bca753bdd697fb7a5d10a1e9a31487819a35917ca9f135c1de99c70378abf5957a35223496fc76996d6ec921a67d5384c3248a1f7a4ee4b6d32cdbeaa834ae250c75937f220343801589ef55eb28d5c47e161513db23b51d5c9fa11cf1a1dd10bc086e4570e6c10a805fbfde87db27fd3e18ee20dbfc63b3713adc851848e44a1572deddfefb04a99a93854e86bf6e2934701e83696b082f6fd8e6efe936aed0e520017ac1e3482c2110172ed3696805ca30dfd09b51286bb1fdac2abe78bef599efe44a5f59ee93e0be05c9f7f6531092a35ad7dffa7ac11d01baf4c4409b8a9ebcd66be8251fa4f7dfc8c8c60ee7229b31448d90b54bd0df5f88e5a9c6966ea6d63cdf78388d4fac33f0242016b52c5cd87baf73473ff0001593abf104b2fb4258d7e7a1275de8fa1705b7c2d1bded64c7f1ea5a683524c907dbb6c5900aca54013180c8ee1e95c874357f40ab1c8129549d8f66aa34442a91f4a9556433e42c4b12137041e3d4b4368eb5b9e72698daa13e80353723bb6d853a7a25ea5ed287cca9e06d694f4061eb722303183a1771c38834bef6294edb89e4bd9fb3a8600b39f41f6cc5d7f6543543ffad8a58e960b10a3158065bfa5d8e18e7aa7f85d1855f27e3d7636ca4a0fff4096385707dc29790f2e1bba2ee6552f75478f580bb8b5abb14203d4c37ab8aa5854a5cb388b2ca0cb0ce245965f713b88d5becd0f34cd7bbc50ab8a360bedc6c8cc79886b4abc2aa3fcc07b3203be098727c664b5365f33b13ae04ec8df6755a3911b07db177c40e098928927b82d64c63a26ac6b0c3fcf9738313a14b55b97b6164a281de2d5e0a713c88d1375775d1f6e0a167200266089bd25e9541b0a81bf32d76601093af5087811d15f063e07eff6296d30dd12ce2a25bf0402d2cefe3e31632201ce4ae7d09dbf9613bc1700c40c37071b6089d2e3ab6d705db2b0e3a8e88589b29033a8dab0d6d12723803679732903b8fb0f6532ab6b627ed27405fe543394b2d03d15b9acebfe2e4c7acde316e4b294121e2c47810e47c58f3dcf857cd0c6fc9e0aa32f03a6cfdd87041e15fed94535c7fede08731d6b3e2f87d17e2962238fda74f84c242c461347bea5174f60d3a25aac3678a5913491e661d9345057894a918dabf189b7ba7e2c044ad749b1cd0b4a7913e5d430ed0d25208c5427f0a813521dc42c7e0446de872c68400c6e11ee296b9def4cbe23996301e84d9cb86c2c5145f2a1ead4015f248e8990b6bc3e0f1038b3be7bd79655cd00fb6cb2dee86754d84e417eb743644aa9ed57a70fbdc424f617bff2de7d585b7a3568365352da988ca6659e0152c8e102b357715c4e733ce0b31649ae9d4a2994066a4ca50538ceb2ef068ebb08d7ca8d16e69bc7024f6d687c48a26bfaf82b7866f968f7ca727ba8bd1dba57b00ce4e21c9b3e71c4e37a156642eeb85a02ff6cf3128ee8d89bea8abc32ce603c260b73bb44868405b60cf13d3b78ece76079e6e5af77ae946fd8a20f0deed5df5ff147a298b97f57eca0077e0532c4303c0cf3dde5e2ebecc916f0f9bbd32724f8504326eec9e839c737d61a18259e42d6751e61e24cf565c7c85fbd8e5cce452a12879563cc2269c2f253f1800c10cbb5fb352930bb1c84c409b03a9b7c73aa58fafd5fd9a65e6b34ec16f3dad5f26501dc2efcf9e725bf207a5959240addc0b3ee105c6984ef6ea4fc0617723598610b358a52ba6d845b368789d8302556af6a65e5f63989129ac57a11f4dd233f73906fbfe06e33f4b53141f4206e551f0e75c15a2cf544d1d274272d4d1eac52fce8f6b467fcc1cb7df052a02288b7f0fbafc0f22d5cade44163a9b64ce77c1c7cece9686adbb5896bb99a4a8374d4deb499cd5be65d646a816cd3fdf7d4b4f0d6dd812879929c33cc700469e8554fad016275fd4dd0b170c75a18dfc7943f7817e27748659adf1f27e1d52a925bb182a271063c1da6359d77d7c174b68de6ae3af1b6b45c92360170a4e6bdb4170994c1311791c9604d5ab35184e98d85ec1577c76d5ad9017ab15409dfa5944ef7bde9ba5a6f15f846a347d099026c88e4358d19644f95032acef77df845f7f7b9357970bc77a7b84391e8bcc0e294d8c4466fd902defde019393b47c3a46351704f6e0a6fd4d86842ef299bbed2637a51ac5d65013ad01cecf7f44fe85e3a11263434e98b7fd703c5da2f28565d624127e80fd2d1410e8a6015e54998077a34bd48a22e5086ff839aaba1ab0d5ab0410144e162364ef5edac32baaa3d5b031fcf5f9f00ea6923928b35f1c7abfa8be2cbe8403d390080a4893e65ece467137c1fa91ed0597e67920c6fc4288e3a57519553a1cab6188d7a2ea16a4d1f938f353d27434ba25a8781ba4b656e0c156f0c658519cae775d993f8035c00b17f04edfc795ddcde3d4cec67958dd7afcb77234eeccef520a67a131afdd063a8da595df2ddd166182b787460e0898ebb9d9188dfc28cca7a864134fee963e63f497c0b079a205f781ac7fd515b642ebea3a3709617b316370e2ee9dc73990bb7fbe728fbab074c80afff9a8637cbc84d217bd7d0d2392856a2eed1e99e02bc57321d2b2d11adeaea3e6edb39488cb4f06a11880b99c4f38627da05f0b0e6234d974c09f9a25f3f31bd8735780e84822b672e02dc0d1c035dfa12ef71ed25115456fc19271b18465ebefc3fdab11f4fe8fd298a51cae2229be42cd6bedbbea913cb9b44d26a3ed188ec6b3d0cb8dc6c77a2a7f60e53b69575eba1e5a3bf31b63f62bf9c96ae0f041137491415de51eb7767b051fe3063a9f434938e9ebb5461ba07bf7f39ff06876599e69e1d47559baac59d5d308be9dd9608de36ad30369c7a0aebf5e6b7df5f5f8a718bb10c96e912e76cc14e2c84a58e67b67b7dbd4e3ecc6992445856b63a1f9ed884addf41f558b86e24e711dcbbd925b9d76ca8db501e030adc509bde56782bf96951c2495ea541e273d2ef6fcee9f8563833b206e2f0c7bc8fa07cf548300f8e8673ac7a5173cebb046ab28b13acae2639126577d2215e4e02fe8a3324b1abd6ba7312c2fc74e98797d26445fd84138f8733547295b6f26cf3a0f7b0809c457b2dd62786841c3f8a623ecd2b849cd09147b6782e0b09b72bd809db24c6850c71333715eb6f11b6b0057c50c7761bad518f998e4bfd9931198838a765abc6defcd4782b8fa56b9ad78bbbd8234972e8511981b74d17c4781af102d91ece952ac17ed49ec6bdd20476c9ac4789a5f50dc71bc4d1f14e60fe5bb7f410f38c3dea508560726c516f2bbdcabc171f167dac99e9f4c0c0281ecec16cb0e035cc2acbc1bed480fbf7ad7b834d5839a8b3fed17aa878455958dbff42116fa1ccd3f13c4607e1aebe940b9fef86b56666ee6b036847fa99ac81c3c89b9bb0297b48071677c5676fe0eae71880ea95507a3825d3ff1ef077bab73c13cc661a90708907258e4e7c627fed28a6a00589dd5878a1879d8c790c7a618f6e6d8f79430d50313410e6465bb28f418d493fda5151ee7e82abbf8c9690ebc2eeb6e3ca33f2c713d47d8a6bb01df5c314e293b7f24f320d1dd8f550f2d5135c090e15611bd892ab102693211ee706301c9c866bd84aff45d9977abcc18ee2ea708dc51470b4c5b497cfaa4563fd017f5922cbf0aa79f44202d0898abef4a241b390036a90d7fd0989f0766afb7ac5118e70a5c5cbdbdb9cd4453cb5da51f4b31786159f75f1f6171c243560f0235a4d139967d230560fd8b2b8efb78d80e82713fde9c323d3a02691567709a83a9f0b0e3c4401da8ee2873e762417dbf247e6f2bdb311e80aa7e6554c797c446766953f6849667d8bddcdd8691ec1e0041d7065caf9dd79884f9f783ce5aa28b40cb87e297e6f966542a609649a7667d0a4223e868eac609df1cdc670bc883899aa307bfe7cd51ba6e620d73c111a193cef4e67ae14d4a1a1aaeb8d1712be8dcb0227478b9eb47e687a401c347d193c3e8423506bc7094a04d4200f50d4128b3dfb6163d3604c92e4c31dec26a2e84ca9e909b237d302ecaa1ee3a930c1be07438fd20b6a79baafdbba6175d044681e3f4bb40cdd0d208a88c87bf049094214899abf9e3bfd71e8fb867d694acaa480d0c183a3f5b70e8e7fde2dcc179b76e2b659b5ba7f77ae46ae59ab72cc5d5352e0917dbb075c18aff816c3f329dbbb70d1df384c0dafb0f63406e1673cc26cdb4970811a06952695215950697e0aa0ac7f1cc15ae1297215ddd05662db57b76cf82b9e15a8a209b3075379cc6774e3507c3a6a5f266d3d7fa653c23022e24e5e9c22135619c2b36bd8bdd93e6de03e0bca68fc6700f9d8780cfb867802db67cda7505aab9dec9b46eb67c133bcf1138f8e30662d8b7b700cace91fe7da76faf5085cfc8d785f5308504cd8cdcbc9f642ea81c242503740095bce19d0a2a1b17d2d3919d4442acd4d9caeeced8475b9043311de8710a19c22834f1f2a933ce8b808c5235affd33da9b4d7597d35d06135ee8135dc86ee4bfc51eb68bb0627e42bdcee3f6c8f97e2f2aee80dc44055eb93ee4b96c632fe97e4067b7d9ed6184c10e5436100f50830c2d12d0be75f6f05e51788a04ede4978ac9498ecce0288cf79a2d77f026282ee5c63b5ac1546619e16d9e898a9afa93f995c053411ce5a9e879722ed84c4b6521ffe7e3d40553da3043d48214ad11bc86d208249e5f4b59ae83b874a7d3696a665b8273c4055e9a3fef0163ebcc1e559469c086f7b95fb721aca5be9e9f1e462a3d88592bd2e56e9c8c8707b9571f447f3b67c3482b6a5b38709acffdbf302102c31418c8a74ed705e3b1cc6bc8392474b958b3914a30aef04bb36c6634f23e9ddca805c613b7faa79aefb094d673699576da0580c56dcadceba52eda2de421a8623cbccd8ace9355a40658a78fd572025749fad2013119b597a07e8c6e58c9b832adf5dea3f81881ff9e410a2fd553405b604d40ead09b9d20ce289c984bbbdf1761edab74726acaed77fa7ad643f38619313b53e165714ca68af461c8d5561268e19e1b166a06a0749d6a07dbcc2b63b89f325bbad34545ced99b47835b23e489b0363157b5e2706997745080e0a2e704ec17b385fbb3d947260d1bfacbf1abadc66e0819e5c49f06c8496d9ba334eadf867f1b96239dd00a34e3613a602aa21aa3919a68409af38778febf8e2a855a42a6dbd116f2d11af68ebb15ca1f863eac22a1f3a99fb4cf4c7b2fd6a562ee5be5909cc7d761f0d6abcb4784c7080e716220a0059c26880924b4b75f03af987acd6cada710558d46ce9d1819c3f332d770e5ca7b02189accae2f9cb61f203412c441f48b1bb90c45bae7deb143a7eff57f568088d5b256d117c8cfaf90ff24e46edc46103e1810d8691a349b5491a044024788076df95cc647e8e21db1ee10c3712cfa7fd71dbddbe96dc23b6112cff55801cd0e31afde966ff89747ca068b8e72cfcaaf08f40c5dc108bfa5a29925b213ae0afeec197cdc92b2c2308606d077c3cc57f82d9092875a53bce4fc00544bd387b8ebadde89219b3478eba0b456aa65b7d0e53da6667aab0efec07052fb4902874e43f5de5ae29e8feeecf63de586ce175e9c3a469e3986cdf696570c98a6a32074ca61d7944304af47d25ab1a2cdc3337d68face0a8743d74f9638f1cd160aa749ff00ee38b0c5815331b1a8d824f8e0036d26e60dda80e79cac4118f5a1b073ef5ab3c8ff6ae21c253892afc38c06fad540d3bc14b5d93e3f07e8849cd05c93fac80190fa3bd1efbd65e64f63fd8e7ef8ed29d6002ac2eb58ec25952411dbfc8d151ece31be52ae77de6a2c04c70103d78dc7b835750bb1d830b062cf57100771bc173df95cebdea101b27c90a7a67f133da5a82d33df49cb7aeeef8bf3149504714e0b28f863ee02f4c8e32f2b6d6f8ae3f6192d0ba4918059500c4b96ff3e71e7de6fe7824a73f626888ee31e7ff501222c43afb7584e7c352f917e97d333ccb1703d845553a0dcec0c4f21622874e5339b7e295f33e8143b7f79d5e3a61beba75ee117ea5b00e38795d45c3f12e831e05e891fc6eb776e85d3c397e72f42a5b87e8e89076a9d2f3393e4079c7bad4c16fdbe184dfbb027bd7a3e6e44e015ad14672effb7d4b8c009173c6a754eb7b0a1eeb4909276365f7bb40cef0d6a98e1028f336d5097ef0e33470eb4bb3e8ad4ac93133c44f5e3330e32a0c8bba235b9f3007a46901a5cdc16e1df5a14739019d83224df5bd9dce025136c5018c8ec1c91c5210d9b83e795c0d7dc38bce3acf145752ec712b868aecf5cd52843800ef959f58ece89ff2e4ece739f62a50c64c9a082796853fbed41b64096d881bd4155b5395a9bbeee5029cc5be37934e640d717f111cdf93dcfbb053ad26ff444c5f8fbe49f7f6b6287de9dcca7b2d4c6349d4ab59787ed805e56bcdc4592ed7486d611fd387fc1ee27fc7e231448528354feb19a544109a43d1917f867f016386c842c47db4b74cd89903d12db06440703bbada293423853f8e9ad5eaac1e9a7bf22f0b2f37d70192bfade2a39f2a962a4fabe27f7fd4387dba5ee1dac3c39625c221d91a0c098262330a0b5a6c602b68f3d70c4057f5513a70d099bae8aa6df4604d4378562dcf59537e229490463f290ca58924caacc80dda9cf8dc7d0615aad5cf0cf9f8e2a712189176490a6c0ff73083b20d7dfe8b27c5738f94fcad9422fd2fce052e031ca487cfc83e3aefe34262162249dd7eaa279f12a788d8770ce670188a4af8b2a390554deb03b90508e976dd406279ec5e1b1f7bbc44da2bac399be2151d8cd68b411046dd67e2a4c7eb85b017fc47d4b67434b3aee37a56f61329703d4daad9908082dcc94a19e15af672546961d822236ef48961bf0cce2645f3ccc81343fcfec9167920a2f559ccb3bf083da8087e7c4920995fd027c4b4d51223112991dfb2278f3dc29884f462428f5e25d2f9d8477a2ffe8412fa51403e43bb8e03f1fe7429d2e4935092d71e6a959f41956c59f804de15cf42e6e21f398874896b69ec09d24415ccf5896646a6e76e2e604fb2204a1685b87c199b59e8411132f38d111719acafed66d12a17b8bfcbaac80927379d3ac8f996405e96b42a44ef117b15ce453395381c12249d999f08e3214721c3ead2e78467ba916ba1716c0680b7e8d41bbb641f45adf0a527144ad399003424b0f49ce31423e1a1c3cdaad2f7f7b6e386bbdb2f08a4307aebd70f557e8ab1dd414d495492b297e01b6ff3eb7013d1923ff13f1a7988d4c62f6659fd4b9ea6fc71f97964b99b257d0ec5e2474ebd5a4c66109c6c93dd91f735980a46d766e8fc2c86453677b15eb539b51069ddf49d4734dcea084ca1a9b49850f6854ad41ab2dd58fb3d81473a3a2dec2c08f2c05eea912a2a1e74485726891a18c648a20f0052ae326a6262a79e566a4b9ff196aa3ee7c97f5bdbc76312970a33b0f2d3d936e355dacd829fbfeb0a1ce8c4620b782716c6f0a944d173ef50443505fe05dd976ea05bb9268c444a976d1e18a58d681c56c9fe7899329547589c00516d26cf7b108abdf65288fb71da47de65db47af3eabbaad0d82189674d3c5f7ef1f46eb794c4f258603ddf60d2d1f941d285b1adb603604358fb3084f46f0647b8f354ae8ee22bdf035b8ab2c21ecfbe4a4edf17741204721ff8f8ea731ff0926917d51389105b6e27aa4d1d1ce84a12ab9ebf36637a4276790d2756c0885691e39c81a4af0539d353e9ce279d3981ed212fa37d15dc843e0802924098c7ea204a41a347295faf92e12afe2cad67f8e7eb51176eb2beddb1ad9b4ab1d37ce6335bbfe661151e2b6c5fbc4c714c19bb2dda02eb5e7a55b9303473361ec377e292ec6d8192eac012c8baa722646edc1ff093eaebcb8a90fdb348e9a153c4237de8760b02bbef1199bc1b3d9504ea059d18dcc2fbb4b6be744d679e366a1e6cbebb90ac3d4de43d8baf2166f05c2a00c21a22d6dc841447c5430dbc92bc601794d2e0c3f1d13960c36ab78a6f2c1918b2e93eb813aed3040a46bd663c64720e9c7c62f8088c5719dc024259928818fb1d9ec6d37a52b2a292b12e24610a2d478cfc5e017463fa9471fe7eaf5aae54213653171ca0cec774081dc6eda1d7633bdbcdcb90ef73b822f494e9847fa6ffed8f55a7aab2764d70ae35e3bae1382708d99838a59814af9a3ceeb482114119e8c6c7700acd54b5138f3dda50983963369a260e30fb51a2240ba877c393e54ca8f2b55703c3981bb6969ba1e679a8fec9c48741df41d30f4dcef5694e3ff030149efc4e9b4a04ff1a2e62dee6380647dc2dc358456d6e6fc457a1bbde153fdeb3829cb3327a763da9e5e64f4378b10377a984966fff65e6c11c48be6550f8ae188123a694f7632e916c6a3ebb7831f9c6791dacd6618907b6a8de4045acce4ed417231d63f355accb78a8f2613b5472eb83a396ca588a4674484cf36e138eea6e79193edbb995ba0fa82f2916e5d158b7fb79a4eb6ac6944b7c8cbe61cae926bef9e4e9735bba51f720c192ccba1f4d1a356e03f85c59e436b563478f958809e2f9538bc2d0fbd17a8dc7c83fe86771d595ff10fa495b647bdb5f86098309c5d3473f1745ec13e7bff1f930a3eb62d639558d576b2d10c22cef1ef3b622817ffe5846b1346279190976960d285870ab6e208e058279ddc437b134e18568e77e099e5dadf1323f85d859463ab711db8b1896b21df5a0c87df2e0e2c0d6ba1df119d208208f790ec4d298bc2a497bc0dd73b98d8e86490b7b1deb4669610ec5df8a8501a188fa259c536a24ab0c277659d44880fcba98b8ad7b11842bdbc0d131e57c44b3da52bd52dd16045bfc7062f1d346c494e23bdbd303ab606fbafdaeef0844a72a3c9f08bae50efff5fdd0abca05b2702e820f5eae12bd3ee217feb8e4bad9ef8a8578533b20689db8250b123da6ffebacfa9717fa7434f926b1f5132868d0b50a13b41d61fb1a99656fe62607e549244085210a89988bf71188c9ad01ffb8a5e66cd64c126de6d6ea6ab56c9f22d7d9c14255bf94e297a76856f883e8e06f4db740ca13a21703654de8054aa49447511fafe17e35957311db2c90ba6e24710d8d846db306e995375f1f8df306ea4c9c5d4bb3f9f3cd16fac1fde5620edc898fe61e628be90a26df23c894e550b2000fb90b1b99d7f5e4b8782aabbd2a59365d58dee7438710ed6bf7481fdf824b4e323fea332784633aa25324ee25b7b4313943829a8f2b4c1429338198cc5db09e53d2efc97e5a24a36a072393ef9e3de5f4998e414de5085b5f167134eb71f57a8592ac7602b3cca84a3bc2ca58f1cdee38feeaf3ed9baddced927293d4e6a9449b3bd32148399367b527c095e2df6cad05dde6fbee40070103b9346bb1ee2a747302a4dd7e730cfdb1f62f9c6874ad5b7e2345540115f6f618b6b260f505fd1fd5ab6823a37001b7501ae4da1df78c4d72d53e68595a0da74d4441fc7336177dc8881a249774872fa82c1f63400783186e185b70a535862a4b1c008adc19aafeeec9d32fd8820537bff57ff31aa1f6a9b6b5e15feb71b4aa937e9e5ffe10d457c54d0bcb592ff57e04d1eccb5bbc36b750b9b0f45345dcf403de3987ed94220600668138fe8476aef5b38432f5ba7297770487a0c6eebb3173994300c3c9177bb200e2817fe3b175815380fad79b72d60ea0cbd8a3c8c1cbeea4cb98e6f0d38d05366e65da7f467886c4d889cb7deeea9d96ff2404aa16bc089e31474c65c75ce220738d747458124e09589c9196299c347ed73a8164724a7b968f912e00ed0540c400179108b65586f65153d82fe7590256e0c4b3f0ebbff582105d739f857dc3ae7afa3c3560ae57818afa7ec8c0d73aeae96e6349b76f3f334b1d184c396c92c7cd3b93d095b17652ce7e160bca0dee1a0bc363e27df3d2aa501f0838a3cf1d45f7da9457d52c7e176a2bcb6b1cecf1627561c87bbc34c559a2946b37a3d7915a9ceb404ebaa836c15d3cf10847ba47cde1400a5495ada49d3f960c5ce7544612bce00833bf094964dce25c9abab15b19d27f0febc34521b6e4f744401dbe23c2ef610f33dcb36deb4d8787997412e15ae452896a71af3f052a3cb7af61fb5ed535681092820d334afe77abc63cd514646ef2f6215acd830affba0000da5d190c47fe074775b7a567f0dbab47ae9ca4b8525b4c19f75600fc7ec1291ec1e0fad182a89c2b23d0c84ef05971b1883d745777ad1fe498108994ea516b23380f6832fba8fee2a339c1b5890dfaf9c1ef3e53b3e3fabd4d61d67593f11299c8fe4d49cf7ed8fef1cd7eb41f91e75e0971595d6a99a9edda3458f932a9436d7183bf7177c25103335d71dc9a1cef60a47e7da80e0ab7458355f238edebaf20d01f72272195962363dd78aac4f22f36623b5af9ad6a1e011390212b287e6e5161563a779e264f481ffbfa7678779229e5d342c465788e444968f49fbee5e81c20788ba3748200a1a541421150ec4940e74d379e52dbeddc82ac3818abf0261b1de82c136c62690f954a764d5aee63f5e298fdeb823ec2e171fc23e2e87ffe177904dad988e30c4be2bf9efb50cb76cc6e1dce3c26c1d823dcac825958c9b9d74dcbf77449edbc89339b24b54a023bc67b75a84254ae9073b62a61c2249a820f54c1c6bc65e57dba18106afe06b7be431f2d126d1c4e8a6624ef17c377afdbbe39f09b39235630bc58dda3cda6683f19d5a08767623695752926340666e7ee125e578ce8dee57afd194b5d403ed05d526472ee9860fda34e4087e64ced989929dcb1925079f481cbf8a28f76e6a82f28efd7565cfc0048eab938f4a48fd24879b188dad8740f2f4ffb4f80ad3c06da3c53543acd9938bb5793d93d162b3c55caeca8353bb19dd59c571b22a84dd1505476ca45fda3e31af0ae7d1e0931b1f28134005daf73a22f16a3464949552a2c59188d21777c9a79fb47811d4c1e63d22bd6537af6cc59dec49445df8d216518b8ad93972d126f062e1d54fb6c6b947de253414b81e7933601d03c6f2a586fb1124adc18d59adb1e2144f1fd8f64b897b8362c463a082720fa11ed602c81be7cbc5d57c11b79f9a651973b3e73ccf0ca323481b560b5d5516325d84390a6afe521811693c39fa0defafe8eafbaaf0aeb0b292e0f72213abf61dfeb7b4eedf4446308fd87bc81c153714c915ed4330c7ce3b5555dc95a8c9f0419a3bdb7e8f9208a6a2bec3162bf61d211379a345c149df374e56e221dc21654f5116039343da79fb95f7319ebdb4c5d04bde5f31fd9cb3bbb6eeefe5101352b776c3684a83c4c58fdd33b316a7638698eb4fb594cc1819d6650494d7b0e67fbc35fc2874bcce6a11313ec3277f683bbeb971e0af27232b9f1f718ce526f3b4f2a2c4d118206ff633b000521e35a486fe0dcdd47ad17c5b4f735eafbef3234d03486b2a7ffc6b2e492c80479bbd025962a74cc582a8e931c0354f3b5c44dfce12ff9f4ee84bfbda996f4a34404c2a5e33c8d8c847403a9012b91aee23836b1424e68b49ec3cb8e291f8afbe8412cd1927185e355f6b614c412404911c5b031818dca1ffe565ed68836e831220cff99eb14ff0775768191818cdf6f04e39c430ef9c66b9c0a5ad3456843d55870e8996e58934e1a3fbb9d3399511ba5e3b7dfbbc69d0040d92bb018af4edfb66feb5004e253de6f46f7c2aa8790db898610ff317d2d5e7d6aec7d578e4f599bccbe502d1dd12ff7c6cf64575a01bfdf0e24c3ef957783e3175e4b89e32097071f69c6e8efe0a9d0faa4ea170dc0729eca09c02f393019d88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
