<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5991144b2fcda624614387982de282fcbc2ed6d4e28774284eb11aa12f4a39e28b9387e4ca3200551a2e6e2e6b7a5b719b41a6c434e889306a9e7628931014e4b7ce02ae9bdae43a775fa64ed0b0d3846d8034cef8a3297154fd06714d6ce54933e8b7832f1bf78aebe3cbbca1d5049974b6818d9b1a3e26952d13730f6138b94411247ea9b2125323579bedb7214a070a645fe423df6eb5a902624ddf993f6681cf413b117df2c5ce3a4b276d878ac4f4bd550ae9cdd37faf5ad740bd36178ae9bc4f8e2b35726da86964f104c6af412c6772feff4b0f3a7c48a2e766248624500ce48a7e84a40a81f7c193bcf8520d9ba1faae0a7f179ddfed2c667087952e4256b115c8d7875aacb43fd5664465cbf2d0ab671b97caa4a99bd6fe67d2da94da15f7116caaa21c25dedb796a2f955b29f1a72f7b6000a7bbda1ea0cf1f05405cbb9f0807bf26c94b0a0625fee49e6635d098f5e7c017f56c0c55bc1835a699ecc0fd7fd7168d95f344ceedbb86db8ffcfdfd63ae80237f7729b309ef4793cc93028a52266ec268087bed4584bb2b71241cbc5f13c6bc1f1f7e7b917807d30d5d34288c0f1eafa34164092f4cc2cdd00259991537a50f2e6a704508bad5e63a5347f5cb64c442ca6835fbdab6941794c4b50c4c892f1899cd99e40174e5ee71cc07a56f253945e22fdb9a2935bfa11012924dee57f584bc3674d73cf1abca21fc673f4e8d508b2672bd8593639b05bd171c2be52f23dabb2188b51ec5853cb1e2028256a63696bf540d7130b447bca0bebbfa742a572dd648d5be770190414f04dfa688fc4b1420639eeced8887f59a813341ac9affb3a2d6e233a59678c44651ab464e19ae8791a48c98c9ee0120bdd783c30b44acfe49fc8bf37c7d322d14973e1bc9a4e9be3cecb652122be51cf944a917b22a9cd6ef46314f7de342c85ffe0132ef454f0f481a865347e7da4167f07e02ee90c4502222918d573c5110f0339fef5a294eafe6e7e657bf42540f77fb339ca4a436b3908e5b54129e395e723ec19e30d48b2cc4bfcb038b32baf0c08b5bff5e4855aa05e0b7886c5dc693913e32a0060d5a03198d4f8369adf9397fb7684d7a6bea1d43df02d3101f82b55709fd03fc51893f4d6b3ddac6749d19f428248df5c61c1b2fcf24c58ffa1e856ffd9211829521bc7b9fde6453e26b9198bcb70948cda223cf55273cb5c9448b42575eb29289508cd3a7929ff454f47cda36a2783e174cf838afec182627b9f6f0e8b6ed2b9d1f4684e79dd886ddf138163640fbcd579f2891c75e124c52cd499ec145bb04608db40a86b08abfff3b9f14130c277f994ef542fbc0465f1957fc1cfbce2cb65590f4ad564ddb2894e289bd98bb3fbfccbe0a6c04d73aad69fc983412db29dbd68f89808de00f9b8ab2b6e09324ec5a0a0f89516d92a3b5e45c85cc86db3f616141d6967b1a884049b5f5572fe23d50b7a9068b95383f3575c26147273eb7719daa2d66417ced0c1b6b7caeb9c8ab50521cdd2c27f601530bb44067d2e35c07a9c27e4e2666a971b3f9e44cdf63a9d3e4109be036572f16c924fa1b8f968a7b38a021bdee000ec7a7bee61345508b5bbad43372ac1ed00873615b0a8a20d08ff0c7b32bb0f185097eb51960dcb80bf31b7a508f4cfce60f2e4aca08fe5869efdeaabf464b6068f6cdc1995f79c30ec754c9e6f6ee659c1eeb8ed1c378cbec762534e5447ff19cd1f749c1f7b95196d6fddd2a22ceff630c192e0a264e172542dc2f554bd1c253552ced3e37385d53400b98e4c4fa4cef0131aad81a6310dc4d75457b2e1703cce96d975a2195db7e3163b83ec9927381ba492da19e955c1f9f69db9ea219ba479db61aba58d9ba24730a53acd86e4e83e86c5ef480f88030556c18bfffab3adacfd8aaad92aedf3566580c9b92c5035cba365e91755b64b4349b09e5e8350372a883ec8e5dbfabaa6dad3e3a3e0d3af7f404a06499b90b96e83d6122592d7b9855780c2ea7d49a50864d6e5a8a7054ea81f62ebac6753ebe611510fabc8ed62096479c583fdf973059d9ac7cc92a6d19ba0fbd466fb0dc726a130e0bc5336d2a970b5ea685c18129df712b50e28bd9cd5875b5bcdfab1871f95c1a1faf87326ba5e2d9910a5a1e465c8da932948e45a9ead7273fbf13485e4ff65cd821a2cb91aebbf733565fe4093c9e6b4e670c969f5a9f5cf3e8b9513c2ef7d19db9cbf462d3c5c0f47137d2b2d36959a0556fe6005af35a9e5f24cd3a518a6d802549d74b263e49a687c14d95b4afcd3a4fa2c44f1cd1072981311faa8a94ada8b3a6f8f57067d12e538a6b26d5f638405e024fe14cb7add4baa3c9035fd2ca43684c5b04a79f97f16ee90b71cafa2d6dc03d275b712dadc0e87787bf3815426b69bafb5b37bc88e8660601d6b3db248582d3a6a290a9472d97e9ffba00dd63255e6a607b0475fde6f1a0449b0988f5d12aa0d10ad95640171e262e939ce758e9e378ab101ccca100e5cb5e116c11368dadc7749de6b0473f57a8d17fd7f4ff90aaaebfe556edd7c1d8bb8b0106d7d4c756d5c948d876b5e8e4af61ae34e4dc86c2612d2363c7cdabacfb77883761045f9f5842e40f9f8ef9ce1c23324594dbc8cc4567f19f55db3d8916c0669c5de3821f02a0f95741df243b2f792b3c87b6eff50f25ad37b9cf44c22ab34a288d67fc655ebb806e22c4739a500635fb6d0b5b2f667428703e4eddac99af9a626d56c296c89069864fdf80044fe0e5566b9cbb669360b1e1d170baafa05c075d7c6b9bb4f3854a8985958a4eda933c0c07bc29d21a3d07ba1c5a99d1ff29673a5af6c72d3b822c5cbd08939fb16279a72cf4bc69b2e6bdfcb23e40825d1c5beb597c8adb0f80b05e374f47096149c8359234a69874e229ae4d1298804af017fe53a7a8793ed7c985769e06ea1b018413475ef971624b3ba49a50e95f6d7a5bcba2112c1f7e3f03f40da8695748d0ea9302d435f93315bdab0ec1017974104645bb4afd767e87a75a4652fb21fdede2c2b1143a2faea09de21434a17f48c13cfdfb69844d024dba2eb3fd2157dadfc30016cbfc8ebfb9cb7dcaf74bf2ea8da74bc25250a07e2f4784dd20ca02a1d315bd473d58caa370d47e67b9a7119543a81d42ffcc08f72e8304db98be72eb9fa2e9f72a5533c73d847a3570abe88970779874feaaef197e0d99e73597632cef657a9b69960e01e3959dfdb0ca02f952e71954aba4bd3bd1e08244e6638922b9b6ded6c52595b8526f57941ceb5973ecf058ba9b91454fc51463b04f2ea07303778c86f8cd5c7015a1cfdfc944c2a66d2163ec7c4bd59ed7913c9c077ac32cb0ec67aaf5bd1e80be7367e8f2246f302a67108c335f0ab61ef464f126d70c9c1294b693d93f6837dda59fa140dc10c9de3b7586f33ceae5e2352685f961a911405229685fc4b9c2642eb43ec1d03d07355474b627c4aee3dd22689c593998e8dcda273064bfcc7d2f6dcd2ef1a7b5f045529b3aa7d78b38f65a8a1bec05a6f590c849c5c867883390375e319d3f6ddfb845818928252de3a8363311b79f593730ce5853c7d08b4796b0fd61d95391d0f5983232544fb5f81ae6bc0273c4ca2a9452ba0d20a15c80606cfab3a0ca531608c31120451a17fbdd864c8dcd18ff1dc346934303fa9d9a928bca962d9825ee0a524c31fd9445bbb3aa4f2a6f4aabe50bb965a0228f7552ee0358de64c08ea87c9287f0cc235b8885ddd4aea60a57f0af9f0893f2ed0dca07b1bdee9bd5eda3bb8eee63cb464b17d073716b57788c5db5e226724b222d3ce5abb10b75832a373a56000edb6985d56296679ab79ad8e81a8571a6477ddd1373592861150da7d55b2f6c11a54da16d311ad4f9610f850c40a3a8aac7e9c3a2ca1beea5c3f6b5523bb93fd09aa9f76e2b82bb1daae56c9f55ab9a6ad7a028a413732614d873cf0c365c0901d380ef73bfd3eeaaa547555e18e57da02b553b1bc1490465aea743dc38d9eccac9d0d7819829b4df55a8b78eade200e2ab8f37f3ae58e102c1520cddac10ead140ab437dc4baf11f432bbf7e7c879d06f701c8ba0235b020bc49761226f9b3e8e55d6535548e84429b4d1990ed4360255d02d49d195c05cf26dd58a2882f3c0524ae2d4d258eadd2fddb565f262159b533c187518d295f34e6b8cde397a2acb93e2cab297738d329e4976b3776a596ffd9469b18ff2cc433311d58d872006d08d120da296e79282a743b3a4f274afb24abf837f325fa70cc2c6bff2a821455c35c82a243f6a4fe33ef05ebb36e65b92204f1d6ea3b77b826a9d4294f975aefd523aec75443bc4b735784504cc8d190e77750d303ee2859893fbe9a27af38523023e088994527a8e0b31631e0eeb331b632e6671ced0706662d3f771bf6101af22d78c6bfb3dc3844e0a5917aef0e2b04240de12d73ac2612e1137312a6ce16e01440cb861cb469f4e0747038eb3ebe5ecfec22c57ab6ac031259297468ff7931fdfa0156a5f010bc5cbbae043c82c5456820bbf943eae72ff09a6121e6ac8aa769d22fa4b48d346d43cd18491f19fec899b1b202f8fb4e4149140dcd6cc22257a73c63f03f29a7f2820943eed2b5efc510ebb21df5c4a31f3208585a814ab78abe4597478095bbed0045e573b589d915ddb565b0f8228d2c94cf77becf9b6601fa10df767a3d58ab5a207573ab4d06edb56a02f305895faa279279cc0d44092fad095ac453ea2d3ed23820726a400b1fcf894c6e33574ab2aeebad6bf3b4a0056f63546b55a21ce5fd9446ffac3c720ef6c37fe74494205bc7bf0af9ed18379763adc2f9f1cfcc0d6627445c97897353afe60f656886ba4cbdde886e1f582ef1509c874e70ed9b9f6f569205e8309b4f6e491206f788e6137b901fea66cbd276fe58c54fbc646a6d9bff1df70f2c2d19bc0281809cffd4a2e3bea505554fba08f8ab4bc506bd106b23f9994fd6f3170755bd00f62a9edb86ce66867f5ed896c21b9eff4d2990097e052bacade64bcdf3d52155a845480da4904f18d47f4298f2d7894dde73ced5f8ca1d9438348b2d2a2cb1d21d04a6258c3ba1b370574b7ecbcafeeb917b3847ff69a799f55b653fc8311852ee8ccb46752e0b4f4badf59b22b10422c3f212eaac4599332f567f2b3a2aeb17ab68edd47212d8819a7ee1205f649c769431b467630fe5d1be0f246cf55445c1945fac1740b971dd4456526cabd4374a9cfab42ba1a1639b4a14af1a75196752e2cd243bd5e6b4310520150498214a1456ccff037929acbf55cbc509200191c9d2e51ed80619d6380a7c4f0e7489f57cf7131ba6f5df8e795535871f0dbed944385931fca5efdd885f60cc5fb3779e5e58ea34d959e0b97c85b8e8323a690793acc99fd58d4f9f9a8dd2084749c181ca6d88fe86fdec09efbba8729fc74cc616fd8947bbfb5c186e941d1000f31f26b8f30f2261ac275dbdd6d3f09b285ed1e935709949eb76f0b492650e7b4d849ce7a04cef6fe4deaf0893a4bf23a4ebf3367f72dbc0b83a39abce3ce58cd94de50c576519e71ad0c7fd6ee6ee0deb5f88d7d84bbe309353326035ba425b01f78109d98711f85b104817dc70d25001193a3df351074191910b300149b011339b43094e5aa3caba7599f7ef78c421040853e201f5083d2597d0043484152dc61d36d63bec4be69130fbdc2e21df5189470b94faf9e95e458739666f18f6c6d262da60543f1a7e726fb2bbe69cb98f549d51d04515d18a0c6775961dde5f8fd07c4c98ff7e170b16da07453168469ca5815781caa5b2f1e1941cd93a27a283913765d481e1c4d22c5b64ec42232aac25bbc5ef1c250dad321f5860b710b85a9b4a08419537ec8f7b69bbe36bc7d195c32a34d725a8987ce8936fc7adb3edb1da062d887d286abe669d57481f81bdaf30ca749f42a56150609a8b909ce8d04aeca4dda283563f139b249b23860750116f639ca100c2bba60f22681de39c363bf9255e07bee2a9593b1ef628fd6d21bbdefc0610fd34a5b615196ff15b237a33503ec1990f4ed7470b974397aea0e547ebb7cb39c3ce08fcc2c25c0cb306ff9381838b40c6f4883c7734f932fdffa7f385e2dd77aebd75135a1dc60e8f433800c210154a84f6f5e1339cb3b15231f1ae9b12e2b11b41cdd19c2d26f00737b4e43cbac13de2cd7b17342c7d9712e356dd5501784831700c1515e2c27a3f6dd466a04c12afd067241417b928faf816594d7626f12295478c36256b441599b90904544abcd5179fab9b0b90bc74142b28fdd6c72445e62427e7e1f74bb538a7412bae8961b430a079684b779b12b95a7a4cb82a1b6343af3732817bddb73f64ef0b8a726f579a883e6be92f09cdefdcb781d84b45f5cddec8a4942132a82e32d5c4154931cc2c269bece0278dba00433a18a7b8f5381e626f847bcf7044d1264d40b3453aa64dc9fa68a43a1bffea2cc43ed80e78109b52621134a0ada996b91b8a9c026a096d4524a8b72922fae48dd19c31c18853f560effbd7e3335d811d329e0f8c1f303b9a204e48d3978d17a0483f6cb570f7c8fcd6f197251406cf458c1369e75b31f84912e540e5afff22dd95169c7fdc0ee228141e7f739f9528f99aeb7e96bda23fb1c42739bc22664cc2137b79632d30113cb661656ebb27300a69b63afe7c2a14056a563ec2614990f9aff329c46927c403f52d0d57086baa24559d87ee1e6a3892093fa75956cc7de4ef756cbcb850c567851e8fe01b40a741dcab2029cb2b7fae2767a7d9fbac5351c3b1915cf0b4626f873bd952b391be629aa871714f5d0de5df345778e9c4aeb3c9dcbbe9abd6fd42936346d00317cef4984d73964c55ad57e3f5895a30bb0cd74a0ffb5916acf1d432ec00ccae210db30d8ffb8045f8a6f20acd39760205c894fccd14ed325becb6be384617258d5769962892ab13339e8eefe21425fc35268dac649dc65a9da5c0210c6781d2fa4ef1170c4f12241797b7f2f496729f59756aecb54fccce2e176657fe479c9181c553d6623d7b0aeedb133320c628ca199905df3d52f226af0482a25e2d9522369d6dc161095e79c38741d471b13e09770cfdab92cec1cabfb0b6ae96afff7954345d135253274edaf454d5a0cced1e51bd1f68fcda5d7687b387b1e92520b4b537f939106a60dbcddfc7fd2443a43528a09fde0ff6cd5973d53c5953b09c79a19e358b140da6ce8e7d437c36d28c86a471e0713f962cd2e10bd703679f814546d255686f869d29360c12c426c41942d871326462e927ad59e3382ede22c6cfa0c7b74e56c4918d16026c9f61c3af557f949585a7ffac28c9fa05cb5b714bedad94ac25027f96185c502aa739dcebd640d82233c14093cff9dac3a90a9b736103df6679f08e8379bb1a514f5cefab6d596ff0f7a7d464385ebc087757d3dcd72bc86619f69bffe345c94699b7fc5fbd5f11dc335f6d22c31a04fe8ea9bc7c531c7baa6d2e5274db6a49daff2756f94334367c1806e43c3181b8c676ddf1771ebcb8d28a0cb822798ed2df713edb05a71d85ab743f86a9fcaa4f9b2a9b1440a657dcdda2b8ceb7bdb5df5a949fb6db0e466088829aff5fe4706244a3452000ca76e627b70f457922ddd8cabb6fbf4b94d3e33b001b263b53214843f10ce907077b7a54c760ccdd9027bb0df3480dcf71ec50e92f3f38a1ff9a50c4ac67f643700d901fe9be6ebd12f43d66c132cc32bf079c9a28b967e242512b75c0e84e43ee3fad78a7d1a5d14d719bf957432229ce5732dabd074979587197df6d5909ca5369782cc42ec86bc3f1612b9b073548a7d9a193b209ccb5485102b27e07556564c09f8346e1a6185d24ed3625216ce82b9f5bffaf43044feaee5e9b0f974658f0553737f35c5483724c6c30f355c7ff8f3539c10660dcbc23f42f61248c8d8854523cea2a1dc07a7086bb432bb76d525042203bdf60cfd3fd43a64828e658cc7d0297007f0b2042dadd88304ac0c155dc36911af29982ea94b1bd1dd53ffa294c6547bedbadb0e72131f7522fe41ec4995cdbc7544eceef64a9feb89a374da4290b82caae92758c20d61505a5d15a86b273789bf52f09909889e887d4e42176741604ea9727ff7bbc3208890c869299f3b1e5535c47b3233c8d9b5b0e6fcb4c8344f5a3f20b07c7386a2433ce207eb28e3ed662c4df6bc4619ce0ba7e4a5201567c2713c0f38d2517d1c52bd25e9e71346de002a91e04a0e67eb6bc8653362af440898838ab50c92622aea5a19af1d85ec1a387173cd80dca4b58238cd86e588cabc264af04e915af2b21df9d4d1c0dff859380cf79ce76fd1ad6e4b9a3775d904027169ebdba2cc84ee35f8d126e50cddfa6bc6e9c8b8984a71d19ad9c2d592c78a06824cd6061247a62a534438969c7cf5b925491b55bb5d5ccc9bcf25b52f3cba8dce3782251cae02a97ec06e5d17518de6138faefca852a11105f91905fd85a123407194d52d770eaddab6f52226b298b0a2deab75e3007ec61f933c34a924e030c2887f69e2a935ce87c22478143cfc1a548b72723eaa7c0cfc39d91735d14222afdcec7d9d01376b0d0e46e8c6030dabb2584f840f9a470f04d18a0dd8abd56fec4677164f9746bc3c251fd73774cbf70c151bbd912d3c1d8231c20d48f31d383ee5a45494724ec52ffd122566f58c6dea5318a43cd4e401fa216b241506c31ade8e00af928fbf62a5145f81cb0005104e068d1047725a061aadca07ceff6e971434f7633b4328012c43105397db305401df77bccc957a89985c8ea58c3d7ee47a5cdf110fedb243815b25e7dd570d24b0146a80df52a09eb1fa05b5e5dc4d92f627152bb43d5beb3561850307aa6372f1eeb3d35ff76e27a4783154390c870b21f4385a871e3a378d2201025af15db96a8b3191cbde2ec9206d26bcab0b6f7b2aaa4394810c76f539cf23a059209fc01e4b85d58204f425eca9881b949564dfd2e19476ceb0540b0d2dc4b4ed3878c55901994a58ff45fb8b08b9505aee7c89a9af021c438a5feff9d75edb5c2225b59a5c078ebfe0d805cfa18f79d66b4f78f25e565d6c888b200557dfaf06be8cd3f489f247b736ec9350b6774eb50dbf598f392a04f99f9b16ca155c9441775b37950b79670f25483499a633687a301b51208f1156f3d90eab514ed5a4fd587ad1db973712cad3fb3a98eb1f1fc021bf6e241fa8ae050aea5e78dde6dbd5958f1f24ec96e5fb553df637e467443785520d03cee558d68d56f30474b06061ba171ed36ac46571f42a968f42b70f5e29d0c8853bb6580caf629856122314c7c6a39dd3d18a3c6bc086dabceb9b69eb7de5d9877a3fa1dc481e8af15b93deefdef8f27ba132ab2d01ab0f83a573aa27cad5a66e68f9695a9cc3fe9e747b8df86ea5fc29be1cf96bb7b0a8e6c67462f29ded0acdedcf5a8d19c3e7acbda18c9bf577b5824e5a0faa332478054d24e61007686f1b93dc7478242c9d33a7883c7674a5da7147b005d5ef00fa2523a59899011dbf352be4fc0ea85f0ee78d6d096c0b9fa06c06a893f045993cd400e9fe597d2a91e410e5d6c55876306de61c64d41bba1a0e13d4e1c2a933ec7388a113bea79a43391619ed7f6df716f7928446cb113c1bf015593263bb446d2c85558523ff1ca6e46042eca903686feda486cd1616dcbd4edced5d486b18aeaa3ee7e52d72675853a12ffd1755b36832f4155d099fe71935e32c694b55e2e470e00587eaa663169c8df1297ab2c38a0b8ca6002d1998fd7551cc6bd85232751d1e5f7b0232978e5d6637c76afce5c64f30698da8dc88b0dbdbe5f52ad94b6974c8df4f1b43778f64eb7b1f4c47e6d43cb4935f22d7c7dc36391eb903e71f36a02b09a0f96d57c1f2ff02d35d8d6b2b801701e1256c69282138ec7fe646a307f785ced1fefb082e9261546df1e913841166cd3ab1f240512bb9a689581bfccf7f4fc46a727469919f22c5bc8e6b6b6a2fac96a36bc582f51092a2f5a15c1a1255ffe1bbc0e119e2c916e3e53dec1be79975181600e30a858c107c970197e88809d04e981f92188a14e25a650c6b5836f2c1759ff966dc8468e55085f93805ca19222f677a0317a2e7995101cc5456ea4720b312af7bacd0a195ea0a314fb513226ef5872e022463229cc8324cf55720871f9cee5d5b2ef79bdc7d160c17d2ab2260dbc7632be57b9691e0efcf37d868c98f9d3358f487037d7e188618fc65b80f92852d7111cb6fa3b06990ab56023c3a09f80ba50bdfcb42e6310f98e767a24f454024b80f2ce450c7a8a3805a52ec717497049d20c15ee1b12f3b6d8f521052de4534f3610f75172cc6ed9c6cfc589e6e11782d65dde953259986b60c491afdaa459612da94048cd50d07eeae030272e17956c7f1b79f0ac796f5129037a1aed9bd9f946c9fcf44cc8ba3794ddbd3ef7f27157c11912e667452fc157b692528946da7f953bbe60e36d6d0f5dff37c3b0a8fc64f29b7a2437aae71581957a7cb203089c2b53c956ed357de5870890f6fdfe2e201daa55d5e6ad8f3ac1c7e29b7c2477a8a8726beff04f7a7a8f78058e9e15d3dfa9521dde727137d4c4f69fe47c1d8f994c5adcef4150e92e2f2a81f6b7287ebd060a8f1da388f853506f675faead05e0768d736ae473fa7088785aef384efc16a5dd954b5ce70225cb7600959f2bc201fefb3e816d4ec94f6a50944c8b3812615b14eb36e1023206d62c77dc996e18bb80f0f81602e4148d5605baddc356c2f0fd42354f7fd0fcfa8ebb59355199d8bb6ac7961226c6f412a6a97842c3d160c50f5d690792f9654efe6f74c3e66e215469477eea484b4b0e63531a83f052f8c1ec62a196858c7e9f34e07cc9d8d065d5833ba148c07d6cf3e7639d8460e87a9ea075349f7d683f786faa3d69a338711b396d182aa28f4df0b0cfa9fa2818d2fc385b82631a784ffee1fe279d45b8f64e378743456c75020eeb7482b60ffeb90b9878c68ce793998039ff4b8c809f15fe2624cbf842ccccf7c867409de214d487bf285219b88edc160a727cfa683908836b64fb9419e4c8b2ce0f06c592a0d19ea43175c2dcb3bde619edcabbbe2319a9ede31b4c08016a680036cb55d912e29f4d14d11c82658de151a2d8266f828ac19a00993ea13a718e0298bcd0ff231eb2f8730f2dcbb644cf9e0b46b5d3fe5ee390b8d758a701c4d45ebfed8dcdc6da2a10e4fa76e72749f6d0279586d1d9814f1d6c01425372a954e8ca213b9786fd9ce7eb4ea88f1ac0e184057d4232bef1042265dff490fb1096b07c5922ef05f0bd2bd6f7cd754e7daf6edc5d7531779c3d3565376acf21a644a38b59910c0b2af30efd2c816199c6fa52c527880ec6cf964d2de51e3e3c7281230c726086c4b365f7ce21d24256aa3f8f310bb295de7b89c540bccf3f4a2e5d709dc11624051683d49eacf2e7a3215c43454a3f13f696dedb19de2ffcf81b95cbbaecf5cad95b70a7e1969f299740fddb0d997b8ecc857c474a66a913a4ec3fd3e054c6f9e0f927180cce4521d80781fe58337a40005c0793b338230803a80e457d406ea0fc45e549f48d5a7d1687d7a23274c87f7e658dce67953f0594bb606be1f887d85ebb0efcc88fba54eed00e39cb25f7167cecdd60fe773464de7062ac940840ead4b356dd10e99f92a56cf55b14bf950c34f74a1ddd9a55dbba3ca76e89599f787eadaab8b3a272e4e5eae67aacbdc743a79229178497c38c55d9310d3494e406767fd8492e0876a6f1127dce618434db2c6cf5c684884181859e3223d3a4b96921ad0db15112ee058891748959d7104a1eb4ebb4189da473b505d16fac9aec5cc55169ad42192454303720b4510e801bd9714946224dcd8181a90686bc9606ac164125b314839097213b137368bd80344d7b96c655ce9c34886c1a44ac298e69ff685d5d597cbb940774766a5b28e8e8e6debb133db53b0179c93fdbff79fe6ea57f22afbe1eb5221da09983c0711bb4aaa3a8664671a3bf7004621210a68ea7af6933cd4fd8e9570c8872498b7e886e183a04aa15a802096a5c8aba07c2b295d151774847b0c76120e8524a789ceaf3809656d6c5933ebb7e53f44908699be5fc47ed8a3ec9aaeffd8b4860dc90be5e5dcebb43246f525c6223fae4f5c8960f46dc9d72b483a27dfb97ab6337884a57e4c23d44b83405695ef7c2c600a77d1d0178eb308b114a187427985d5c7a93234eab3825e24dd06e9f6cbe4bace34e780e13f5876889017e4f323d19299e97b388b77e714306a58fcad0d7b6d050738ffb8777d048417619a734eb7edd18b8d55fc8919893907986b63bb07b266e30825cf625a618abeab88a809aea537aeb430fe6295522b9910068a33da7db11eecb91677944518c6b118a6e0662e5d7b3f1745730eba5caf6c72a2c7f93faf0d8f77cd1e3a61af49c73b807e944f21c1f494ce293ae4bf5c65d699fa8b22d17d466675d47de791415edbd79077bf33483cba1ea264f7a5f915003be1687f00c45f94b00854ccb1c1ab3f0a33e13152ae8ea8b3ff3a639dc8ffab07f5437891f6d2e6d3328340ca9a557b4da801093d20f83aa98646e55584190cc857d22477d7da695b913159659cb00ec0ab2c7b09508c4deb377a44afb6812afc1fe607ca56377c651375ed6707d0d620635be5642f0197adcd29c47a46a14fa77e9a45a473e33ae978d9b4ec5276d465f8052cad96561b0bdf9c299b1d3d2f743d95a66275602f857a9cc3fe14fec44541d678807403c5346ea51c63d01e9a20334f638282b524c23292eae0c8ac5d800cbffd4059f53eb1dd5590cdc35dae1ef012f4637e7ca7da1c7f3c022a65510062af6b962418dd074a11b9857deedcd41feb8861fc4c1a76b81168ea4de53b0b22d3376f6193a8e51efd2c45f194aab9ab637e21f49bce2fe65f399af8f658cd858fb2a0a9a3be070b6a2517b502082b604743a5bf230feaade7fbb7be69f5724dbea6085979ba729ddbb089cd259b39aca1822ab207cd442c97cd655c11520d7b3b463d4d611bc00cf3ebb2db6433683d505d7ab10ef74a3db9517563a378fdae6efd0a3b024d71b833b8bc8af4efe0032b6e6eb179b1c43517d4d5fd33f4897c2477fa41557f248afa8ab63031f11212c437ef8f2e936a85f8e449dd8e565d806957b785edb2027102fb0738edced12d14810595d60f2d9716797e563a3e2a773b420fb7bb7b90cfea469e1056db582d5ac939ec51ecfcd18513ded487e1366339b13dcb4ed50bea04ea07659bda4ba79b6a9042649b5eeb856efa6be2b9871f7e068e6e8d62769ec4d6559c941933b806ca6fdba0f5ea27464ac2fcafec71c0e2fa2b012f533cf4403e3622bce7190212351f727804dcc0dc7b3f40b2ca75f692fa20dc626c6c8ef0e9b6377372f35af3c0230c3149774aa2d96a665eb32d2a9f9ad851a9fee59de7156efc13194572485d11e2fca0abe8f3c5b85c2834cdbc88901246f5aa028a852eb867d885364ef766a6333c1bbeba0265bb26f282b3c20999cd35ada36e66f2645c154d351389ad7a7716d1129caf7dd341e008f16eb48e0b680ea734fe4de1ef1e5f8cdbf50ac9e084c7e4edb7bbf475916c265380369f8f3a8da0ad56d2c2983d45fbe2fba35257342cb76e390633bde3ac58e9c36a57072b8e4ee5a1a4696d0887dcd08799174fa06f2719754e30eaf4e557b7a58c8b0770b8b7c7bff6aa46d496db141525d9c3c0e97cbed34465fbe73f542ef16387d28a49d897ce23427591b2fea067d101d9ec3a570b69dbddb7f09135c7e01d21ae8a8ccea332342928dbe2f211d9feb814fe1a30ecb840078830be1ec9d258bb295411cbb256d236201aa9337f53c092a608422a7ed8c7b0c26197b4b223a375e16aacbc5664da061e3df744f340310d9ec0af06bc7a19193c5f2aafc4c83fb3a51847778c15d6c19821250f9733af398f571879028920b3aed036cdb34ebf15cab0659dce06a3cf7406a92af2e155f1fc671f2df107c48eddcb217873602e3f73692d5340718bd406c7b9cb81b8d1cf43b9df1ea5a4af77699624449a0979c1ec0676c2c6a41881144e17857fe35a3ba401a506aafb0461634432891e0431284aa07f97ea94658ebc62a7ecbc1d9a0ce401c49e650b83a59dd8acbc1aae5120451345d2ce74218b9d45e703f418a38dc2c0711281ae6ec4b2d65b5d8900c8c22f2dbdc077652f1fc9900397757c51a1c92f4addc431f316483f8bd598d04e75619956275040b5b83d8dc87dbfb08a8e29c8858d4afdef33575ba97f1772d1fb8a03d980f25b91986552f7ff90a65da7ab7ac76001e17d4cda137b60c3d210385812f788572b752c7a8b0c559e506f930e756a91a0b3ae100a4c4acc26fb59ea7a4a1eb6a3d5ccf1d3c53e09e6ee299d0718ea2515ff7193ca939746ba885f6e983b68a49fc82e0ee28ee14fc5eeb34bbf42d84280c46190560268e237fd80fef121535d072545b04bb47e992db96cfb372cc0d8e7166a2644aafa164639817436112044d45dbbdf925d3d432d1fd809db9bd9d278c7fe0c722acdfa87f07f005927f33c4187c990292efd0f3f559263b0e33214c889a2a9b51cb74b6f83827dff9e7d900003d207703b87b48784aa94e3d8e09b816826019d17b6b44a9e31dadb7667a9c63e04d5a3154f2c5d4e996eb8a01c5a949a3e740754cd306e6bc97c20a88310e4353b43845da9c27a74abe1c3494168ffed324c56db19c0a1b0cdbdb0526309d650c70b5afe71098da1a05dca9acf7ddbe1f82ecbc7ae03baec65174cfcada4e04cef55561fb0c66112f82e97001871b6ba29a223ca92f9f234184af8c11a0d9733d0b9eda53692a45038bd80e5e54286b2aecee50419d29806d9e330d31d48f3c27bccf163f574be5802caa2383dd01390ed51c6de933af5fb622085794a64abe009291cb794918c451f407a7f6b6be4ee8ff6aed50723967969b1d8384080eb65d77c30e4ce2bd236586a5ea3566c8fab3fc7634372e10bccc95c176eae3574fc2f3c55beeb01dc7e28d6a7f05f171fb0fd0bd1c80e37493cd325b168ef4f7b8e5fffa02558de6ec7111affeadbec8e1eed9eddf2bd1380e2218b3e2946aaf1f9763afbdd04c2b786d498210dd9317ac65376c43af336e52936e43e6815b5958114d1129764da2a88a6c2a06d83c5e3584e53b528686e5f354f61e9f667c051fa58c93743b89eaa0931763b628f2bbdc5d3ac7fd22d4827a902f5aacc77ad7228c3c35af331ba87b8a7f695dbd7388a9f56c6afc96290e750f702babcdd6cd7f8675b6fb48b21af4241f355b9f4963b4cf2f2a8bf517c9bd7b0b6496a866c4644c73ab99d72241c57dc0cf01aea19ae828c900cb7e44865c13aac8883a7fd735f80413c2ec60b735a735c7ca783552b7257396732d86971d8f23e0299b6ca1ee52c864a098d6b680716b3c03ab0667996c592cc0379ff286b05804a03cf5312c63b598b3a6d1bbdaa1ad8a92016ba65b6237b210dfb683274d9c8293e5015c12e2cd9af93f7b7a109f12cb9d823a6739dad75719220c83d409599c2d91e8364c5196fa10401a41c09bf3f5913bfc7396f49580c80254619dea3687a1130465e4b95fea3620d2064b50c8dce4104f7e825b5ba47952ddeca2905cc2585bd67f49723d9dc51a26bd24ab1fc1179bc46ca697afe3d7c275b39d69bc5a0aee69e63b62c6a592c8bad42a75a2f455247e09aae9cb74672fa29e55decee90e98e0e7e8f128d3dafe3c28cdb5adcd8943719c4735b18061d9ef86007a63e92a4d8a58d0f32e9ded4c63a56f4ae89adc3986a282e792a2c1969d44ebbe1f3579d7630655b99878906c527cf0919f9d24aefc227c315bc1155a0e77d8c5d9801a977a46a04dbd0d0f96c98878466f3f5b07481d4f1f1e90538ce2b224c0c6eb0e3dd08a5aa4c38da104c1dfe048bb925f110b4aab40571812c93d59e7b0e6eebcf4336d5c2dc352ea3000a672d1589abdb0c5f9b87418bd694cdd40e808a25fac3207b08206317223fbeeb267c250fffd601f88a212e98b2b0a3d3e482243607989aaa517bb5bceeb92756aee43829501a7edb8e813d1f5d59b23ed6f1410dece6df5940b292e84542d9773c130ae30f0b555bdb9e87051f80fce6307e33d7b0c14b3cc2b0243b171862fd6fa37e54c1cc077621abb233b80275f151d9fd0c2f58dee85cb27ed27f4cfbedca97ca14695e7357a3571648805aa4d7644d4dcb4ac5d0b495bbbbf50386732bf3f02f7fba44ec60c1a0272f9fc2cfc6afdd5331521c389dc16687d0de14902e167e4e74ad233e38af089d7d9f27b025c2ffbb3c1ae3f18ed3ec11941a5483c0c21216b86e5b830b745c3ec81744965871fe242f79332cdb4509ed46ce78455b69ae5ab587dd769830a655243ce8353bd16583b2af653ce7d6b34a386882ad6028e2591ec30c2640614fcaadbb1329a9b21637f902098178b54c6e226d29615e19214815250c7a9546144d7422822f356048a3bc906aa96f2e585fff79ce2fe71ac203db702921b02dcdf61f6658f914ffc68642d0474bfd7cbe7340d27597fd85887e1d30cee0d0e168ff05e46ec0f0a1437f0da7b9f435601205e901e975c55dd70b3f840c0fdcae8d81022c143a53bd5560fafdd6c5c2266864f384429ced997bb85f26a7db6d843632587de6209d8a94d05af0a2a23ec79ce230ccb8b711f8126097dc16f7a7d1a6aae45395a9c8c2507891fcdfda25873ff8025b512f4679226f087bc4ce78944f7f7c2e0a353259c39c5aed7294a746a24304567975ac0056cc30033fad90c5e8f8124ed2ed76f990c9711a9ca17fc9ad80c86d8ecc69694568be766491e36fe917837486c09f3387ae07700f12efdb51fe4d71401e369eb5ee862cc71b7c31ebf3835ed06d95b60fcb3f9b6f8a7ed7176cf22b99f6f7df2b031eb8493930a0cd773806cb89c3f9a1cb4a2dfafd23f1497946b0c970ddc6637dcbe194fc43e724e06453fa4471590730c7713dea4a561d953f9c768c29f6ffe33011dcbdaf881592686e1dcacfc2586ca9dbb683d94047026efe9e3d3f1d622cb92157768661018d21afef3b4a88be19f2adab3b55fa2258e478d0960320d89169c69ed3d8b7766e25c5d4e9567e7eebec56bb460467298826f7f3e7b37eac8dfaf23deb6be0549d54514de2cced1972c3f07600c4883739621ec499a99a8d27870ba10d83b759fa796dc8ad3a15f5e7de926ecfca87152e12739fce8639fda550a13da191dc555ea4ac7abf05bf184c37f784d433e123e09387f77e0c99e31b81f1098a34b47366e0c4330b42afa47f2627cb80a854e58bc0322c940c63ff196d2a44d580a6b4b8248e31a43c25f937b12597cbdd6176ee70cd07ab16fbf7dfa4c6d4a5705cb3d7d63b8c422e1bf831d3e43a2963fad4b542c6563b25af4e848f861b5f0e75eb697cc70d9de35f184993c5d308a703e22882756816b28c454bcbd90856be6841d18538662c93e68bb1f043d75f1508868edc43dfe53d768144a53a02a6d0d5538a3002a49177cfb248534c5247feca415d7032e7c5a9932a63febfc440300a98c49389e9f90dface0f1b256f01221c605717cb01b2ab3ce37110dcdc578847240d8e46c8ff591682c336ddf501d2f15bcc4960d9ff3390014bc5e9405fe52929c2b52d1133e1537eb9e1132293dc98622303788cf24d79fa8f279d6a1ae44b990753fc1d946994a82c617c3120970b173c2cb8e27d3627f8f853b55fab25a48197773b59537d6ace3936c3e37ee8910749dc86bc036d03d7afce4b2340350589a8fc70ea37929b44dc4180419420f2d37336f40dd6eb3c149f4f60abca7fe8fedbed06507b9abb6b4802aff3e9613895f695bf7110174d45dfa38ef9bee55d3b91eaa11f2f52fe9135f41f24f4e47de6b6011da8e8aee7f58f5056c3f3ec79f457fd6552754b49a935c63b0ba1c2e26f82f348b471f24677fd08be21932cc813e3c9528","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
