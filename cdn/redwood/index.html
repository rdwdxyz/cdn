<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc8f49c3bf0e31cdc25b0e09a2a2071c14d72e5c0c456486faefd3bec8ad8655cb315fc78e532b5fe0366d46b29f95c5b06f0ce2b97108d9e9a7c30b520c69e2d6f87224ba743fdcbb42dc32661bcee9ae6c3445ddeaffeae110264b1abd3f01097fcce0c80b1c2776e3949788300bfc6f995f614f88f93017c966042e103d6ed8224fd96108f229aeb9f024f2473f35a12293fed09b6c410d0159f4a63281011cff0367daa0564e54392172b64d7c571fc64ddcf56614a50ea6d7cd5a876763477c4ac0af1ab787275c999611f98463cb951cd8d91ae581f9505d0cf6f872d60d4976b1179684b847bdc3f12fc4dc5e42083b5fa6f89babe4fab85268c86bacd64456198d7fc38fe115bbf4f67f14dcea89b333c654e6b929300b2e87c01287441a45d7874c438f69efc1d48d512306d5fd0c73d289339206dbb13c2765a7776adfa24b35d637c83e0441f3dc3f4e4cd8e0dda31a934c768eeb53ce7f503bba55b7cebf3b5a31c8ac7f909e2b9106edba7fb6c8fdc82d891a0ac8444b2fe2b62e6579cbcd36692275eb502a4d3778e988566c3395d1c8f2a7c844bd11c6c95e9a9c40e9c793544e5407d39a0dfe005561ab9faced1ebc08a0043ba6b35c6274266c195ef988fab1fd5db60408bbc3586bf6dc3b5825bb829680b7251b6ef0f852fa2eaabdc3ce1372c544d3bfb5d097f1d85e029cf07c2528c326a7fd1e60be8561bbbea50367639cb39b9f096b73937e64512f5eedc2daf7f2cab2e71ed7452b758b3e2290e11ddf035ece6d9bf6b1aaadd4f99d92fad08f99fa8dfdf106f8d9a11443ea0e05306a2fe29c14a690c5036e684765ff014be6df3982484fefdddeb3d0742ee1ccf3bbcef22bd70a502c082458a0498884c6558bc38e20c96b63e226354a1b9de054b337a92e3adcb69c4d677904dc3f20cd86071132854679a3122ba7601d1c752e2cd5a52d8273e16167e69eee82ff98cb25822b8644aa76e5b79ac6003cfa5e6951bb1cb1c5d1c126e66e5d765ac5d8682c59710832b1d977d733faddc71b9f7ddebbe10f586548b12f864e016662f778d1b8a2e17854d6e79642477d1274aec3f501f5539b0836ac830ca9e492c823b480103ea6f6989626981946148c7677000b2f816f6f57e42a748d2780f7f7f917372acbd8189a1aecf636485c0b0edf8b614298452cd061e8bc275e308a60e49fbc503c3bda3cd2e9403dafb78df53b847c5cecb26f51615ad592d485b46aea0ad087c330f7d2ebf5c085deabecc19fd53d226e0e59d022a98c4964ff8664bfd16736b3e3e45281cf35b0f3b3d6430c0ebf09043f293dbd07ebe0cb9cbb61cfbcebae46076f380c278abc0ef2f2893dc96b335635b5e377f0ac8fd852fee72cb1eb2ad4beb27db71984570f10ec1045dc9367a5b78ccd960bcdb99c11909498b88ae08c78ce3d99fa329e583cbddda6d2c94d80685c27f7639990db48fc52f2f8e2ad80f188b5c261c39cfd51e4aadeac50c67be76f3523e5661a14cad1a1263cbef3c0ae1b03e6bce01f5ae48661af3af9a849adebb6bf6fced773b81f0a8bcd1268c34acded5607fdf1e63186d6ddf38e54c392de2634d034218cfa3a99a135530cecedb7e94b6034cc9b66095bec052db09caf04a6320026a05b76fe068a84990b583f0c02a6093116bc41f9a93dcc38321d9293465600a57873694c780401e1ae7eb3c61b6535d1a34c5ade0ab6d824e7b6d4627574c4cd388d9c52a24c4086b159216a099360380cbcaab3632dacc302f29fb01629c13e6be0e2e43aab164c6942b7a086dd1f8d6a0e1b0a9a4d9c1610e38960de90b74b8aed0f1b9565ab4fbee3833fbf8bd5fb72f94d28cbaed1712b273d416f9f86304e9da7df7ceb3b4c0755a9ff3cebb7674d14dbbf39ac6379fefd033b10452213d706181bcbcf7fd9163bf6d042c4a7a90eb71bdb3f9b7fa3515e44f60cc436dcf8f9931a9c897f741fd4712436f7a40355b3ac3b7647afb4b438dcaa64833ccd407ca3ee3a41c63efbc09fe5d5294166a59b22edf57e1b0a7e3aaacf9c842bf5b325bb57a02bae398dc45660326fd08a51f0352ed2729ef8ddfda91bfb72957eefb437ead30423ad1df3efafdd90eaa87e5e6f8b63f2073268522434abd3cb7e071075b17caf8dd5d3fc5b75b50d2a8c3650b1458c3f3873a635f8f7a834008d51bf571a3a7695f039d25bd2777445491f3a88fc32fd23ff0e467a4d608647342405dcbeb2958fcb2874ed63eb1692f918bb0dc501e87d3602e09f6a439f1649d2aef47bcbffc5f8555866ceab6ad3f8946a894ae3f7c4f2da38b10f39f57e2289e53f9d90ff636abc9c2673bbf9889a64620e37352b20df4b22175786bca788ceb1a012f9733966f7971743758c63205ec4ef53355edfef68aad89d253615459462ef5e7cb52326fe8d5316a1bc2a9b14bc77f76998004bcf4fd51d06bb6ac9f520c41cb0e40d816bce127c1c27f19297d0ad233ee02e0a391874083558e14bfd0d30b56ba76d80161166b6308826b28a21609b19f2c0f110a679142b40fe63dcb77c45fbfd0084b3b3f49de9c42157446d5603b48643bc912f0e9a891f11c464907a00e1d3f60f5961ca942eb5534cce2d9ea63b4e650570613cabdc8bfd3ae8dca7f89e4a334e7a2b065807a6b35b0da3de55defa8370856dd53a7283401e3ddd2c7aa35beec341853ae5150e1df2e2a62d0c972d17e9645f693b765465ebdd1360f7224a235efbd6cd970d533d4447e64221282075fe356dbcc7c17826541f05316920600c3cf2af27674d75abc548c59abdda85cc91fc2471c81cf95101cfc87dd08f286e1395790e100e31ba7d1d027924e0cf548dfc831f5de64b07f69e482a0f5e9d01a144d05f1d0267fd40351dd1a94b792800662508f87e882a02cbf80c200b70966d3cacb9149ba527e37814d5243d68d308ca71b2ccbe0e4e6485a07b8f1abd3bd3ca9fe1bb5a117a78682f0610a8933cc3e7ad6a83fd4cfad728bb8a3d21a51efb271eac4c2a4fb58de7d5bdefb7a87dd4381ce3c6a8a35ca1ae0d322d9114c39f39ffecad0d604a97f74fd373fecfdad3a27afccdf0887c9858278979ab3307304b22d1bdae7e49abaf3848663d8d5d6ab17600d34c8071ae3affe7e17efdabf7067cdc9c4c05e0dff39b4736fb976714ff359ad6ba5417f5f08e41d44dcd83c32f392fb9f8578ef60b7a3a4ea568f58b7180ac64d8fc62bbc8cad86272e2a359e7450b070e598ff13caf67ebe609b77fb04a9b906c103bd90dc2bec6f9699f8744be4e5e31da1ad6fe89e9b7d24f9e47a8ce78f61eeee22bec66143b30b7992c193e3ffb8ace31b1de24c4f242410c9521d4fc4de8cd7d19831799c1f809a86eca4a0f148fb0f34671e6347b0d7c64186b2117d4d02481b5d1dd9872cd303b4e48a6785e993f3978aaba4182275233aa71433bddf4f1cbf67db5ffda001ddf30400488e950fbc048933c7e854c26d1725278ffb0b0494128d7776dbac0a3a247d5193499087420b2418ebce8c2bfe1ab301257880785cd0f5af9d1999a9a579c8152258fab37eed59469a3200d2e064bd97e36348556c60ed6a5b29df0fb86e2438767ed1b4dbcf10f64fd5a3e790bb6f3c8d9c826814b92ea57a7d53d37c0dc221e1a407794bfc73090045e7bb9b60e4c7f948063680ce8dfc9d0cbb024d0add208d849f2d0b781af87a044f3e5f5b5748cb6b8844f091428f45c78286b6ce63353140cdc030c107a923187dabbc327e9b276eea3ba40b3cd1ad67324505258aecdfd320e80158fd966dec3553ca56854f0d267cbf1c50f494f31832675bc679e65d757d372e02c9f7df09ca4a6c4fd86138e67353b429e062b7d06e9ef9fba5c23969afd9bdb8c60e1cf0255e421259c11930b7f95c5ab10aaadf6fd891f3f285a488cb3152027addea9715288b7673498dfef620a1582157f741ad84d78bb111441a42f3183b1e4db2dcb6a2165d80aec4f859c3e09329c1bd94b8e95bcaa1bb2132c0db8132128e9a76d9125fc19c866e3abe16a07e850c34c1988a08ae19bde42bb25f781c46cfe6a5e1fb867c0f86e62b13ae06af45a1123cd9703ef70910d7a5499e900230a0e22560687d940108171edbf5bb6d6e1e0634a04a9caef0aeb0a36de68c9446ce34310b1ece81c4a2747dd73aad5ed7459054e77c9c3047e0b5768331aa3e780192c99a0bd8b5f9155f6d790f1c5b4e63e95db9f3840911833301af6c75521fc67c5ee3d860e5bb180f4daea0f1db30854422055dd1e40825ffae114dff8d43793fdb11154d90b7e7dc77799bc18f706fb351bf924cf20d8970931c995ea5a78588faf856522763175a210d2bdabc50bcf1637f519eec17ec7e4b00d50a64f42e4177ee33024efdb99b2edbe08c9936ee863952825b2635d577fc4a20bc2c8e0e782314ed2aba67a4633d06c722c3588b0baede77d7897a14b51b94914170eba45d6beca568bd1eb06e92f38f15ceedd9b1f67e067350601817cebe38eb742b1e055bacc4fda8a76d6e0815fbc7635f6a1f4a2c87d67554bca0102339fb31f5b929fedc610b2152f4328975d0bff2252ad9a2ae6dc847863d763c476a56dc6415c905dc016b123accad6a961970e0230dc77f4cdd4b97819bed89d32376103e1cf85b3b853a3312252711003482ade008d7587feff1c4ac29a415f9ef87a47f2f488d3ace5fcc5f5ed712ecee94445d07867c91274e806cb7f7cfd9f0db3a46dac378a1b54d4cee0c6e5a66b00dd7cb5cec68bc124d6b7a361011aeccbb9b7b0a36e97dd5ef5c76702585b969d17e0b7b75609a77d8b964dc7a916fee1529b9bde4050bab38dd60f909ebe00d7faa58e829068205ee47ced2c82ae2e17e82bc69a986c42d906dd6a066f7b4781f34055cd2709c476d6198a18114c75ac50c5accd191a58f2546f5c97d56748b0939a07fba8eb40e0b1c1cd0fd46f65658b53057739b65c3d93335f26efd2f2c7196f6d614096a0e444f598651e53394babc5f6db770626f51b2248ebe0f045a0ae9fcd5f848b36ae955a3bdc141c3333204ed2a45b21e438ee989525c312eb302aac391041692f19d01a978ce0e495d43316fdea8862e93ff5c227a758e3b4928fdbe560df51efb381c712eb0fbab0f7d910bf17c22cf529379218d7aa75420edd55796f3cd7b095468004aac0f55c51f12548a71a2a308c5d02abc644b8600520cb32dfcd335f9a5c8db14f33b6bfc931a3f3ab1d5d95ad763887bf8353b6963bdfd4d404c804554cac2afdb735115f719cb7a38dba7604e6cddbf3fa793fe31d8b147e524cfb133ef76c4267fb382bc84823c601ad8b45c0d1182432f16746b65c2feb8deacfc09991d2a96905c6cc6051245c371473999dd9fd84e64fadad552eba9df17310e9c4d7b344844bb4750da12e886d02960ba9aba1045cb7906f3411ad7e935f6a122df7e31e50b8c8fbcdc999e0855edafcde1ebaad98a0bc51a501e5fd6a0fefdd5b3a2b568ca7d63649443b7f62e21d4c08db8dab9e6db7182a2b443de5954d6fb91260fc610694add562e7cadb178ac0ccb793b622f9abe34566cf1a2e29aba3ad2878c8d072a162cab02b7623baef49b59a8e2e227ddd9216adc45bdbe200c945a2a5c756a640b735f9b75bbd5d0a132f5d527cb0694de4178cd1ffdb5c040b95e153576101ef1477cfe4b43e7e5e542be07505b25afef067f07f9df1fa6e0342c094ced2c70bf0fde052c9bfd3dc47f3293acb58fef408be6faf5708ec3b5def8483647459e23bc190c141cb9e86248a4823e5e4f97cb1d0db3bb69689821cc03d0e429545d9124fecf24530ef4461290e3a05fa29a1f9d1c0abfa60cd7310999b02b5ff7d7c3d2f2f0417ef479e437eb5c629f562c7b885550c7b16984155e5f8781f6e26a830025587a56822ea62b339a58c88adb6afc8af23c9c19b6b71268c4aea13f7aa69eadc0771f491fa312db02110bb9798727e0053f65e0411dc7685c9f0ca793ef5580ee28ed847e0b554f32592bbc390bc9e6253d79f644b38a6005f7bad5d67e2c607e71de97cb23fc143cbca13c8e91de4cc2e96b99d1e4b0b12482f36b155405ee11aa25915c3742a8e35dd5262f23ebfa93b57da225832ad8e30a8be93b7db557673bc9caab0b8ad45666324786df10e2eec0e36fb986bec86067ab4010bd95c6243fe3893b9ab5cb7506862ebc84aececef6422caa8f01b991bf9780b637c966d969f77be079696f78644f3100883cbfc7f0c63c5f4f4b7fdbc2f15490cb562b16dcd62401dc5902cd17fc251b4ab031382471aaa432e047c73b0e79fbde05f50cbd0e1830515f489507cde44c8b0f1bf9311b2f38b5dd5571899b662a62762a60bc6c8202669a9b77e91c657e7421da795f7d9b26420fab4be34f06e90caf0c06d09c4a661171e2d014f397fd0b7b5221f864e2315944d3807d09f397fe93abb42c5314182a447193492f1a9dae5df9b86eaad122e42b6c83d62c80b6b3676568430c99832ad7af3c3ebcf79c46d108dd7ae155fbb47fff420a775c9a674ad3959f47049583003055f609ab4da03010772069506caf9d45a5408437387227eee1de089bf24289bcc0d6684a47adc0e8f311509e64218ae624d60f144b33ca9c917dccabd209e77b278a0cff89eb51bb7127e58d8dbbfe53a1095a674bf0e56d1a6076cc6274be1a5d3672af3a9339616a1255779f2df017e2e126f6bf838789fd3b9b7d3590407c0edc9799533423027e41eb019d9bd320db506dce2b1bc8a3f5f3653fcb7fa46adc0befd5f876c9b6a48dc2d13aef9b26b9746b40633a85c36075f76e1506a2a55f97378e3d4ec36b6ac43328e5bfb35c1913ea97ee3d47aad5beb02578f84b37832b785cb0bed5ee3b8a445840c26e837490fb663041240c5e43938faf5b1b62b444d722c3ad7d615ebac64b5ee832dce6d05e830ea525154d00c16d2be0564eda5b208d93280e348d23df58f7001ff6647087512a0e3ff5275c211407c3162cc443ccd59998fa282f6b9c6257f7203174e5ef64d54d2e6ae3dd3fc2cdd2505ba79e79774049e4d08eb2ad6782564f764a578d4c98f3296088c7650b468eedbaa7836047e6a98d1831c4d1dd3c860cd9e19b9852af8a3ee47441547bb2dd072fe2bbc208517ed290ab9d3b98b068039d1adb198f6ca477de98a7c77ca0bff6fc7e04a19e6cb2854a54333bd3a1bd3f9b0528c5a6ab5359abca9ec2ac152dcd3d481cb434fdca9ed17de802c41fd4e8451ce18d38e2df7f6d767f354ed1ca62701d243f0c9c5ff1390f98a2581012183b3aa921e7dd2d1999b58a3331f5da5cc0c1fadc3e129a6e87c9eedd9dbb045b21778a37af038072df7a7318f885580127539c955d8b0141bfe23440e80fa199bd7458d498ad861eed65e62cc6955860dbb3aa8011cbfe0df1069eda1b7ee3a2209e7e8a15f1feb77255d4208268f3012f7b2dbc0f4e604514f02091e07b2de0b77541866f8bfefffa44412adf5a43a7b3ce1ee0571cf3d1e75f7580d3c396882e3cb5fbfc48780e772ed56629108a45b48f35e8369e958981d0314e5b014b0ae872f0121a8540dcb4c314b8fbd6a050ffaa5fd1d33bb8fed91f4dc91b82d15a9253e5bbb9ed66097bccfde6e10a2e863a3b8b1f500017d76a0e1bba302ebbbc149363042a2f30866181db36524d935ebf5ca506e9a93acb07022bae3c44ba1a3348b26118a4dfbb76eef3cd6ff5ea651f8d3651aadc4fc94827a0001bb2b6c756805820698ae90663860cc36e2d4b40b77c7d71d379a80ea943fd6d3a1db6e97b6004eea384be023a438a3163609b543f5a8847c74d800fec809e492fb0259128f5d145735dcadac29b5dbc4c7e11eb5e66f2deebdc9bf4269a848ab601d747474d8c2db686e012043651b8e12604bb40dc97cc569db1e9a3370e2cc3fb9207fae9cd5a1da7c9f794abc2f3bff26d05da60bca9819305c99a1fd995d5e8dee283fcdbad3e3d58f5f21b264690755cff44cbe87b4451fb87d8ff1d54a36d6d5bf90f8527c1c84bcc7a0f9b0c6e894a41ba83b77d597447f0a595d590d3a103f26c48a2e099eee39f414ee24ec4dca9b7e0825c9962119ca916467201b160efd1fa4c5ae43aa13b029ce73905e9e00a59859088a461257fd87a9cdb8ecbf2704467802525dd2243039594c3c0e5ff6e0787d1e4f076a1b026604633e6de2f339c76a30279fd0bdb45964a5d23722d23c2ebb45ec7751f3d9ed9433d54748128dc8047292e9eed88930e62393a8ff5ba2a4767eb80d4c0806fc43ad378f81753dba8cab12395f8703a0836c74af4169b6330ef2a014f715c6b2ae4ee5b784d5dead7abbe89dea993327ed454de9777f74e1d2d61e47a98cf809219e261458043bf9bb0f3214505726a45ebf2be0f3d3691e19b69fce6babbcaccd82b053d0357579c46b179e6294c01fd06b01617a7f3a1633f07cbe4b945f9bfb32659152ce50e4d0a2b899401b697ae93b7d7ad2249934b393bc458f5fd6b02c925437dc6c04e0c92d236029b94c2b58ab4bf3b06d022e9abbee0284b1fb6f7fcffca32b54b4aae912f2c607a8e9941f61e851a95082ba51728925460c3c8532888ba4048972832d15fbf91385be29cac7c0f62277f5dc54f9a7f9d150e465e963c44154bb0d293c59ad3c2867c756f551cab004a1370066639e91f48ed22b387194502e7b7ebb60c85544f82eef9540ec58521c7f9b44367cf6e3dbe7bfc82a1c9ae4a4a6b67a17d4e28feaa15b144962626c0d6ddf2461358b5d83d8937c91500d00a31cca4caafe53d1ebcc5fc6627cf5285bdd553086b24a663445eb24cce3bdc9155093bbe4e704252ad661d3ca762e668a390da1653237e6b78a0c31f95ef3421cf22787780797ed269b0d5cb8a7baf6833d97d986a2123394f687fd5f73fd5cb12fe80d57a5c9b1ef53c6865d81febca726b475ddf2c33bb1856c938306018d1a5ea5fd89bd9dba27e2998c195b7e1fe9ea27f9e368cb06f7cbdf17dbb64ef067798cb7cbf6fce2f1b68ff9bf1dd770b20783915613a68857afdfc402f8faffed69d133c02550941137139391fd1797d64428ad002f4c204a2bf3202ac33439df45cc574b851a78c842cc2d6b98610adac570ffa33540b138757703f9b0cda49514e27bc9d07db83dbe75605e735bbbeab58c7f9301104c500ab7cc1ea756a1484b615a9c744f85ff50161a782794a5f67853d0b74abf19997f50ed2289aef4cf9cff35fc0d9b2b85bdf3015e5f6e01b5d6719c8ae0e913ca3a0ce1218ecc3ecf57abd985851d097aa212a1b414b1f7a6e204e088187d32ceae6ab1b4f7c2140d79b8d8313be3a33c93508c976ef6c41d7953774823c7788ee265942ba98abecaaa20215291265b02f8ef0731f1cab4ccd2e7a42d1a1a619b826ad3b6a79bd80d0f45d9cadb0fa3e4710e8da5aa0cf909f90f9883498660a9948fed818bcb01cd48cc95df2fcf7989997b886c25d760c9ef72bee7b47bf34c4729532965dc6aab1041761c89fdee18ca9e11c9a2a19db814078ee48f734b273681cf6e4409203b866720220410c5a0af51d2529d6338f59e5c571b6460de90117e1f1b26dde5320991e6c16cdf35af08a724a249754aa1090cfc71156059affd70be1528ec31c45bf47883bde0bb5882bf8b8e1095239df662bfbeb037baa6610305704dc898625ad03eddb7e50cbefe178ef5ed5972a3150579e01ef312d05b71f6af2dd3e9a96f47474382f3aba5fe047103693ddb49d206c5b09d32ab41f4d7ac256b8f6aa6538feecda5e7eaa493bbda26956342937a4e48dfad731d9fa7a78269823e022cea50f5b6a1a0ea06d14bd5146b772806a8217040a05a8d74c15461f4ee05f2ede1c4a0eee9e3a83ccf6155c85b598674ddb04ecc2a1c756f3a6809fecbc9a65e3a3ef792cab177aa941eff42289686433f738c7131d691f4bf35d3d44c270b86e20b8cb768585973543e9a2a5d4196e846c9f0ea4423b2155424b1d09216197204206643678728436829da45f08096cfb779112817f502f7ffc8cba3f8d4562d6cec610051f2edaa25798c9ede5257fb582fff3673b291c2123e687f322bb968288853812e4cfd55099b75fe7b7c1b9e79333c0bd51a7d64eb24eea50b7d9103e65cb439d07be582cbebec676d5b276892e578afbfa99abe732a04774865f1622fc452b4e10f7f167b4c8e9e19dc7dad0332e4454c648beee123f53bc1c4c833c8d4bfa3481b5408602248269c6738ecbc30f86dc98c7ebf12bf857feed5ff3c3ba9e2447b08021b1c8a3f423821431a36c8b57c84439aae0f14dbedbb4ea0e1f86e0886c2b9c51a729ba46e85e4afd8528bb7966cd82da11228a6ea8324afb7ad82e0685f6aa48baa7a53db99fecf6dd1c9f50c54f847c7eaa9b5460d0b467ae5ab19d46b4009a28e2ad1f7f519c977e761ac2decee17aa39d26ce723bf72c94606c0ceff248fe414526e5b83653bf1436dea2d4715117c7a96f8ba55beb3fe148c4e2fed19ab77da4c24f41a48e2cdd24afabf1be06d584b0d214490f435230be3e1ea1d794b5c38a7adb9fd505aec01695edb5523a96bc24c63c6b4a380dde98903985ed07205cc5b1db699651e5910daccf71f5086a30c813d61907ac310b6aff992f4d2c3b605e10723ee030f0be0adeac31c0fbdb682adcf2c51d92e701b4cc7512589492cf17ebaf6fa7b03ba1f808e6a7e80d07d22ddf6a66e420a13256def7b75c84c38fa6bae328ed9260dcec4d59bb953f520960c67f440de7dbc7682523ae8c6cf9cec095fd9db8d07b4b1cc1034989012a4fbb77e09e404472107698473ce51d937a2e6b4f23d091acf3af68a26fd06766744e157b831fb4d24077af71d68798d9f8b35c38a110785acbaa842abfeeb1e54722a0f8eb842b901c8b5777b2011241fa3423b2feb3ee3175cf70d8ec9ac734f069b2147f3a6b56cb8637dce0978d9b7267f25f194e8d5517ed0ce8c01f7fdc4a57b2e4ff171d953d73866dcecf8ce1b322034abe59c1c62be99072e983711eebf9d10069a5b49ce950892c92ddd2f31994ccc12017e521c79a3a55e6396bdba461cc9545bd4c970b24555dc019504e22218ae126455db40c65c839c88439d65ddf285f97944230b6c16d42c1c4252265d9cc6ef4c2316a0c2dd8863faf8e8f512fab4b275434ebab79bc60b6c580e3eb95951a18b9752ccea91ba5e69d7c2ff9b80d0acd214566d98e036a8311199445ccfa11927f58dda20d35ff20c56692a87db7404047f0a716fe95e80cd63e810923ceec69097994060928326042aca9bb6cb762e36958a15d9c757aefd82a33fad70b0be98ad8b4bb1b38eddc0adb395939382a004a91975c6f7be8b5fd477297654db475dbf022198fd9e1d5b67d669f0ffd419884f7bcb81ab4b5c3c72af8e3c4f1a034db61a86bdd7e76d755aead6fb5adfd4cf7650c6cd801386a1eade64d2cc70f1ba1baf42414c94a3c4d9fd45ae92b72e38232540b15d3d014a35fd786c1815f0f83cb7d2f61efce2bb67533e128fcd50813f144041cf617e6f84ea3085e2ec0b0ada1bc4473e25a3de1b575a56c650e7f375c5ea97d90fcddcb2f933047ffba3d51cb5aef4fc8ec24a559084d8b57f1ecad299958667c5e7c1d62624674fffbc62f4b93c5bccf3d38a25730646c08ffd1ca88761989e8f4afe8b9b076186c5d39371df5c1a8a4bb812efb26a94e1a03594103eafbf81bf7a1b3cc779b05e353e6c67b0e54ef5bffeeca15baef3ac7a8abd82d6eebeaa5b3f003acc1875aadfaeb7042c62791150c4c18949e62886f2c768c3ccb857defd52cdeb04bdc1059fa6b890049af4711d38653d6f7ff324d2f832c254c2a51a333af5b23fca7f09a571b26e6f1e155504758d4b220b4cd154d79389021f0ea38009c5f07b98bd122809597fb58097031e02865b5ff042b22241eb2832d1f8411ec4c4d57081fb0202044747d872bc30f81c7a0ed7ffea87dd11f0917fe504105e06201579680fa270f54a75ee10d5a48ae9ca70804732cc1ab8b46bf532f752ac72b3a690c912a1588f886856b7cd8c28ea0688a0c82c5a93f6ba734510e42950006f62b814c4041e0eeec7759bd5d16e5295b46d824169cb3a34299776677c5a4c1af585fde6d3610e587a33cf061a8eda8c0c9027bb92d2b03049ca83ca91b36c2df9b518c72fc2bdd300b51adfafa147c60e0151c7830b01e2508038d3c05adb0834d80646fa85453cf9d6f372f1aadeb4f80e1945f29c4e5843bddae33e917c2d16582d5ec2eacffcbc07d2247a427103c4115d3ac96d00d1ae23d929ff02617bc8945c799261ba20f8ddc769a7439989b63c321134154934f78b462756dd4bb4b09c4aa74e58f6cd2e0392f1d1c2eb1776b3d96aeae7920c0a65551fba463c7023c6272536ea4e73b66849db8056cd44de857b823e443df915b801f9618df373c1fd158ae03a171e14fba8bcc8a0ae5201ba855277f10b2f7bd61e51b8dee74b6e373243026bb1a187ec6b498fa0834bcf0395c6522717a1dc8e2d36bbc9dc15930917f21484b76d7fa6681cc80ae71146931b804ce08efee97bd45daa36971449e9a90fa960e3391a25b44d514bf5a0767f016efc9f4fc1559232fe6c1079e23a85cb432cee3616c313f9e90e4b8bc486f44924eb948d4ecd566a530acf731f031b5374abbd97fdab567ae9a3366eb14e9917c5ef0c68b44cf53493c047085bf5ad262a16dab561c46a4b8214e10f970a9c096b54657398494e925ef362452c99eb2c71d0e368cc7a4927da65d56c5b424f35cde3c580e3505a771647a27ba7d29b848939569043da9dceefce6e5d0a15f09d91ae3a25caaa0eab8c6825bef8c86e356adea9eb67a08587f97c42a484f563b57b2c857f94c93cd1ccd237255ea6d0fbb841359ff99c7eaa3ed6dddf3bf9978acde550ba46c88c2078c7aced871e6a84b5cf07cc4de51490717dff6bfbcb582e38949bafc40097372a30fe8d6a8e160b0fef3eb70f105313b2cde9bc2d1ef91c8a2733544d59d51b2b905d2ce9ea39e2089b29204857cbfcc36be78a201bd956a2650008bf12ddb137021cf0ecef374ef81b60b459814a6368240b424ec2bf6a4cd9f78f72eb4ae3b8d13a820ac0c5cb57cc79b3e240333a3c833c7824e53f147875ad23f6f9c6b3aa44e92645dd5989c2e65a92fdece6c1187eb11543b9d8a82479d94928b336b1e173afa55dbae5ee9b3ff741e2591b63f0b0b6a2fe27e4238657467dcb07de343a67d66a52bc73a5ea74c5e43b42074a7e890c334bda91acb7d318e5e095eea528723117973846ae936d015aa8e49310a6aa2635ade1f66d57910fc763020fa5dd6372e5d99e397668b8bb7decbcbfa30d7f24bd11ecf8777ac976b16aad4192fa1bc1c0bd97c803c405b32338ae3322431ceecd593455f7e82aebff09ee6c28d6371b88deed5f4dfa6ddac195494e4028b15ca7cc8f357f6a6311563315ddbeb084bddc9b67a5d21e3f9fb1aef2fb5fd3b97b6f53a53cc5d0c3e125384cba725abc6c8a6d111ce3e8009cdf6792bf419744658a8160c1a81ac7545a0aa4b9aacd3a134b1f5194d780917de36e5436e1ba4287affdaf8d4e2c70049935ed122c77dc2120a6c7b92bb8bd46fde9abfbe993ecb8300ffdca15847a403b7273515b8644df1b713b0016301f4a3fd7d8a60d9d46a923dd8c70f47099a8410644cc5eb01e4342177eaa13e0228b092e457e9854a4eca9c124372fc60b587f1090da1d0246e1efaf10abce52fbed1537dccf6138f145812c61fda36ed1ac8dd27aec7edd2c1a7dc31bb9ca9e7b7c8c879a64011fcb960138beab4eed1a5032288c96e0ca94c676f82799d701783e98511f7ffe4ca5eaf65a5da67d244139b6a590343012edf21072d4eba394c984fc96f940688f09aa9b27e261e20b1ac240d1ae0aa6a3153b15a7ae83b2b8347eb64efd6258102ee25a5eef6fbf0cabf8e350851264fbc65f8d2ea6a87598fbe6a15b98cfa88be168a0e1bcf114012bba8c3f4f668d4d134df58d63dd691619c6f332f07e7b8a534e37f90786079983d68c4e3ce8a8e5d70fe7f2009b08f0186c8571f6d747dc1896b31dcdc8e3a43ece788250c0cc8b8e836bffed666d4fd18a7035a29790125adfdfa19beed67505affad2ef74815af0fa08b341efef6e775841cb53b17144476743f76569182b38bc795327e42ea4916465e7db6a2cb2cce597307350a032c32abcdeabe8482e079d53ce0823967ea22ba5531c2ee6878eb0a1b481a9be9c3b65b65db008b63f2706fc4648cce27720d71ad8e4ffedd2bf9c8a8660ef0f38bd5556777fd5af075557d46fd71ff29676a7ec25d1f65eb4fe3733e8777442f32f70ab5a02f592ccde8ec21e5773919d324f5f92519dcd59c55fc8987e1d2a7529d78d2394d9c0745909eeed0c7a0aadb12e2df43e5d1a1821a3c006e651d7358690347339aa932cd8ab16e3f80e52348059eac2f5574fcffb95af8933c83fc0678dbada22302e283bc5989420f10a9030a8f002b21d44ab6be60c7c796f1633f827e28ed4134cd865798b3cfd43349948bd6f683b3e42aff8347819c10e54e6755a27e91a29312741783a52ae8c2506ccc1ccc08a95c64d49db5d995bd95875e775b84731c043e303893b4855e2ceb35f7a577d21fe557f847fb57e8d0f959e973601c184f6a9926f57ddedf9e2f0da34ed5e33a02e6910a72ef871765d98b79d2cdc40c0add22b2eeadef63abba05fcd4af09fceab0b8443b200550eb72b2f477eba88597d417b6e576d5152dbbe3ba12866254f5dbb94103814abfe24f0488d07714ac35e93fe72cea68ca243159874bbe32c993841b2b5095b3b6019e5aabce2db9b779b22f72f8cd373d08d85054929e8653466c1132395641b8ae2459bc396e64ea5b0f74d7928ff02e7b3b1b5554fa4e6ab1b23c993785638ddeb3a4a6cd7ad6f5975f4a151dedb714ff0a4fdb0cf8a0ea6c3368e078691fba9008c2f0d637abf813533a9d4659c5ffb30e053ea349e0e2e66db65f1a7266b7c72a3dc114f3dba20a0ca24c9c9366d9880ad0919cc31baaa65fd2c7863e2f975440bcd89b654b96233f02c705a67af2446f14a2e599cb195b22c7304f8cae11a6fa9b36d7b2a491c55c6827b4b51f3a1c6c1cdfaeb1c63d634f8a719ed9335fe5e03ddcf87886c29e7dea507203cc033fe3541f8ea7b1e4999103f8fe37d3120b32babac474325da6f483a1051745c66b2ef0dba63251a4af4b9fbbbfdf70e0b23b8c773667cfd309b322e824ccb991cc52edee4ca8c0a710fdc1cc01a7885237c2cc96bdb4332f6eeb69748e4dcdf1ca1e6072d1a753cba780b55afdcb166e3d8d3c4d84234f7f180bf3ccbd9cdd19f246c13a8ae365daf4fa64e4bc1b2c3f8283ea6c2cf18e0c4293403bd180ff14cc2b68a5897c875bd89740ddb667404a6f395a6b6d81aec3bc34de898f6a5064bf5a37cf8506c9963d729b1667dcdb4b865fb553f6ea1ededc3a729641f63bf91f402331b4deb2e4e36673bdf52453e4bc2a3709b3a1b10942b054b09759b816a70f459ddc5e688d73725f59063c5cf7fd4f8a39a99e5d5911ee1a387ede758e87d1106be86d0c58f2ffbedc12d0c85fff4f312e1164cbec98af9c7b631710cae90fbe53bb59b4c6972331ca59ca936f13e5f7b834681cade05e9279100286dbfef7bd84db816631e7e8b6765fbe8dcf5a0db07da0aaf684caa1a5e297fd840441aa68ee0c98facc1e60c98fb8b0fe132c911f7845543bf864bb873bdc0d40a30dfe673b353da7534d2e21efab136c1782f80a6778bf8782a0adc7279171348d54c86509d03b7b1c23a3ae36df223db91d305a417d4c4581ca63b7d36cce9e4dba7277b1642ff65b30e579c237e57211274ae0c081305c21c9d6c28afce0fce7d776d4a80018801a0addfd5bf0beab900427e3b173f0eafce089662961d680709c076648febbb2c4e2c39e8dd71c202fc2d887b6a8c4476bc6680fe05f312b2ef338f9504e0469c1a8723cafa0714bb61e0916d128bf61a5e82274ff55e27da7feeb4a63c10c4c73404a75728d50541497da9a2c7bb26e8bd98f37fdd016408b3d180f01b5d55a8fc05f8e55e70f31f16855b33d1a46a55d1e5403487f76e00827b0aa0b688b41bd9da45516abdde430cdb199f47065010bc9ec77543566c85bffcef75f07657107767b5be1f5151d7c5f91f386f7541d9f03afe44f6e424b77707462df919d405a7694a26b4399f2999f37ee23a271638df7c5bf681f3d43426fd0e2e6095c2d8f5b9dfca3caab05e68a8add32276e548fb1646cb1a695706ab511c210ff84ce864b8838e996a28d61e0067d84c3199ff74b233434b11d54c146cf2b689ee66a470955df6c3cabe06a326aba509f814efcad4fd81ce6d9a973cee265cab5cee15ed0864b70c4a5da137b684ddae8da99783a08ae5d7486462bd8336138e96153b905cb63a0e61b52766e84fbec9afc8e4ebd40c3e1c00408ed2ccf182db28355e87118cdcf17eedc8da1c1b85315abb7d8686690371fd17675e72e956c6e9cd20d7482885c6ff809565b11b34fe9b03b305dc48c468a5b87f99c54441600ace9050272eafb48ff5ea5e7fc5f8544c63ce2ab28ba41ee49459977b0b0bc9f81f6afc992a65aac97f6433ba84783c4b6f826810e3a2af60eded972b5468e9e972b1fe04354a8c6fa4541b4f28784fe2257443062602e5651b897e7a83e981e5a5d823fd4f02d97e1ccaee3894093bc64fcd9e4b043489584d11f3647bcc29c1a17836b0405fb93baae6781512295ad7fc14b87f14a57f1e2ce41a77dfd7cb88b3ffe3186db9f323fd9506e006ca4a0c1b5a545019dee42ed38389f466a742b22ad71d67f6106a67659ad8a621fc0f76cf8029670724477ab54109efb2bf7190179392b36d4be581fdf0d54d2864d00fc5412b3df153ab5ffe9aebdf29103b908e591965c31a316288e7a5a0300677af47bf88d6b87f80b7a785d93ec558225ade934b2423aaa00b01dde9386eac8d54174552c215a6d7cae0f9ac09b7987552d7d5451c77d5202adb150c9f581ccad478bb36818763f06b9cae5e965876f02b15a323989ed3f1b2bd557701c155633a8c904d62dc9c3fd46af3932a08fe8915b0bf588cfea2cc60b2007b6aa03f488b44a2b6f8d93fecfcff2a42ebffa10969b63f3a5fc22026a982f667ddf1b017d35ef5479105f38278ae65aa5a879ce5fcf5438154a9eb69afa829d449062d5a20e43d577a6e13aced31016307573c6001631e9df79e40663b3b5a3ef4f3ef0455422df621c5360353e1cbb28e5fa706d94d5f2fed29bf8ff8d91c64db3a847bc4edaa72166c516a1b6a5e19882b935a0b86b34031f77e0eca5b8c5e18603339e871f7e8088124c3efb631b30735bf410681f47f860b4e9fe1e4ad2933797a1f9a0c1ad6bf92052a713f171b9cb6228a0e605fa23faeb7012ae16ad76bd68d6c6ca95614e85526df8f4265d188c3477fdeb1e60ea98be73412026a709c65f7c3015a5946e208ad785503a6fcca351bd2d55d544bbd833b3ae9a8635c86bb5b5e47b5d52ed74931923589276086852e1bfaee49687b261be3e21312851f997f2787686f5147323ffe0cc45b8d8ddeebdaa8b73b1a58862aad30186cd5578b9049355c0b3b6cd502141c18bdb47d91f129eb73da8f9563d152d68065d1e32d1915a77d258c88ad6c7db3cb32cf552e3e90308d43abbd6d5be8e7c0074bbc294dce1838b7c4f847cedf4b5185fa1258b28ed87df157c3e529be7495061dd3680ee502d0f790ac862c4d6df0f7dd672d53b1c8d022d9503fc952f74881ac69530d26b2f0ae8a4f78e12ce4d57df16ae63e5d10022ad87c9fc44f891eaaf7f7d1c6b0ba1cb2e2d0fb590bbe827def85e5c089e97209511b675c003c0bc09c1f086f8b1196e958adc29c52d945e5679692e9ca47260455d0f5b4f483","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
