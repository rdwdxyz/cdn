<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9abdd77341755f94a29c981addeb522fea8b9b229e343c7502409796e263c31a6a1c556497fb64bf027f99ddf76bfb657c214324ff4e0c1aebe9067ff11ef42f7936a6c77abeafafbb2f09ea14702299f9d85ee78adebc39090ba3c2331c7af893b5c5bcfe8c4bf331155c6a4c12e3fda1069768d46551bfd1fd8ba1c96459132634c7b6a6e57f111f367445f6a8886621a0d345c77b037bfa1f1bc23f61b8195292e4209080ab6ecf31b6e92261c93f865ac304edbf9a3243b2a05486c827334575b643a50a080c7bdc836d2c3850716ef738f7078d0afbf1dfb9393bd9f61c7914adc0b99df1d847c6ac060a6ba1be4e316322524862a2ec5dcece42dc86a2b2bee4ff37e764d7f960b87f933f89b3daf7a68504ca06b8438888c46d5b7b0a56f72337007f53eee52db8d761a141342879f0b186da80815bfbc0ea3b1394a5b8b89d8792f7a8a7b7fd1dc17bfbd67dd36bdddd81756a7ecb3421c2993f3af11806f75ccb97d39e5f29591174d3fe11b6a0a6254c3338fe36f19b997fde43a4c91ef6fe69fe18fc41dfdf83542d4eed4d731ae235065ad8f5e1f670e13b2704f9c925c035d3e6c2155fe2066667a8811dd88615bb32a685e67e0ba11a946e68d851c4fa19cb23de3d83696a3a527a19f618581627619249aea128277bc4c99901f1c9553fec068319ab4c029fbc9af5a7a49a4e4902d775f056daa400a8193479c67123f453d8d49b6f04a0b84ff9a6dc82a3ffa1a1f06e93d3b36fb6f4d701f60a76ea11e2c20a74c871de6d74fa31c5860a401577dc53f6367382050baa32cee2de5a5ca9ecfde115b8ad97f02cf7aa84971a36d43a9ad1b32bf549a1606c557c7bb43476b141960bb5bc40c75415224163e63f19ec69a7a9338894d85d5b0e10a866e560c2aa2513a86ec12e683d350588201318aebb565b22b8317abbac387bdac1e9afa4a6b967fe33105856a8223278ffa43d2b453ffb95434a94a25fd06792f7f34236d0da1b0b51f56ea8f7e74691c34e757216460a628e28529a8d01a33e17d12a7348d2311ae4627f6a3044bca9537fd48baeabf9e62393caf42c9063b483198beed14208f6fd9a7e9136523e668a96558fdd78dcc14b705d49a74973308f1255693a1f752d51e1b13b95c896189658f1a3f4f71edf79accdca01b9ed962897f18bb405b60a8262ebff93bd34e13a39550836c845437792b4bfec66022c7ff1961b444a1dbe80a0956ed7e3f75580930d161858e59b0df53f2c658c582ef8cf41e7f06e25fc8630c1fb01d3acc0d84da47ca432d49090b7514ec490bc1b38b44ccf4f87f7ac6aa9a729033d1810c5f5312640f525d20e2a155962f6a9397f45fa4325141aac9e37fce769487d9887ffda7ecb7945dddbc2f566510cf8f95c8b96ffede6dab44294efcab00decf62d44af97b587ab18f494ce93fe3211b97e4937f65835508a4ccd3d386723cf5163d8a21c9418f495394d12165a0c68ba60f592f8ec885443d60cded4f04bff76edbba27f3336fb0ced514f41104563c1f10c4f4cf2561bc712372485aa842a5fe664e8614b62984e3da5c20da40cf6794c3117f3f04ed6189de7edcd323413d8f383051f1552feb84c52546b10bac25820fbb3b6778738866c27932d02d3923102ded2a88db8ceff1103c43f81431a87553899ec5874ecefd8a8f7483f892ceeec2d9f9b5d03f082ab22e5eed019d14c2385363e5809186598b76c884cc24e71a0f6c59002132a5cab2dde7dc2382b3178183d1c398a6c155290ad01428f924ab1f3efddd644f40bfea66a8cc45b2ea8967a41c02bbf8c876a8f615ebf667cbbd64303ddab1a1ee50439411a4ff9ff702da955b2948da803f2a7b5d7e38bd9adf37cc9c989af68524064ad2e27afb4f28f1d760ad5db147ae3e8dbfbc94be2b11c86352495663fe3bee7860ea99ffb44aa2a00895244c4ef01098ca5e7a58824c5337f97c6cfb4fd6147995f8d0697b781c25f2e099fbf5df797bff7a68e3938e9c6dfdf904647061d66579aca00afb20ebcf7c2e05646e723827e2df14b482ab206cc695248b74c25078b19e46f2df4aee8e41cb6125272a277767bbf6390aa8b922f7394667c0c2e739040f70d495abd2763e9d780fbb1f44b811b0376ee22f64a7e2ae72e4c87b006a508d8ad0ac6f98a87cf51fd4575577b47c94f96409921f3ff5fb71dcc6a247019a854434e7c6dce8057c20f1279972dbb2e02719016674a4fded44cfd036ec350253cacd9bbed63f59d896451be02be33532d4d45c2503d2aa23ed71f19a71fd49bf53b5e244a0b4ab571e87b2bb8e219e9121c4343bda0be703c3648e512660bf7ce6c8317c398e5e285a4bf42c895a56e704abbcbd6b5118bb476963ca2ab260d13a381bf1359cac4a81f4a6b8520f837af8b7994c96f1676c9fcf82f8d32b8f3e5e5fd728ed30e8481e971994781e42e29fb5ee0c42f00a8e6dfafdc8c7b1cc8649b597c91ae8dca23eab7cb6d8fc6abbbe7a682f11f32475a8c893515676702edcd3360bf82d044c7e84c905d5d1f700e6258c3fea4ca44ecc1b9d156e440f3f249c5ee27f6bac38a5d700e749210e4fbdf8747db80f696348f8f011896a7f0e302dc786b5199cbac7e1db46b7e4b238b816b5bca479a49c3a78c110e814ad68d175cc732601d0b3b356618be0ce864e24d7d95d101bd09ebd96b47b77e2b163079f9bbeba8894f06339a1da58792d3f4312a398cc0c3fea054aa956aa74a32b720a83a6c92ae401a404e861c7c1b45c443ec455b8024c0d0c6101eb2425dab7a9473bb1d482fbf8cc1e36f81f013025f015b1f06186d93ba360ee10109d6fda238ad8e5d48dac2a8b72b704ed6887f8f8fb6e3182aab6b48491088c10a5649d1062b7750bdec712032dd8a86bea20f39ccb08b5bb1ec4fadec266124a94b2c90e713ffc65b23dd0d26f9095eb0378279d81d5c94a2df98435d6ee892c1dcdecb2a79716e82a10240b7281c226ec84a55cc0fa55457e94210e5ab6c3733a93555d1c52e4d762de8a2bff0acf8c1cf0ab569e65e25200cbc4156c073f9568b9b83e7e40744448e486b15488cb6460dae76f4dbdae63a35b1082c151ea4de463a600537b6860acef4ee2231ddbf0bc50bcedc602ebec8d851b2d130b413426a342f2bbe6d89aa1eb76f783bc9c0db6fe810a819068e1d9e2a6a1d055a9f62727c864e7ed487a78a6b09e4f0285c00da59a27b348e8988960c5ce12429ad1c9c88cc6d366e291bb89e34c8171f8191a4b7879d4e5e73e5973f354e24ff25c33e73ada8ff9e00e0030f64d6406067c8db430401e64375850d43674def09d888caca6afdf2551bc04b7a61d981241dba9422d434fc4481a820c98770e64c700444ae3ff601abf000e8f1f6cfeddaffd20350f8686dd4dd398bd3c5a83ec3ed117a8e0f2d468721b0332164cade9301ac2b652cb87e4383e9e38940e8c5d3f652ecead1a51a06b76a66e27c05d6959b2a8c6142cfd93f27226edba039445eb5a00edfb52c0fbc80a7df916ec70eedd672b717fe59d59664f353b0ebadfb7b32ce03d0681ea6a1a391a39f34dd45b2a70597b748d932ad9f01afed8c070d06591a64d1543fdf4c6aa8ec0be7154e6500001ff422af95fa2dba2b6228cb508307e2c96a1e77d3cefd6843baa6f0b509a7e0786aaedbfda6d6f7c20c893c11e3ad72237994d5a4695963ae342794c661b99d8e98f51eba0414a6c15c70aaa9dc78546601daa618d36f954f6c0dddc533366085d5f8be5ca5e1e50f01ffaa3501ad054b466401ba88ce743fdd2c8c76b6ea2f53864b8dc02fbf1899362d4acd63dee50aef0a8b5f55f0f49ff4596264c5df3998418931f35eee6cae98738510434300780b034aa3e181833bcca9ff8c78ebeb275f9c7e5115ff48bded6a9ea0abe23d75c8772cb2980a0301f10b8eb346de141ce95a4c164874518fca98a395e1ddf34bde95c9c235f7c1d1976ddbff20bd1b325806c8b1a19716d925aa0d0793162d7b166032d3393215b4297d30c5a8d7ada34378b616cf37f63fe15b723203b8abc1be5f0209ab62802db2b5c9b1010f14fa080bcc33fed182068495a8491f5583e6455af8760cc4ec99a5ff517a5bb381af211297f6f14b0bc853388c2097be624a5d815cfa30ce84571317fd862a0602fad66c8df3c0ad568c617dc21d9189151f76a700002535d0f84431ef0f5028e7a43456f0f019b19a0d70b8d4be4aef712038eadd996f101965455e3e221637967cad3f6dfaeeccc94bb95f022e4e8c4520164450a70fcfd80735e7b2025dfc7b34f50b0058ce83caa264658be22a1cac2cdfeb0b1f42fa45bd1b75920572ac20810b34db02d2bd9c44b4d73deb7b427360351dcc23dc57e1ec2e1e2173929d7299bfc56f8dc7be98dfbc9af668ea7cd91c991eb94c42d5174f3cba4e1a45e013f2c94b9997b5ca180fa26af3cf475700b3ca9bf8f6f29fd1e3f40ae79fa00238eaa1118acc1896cf1901e9b9ceff3af16700b97275599543843faf6a22b201d669ad3f1a230d34f4438ac6ef98f5b71b4f361bfb583947db0cd712249fb5e9e635c833f97301897bed2d6692691535837874cd7d993315900e1fdac41f99779a5a4e8dab476fff1ee8c0383dd113d29e2017babd96982cbf78d42048df708ef5a34d47a7a9e227f4d300383e0cfcad7e017240b5f2d5fb00f7b148a8b409160d8f13eb2671731866403e8f16067169e3deee4a8d399de8093499acaeef646b32d0fd2b4dae906e0eee09b7bae87fb80982c309274ba43ddd434d396a6aabdd855410dc2b3dac5a1a3c8b561bd65d9050d666f263c77ee79fd8238e759f17d4e976346b0e0f19735e992556596d5b907e178897f5868280ed11bc2339b80eeb94140f63230ca903ce1857baf0b37f2914f84444305990ff8d1b5111582c769bee8ad616a86e575c8feceb02466f51539fc7041eeb30871bf8a2ff07d3a615e6a37462d5fd183ee948ad422d7a3ebbed054aab4ec1eda9353ef8ca19ad8442a3c1c312b0b8c87b9908bb7b9fd940afe8bdb52bf60e2f6aa902b74ef163ef5a8dea1b6ee73955e5e99e7ed1d2cf31d3ad3cab2c73f83884871d42376f84cce3c7d9a43eb1423f8abf85e9fa7938373cfd90f4c6c2a12deff997f0ea14d1af049ca343fb0670a2ad4e565e84877d089507e2ecde44df00f1cecdeb8b2a8626476c7ba164b10a5bff3df41ae2399f5ce049cfc4b21d4bf3157e0fd4952274cab5d36e5229625cfa75865848eeb79706e8854cb78848016937ee8e5e1898e0ff57f39582ff3616061e5bf1cdece1209f3b31719a34127f5297d62bdd40ea97be3fff3b1edfe337d6744402a0793dd522de177275ecbd4926204a6921d7fdbfe7a5b7fc252de18c701f21076b560dda1018990849f034af42a2104fdc0890a86c410da65ac789bcf1e4f5f2d64422c0cd4ee53cad036f561faefb1bfea9066ca8be407ee86015a71911db5cd5d95d120cc18a5d33758e465e50d067c7d47d57a03948c0331c10bc9bc12bdad008ff49cb6b0b1786ee6fbb6277ca925076e8857bfdbe3ac154a3795366b7a169bb13830fa2481992b080251c7b76adc458f4580121de3770cf5eb559b65e35c11b813fc7756abd43e68d5ee88e10664a008c9d2d05bc2fffeaf2597ff069f4b4c73f280fd00cbcc8e15c94627100b0b64bd60d75e8eab7874790febbb38441aed39e1ee5beab072acc98196345bc2e2417efd3075db5ad4d668191170bec4686a1fdeff948e6f2d5b512672dd9f3f55441cd6d4285736225fd6079d380dcdefbf43c9a11e8d8fdb212d934da23f516cc73ad11f4a15f16bff7683f357268c17b9c38e3c3cde71bf07166e63f474ed9f54f563819d8e78d682146783f719d81d720dbe09f136c75d6f94b297c31281836fb2630221d5fe2c5237525b82ec27a1cd1fc1b98467dc52d96faef1bbf308732e5dce7a6eb9912055f276ee088de7acdefb6a6bfb744df4e19089a1e98c48e5fa5bf34bd31b6048039a8a52f599b12b05cf78499ee3eda01ed312b4f9c02a1d4805d9b6a67cad39cbb37bdff147dce414599583b6bd0b38388f6a7cb6744fa7767357b0b90886b516c99d631c40cb785863a8f1a36dddf9a44ffc1c772afd97c7a8992db01bad613d179241f8ac1b224a7bc2e5e3ce8577e08dd432af67e09130d65319dbfd2907e8c7d6a8f13395df64411bcfadf793cd86e8b9603c347d62a18e3589e4347c3dabaf3b14ba92421f034c385538698e7f79d3c67ecb3136497d9232c038585b01883485232f670814f833ef0cde62a2b0bee59c524d0852630df50129fbef29e575df101ed5e37e2674509b606d15f0648d61168724e76c0c3fafe3208303592c74bc42496da40db2b917bba0bd30c06a27104aa7a35b6d21bc51bc26a1528123b134a52b1cd9903815c9f40d7d35826ac8f48f40819359dbfdebbf31b15bda54bb1405ec1a87c1d0109159c99e9c55c8f77c130bf8b412eaccd05f4f9c15992c15827649f64305c018007a376b64036982eadeffef3cf9b8a8d9619689e12585b524d6f60b5be287e1a759e636a8d49518e0e77ed1bc3da9b608dd650f3ed0a632315bb0a2fdbd9fcd9d6dc803fc8a18312a45548b2f42931a0e24f3d1f31f27c91554003c213ca6db4754708807d7d8f2feb27955c92e116c1172b4eb01ead1511ea1dce7a7a4f10990f77fa35ac025cc720c0c212ba0bb07a3df65560d17af4959b94ebe5a9b87437d66bf89a384e3835cf7a74adb18fb112c34e1c23a283edbe746284f754743ef437cd1b4a2cd21e00c434011741f7bfb31c3d161a7d4d5f73c5412b0d9d0f46326ce3b939f6a76d88a9cda584a5410a1aabe4904ef06853b601136e8231b01e4ea8f43991b3a4a63d8e2f96575d7b68d273d4efce9cabde5e51d7d7f11890f256a6ecef53f611b9699e4e84f7d92d22f78878fa79ffd32b71ff81d3ebb0537fdf7fbb9dd877543076a4cb6ca8930cfbae1bb9401bbb259d6067f6d4c3c2a1428f58a8dbe05ef0c0d423199c837a0f2e534e6195782042c8f1d5c93497539641055b027c64d0b208d03b30f2f4d3c2b4f19ed3a9341f983a4833d70204c95ac0813f35981d14c831227b1ea29b1d48fb7eb0cfc0d4b2a1661958d4b770dd9baf51742f50677a646ddc81fd63285b8417fb10077fee5755819b7c6b90ab80cc8c117c2519884bcbef676938a91f3d3a5e3193ecb24e7d9c9732e42ef1f078f4ee1b9f8f1b80d80e1810fd8d3724f6e14a9c2744214a38458f29ad07166684f95c23c440e7e85da30ade29439fa9ccc9390f36b3dd245ba4700e1c5ac4b801782deff089dc0e4fd8477fd0d2b93244ccee167a709cd4a72f2cc24d78bab4ef6db0fefe84b57eaa306e93e082615ec481d7680e5d848351a4e3add65ca6434dcae180f911ec9c47ef5653dd30368998bafe823f1797f5e8cae2a98fbe899f0d00fb68270be8abce46e5f5687b44bf2c6761e263ee9157d299784c890e4596a47f1d5c57280f5dbafadfc4b926640f8a78ed9d68c2fa5f84c3f549bc696b811747dae93bd8ed2b684870346beaf7e717304177dc4ca27bcf6c9dc09d0b54b0f2dbe0dd22712ff467cddf87d9a27c8d06e6dacf4a27e74b76636373c7576a51695a43fca2ae7043556d766bece114c8544f0fb507d1c81ee0a688ac2a42ee6ecaea9c08750a772b4175dd6a5ee01908321b1259c0a835659b6a71277598d9aee605b074184174f54492514d3319a41c56cbcfc6e9cb6d73f385031fe0047b5e53d7336543636968cae44ada74a08bf90814b9745315339df663b4aa7dd371c51b05df5249336acc66ff302990402e56a91a89241ab373cf932deb86dfbffc5584cb7c1aa622052823592905cce44ca5513ec101443e0bd171ce7406acc164dc184d19f6f3dcc6d26353ffe5203b4cb6a4cbf0dabf97b93527f7897441a588804367e9df2edfe1bcb762815055dfd90c360422c6c673f662f54106e34582e0d3480ce624e4d5eaf1d0758b73681086cf0eb040fb803defc91dfa6f6702d443324729d6e825373bb5560e25d94f70fb9250c7eebe675e4d8607ea6cdcf56dff5874cb742cd86a31e384e876313c3145fc0d66e1c5e29145a5eca94beaec2ef7cf5b3af166fb5959d120f8bdd5caaac06ebefab2b428d95217d975eb5605bc462b3139a5987b4c9cc79b6442ae0255609c557bf73ed781872c04acbcd9cd2ba4e6e7a8c371670c7615f2c56b5281b4cb0f7a89297c322db9d28ccf5cbfdbce85f4acab189842d4a647bab99e2b749f98adbd55d050792fc7fd3e4498a0150634eb5f9456f58838a7e6cc1904af368e7f108363a85601e44a4f082060d1a43c2197a87d806bccee80d3956b8c4d692ea919a55e78a7047ac56441fe24a0acd3aac51d7353a779d1838ce40fe7cc45597ab075719b6a58f5df9b6e873bddb9f5e461448a1c5eb025ac3e1506fe2873f1dd36fad500144123b247c9ab37753d6aeb3786995fdf4b6be152bc2a9fc1f5aa5ce41cf269b57facc13e0a0947d6f5317a79b8f94e765722248dd94c169b0ea513a7c9bfe2030f274a2dd0ea7da8fbd09c217f80eb0d2b886795532e6b8145d40e787d4c40e69e2a92f4e3908901371797fb895262628928e2fad8e54bd87ba50a6c7855469c2ae1120ba1cd8288c0a1ed874b23adeff2723f528ae4ffea652dd5264369e2b1cd509153a0706f879d94b24a7caebf2e044d1992798ade18befe2e476773246b00af1a10ed477637077fb4b7d722602cbdfbf51826c5be644d66abb74bfc9f36c5a0dd838a6a7905d87452989ac4ca0e74f59788a3ecf0d5f129d5898cb26c0215621c945abad5f208c6ca011c9cd89e5d40c1cf48d2ee4130fc5f5c2ad3af220f0dcef61380658f6cccdac73cf1c0f5ecc1b7e90f6a941fc32feed0136324d772f989f9b37125069196694c527d308f9eb1c42998ea2a5fba0008e63389c0f409122cca4fea3582e5d23b91aea0196f63ad562157a7d1b8ca98c4fea86a996d148882608c4b3e701866bf8149dc33fe89bffdf27d05d6f01ce386fc5e81b13ab353e17c53506e9f2db22772ffd77f3bfdc621712cd830b6da50dc423eeeaa21ee109f6356fa99e017b3861ab395fde6d3b7582c986278412afcca2fbcb815113b0816320b8f300fe9aff7d5718c31c643dfa3c3ec49d784e676ae4d686f63a6a5fd2a3d3addb77bf7a2d636d25aa4f4ae9bd679002520bd60da0366f4c9aaef8ef936e9159614dbad8bc126f61174ab7cbfe5a3426c4ad2b2bd97ca2cffa7c1574548d436ed54c55b16e7dcf49926fc2cda751e465a7336f97ab1e5777a11e4481bd90993bd01a28a78b84c526cb422e76b4c267985cc9933e118d847844edcaa5a6a34061c7ab2debc9a37fa2852cbe66596625bbe3a54d0e011dfc338e75eb3f23a13ee1072e00f91ef85f6be9ef8897b1599f8e74c042f4640c86e8e9208e6ea26793a65e76795371118910c92a6a211efb0eb6541444f16f5bccae8c57157c57b7912a38e4956d4256933278c8966463dfcadb24dcb8259eac053a40118027e06139c8b84a2a47a3e574dd265b9d4e76db31a5edd21ab58d9be10171611ec0edd49b4859ee1445db752ac1ee1fee163c32c3c190816f290e38f43b84ac060535b1040649741ec2cd24de255d4ca9c217906c48deed6a09330b252678dd0aafa7fcbd971d698456f1e2a2ebcdf2f23508d612b60ded6cdad7d158232afef0b09880c092bcc2433b476ceb4059489106ae844a3043cb80d6f78046dc7869339c1325f2367016daa7b22fd0c6b90a4434b123ee85120be26534a72ae52cbc9598c277d0d10c6df352639f77732e8040a55ad651fdcfb5a3b8524d7ab80ffcf993ef769ef1440f4d326633e6bfa2a9bfb8c3f24622193d39fecee1a5d814104bf73fc36478ded627a5b9acbdd318cf787b8e5e816f54f3bf3b6021ccfdfccb6bf3811750a8f3844a28b60f062dc7c250431aae55940428c75c6fd918b42ad62255fbac6c2ee3f9fc51537e7ee82af37d96ae96e046a91342d56f7b1b02aa9211f6ca0bcf26e5da58ff48f8794bca9dd74846fc8d4a0807e4f43ed363651ddf0b8aa66d32b424057e31c3dcc952bf7ba458ac9c073925c7a19da9ece58c48eeebe86781b944df67d75e65df6fbf9f400be24f1fba8a266e5752f908e4828870261d5b3755ca1bf13c463979e7832597f13da17ce543b3a65b3eb8c592a713b3f18d67b9d665e9f4b0a200462e9362a1a1aa3497cd53414780158215727d4d16c9ac740033a15bc2ad62ca7fd4fa1c6f82ce3ce981e6d5ee1354f4dae1d8f51fe24f41f50e88f4ae9ecb8475d05bf406225e633ad87c6a464ee2e7b3eb1455e364722768b93b8dcd45566b33e3b109c69db3649200506001eb19ff7fa548d904f99f79d09ed12281e4533ae8a3f477b861d04aba32dde71b507aaa2c86db39ee45bbc35a62dc6cc0189e33e0d1fc121cdb45f17f805a28e29947b29f91c73efba527b1e7951f9ee774b4e571167e2ba9dc7ba44f8ef3298758c95d05a25cbf7f278195f0d5ce0f61d152dc69436c35ee03c802b69a06d9aa473b4ca21f2d4b7704ce0646c6d2a46fbd56aed9a05256df379807c18e8026d26396c100bd42a61a2e5fb4792ea5ad4bf67fc78c427093ccd21216cc2e8d5fa0041687b78303809c7b4288ce6b3f0938936f42311acad1e26a299ebd9935ada27a178386c9278c81f4a275d641ed51af1e35efd49d3bf38c6bb501cbeb74310351f53aec6f83b2d63846c8cc1d66748bc7028da194fb68e2688d64017bb95d79dd21d00520da4a6c65f81e9bb5dd7b6753f3bc6c6b8d306f5d00456c32586538c40f1ed650cf53c72d837e3a97cf4fdaa8b124ef566b8e886679f5d79664435a30406fa7e8c7d50ccd4ce75bb38c9ba3bf682afc36924c957fb36d6b87cb40354d20b89cc2958e74544a92ebc372933de651bdcee5c8d0851eadf5ff0e4ac258a13f2c742fafe1168ff6b30b1e907d350ca77703b737972883a8f74961f602925300dbfe88d6aa8ffcf90ea617b52253ad892b4377767826ec580fba368d692fc2feda5b7717c38991a557e2d8cdd705045110151b2af3f0970c47c0979466403ad7547cb0c66bb1cd20a35acc1e6d9d0f6d4b47d13af985b1604913eb626d191047916bc39f3f8bc8e0a515821535e23f92ea2d1049848e1db01ed5ba86acbb69f283f7a878fa1116bccc22a7649e34815913ead5c96ab98c8a162dae783e062cd4d5c528edb31aaafe8909ff54e7f2ac20c051214d063f61b7cdff807c55e320b69327b3fe287797c953f06207b9992edcb0e1ae016d5f03314252803d804f484fa6eff2fd5231cb26932e121d4f889fe27724e647281c48a5057b132b385de0fd5cd74fb66841655d60008aa01e359f6366cd9ac40a5dacbcf7538db1ab3801454a7df507555c14abc4adb3a1894dc7f098fbd3c28f5ae155b30d27c9c2980dc33feab3e51692e98a40c6ae93b7ef96f4b8ba88ad57de8eff56d2a3988cfdad6063ae0d2ade7bd262c68fb16d87f00501c9fb4d493b1a89d3fb2b2071b8da045c0efd9ef03259055864a681c916646cdf949e28d629aa0721280647a20f56ecb493a8a4bc96ede041f69d45100316df450ea0c68556b8134187a7ea4f7d80568fed45e37ee4d93d98638a9a7ab598a5e44e8bc9dee9439ea99cccca68e5efb480029b090506bb2bf6258803144263d7724d845b8e86de0b7e713aedd1692fba79933f163a33bc9ea8f857c2f7ebd7b1778e15fce71b7deb9a5ed9fa4adee5d70bbf462c7282aafffa2c6e42f4186edcee138db7ea66129eaf1e7b56550967868b1c5cbd87c3407d89fd971ba61f0162e4c8d273ab3b475733b53a7f9ad9758794e7504ccffc53247a210388b63e94d562f21b84fff327ce1f4fc2363e3f7139928b4268c0616e4e22fca183c3f18c842297d6aa728bfd72db679e7cde3933ca60bcec1e68c5cc3666519c70dbe4cdb6d6e6f1ae5653e7f8066aaa94c13ef8693c2c5ed9a44899f446387adcbe7f77cff838e9f38296cb5eaa6d9292c4e4d8a28ba7d432024cceafd94a2fbf2b0a878a8e37749f2e2b48f5b30eba47facbc88c43a0d3544217e6eedbc6e47f672ef3bb3ce41595c9c146530e9b55933b3e5f1efe807ba688ede651c7133b8cd5a0ed49b9f9432ae8222365e2e1a1694fab7fb88e4141fdc527e22849d010f32d9b8bc48ee82577ed171cc2273cde6b0f3f0a1fce30bdd0f2f3e42e3a06fedd16155c69fcf16650129ea995f2c1ba5bd354bed595abee54c6291893b4c6cc2b74b7c89a9f4252ef431e67bbe687f5bda9099dd80418fdb66d160061c34d1ba9eb43c9b72221294674ac4ece2afe53e2eff2496b498fb925a063ac6d914e6c0ed4b2c094f670f2c75c06efb5aa129dee0ff51e57dcfcb9afd76356c5295b5bfa4829cb2953fbdd67bac746b8b2ff0ba09240b83891585c1e88754511fc178da24e0b7ad5a8817f50757a805081624983bbe08d10fcfd78057f063423ea32a1fd19e840024b5e473c4a8e56da3cb939fb8fccba0f9832f554501a20d191b8650bb5fb3b9b9149e301b8721239f042467ed7e0c0bfa955c60aaa6fbaa3b307aac56ba85abaee35d51637797a42abd4c7b02842d5b8f16b985541a21430dcb16346b7ca26699eb043093c19f734677bf012a29ef841729cc92f25ae586a4f25a68b841b77cd2eef85c91e367b3144ab79393f4a4da5ed07606ff7b70061680d2d0731dc3634e547798d5826e2c2e89cc7cf7527b59d513e3a777a9798f2ab3d37f8662f6d89a07a31f226d83aca7b1251a87658688aa887fea20556b7e725b8dfedaa34895ef2118ec5d8138ad136c40633aaad3c23a36fff1a944ef846825e0730cfe840293961749af58d92bc8a857da37e219a1ddeffcd51ce99c8a33d2b12744f3e5c3287b13f07e6aad0c010b616a66d855b9452b8352217d16bedf537d530193020de5bbbf9a8a527bb3ba5fe9b5b051d9aa731f6197055f354c021eb14eb382cf5c2c27ba8946474b793f2f30b24d5bf960c008004f0b436a54ceec7ec09d5d36f13afcb91494cb1d2ca7e4646ea7f59e62e3b28b140dd375182c67f8e26bf000c893685a369c8787a8479307e614c8a64be1eadb5ddbd303d9bf0ed187323ee3a556d101fc2c11f01f2d945f533a7a3d9c3f4c201bc70564174ad67d8aec0c710553fe7eb52b1b06c90ea1b1443b148a5388af1488b5e5655d1416973f09ea80e3eab60ead7f991b27de83f0ed7769a77186a62905cb6f665a4ac9efe693ccde973724721ac93085d46d249b2434d232102dc1414220ec3f173ef6770744ee9f075c97661788f8883cda775ec3ac34859b3eee81ea3684509dc67f3b09b94ceee2d5c64e08250f405a81f2d0ac69b0b1cffd9075bcce8174b5c127c415fc6bf8d5c60d3fbe50c760530711fd11af55f1e16c147c91faf8c46e864c3f86639d2319119ad80e4266b2a24b80e5aa44edaf500c415723d1e83fa8f52186a667870f6a8961ac03ca19ff71cbb153ddb54e5c6f0f6f126be82662eddb9b8585f43a0e49fde0ca73dc60190acfe250d6f528b5b797a30897215ffac8130b825707a3e2345d1de2fcfd96ff76dfea4abba21622599ff428eb091b9f0dda3abb9cf1cae515a4946b1308df9f9a67d5a9159d0d32cb429a546a83c88e9e837983c0b256e156dd68edc0a2c0af1e536109a5883f27185da298d317d81982d023084aaa630376fbe35a05453ddd11421b4a2389e0b51b4ad9b4ff0cb9987024beb482a659ecc6186ba47412c2e58eff052c1540a1f58e0f3cdb443f0565205f0fc43b096b80e62cdac3b56c1f4346bf350575a84fe23fc249eb799d3a78ccd73d2f3b9af14ee40c1b6de9fdc4e7b3ca5911fa49c29a60041e18e68d390135cafc80ecdb0f945082d9abc427f3d7c5d9e72b8be3bd01f3c03e9c532602ec299787725b56491af2bcbf9b92249b4abac3c6ba1ee6455c4682ff6235291ff1e371dcf086e1cf780465d8d18e5cded10e4ecfcff95cc2d7bc8f04e485e7e8c054510e8cca6ba2588018009a7183b8275cf4cad994629a771e5216ba3067695de7a606261f39e586951c4a6ffb0f09bc15943176ecae06ba217302703198d7821952e20e1839afccacbe8389b655d32bfd7d144824e3e806546f4f90932630dae1a0c768e828aa69c7591a3af99c6a15d9ce24f248ae94a225ab913f7645eb642417e1eec73807499d9f80373af762377efed582dce574c46a9dae52d4cbb6674f4b488cfc033205eaf94c9a79fba54aa926de51fccc572148ab1a5d3856c9b6959a76df39ca7643df4f60ed11b792b2ab29405b22ff1c34cd0d456d3af6573a01b9007e5852d19b5fdf4f1619411f875d9989bb98a2c337889f7ae8d0922eb55e247895b087b73711be4675deed6ba6830ca2671c3e125328637b402ae8c0539d78dc00abee519ae1c9cf9464d9ec8e62969e358dad5b847a9fa5182353430390276098b6797e17530188d91c5e424629be6ecf4a95d364bb36ada557740f15953e47278afb9c9718f8865a7bd3ae1d6b82c4253f2596227823d0cdf9cb3f454500eb1385dbb4a8ff3f06923297fe52ffdd2bd60866e0f04b92735238ac9855f3cd5b94f829a56620746873ba7f5349353e2a0afbf3a6055ca754c317010fed251ed4ec2b53e8d50053c3df78343997ab2b07e685d2441d64ce1e158ea8ce7901f4002ca785824b15455422d679a3d2ea3dbb1e68579b72ae8e941df4ab9cdf6678214d5df2483defd07d8b0152e1b34d88d37f70440fb1b3cb50886da7ef01d3dfd9385cabede36c613a2ad1e82e9092a36c8b4d0d4cd42aab5313390c5a72042862c9f4e50399404e12599b67250a23f81ad712d409a48fd330d3f3eb849cc2767c1affd8cf170c4b65a1d958a9a0da6f417cb8227cb960ff7d8a358e0be6bf730bb584bd74b2cd6e089d58c5df7ce6ba4167df9d1a8072491b63c6495592fe9b68a3bef7e504f9cc62188d0417a54ac2c47fac82e278e8e5e42ba4f70dd54dfdba2c09d978e0972d1f3a26160dba4bec9d6ccb1a6eec5c3cb2f470c7db721a768c1a5479b6d325858dc923b856b65bea84474e46b2d2e0a1f877ebed6fdb178f5b835838967393e2cdd6b8d0f0bc1b77104f0ca000e694a5dea1b93ad99163cedd3083a24504a7a3af916b24008f1cf4bd4bdc6704ebddfaddcce2db2bca954c6b25c9d561e8ca40f07dc7ef42eb0f3b849315609a43f8f36f1ad138fe01d1915fc928a708a3d82d7d6431038413d2ece5016bcba7c5dd1e53da14e5eef61e8a28d120b82665bab15db5fbf5d8cde0fded74343e0da07b2298a1402a8c998f3ae486deee0d256e68c729aeb8b44a63e219a5fded9efd2edf645302202173a8c5b185877d5d1f8cb008897bbfaf650b4aa1ea9cc2640da9c0bfa90239fd5f33b5faed715b433ae726fa49d5e11523005cde84b3c10d569a00a9d30ba4796900037e650de1637cf686f5dac0dc72f51c92de65e91a5e4e0723cac04fde50e593d89ace283b0bdab5d456b24ae077d97726cbf5e49c32f62c1f4e92f496a754490f75b0e3ef0bdc33463e494f2e55337d6ab1415f08e3ba71bf39ca4c5ce48e05a99bc03b4f467b08c40c23c1b3b5906f69bc065c97a2c2556b33d695b2cb6dffee75094dafcd53f732098cca6256eaee3cb2570ff0e784d5181f3c0b1110da69ad3c6b307947c345ad99ae7fc8e5da81b659571ab4e0d48725ebce35368cdb1913dc5c89529a92f3d5dfde4d2b2efccfb30d618ca55d9f4acf593a44e9c46f71db26a138c11128b5d4a13a285875c8ac204cc4fde910ab89bdd15bb32f6836913e5f45926b64177d0ed527ef3bf98efc81d330bf9e8eaf997097eb1a0d974f8e44446a72b7bd29db61e969000a562541f44e666e5a502117d01520c3cfb602d8b207834ae37fee03f20dd00723779e41a46deb011e62438116f52a27ae2de0e88b2884d3d9e0d02a35cdd5a71432cb62b8073100ff14df6f812b3f482b44787dc85285dae6eff88b1324856b6d094f53e546c1111e854055cf4ee88a6d79614b9f25b990d8fca8a609316e90857bc2648a470413ccac0913f2dd769cfbb69b365912179bc576d8905182ed49073b1828ca1cfbbb0b99b9b6fec49674d906d2c51cbe46107b0e2bf0350a53f307abc43c5fa4c81a35c6fd19b10880b5f19835a3545834658f73c0672f6d7830d47b2186f00116d9e5fa0415ec3e87f6f06673e2fef71b3b59c5f3e9574fa2da769d3c57f42c245dd8d5274c3a78d64e127ef4d3c1c1f65cd16a3f6bf9b4c2c5c025f51a5b96bfc616e928351ca36dc3201065b876a1f7e70485d12a487a7951ec07ea85477e45550bcd2532c2c8b755cfbbe5fdda48cf9a7cdc0f1d6e0222e30211c0676586a7c4bd4932381065fddac8093831eef9bfacb17ed0e55bff479b62d7fe711700b34711700ceaa2ae19be73a4cae3b1483a716fa778cccb3c822628974e86468fe117c023e119d393fc06362bcf38e0d68d71bfd080278d57a97fd610f8a485397d9c617bd55325edd0f80266716dbd82f7cc767e473f62fb118c3c171a06b79decd75d8c49b19b85bd90746505a460afe04fe65b8a242df9948d0c24f4951e82281b2dfdd1e6b216806dd5b240dba9cfe2558ae22a7791957ce03d97f46100a34794eba6d27e4a475503ddcdda2375fd740efa3fcec890eeefa500c96013bfaec7efe7e8cb0ca1040db338caa9eed1633ecf3fd9876b3bd35ac5474c658843bfef0b03b1a07137212b27b39b4e2fb9d3aa62d7f827e0f8ec1403300a09b096b41391bb18431e7d7961b9bbe31a4f2cc6ff34ddaa16ec234916d22d98e0114a91cf276a1d60a9af4b41b77a9fa10f033c9e1dda8cab8d4a4807014d74b97f04aea4242a6315efa1b1a2adc8e45e8bc6dd9e5692ea56232789968e7288b84487058e00756130d293785b62c4df30998e0fad17b10a0a84a9d6a39799e56f6d9783bea38a3744a4d59678226e900c527afb24a4e285a3deedc5691e462a6be1f961b8f5d11b2d5cb22d2361a297db2c39c7d9b15785b4023e6da597835556dcf195c578b73f5ab18b81bff0241cc035cda0bfcc978c7648cd8ba0012dca85d02b42560c7afd6d4249a5084d6b11dc0f8fd9a37cf15848b7387e411399afa5bbe1082daa6d1e4c950062da999c652af1523b88fe9da8e4741bec9c904ce729786001c70aa9053ffcc8cd5faafc732458c018aa6e6276a96a60e7e0932fef39b6816dcfcb2539ec0a78eb3ef3c32558c5559c346f309297d2a291fdc01dd2078f27ebb546041016ebb252f3ae7786769eddb644fb14d44523b5d74234e3e4fbbd0c49f2fa14179e54c5c77945226328a2ebf14d2bd10a62bd4eb068c14b744f775c43379b4ac37759335625f33f52dfe7c77bf5a991f8330881868f3c227393fed25e7bbf319c0b95b6611f3e23e057a20c3898da0a01a632952ea58e1f56e62e3169854a5e128644c8a62a0ceb194158b63071c5d75c046119ff0827f1cb9c3a366c3784e7219e9095ec322ca4e2bd45648c41215291d267712d634fa126ffc6772ff22d876e5e0d7598a7ba1a827291a4380380a63dc7627f61e1aca53514b706a0ab3b1477a20ff1e83b6e88bd0f6af3419e677b8a103de8f9617345ac676cfec96fd2d8ba5f6fc2219fc3e375873645f94e0ec954b2085fc94805f0884924c0a1b3042b84e0f707d2d64567e0eb999de30f343eb0ec96fa868d497215d4307e26311c805f3fa9fbfef1a08c705e9111e2238c5423a479a2087a7cc284e7ba86f0e21013f63e40437af10a2da9a664bf3264fd7f820d9b5f1e35b41bc62e648bd98755ad33f8d17bfebd20012b5522b3aeb51aada2609bcdb65927a8763b0e5b4c62b57ce014fa84","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
