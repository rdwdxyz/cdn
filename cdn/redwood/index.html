<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"223c56435e040491ffb0e18ccee4113a362bee53302bda861d87a810521a49d49bda4d5eb186fd03e986dbb6a39c74d8179a110e47be56d2e9c3a2860ea255a7922672c8874ae8aec261d4adb0c03f4a8fbf7d9832fa949118aed82b75ddbc4733d378b503b20c7dfaa3e839d25e534a3ed35ee987a57cdf3267b8acda2c23fa4dc4c16b2d8d54d1e4a57970c6cba5de40461f56e9aa0619857f4a379baee225734f14b8fbcb5ee5352723ec9bc4cf30fd74ba099f0712cf412dc3512dcb9dfe288672eaf82584b56cc9a54eee8c4d92d7f3fc2ee85786c9c252f71c99d45f4fa0e11b6ba195a865ba436dcb8f9f07a3c7d784552276b79203a7658b10d8ad9e488503745428379d2422c94b78cdb7af3d017648d320ba3f9eb63d39309cd6da60de8109ced3c97ef7561337470ba3fb854cc6e635a6e2c9cb0f8407a10128248970751e90bc7f5c3dae749ba83383d4cc57859eac770d8718d4a4d53162ced0b835b6864f9ac0015279b903b33976728f5f3da509165b9e42209e040ff50d668641ccf06544da3a954312da795e169b95ba06732bc6de140064a04612bf78dbb3edb409ea842a3175b316861c4e62b9404699dd77bafc790820e1774646583e8da529bab923e280b2b561837145363947d826dc1de6d0d012e21a55d0367ae9764cc706c353565a1b4c028786fbe7266a113aeb7cb17e29e29a8f8204ab32c9aa3d219a955676b058c7704eccdc0dd4ac4494d85f329b52f7afe3239cba6cf9fc3406e68d48b94ecae8884ba0fd526a30386afb66a189412111052af0c5a210206609b736b5ea7695280d0033827f621abd1313a4bc66a3f1ded5a89a87b7312d0a39bc9228e836289f31d48560c8d00f5da3199c508a838041927933f4d9d43495a4a11d5527f3eb55d872a9ac2b19a2a6d321764d10fa75569fae635b98cf00934a7fc87190a0fe2e599167fc8486c24b21482baf13c5f2ed6f9ed9cb15667695c0129b633b926041b8286754569a9f7a9aa9c0aada2ed00c9118169739e228a4ebf3b3b6991cc212afe58b0222935e18bf8819d145d9ebbad6678e8ad4df12280d1d4a09b029be97eaf2fb972e949768f48ae9059d5531828a50a04e82ca49fb4981747875d038881e4653a9baeb991e94e6ed5ec60a3db9c1a5db4829af981ddacc412fec20f7619de20110cbbabb1a50775fe0fa44b3532c92c01153c72ba21e20cc3fa6d4589f0e57a30abb702bf7130d576d152632c033af8aa088c02cc831775c4fbbb223c7958c83369d6d78669a1f656923ea65a98195416655bd091870fb6504f43f63d122d2c9778246519563a455698688cec144b48af53226c703c03db6ee181586d236aa0e6c3ecf752c1098d2eb76ff4f072daa67176fef7e439e0555e197601247766164aa9e57b5152b502bf00ab5afdee68753edd127e164fe87bdf0fb5b87c77ac4e895b3b796b2f20fc0aebc5b9fba40ce5a8b1a1cbc99a9fc43c177b04756f12bee38e26ada48d684015d3978fec7ea6af0780deda467e7cd026527300e6ed2eb2ffa3e4773ed3915a9c5d1ad0c61f3e399ce39b586fb4d86c56e3cb2f4f80e623b82dc20d3742bc664030165d243f51b6c188a175a500ff1b208e4d20f135b4946503e95f3576f455ca20d3eae5b76e84f08a99dfb08c0e1bb740e2d4a6eaa57739a238857c197f0a8be543c0f7be339b01efb891c2f863b34a550fcf69e1304b4f33deace3b3913a30c616830a8ef2bf6b2b353c89b4152534bb36534f73feaf017ce21162f4fbc1e2ed50d46ce42513f5cc5b2da255f51d4539df11780903dd6fabafacdb9b2a8e0a110aae9b0c8fb680c7bca5ea990a98d0e1b5b8c587583245de50f8a322d043525c055cae03b61965a29492d8af7294d44b280511f142997cef79fe1726eb7a030d4906d7f516d3d6a1b8b0456c8803ffdce5aa4b1976dbfaf778995094e273b27b746737ddecb8c0bbed1c8d5130725965b50f7fba8b1f9f31d66271eeab4a6562314689aafbc323cf88755b69d12d9ab3774329983ac5811bd11c5f65b54e557c2cc9744b4964dc8223a6a95a9f7964bd04d37c4d5e0987ce70cf24051ef99725d0e69563fd5888220aff52161105e684e34c87ea789ca4a80fa4e31507ec511253c854a62f8fd9e1e63f17372ccac7532b684998be64b6788890d52e2250e2313af3d3b4cf325486047e76c41f251afbbae7159caa9e01e9698f6efb8925dc7601acb8e408573efd410f6a84f8df054d5efda6410d5137d8412da650f5337578afe237eeac9b18615500fdd05df0cba1407e4102e9f4406801fc33f9eafe24d674fb17bdf469d59c143056c77c50fd42b935b3a513fc4ddab3ac054f888295d900996dcf1b86a3465f93e1e32017042495b3b96267157cd9dd605f03011de280d5125292154ffac1b372531f3afbc2b47884cd777ba2be4831bff18d1ef52a6baea56833368d99db07f8b5256eb512ccfa03ef0b1f73aad3f214beaa66f4518b6509249d72aa37a4bba285ec16ccf3f24151d753c10b0f560ed650c5fe82dfbc7fa6454bc3eb240cdee787a9274818146ac9e6e48fa0ea4eaa2ba708f15e87b657a6b986e7991742a766460ab9188ea585ca64bc0351e28a7a9b89399a7a2903148d1dec0695d31b013220684b142f750a85df8f5bee7e81edd7d3927824abf208b2081157df644e26c1cc6df48b9e499198f2b50b21a4435c3ac7d48ed4b0119f1ce8af4259cfd00ab1be9e6664569a0af7db7a9367a16dd360fa25a1dc020fc92eff4a868c91c4b8793759662ace51ba2acdd87d3c1dda8da0a262e9af038423ae37829038a1ed4a4c6bbf8311d17d034bb37291df29cd57ad38d9418a9d2b264528d855611cbaa462fd9bdc70312e90c385b9ad0f3d0a49edd8f8efb7cbdeb1bb63b1ad81cff104f73ca101780899786901fb27a7e6908c11e77dc8defe52230e1d5a41999e8b6a94f0c43695a26508bad5303445045787c44747213861ba79034f5fbbec68c7376ea93d8403294deed69f7500cb551e6e32c48be8f5f0fdca0883f347cd7478de0e615e9d334b53e0d8b419c37cb367c17f3de7913a44a7031d345fc1f0e154c3f63e492cf6dd621e156a2c005c1dc5abf349881ad2274ff1a0bfc521d0dd74a98339ffaef81c9bc407e71a1c1345731366b966d3468efbef7792dc3e0a9b19889af611efc56d8001ee393f3cc62de79645b3597f546f5d1f434249e163272b2ca0e428a808ff15cf7f7aa961540968c51abda5964787875c7f6ad1296eecddccf8d5dbe3b90ac0bc79045e9500977ce51b5decfd21f0d305319552b5ff559620e93e3dd30fce1ca3dbde069bba5445aff5547255b4fa66c9e4009fccde25138171c31c023907e878d3fab6ad2bee46c531e154e7185aaac8749923151e6d20eef8e8edd4b6730388d6827ca75048c73fa7ce6968d0edc86bee1145e0585c278474e77d7f9654a76f9f02d4dc01b9bfef7154d36f8c9f0efee664a0a4f61beb9b61dcfb5d510831c83cd5ee78591f9b3ad3cd43be74bcb2b20025dfbbe80105fb29cf927135e15f9c88878851631411d29b9e320c0edf7c178ab6c4fc464f802880c962695d9a7669a20ded5d84e5712decc872ba8c5c50dd5552b348c9ffb567d788330a4433988b086739328cddd3c5c626b4271ce9e501195873d8280a896f297df5f2838b7bfb66653d1d2218a5e4c068c016e8a2e5aebf89532a7ac7cb1c6fd0b5d476c4ab551f4d4a5dab348e0372e31793632e49b48fe6f69fec152d2386b2f671672acba3be24a8e6229fc0b302a884d491443c51ab4c00ed1aa488dbf127200fb06326527135791db96a6d20a6766db65b9fd6a674036af01e85b5e887ecac4ae0c563ad710ac5ca9d76b818807b9c27ed4626f4a8b5808424b4c35ccf46d45a2c42c7e1681176d46ee930137217735675ee51223d8c10d59ec1ad2ecec204d7bcb0314a41f141bf4f8f6f79628e3f52b5a64ba2edebbfd7c7783b16da1f0a343ff05d46c0791f431cbaa1ecc8d54d2674d18b73c3837c5b39b3def7895e49054442b82f41ccb920477828774d1cff94b057fbe4492d0fd24fe450ee101939e1114dacbb82a9d1ad512135d1f1d897db8ed2ba4fa87e4dc872b650dcfc78bce2c389c87dfdbfaaa5088f1a0b18fc82fee6d3d5f99119306cb78284e5a107bd8f6c19be7046dfc1a1864dc02fa8666c1e72dc7a6526b9bc5219b44c78246ef73775c8b9b8814af7af36a994d5741e6e8a019017e799a487208fafd3e7fcdc7e9f32c0f5703e171e933ea129b693cff5a0727b96c07ac00db2162a38ef798ec8f76c0ccfa6295ae0b69e10a250b864f62416906535ca10e21ba171f5546fd79ff9d4e597281c935986a14232dec849622645feb6466b79b7cb41f66d4b31ebd9a4411c528befa3cfb75db290724699842135407f19655d9734916549cf3ec559972e0e7867b8499b7e1d9f7d57aa3c774c503193916bbbfc062a7d84218a3efc68d6c51e52a7ce3c9d95464e8659c66cab8a41d3356d343669d27329809122d04d18d214674a8a23d02e8c006b6156b0133182dd780fe4634bf7dc2e93c3edb0072c2007bb040e3b740aa703251d4e96a2e074e17c8cc111ec5aec5f2691abd65b7981cd407392f49ea7d55af9e2e00db2f6a1d92e8eb21f38efb661958d67fb000abe3b66832ee0c667814abb6e99de2c35bba42fe5820bcf0da847a0e27ab6576cea87e5481bd8b48eae20e802fc23198fd7f63f84debe5ea1d51083bad69a77ad6734c25d7e9f8d15c988fc7524ca9ced68d904c2f510c9295d7e421d6df20bf243db7487cb98c2b90dfa5059bd13f90199ff269875ba6f0ddd5e85f81856d9482c64c4c168618808a9af283822904ff5791f8cbc83150cc34d10e56827d7d5f5d2d50c847c56ba52bec4396228cb49fba0d7ee63d6880ee204c50c961d60c959c64fed849589b401e9930303e6e8226b4a29835d06eaabd55aa671e7487cccdf6a2e323c22a20a25f0913608073e333ca26e55bb7b4f3c45e963fd7d6f1f0e3b900f066f50630289d0700bfc5a8297b7d6ca29f74e0a043c4fb238c5ffc90428046cf88c15774e425a05de763e627720ae83a0c65611f27bd44112e3c4fca070c7b7dc5f799773a28e26bf58afc9ba2882b416f669bea840581edb5beafc8d1c4cfdc6733d8d0ab5dba9e0b1bb755aea3fa6e7fb965c06954525445a8c935ccccc21a5ec7f60fef11a939179cd3db1726d7c53ace03a87c146148c2532c0a420a4179fa0f26c45ff2d2e9a5cf869e5b16e50619dea9b48bf81712120c36dcc7ad053a88d0032e6a16e97fb0bbf8defed46b62577780b0ab24aacaee1558e80866645b29e34cd87cf49fc93678df7ee2c779e9663143b132d4d2975bfa73b9c941bc2e25ccac9c03417e919d0a88f0285d7f69d72b7c7924ea585e71ad7e2f330477a545216b469af2815bd21bed9cca4d29718408fbb17ceb0d269c2c61807ad4b4ccccc6db0324432ee03ce2468e59b1171479213e01290e96082346dc03287a5a516901f57c37e53cc502201bdd62aeac5d4761696958cc2c5dbae945c5d0a38185fe471677182d46977a060f0315f07905c3c2efd0dd70c0dbc0f0fdc3cc4700c301b71f56c9bcd28b30c64f7726644048470d9669cb84f4a661da4d5efc76439c3d136e4c7ae0bb3a1b38ba8f45a77b33645202df04f10136b3975237da2725327681d4f9bde15562e7bfa22d67507cb27278d9b0952a75373ca9f2f47613d6f2924a91519e0fa7f027f678fcaf8ad94ed75f3ecbd59a76380e4ebf20dba0c06fb162ec06d429312a583e9ab0a1cae8301f8e0f16cf0c900f974720157b5611db0598502e465b16f9f79098c011121ac38d7ee120fc7544afd1c8e4f81ce9902faf773b92e5be504f6c340ce0d218039702dfb7d567c3b71ba79957e61fd66eabba8caa23bae1ff948fdce2fd74b539dc27a0ac354a9a9d7a4320863dac9d1084c8a9cf818d9a188ff96a942e991245c95b692a2143b1b371d6048fb0e2299dc3f464eedf30c3a1273c878631ac560a964177af87b647fd606d5344d527f2bd0fa42436a6e7793c87ab8e4457eb20c4849b45bd3a2dd1f276e31effb65a33e413b8f92b6496e303bc7183d999bf9b850e069ac26bdcec18fc0f280a0d7e9d68ebec7665a61eec5d2659b99570cc6766c3c771a3bd6e45990dc0d8b313086722fa312fb3103189bbb450865d11cb47983351e13e31b895feb7be190587f84713276efa1fb958dc04f279f4aa32dc398060a39b81957bd67e0f1191b88b3132a6a274a85f696f3d312373191ecb8ca7891df5a213e40beefdf3effb19bbd39b30b8257e302bee52ae63822d45c0740b73697bcf43f02e62aac78f2ec974e245a348011defeafa4b7d62a4cab1a17c83f7d3311519fc5038661f150a3dce12191928ebc87edde10a5e0f367b065c643dfd3c47aa3a4e0884a1281aa48dd8d0cb1d8d3a810996342e502893bd9c46bb9116c6ccd736f7a149457bf18a73da9d054e7c4e4ed21d7bb9a782de54120b99d9c4f62155cbc4bb0e8015585870bc093d1d61fe8abbf0ce0f6e810ef06aa8fbb4ab46b30ddeac7550ec03310ecad4dbf2b112b6938246475970f1c03bf306adc6b213ab2ea34870c25c52536ebd7ad652968ce119d9ef2aa44df408c51b6d137f60291665707e7ad31cf0d794a90fa03c15d3c9907d11d40e1ec4ed94fd812a9501f8df7aded5fb325a80e46b28fabc814573279d36e38e5e6ae1cd3ceef1cb716958a12b8754dc28b5e3c0ef5e4804362c908a1abc32a5847b574f2e95c78a778ff550a0a8b15bc26aaf6b6d847b53f8caa4d1f804574167d8f6f8dc8388e32eb839ebd67b11b58d8c8924b36b7a00839310b56080ca8eb00b128eeca613e229ac734225e814a55588a85982704fd6c16295ecacedc5fdc553407fb67c4f406eda0c287e72cc362ec6477bb9aa273761c34f2a4dc9758cf4d605b64be5caed933bdb9b4a9fc50a9d46dcc3c32f32ff116d7a1d86d6f8d6f1afcf1b7efb27b02638369373776ea41491402739538acc4080583dd49c3350d435049d519f8148f200780f4f0527ed0b2ce53cb3c0094afee7a7516e07aea2d6fa3a829db62cd55fa215af2cadc7d1306628498cac7b03b507269cdf0dd0faca0c62179c45c9b40b3c5ac3bdf209e4706273d33a03e12be73078ae009c21ce36937fe48c5485396ab7c1fa103038160519a28ee1843a58aab3c861402bb708c538b12782021f57d4713410711f71a6f6305b66e23cc613bdadfb4deca3cf2c08760961f8f3cc885afb07b2aa06fbe6c251a82a3b35b60da9517876897cf5bc92bdd9c1ec4956af4218dd64d8233657bb19e46adde412ad7d725ba1f6f9d9a808f2c57202e926ed9737ff170a27f6ee1fa7f4df6c5e398337628a8d0dbf746ef8dbe7195e7fb5dbbd88d21bb46e0b26f8cd83b73980539929fc4ce60c1bfb8be79bb7844b612c2fa2984bbbb39d69e96e79cb0aa7f44bd21e2ae6e82b7eba2a055ca168cc80138c137736cf6bfb48d30a760e5174aff3815ae03c85e14937bb25547d4ee47f4ae4a7fcb81167f626e15ca545ba1506f238805b9c34e30f1b89b0cf576b96cd84949b05c79c7bc6b7c1894a37f97634c8058d7b21b5973a280c279f889c0d793bb34190a681073b598720130d54106ab83f72eac4061033a062f21521e78e146a3b1bb4896e14aa571fc9b981ce2181fe164719f273e9fb6df9ee7a9eaac4a8117139394b7e5b1f3aad8671cd92474698962235832fe686f569c2ab29b5f2c2e1fc348cb38a3c9700a9f47b0bbd979baa2c1cc477265159dd21d6db50478551150ca4f3062214621be2a79af7891900f65222e6db29c5509833c98c9dedf99532ee7fa629c5a7595ebc9b96418704ddb6126e5064a839c3d3142f23de3f9874c683ed8e197bb797266259dfcf9838f92780e9b256c51ff5283ba0932eba750222578bb40a7bec7687820ffa341298e4b04be03f00f82588b891e5c0b9cf63d3a48e89cce2c52a415a79403c39e974b548df924ebfa9af54bf1abbf10bee3f680d995119ee96ba253cb49b38a02d32524bb0c8148455ee2f9b9243f521fbe13d675e0d4bc28fa327dd8009da68bf019901b64c869265bd039be1cfd942af222476492bdfa84fd6d254bd106d99a35dcd58ff087b3298a438e46c8e85da1c3e883163ab21b0cebad9d2784e687df270e233a90d8adcc05df9701b0b8c0b5590a1971d1b4fae4f31badb06ab19d453a6b8309d0cbd3fce22cf922f83fd586de2c9c58e1832f0b425163788da07e5251e564899bd83dd280998df7fb2565c271e07f853cec3249f695aa9058d84710292ff49878f3664e67d814ded0cab8db4bca90a5e55712bb11aa9d8352c6a928aaad845976e8acf2bf4a65106f558c39e5a156143f553eaacf805bacd1b3675f35a95a89ff2cf990dbb5a2dc25b6d022764084225ad657c50371d623dd663c4e60af34db628011fe18cf1dbb7ad38053a504225a7ca7c151e54cda8e4ae0ad7aa4c832f8109852709ebc701112c75bd6b611d2ee8ff0600cba9e20e9a56a6ef0d1a816576150ab5f1355a8fa7d7722ac749823e674cb65ac860fb69952a4b8a52a62fc0ab3eb5f6e4342fc066e67d97273195290d53edcdea63d079e047e5e7d32d9a2ebb900b5695d959c2fdfe59ae7c56453570170441c72d540bedcb5ef3ede81be0d7ce14d3ec11101e29a14c9465aded93b5046f21f6eb6c6fc2c6e68d4ac25355bb45aa891d52fbf1eebbe03a86a62190fdd30344936c3e0722de0b60262228e92853b3d12ecbe50fcbe7e1453a76817f7d97d50ed7c34aa746fd5f0279a205bdb470b8d8b129b91a4efe94f0f70ebcaa7c8485948370264fa4d9e3ded8c827462114cb915a5a28faf6d419a37daedbb10aab507cef1769f231eea413f6538100e6b925a1b8ebf877748b2a2b1bfe2681798fd8a9be9e47f5763de15dbe48135a0b8db6af822526c657a7c1d4689d8fe22bb1da978bbe25d7bd910e26e7525b7c30f40bd5751e15ecc710303f9512a200d0c9cd0b91eae08c25b961301756e3c8af2c43c5678d4ebc40806a45e129692ac01f20f28e67653085c2316cddcebd5ef1cf90f11e556135ee31cd3134cb7d1096725e0cc3e69ce4b0c5a97767c65b3c7e3011184cf16e1a3f7f64bbe65d1c1a6dcc3fa04faad28563da9827c21412307f162dd6999c7d55cd45ecdc4eaa9be9ccab0cb86c6f09be7227358de87053820df4643250726476b72342ce4bd80312d6daf0b1b63a08a6e3c4a7f56ea2adb92beed7f7bbdd7781f8f8c3bf47c357c927d5fa905a77cb4a297af792dc5d3957559febfd4491eedc50d866716420b0d784ef649b8dd294e5dd358729506b040675eb4e669bd45703f81ed52deedaca124c1e45f532467be0ed5621040a79dd2a2f4bd915d031e621ca098b4377a9bf481e11a2aa8291f10e7908d72b775b3f3c0e1701692ffc47349dd218e9e57ca8da06c27db02871e4ab755f92039a11e87964cd641aa43788cd2a7d8fcc14915c66f133a228539a6867d277d2fd558a91b2492ae4644a4218cb53d7394e687451be6bc708b09f9fd11d11489d668b31dd3481474efa0909a45eaae4053a45ee65cac22b1f58bcac3d8132cbeda2043ac9633ae6d990843b7b7312a65948acdbdebb42b005b42dcec0f63306b8469c552cf72fd095bc44729a3f374ccbfad882a18213ba7e626c27b00139b6b012add52eac5a1a8d54718eb8201b85887a66ff38b9f10b141f557d22359f80e8c81e456cbd57bce4c46f9d339729cb1745d13e71d0f4ac3990bc291cc7857cc558978a6f04941941fcf05dd868e495ff0fb5f2e8c462eea345c1a5904593d2b76188e36f5973eaaab88f978d2f9b4c0415564db45302632abd431f0cc6021afbc904cc758cd9c8e5c8fd1903c4a92a8caf6135ffbcd7f30699daf90006eb00b18bfb02ea6cc6234610561c1ca2819a32db6f553a6a4703904e0f6d59b0910d5d0147c8f2e45fa8de738c9cd1cd01f3911a12fb31495afa99b1064b9263ccc3b2c06e0d75d6b99a01ffef74ee28dc56ab4a958f75a5233054a082be55ab971ec2ef2d05ce652a259a55133fd59a5e2476a7b0e3f09dc21feb07c4569e11058145abc2a50e3dbe8957a89ae04fe471c2d4c1dda7934ebbf12cee4533d31de6485f6ef688c696615f13ed95280fa6d36675c359c3911011da6baad5a1f47ecaabda4a9df609a4c947e046b24faa7aa55f190f5e0bd156bebe2cba1e47029ed73bcc1a4db52380953e25aeac1738e611fc5165b1d6bcf90cf1052171854815ea345ca501f15c739eb4b9976825940cbf63fbd2cc8792f5ec701959d3ff4ac01a94fb8b2da7f5fcc15f4412f17ccee0b708b207eeac7d6db8698e88ba8b0133bca86689289b3c68c9794c77cdc799523fd22ca4040b203b4fd747055ace0707c0ddce0edec56a2051443ff4e551480a8631639eeec64c90b1a160add1d35dc8918a7ae0a5ff3071bb550521b0f051e40eb6201ef18bdd0d38647ffceba516a1f17507c988065ce50bf58062b27641cc0e01e00b62345c2f0cbfedd90fca0b10883cc18559a49ba8355357941eaa4b28894c14d72c8975cddb4adc508c3d61e297f8b2f7b43d75619010ce76380af364ef81db2195f3712eeb09381ab48a903fd0b3c86acebd85d1939e92aa5826e6ba0f613e799c09c75f7e1d299b4721cb3d81bb51fce1fde17622f9ab8eb3fa4bd8552f3a2297711c9a3207ed4ad1a73ded43594c65d2bb54c667a30d00febbed611364333a89f62a7f7ec41586afa2bf90bbbc52937fcaf447dc3c159641cc5e4e28ade674ed385df8708dc3b2893c9aa008258e36728aacbadd9b028bca0cf8badfb03f49039a58a2be75f022160a6e86b53fd5f5ee24fe275a953adf58192655bd8992c205bffd12c211ae51e964d6be7b3e42866312aa866e6983fbda3abfa3e89c7d4f9112c589fac2607f1d0ebd84f15487e08a1ec72e2487f355902fcd8564bec50224df4854ed992adaaae070899f16ecdb5f3ee60cb0aaa02e90d072c803a8701ae874e9c2a43ddf39277c421bcc5e303b7b1a0623d72742c68d04a2a307477af885b85bc087c5659e6ea727ab676363b8417effa73d8476a2e118e0537e1eb135bc1f1aa1036d0be7be6b96017934346efc3f16f9c0c255043a71d76f289eb5fa6f8e75c9126dcf33cdc42fb540a1dea9cf0fc502722c8b7598058f0c63f52bbd30461549a5e48b07a828109b5bc28e5a631d140c88ad27a4cfb02c6c81f4d11ffbacbb03c55578e4cc74ddbcae0e2ac7948a1e19b99ab1a9d2c1f7fe2e6a63ed6c3dab6c0aefe6d504f464c5a41cc3fab4561a5299e16945272cad85cda0bf6417c606af90bc079346535764d3e4074be3527d808345b714bb3701e362fbfdbf9a53deebc195da412960fc654305f2a9625e90790ace826aba0810feb08a26dfb8032739b95b4c90924e833a6664d33a2337275c858367b55f66025f21ba5c6a90cf10c9199fd07062a87d4cd277f40f8820dbf157611507d69d7de15d6f80aa0ae497fc294ebc2bbe426b86faeed41ec10ea57771f9c985a6d6d2a9866c2b2dcca0319330d3af1b63d3166677b09a24f9312c35a3f1651cedb269bf9fc7ed1ab4c1e42147242b7bc33c646d8368d0d59a5c5d163203c5c48e1f71d0dffa9fb044b4243be6cd39a9f75f2dc334dceacae937402e74a81603f8a6afd0a1552e5f4d8328e80499f64c843aefd05393fb0a2ca805773888e756029a96fdc18ebfac845f10405843594fd25c698174f5bf776a6d75f562ff329949a0fd628cd104ef0229abe576b0ac64523e7a7d1211343a3ba00fbb8c67aa5445ba62fdaa9d1f56a3de83244f92f90d0a6843d0271421c4aeae44ff53c9386a28e5bb9694e783ceee542be132f4404c8076c09bb5e24f6825f21e557e0e32a2f725fa3d6345e5703ab8a85a02e04efb751c24d2788fe547acf97c59622054c880817db6798f33fb96fcd8c91da769fb6e46629a00ba75805fa06ebf1153104fa0891622795663f64ea5da1081e30a74be3f964f2205a9a9bf516c9bcf741501ba02f824ae9b1c6d72ba43b33a1ecf8a2e697499059cf93a7b2c9bdfb638d742ef9c418b2bce711a5fd06c8289a437c73193491ee1022dbbc92f6446480fd44b72d243bea9e653ec0d66d59292975f3dd61acedfd758d84b1a26ccfaceba1830eac7ae4f23033b52cfaa25ff03148693712d8b4f032ae9852f8d4c87dbf61b83d3040866ac1c8730c533742ebd59a1df3fde78678acab65694ff5b54e48df83128d5a8fb04bacc2682c9a6ab7504c0a94e4ed3c33cae49b07c0738b1c34253e7ea0d2483897dc52792c123019ba8f3eae18cdfe644e53a729a439116823ee2ce1dfe9128d31cdefa2b9b0c17badbde3a7968ead5229ea24e2fdf6e50effa35ec6921869f01843b26f6b11838868f8c6384af6b1ff3e90b9252ea3846009b3673a7858a8382b0957f030b7d4e51bf56f355b418eab2f2abb4dd7b31942b9390e277321b01c42cefc3978b1f84a05284e4ad979420adab58c146aad741cf0f02db8001abcc9c88d2441088558be653c08fd964efae148dece8dd3efab261cc16594a1e8086f9f292e1d89081224330b6ad3f8edcebd4f3623fa6766d45f581c248d0b62947fe69d5915e67db93fb6751c2a4c3bd65616da53555916de0309605d3de230a1687e16f8d90c1b45bb42a8376bdfc1844808e31939d38c098328469bd386a691e0a4ba9de4d1286a2c87c9a1594a263499e54e6509b664034c2c0ffa3b911ae2db6a04227f8506bbfe789efeeb947128816948444f865652c8ffe4ea93985cc3a7357c1b8b7206f58636bb60ed2ed9d0c441e30b85160d102f81f16752c07ed23dc47c9d8bff14ad82d51ea1e66e6df95e4cd50603dea49ca192c1792ba0b2fa79b70a358bbf44b272d730506939bcee85f757f41b484a9b12704a0904f53f692e7bec8f2981c5dc7fe6569af69eb31d097dd13906fb03cdecb5ccd15053b57d42cd76feef5995c3dda263b6f725da07313362d5f4ab275a68eaa4f9cd78d95746868b2a7d372753d1dee7082cf8ab12ede633d37a599760fbe4cb56dab48c23b26f24bc9e51aaccac4795d2bd65c3f477a59fbe9b700e346e11e44b247ff3ed195e10b09ae9997a5a5600bc5c4b2b3ca3fd1d5ec6e65843efbbfe981b91a6df6170470e99a4ac9c5f8839f899e1c691682b7c8cffae86278945787369139405b0fee584cbb3b6c2c37287a2967a0d93ac5e4e25b209edaae966c9c9892b51a13372d4e59ddb3a428537beeab942d3f2ce525e6423aadc12103375ec1031f4251e8cc1cb2ad906816856366d2691bc98489d7a106c41ee3af2676c8f48033aaa91f4ad163c794952bb5bc82d02f09976dd2a3d86db305beb3bebe5cefd131bed24e4624ba4593a4cd4d3160bd5c316852bdcee8e0788cb4f340b2df72c6feac1446114af8d468d583c8d353f2e32c02427f8792ab0733beafd5061a96fbd311058211e35e409e12f258837380a30e9c8bd6042a81888af5ab02a891e0fc45704d951ae05477722e8b4fd7c12badef311f001e6f45591bc9818efb6abe9ef715eed6ad643b865d8d220e5b191b329ad090e859efe927c37de2cc00928d738e9040d8423d1115071d2acca6738dbd5026a93cc647f8181a8069b43d49eb51d4755ca0ae4954294cec93f5a9b9825a54ecaa06c09c67877eec12c5c981492b136ed553aba7f35905f44167d30b1f42b5028d45742a5bb2337b90e185eea14efcc02777fa9675512ba2374bb979cbcb87152f1bda7072d15e8fe78eca6f0efed9752c16ca3a37eb3b405d651bfb4ee3a445cb0139eb44cef3a9ee861fae05ca0dd65b5f2ba6a1c5b32c279147fe50721bcbed845c7ead77a741b1f76486a9ef88577152ee2619887c790efeade64e52db16f4281073dbe8640cc2c02e410a08bf1d39c0408f2e1c58b29c47912b1aa9fd001d1b8ac91007d2cf882965cbbd3226ec543fd1809d85bef378945dc0fab525576954e3545e2f4911af93bf534bfd483a5af139d1671fbc51dbde90efc1c95c070b8d15149dd4fb1749cf7ea0a9554787c2fd0dba1858a1fe276cbe5da5382aa8f4e7f951a46a9b02ed129043d0c7c476254df6f87cda7239eb81f7c3bbca8d28b6c12703c4e15122b205cf59965fbbd40726a2b11f76fb70ae195d94136f911cf224afc0ae2b0b0694750a407333e4d0e5fcf1f0332845ac27ec22aeecddb196592194fb2ab63e74ac64abf8cbae06e66409d23a13552fc6eefc2d3f94b4026822d8f463dbbaaa075854ae08c2acb03dd0819d2a6020674e28f0755beaf30fa3a8c6c15c5eec5da1e0365d3421b773e467db7378dc22a37db6335df410c90c4a37abd248f5468fdd82561e9b24056bbf162661029da839808ac485e2f189da10756f7f420fed7001300ee34ec2eb23d4ee4a7041119f4bede0fb20af0a1fa04906c900f5341c2d81d62a457c4603fd47231eb0e1d9b5aca7a1fdf0c903f37f36e926bcb39bb346bfe4ab37308093bc3ddc6e1451e344ce65b8c8619fbf2057ba1fa8e110b2c7ae93371a6bc93a5cd9f17927f9d800f593428a45274a29fadecc801cbb71993baa37c44d2a07ab630b8b4d98a5a7c9e5adcf81e30dce3bf2f22ba81959d4dd62e68b93b3f2b0e32c884cc5320c5d68a1bb4e3e940496c107338866d0be71e018b2be9df7db4e648523d4fa89158a6e2f28440ab59b37c9d1121a7485eef0245e730c22fad8df93f043dbdd20f111255584f678c731fa992cef61eb2dbe28f9964792f5c1c8287ce106b3b8cf2c0fe6d35e409736a67169681b73588269ddfd911e9917d05e8a1983f1c40fd575cb08a73a900b9cbdc75818653bfc3a7dfda177d5beffa7fafa6ea3343b2df71d1c74b2740f960e9852e6533d070eba4fcd1e16295f1074eb347f3e7048a74619dae4b94feab37e6d20f318c1b01e2adf867a445059ffc21be5513aa73a2e0f1319867b8b9cb8698927cdb4e7e943a5a6cef617d582e78b45dbd14eb1dc9e3305dd798f465d6a1e197c7ff81468eeb6e72c181b53a76fe9d8ac96978d9c1502120acf25a0666db51ad848b3558f11f626d8718fa79a804130cae19d49ed8c70300a21298b4fab2d2b8a4527cf3b2897f8a704c16dd1f5518adbebb8e819844bab8ed391d9e17b911e77da1a083ff20584dee3494f41d4a3ae404e38397083e83a19a2abfc1b58e24cb13536d283133ad6ee45a2555171039a6b8d5deb2e2454ec68c5039b58f3c942efb83012f0cfc7c2978a7974305c3d9a39de706e5b4f3c710a2f2db491bf076566fcdbf6ef5800fe7d76e1b338721c0cf5098fe896b5cf92038dd8830a3deefeb704447bdf6ec795de99ceed9ba0fc00903bb980a28a5e038fc7c0877170d2c26667e5d59429f3f581bd50ffa7167268011bfabcde5b1b8d7a7d2e3e64869439b3e60e7753b1bac959c435741ec54c67e46e1be4cccf4380fdd464e6bef41722b1e39504646482d80b6c37a429b6267b0cbf56d2bbec15ac1d84048f8a879f2ef6d295e6998b97e642faeabae9578bb2da9bf14435de5bee31eeeaac70e50ff1c322ec8532a0f7afdce3b91b091780510bb21bf02653874308c5d406ddeb351c5675383b6353c795232670e9792bf19f92464e7a3142c6d337169c354fb9939e6a9df773f80a96c18081c5ec1b3911eb325a6fddf2de819982cb93c5faf35a037379c6c982b49fafa8cea3a4bb9ea2883b4ba0d798613097a638675206996e2cb4a8bf45d52573a4171cd3038b2a072ac097d514108db2cd09e5d6c4e8d9bc5b0b1cb071cf0750facb7a621ed2caf39e0319f70d927343863fd3587df8e994409142a505f84e5044234d8d1d3da8b43267ce14eb09e257518e5547e8732075c620ee45837dd17e253db935f39b5d0805d76177b4c88fb0269f3810c9cf53f6ecd355107baf67519d0af74b685d705f35c6bc381e89d778264e1d4d643e7b49620c6c36af3e0a0290256a81393364a199fb36d6027cf49f3c44fe8a63acb312465e492795e3eecbc7c65f2a41fdd1eab94035b706d54a6d6f1574173b3ccf03a211e6b09bc7b284cbda799eed710b60ce3dca9c3604779499eb1582cd823d12c378573224db81640c78fdee525a6230c997ac8532935eb2486c0fff8f9a1c2ed59500303d46dd80ce61445ad7a64b824276a9201bb1f3378e6ae7d6e1a91c37287538af7d9b19d1d2b8ccec7ba96261853a3f05a6656ed95a4c86f27af08b352a4433cbed2c2129d8e2b68366c73f3e51f407fc1c3d89c6b78fbb7e186610dcce30a2846c0ce00a572e12cb225eff93fa0aaf7dd041c4eac1a9aeb841267d419820af7d148f10914567e8ac8e46019608528791e0260fa8d8224345a7a4dfe95e4f04c8f230fbf10363c0a530683d0056eac609ab182e34879e2a803c4c007edf293eee57d4715c1c7d2e8943650d37b7e6c53f5c4751711b3872bc683b9704be2074594ff3dcaf70f470b47c1cfd9fa6ca2cd7882514a9940c2f0be8a8a2e6a27017f8b833f7d8bce1afd24951d9acf68f4c200e3a6e5f768aa7bf7feaada13ef46353f5bf3e0cca2111419a29b8045723a5b63a5da4bc18919e31f684fd8c0c3a491fb9967ef95cfd573ea685a9ddc53d400167a48cc9a15ac298bde8d7d72c3e1c2168f6b14da688b6a4e2f23927389214d866bc1dae642c7d9f536337ccf79b61d38bd22b0f9e6e4d7fdec6ea8f5be01fd7a1fc34de111890dddd554b75dfeaf7ab286c48c0bb2b9b2a0cd59c232fc47fcb3a45e7ec288cd6867e25554acf9b295bedf43578c2fdee2e44e471a27526f3bb7a3d8ffed5083c9c3e058ea2eaa082cf22e06eea222ae9a327b79079c67e544a965fbb5fff38cee0cc135bb2a89233b3c95e24e823be35ba507ee22f87d79e2ee794684d05da9f027f3e1ad92bda753c474f5df1d28e212fc0f71e78127693916ab0a16146efc0bc9dd884d68fe0d0f3c2aa705c3812e9bace3b195f9bdcdca568ce490ce51bfe8161b58adf3312ccc103f4fdbc535f6431650c757e39307d8005954a321546fff8793d8df91c81e10ad7e29913a39ab67a4a6cb200987430196929a9a24098c572c3c0318862c4f0a7507c5b2a925c417d327fba5f7e7a599170b47156558ee35944a00c2effd2feb4b3ba4e20b9b9db5cacb37ddaf2df9fc7c280784294a4e361de95f16aa47118f5b79ddefccd41ba9dabd9243591f829cb5b43834b7204d90416e48f969be0aff608570b45e41c745704ebb267178593bae66d53b8143f292bd6445ab0c6489b7026458e72088237a2dbd6fd0db91db1b4fbe742d2b3cd4b39480317a1307d3e5b00e3162e5e0d10d431c21a5172493531907e1911f4693d2284d212e79fa7f2497612327d3f4ca360661b27d8e03335ebfcfadb2ad2527e9271bb3416f30176113bcee76140ca2278330f180a110b641b162a19f00461c28e515c6aefcb4d56559c35940d584d04d88d19072ddcc687217a93c20174250443fe0f9f1ab842d69159012ecdf15c029ac3d83bc0048b5c80d964b504c6c95460650429f2815eab34906a8b32473dfca979baa9ab8409c9d9f278ab19e76584648a6a5a99f50da6995b268b9f1f754a6d764dbb5bd51c0e8679dd57f8c88ad1a49fd29f8304e76264e61512bc82858273f7fe0e163e3a88bd28e5ac264f3aef30f702d074a7c51c754263a585773baebd893a7e614f295cbaf4b25e5526efcdaba519b01c19a85b1374a442df5749f687259dd5e8eb40c579469d29fdff35e6257d47006b28aad87fa4cacd53adc69327b3515fb5b3a4abfe3f88b86520c522bdcbf851134a176beffa96d48345b1eb70","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
