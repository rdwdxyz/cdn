<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d1e8bec7eedbc09b4018e5693dad008a0d5bac21f564de75b4f00ccc6e719026eaca0a82906ba61141bfd84a1c384d35db25acebcbced327427621fff6418dd688b0c5a60130d6e7a15e26175534efeb6e0c057f270ef51082175f4e0edb436972cc33e04db9148b5f377c26efcf591a1b4d87dde89c7a6fca6c58952af3e9e3459eab6b0e64911fc72bafaad47facd33953f378581cc397d298e5713f0d90639695262b74fc1e0ad12cd893979b04b13a578c91085466f1b9941adbc391714847ed86f62775d2d82598e6cfc5e93a8d767c5e4d7f09350c5e7753b99d5d839d0cdd43b212b1466c8092f4119e80ab8dd9ccb4cc8d038a5663ec835fb60517c45236bec574a2d968752e5ed0e93b05d1de943b8471be84bf1bba02cf0cee981532dfbb9b3a53261b00a12e9f2e55c026eb0acf470dfb25580ebbb9347f58718c3b702033b9bf54c80e26994e3613ad63098194df66e4501a3f96479edc7eef461aa6efbfc82699379a521a5ddfbbf8e6ddc3c7dc89afeeffd628755e974519478f6f5bad0af12e49745d3fe6b863b23f8063e4cc34842db914f96a2e2ca8e41fcca4769060331e5fc9315a136fc221ea584c42787dae9b11f1a22d799350bcc7cec25b5230e68dfa3d4bc98fe93dd36d685555c845699d498509c019324792c7cb2391ad95eec2171b149e3e09d83241827ba38acfdb7c72cea550449922352d6f1467da3051def2ebb0df8ce7760c8663e31768a3772eba5c7ff069559aa075a800509888cf8613494951895e3464f3f889c77bfadefb9bdce74feb51ffd4178f566f552da63358738db09c0c84e5d44348cd781db0c65d755ecd4cf40386ef018d3f4c94b2d855e03419d102bce304522d18f2ccf4c8a30ef3062a275462c2315083cd906f0b45a138289d6d0c3bb18783b5116c35a78920bf9eb9840b2aad43c0b2fa656e9ff35348e9e85b4c57d3699c05e6049de75d8c41c3692051859f186b14446776f7a607b93ece0c60ae2aeb15fa32bcc5468217da8e199eba4861396890edc78bbaf5ca076f5613bd45ec4878805eaf3ea13658b7dee3c5bab49dd5061157abbebf4aa790511653b1c928a7ba630bb64f322736636db06b431653f61fc96ccd7117e3ede95f998a4a53e6e63937da8474fba2e32fb2ddfa55d0d77138ebb1fafbf4635eb4a72b54949254077ed11f47c730450d1c3f5a51499b2f7eb9ef163e8a22a45f9538c76ccdbb5e9014c4787e8b18723a383db306c34460a0307886284e1aa213cccd0a96e7a327a14ea608ab4ee1c6e9510a9d2f8fd51d066f14c4f338fedfa5949a9573d637b7977731d50ffc81312c26549d11f655296e210555e3a16a7f9c197a36e4ba08abb603c8938b6411ec85332d8a5ead3a6afca0be97e7a8cfcfe9b2505f8f59acb32eb3e11654bf5e858a36e1ae5a9d93b0c3770b95dc8683b1e9d28717a357c12e2130974da9848a146f1ee123fbf6482d4c508655452051a82e2b9ce09ec74985375652e1083577867ac76deb3ca58fdf75c785777766f7958fd5ba763b4645d7a1c0f348d919cae4a46175cc23879c100f5d2ffaffa7ede7f2bd458c34f84982e81984bb7a7b14e6d95156e0d9912e57bf43bc95eeabc493c61fe7b459f174a79d1652256789daeb196bd452cbe84ba898550b4729eb836eab1331802162bb3d5205d585c539a8dcbe84b828c70f661b518233d9fd1bbe61a30151ecca869a7d6c3767fc678b45510ebc4aa3ec265bc47768f682c9acd378f0b759b6252e4fd0779c6d72d1201b445d2bf76208728ccf2544e26e325e391ef44396d5c8b1eead9f0f37be3bc4585a2d5e6b19dd2d6403fcfcd0e0146a80c7c160e4a8ad27c31e916b2582170590d9145ef4d8a282381b27482661f185557e695e00d122d1ccd7da59a8b8e9ae640eae931298bfdc369605ea1e7998929a0898812fbc37d4e73519a3b407d1cdd1f907dd2c45c3a3b6291a28b8f13a1fb43cbe66bf66d52e1b3f39f46ae6b9bb1643de93942a1c2715a078664ad297e98be938b89a99a534136eb3bdc09982ee642c683a18f5b26de9c96b99bdf39a61c7ec688558d3b1054da5fdf06b36d9db955ef3e3f6343c123b26501a9427e455f8be41bef080cce7d4fcbc7d47074ff5d29b69bf98e1cb30e5cd8e0dbe19703207c5ab30e3fba05e716797f85bc4c2b87489c1da4f6a554585d1687abaa81d13d6661dea674bcc32434d573b1c609f61603d3359f90b7cf0f090b46ffec74c10bdb6b18a1b8cb3b6def6892d45df412621ca24364631c0bbfee6f7d32d8d4a5fe3137c33c775e6439d80924798f700d1c93d6dc2d191e94fd68ab7d1f26c5cda5c45be1d0fb58a3dc8f44a28575bcd8dd246b43f5299dc5e9e240f85bbddef815bc5458815c93d4f3baae0600a4581b216807a9addb84dedee922786b57d564ce7006ab8c6e32a337bb0d2bc4e19aa2d8390623ebeb1f49fd9e5809929a57eebcd65405014d1cd08cd7779b1a78e26c5173db419d01a91c58e8afef8c36d6d963213104c47a6e42c0fc394de2b1ec310d9f359c6d4f165c06f73cd85f678e634e0db38dbb8a6c14fa1b54d10035b03ac2404a7983731941acec6bf0a9c16b093a844fb756d28576006bd7d96d4d5bfb7025244a89e5b14cf7134b747ce16e1492c18f9616de27590e1eadd683984e552996bd70c502d62f1ddb97b52674c7ba780b6fdda2e110df6f39d50dae89c74c8f709b0b21e98235e4a9c1caf7e909ce0682d41baa49e4e27803591b9c9a1d6e88411ca90dee2d9f2b24652afcfe620f6daf1aefca39526264ec3bc3ce6d2ce6fa7b65b1ad1a83ea63e1dd2b9466758684c7a56c0f5d3566e4f720cc0fa947b9ecc13a88d2ea6041cc16ef3b7a00ff62963d25f1443e5e8a55f8d9d4c99876d210f36c932c94c10073b1f714c65263568e1f33ec7ff751d6d55bfd1ef4ca22f94db2d04ad890c171912be640073377700ec670e6290823f869b304a4142222219f965fda17e0eed4c78f646538818829bd42899166081ae32abb93ae92671b65deffce0a6032f117e519031d7d92704e46553970a1c4ca72a71c84022e16d9649b640301bbee337f8544dd28d49e99a1c3f179bf8c9ac347e38ffbf6b2b8233b0f49541a4dbfa55dd17733b8e2faf81a6609342a75b30f3aee4da95e64d0fd0b080e70b58827558e4b49e3c872d55fb8bbf9950e64aa561380770b06982529f3ddee6ebedc521a5dd9493b5e64d44ba8b38b025d648d8acdbb94468da94ef10109bc94720aa65cb7719d2d0fa9b3277e180ff17fb6ee1203f7e6522b5c5c8e7e0ae4873023d6a73535d08b13be5a9a12ac14ffb7a35d783deb3f298761d040e906a8b52fe52d172fa2722e8a759fd22a5c7e2e20baa3dfffda01937e5f2e277061d2c50bae801b150dc9fe2e73ebfcbdfce81cb7e0fb71bbc775fb0bc4ac554593343a795c37b55f36d843f38345f88740971032b96bd9a42e266242c2d52318d13f9997a6b48c76290c5c6f124e1cd7dd7aaa88d42c1214788a0859cf0eaac7e0fc728cbcbf482ae450daf7c8b5154b34419cc07aac22e035297773b5f3aa897b255884b347b21a4f59e3cbb123bc2657cc23f43c70a6ab295d3862476f0d5a89436bc20e33fc0e38961ffed4267f5cbf2b09aa6392061df0b75e3047cd3234eb3c5b1618c93e636fb227720af31eb7d56ea91cdd1be96df32c72cd8bfbbfc6e0851e7c012112f6901a1afa3314ae8569a78478e3a5f9f5e5368717db2800b88acf368e2ddfae506219f0df3bdd5b9d73d9a8cab4de86582d11a69e6ec1afe8f29338c9ab6c98d1eb491aa9f244bf42c48752f7f8425c992e34deaf432093f780a73409571f7a96c878a6551b839d50a46c1d33896d8527020d0345dbb1d2bb963b896f72d8041a63989520658a78e690b9cfc727817f4d51d5f4cd7200cb83bd7362bac7ebdb555c47b7c627b7f46b3f842d45ca7d8c00b10aab0115fb704cbc43ec9700c06053e1994c99f0ba7331ee9bbad571ce112f2415713436cbaeadb6aca71df1d85db308144c65c25019016027d67744bd3ff432ca74665ebb490acf82e0a1e1b4eee370fea97f2e2eb94b962bde785b20dc80719cd7f2afd2d4ec1d7832b2135c16f86835afdad8f3d7b6cbc1420446c74d9862ae3533b2a22928384806c398666b32a91405fb85d15d9bf7814b84a7935fff97a436bd28d96976834a8bc3caf9134536d6bcc82aaed4f8ffe22aa9eb6a4e5e9ce79da711a4ddd361adc4bfe89c6d42ba9c0ff2deb2915473fa411515d20c7c7ff82fa6e2c51e92a29e3cdcf3f7e19bfcf7e4715ad9438215909ebe9267a77eaf2d2cd45c9990a21f51f94c62e0ad3226f11b38cc25210cfea5032ba247d7ad0c1f70a1ebfdc2b0e0eb1c54d28fe94dfe880db542771553b0731d3b8e9838ce6a2b9eb78347463844326854ac0ca49a5211b153daeefcd4597dc09c133eaabc5244211659cef0db897d8f3dd7662091f73f47c447aad4b1fd717d70c1cf08c6b1a1379a4806d16337bfa124fff862264bf21680cc9a729e17d45c56bc76cf1cfb9663774c77b2f79699e29390cf1d83ac9eb3f2a9e6a21f9f8f10fd2b28250e49a6888c63cb5774a7092d1821a36b1c93ffeecf4661cdefa2a1dd7c39aab0bcc5ddda0cecedb5d11998277625fffcbd42f58bf6ae1cc17beb45d4e9140ec16d7956ab89f7122e88648de50705ab1e5e8ac1cbf273e16c4bd174f8deecc04c680b0ae7a509513d62977c999e28725db233fdc5db972f4338a23cde3184bbbd7272725a85761d6fe50be0d555dc70528452cf0063c86519146ac03d0567c4a62ed14e7ab53c5ce2a708772e77ae1d550bdd7850e95da9cbef8c459d4af7e1b7340fcffaabede9b950732caffd85c473a40c93fe00a332b4c43d7cc5920321bbf676b5a9d903cde8226be91826248dd5ca7be56873f6b9b00708e5d2c0b67914bf55d56595e1532052bdf3bf31f3b60a9245788be13e43e949e198193412ef9e6a1752674eb0585c26e3e04c1b23b6333f827fb179de135284a9e6ad88ffdd592a13a3bc48a0e067c5c23b248f0648c6dad9d94805647df3c44fdac60e54522ffdbb2d25f3105612c81dabf7f9e568d28f233f93d09561af624ed8b84534f20f852445dcd9c6965fa3fec1278b7ec19fd1707fe67684383cbd9b6ab5a114a449d227d6c136291161f32ae4bd39dfaffee4da920f835aeecda14378c1d177b196c10c6b433cacdcfc4a876a467d5562f18c326b861df919bffd9ec4862e5db3e109e4bd35a1f2dbd8c1410c58f7381ef2b005636abd1cd979dd0dbc1f0bf8a91295ba56d5fdd3c43b0ca335454c7c91a6e153199a0e41c74c1ba5a57ca60939f104c7e7ed36a4bde80d9ea505f2243f0fd80a152569108e524ee8218b2260f35f5696309d3f7653da718e26389bf7edba92f05094799f6772f29cdfb9ac953bb0d13d349256ed3fb20160e8410c35afdd815c96718b9d42708eace45b7e44d72dad63c86115e5cd2304f055564ab59ee99767617adfde9d1541d5b2c35a7387e62078f55c9b785768196b790d33b70a3f0bcddfd09e651aa11687bedaca68cc3d2fe3935c38fe0ccbea7f6a1ceafbbaa328895034779a789d501380081ae7bac54b9c8888ca869c2a474eccb716f6ec2b5da47da9a70b39b1bdb89679ff9075ddb915e7c2a08f79d764f4106372316f2e1a5b73277a99d3e37e427baf63dcf048fe52c85b7d772a878681b45d4002db4f333b44520f385628b551f70dba6d4f2c4c612926d81f345fb676ea325720b30b344cba74217c466d2faba33e6fad3e6404e39827fefc598bd8db4dea4719572a71c11e832b9d596df76ecc1c3ea90e2a10f04aaee46d2d59856fbb2ef5a832f2fd6a0008256baa1442af4a2c4aab475cff98042f59fc8798d9ba56e34e5bf0e256127e301b6917d0af6e32ddee3f0bd93e1aac1e5c7d8ac4764882c9d445a5c7af771b6062953b759ac7c65ca22c8a3f02ccb39126013773c720a393560ba6d84c71d2012c9d6e1a55b0aa6897ca433330e18505dadaf4172538876d1df54a4716170c373c36dca11822bd2f34c5f63bb220883b47ff42cd7d71b35bb12e76e15bbbb6a804c84d5f51f890e4e75c15c01198550d24715f76f2f49ad234f26462221d57bf74e8726930cf328720f9f7c7d7adbc1743afcf75e696dd854634cc51f96400af4353cbdabe6b422e5ec0e06104328f609e7c28d97ce0d397e9736afb4cb44c1d6a002a091e166d3c3f3f46f7fc99884d1b98732c9efa1aa8267df661cfdedf680daa78241177fd846b68d9cf8f74e942e460352e3572d1126865cbc0d56f1aa9fba2b7cf3a6decf7f93efa6c95b8c89ed5ef8bd0b31aba28e8722d892eb147ce8e5f0e2db82e8840c871cfe5d96fbec4fa414fda507e54f690bac5614cee8ac93f36cea12b8ae4205fb8b0677754cde5a3f3d8334f5336dd3eaa0aa9f7a4c1481e0b861e1584ea957c9853cc289dc69ff7afa0aa1149892d43c09dec9621ca3feba402a8d62f06e5ef55933b34aa5ecee56dda339aedc4b1fcda984c5de9ee6e899d5edc1258a0e6111fdbb2ddccfbc30e19c869e0bef35bc8ee6432bd57d4ff9c1f4c0eb1dd295e3372ede1151b23e360875dbfc788eeee502a814c6422c7245873626276578817ca4e5700d050084f68f914bbb16c0e7f38d416b8211d80231f443364e08861c8b3996ab4d62494e6cecbdc2b287975b568a1c699d0d5e1560b311ed78f98b79ac052744bef519c2ec9b4e1b0dbd24d5e0475f68136597859152780e1ea051e41cbc88ad311f532e7fa9315f435ac0ef1151443e877aa7d54dd34c925039c331f0a683e2071db87b8fc334728dcc85dd8eb7cfeb9faeb29ba177fde9c3cd1ea5d7cb5e169a33557982716ac827f7eed8f67ffc0df1b7e8ad402180dbc0cb98c7d53eccdac01f49b0b5392be0f3acac74c0fc2212b925f02b8efe327438549e7835c9e2ed50ec3be547da3d43548f75a0b94e6c76599ed87cd416ff4e4e8c8d3fbd05854df0df816309941e5f928d515662cefb959d75b4b88b4016babfac4addd9b463f0f1e788368238335d39d795499cec2828ebc9fa5449346cc50bed317549d9dd44eeef2fe34c848b87a1562ee1c3988a947c8679325c17ef2ced9a22cf687ca588a8b605faad804610a25fef01e499b8a0dcd9f5e833c1f59a89f170809565ac6c7c4fd7541043394bcd0028a84a94cf8ee13e55ad0d6bee204b99a7acbb12e7bd9c397d2ed1c595ef788b55282beb9774b60f41c37e0f70f6737e81efac4d848a6ace06a8173415c65a2e509d812e6db8ffa6b9f23228a0b5bb34d7452fb47c55a27f627c997f6bb8a68b69b63a5ce034270c6486ce11b9231541fb44ae39bd369153708f30c1ac96683e31ea31876337d4791d9d08abd357b1fb9693d90e3bce5ba01f9dc3509afb25db960fbc83cdee7d3f9f6b7658171dd543b6b7299d4ece402dd0676cc71d897627923ae3a6bc8e9f6dd961b591510658f68995dc2bb5bae27fd3fd279e8bf59927dff499159c548026d5ad4bb208c5d90ed408aaa0cf91d5b248eabed0454afa9734ac524719751871db26c988f4635581243db9b4e44559f4dc1ec7b4badcc361e7fc657a7bb6984bcf2c22b2fbf81715305b3e7a05ff9ba96d735c3b935ddb68a8d88cd1f07bef4e9fb84e52fe7ac6b7b774fa1184a3bf81731136008506098fd12474dc299de2b6275a498f7d6184546ffb3455c575889b9e983ac758624c64ba03fda71d2fbe3ea1a116594c84b3ebc450617e33c37c4513f25126efe5fd57538e31f1511262225211aa9f3474394b253f96ac1d6a322b96b9aa1769f830bb68d6f1a80967b7e04c2d61cb9531ba4ea5eb6c88b17c4cd4928f42f7fcb81e1c6edead92caec4491171b50281d72d001ddc6444b25c6bfc923dea73f492666277d1664d9ecde059f336095f04bc3e97d1d5fb2e30bd9acd32ef09f68063dcc1fae9be37132e1d43996dfeb238b617806d0826ec31c4925419110eacb54dac505a72f9ae01a1f2bdd2f90936d2b21af882c238d88fac3af966319d764033619119769a5c06b6f6415c7c887edf051579d4d625124757147dda09934a7c70fe8dfcfe700f92bbfd5a074447ffac9d70983f2859f388a2f74354ae41fa06b2a460d23378aa95a305bd37e8880fefadc8825826b9e359be90c733603811ec4e0e7974b9901608d73c5c881062f2de397b635c227462e92d72be680620903e396e4fcdf0234be5f6f13f48d445b3f15b27f9ebbcb6dd7fcb2b8fd1f83000788d9981c5521a3b0bb8d7f9678a3d12037710c9fa1a6340629cf7cbe8ecc7bb1f7c8031ba3881e3e81c58e344d7d5309c45e6100c5eee2e4c6b95bb359177e2034ad9b96fe81621e30be3f6451485f4cd06a18b8a1ba5cfd89da0e2f17f962df435c599fd42602f1e3dc9d765657f68ddf88e8087a1598a7319c20c1e8b73d5139557a126cd331cf1331c53eaefd010b1f8b25b34d320e6924e039453c32b91f5c250ec54743da537dbac87e5c2f1bf3efbaec5db3f7c9d921502ae76b18ed49a7be2aaf02944e931768d614cba66b6cab984f290cb936d595ac0a66ef136797f56a7fb5fda41d2238edb15fca254c8c9225d7105795075581815eea069f1681268c90ba4967611a235898174557703fd63cbe948a6c83ea0fff290a9ad770ae17987dabadcd9a950482bf9dcf315a2c3ceaed848e71aead1231ce48e1fe6291135eee7dcfe73b2eda868b6a2603ce686c206b372ef04a6e174af0e8a0dd097d643f7f5cb4da001aab7c3efed5b0842b9ebfebcaca8d2109a70f854d767b8d94c32a1a1361a2d8af334585d2d333f604ac8f0083630b3fd9004880df63a508abdbfd54df815b95f9d48b17aa87d87cbec3ca201ae9af1762dc8323cc4817df14e8461d21ac9af23302803f2d87b65ce5ea7c2c3eeea293fb084cb18eacd5b9c3972668bc267ace390d257c61f20aea0cab6712d9043e4f8b0eb830be9f3dff1d9b49836e1dd1a4c0b836bc0efe921626e3b40593933f424fc321b3dc36f477a79eca79bd951e740fcf864e76a482f0082edd3458ba11c34b464e646013cb09c4f29b6eafb535f327748ba40ec208b6b669a874edfcae8c5a87caab6f44fff106fed7acd83dfd69b5b3da4df48f7b7bff2ad98a9c0436e28bd912b41f60bed03555058a6aa558169a11b3512769d228fa769eceb64fd1f8ffc1143356b60ddcf661b71555af1d8f2c407ceb36437f3e5b85d82b29c3a8079e6024c84ca91d47912ceb1b405bf07ccc8c8283c513dabc81d5bbaedcfd4226f9277e445c42160b4bf7b77b2894fb43f90e54013b197810879fd624db401140b24112390050409f221d5c639e22ea4a12ac150362bacba56512db6efb7d8325e71375e5d53ee542edb0d641636a7626fe1c03b398ee7266cd29c9fb89c4eb965ecc05a987bfcbd489e258f76e8635f82aa9016dd5370e9379736579b2b69ac0342ef2ea1f36b59dbfc06c1b94c8f70aebbf0c278fcc35574975d35708d76db878dcd740dd5aa34678b36637cc9556da223a6ecaf8e103a931a053ecef3e449d1253d8ae90b84d112838660e93bfd33fbcd7a72a4cce3b640b903cfd09e3c3dc08859a61aa426a46d0a01a332796516a4ec8d12fc633134ef51234359ad4071e3448e876078a759a3980a36129c53fba15043eef85620a29ed9f1a9f63198634105215dec7fcf9dfda6b6a33e768af78ded0a1039b46121fafdbf022b6050a9ea248e9cf72fc6830fef0ca2a76c781d4e8462f355a696677db6f84bcb67c4b98a856b4cbb0ecd85b50534a9f839b7b84b54c2506508d320141b12d2b05e8f6111f467860e19815255ef307b9f9faae16a2656b1c19e55e8daab192367b4ce4b8b19be8d640e5b520cf1dcedcd753aca21098875b1fae61c729d0794dc1ccce5ad4c1a54e1dbb46c0d453a753b365834ac6df96d9ff6d53d3002fa43d3916b69849b91bbbedfaf88318303302a03414ca1ff5dd5e1c6940fd4d1bf7b5d5736638ac4bb34e64055f399e006b4850cad939e1a2ba1f5460cdbf94f582312c5bfa664bc4efc4901a2b4d1777677de110d128ad9ee4f0c3a858b9605133b8406e227e8e24ed7ce37466d929f2bed5d74d0c86abc9b37792dc056c8467f0d2c7269f86b8f6de1c5effd5303507044f0848fa12ab36caf963348f2156d77414d0290f0e317f97d6f682378824439ffd1343f4763cad71abf60106337dfea5cddf698c4c5f17ae061262b72d05da5c3497e0f4b505a9fd7e6ff39c36263c9af7768d99d2b6434608f0dce6430fd31fb24fd47d94d4cf0bf51f8f8b4469a2edfc1e597fa6ee8bad2375dfb5962b12911a84f1dc1253cc01047fa8c8ea1fdf3772685305092797598a067773373df02f25f6e84c44bbbdd8a8abdc702b8673671b528d856e30e0d74e45d35fc06edf7aef223ed09e65c80da79377e3953d1d0426fb03576539fb6ec2f4ab52756d9f7dabdc0e6f4ca3163ab42b0fe11281a0c44152c8b1bc63fd058aa38a00cf09f2575393907ab9fffbbc3bf72ed6a143bbb82df11af3bed37afdaca42eb0d6278e36b52e93dfffc6a6e8e6cad19f78a1bef19dabc98a5ebb1d77909a17a0ba0dbd54a6ff69873f54f3933e37b5d83475c0bf01f2aac430e762b0624de00a8aab72ce430bfa2680e438ae5d752453b73794274a52b8fef1fce8b0280b567efef9022aac0feb7039b709a4e1d229b326a3ae648f2411fc8bed429339a10036278c1b6f90ca764d268d446b78881ca321c7749b7ed250174c607080f3f9ac946b6d356b59aff7ffc125ff4b3cddbe0437ba577c05730b6951cc28159d6e5c326088fb8f13f34e54fd3237bf462572c80ba7338db0993e590ea7b1beb37e6f3ac4bbf81fa543d603b8492daac8aa4ceeb0613c38e44c80fcec73e84ff9cfd989ca95ad6fcc767a7b2a5c1b24776dffe1fa19f693a18ff7545832d0c51b37b5bcc82c225d9ee094d8fa2adbdb525feae55167d6be30955bb308d9be444e553d1ca0e09f4b0514579eade1372849a4104e0332ac5383615652c34413f456af77b3407f180623619a13fb4608878a4d9efa4b239894045db0938338cdbb7d663ac36a8ea7e2aab748d443eddf7b7a514aefdebcfc2b704afea4bd6b4c763b837576235be860da8311b507fff91fa8b41ac58cda45f31de941a5eae99f1ebfe1822fd9ee60cbb1688a754da7c44a000b2152ee73e87d6aed1e6833f176032acf0d77c0d55a4877204c77f4313625ef642cbe98fddb501a7ea22f387d86ed430f62649ca68aa587519a463a8b8e07c17a9dadc8cb86223d41766b47215dd7cf447eac886733a13df96d44988f2d5bd7f81bc634346cebf878bb1a879444f32a11cba37602d39450c09e7432d39806bfde81b4359b1a0269049e806dc123e1e28aa1376740d1984a1b83fca409be97656bca404f66bf9cfa5352eb4bae85089255eef5979cd650a94ca3dac1be0c414aec92a6449eae93af899e97340a554e12293f846e5beddcf57c41f9d1113ac3237df694e21e6be3262fd2494402c9423a65ce3ecb2b7faeaf7e8df0a575dbfb320aaef502ba25fe8b5dbc5c1a4059261c6ee277208cbcd4dfff102f5057f596567b65201a61791bbed30de2460fd4f0a647a9bfa4559f07da6c8ea74f2a6c0619ac054d64e074a7d8f050550a676377a5aa01cbac7624402853a9fdf5ba267de172cf54663354dd52a0c0bd011160cee0ae818000da2c63c83c8bfaf6cb88d3c935bac4c81a6a566238353b252283f3c49a27dda667768ecaffdd5520c483da4670e55233ccfd5654c18dab8df907304dbc62c835544595c07aea5f3c02bc6de17e8d80eae1d31f40692c81f4fa0b882a48123f32483db063f957846938e1115fe222a28e194f2424b20649caae5213bc287235854ceaf416b7e4e3a83938a65fd135d7e97129eccc25e58fc707234695a2b0e047dfa0111255c5a353c3210e0a70ce5d3471eb6b10b8b0f56653d28ab1cb8b2882d389e48fbad04c659ef64f632caae4ae38991742f6852f9eaa4228c05eaf0ed7eac4d7f962d2a40dd4d82ccc505399d5bd4d7c53290e0f6a208a49f9294cbeaa8dda66aa288fa028509abcf29a237bf959a2c81e4f5b68adc60379e99ff835566bcb23335845fd1bb380c266d622ae197431ffef175924d2f09e323d7b886e89dc94e8d2c4aa90623aa136f362fe6dcc2fac85a29fb2f86f2dbe167dc102b66a713e5ce1e4cd4fc51ff725140674beb78d333b3c684de8151b2dfcb10feef5fa1d4a8bc56196e5939bf947c109b3848a9652d4341205acf7b01a874f697f33758e10b994d0713ea8c4993669e6727906ecdcdb83455210e163d68477ab2a18eb78f3118d8dda025c1405777916f15be75fbb6d4f3cf20afcc80b9583a2373c745b13e2340cd713898d7dfa7d9d9f3701df3c228ac996405c829c8ac086e09dff8c5d58b723be678c08d9e4d19fde06a0c6bf2d54db5731c2ba90db9ee1d4d722ee030af09da8ae04a185a10b1307be20f4bd003454f885e419f94697005df7790c166dc04c023bb0386a6466e073638d4d7156fdcddc30b6a83c781babef987e98e2b214016f63dba697ddfc949151e625d2caa391ed97263a05ced09c40483959000c1682edbe18d90e8236bc9f5bfa0e513c1d141d492e6b23995d8c054b026fda6fb61200323e8ad7a7f441e1fb99b4e526eaab6e1526cc9e17d0fe8f4cb8f873675631474c436e9478bdcf611ed4fdd90e13e452ada1fae7b58bb500495aa45cd4afc88ed12bc4125f5bdff068d5c08a2dab3d7d6a8be8ae4fb73e6f906ef4bf75c0f878de8a1ee66a1a4d731fcc726da14f7a535073d63e51922291350944a94fee6e9ab9c2903c5b8094e5c6180d3dbee249e72a0af183bfdf670c9bd1039e40412b44d23e5d776832c62d8cf07ae80a99d121cab5e53d255126df786c6584a5a9b704e6d1f1d9b4ad3aca6a47500a07738c385e52d28f771940d634baae014bf515c44467d0e651ffbc0f832151ec8321a975426fdcd09e465de5e7baa8f59dd26869936181598226ba34c4a7a7130d2efea37e036cea69ae49e6a69aa5d49bf44f0d7c7ec21030a6e397da8c2f4f9e3a7890c42728ca59601ee952848693068acdd6766a2eec92f3b01fc8253a9d77cd8e1b10742399897356a67e1303c98479e80ee75c2a00c03880a1f39601058aca149e79db135fa3af7625082b7257393f0ba10f318c801245b9f9d4046589657d265d103197d09d91205eeda48bd4289317fbc7ac0adc2309f1ca798a7a5ca3f0ed282b63e4b98e3a9b68e1c93c19a8d77f0a6e2b0ac07c8cff3e119588093d4ceaf3fffca19a371be43db9d96d8744b6dacc84bc6b790733e54f5b7940d7884a04d59ad46b6c255eb43ae8978a56d965fb9ed7644eb2858d6796a9025b328620a8dc32de15d384638ec0a61767276b61d91da1c27ec2a4d98750e37b1bdd47bfe4e079b2eadf8db86e76bccda5f0b21ba2f731aa90af96ca9f0988abd99d53161911853f772354a21c57509ae603baa8a1b943edc283d3a7daf10a968af8d37e1d406b04fee11737939fb19547f60e0abfab62cd6da8582a9feba2ef82ffee6d45b7e5a335ce5a60f8bab725b0e438eaac6a1d2f477bf07cd8e065e3bdd1dcc7b16106dc41c57048cc641a33cf6bb4a78b8b6b43f783ddf94276188a6b36bb223f0b36627c25a3b833cdc6a77a441d35b120141d1a46801ffc93670f751fdb9de78215a0e9a1b93d5ec9446910e0b4a956255833c82ef5d32cbb0e7f3f532acbc0011b033bb59e3af72d665d190ec52addd90ead51299dec91f8fb618e76fc5c4dfe43dec08fb6ad5fa313692f342e4bedae64992b1c349f5f1051292d467d19e39bb18e72c1dc8ad28d9f7301340c7b9da5534f603e9f51ab54bacb34f0d1833f5502a09c90b3573190c9c0abdd230219292c842b57f0de5c9dd92c9a97a0458bdb51000a17fcfa8b807e2498870813695a21347c15e6f4819f8e56a84f7429a99e948fa69d9adf3b1e43b71a46e434c12ea71811f90460fe4cd4c5703e6274572d189ef1e5a90203465c904c6299ccb062804f552a8d220664ebf0cc5b86b50699966c057e236ac2978fd9775968759a02c8a12af49fd9d2e83d1c9012b4144546d7b6251bbd9a4937a4434fd10a4531bdf7d0ce800cf6dd70f716d1323c779e9db4142e9fe3c49e19d2dee55abea73c81c2b4b07bd870841d529e4427fd80e03f298f6645daa33baa340e5c7e87102d0884fa8dadb17d0c949d2e916510bf01105cb18885534601020a97a086b9fce880c8e44ba5210098d451fb83ab6653bbef4e8f9c49518418f0f7b9512c0dfc6b6529aeb0b04127926a2b00f5445621671d34bb74a39ec2a32fb69978389183ddf167f7dbf8aa2cb554aceab90f5578ff10698836cead32762610247333ba45d9ef804bd631a553eea3b918a7e96b308d921e7309802ad59a4e7f9e21590f0b6a2d7bf24adae7ff97d7e909d822e61b3a530575a364f48408c1a1313e5f7c9f5f6ae42f45ac8fcce06387c546283a8bc2c1e12a7469769c9219abcbb0e0d203b35c104920e6bb60c6b449535db453f0540ee95e92d3b1834b365aa55b3a6c4bfb5d0a853921dc11c1bef438fa0828c766102869c6a090155a93a39e49ce4c0bc12f4fc04a9197501fa2f18ac9c989c8f297a855cd880dd9cdd4231885229066d5555374a148a6abe40f0f5d458136d5e2e0f8686499bfce40bc976227f6290e65d5f26c09c29c401ff52b9b941734a2f6bd517befe7b3eef579e0bca123a96ec86bc345ccd49d1f2bf4c98184a152206490751f02322b533b4e935544d7a6dfa249636cfd4e47a9f9189ada4c1a80870ded466868f4a5fa5352fc215306e3eb432b09b874f2e5f71b66de993363055ec20880983b05c6a52ef2b6f19cba72012609cfd313b6cafc5ed49c937cbbcc0dea3365312caab176489cd20f176763e6cf714c5c3f04e9a22ddced77437b92215441c2d3d2ae101e8e11378002c80a1c51fb2e23716d718864840a3f826f87c4ab93ddaa280395a826f5818967db77c13de91b103aafab0c527572776e6b8411967b6eb68213244b9b7a5fc978b693ac3d80213e010e0e9036fe84d6deb56371e24ffe1756e530bbd22cc8873ab1cada85d2a75b04176be453e016ba07a45c00d62f31b3c1fd939b10bdbcf060908e82e19963bde812d66ecd13273fad4a71aa8784f8ccc36510e039b3d5ba2cec1d6f00c0d5f464a3358e82860d13b20540a79c0ec7e4e73a03fe83d7cca4244d1c421046b5913e36979ba7f13ec319f7196e71304373726bb4cc011bda6d058f20aedd4402d1abc0e21c21ec04ab56d739039c257a1903e7005be32bc61d2bf0699a9d45cb6474526d6bc7df83905a22972d41d4b357412c68d8ab819bbfd46c741eb3498481c6be02f4b525932034eb272cac5c7e9575ce068bf97948f8bbb6e88cde220a76e7e3c45720fef92294016749a8a5b39b24e7a030edc40ea909a96ead2ef28d1774eda1fd69915e1ad4b47d22bdfc5ef0822c1c6396af98f1f1f821480229fa5a5410cf7517082db65ed6034bdf59fc687d8a89f8e46c198061390a0830dd0e2cec763f83dab4bbefdfc839e6e294509927f28b2804eae086618951bb250554ee7f4680ecfc7f67b4d3db55e71d0b93a590a795c7760ba60c3912a8bd7533f238b426587512cc248b0cfc9f88604c12c8117f6694abeaf29a59d6158e1b2e1c877b0958485cc0d75fe9fa1089832a0cdfd477e99eac861a58f45ab0fce37621047ba0479c1ffd6d43a2e593a6df8578d66fd91fda02842fa96618bc87b76386410fa89860d7fcfba469a19243b32fed3babd74f6f2b79a6be645f61130f7fdb811776a1a156b5daa0f5da44ed61c62a7ce4411a6b2d6bae9f52f0904957a3f7a7824a489de30c872ed1d8867f2e51bdc918354c15769e192f0992f74a1354950409fe23ba3adb35e4c0ab6b48efe74c8e29d4deca83d0be48dc004c9d4569c99146f9a951c641fd9a7a4d9e33ca8abd36b6b232e12506a0973f3ab00af486f0b2d2b973cfedb6906d47788b79eaadec8740204fe5229a5c4e05750c183668e30a369e81e21d6e92a10980c0aa7f486c05358a9eba168a13781da31b8d7dc478bbeb81fc9900b19269e9976294fdc768b1ce86fa15cef9431972275fe0f0a2db89d225bb54713f2403b8eafd5240ae841474f83cf64d5b0163bdb556d1f5880ee697758475b321c4d70c86694c5d7ac0a5f16ec7c248330e8027e0dced31c85b1983e37d1eeab17eff872d048d8aa34a7e59ad7e78e3fe54dfb8309964a7e5da16cc9775284dedead0c8176d3b07f58942dac1022deeb9de8a9ee4be519df6a103f519c91950887d2bac6d066a652e7e157d5e74c3afcd5a00140aaeba9417880204fbf24249768caa8a28caa9ca10c2cf016074b2498630c90602837f4d1232a4ea179256f844af6e0f191c31c5a05d3cc46f2ed746debabc99c1208ec56f8bc52e340c9e72da933e829a933927819a4b56c83b3f491ab41ad1b75228344f3fd34d62d749c42e3e4c567f147398b07a9c19fb621a6bea2d71781c94e2596d1e230f82f1e7f120f473e2675f6e838279b87f4259ae560c5af44b59436c2d52715b09540162fdbc05a75cc79e88ac35f36efbab3d115397352358f96018745ae4775c71e0c1f19bcf2f45f63283994689546f882beabc98332c8ca5957e583a8b4c67436732f3872b2e995f5880ebf87b5c9530da52e2d8bd2edef2f6d025348644b9e6024846fa87b1ef9f54930440dc82e1a442f2dcb75579c6ddb8d3b3324f493f93971fae9cc5e256b9b6a7ffb75e2ff5bcb7bb263e115aa746ea62acd76da975d7d7fbc8fb12fd0a28228cecea67976c7c6855b8fde18234ad18a5635994b896bcfa3e813482898ca072d242b533ec359f35e1123521d5fd8f549b1edeb9dedc17380c25e42dd92bb703adb946248ecdc59c7dac4b1b1156a5a547a8f3583678b17e8f18bc4f18e91cabc6bd4c673a867f165a3ee91373435aa17311e416449f8665ce2e8740b6555a64d735b46f3bb3e6a6caafc4b1aad88326a7ece027eff0809ecb0d3f0c1d51ece54741546d285a17bee75b72406d10ebd12a5cc077c891463e23839acef1a3bf222d234289a92fb7db08392dc7a1fd49c3dd44ac956534ceca8a2f917d06d043e496c495c6ee2bcf7dce8814e40ff832f7e9757bf232a41d6bde9d57f903003812420ee35f7c3fe397003782552fcd3f617f7ef8283e2a5ab6d8e935d677ffaceaa83ca212916bbd4a1ffcc74cc129691f4c507ae74c17dbce11a4e1c44d70de262250f0168ee07e793485f6a1f780b45aace85295bc9f83d007612be1bd063a554f2bb76258641fe9c09fabf9ea5f489e445850a5e8e68fe5fed9c9073a90bb83c1f8fae6537dad5a810db5fff7de05e4cf7a30e2135444331a4ffdb8754db202581edb94187d07a9e54ebb9852429d83520f4253b2f42b00c6cb357ac433d2405998ddd2ecce54e2744bd2512d7e0fcde532e06a842a080426f6cc453077bb29ebaeafa6b6b11daf82c7ba2cba33012787bd0c7f7fdd39fd80e71c860991c89e681f59f6f72bac27c4f842a727b549e6118dc3e7cf38d53d0280dc305d519278ec2be75858139e38b3e4cbf30c2656009e8b86f53350d0e42499336aace5687c7e73c8a54f34eb301f0ac1d8e965bf310649886c8ccdacb8261030092be3b7a3267104e12ea7bcf3ebdb8cea581761896121182b3710a766caafcb4a8fa282ae2001208e541d795ffdf07648a1c1d6eb51228b8f65138881f19c2233a32e8a3af53eee370178863b6c154e9d4ef2ab0e585f41e5ff78b4291ba57d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
