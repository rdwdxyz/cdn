<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6a239f3850af50e25902ce641e0cb7f1e051f372699ff02d8aa7f17113d1477664536b2c3f082cbec81e14d1e9362b91b4e0782381977a0dc06c0adbd187f19feb0c77e6d82b9e2fab40c3d3f022ae2d3a5714c356ea8f92b10f9478c0bef2f95c0560f5bdee0f59068858d5f98b5d67fce7f4cfe3d547e7da9006315b339aa6f1570263e07a68de8226fa42ffc116b8607c2de59e62f77d723b4deeeee5c2d8ca57047ff1573c5b7ecfa86b489c0fba9137ff420a83c4f8b63b3f5b529e5a17be1395b20abbdbd7e0b6b41aa877062b30967fbcdea520ffe074b8080e4e3e8dcc50aeb89605fe9efc286b21ddd3f2606d08b8cc11fdd9ec79cbf498ad6909b2ea9395b165a2b33f98e3fd626b346ca7b1c47a7e10c4dc1cd80b5cdec1ea7759d734ca4b56e2626fd1f9bedb84b62a0e6a6d8c5952e2ed8e9768bb08c98540d6ba80934dc34c68ea82affd8b5ecb8835bc13fae8384c25b5303b296cf283c5d9cd425d1ee9ea428aec4061b4f9929fed6b3ab276368974ae1f2e1c210b3cc1c992c8def3a6fbbead577f200064fc4bd7d575c5b116f47d793674f74557441acb4c25058ee1b8709a9fa520ec2a0dc6a31218cb175716ee2e8b45ff26e938955832ee752b868d0a4de4ecc00240ed46a31d186671e1171c5dd10218cab082c1f1917a3ec2fae4df738eb5cf981ecc06e566e9c22840af3e7af8d34ce499360bd21344bfce15486cd11421884fa95930c3bb122299a2cb6d75658549c32845c56acdb8d2d7dff360478bb6cc25b820a370a99aa22c975106344cea949ecce44499aeaa7161a933da65c3f645fd4ae1b3759b3741fa7f5ce39fbf4bbf7a03e7da8ed7b0eda02d86faeee5ea9d44fc4c3fa4951de12ba71d53ef659f7284b005f58f779e016e0b930baa074a0f4a6cf35e6263b6fee29172483884dcb58392238f403fcd4cebf9bffd215a2cd81542953e03f25e63c30b1e30a0e8bd2c6211dcc2f7a52aa117d9d2f5fef25bd233d869ebade2991a026284d1a519212051f023d6fecabb1f2bdedc535f89d9717ca048c9726766bf1919f057b0b24938ac4fa341c136cb46f111b8f4708a31b5a1468b88ff3b60cec2b1f6f5bc6bfc504a1abfcc55c40bfa37a1c290f7d3486eff779a387752a7fd948ccacb1946be003a0fb494ef78f5d53d69baa247816ac9e9657498ee672bdb6e15578313d305a6d6854d08ca83521387b7bea001365398bb90a8b211752affe3c0d60cf4ecd7270116f795c9616eb961df4f0988db3c14c98b33b11b040afc07fa7862f4d0a9334aae9c8e866050e8567ad8d24e7c7a90c691766dba7908b2fa518907964d85566bcf53c268e0b8c06923baf7ffce75471ba59a93ff86f143299f72512eacd352f73ce6a9a2c09152a06d42a7312fd1e298439bcc3c1fc3a35da8e27e40bfe1a2657735c83c57a0f2b0129b90ccd370e6af5473599b67452516a0004a7357722514b1e574537f733ea1b3c79c030fa8a68800ff070102e6bccdacca7f1454ce8bbe2dc8d525e8dd4767fb88aed9431e0bc3f182d4287bcd31b816b970d988bed423e88ebc85c9093c4ade36fb05f486676449fd6fe389130d96bd1739fb495eb9264a585f437467ac304e44d9d4135b7ab8ced5132bc1426eb95b1068fdaf19f32d36b36396b3b75d4493508b1bd990cf83f10e5d721e68e38ef87baf49c7f3d9798dce9fab1417703f5fb4ce2c48d59624e90b2c6d2db0aab9597ab6d6d2a1fdf65e27f773cc6336e3faef763b8490c7e79dbc0581b6cecfdfc97c0f3b7cf061ce4df5b0eb45e9de62906823ac1e68fcb2e2c315c36fd3456a225f3e542b441940937534e4983aa122c1011bc5f69dc2d1733e2ba4c4f973c057443b67420590a8204c60bfc8b1bf9a1268902e18e34ba1a29ce4710cc8c66a5a3ec3daaac864c6f9696c4bb7b8aab25b916fdadfb7c104f94139a31fed3b387302800178adc367fd6bbed1ae5e832fc55d70db1752ac445594ae1c770f608304003fe561371e60425a1266c69e226dbe4180cbcbe35c11008723c324b859a21735e7ff0774b0b113d0ed78e078e9191251f23249d7b17a083769ed6f4db31100153ff4375a9169afe5ee597a59231b198f96fd6f3480db19e192e93a0430afa278db8bb68e312005c1701bf19fcb7133a1d19d69b1dacbabeeb92b2d5dd291e9dc23519251f9a7a8a51096e9934613a2e5d8abd73a97b3ace2536f0d287de34e06bdc96c1280dd2747dface38d1003de13097d781bcae68d8f3db558d7f936c649b4b1d2ae39d2ca6f9a98520412625455a282753e5a131f0dfad3dccb95a05c9cd3e4f259e538dfdfa69a9f2740befe1efde733d85a1b3d9c3a506f7e8b00df76754b0611429819f8315197432f2f89de5686d568383684895460afded4e57397f76bbf94bee8e5c7510d5e3b2f6efc9f814f1b0f7a2fced280b9858c7beb15d4eae0fd2124f428911d60fad8c16642d84561f09b078497dd14128e9e5cd4dd73963833269b309961b8093ee31c2cb71d270f75e8678476b750140821a2433923b5d82c2a59d1319ee3fc296929fce30749bb42eddf44aa36fb3d29dfe8f395b2305c8f3840887ce788f88d6d1bbc2b6124a67509acd733583d6c9e1d8bf17602e85c2ab82590244fa4e1ea6a17a977b5179414fa67ccc6dd338e59ea5357467ef616984f4b371d1ae378dc1bc5a89ae39430367c58c1256ff510287ffe68a46aa17af83579a96b59c1192b46ba14752a7c2b383bfa6fa1549c85b242deda469b6a5005fe09a51d0cc5844d226ca33a3bfe909b693c6925c4669b98cb2fec88486041107a166b8ef5146d4ab725aba406a5fe8e59a0cbbdb0d906640012fa0740fe43f3c3581b78460e79099441873562dba026eb3b7fa3b1f6c1900364f43c37a0265141d2b83e4e1cc502fe87c800cc2b13d378441cbdb19187c58c90517bba605d3634c47079c6d85001e7e66445a24de61c2c22e925d82e834acd2167a8ef73c82986faba456bfe060672fdf7c7fb1f9af17222fb421979c47373706d18f32f87ccd488acef9312ad53e8b15a743895cfe8c21acae9275f939dc3b6519933f256b727dfa9728ba703637c4ff60cff2352b67c852eea18a65640f87fe9f431132cf62d10d03339d0dfb8271a3655da04dad936bff4ee489458a837ea9b591d2b15070e34fbd7b832ef25906eba65003a714ceee83c3f3d21465b7e76333d2b6ce5eea3200600afc250bc9f20c1be4d640db3ec42c6f2398dc8ec6213cc53119f9124417fa6263d50455d5c96f2b0ffa55eb9f71d78e0bcc2e3157cffae04f95a586350ad4f291638ce527275b3a52dd836b865dd49cc7914eaa4dd9ab730112ee2df755dc176d0a73dd1c6ecb95d4c6569f011015773dc610ceda3d516aa8e001f9bbc57dbf8ac4ed4d3b76430ad6d8c8eb1243863eff5bacaac0f434d44adc6bac40f11fc8ef114513e2f102d703c0e18ca04fc3cefd4d0317e78cc4d3ae5a824c87c61df8810a7529efcc17d80eb2af1047314b1adf4f3aaedfdb66a222409ad9b00149154735e321950210e6e0c65667bc1dfbc3b0fdeb045bf8f430ea1322fda83f5bc3d84d20490ee94ddbcb09ea615257323e487ffa29ce402602501bd3f04467ed1ff0ca3666e6c532de0c2ee27714b8f9ef8f329d3894f40da6cfaeb0c02e3be9d79f90056e20926e644c135bea80a622a75cccd10d533a91ebbb2d29950a2e61d77afb0c26cee08b0130e1f78e91fa28b6d134c5b502126665eb9d5bf33d84ca37320e99c0b4fe6df3d6e194e9d87ca80c34acd2788e39579770c14cfee0c45e07da2588c9ca7961f6e97157d8b20a0515403f9c5e5f1403f67abc54c4bc4a2552cea143bab0d346863fb98e2c101b1b91121d9f8e99d5eb6c04d6cb64ac31642ff3d8ed25aced96ce5df9c48d5c8b78b5f8e5795ae7b15d76a3eb5e355aec20018dc22d1ef1a53d035be31268bb6582dca35bdc4c44173c09b9ee715ab5e46168f9c8d21812c95be0bfc8715221ca59d404d9e52e908e5f8a4efe65e207039af9a2f198ba4191de9c13efb0ed69d97878597dc1b96d7c811aab223c21b7e7296c8930bb373da90e863a4af0cae122dd6b30002604c0c4351637f1ca36c9719a86deaaa3a52d3c2915b74bc34e9d28d5d4d45cd35aaab4014dd3f5eae13c3548594ae1990efcab25a09f7fac8226871bda4441fbda47044d7d30f180c5c8740d0c8a7b33b11c832f3140e7b42822e733ce178c5f5538030b88dfce858de05de386872b99bdc08be1ce162d13879d520e9edc9e78aaaebdf75436ac8769c2b5e33495ab1419f6e0958ae8ff13832afeec901ee48a6af4245223f5f4f2f72c3f8ab6dd2d93e135677ef33fb2238519c14da252f2f5073c17e47c5fb016c43545420cc35e4ac831b50b86858c41bdbc86c660c8eeeb9d9c127cd9adfe49f26396ee126a6408d99468952586794ebdcd7ff765e9fd9a35080994ef55e548301932c60b9e87aaa986f6586b87968478b5e3c1a4e19df2868d1cdcb9dd5a9231c96e80df686b4a11c86313649e07c31863b0642f276a580c5f6a10ec1ac591594278f8ef8470b554793080f64a747db16cabda7aee2b6b71133ec3b58116b21ca77ad7a828afa58bab0246ac2e1c53c0e1cefe507044f58a3d325fae1bde4aa7c209b3be7ad82e009b7f40a9367f1e75fe00213cce666c739e9ae37e48eeab4c030bda4b5e4ae06780df865754ca56ebb9c15d08286f12eaf334f60d56d465b8fbd5aa86e38d170d9b07903661a615669d99bd97bda538c5b0d3b6ecc854f41fdec25ea75238f4ddf024388e26b67b261b3136161b3432e50a2e2f0f7ef3a3be08098b7da2361361dc3011e83492ec9ad42470e89b0fb1f4c5e1a5da1f0a7e7ac474acb153d1483109a419eb35cdc7d263186da72cb9ae72f8ccf74c5dca5f090113457718174fa6eea95401bcbcfc84010de657defe8ccc4deae504b2ed6621519e4cbe3b784347601011edd3ad3bb4395f20dd84e9dc6b3e4aeb655a6aee0ed1a68917c9a3deb7cd79e91db212e4d4dfaae17e1eb4f9cb60c1134e782cd175e673854951dd51e85561afd0b502ba7b90000924538ea100dafcdfc121a7c6a7e8ca1ced03544197d855a79471b0b294075488ad4605d9129fbbb1008eb10051448c511483f389613345f547c019c7a3ba505283f5fafd5e7e897630a47850e9b0ec32c26c68c72ab4e00a343cae57fbaf7887fc6101334aa75947bbd7d60136d10fe962889e8fc92bc5aa346ef9393dad54f926833e56038451a6b5615dc6d57c96f692fdb4208bca2e16bae1079f588ad0f27bd7ed528a95139c1a44b541fe9b6bb099379a04acb041f1f0ee35816240efeef10a7a6bf3b7a6a687ee9e98dcb11c474118526f1d09ecaeb6d991ae8d051eafd7abb1b44c4f36ffde729d9c2fd6714b9f3f9a8700bef020481d66c58b366dc1ab2b3c6cd95ed04525a23431a95172df692b058ba5633d49f7304004822c7a529d89f754efff7255820320daf6b6afe0d45eb75a55789ca84146ed1766c373e2c7fb2862c850caa7130df014b1244c7ba61aecaaa19775d010155c9b4faae319ed204feacfa0ff4656895a8d6b3bb799ce729f0291fbecb222c408d24e39c5fa14439403aaaaa92fc3d81c56aa35b5c7ebef9b79801b77a48834d6c2b2a693353ffe493dcd1426f7133f7c6dff563624bb9cc49b1da3c945a347e7912eb1b8dacb135801d0e33c806ab326eb6e7db49b5430fb5bc596f353f8ecd67e428ae4a55c8b29eddb3c2a72b1d94b474ce8d1d6ee6be887053f46929064055acc84beab4240e83f452d6df030712f0b52880fce9337a7bd88c8f97e483ea21ee4d6f79911c51420ce52f205f534ccaef0f4c78bb03544f25faf9198b97aac8bc948c8ce6ff9b4965706800ddbe2066f508478b6b2fecc84de63150ccb1d88c6474b9eb46cdcc51eff6088aa8cf44d34dbafb3eb3393b868854c9a0c0f506d80aa75a1178c6632463605c070de3bacbd890658beb3ed103c2608006d0d28c34d4d0fb14788ec86d7dc16e8fe01fc290cd746dc80309a15289dc5507472bf0259eb56dd91fe8070956a04bb4e27485c39b003df210813f21ea06832f50a4417202e6e0807553ea97ae84178986aa5459171c0fb2f1ffc9f359c2fcde25b8ef61eea22b3fddbdb682b51a62867c22e0efb579a144f05e585e88bad66d62ce56e36ba2c30c8895ab4a72744ee08d03a3ad962acd07567b91f4cdaa78f1d5a816de04c6e59a74cc812cdcf2efdbc849c5f0e9c0b254bbd344d872a7201f86e4f83a1b98d4cf75c2a40d5fb5125c3a27389f1d8ef4910dbf986cb1be7ef4d43f63f8ad70516d655f2e036175c4fe3928052e13eefb359b1d1ab99d0ece2b87ebcf9b0b1fd535e15bc2e1ad460942e01ef324c2a255e447866df13693816e07982bde78852f386a171060d891493843f6a41062ed95cd4cd135d9ddae709828cacc0a0089c9ee7676befe5b7841655aa09f9cc9b92c1673407a2b9bbc1197a008be1f8131c0b33b65cb27c89c05e8062119675153f19da5eb02f620184774b70bc00de7703482b89cd8eda6ed006ad3dff98164bf59f84d7e62af8fa989aa9af1db7e5d6340ef96d91b50d1fa81bc47a79eb2597a0796b42116cb8cbabe905f7f2f7a28204ea5270c468f8f279a8bcf6fe50d979a6c658e54ab512cc317b21d049095f2cf7c5f78e8736116bf6fa180868fb7173808ce7dfed1bb8f8d41d467b9258cdf1886245cf330f13622330dc09ecd2b436a8f85f65938caf9838e005f447beb5224fc1976f2b7a36787ac6a8b468d2d3e2098c746f8d0eed58c1b9b97fc7279a4e34958ed61c24207664f2a9147486bf85e94b01007155e84d8c6fa61369992c631ce2d665bc32aad9e3b33fa3099bdede8e34d0f7590cf5b3fbe188dd89048a5a806dbe558d276aec48ecb9870e80920a96c258ab9759331eb48da1c8cba4f7bade2987f24796560c95b5d90c8cb32677f1fdddafe846d6f15b2b3fdc151f311bc92c8a5ab8c05804d726023ddc51836b77caeef0f9fe98da696d95eddc6ccceaca5de4641666ba04e0d5dcad47026c2b9a130a274a859724dba64ccc3ad0d4db21f323b7007a7c3fd0e32054e6ba7b165f8d7e4dd7542ff1ca206ee01629d717dfb906496da7dfa5d123dea14a660e6c8ceb3f7f375fc23e000b9890a3b34b388fa4a81a1735c09d5e61f33d577ada4b04ee8d8e356c78ef948bc181b3b7708205f81d0628f2d61e5c75326d342b2781f3a70e0c6ce2dc05d0e53fb1b211404a46c836ae92c566239fe2f9972fcce131696835ab8472521e65095e88e072c26df4cbd39a909eb593faa258c227d77b61c91ec6c32d145206cf2d90c3b19e8e47c0393d35995a2b1e80f05a260f2abab762bb93664adca218305f58ad55f2ab9cedd9c38fef14ac5b75db194dbae5ca89f7c3084d35a301e40ed48a57fa9435cef9da7020f620ed78cd09163cd36b39e73c06822ff06b4bf6ad5d42113e2815a6368f924c7ee207d3c4b87c030249cfb2e3277961c66bcc1560ab39ace42be9ce1b407663eb1ed51f7b262dd74b097f34da19463a946d4d6f3c53562657ecf9485532784b59aff55e492584fcbbd4778a594db779e531a571f93a28c60a1c3f126e0997e5256dadb77ee8674e6ebb6e8e53cf4873d93e5efddd9bee766905398bbedf6bdd0a8948f7021b43756c05d89681ebdaf88e87e5cdb1aaf8d235d09f7dc704c1f6029130dd3d924fd268f372fa1255ad2218ec56c484a2efffdbc31d778851d85ea291dd479a5a7c6fd8f4724bd953bbec96c89a0813ab580f365077214e0cf4611fdce22339f3aa1c33474f1134650f494414d5d705b90ab62fe262bcab0f00ef6a09248ec92be900c9be7e0941ac44af85f462e56e832bd4a005255d364b10f1b3de5a7fbf14753eee65c05c013a9948c761bb1bc6f6b560310db348cdeede74cebe1fde73bd4fa72c10848797ad2ab6bc36ece621d0df04bb0bc3c0c8fefaec73e7adecd49e5d376bfcb7b93080d683df0fdd5c50a84952a68226de11aed0c8f65145be88f01eb7205779f1975514a57e5a30522dfaca85083b13b661c18668c0c89cb7c8fde6609c6b63e66ddd3c9283b7da09411f38c8058ddcb42744a3609951a115f0b331039761c446c616b0983299c2f7e6a3654c37ca611d1ca0fc6565fe24ceda986e1631201ee5febd75330a088cc050280b93590030235c2785f191ea562771a71da522a3ccee250e0dfece704d9f49ecf38c2abda326701a5a93ef98d2f2f17a476e0b25c847c3cad357548147e721461578abfbb9d415ad3c00e905dc5b63423e986a434743350452c94f3d0688840f5eddb063f1e681e97d6ef8692e4a01fe2d0bfda66d94f5abfafb2f7765249d91f27797fa73bbe0f1265efb60bed399e7169f1ed10d388435600b29a1465755c7ffd3f53909a21bb587030f08a9d91f5610bd96d7aada727ecbc796ab5f87c2874fa21b63bd2cd1de1d8e787c522a0ae763b65a668efce88122c033f12e810575c0d1d2d352eaebce71e5022734d6d89f85aef0e52d2c1651145c788c6688dc3731935cd14362c6c37efda6d3f98e12bed3fa3d08865d058b897397e9f0af95ce61fc96a9c31da1c417d40f0d9bf91d2a5bd456d0ed202501d9482f1af71fd54d53e8b4cae676a840420467f042d09f0ae0b9cbb9edb5b7b8b99994bda54e7d138a92187024dacac43f13deba014c5576fbb93bca5a766d26bf4293261a91ec68d2f9a0baad61de0301aece744ef14948b22331151e5268af71937392ac8bb36533bc140dd9e20deed4cae0fcdc9eccc9e7d14e9d72862ab1ea14674b8507b44a0d1a30b90f2a08fd4cfe405a6c9a4f4248e77de9947687946254a880409b2dbe2bbfc55ae9397c20cf11475cb64d859991ef13cf202524df94d71fb5583fe73edb6f12b1d7a6b3c27d995b79688e8f89131106988b171d9a170bf37501c93e9154133ef5ba6f90bea59d0f55ff4ada60c5ba68209b5a924941639a57a7d50a79c9ca278b08a1e2b28564fd53614cdca3e13216b4d7289a55f87389e8221734821f5f31df91ad8ae48b78a981f764e224698f739f527a1a2d1286b265c4850a2aaec6e85c4610f36aff1fa1a9a32f2a03ddd5d8c000e73bba0a1b49e162a737ecebd79f5e7d10ca416ddc695d80dc94738f7f7bf9e4913ba07f32002d84fc35b9505b37a6335be944d8060d90510911d84e38586196c000ed7b67665b0a5fa8e6e0f287e7821e6a70710a1623aa5649826f0b7ffb7e92b7a049153d8097a134bc26e9e4888fcb2085168bb78224a99d78d468f61bed2eca0cc075866e5a5553cfec62772f562c3cb74cda78cced145843cc0eb517c2c8e682a606338dddc7c676f30745a73c32d1ffa3195e4a2e3836be66b0ae9115841fd5fafcb04cbfcf2c6361fd1820d595ce05061395f9cf708810a13573a7d6f58a7bb8881312ffccd9f44efab8b4abdb6062ec2faef2387e125c95a6b8fd0c80c5ac1c59d2a1c44ddd3f8ee7e016d249d7b2b4052aadeea04f26cb1fb4ef291e66473fa2f056535532b9e6e2629e9b763c2d26ef6a18f86e82799a72d0f119f8217d06ad5b1e84a5401a0d7dbaa69deaef20e683a58012f082c12004e1cfd7a66e744994594e401128f741860f83b0c2229f5aa7908c8d0f777cb4c6ba2d68b3dfcab5c51a88d281eb8d3360eb805cbd0514d240b6a44ff1d2c734525e033e38e43de083f53b8909cd6f0d6237c570b2ce523ff28c9389b68e5dccd2f54684579e8022c025aac99c0ab6e2672fc77c63c5dba1bac832baa941d393dfda58eb63852d05c50d61661bcaf71f14aa15c627b159dd23315a165ca287685f5ec15801467188c9a9d7b396099d238558206dbedea60893eea2dec5682b394a476e13884e9227f92bca7dc5320f851c6fcd72840806677228a6a837706636f1d70bac792be2b26308ba9f6feba8731c8a78a21fa35fcb51b69bc7b5d0a5877bfb4c833356646766efc377ebb8993fe3393ac63d2f6312b02dd5f057a6e8987338267bd0bd959c1a3d29b4c79f62f7f4ca6bd2e176ef3c719fa1df5dc60f483f8eefa22565365fb76418a211278229754cf9395f926f894d52582155a3b845f20abac740bd36c41085b2ce746000848548b857d75e55b6f790a64be72ab0c079ed7a117f904d137e29fc7bfd3e8792ec156b1b1dac1fb3adf69f865c92b8761254c8958157abfb0c5780227669c4da0eefd9154482e612aeb8f36239246f6dcea6b6e10b0bac0d5bb635daec4766a037ba02907df2c250f36c49216338fbf8d0301cb0a1269dea43283603577a11a490f178e5bde832989faf9036690c7b482a3bd656d7ebb764002f9a7afc1eb52b06f55da47a43a6d5193c717fb4d1956075768c48a771c84401c9d2da9b7aa25d520fc8844ee0dfda94774bef39674b3e4c4801cc9f965e75bd57e72308b50ba12e3d0ab523b04b0fbf3c54f3d02d96dbc9da9bf46c0436735d480f2c63f0b74ce75795ab60b06676f87ca0b4a2e2a50bed28fb43b086716f9386fb1c85d8f92015019a42111386ddf72ec6384190e1f658213ba67fd4ed6b4e1af135ba55893aa36cc5d03b353c7f48e2e25d28c05f163b5bf4f6a2dd078c0b42b0b6cebb6a785361b6ed5c6652f1dea694a74d1a7c21dc1744e30b1dcaa6774d4278690d625484208dc7d460009a12d2e69e1c726171ed6f6a13ad3e127242fcc1ec9cf28c72e7dc2df298401d215e115e9484f1fc64ccd8aac2dff2df8813836bee44bc5168c8d64b99dcfcaf4996ade7b80e96eb8030bc81d8b4892d223fae103b0d7feda92fa9d5d6c2ab5bd264b2b53fdcf3e7cf55796b81bfed655f457e3e4133dac7076f668aa6118d6ca184ab0af347ca7c14fa2008595d6ee1df9dfa27dc0e0b5bd482cb3a1c8d704097ba7ddb56f8436e07d31b95cb0e4e0e562b5d3bc0259818286e7193890485556683868fce60040c63b33531c6e49ab7e6fd1bd01128d1dba1961acb1f0be8870fba34c8057d7013a0ca01c15dab46ed3fa74e816f7a7e67a9b60c03cb306a7dc07364a0a9699bbd855cb6901603237df6f37d04405c4d0223f3adc2d0a331a257c597052c2ae8e2703d92717d95bea44c197d0d763e5611414067b4aaaea2dea154775555d87a3dbfacb06b0a7097648aa0425af367331d1e249e227a38e4ca8d6389db03894a07650273bba528ad299b6263baaac41243e12dd4fed0bb457887fb7ddca9ff8343d69ad76acc021b08189541c15c413ed8c2276bae393af98d17bd7f5237409e35068f2b8b65b65461f6622cefdd3aa48bb11499e5766e75dc6b1260e04e4e73eaf9dd5d307474a817b3f18709c669e0a97c1f7d2ee81cd92fb5f850d9bbb3956046d1b29930fe424948b6cc28fab76446048ba8f0b6da820259b727371a5b37b82536f104dc7a000a116161c72b0939dae5cbfaaea7b7d58cfcfdf5180a31f0c1df1eb91843d9c350c4bac575544ccff825e681ce6eb9bb13e989faaed00a65dd9174e33e8830fcaa21318624aa968c4ec251895dfc61044ea3fa637e3af64c33b576fc865e96f571b92a41ba82f5f8d439fa343f2fdc1cc754abb861a90792cdd3126206b1a5a57eb24641b724dbb5c1eafb57db0b898de7eaef05c16ba2fdb95666115423b39558070dcb0de1f340dd7180bb53aa1beb27e0c3d36f30cd186707ea581668f043a1cf20660e3b65405e80acd0d1fb8ad8b4b44f6a72f2e674624f192338ad161c9e086c79926f67f916738662924eb25004ad2aada2ac1d1f36e20e19824d7916bf60950779fb3491335f61b35b4ce12281441fdc9913568ee91b8ae9d616e2b4b00f84d9079930b119f69567e85b6a480107e7333a8bf57b1136e2e4109086032dd8410c62aae794e60bb60f5472bc98ceb4aa09df75dc1d51a6705827b1b88ecf8f893fc5137304c38a3fe7947defe8ec7b7ba6d85fe3610778e8d0f6b7c4d22b0c8b2fa4737eccbf877deaa6e7a019478d11bafc74327f6a3178ac7e58d3c1dcaff44b7d59d8aa447065252759aa3044e32b333a2c8bdc8f4e360462b3dbefff358b7bbb5a7104e685eda0426a2daeb2352104a4a65a937a462a1cebb2d0e258c13000b8c71589330ef43da40188fe2b8af5e4b5e614d77ebb60b21c9a1a6550155f0efbebb2599c3e46a8e0b9ee9eaa9d7e57da758ccc101aba4c79212643afbf8b66c75bc10ef50b5499b365ac6174fcad1c8cfb2b5eae5af79738711bb32387ad11dbe0dd8a00f6302e9080e31862ba3d1e3611f1f8eb3edb53392c6e7ebf6a89fea90d86c42cb18592009944e3df3f036b9f20bc3e02738affe600e909f1312ef2b37b25f61ede17cd41d3020576923be02c360e129b37ee55b1cbc1350f2e9a5894ee8b9b9a79d1b27f427ef0a03ea50a86c8a9e7e2c7fd9bcfeb14a2b155d18e2932d5ab50e11cff8456b7330bc06c98c68ac21739e81ee809576475e368bf154cca48b28d067ef5b7e8afff95bdf66d39daab95e570ec44150b78dd47dd822879fb522477b39a5f5333a23fac3f702081a9089091e13edc3a80265e2c56efd01e114de05967cb79680af1c58211a1ebea2b069d5850a718b73141c505d4b26412505f8dc8c7d1027dbcd5f29963163ad34aadb31330500f4ca5cd6f7f6d36e04c6e86669329d1d72ff9e964b904c7b58b0018aee497a9921d8c642f771edd00d2010d28e1a431cfb2bd80975fa02b5f4a1bce2b3a7aceba9918cead5298e2af9ca9aef1399f7880ce277e69ddb8819ac482535b275e3dabfb36e7bdc1e6bad0ab9d0fdec56c8aec87437a5c635ca306d6fd2f58f5a9e4b598860fd3b384598418d2402a68751f2315c4ec2e1275ddbcf3a250e5c14e254615a9ba4026cb433e2ccbc2c8faaf5c906208aca3c39bc9d5eafefd0987fa8b67d39456d58f912e67908ea6407117ad3fa4b5c503c716930d8f90de78c581300941cbaaece73d12d67a28c7691f7cf13c5ff8df9ebf6d79db46c6230ea6cbd84bf6ca0b60c76814ff97d3464d303b2064eaded15ef3d6069a0b40b4572116ad8ac7dd035c586dbc69ad4ce7319f5d3030cada785ca53dedcd6b0a383cb9fad3b7a40011e567d64c8c4f7b37d238eaadc4c428c2944931285233741b7e753252511c2b5161426338b2d17a14f7e525328b027e96cf95f092fb79dca8e0153870c7e7f697538528169c9a2b2678833e2dd6ab82af6bd192ae63ec9420a036cfa4edf015bdea7bf89d6f25228f9c85e48c1fc7185ff133a9e2d72baa72f521f748edb68d26c2258bc5b11c3a2a998535251ae63384cea2272ac235e4a3fdf1b3be1f6048497a7023e306fcd2a9799eb8c97f0c95689ed991e4a562020609698b59d188b6d8067b8d06b08db44877ed4528035b8a1d8574141094ccedc120ee4771618b0a7111dad723f78efb8db9a44bd2923d8b97294573c1b78cd6449170c3c970c22fb19699cf735ccbfba7be48828d6e60599e0da93eceeeda8e1c6f6db2eb54291cb45e067f6d3b52c1029e619ae34044ef85233a4a377a260e58eda406462215bbf310287283ac72c5f5596406b52210a54e308db81f83ed14aabf313a53346b9c1e22f4776cd04a65dd0a727b01ff3252f8f78b9ef805abdfd028037a2f4a801e6119474d736f4dddce4bb79203da9edf51290e95e27d85492b2103642f9c87876ae6d3bab7730d8315932e32a816333ad0a4f99a9b3b3c81e02414717a9a6de0d243632387fa47f12befdf28b22479d2e399750f26ebf8b18d60298e1509567ee472d8ee720c742234efcbd9a288a8472f2e858193c4b1a87a4cb9c7e4338774feb8d4e237d764ca7cba510bde2418ca55f7c278968061a33fe9c79736ceeab4904a77b0d1f85c3ee087917071fa50428571afbd0ff280d613c94e98cc81d93d8508610fb1ce1465547d69688e3ee73d194be08a642d2bf809c111f751e111ead8bc917e92af363d2c8d4656ba0f8ab890d7031cd6bb429b5572e9704297169267a275c2053804add87f1c6f5eaf76d1fe4d990a55204261f481fbc37a9b1b55afc6168d27496ac501bff4592269dfc2514f543d43c89f73ff63262cd6110639b0a978ff12447d73975b152e25739d9f042dc432e995f6d4f124dac93ce521962636a8825706e187cfe8695f30ab017ec262faa152c9a7abeb08d608e23e074dfb2d5f6a18f53b91289f2b8047285b68db74ae865f406a74910f7e1c25ae60abbfa6c1fc18ac2b03c90b3e3117b25c3bffb07ce29e1e725a6676340e58b29115a6851d54a8c5433670fc98ac78ff088b27eda1ae9c6a4e7d15d7d42d6e81aeae48ebd3644379df5d745b3c1cf8f9430fc45193bb133e2ed485babbdb484d4563de7b6ff2a9ae99b750ef2125f034d8b423542abda60676eb47714646a1effcf3dbc9bb7ee6a14c5135e6f0de3110afb366028c75d79fe2605290ffce8b93a1a2441eac1edaf0e6787769d3e6844b65b872f94e7a615b7078484f45254f1b7dd2600cd8e5f9063a11fe1debda456298ca09f9889c4152c945da2a67c273fd2f5c53aaaf4eb8d4b3cc00ebecbe81d813b4c61eca0bcd656b159da14145d65f9f44f271ac0bee0c35da194d2e56ac6f81dce0358a6769ca06aff0889e4046432687ab0a15bf0d90fe8336fff4fad94d2bf09c70cca3cca632011d6c66862302ec36959d6f8dfb9e1cec527cc7ccdb49546e7052649d6885f48fe580e993094f65268f77c68e669e980f949600f125a5fecbdddca16c2cdd9eb5a833895b474d685124fe505303ac33ce403dacf8b674785e23209c039ef3cccf0d245c3308e70009e8382101bd2f66e04e7a04791c0fce96b4d0a0e8ad45c5024cb0daf494ca14136641936adac3dd64d5d76e5fd85ba221cffcf672bc358d1de8090e0f74d6350c5ca4b083ac84f601afa0b107ac13f419c2366320da033df9d8ee86d9b343e51ac7241e62fbc1f2650c57bcb7c10febfe764fc038daea2e4c46be0bb33f773ecafdd816b764b2457dc0ff09c2bb2d683f27cb95c6d7840a766fd8f4762ea2c66ac10d78bc904ad707bb407d1fc2be469dc0bcf9f7f7dcfeaabdd4309ccaaed3f41dc22b6f5e20bb3cd34b3ab6a3f35c0b5761939ece68af52b472eb9da38924344d372dfdbfdec54ab539850947eb7f322c5df2cf2c336b69655b2a1add8be67fac1643373858f6beb0a32c59883490cb55ac17fb64683922c80846c7d9f24ff6ffb4280ce89f19c14903c7e16984edb176701b2ccb9d9cd11de49e27b71dc2d5178a45ef49b41f8b56b4c17b741074d22a8367c6dfb70ea902a3a6ecc7cd865bf352bae91403f9776878e8f8adf7a556c2eadcacfd146a40de454deb9b0b27fd7e2b72ab73b301608139ff2bee1323ec2617a79d2c613a03daac40b8ef62b51ca813be490e6e929b9513107144d0d0890649c4aca4971b9378e386b8509540149d5849c11bc2d67642d3c42f71cb3975c0dfca91decc44a98b2b8aa99cda724bde4cde8a624f279689732ac8ca2fea79e0ab208cd6156833916fdce4a6964b28ee13a8fc9737c7f8b8cb5653e332b53ea85de9a247aad2fc96b07caf0ca3586b8088599f18da18b03081221f823be42cd10d46fcd243a5b00e1cefa87209c163322b79e71af3babca4052ad767d65269a5c58d9d0c19fc025ae92fff6021c2b0268ea557c2aa93e28b5bddee61cf027fba5e331763a1aba3bbea85264839d0bd9a38f78635b58d7da3242c8d69f0b0b9a8eaa8726cf60ad9f461c6fe5812c687edb5f30a47b2604f5cc2e8efbe13f3be95b92e8eadb9650e4e03f9d5859018f98df8c94144c87051babc697772eee7463ece4642b5f49aecfcce19af24b42b64eb72234365784582cb68b73ed7c04647df71343d7c3cc8e6e661972cd6aa457068f52e037931fb50347cf07fc397029347c4bc6f36a0172aeed1da74dc07012c917c931046679a9c113f1f672ba9583233ff1f29167834d30803d0c041577f08b8b89e9a4cc8a7654523ec382a46fd5bfe160eb0b1eb792dd05fcdb617e8a6d97debe851e339b58bb3a29a1eed8cb029b422cfb2c5c74f8cca57537e4cbad2119feeecb233a6648e32061264b664f759814bdaf0c408b596704dd5bff4a955a344c46b004a335aa21dc73efbd429873ad4b44a037492a685a4b28960e3a4733507f12da880fa1f75d3df5b6cb7058fb8f4b9a93b34a05ad689ee4eed529b732821e78c187e04b243eae70a5577a5261c941f7cb3b4243f0f3dc8241bc8418075b5d453e5190a7f7398f965432ce762876243a6c54136bef3f6900f21beba9439e7e32caf79e861be774f504be4f87369cf036d39f2d47d5cad53e88c3f5c284b9e058fcd659b035b046f5d6d430fd8f5485b13c68f019c1bbfd019ee3382c79a22b40cd06cbe0d6b1dbe0e06cba4c891f4b879184d8c09ac1f8069e3cea01a528cc817a99149e0bfa95d9574d91e0a3a42bb0d9fbd3172b6749cdbf714aae3bb8fe1c9054ca5039b11c13eb99636257ccb1c26ba91a56522c7c1428b82a06e49442467f0d81f77a0d05837c890f6c9cf8e4a03448b0e96ce6d6f18c0d571554b0cb16832efee0fe797ccf84dca05818229fc17d49f28f40d4bb9bad92264f4ca98d1dc65da73b18373dfbe69df78a3b958e90f675c48718ea18fac8b8f3dd08095a46bb357270c2f96b980d09fab1fac733d7e4146597e49ed34feae29019939942935c6b4860db330d6ed88d312cae661e63bff76e4d72e3f6011fc2c165de699fda941071e79ce1d0811779a8f94ec532635307283753c00678c848ed32dfa8c9ae606321200fb7f3625b011a6c291fc6536ff54dabf74bd228769bebaf872197baa0a14a65adafec7781fb8d13b69e3f9d1c954b20f05cd3b862ad6b70460a743b5709d4d09bda765775e66bc4cbe526acee7ff4b0a8a95d93dc00f1c4473149513efb9d7b6b1df1f97b858e80a10f8d21e59c13af3ad4b44544716d4075f0426c1d37fb1782e57c198aaa6f6f47c0bd23cdc60fa1c2cec753b56f4014138c1285c509426eaebb593acc1654873e8d6b81c18c7e63a204310ac296f8828ee5ff98e9622cb9b05eb534995470141ef6eaa6972042d58e97ce6836bd70074528e4b79517d03435ee3f6b6968ffaff723d38c6639ddeb33bd9d1c9b2d6e81c02925c93a473ca57505e906e6594dd05a4bf2a978b28135d31d1010e35c9d2a04de0b5d32fc6521dd096d8b968a213553dbde4405175373a6191ce393463f97cac9811bf6fc676cbaeec20644f54c583e10ec4682389067a4a063ccb7afb4d3688b212f321f9f05bf6e896ca1b97626fd3280713921ca42356b3542b2067aa1ab8d5a408e38f5d4f1f7d3160b395efcfa5af2f22b4b4e32d9ab39a70f15bd09bbcf75d3291db7fe866975bfac2a04a1e8012edca186ca06e680f43cd2623c84838fdbde203264ea1bd7133532fb8ef961d993db99a1bf2f52485fccf09a27b853775d239279e840d2898d2f9b6c04d23fd6107208c909edeb4d0fe86a175fd3303545a23873388619ca13fb1337de3a947c0ed6b29f70ff45fd5536e2645c020c74132ad8dce31ccfac5c44eed1b9a63f544a773e1e3f86d4096594283f486c5ff05aa01a96527d919be91d47509c21517473abef4efd5cced624c22f178569afa983fcaae716bb49842a21f86471f8044ee620793605f23ce29327ef6f2bd82259aa2bea5d668a52d19f60046c8e00f4438bf1954561fb54a99ed42244e12df3cd0701e4523a7d9dcc58ea9f9e24eccaa4df65a1680d6e4265cd37eed360b98a3088a4f55edbe3552f0af922fa4837602dc893c0bd4df9413fbd0c103e57c0602a73441d27c537c7d98ff17f8a800ce43ff7afae6aaa8444e2820eb3c3cd2b8b20eb9850b663ef6bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
