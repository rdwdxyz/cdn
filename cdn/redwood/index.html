<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e7dec47f0df7ee364212e71328deba924cfa6402c38d30e07ba184f7e6efe18fd885b5cd27a81ee9336eac276f0a14dc9053a052ad6d02984860a28f7a4faaf8aeb7e397cbb7169347c63ab10932998c003d73f56f0458d78d99e24a952f1620b2e9d629067163a8f310fe1ed7c8527129221935a65da3a0b84bcb9621e4913de808d61905b00e41131b97c12f2d1fe86e0faaac4d5cb51a01358ad0f2a84cd6e2147734a72dc3c8de97b88ac34a9720de34c0e63cdc741fda4e648a36ef91a49d69c4f3f4b7e82bab2b7d67e22730b4e2cb06e5ac44026de3aa3cacf65416d0c8d2c6ad3ec080ef53815b29885fba27e688809ecbe063d718297b7e821b91754db3baae21d3f5f9e65aa986ad4b3b8d471b33e22262a28347ecd884b87d1ebcdc6775dba97b2b40530b684583eb89d0c07fd1451ad2d77fb3a7e19c526cc8cd0fac99d351f95ccf0e3b0c0662efdd1c30692c3b385f6ebbf684714de529f188f3485c3dbcb5f37ed590a80f41c62a3ba804541972ed7a25ffb1b826bb1be0a626fce016f6bc767672781dd272f8cd62fb7d96045914b55f972ba45dca1d38525175a928a9c2b1477ca75ed0f618b5809a854b92c7bfaf699f0c9fcfb44845fb4ccce3ea3e3db6f6822ee652fc1a481b2efdcb3211e9f39661eca47aaabcf8c5b198bb44065e375060b798b46cf2de3158a618d9bf52ad05ad7e45b501c413c72ab64924d9005d11df616922b2b259ebfd0acc889a507ce4395f57964d74068fbaeb14e6e1f00fa14edf5c35e5ecbdcabb9a06f7a8b5c2f8a0f40af8e40767fb9247ffad4e51eb38b78e3cd4e274d72b28199baf08ba700912394697f268a77918e886c0d407ebd600c0b455215ef5f3a2ae3d23d174c16937bc9d40f72c4b95dbe68df563375152b739faee83209ea609b9cbb41733c2bd2e3379154b762465ebcdfac1aa8756aa4776f7101ccea0185c2956506fc86697b7384fbff323194bf2dc00ff84ed03a15e72f9ea0262dbc06b82257aa25eac7ac95162054dd6582a605b60fdb666de8a522d1ecec7312996d933100298c83daeefbead27f68f9b52cdb166842075218b667957d1ab14d6c6235a027565eff3d1f035fcfd7283575094b419b04412555de461a6e518e7de0d3b414e05db883f4bc8de6b589462c5c049a073b3d834ce3ee7e7c2e1117d69a42f79714cc984960253c5a005da6f3029ee815522d87ad8a70c9ee2596070b9ef0d5a83097876b1b83bc614d75f74f2abc273d36d0a48a1768ca27012f971dac560e17faba6c682b22efd190e3aa8767e3c11bbb4c2c3bc6e245434be3b0296f84dd1f0ebd682db0e81323a78cc2672475d1ef717df6b4116ac11334c8915faf0be139b6dba25e7f26eb7388447088918eb807d506a7a8d616673f0d68436e30cca383d07bf098f2bef557e4a715dd2f65dad64c14fbcc55a72a6270e534643fcdb3f46f7f34bbb2c16745ca03836a1d724aa7bf5a57d02fac1072d2816dc4aeb5038ea837cd263316cc8f8a45974b3fa90d94c6175b17a7722c46f6039c881f5412cfffd920ac567263df54c8a5fee3dca2ccf915cbd7f03880b68099af6ae787e8ab5a098191ac477d072f250c92b1623189bf57bd24ea7feee10ade620ab7f99abd43d772a2f8db86638cf78c9fcad439a24696463f9ac6f1f4130ec657f377161c168e1b7db98ba549d00efbe0a165a248b78cabab9602c5cee271ef66b35f2a4015d60446ed75ef7250ea99acf522cdd4022a6bcb069c628206cd917695d2944290fa1915fef6e3aa7c2ef01d80619fa3b638f4b01e254cf5a1e65d6187451450142a478facfe38d293bc36c70e92224911c5a82dba8c15880524f0a7ed2b48d4bc24eab6058e1dcbc7636d39e7a89374d78403c7802e0706db17d469468cc001d640bab4e156e6dd6be88ab3e424cf88786904b1715e3a7a2270e7e4342f9a8f00898942c29e24bc20d325aa0208dfc0ec55e95ab273e9056416782fc5e462adee164bf0bab10382ca1cbd07bba2594dbf7a4c9e827e48a9e95d18a451910a23465b1886f5a03c8a6b70712c3dfa10cc2bc10c8ab7183a9b5ddc188f9784e12cb5fe297d50262f1c3ab7197ad960eafb0ed016e8afa195a2c8e07793d5ab4a4b036e83eb87fc0d088f9c2dd4cde7006c163c0167e80c6851d2f73ad5e36c8a9a554faa2efbf2fe6720d77417f9e7215df77e5a8fd4ae4beabcf7c5dad152fe022c5916865fc57137e0c61a6590a49d8c6162a71df12892eef588ca9a89051ae6030ac2986976a610669f874defccf0342948a2bb23d2f1374a4687a9fa57c7f91bc0ed0a08866427bc0b7e23f466f6eb58ec5b9cb0fb719603ce9915eb20051a48269e3f0e61bbc4168f91ae4f9c8130e3b31aa388a573f7f0d62313db04562f46685c25787445b9f81daad7a09a5b2157e209e541936cca5bf7072ead830f74abca081f8884e475b752df7e7f7218c5484331b9e892c8d7dde16dac6eb1df905ff316ffb2f243109182635ba27058163fd1b81ea3f77fb6112c13e4665261e6995f7152d8e4c6d5bdf923d9a6d764f95c22fe00e8131765a52db6fb0dfc135e65327b9e323672c0c4e718399008c5406eb2de4603469e8e7acffe7c0b4ab2930d34783f46501356daaed5d984af6d59051f67bbac8644c22240d916cb7ce11e2c8e637f7e458538f5645f5556b8a7e7bfd5c8d50c8bc1c39702f170c4f7fc7e2848f08768ccf700da4c9b48e9e64575e01d95ddfcc300acd28dfabf24370178e9e794094af7f9ceb309d931a968bad2f68a8881db88ea5538626ae0af8a35f0802e614bec23906f04a67111c1850c736d44816f5770e1f1fd216a475d4c34293fb49e06e5ddbfc2c2293ff76be82b324147deef4c65167c1becbdad2c4beb0865271b954fc5dac7cece6c166c2e7821a65d63f12dc868212f33b3fb12b209a43f1da65c46f4d2d1a98364d3dd2ae0ac7267400974a4c8738e27dc30aa787f83e19a257919606b564ded0cffed3b0291916082ec23269716a9689a08a3968714bdf3617b4a5463b4a267af95e52a48029f948d7488d27fb0ec2ac81f7a200003457e7ed7a3227ecb96a02eeeeb0099d05e1badf8a95a141b459ce0353a45ff7495cf64b30591cad1acbf79bd98d0ad2ddf7c0ccd54c4e4129c7d1fe1d71b7732facc668be0ab66ee27693b2a48d08819fb1e53825250605fa8bc9700073e19f328265673d05185b5fed60330bd16dfac4beaaab5e370cf980c3a53ba1a61d42ab12033d2bdd3f62593c51c8ee4aafddc791fe43aa8b781c1b7b153b6ac8fc31a43d3e5dc912363e9e2c9c8157c1d50c88a4f6624327fa484d69ffb0f28e57c1c74527479910110ea0114671d31578d57ae6b180dc965b4220d9ee1977850ed40d00958d4e7ff7816e9c9ca5c3fe92a3ad0c110a36d003b0da75db8a32b1ef610e2002a2b13d6aaceeadf639df980f4e1dccf24492433e20e3d10d13cadd9285671f5d27d40f1ca48bc033811e7414defc4d119e800593b7bb0f1da5a03e8c4db153db7035622765e3955584ca8c5a228450feb577de6bded514a68f64848af276f3bdc5856cf63f8139014d0bb62787a5788eb705660b536d1c4a564295a4a9d65499d2883317cc2088a81de78955159dfaaa6c7bbf206fc15110b6718a45e186630a7fd0f93417e42c9a3bbf6e6dbc9987a7e826099a4f8bd9920a5a8fd2f528554b5b551c6e3eccf0fcd1f72d45ee694736b3ffff4e64c1004f81e541de482f09a11323d2cbd55631014add08cb6df524058f83291749c6fad96ceb76881589f3d962c6a1077de7638e2d8fa353617bcf639cea7437d9cc93ac8ca96d06d972e921d4f129015ea0a119a209627db06f1c76dfddefc0183fb669f9a98171023bdfb1e15ca9d8252881f42af50e83eda7357b36f4d8c5814791683e693dcefd4c338e8f8a2adca3b6d805d8273876e222c0f226353d486b54179dc6cce698a0a23a68780172836c2fec6079403278c4f6ab1cd0190fdf35c6ee16d05e0c402fd4a53996b111a1e3f09fd0a48d1e7aeab4535e9ed19542f8f2ff0e730828e11fda30ec2a8eedae071b7a554d2f31d5323281c9e4ae3c86326c9bca5dd2f9c990b3f23d032b131a2159d2abb5f9308d433ddd0ddf54cd6bb7fd29b3490beba24a29ed8a43b1eac0eb691ff744e51736434815b8d23d803ae022cc576064af2509fc487cc929e67b3b9dbaba839de493303f6ca943dd4ced63c7f2ca2740d5803aaccfbbf08b7f92e3b2e6f7c2e7f2a1b71efa0841f5cf686e71d6c8003523f03c1a7d25ee91e984cb79f9ee5c6e7919126674d119f9a965857d68dbf08d5590c08b5d7bea61fcd3f6adf1f5b0376cafc80e91a80ba80b7ac396d10b06fadebc4361567f91cbfc51ff91ee99c66e2a820eae187c2ba6ee4645d76f6ce4b61a6aaf350b84686f0e9435ee7d77400d97f24a52ced44b7657629e3567b160807225d237ddc4dd1247ffb9e5b01cfa66edc0d3beaff7ce78763cb8352e5a160eb09af31f3f93ebc67bb653f71fd00d46b31f7ea90564305263958306ab84e9a3fb935d38db459eb5423845b3fb24d72aab417595c10abae1bc733a8584a2a854d971762582a5bf63e56c8fb88b8beb24fdf3e81ca4940ece237639c18c3de0491aa483186f22c775175e9d96247fb38aa84aedefa678bca225b7f94b75caa6a8ad77a919f05af741fae2258993ec7635ae479115618845b763668a6cdf79d840a921649b7a4ae6b0af83de71a2d5286cfb2d2dddd9ad310231e43f81b11eaf6b1ed5af96aefc0b0c2cc9326783e53ca5de07fe86be78deb795d2793430fddaf3be3184a2de4e6500a3667fffde1b03a51f79689e6596ec3f60c7f4540b31ade2156a37873cdf60fb71b8c7ac11eef17694344b5532ba6a822e743b6e0b11340a20ab4519aa43f841e6588a7d2a0dcb617716436b4baa4365e451b188c040c90d7a478be8197d66e5d9680df0d1a9718bf106bcccf710dfbc4ac573114ecadd531f7368383ec605fb1d3e9e555f0a626b635b9d1d60c1ddc9a504359b2fe6a66100229dce3309e25e214a98b3965130d60ea37a35e4a2d5fe0a66580a28b0558fc8e4fc37f471c746d43d30837d8f1ffc2f08927e5c4abc7abc20a21dc2b01187c0865ebe5f5535e48e321de0b264780a2f1530cbc50b87713d10341403e177cd16ec7507970f29ffb7879c910d81d40b2e2db8ca585dc60e232932a4a1d429d591953bea237c3f7672ccd0d389b988dec184d1f0b2e276bada29e893d18c5378a8df1ade5155e60ddb19d44d41462692ed7c026ec0d1566a8b770b52f1471d7e73e33ff3acffe2388ff728c4b3f2763b656a33de840eebfad08beecadaf703625d7b415c24047a59e4b7c25283f4d7987616d7cf623d112ec7459ec8aa6bb101625412bb83a7dd03d26ba857d08919c2c9b229ae2df502cfb489fcf01eb9b1e8273f9072d98033c3aa1de3672af5a314fe152c279a485b49f7f4d382a3e6cba0fa34c115025f8cf1264c37e2b59ebebbb16c47f02845528f62af88b44605caa029e89984098f6589862b58c1a90203187d3c9c1a342f3a284f8430855d2d8a8bb1ffb18f78037cef8d5c92c84850fe75085ef489076f9d8e51360a1d5be06a9aa1c572c89a59a4126c68ae58fcbcc29878920475fe0ba89b7753fd0abce7652b61c2913846878114feb0abd3cd0ccb420886c15ffce04fe4986fbd276283bd9bf596afc3da8bb38eab4f186cba49efa13ea32a2620dca7708055ac518c557dc09e45823a6db67b781999228ba395dac80769c997aca26975d9f49cd6171ce14c598e9b24dd336457586df574cea31bf922954f73eb52e5831a3604a37ec24d6b2554cb34a781e3d93f3ff8c87d52d7032090d5f6083dfeed7fc77f47025ec4f5968b49ef02869f4edb3391d40cf54ae4de05c0eb3ce5979e7d68d6af25b9bdd9dd1cf3e9f21ba0adb36e79d09eef07eaef81c86057ab5764504df92d1ef5e924060a0d3bec3fc33e6a86ff69780f3c96a617d49f866119024cfafb464fe065bf360f7170f4a12ee3893423153f653b963ab7adb5cf586349371b1bb0df7c9ac7802e9f7145bc24f19ba856ac7297436f1122c83fe0ae2f08c3e1f726b536e69a004523826243551502412e41ef68b7107360b7b85673f6d2e7786113501776a981350e93716f681cc390d9c825b9c29c386cdf4486f573a619b2ceea9adcf44f897dc5039cc39c6c85e5912aff6755dbc175ebed24bd9304af886c24d826fc537d1ad80d6ed0dd0e7af6fe729a3f00571a5c2cdd04b1854dcaa232dd9d7637f9d6b92efd7a65374c717294ec73931fed530a7b111829dd8fca8ac76779c98edc617ad21bf4839f94015dc509653d70a794e1a2d1e5fd3abc01e50e88f37c94d7e37982f3eae1055d6087bd423de97a80c8fc0d9d91aa04a63e1a2dd95b59a4ac52811dd3a7624aa5a3badeb8fe2230d57b2dd72efa2cd3a9fde356322577db93211396de38351009b4cd4861c297999f8b8a336d15eb63b49def255e009599ba915643222f0233287778880e6f6fc14dbdcf28d1089a39034b1f0154413beacb7e75e2c184377fc5b48e1225fa9593a4be201a8ce5e5eb78904f6af67a1c7003e2930e328e059b23b117f362d0f02734e2cd11d47f85879e2b7201ebddb75df9d75c8b746ab615d5473bcb4f6fee9c22f88726a41b3472c34ea95e4ad02d9e0c4b873914990e148b76a55ea98089289fb7df7df52f20c1e90eaa6e1d399e67c1a82f582f3e86192ff1c82862176dbc721bc91ae86c12e6db1becb8cd52cd7b26cbc445fccf5c3b49a54746617c9e587282263106ab7e8193c63642674e84aee9aedf78cb125b67c0475a8b10b80b1721693e50fa5457bda9b30a442fa8960248421f123eb5029165c076a64e275f1eca8a4138963eeb942cdbdab5bbf6a5d41e19a744f264210c954570a7cf3817c094e10149bd502a4c08b626e9d97a988f9fb63ac872e22194389f46ce552388eea4c3bc7148eeec94a62003bef49825e61791811cfe1f83c135a285968093777539df89df6a729ea77b6c6c6679892df1d34d2773e60175e9717559b280ad4c7dea07f7e2605cbeb7c65e0e70bd131256c08337edaf43c67fd94d7e6003c5efe2f980b66cfd1b1ea4084e689c63ab342374d080ea99f3ba2a05a61cbb228d3aed4fcb49f7204dcd30a75288649b0cbb47b256a777d8dec639070481adb3154bb62b9b60dec61fcc4e57871d5bdd71998bc7d7847fdf5f86aac36757f2126d484ec5c875a8b81377c37e40d4bb0d9665b4039def1eba91134505bd6e9dd68ea17186bea218caed3772bd306fb319299d13ae1de537d75212801dee3cff8d57184fe1d8efcdcc68b59e2264ff929a7cbab3a2f56115ab9d1f365bf40a436903668fb5800e264f45b6ab488b5cee6e99de2404748a74febe58e4df79513482f6575e155abf6018047d595e73687189488da4648c99800ac9f3ed224db237b3d35c8a8db99bb404d618018710f3872ab7b928d2d5b58210a3ce54d644ef373ef057016bee0062d9c66b84d7077aa1f6a7d88dc3b55924f19155df8aac91dc3ec1a2a65322cd99c1e28925a2df20d855a138ac99154b2af979b9177c6358c88e606e448114337a30e785757ad2ac8129e3ccfc6c8f99974dd5ae5d83cbda5aa3bbec425563fbcbebc6970d05666ad959c55bcb072f0cd2aabf191d3ca8c0110d5a39d23bffd81ecaf3dd7f27808c36522fb44bf63f4844460e8dea94d0523372b8c7b5b2fa84ee744798bb5622eee670195709bed29d20a7142e0d07c1c8da62e7f7e0401e6f6107360f32d9fd2e8244f41df9d6fde426b49d25a8a2927fa93ec8e9b0aacdf9ea28e1881a8f6306c691aa5081b5f6788d33375cf1c74bab4f5371b0e076be641c0bfef6c1a3d0caf50d3713a193726cda7a8b18528e60529dc9d4f584ccd59e7ba61f45cca10ac40cd8143a2797d672a7c4cc317d40ef752c36469d392bbf4b21fea32e28311a25edcde04966f620d5b8a53e68585dbe742ed3848bc92ecc0720f18f297d85411c02d6b412754905b917531a9b549412edf771ebea32262eeb6ce7b6dae8cdb906269d9298342c8d6f06c6c9585d50f6c20eadefdbf3d61f802f1a1b27fb45f7cc2320f19723bedbf8dd04ef2417e2917fa0c32719ff02c0b367dec714f0ed83ac286d71fc00f2ae7e1dd123da3ce961e7a243deb4fbf73a70acc59f6a3216a56f9f224979a0233fa1224fe8e67d826905af3153902236143ce0b506118643275a94a949f39a256fbc587a5b85413ddde6fc8dc7ca286e77d3cd9eedcecd47783aeb798be94a67a66e1a27a358ab1725d1683f327c49b6817565d0785db2edddb5d4296e65aa950dd57f7ea61060f5e1343050e3008dff35cc7c5589b53896f5e876a000a821410466846387d9a250ab7d5ff83ec68bb96ec3ec6fbc6fd9a0badaafbf044dae891b5d419bcc672ce5b21e97a4be79f37b07c0d8de8fb494a0f056f2ef85b8dbab278f9f5f795dc7b3320a91c1d5bbcc7a5f104602edb4d7d1c5e33a71cd67fafe9f0c03029e5ac08cf38b7bb788fd48137490b375607dafc2d685cebd04b6c267292a76a7a3d9aa4c5a04e3fc0d930861deab69a3d7322a6369b5ce610e95782f23e217ae46265ce4f0d4e4a6fcfd8f631588a228749f71f5b940ddf231d8cc235630d31c6e36914e1ecd0656a811cdf9547577b84e6582b4190bb20ceec44857b5e25f6b95d3dd540a00b089da963b61d7adcc16d8791cfbc84ed04a58ff27ad5628e945ba1591a3487b84fada2347d6f9fb48e7e17b88e80f7e64a06352c53a9e8526bc90adfea884a39e5782c5732d4c0a220f6f7b28e108cc4638edbbca9991272629812e6b008df56e40b8544ab741edfdcdfd6fac55323e2bc0d0e4480b5476393035cbc2243096539bd4ee3a285bfb1ae09a4d02e2800b501fa419111517535e7f65bd6de32dba2774801f69764614976b4286eeaa29153f7e7ec3d75ba7d361c3873595166882eba017612724fa88a44329aec392400173ac3e2f81151877439a902a03457a87e88d806fc9ec2f66c0a7171c3407422c4749e0ba117a700dab70023c059e94fd6da269d1d49a835b97fa171e46e92c2a3ac2305b4409d3603fd7fe8377d959ac259f693c68cf6a1b9470318a93ad2332cfc10108f4f44de28cfbb50eb89f1e1a08bd26fd47647e83f3e90d758600c7b977fe4fcac821642c8690b536901da19e2b24b8a56412d4fbeb9e8062feb50d6a3b0bbbb7fd6ce2e0142f634a061611ddc75f475e84cea65668797c6a5ee89c9627baaeb410180236fd0088339a93c9f77e4063a24814b33ecf792f2fc5e09eeb3624b64248f0f8f784782ef675c10b1e4268f7749d8604516f67e4b2e6348e7003f54632560d9361469077d3f9b7373c5716599156fb70fa18614bb5b843f8e735d4d66c57046a905a13a4702253e1666e725c91a34fa3d0a7b44fef56e47b75624986db50739ec22e2a937ae333ec1d742bfab9b917fd3133bd4fa1cf9570705815e7dfa9eeaf31f0264b0ac9af943770e9808a9e2faa744bf52790522364500536922c1635eea38c345c37ce288dfb743104c7afa09609630349dc5bccf985fc425a0e42f2826531d5443cff45ba34a481792a38876455ff6e7108b6ea9eee989197b63e29344d3610bd4f0113eb7aca1b51ffe8a941c6d5dfdd5dd57e67fafca13ebd17fa39c57b84fa9f19cde288857c61c7a57f2330d63182c6721ac47a3409f032ecb2ce01c1c4ed9e0b88963b2484b646549d4f3389bc92d3bdd89ce977d2e019995453211bc9de7c3074b4a7aac16fa5469b2923e61b3eb94e4ac40f04be58aa687b7d6beeda44120de9e55a59dd5edb3231f1999af7a58deae17e4f80dd7d82a518320231bee62839fd05e5f9481b649a4248c3f3e64a4c492595c4af86d851349f327ab682c03a7edc1a19f15018e986ba4676eb65324dcac3bb202b5d63be89a39226334694ebb267419c047c1423340821b010fda66b9dbaffa565f1f47940e7816d0592b997da44b7aa56b3568c95deac0bad4db831d67cc48f33d66c4fdfed638a67b8ba1322ba39ed7dcde5020d044c4c48f7d6a841bc2d6452ee77e93d76577b88fb7e3188d2f24975eae169faf76f0c7844e1684f41bd07a4fb52421cbc0c41696d1c76fafc833f2d7251716eb3d4a83b5437ac0003f01c90fc560a681c738d5e2f97771cd57ae1e48a019a11917096cf7f247b75032f8764f6b166b4cc167a075e461c8970e6e3a4aefac3dee9c93adedb194b635712d1f4cb2ae24e537f15b9b34667b323dcdbb6b96a41954cb532070ba2da42aa3b43ed65553e0b4d28499df8b758023a243f2e7b7f8474e264252088d7f428915ee97fd995765b06eb64eb234c0514411471454d9a4d62047253f075f993b662b9e3de388d6c1ce64202c97c8df74c766b24794d12ee372bb411fcc3c443dce46462210f4e3c92c34603bd43d5310ffc6766d2221acb55dd2b3a5c8a6b6644013749b45792a166eaa7b12be0880e707912ad840ca3ae4fd65a15dedd99d8e2179db0cba8999a293ed39d30baace774a6e4c5a82c7a5251d65e6c75fb345b3c69aca7ba2eaba4e0848b7a7c0f8d73aba4d99e11b503a9e90fd9e7ca0930c554931ae305c0c050ea06efb3427bdc022e1c2ba00a206ed7aff87259c163c5abf33faf44ecdb8e00979d6c9b2821970109378a0b0b616dde6d6f5e9705aa3338779951f0ab4547deeac39c09d8938b1e756dfb58195cd347353e59c81698d73a032cc24e8ac36d2cd31cc07209725b69d99e04dc3d34e14ce80769f67e04f70c81d21729b0b895d3cc9c1f652db8e4860f84a2e746d21cb275e116c5fcc1b8baeefed8aae619d6730ace9cca8da143a7d3c0d87d082d5d4b1055482ed70df19249bd7ca97a5ad63e0248bb2ed669eaa663b8a9420fe73a69d9bfb4cd812408cea585e368c73dc733f80d8156d01fd0ad1c75cef31e2a83a462ce9274ddbf9d0cc79b2c72b57c32f86dc2df38c695049aaf7cf5f5f90fa7ddba4aede330fba1bafdb2a632dc11f7a05444bd91ca6595a93c4464d16b2c360f00e098161e9c3a35f24ce743d540871609f2e75cceec9b3785f1cc60722240a366e0da1efc078e26fa0bff16f12f73593d10b7868cf65bf65537b5c6045d8d0a750b4b9f61f39286e49535ddb48aeb089ec2b6cef008cd559920b0b9105fead3f563c66e1be162fe6d94bef3c65752130e837e787f5de7c0159e622ae8ae7203e7e3fc2e06456e699ee6a925e7ba81f6a9b0f72b92092b61133130509812aeb0f07edabc2215814d59e705eb195079e322e983d52f8c671412dd281250136ac81d9c70a24deeb4fcdd17ffb61cc1ce66d20605cb28933d8882ff87f8fd114c029b18131009fbe52ff30f9340f3c124c913f2768f96f2b0cf75c3e1c95da7f77ac310abeaf692022f87b6c7e80179b295debb07c0b951a942e6cb61fee0029f1e1aa8bdfe0fccdf48e6cee0420ab25ed7043da0c89faf79da4c1cacca8e209b5133eaffb1f8b01f064e98cd2e16c39758e1bc2ccb95c78df39f8cf1b442a22a787beafd98ddf2034448e0016fb694c275d6699b6a100df9d8ebc3ae06203d6e51361a7d76977f5755430337b937e049fc24db57d376e8be8ee4c2b90108689c910110a26420f39b57235d77575127b31d8a8f32240f03c62d8bc9d316535c636db24f93d99eb4f3f98e2ec19ac245c671ae99bcf8689b9a723fcf88732fa9bbb5e1cf91face7b9d072ab89199242b5e4283939cefbb51882abae4bbf7d005d8b23a71be201510081959205c2da5e944f44b78b52cdcc4a4b34761427884310db7b139b264c849a588a3c9ede4aaf210ef0061990d6024eac8e12a5e3c1e696ead4f7383bbb885b55a3ba706380fec9c65fa51882144361e49b6fd6f04f53dd5fcb54b1d6f6a2020b0ac40267b02a9458dc6db8cfa2743a1ef316ff3f6e102e28fc8d5e1488846ab56ede5e69855a2a67a1ffcb73fd8f30d076c47caea7edf006b8fde8bd0854219c9c8344de36d7fd4861014cd291fd2a698f70961e64b58242339ed86a8a0cd0b5ba58fe33df323e077cbd8b237466bc431abd45ea1fbeaff2f6bdabaf766b543ce609628bec0b7555bef7879e995d584ec63a10cd97624773400e024311c764250b59c191ca4ad170cecb0d4e7f6902d8b0cc9585211565191ebe1fe08a94e9bb7ad5f6b5bf1d3f8c4be93e5c2ba301139683aa02177479b4fc94187bef9220a00b0b808e9aa5190afa9a63cca7a23446cacb6502b3ebb9b1a0fc3d754c149acffe9bdc2b3da7bb874164c5e8f453f233c0e1d0918ab04040f7ed47f5d0db42a53761be4ae11aa05b411fc6653a2dc56102d633f3838ebcc0e6dc18c4f175040341ca4532a03ca917a9e5cc7116b5ce2070597096d9738d5c865de824bb248dcc795f2e976348fec5e9aff2fa7b43ffedb95cb4794c54a632ba24675ed419a676a383a8b8dbc1c29a6a1a32c020ba9d3638acef1916b71ed3471cccbae445858ebb372236a712a0ef3d3ebf60164fa1b8219f2a66943dcd38ec00f19aa1632dbe455712f2ef25d7bddab4f15dbb6f3faa948e73968455d3ca6b350db16f5db39e7317f13c15aba32bf9b87aedc61671d4f25be7e7f4d20491c85b595e55b1d7b51142b6efe74addddde4cc5887e5420dc5ae4357c7b12248d9e44a1c5a0f2b8ad062c2d790af1139e7fab57d9f129d3e220309d817b9f62944128e7e809d9ef99dff5630c5dfe99555a06beecc52827321d93025aced791f96489101e332b4302c20f0f07dafe26452353873cc0d2d78f65425305ff176b738459e03f4aea42b452fb24699ddcfdd638a7a91d74fd9b19bcba661a938a09cbe34d5c8b2d6f76447c9ecec403f89a069456bec03ff9a4f547320ebb45d1db6f37705aca13c49c802867b67d808138245a275a60b2f7174c09d1bfcd14928f8e68c63a8a30aa27b9f3d4a13ca40d50a6c1bed86e260d3a6abed11af31586eba9e59627feebcdbeeca3404a325fee100bf2f490a199e4b71a2e0d75f00a0f7a9eeecf4e027e759935e1c393f5e8887ff878c6581af254964655141d08f028286790fb8017702aa003b6b880b676d6665ba796d8bd5060eaeb5608cdfb016c1e2710e2ce06b4c15031f1a7ef6f96d5b9f7e924461361e11247c3a0557a65b7e7e68ee0b08267a0d8b08e6aada246768cf23e18e868796b1944c8225d7fc845ba09e0c0137e1f2edc4da5b2d0f7c35daf9b6eefbf2396daa442b90546e34dc8aa1bd16f76346fec840da8e742242e53ba287cb5b05f350af0bef0dd6c0a2009e92fdaede49be3911aa974019d574f84735de14c79638eee3b03da155253aec2ffabdd6ce23fa21497ad9b179c8c3e477c621c89ae89acf2a56febbc189f6aeec57de64bfb5893cddc9af71540ebf2793618da74772ae6ff65365bed5479b9f216d22cb28c7886abd96565e27450071ca2b56181fcaf3ee5b9990f2c504c19f9de51f18ee0bfb978a7ae341aca1136daa326355a2648f256f8369540b999a05ea59fe474e5559a59256ba6d54ace909ac1889aae7da20daee1192b41b9057a2d92cd482c82d4404111e44111327148e6183680ebf412ded31aa8b634f473394712ea5756276b4f1a26d16c6e73e03459e9ebb419170e4406caf03dec4e8d943512346d8eb559ba0781304a43f4174984afe785a21e4cf1f45bcc33fb43f6f2da84341a73518710ca5cb214bdf95078c5e28180cf4baabf6e422e0f4f6824b998488c64d1387a9c4bd0027cd2951cb33c595868b746b2c490c164ee224cd463c3c216cfa0a815655ddbd79e6a370fa6df4b27f2396875a651652ffbe3849e60d2ab4fcad8e8ee1302c09a03479c98cd6699ed67fe902cf9438d8a367e4e5ffdd48a341cf5e9a9f297df13a425038f254212db1e40168cb57ce25977dff5f84f0874a38b4cfd57f11200dae86f7932d7e122cf18b6831ff83878d8af10c73a39df4ae4a86d0cec3efdc618b31ff6401f88c0fbe07d3ddb808dffb1aadf7d9d5184af63824bec3760ceb2364e3c6ba59d732d3ff727e9f4586931f236b4a666ab0a1f9e58bb7ac4dc34141f1c7cc84dbc33a33deeac39c4dc912bff27c7103fd6e23c119141b9cde9eae7bd0d0d66dd48ba8f0103abbaa908aa3c1b1450389b9db8165f8e88a2feb5b43a49f2f5bbe6a340d3be7c56a740798a50780c47e99f803241c3cb07bc9360335ab11ca9c988fe8e238440c2dfbfd8aef4ffac6f9c4c818e1d29cb7208801f67bdd608697ed1f4fd4147829c207463da217a440a20ac74572903797ad28eee220c8c89856074544083e9f078f9926576de9c1ec3a2f4f3ea1410bd70dc535123137e72acf14f5e983b6b164308b52a3afaef12fb9d6cdc374cfdd845c6151e0a96386d31e2975576c7d35b8cd577c27026eba8f7f32959673097bee573d4c53c311c88ac08400a255db25100f31b1e36cf56fc7a8171fcc62558a864f4b532a0fb8900e29410c4fbb08f3ac528b5a871273cd243b50fae3ab7192c2a8b61b2049e65d769026ebc8c96b06c45901e8baac2de0a936d6870c8a531b9e60c5def3094efa108c1a5cd631eb7abf6135fed812c7bfc5e60361ce66c272809cc5a183b7240f5f69815502bfaa86a08eb00262ef19da8dd60ac5f25ec9a355c51c89efce49b47580aaa52ebef9ce0345ae91fdcae98cdad13b8d0effb1c65965d8f0d61ed2003573a15a8f89a14c31f41c25b7e0f8f668446c4332c6c7fda4b03de25225ff184ce95be2be94513767c48c5b25662414350de9e4ceb9b7680867691761f24736c5f645a1d8f4b569513bfeadca2b52a863436ba1bef4ab59e31908c07aa94faf991470f1f4a85e10f3864435fa83f800e60228e46f421e1f702487570ca71c1f972981081ac590b4862160823c7e55f6b3a79fe13f92599331602354ad41b89944e67610f1dac190f6c0334d553c12f4b00678ac8d43d39bec228fb128d00c98f6ac2c963defb32ef38c887fd9b2b5b397b368f6d70d23cfde02fdffc2a05a0c0b1b5e73f3fc0549c58e4150e45a3e2bdcaaaec0bab2354a8f51cdc98dc87d1c20c089c38488a0c96fefc518c1ca4908f76cee0ddc65c721de8a92d54469623a4c0fd2eece8a2667f5a7218f4e6659d4ddb6e3f9c3b2c58cf4bf78cda73227c8dd4934a22b24cf5e4a00fb0c092b934247337e15e03d53630d54c82a58ad5d99bd6c7c305825d47ac4107f984b2576e61bcf1161c02a1edc2b031ef42967c0185f59cb5369d5540e15996bc54d09e2fca3587358be65230b50319867aa0759e084a6e340987d6c5698b96505a54edd6bdec85e7b1a8aab8262cb4b2cc984c6d842f881647c0ef293dbcb2a1b8749f0644d1a02ace1d2629ec9a561bf1307e8fb827030640bd6c5943925392642b28b5d57fd681003a1e144b5598326f81915a46933a5aac1e8b18ac654658cd2eb303b352ecd4cdc82c82b68d145c1f54107be4619f7dd1e9b13ce5e44e6bf4807e4f56169fa5130157a8d627623aeaf128fd506703967aafa5137ec6ad8a046784c88510c1104f43d73d5cb274ed1846869f4c2cecf78c0ca50cc8da4c700775162ed6eb31e065104ef39edd6ce1092118aa7c12c86ee5d4b5b87e18728ba68d10530463f6b2574211c3730f358e5e74c7bf9425d456ec0e3b769103fc22af494b6abb184613caf98bcfb528890c47f1931232a75c1da81f3b4ef75a22a50a793b3c8c2b174c07b3cb8fc5e2c7aa9d5f3ae4324758df4b41885c69ca0532ac8260b4f6d12f7574fce72bfd2dbff2340ed067cd85740f4fd04770463091c66b82820ed2be6166d41a331104392f63470a4d9cd3baa33f3eda4c24d539954ec7b4d39f325602ed73e0dd3bab19c6da8d42b9adfc4a524e12de7ec01099644d92e832fafd2b28eecd108274b6eae0d5ade2cd519a9cdf2d7c75aaf2a30618f3adb18863088b096931aa9216dc7cb7418854ccbd11dab97fb0187a8ef2d30a487f10d07fb980de1de0b25d530cf94233d2e3976ce2e3f9ee77d2d79a10befc55cd2c40d6d2d67a8c475cda8a1d3e4516b271811ea239a4f6ca5f45c8ac31e823917425d0500fffc4e0b8cd801f1b52be2335e85aa4f2a191f4c61586a3d78906d18464f1b297ee4c791e81a1957a50acafb389110b8a640beb0ce9e4edc8fda8828ac131898ae9aa0528004aeabe06701781154b94da34a93a915435f611e31adbd37c7bfde6154c51fccdd3cc9efa5652eacdded5744c00c7f85232590d83a69a64e8c1a65e3307d536cd08d1c4ea1963dfacd92479b0d26f0f49600f8c1405d309ec0c94df28d39ce3b41256bd0eaf6eb01a6757f1f0f1db5e4c777dea93b5b0eabfae7c93142859b3747d013176f198fe12a10c43707a0cf6b20f59c6b2b5b006adbc4e3582e283bbcc31923a60c9801c3ad8f9fe75c792ebf67aa32307ab0a54efb890ff36424aac48b6df209b36ef790d9eb27897166b871faeefaf95ef9fe69473e0d7cc5d343c80315a3ffa630249e66718e89968ab34034795e5f2f430035b2b8aa1f34813cc6bfd2fcc53f471e3ec31be39a22c0bda9cb0d1f82f31d72e7bf56d4e45e15be136b46aa84f4721f921754951327d6a443213d0f1f79b34130b51f0bc233456587dc60483f0ecd509b362d196dffc5ef4d2bde73ca402f5f157221af9ce0cff0c1ce487f848bd6805ae12ea97c6bd169ab56e62cd0ed14693a6dd7f66a9a277687c7f653a8dbd975151be81a49dcec3709f29c0db1e560cb0d786f8c0d1a20735cdddaac6c85fe47c86a899d86cc52c2e7bf764894ff302949b8e2dc794d3ba8e9866cd82dd8828621db7b57edeee19a589de1cba1ec7c1ee3f7164fa30c5d0febbb62c74306292c19c4e682bbbe10def577d385dcffd9f0e1f86e7b8ff8f9940dd70e6594de2cca4960990ed2deb73d92679f4c904afb4216d73fb644f5ca4187efc87030c0d2ccd99a3fb715364c7229205a9e54b13f58ab7545344ecc64095436d85d45a4a5fdb8e45d2deab2364f672e5b9ca4962a97ea007e70eeb0465ad554d8a4466aa97fb589bdc1f1799899049223208ddaf1ab93843fb400378826a942df9db81c7b0b6a202fe2b2408c3e653e69b6dd8d1523569d44aaca3a1874fd8d7e80cb4e017dc66d07075f3fe4da3741ed36dc2f748baedd6505b9f8a549dd9b43e05bdf7c1e594510022a28c92c9c08724b5823a2b4fa95da32227485f9506fd4481ae97a43e4ec1eacd5f62d9c0837e63c2d085934cb157b71a27bae9e53ac80c923a11f9baa56d8830bbcfc2f71d45a16ba612421779869e6a82d1df0c378a1bc10b536ec964e62b701633f7d09b6e0ed8a7933dd9cccd35c737137caf32b348c3ef0681fb2896d7ab8fbaa7c39f382c412595803cf98b4006ffa132f91a1a8a003cfc4f97fc71986146b615bb7fec4119f76893cee59ca90d6c8b894b852fe778ddaf4d4cd0f617836f055ece93f909eb962b102f290b4ac74d2a02c226015f15c7777b066c2d974da61cd23ff57ce8162e2efc497c857e37d9ad7a51391c7695b33c4c02100093bfab7056d1ae72a42ab97de55ef984ef4704e3298b08679708a6965ca27be956a699a15f90f605d798424325255ff171069ac906e81d18bb0af4ca8a83e591b7dbb49fef835ba58db095028d53640c298671e85968e6e3599ce5ced2f276242f3c3f6518d167c86c781d164c6512cc9504e7370f060727196ad0d7528ad369b542fd496c4a9e5685718dc049b17c6e6732c8fc0bf1ec7e8e3d9d46675c5676971198662e0b668dc0cff3a0be40fe39c6b6192b50f94610512879ef5c9ceee1389ed545158c7d13ed1e7fc6fd0cf1f0b29da45cb3ea90c3ab6ab2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
