<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c2d9a0f1b5229b5b7c24a39f76671adc46c749925f39a04099fdc54095ede4ff8fa16b341ad25bd227a077292644e84e58adbea0150f401620013642a9c3c4d7a9ca0389046df849cedc794698725cc05772b9a7a3b301453230b897046c020bb6310a8288ff604dfcaab5cecda3b0d26dc6993ad6819914a78de600048f7c679d5b027531878b38bc627a7ad02108fb47ac494b4f29d614dc9fe4c4b506803e79cb4a6270028fa267ef94c923fc7e9d75a4c7aad349a81e851ed3237aee0accf54d7457861a996062cb9eb351d55ff4505824100a6e2b8953a38b545722c6ba7214eba294dbd0aff68a545bb243f1a1c948f68a5aa4e7fc7511156de7b72af2b919344b3594ff545391d8b8d2189ef8476a3ad20771ab6094b2c02285b5171ce206334da34e40f90410a85c9ba38a6530b352eca0ae6f99b7730ce9ff6778708617e75806d28388267bd45ad1f9800bfc68e49ddabcf57468640ef3b0e9276f06bfd8b63780a1cebee4db82f590d6ab5a0a6fcad6bff617c8ea709843a136d2e46c6b1f8200d66b988738340bf4bbad898e9e47ebacafee4d35b58174f83937284240c87790e29034d22faad9179aa687d227fa8f65fb2312712ecc716a3fd078ff091ccb23578e0948567cd4a1c199765db67b1350499c44abcd67b416d8000d76cf18042ed05c1d1899f4123c5771eb9524e95620e9b4c5d17511cee0bc75022e8bc2dda8bd5473837e66471f78863a3a823b1292e6fabbd9668e2fcdeea864ba1ef6e924f89d0df2e9092a774ab2dde6141ddabf9fc3fd9494b0500c68e1a4b07bab7c53d786e95c1e8b127a31f12d740fdc5f3e6bb62c4345d35f6c88fef62950c30c173fbce158f893fd8e1e3db95901b52c8ac4d0b26789a40b2e1f4d4e71ba0e4df37eafc94833fb4f2886bfabd888232d8d1afbbb4a1ce316bebfde450e89d84ccfa5eae66e913289cd0e053fcc0691d2b1e3cd7d2137de7d03ffad475c987900eb4d790a2288e6231293af010623a35bec45907ebf58e705114a99c99fe39a90226b1f70870f7b09ca6552c66d947d9f8089b22b83f4ffb808c8a1d49788145ea20ff9a8fa124767c0bc400298edcb47a163995196cf2cb9620473a52c6f895d412511ba7e1c2c36ad6f3f24faaa041e7448a09a92070fda52a5119ea042370413aa93932584d64f866f9b9802c7b1cc205c8a5d44f3596c11ca017e5a53f1bc55c083b411e0d72de6f515d915b76039aa7a6cdadffca39bbaf775e81f027cc2dae3bd8b99630140e965577ef3645ed021e66fa3503907ca6eecc6678c46d1a6f1b79164bf5f31e28af350896f05ed2c023b7a7c22c9f81b0f67acbccde2c6c616ce498894e11fda29ae523ff220beea1beb408187f73a7636026cb77aa1f829ca70cda7b8db3475336a999776d1e2ada28e0b996281b7cdd24ad933bd7c2eacb1779a890c9e9acba8fd995bab5e0861965a6156f0f4b696a0552ef2b2bd96ed01798d520d745c89b5911607294b538fd05f97e7f5914902da9c9d169d4c4c1afc3142167d6437c61344c09655b8626c0505b3df035a7959f44efe5a33afd88d6d7d876eb214d0dd6336ded3c5ec592114d349494e4af192dab80e1917873d48b971cd0b968a18ebd62b3e253432f70d2f21ec3d40de0ae8dd1a192f77643ff4234b35a352e72580c028de952ecf842ccc9a3fc2d9e7370d03368fdf4103a459f76373cced3136fd026f931e9214b8905f82cc0910643b50ab66600c641ae22c9c14d1a90b58ef5f1d819c9c41f007addd6cc44f286de93095548d08dafe30417d4d053121dcb493e2c9763ccfce5c6ab6f506c8663758cbc8035ca69a4b7a6cfbd18251a0b251aab23876500f7cfb606c3eb4768826e7c6abe66aeed28f9475a77ef066fb7a4d6732166b67c799e8e5e844cfc88661136ed028f0bb2f5d8d776cc60e817ab653d0b63c917bf9d444332ca9ba5dc1415ed002beb8720b3857e7daa47e5cc930761def5396ae212964ffb71795cf5690934c9d71e5d8d51bd4a12861b22aa5ecbda7ef4efb500743c9a2bab3b52d5107995497d46a158c321ad85ca6f47d222a21b7f16b3a514d14a3c3df4afebdcd6aba8312e7a1defea00c164c0443f836a06bab9db60038a73bc4ae9acade4718919c649221c67d37eb87371344f46a5c77ea88f5bc2ceb2d8f68f5b4fc9d38c32f1825b22cd2f314b94806b9941e727d81d4731eb6ba524d2a7963f3863eda6efee292d96bed865fe83fa1ceaa7a293d5904fe70620d20192d55fe55e70a4645483178a12c2196c41b69c306d0889a61a834463b6ca0f7758aa3229fedc9644393f8d925897488d453ba04dd48fea8e25ed9f52cb0ecb47b0ae11c23c5cd79bbc3d4f2814bafa5eff503b206f02055a140ec9f1279c7ba8f472c6fc4339d565e0602abb9c4ba6d20bb560de33dcec6c779177069cbc64124d0ce695ad20f2df805cbfc59332aea086c177f95dc5984df337bc820cbbe0f529251d1b1483fe9b28ba3a6b8ac162eaea8ee5d15bdf730d571c9adf7f1a6aa3466ac96c08cba9c23780361c4960b8a0b13f785196cc230f066996a9919738b8c26046960137ccfb22bc2d3000ebb32435ea7ac717de0918e9149afd69069d7e21c9e81fbfbea784496847ec5468876f5631a94c12d52de5e779568317f61440dfe483eeee4a6d5b613a054c662615674400149aa05ab0f63d44b8df5cfb197a961569ced27ee389df31e0664e4f5fb0ceaad3cbbb224c4401c6efbbab0b303226520e41de9e318d5b9a023959c73e4f7ffcb9d6d755753d82a49f000cdf9c71a124993e7c046b3509b6f021540440488fe61b34fa4a3fca2da61e9b2813dea2f5a01d933e4e41371a28fbb94ea355b2c592ad5e3f1b6823d3e48e73dddcfea38ebac87818964bca167c78a9e6f2f8d7472ad2e2b89fcef2bfcdaa4a5d05148310036f02d1fe46674830c6783b18bdbbcf540fabd1213153e31e3831343fbb5cf8353b2d9e40cb321f332996b9da095c25adb71a8d66e731d81523a79c469baf2dbbf8856330cce9fe191e9c218726c57196666e224aeab60565e997598f421bc3468520359d110dc94ca0147385370ac12e9484ac14a7bd4ecf5a6eccad1dd3a92a1e27922225c9d36446ffadab83e42f3492f7dff7b435e525346db6269c0397a17f54f540123cdef14adb4edcd9603259ba42962ec639257600d245106098d5e6044ecb7d5334b93ca12c2f3688b754e21bc11443bffd004a75cb495b0729ebe36f99f5b23652f63f9799758ef62973e9aa8aee97557107380013a20d9ede2ffb655a5b3bc87743142081ed4ef6fe34ae8ba4024da8383472c7a9ce34eec0a5948faddf208c6429383ea30d9c7e75d4fd8a11914f526ac9c4a992cf96e64d4de2fe35afc516bf3acf9da7fb896d768e9c40408310e1872999e2d37ca5f45e04bac0934a53007d6f85dfbbd5a5876df1ac604f9c17c22a7306ce642164ea9244acae9dc8cd800205567c63ed9fba68c501377ef8285f053a998fb7e57292ca225ddbe0a6700e062abae7d6a00188ad2a6e0a34e95d45e99543ce48d776d8b8d3c3e062917c0f34597f847abaab0809f105ace263beecb0349d4ecebb8c013fabd456b20686c024a26ba79e97fb74df84a5fe2ef2f3e4c34680ea578aa810180d2568aa6f116e207760f3b8ec8da5e5965d15ee45089ba6e5c84219c64cdc6839000c62809b7a711436b2c8117615d6ef5982d51bbdc410040dcc8baf2e0bad2e115d4f50e4551614847f9d5d3197eafe402968bf6e15f8a6ac19e2bcecf11023756c20b7f33284290b8c0b95cdf245ae37dccade284640a8f8d218ad4604b3c1a5a06eeaa8998276c1cdd300922943eb8e6e9b7f95427ed5e1aa7ab124df2525e024b3335198421c6828aa622de0bc3b8a4af374b3e41e8c4a8bc5af7b519526097c312f2a313d4b404248068985c7ead373ac5a48185524799fd425883404195699e58ee1a842a74f1b9ec36d91c73e494a13e3529ccf3f32e9455a7849b1f614875f130ad8e195a1f15a8e6521dda9d1773a009c9771fab7c44e613ab3e2e7152e2cc05c3a02cf4fa942645e957928577e6fd2214a74f21c863ef7126044bef1cc41af67323d130d6af5a63453da9616d1b95c557063d3d2c433ef4db0ef328ff677535f8bb0b949d926052a4d66773c9e4f25a7a138af1889ab64cae3053ec84fef661df2bdc330c3041e0059e08dbc814ee6569ef640a3cbe67bcceac7c7eae08b8503d9acade519a6662a25163be07e5b25556e2fbe47dfe22dd2027e3a7d0e55726fde586ae868497f6ec652944fa28d15cf9273eb9f7b79b9d3ce3b48271c44244f8dcfd9699993a711e7c4e95308ff8cb9a8b5578236e8fce8c6bf51e4c670552ae47545b5b1c751541ee5cc631189d8f83bdd7d387f21f7fe0e874791e7e9909bac796c915b60976a12239114154f2ddca5a49a56670ea9d61f283968aba6c5d805f5555b0685fe527928287435b772ad1e89705535d9805e7b6694eee399e79405a4a2a5e5454f1cab0e1091cead3b61f1917d0c16ccdb2a36c8af7f46a54d9b165668c7a028853e291e0dc155f5083ea6017498cd32a473b0ed898be3f355f2aface016e9100daacb96305d2df47c6192d90ceea1270e0e837212a2d696d076ac29922b21d11085efb777b742e45ecfce1eaa481acbc6d8fdd87e103f57afa38e2e2ad3d4104c6bd2cb105499211a7478896a8c93115d07e5d8a9cb249c900f9c025647fd35f8fa667fddb6dacde33df2c4ae89c6496363c8af57bf85256c618ce5ea7dfe95709ce4558f3f90fdef87bdd2c424ee5e51bace5c0a11649055031e9c107c131515f8527713c8c1a70bfb9fe4b497b6ae25a6389c3d20c9a3431383fbd5613d94ba7bf6e8d19edd7de8eb99dcd103ee5c16709fe23c61fab840144bcd243bace21f64cb5c34683eefbfb35f138c7af3d15c2c73cd96bab6c44c317f1ecaefbad0f640d16fe0b94f2a7acf4822c57a5cc618e227f4f3f880f11ce34b34872b9effae537021df415f0582d180d71b4015d428e54b3063f579576218f56653e853e471da9831fffc0e500f10a6922d913c88f53fd5cf058a739cbde8f36189a8be21892219133c31267717c4f4588e5a503daffb87b60031ea5185a0239e7d13fec206a404c80720d7977164a0e951fa26eaf561992e06484c9d7aca7a4b8a727b9d8a3743759e0fb9a0a8c6611bbe3d819fb256fe0a4a01ce8d53aaa6183cbe32f068a1f74ef7c5cd818bba37affd966b5ad1bb6ca080460e66a0ec4515a6d488622a131ea8c5cb65cc15f8202549233a87c7b68328715280c03fe7ba37cd882614e42c750d3ef51bd3c5c1e7e9326b551720f5705bb0af153a03c705629befcf130acf1b5e7e753a0f5689ec0170e2642772c985ae7a1f222b0e6d27bb06714aad85283ab13624308d87d2757c54f55be99a73f4c195826d6b74dc947d0bca03a94efc53076aa41b474b50c3cda50d1027135fd6e872ba6890e69de351f01b9d8282bf04ff53e19244b3c9c90ecc017ef7406957bd08ac7864272d7150f1ff411e986ad89c8f92be18977c005fb7f897c94de922a3e96e1a21c31300798412234cb9959f088134904b63541b7af62d5241bf495847b0c810de813cca4f49e1266e11de74608e3f68102edf948d3c267ed8d4e8b5e1899232883b32d763d4bea747e6a2e6f76917d1bbdbc250702722695554a5575c974919e19b226bb3bf92269631887a95564a3401efb1c123ccac2e6d3de08b5a14e32615bd24c50e32f289e607fdc77dd0f67c6c86b7c090d46e9048662c844015166c9040fe5754bbaa6dfe736d9e8f6decb061ca749666c44a5926b8344067998d93525cc3a5d909839a54b16f52f6d4840ad679882247acdc68fe20bddd81713ec90fa6653d7d80809fdf7fd22fb80cdb83b37f148d76c1a6d2fdb54db3c9d8ac6bd00cde497bb020b6353a2f7be0776c998f792e190bfe92210a9bb9396d61dd0a151ad94dc09097463545f9d18b16bff6c6a9d8bdf22dafcda0fe0baef88c4bce59912a698c91084ab65142e1c44c97af423fd1f1679e116ea331be953abb5e2afc690c8dcd77bbe7f87ef22a774a1fb23e6c85225aa90033b299d959797b5194bf5b2ae0d373e52ed4990a350bafac50b79a4d2cea2de7e06d2acc9f0316fbd3c0642dbe5698a9c7e75691ddeb09b5d15c0d3161ead6775d32c83b46223acc0946d362b4d5ff0ab250694d4567098f179f5504d247ebf045518b9c74e6efe446fc7d37d862449feb820e3c28ca5d82524ff49edeea1db90640fb254f36a89186c0ec2ffb596e485aa8e95e854133088441b88b594d136f035abd9723b910953b05bffe87ad94c32694f57624ff9fea18ca9371f384b8629f180178fb093fea09cad567681e9b473c447400406dea705bf585f226045a1cd4fbe85dbd1464026a5b265fc799d2a21e47dfeb8ce1c74359924c937a5aa7dfce846f0ad3e5b21c963a98e86ee04e56731a6cdcbb6131cfa3d2eea1cd466c49f63b88818f85c963454fffcf4ab89d1261dd92ea3e527df98276dae382812fd9f0279eb4a9b66884fa73aecfdcb365b97cbfeef698efc8b128286c06cabcbce107b54e17959ae35819da4a57be3c76f316b8ca17de2c95ef25fdb4bf6d62bfd16d72b1db47a2cfefe6c4af2dc9cbb11ec42cbe2f062800e81ceb2a5c7e5db2b92e534b9a10f2094cf099f5ebb1aa17ea886eedfdd7ee53697e8e2c64ca40f61aea825e20c4a17bff6b35b91520ab40c5bad9656ed415305c930cc1f21df07ca7445c1eb1e6979a8e2da553b4f910ac968da20cd8dc6160a4e65c52200ce0b4c0ff3005d82a11648cef470d75e172d3a59a8e18fc195044b1ed61766a22617b2cf574e0d121cefc2b2cd60f3e949b3d1a60e4dc55fba1d74561835eb80e6079a3f8760a16987fdf55a88b839b0ada56320cd9dc78a95e6c366e9d14fcc8fb2b0370aefcec5e33168823386fea1a2f525ed052f9164409a554b37c679f42ddd1ee309a985c9151cde3e6e98bdd7333e90588c3302c11a680caa3a18a5ba5ef2dc3efc42fc44e36235c677fb5f519ae385fcc75402d0823d243ffbb4e684430a83751ae70a8a8d1eb838e1fa8ada9a29913f46ca03a55c290666cab1385a4b9ceaf68667c72421f2cac22ac4a7d9da7cec4f880a6fe1b588db15d89d2315024f3df0ebc5dc063c8a44730ca328e898958298ef90df49f061b155deca4b586a439daa3aa9e4b62eb678b30f328a703aabc38d5a99580d67141171845818fe9ea51f7a3713315fe103cbadc9d43b50e9394a53a656576ec0dab16ca2cb8b6de829624e69b4cd909401a9a5b96d05aed899d21c28cc679826b5ebb468840103936535416f990d3dd626216f21bdce7bce391d877ca24d83384132f9f97422c2a5713cb2448d116c694b25a22034a9fbbd0db460444ba51dd9dcf0d5a7f87b86feb954174426a87a3c9cb963c1ae48e86deee136e9293d2fbaf51caf849a398c23b3a85e0cd694aecf16b791de0fc79d44b9c564e1b6663ee7b6cabfeb17b733428ccd9b9422728146416828aa824fdc70d3a48f37a83380640c96087906979f05749602cc0e1a9c100e249441d7fa4293ff00b191398ac75bbbe2f87d40673debf2343eafd2772bcf3a48600233b93c01ab40420841a9af6ffdce3d6be4a9a9a6c6a3e544b3fdbb28a463a2f54dc839a65902ff7bfb83fb0218e3a6f8206f06296d9b276f5d4f875b823ff5f0f2f6f4ff95775e5e96e948e10420ea97ea5b04292a16834e2d95ac874d99ed438dc8dca6158ec4677477674c83b881dbfab13d89beebb5fbc30658d159e906603d71f4d1ea415478c12df836140608f66b9e5a9983cb4bca9d4eed313a368baa1932b3c02af1ff17e975c55a24241871d89fdf78c3629260156837dad6266ce07f28b97d7f03fa6d2b8b01631c6543475d4cadbfdf4d9fc734b53e013b21b558a2f406bccc0698f46e90146fd4459e66450583eded4c55142824d1331453b7850a663c1c55d6fcd9264d99c9cc590f1a18230116944d5e655e47959c91659766ce100b3ea110a72ace1b8781747b10a6ae417f8851f957cd26892542744c52fc74f2345366854cd82f8d0c863e003c6461d7052e1db2e10b9014b6c1dcbdeca46076420b4f86453d1746d5d71dfe88be4c1e7191f82b83c6023d487e8508acf18ea1a9cdf43e9e520b3985b96a8cabcf2597b6f84f2d8426e21789c30e883b6222495b9fdb3f1ac3f8677692709270846dd3595c1b896e6b8eab11ef523dc9ed956d15541e41dbbce26cd5a443d969cd74cfb708e2454917ea96fba571cc0773b5c16e9b7894e6fb0f64fe9cba1a011c735f2d35d039587fb85d35a07d7727169156e6b42b7285cf8d64346732a2a7725460444556c2968311ecba4233adc98c6b0a9e16285fd49bba6fee475ac60e02a269347f20f023730dd6ccc9637220c02719a37ad7b7e75bfe8d214d581ca4267e626d8d1d32f4d813241c8c98c68fe547eb39a4f2401c33ed7b9ff5d50dc58bf2bd4813cd063d002ef6e58705fbf772afe4a6071ffc6bad0736eb43b634d17c8957d5a53cad5d0af1a75e459f3644fae35e622f97b308182449d57328eed873a7d4f277565cadff2acc2bcaabb5b4891c263126bd6e03fbd785287b81b2922d24d6225bb5c6a4a54bb0831ea45c425d84db4e9fe2e65dd553568a0552534866b03568fc8e6380c611b4386bfc6834e39fbda7a59ed13f6af75e465b64586515fd417f4aae4d3e2a008264bc10ef0f84983d8cd05cb81763e7dc70355543af77bffc7b47632102ea10c953f5ea851c63152f7abc375c08fceab4d97f99a2fa41a3db840940faf5c7c5cc7cf2e8c9e99aae2f6affea20030e2f20ab39b2a10f060966f7bff2ed00c17880edf795cb41fae2665dce6c628248981d6d2cc0ef1c348241c3f8a4fe10794a4382211d9ff2abf69ed1adb0cb29ea4176a41bfa929b1df3cd61b8b4e620491d72156dc9031abd6d30163aa4620dea7c21b4d16a0f43fbd512e7b7583fb2c0cafe80b6f5b47172b997701a3b48e24a992e60d18fb771adc52be89a309b5467eb19ee610c3011703436539e52d0fba388d84455d9781a659f5f68a1a1cbeb52716a7f7b7606e82cf00f624d705ce989fad063e2361fcebe65fb96391d1eb72c6803b011d8e30f239d8f5584ad2c345e209a1af8dacc52ff6bdd27c15cbf73f89d145b89e3faa6f4e111ecc24abe15810f660c5537df44e1c71d9700f673a8cd14cb8af257128e50f75660b62019b7289444df9b9872b6d8ca64fc4cb8f967785ec554108898213393ea5056ec3f4d7dd82ff920735e401a9d0dbb393afa6ce7e2d7f8f3f729fc3299a88ad704466a545c7fca57681121daf5ca760a1d28ef83dc23204897706ded5771756882bde209cceaff20fe60308b95e3a46c9fcc9c5f6b4b4cb0d2714f06f309b7cddfefbbd14bfc805d7525a34efed0126742e94a316dcac6e29bac2fbf6e839f8e096d77f9b95d4ca5da4e0b4dd4d9efeece09aaac4d501ce3fe1b23884272fe0c0cf92dadbaaf010bcda36a7c8bc3861f3d4ed9ceaeacbbf821d99cd3564e74f6ef0e93e21128dd19c95688fc2ae82f10583c2b12774c1d188ac8fd1c6e8968f9514d153454fe279b0a4168b86b42d83bb3d40e01456c95d586f9d7ead299f6206bb9cdf78f4835aef5d7a06ca2edf8ad4237e70c4b82dabf1c56fff074111c1487d2f852bf07cedabda08dde50fe46685a9770c13aba8c2fd740c9f81094da70a28630f80bf8555f198a4ee5420be5bc668840f137da2da99718f93f56e1491bf9d6c4e2e403361c8388b870abf7bc7872eddbb79e80d4b640ea926f218e9b52d509366d68114d9a812f40a7098e1534621ceb605c9f38f69a24732ebe14b58db05e4ae91608f9f48c31bedb6ec86369d0b8e78bc1bdac6ffb06b6a4201e00bcbce57cec87c9753bd3da1b56ff327c25429de77b783be12219a2ea7b838f95cb3668744e1aac961d6bbc0c41fb0c6e40bede592f9cf3b9c1b479acb71b2c78e0fb07cd17d01a04a3dbe624ba8df5b684093b8eafc41a3ab568cec31f2e413939959308596e8769be173e3559ccfd31b87e41f554b53c03288319fb6e94cbcef76e43d76018285971b85258c880c9f99591f0965c198a7244bbeb49b09d9dad33db24e5e5ebe1ce69e2dbf63f52a89f99171a6298a04bef906930cf82f0645eebc540f291a3212c0f598933e59424bd2d12df186c14744a528bc41c1388acf96975c1e4c7598405c915adf8fc6240d785bf2adb31e5a61264b9c67606df6e47a017695ff71ad87d6c35d02c3ee061bc01af54caa7347b1b7b0f55919ef18a60df85407539b67f19694bf2c6b6e29acff66ad7f3ee7bbdd0c2171a18b8418e2d4d2d6cc49cb2a233fbc59217966cca0984727e36e428201628bdc13f55790d4816e2a02a78797b56b527176c74ef6cc5bce3b1fe32ca89a711e9335f285eaee183d208f353afcb86e2cfa8435ae4cb2222ff4621eda65ea09d26bf897a963fe94382f54f3f518531ef1173825512cdc6d2ef436b6eca8194a5f9e257a5b83d920fbdeb3f89142a927b15bce6544be8636364edc2fa27dfb501e13d28ec82bf278e2b1e30205a2a6eee03c928afcc1d9c3d9fdda56783ba29b31951558aa6b72f8e1848113519480ff31ab2d4cfc056fce8adb2a05635968fa0201bd90c7cafc16d45f29c84b99c2594b13f9ddc81fb589dba228cbcbc03357839cbf7a0296460d15c5a9099f5da1c4ac4bdf3680af28d061a9111552ea262f142301c04793d80fe039ddbfdc88d07907210a5c5cbd273de19fb390b1c37290b7229a30f0b404c7e2433a3c622df9a31ce87a808f210b614881fb5c53e5930547398b777bb044079f4ca24416b7990a1794974e7cabf4a88acec2ae0cb7728f81451d626caf7728e88bdc1f59fe2f6c10a9258b98e310637c8ef25fe797637b185353efae956bf327c01b929425d37faaf2ae755f3205135be5409f40a2877d4ea13a902576ebd471aa969e947c7bc5f0132be70ea9a34b4ca612aec2846d85750076f3dc7c7dd63a40166d66211b5531a0f7c0bb0ad5a85cc7bb0fe9ccedc8bc390dc35e2333faa97fb621aea35912171ad80cce08c27be64a1bd1e868e8bc563548737cc9ebcd2fce0b8d4bc740a7610f9f8fdea84d0b49739ecbfeccdb0a03cc05440e1a8c9b26e8c6a7b495fb6b1ae0b91613405635552705343d47cc6032200c1cb454af9fdcb4ab8ffbd9e74b02f6c01aa7bd4a54eee2f6abd83be8e67c7cc93a546e9df4c49564e146c4ed658907e493ee23829ea1c473f6b9bb041e079f4861957df2d35455706a9fa0e30e1c20f849a512b5b811b8ac9eebc54b6230ac2bfa7d0cf78760278f7931b8d1725cb3cc0733ef0da886569c95c845ff73aa8e453e6f95cb34a0f0618229c91ce468782bb0a41a1003b925ecfae05c6a38d1ae0283f9efe07a3ecf1bbd6f0c567b1ffa3fe9096409a797b909fd18181ce62cf340893d138578bc241952a1612f53d3ec64f632219a38d9c35c67cbed7f1d74c8af74ed12184484b5925448a7dda28f5edc809ebbe1542e34e0066e4e3ea9acec98fd788f2c44c6fad82582407e3edde0038cc1c196679f085aff084bc60963843184b85791a7b32de43e380ffc65fdeffcb2fd1a82743ec8530c8b6ed1e759ec5379b9a3e88f546550f4a1cddb5ccf44331738fe2035a458eb043a38dae42fe566aeb853be1a6484bffdee1472fc98286616acfe681728072a443f1228239c521249764f971e53fa3e2141f5f1e84babaf12745d5787a4efe724815f895e235a1827075ed1a1002e470180af3da4548b75cc7f152a0d93f82f3286aac5a209c981b33daae857d1ddbf60b2c6d0be7dc8a1bf2283a1b001940724488796dc92fddfc35f514f3e845d5c14f24e31b8f9bfe0549e358b2820117b0c8840c1ef8805f0bf1bec03d20d3f2315af5a4281a211e3f4941de7c93496ea96d5d0ddc49d5582f8ab811091b950d08370bec2647ca3df9a8a5bf58aa698467a9e9bd460c2799d841f3117278dddcff28c54691ec78dc37f4efa9d54958886bc7fc6bf7604b48dbf13987f46a2cead5c4f83e039f151ec778237eedc420e0f1925f955c447a96c4f372e791464544325b9f8af8304135f6f3d0d46cd003a69a6a1bbd2ea58a97e2693c22acff5486ac6a2bec91bdfd3017dad0c883499777ea90219b49538fe44fca3ca7796a68fbfd2b233a262cabb0d075bcac09a753825b9b603aa129a43e3f09c54cb979424fd5011da0c4ebc46481d773cad0cfa74e9b808c3a3def07f1fee4247dcd304fece6a00c9be0c3befe7ee984135e46dbbccb20f5c4099ab71fe2f38de23f30960cb8de184d61b775d658ccb0d84e52f67862612d0482b3c3e32dfacefbf419850ccecce0a39912662c55c7ddd24e676d2b4cb7c15255dc8c547eee0f76188655c33e8946d03fbcd86ee0ae74deec8ad87295784c71f93a7f31c8d51acb7f7db673d09536a276d4a0726ffb75230acecc62f0de53d852ff7f79a0903c74b18d10db940afde52c74436627ed2e3e5dbe28eea89b4d3076d4c835f167e518e081d80f4a60eda6016184c86285963b4d2af62f3901c6cb9f22f1040255747967c5ce9c5b4743cc730625f7c78d39a1bed77311c0c2e5ba641b0fd65e1110d667187e2fdd958922a8c1a0b85b76f9fb6dfbe85d51762338049d334fecc46e3ef948b28900d2a765684d82c0fde1ead49a93cb0282a05b0564ddb6ecb2b730d7f063f885833a5ce670c8436c3c66110c7d089ad5044ca3caf3bd5f24febcae65bad8766ffabf62d9d2aaefef459e5b39d573f2c0e349a776fe4df4bdb82fcc85f4cd5cceb357a3a8ac7f4fb7425169daa66c5996cba00af6a7182990a1a32856403220a65debfec8343c13b8d21337397347c6d5a48fa7ba7f5b1dde9d05ca2bad537a7094227076c100b27efb0b1a5ec25a56e188cc2429bebf9e68649c042764b0e2be13d59d83e422601a530563be088693a7656afd209a49b033fa7014e106dfca0c052fae807f88bd6d50533c96daa9c6262003e7cf5b0c7fcbfe6b754ef1d49ef53a5d5b223dd206943853a9a078aa60baae51fcc37a5d940d1f7de9ef4fe5ec1e6d0d53d560a58399b3e2edd8ed7a5ce3f5fda6644556f81f0e2f31854616ede53edbc9a28853b5b7554956fdc598e4a4d52c238179c016ee93780a12c115d8ad35371184ab574a349a1441ce81dde41bf0f1db3417b3dd255d008c04fcfbc7874cfa689975b77ad3b7c88a94bfcfdc31b2b8b54df00fdd76d3741fd2020dabb3041eff3ee456fac49b5cb16e205f7b6578b2aec0add9ddad9a1e97c2474b36d7f95f1c0ea4f20194053c921521e9718327e42983042e4daa3f522150cc0436013389b47dcbd6d03d2091e92b493c9b0b1c3735aa65fd8a4101c4ab8aacfd223da595ccab27667c794db440bae2843372af4c35574c2aa8cac6d714fdd2127e3ff99e5437ce4fdd6cd362280cd8ecd785aa227fdbebc6649e131f2af70525d1a7a08adee87e6c0dfe25cbc40d55ba57c9e256fe1f38666a5bec9e5c3336a20a735d1e8726b928da72cfb0d9f07dfb81690f220fb04ae28a005a5a2e6ad9ee9d440df2ded7cd8065b2dce6aa84da6142aad4ad6b143d35fbc7193a5ed97f860aadec5baa489e55bc64548fca64959a5a0769819847bdec907826a141ad27ad19f411ef596680c66725bf4acc514e018f2f05393cf25258b87833ddbcd82e38b65317e0ce88c3400851e11c716848eb23515c0d27d2faeec067804f411223c2094dee24b7757dea58652c52a732fe4a120850046aab09dd639fbd2c54a259b66a0b729b7e325a5648da64c21ec183e1c5a59cd8c2faf8e499bc111ef5adcf2b26fd22e8a294614fc940209e8336f4ff9b41cfbd96b6ed47e2c07bca5946fe9505712129ad38ceb2d6c94068c4bb47cf24c90444309ba23ce4706ae6be1add995ee1fcf484e902f890b9dd3f40ae97783ffa0b9b52f352d93d66a5686e38ac312cea4de9f0d65e9c4028bea7d9bcf94b35b28587316ce2b83af6deaec3aa1e1f37c47331d63be21049b958db7bb79ac815a449eb8a1da8b83ed9de04f49c2ce7d4661233a89c415daeea47b96faa00b38576e09f05e590a8a6a3d7b21b8d38b52dc5e4a02a9b50acaaabcbcedf66410ef6cbe5e06e0553ebd68cc40f898f0919fccf95f200fba28532fbb0102be8ed2beb7ed8fdf1436ca697e78ec6f1202206dca28dd86a51bc43582f7840232ef4042d98d585d30790498c65c3733a1b2efbf57d208365616ee6d2043d4da59c3a915ab2c7bb08bff17cf82264c22c11144c4d4f7a4976b7bcd2335db08d3aea1a55377cdaa0cf5c2df005f0b1c939e17be1f2ae08d43a9738435e7373dc26f45aa7b65b059b0aab9efb012f628bc9388b046b9e7a46ba410d8884d0c9574dc018f8b03435660152a8cc2acf257612083e33f44d9122a2c809accc577301f8ea2cf4f91335bb978cc61838ecc8125d368d2e884a1448592c4fbb662f468775cff94317e4d975e3d0e0a64c2cd230eb3dc3c3fa0088b868738c971918b2a174a0674ea60c25105ff4a88280c816f0e3929d996ba18f254ff8b80e931ced362b7b39ae51a115025dde1b0d78fa7f82dc81b3928cb5d2eeb63be0cf686923de88de051460dc761c95c05f8c246e59ad132b0a437f5ddd478b4b68025f177158dbdcadc2e004cc55a872a4126e14cf6447998ad45075909ed987fe971327b5eca25d4355182e55d10ed21660fccf4ef9cf322bd589bdbb7ebcc4dcd13a2953e39fc0ed88779e03f71e59bfd1fc899a5826b2cc9793e436ec65770093dfd0458157635dc7d019c732089a1129c8c0d1928f125f24bf26d992b43345ec92166f18c96dfb2827ab30771e84922e48ebc9a8c776a706209a49b337ab0dbb0ab04e908d669fd3293587133ed263def6e48dfdef3bcfffa3774ce9585f599e66ebb037743d723e3c66e47cbbad5eb4e0a6ed41faa51fe0c2bfcd3c2ab3e8a87f2e336d2bae5e8880443aee00efeda98d78bc031106e160465271c52d26df5de1b8cc7a85fcbe01a95fd01f7ba0b45383c6496ea28db898a5f2fcec6c2541f3e49e91194de37501f2e2739294f4cfa8c7c596e5ddf22b66c39d9ba9d776d37dc3f5062e811e62dac26539d6a82019c9d9902c8ed0a788983173f6b237d8306c58b9bb811dad0a030a3c64baa744565e7e0de23868e8c4cd14a5d3c79acf434951622de9a3f09dd5dc3ff66376fbecabada1f68b42f676c6b3c008006f5ee66cf2138782bcc87f91257c180c10741f7b7a2a74a115fe6cb2458245d24c5924b14044aefca83aa28fb2d95f268d4ca61dfef9e52f9fdbe5bbbb4c40a043a24e205149449990d3fe744db1a94f0c7888c9c9f9b7d4cb826ad9c4c5921365d4227900c033ee3ffd74abb59f8a645cec6a18e69a9667820fa865518ef30182940903ca1768655e8838191faa46f862fd01160f40a056d73df096f8e7527cb3d50c8bb54fe679260d08581193960845310904f8203e9ff68b7604ef1ce0ec59ca0adfdca3c8e9f39b8fddc1c4e8ef99817de8d24cae5c9ea34b552fc505afd2e1a5fd9f56b990debf5a8a1f39375dd330975deb79c2b7e87e75c923ae39f4199342c363354b4e457deea4a15aa018590c1fae315e4804a95917b9c98049c7991ccae53f52da313bfac0894a06541a0d7df3f3765052d2d4c9f4b8419937e314ba9241941595c054003158f082078da2d96ae463910c5f6abdc034fac2c98bde69585ebb794dbe86d724e1610f24a4e0772900bfa038ee64cc30766923c334df6980d93c7fa47fc03b8176aa850d45665bd73c18839ac62046b20b541ad9062519554ebd672e92268094be24aa558237b0dc2a3922a944e6de036d64f300a3d7955cf274773ca8b0d0e4aef7ba1312c7e42e9dfa58d00cbc57d2c161791a940c76267e9d1723bb43e623c48330111272ca1e875df21e059af28606add4d943543b154eb1f9cfb5d2aeceb6f6009103e1d56ed076b85d175a14a096236c1f76276b734fbdbf98de0a8f1f5e404d0830efd7e50e1f49c879b1fd0e51fc72413ff5be90835edef8912d10f83c400d7b4d3ffe408eff7efec71ea296be33fc4d938c7594ee6d86b6d89f8c6f149c4aaa0739c820286d37b19d279b9ce10cd47de20a674820c906d24847809205fa8cc5ac9f749fef03ba35cb723564a6225d8da42d20f51ec3f477bf531897c04e3c710586e28cda0f57c7a271a351ec99d2df6a89f96b85f03324762244fa6d5b245d8deedd585e1793f917d7f0af9c20a62ea79ff51e59ff30ffc8d477e88ab85df60a22766f9377d3ceb892835ba5bcd9ed7c1cf16212c39e8cf602770eef62fea21d3177425733369c0d4166e417ac5e889dad1ba2e68fdb32fc6f5543032ff861f3a97607fcecfd1c3be560d34531b4f5b34ad483b2f20fae197abb6baf77778dc9bbddfd0cfb2035b437cc38a04b2c8ed0933e560a07225191f502e3b9dfb9408b00e79d99a788c43d6786331bb3603fc5b8cce80591f9d55dc34c1a796e7ce14d62a9763cfb906d238063b605c64194693ac9d15b00aad23523a98ead594abc4179489b56ce2b0fe20b1cdfd559ea32121ef21e55b6b62b4b232c40c0d00e2320d3db9826d9cd7172b481a02e5f823caaa289bf3621cf74e0e878c090544c6693af543427cf8f88093d86b74d1804725a29672f0a0ebb671d0f8c66d7bab6bdbb5c7fcf7f518e2ed9f8b2907ad6fef16757bb05e438c894cd54744c05e2098bbf99bd10bfb72a6fa2fd6c726bd4b05316ce0480febb88909ade087ff1ff701be344ce7b68ece8c722bf88ede2e2e4ded42822a84dc8c55a6e48fda1c0a5a281ff6af6b4e55a3008c05bcd8e87180096057061c9937db12dd2d51eab24b9e3cd312dfeef114daa0fe7405657bd94c13d54fd90671f64a268ece82a8dea2e3147bbb520f9b623f85e5a795ffa85d8b137e1572e881009e38ac5fbeb04781fedd3919ffced0b9a0f2ebedd11b5618b45673509e0ac7aa51a694598eb76de61650a8ab30aaa7ec059868cd1385ef623af55a4732b5ceca801a637db747127d6678a8f3853ed5bf06827bf7ce0991c736ac830ae1101565d1a24d16dbe995a19cc99f3b7fd0f51db00a863acd581fa24ddec03cac5287e47fe45986b57928db66dcf1fcf684c23a5a79dda3dd781e63d98848e5e0c0f03d0ebaf816598dc62497fc36138c5125a2d491fe9a869d38b937dccf9673b199c69d4c66a5361a60a6f4b9936f2e059973ef8b840edf61006c6b221208c066e3161e6e54f8b557a0f262140e447a3a26ab7b52f1cbc9c96a7ffcda2c781524cc4a429796016e307fdb8e00fcab35025e4bce5a7441da009f687b0b7fdf381e84745a7e78ea851db68e7afaf4fe6329e89b65ccc9cf20c315aa10705fcb17a37d0864c4c69178cc458b19be5d3caded07672d52ee721cf242ca601dc3336b6191df4dc4db35c7432244624c6b44500c72900ecfcb1a1be8733c6aaca2366df2bbebd1b6c041fc907f8b5bd67227e8ac28a0dd39f9e1c9476f74a2004950bda87892ed5bed3811a4ef82bc1cb40cb5c28d6bf135a20ce3a2174aa26c426dd9606cf590dcec5ba88493840f782669f193589a34e675dfefb447b5035f2e9fb67b3f7341078dd0cf66fb3a14c286b6d847edd9b309e0ee6679f8c8ee0274a25bc4c8f702ae3fd972b407032598383e3eb5290729591628398f4acc82af6e297b761918ebb8f65b960c48585ecbdd3e1a494bd2e0f7044eb2c671b63c73aaf7fbf275367db7e7955abdd5eab1424d16e0f82fdc53922444cc2531e02f25d1f003aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
