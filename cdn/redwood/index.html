<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95e11cda96814d78cb533cd4c264c789c65bfb21e00771ba7e9fd4b99bd9bdd6c74a99c0e8a51126191087cfafededb789678fdcafba5b5c4e7de584e5eee569f1d86429123c6764ec67b40db1457b11655081e0f32895425435c1815a6cc2e3e8866389e70856d6d0e18454918bc1d2d8e20ac036c3bb6ab3dac540c50c9db75ab7bf303c62d33957c790d28d51d43c085f32d19f0f486a35c9aa6d8620a1dcaf1815963df20fe6a934ae600c0e19988b3d3bf972d49df3f3e616c113573778c7edc99931c8a374276c669130aaf2265b4babb945bcaa50269d372f11bcffa605ccaf802b64487da0caec750e3be79de68f8fa7ea82dc3c7137ac51496b5b4e92fa0ab7885b300abb6c079017167b1f2aa1ac5529388479d9a1cdc9d17298c7388a9ff1fc57888172b1cb7787fbe1c72e8d084db8e82de203cc5ec06a51401babfa3cce14a15ae54c02a9cf12dc653faa23f4f777558cd8e5d3d5ec5a6ac65fe67a360a273a882c3977cf5ddf8db2910cbc0824cebbae72c596a16b63245e4afdaa913c00cc872aeaeeb87e360250a5df957fd3469e792e0d936553133d113f054acdf7e3594c0c37656e2e6416b58a3ddae855b50a4d34a3ac1692b3ce58a48393930814277d1593e57e083b7a0c410fceef547e69e4b961bc9d33f537d29df3f82f45fd8dfdd7899f562c2b9d147ea5731bc0f2b6b73bdf73a6d1243c66d0bb65bf7aa78a510404cd17f0cfba0178e898d9febc335541a7f16902bb226d4f7158a17ea323878237929b11c8f7a8adb013bd8149aff021a663fc3ea66ee7aa7f8f21a70bf43028711e20e56a3a0b4bb1a5c44ffb25cb38e551fe0e4a8caff6948678346f45956f947bf01eb9fc4a02ee259525eee60d55b9c1ddeb5e7cd3f94a2cea54773299a3b04b2825a23d4bc2a7256abb1888ba33ed862270cc0567f0f668651eafbedd14e5d9b1dd149160370cfc969542a49f4a902873686155a50154be746fc62ee64b8b639a7c7abfd8748a2fea84ef6781dd9f79e931fa87713bd89a7e64d0b8f75646e7ab87539edad982034792f22b7169b6043f2ea40d9e91fbd9d22fdb2942ade802936b8158fbc5371e519f00929edce15469b566b98b351f77f39094ceb3bcb0773f8ab49d8994c9cd694e6f450c1a5da18063f68e65b04141b6aaea20685f4c376d94889f33267240250dc708123246f0bbf72d637b5939b408f06aa3c7d438b859d7aaa652000147256b814c606b4c3dc99f18dd16483db947fbdc7d147d2be64510ff6dc14cfdfcfc81c37af92453ad43574fee41a6357580e82cd05f17fda2e2ac3d0893e2a4bc1de07bec0679d2d99015c8c10336f1477922a6ca0cd5a7d4d314b4fdb800779d3fc9e6035eac5542bf65b99123e06efeda3d56e78e0d54f3e5587b3429d89a3168d09722115b845d52378a08b8918dcaa34e532061b77fe5d3edc190596ab89407702615c497e4d6ff481e9fd076415d7d55147d7beeb612ac94aa299b64c6188e4e11ec6e7d179fa1a2d70847e4a5278c6a4ebd55ba8716be04de825cde750b1c42ace6ba8e6e47d759038c964e4b3f708a698de67335a741e89523d019093c4c976ed66b7c4fc83099482d686327610788dfcbf53fe710c61554d9d79127cc882059bbbf5362557035aca563d75287478c46d72e16ecc0fcdc45cd971e233862956490d7d0eda0b0e1664728aa2296819bc4733a108b47e531f220c0fae301932e43e5173648edd3e2d13efa8598b5f67e1f29ba3f36efe3f12990d145f4449a5074f93eb4fdb910ca936cf6995073966c7879fe6af15faa2b9533d9d9044d103e4f6080a8b31ea3bb99b53f74cf4b382386cdc9e027b632d89f00d267cc436423ad81c7b0bc1f50458ce00b34c56787f49075cc97957a373d21cbc7ea56d66415666aa74bfece45749b0645d0f853856813bfca131febac3148eee29669c9eedc0270bce699d55dd55156ce75c182910083abb4aca0a77ed20fbad2cf2effff604ce5cf2f76c652ff521ce9ede0241cfed8c50db335609517d57b0a34cd12f5dae2cb31c8f2ddc1481ae26e72e3b150908146959f5261443160e1c23e02ee0328e40c54da5221958708bd2837e3c3fc183228a499fe22b21fea61177d612f07108f225792a9087fd4434f992c20888ac5e94ac2eeb3fb0d0863d0b88c6654e854a5fb082eb2025093f30669aff5732a97fa326a28510eecef6a5850b762c21fe250a50696c2ef51e943ea75acb667bfca5dcd28cf12572e5323b9f4db64735d510cebdb8f8c0ce01d8211c1768539b11c03f244ef32a3ae38f50b49ab2945b05f51708d4dee480183a599863fe9c942dd910b6d7cf8795d31e508d6eb40cef029e6ae465807f35c7bc0175d7710d834be2103aa098d2c8da87cf3d4e34949f4db31438ab069f3acbaa7502aa6402f791da03797ecfbdb5a5331edb41da9285b7bda0ee4c569464196f4759f4f6f5d8c6c43efab87e1f2e8fe35acad1e1bd22eafaf8dcf84940c5aa1d0192b45fbf2c9db784f30b643147dc01b79cd50fd8248eeaa674f12010dff0807c227afe918cb6d8d24e2aa3e720e5e969411861f326fa7d17986f24efb6d6705e0aaf538e6551845d4cf2ca2595375669c5663c4b7e17269333710a10c500db505b4f264590ded59a9a700f53942304648eb80aa6bfaa76a5ae7d814e620e45ab1cb929cf6a18866f8be069980eb3c782d24160019b4b54c40aec126c05a8f23dd7892948838239362e16ac8a496d10604e70550f5c6a77e75269e336ebf42039c27c9999e9a7513c344f3c0bb927d035d12a9e2025ec767eb2e764905c898ebaae671a211073223eac3a2d76eb89933af6d2945bed2920032fd0560c6a13e772a1785e444691b9d0723a93d287f217eda817fb7e818d5c7e0b5a3667aa72c0cb2b08d6279c8e012f16afa52590a5ca695a16286e89798180a18ab625708e7d7e7dfff0b967405993aa5bce76ea99329a8e79cbdd96904abc322de2f3b6a4651a583383e7d9d88127d4bdf28565bf54025ac2b33320703997d5170543a84d47c2ae78b7c01f354404e3880f55301b9444205648616c2b221a6acf06bc30a1c98a6884624165af1b3aaa08525f0a4e092c2e9bc03e603d08f4cd97a45b871105ff600ac6365c733489a8240d6d2523597e23ee4551fc4e0ee28bff89f12c3c549baaead0b4d8b9d2f34186977376006e02c86aa5582c42d420665fba0c741435fb826774f97f49b81127bdfae4cd9ac0908c6cce95dc3ebbb3b43be810ac0b708535691b8f913132fe075752cd53bbacb486ba81b8789a7436cd2fa79a77c9f2647a9de57705c1d0f8bcdd84f76531f0e1b88fa1a85e63451cf8e5c1c2ed490c54deeb946ddb303874e78f16b440bb644b7a0d67131a55a9c443b0f306b549f944d254bb1c7c4c192f28add91a15905a225210746609c3b933861e2c2a164bb28488f733f18797903e0b289d2c6f63458da90383d04340b7ee093cbe1a7f5f38f7ef9326c4735cf86f7d858f91ce368dbd5ab1c862bf5ff8e794f458feecf054acf825348552840a961b93bbcc72e05dc76047e3e2dfc213d4b711a5420d9a041bab2f031265966ead2331de64446d3e7f7c1164a69fef47768b04fdb53a255d88a778014e995ab00b7f252941f4f9066eee53cc91fb90fbf80b7a643122b9486a96eae5e65c55e1c2fe7148335fd9d136b824ba5c2eb9e05415a6f9e1172908597af99e8e23ed3c82b7a6183ff356157859a830ba57db16c714da7b6b91f869cb3fcc52617dcd7551f1fb0ab357d0d5073cfe639b8b7714b9cb7d4fc556b3181ae68180165b548a601b25b6795b51973f5f6498ec34a944ee6090dd7851fddedfc5dfdba8672f773bc86f5b4dc0189f8134d24dafd2d1756cb3e2b8047404086f5efaccbc018e204960275cd2d44e8168c357fc3667d4a2094584eabcb516b77ae485c3dcbc401026fdcf671bb462a769d51490cd4ebe6a7d15bd88882150a20cee568e7f428eac4f6bc4cf59acb7ac1b1f6911d209c81409c1fdd383748782855ff20b35b14b49d79e7ccaf844247677afb790970fa7da789a254eecb37f9d904cec3facf059a2590bfb224061770d63587d7dc7d87624831dae3c2a394e393c454dda16194fc7cc12b415850bd9d1197cb33daa0cecd82980c456f1fa2064ef1c298b8d5b4622d47863f275956b3dbea859a4fbe6caa9495972d4f80eaf5ffa5cf163190867193caf6edb7e630ad5ad2797afc6216f3e5398f6d94ed184411437049e0451a6d70f4f591980bbcb6949dc3b99eececd45be946ea6561acf7fb838dff92db643ce022c3226d20824ca0ee1ea2093710b9186ce1b8695e6322cd6847319adea3a0b07fd495c888de0b5d8243cea6c0ec7a3db8742f7b1b68cfa0dab0543453298d7335922ae9366c398ebf4ae3e8488b18547c08d11a0afd1a455f826f8396edc752c5a45275a5a4ffcc2935ede311b9de026db408b6f2c95118bab59bf12184f0efc07a4e1ea8850407ee61d7c62c8afb7ea774c9e82a20c926cd2f2c5b9a999a2350491585c3e8c25994522e2f85a75293e883d1075313bd2be7d0a23ff0cb008e8321da13ddc013847a2873edbb31c7b4c7f46bb44fa29168b7168bb38d9db99d8fa4d02e9d39d93b4cf8305c607764a6f957b347dec49001ba71cbaac690b1596eed5e795e3c605f465c66c4e2cb7f6c2782bf8c94c5bf439dab72b955dc50fd2af3c16cdd6fb2ea693609d0c61e2c18bcfbd1a4991bf9daa255a120fcba806a3d724a00caa8c5ee28a45ddef806ef846b42639e302a2b996a38c95cdb6b85a585a545c65ebd38b5e375e21017f9e0ec98f79affa6f05d12f6925d3fe260e7afff3674e744a13f14c91c6bd8cef77e9f9fb37f3d1a7f0056a720460d929668093e7a3322c3debd07e4c86af677be78d1083404d66c52deb592d8d307cb64b5bfa8475d82a64e6a14c62ef7ce34a24decbf29a860a54e9168189efcbb208df20fd5c2acf91def885035122498318a1afa81f0705232c14d0259557c7832fb945c031c324e224892963ac0da7e6cbc4b5eee645a82ccf5c034315abf742ae4868579ace7d45a6e2a994cf012ef14cd5ca330171b577a54422c068708a4fddc80f849c40e85741b76d5f5b1ac13a7d53ab57b59b17d21953241715fa1b79751b222b296bbeceec6d7bdee0196f7ca93b7c30e3bfc6ce769e67bddbd509825bf20b8736093370777ae8285b671952c6945dfb737144f2d9496bfe448c8174869c4f866a17a21d4c1bf840f039247032ef2891c7bd39a49472ef55ea9baa58f93e751de3eab8d7776bde85205bfdd5b4bf1594ade7b27cb789b7f24ea2f09dfef73174e96f2907851d21c0db6559513be931a00bcdd7e3abc429e4f33301cd3e9fe8d49c4c93eba12cc6fd6156fcf94a265c07a3fb78c225e94684857d017f9e68bcd47dc2096fa3373b755aaeb0616f75892ed61549219615319507eea32d50b21726f6e0b8afc41c3f4e10d8b5564dd44526f2b5d3e8e712a041160118acdc860a1e499b9c3b3fdf041f72569f211910a2769d2e17f9391c1a73de825688d1b198bf68f02eed913df3eb247a0e23eb0e887491d1e28f8f47ce78cb4d87646584f28b383bc028c4e67df24304186967a6f8e83e3ae9b2400d67ea5570a70da6d7bb1a7dbf72fa6256e861e9c898806b40c2425c63edabf2c2e59f761f4560b1cd03b0fd31e2b98a0eb27eb7622af723c2f147e0f28bc380104590114045b8a83230f50d499c14216824e0b8bcc8232d050d7952de70624522043eb9ef21a69d1cb487f04c3a56252c59b477e55f6aa8c0ea2fc97acdd7cc0dae3454f85ea05ac4bb7e8724322317950a23c106f0d12385615b5e9a18de77e56de298ab0c0594a8cd3e997753d240af33c8053caca35e80c38656ed4fe1e29a2da9f1526e0b3af1e90f8c4a3975c4c32b5fbb2237c694fe3e6b4b66d6b5ea30408b63609259c5c7400b2047b36a55122576360631e6ae7051859611b34e91d50d01a208cf633018fd2fe6aa8c2ceb74be2a5212d50a5ae7998dfc2be80d56094780e6811b1e76d9c6c7bc8c4af75798a4716fd922863b5f48983918850d8c5678828db933ded4da7b9fff94fb9b6601714e3f052511c198d39cda021804d878d620b5d7854b16029ffaf9c5f616ccc2b928ad7eb9562d31b297118f77d31709091c1a6544761ff4b4bd5675d16a219ec13c01ed62ebb597a3f7f4899215fdce091de7210e8a6094e75a35f27def586bcff135bd7b15ee325ff0602ab2f79c968736c5c8b8e1d7f3c686aecb94cd16da13782623a14838f5c141ff36103b6078c53f50155968c903dcb41b33d33b76a406056a5e05fe030a5c04ccf2d9c776bdf58ee7dc5f13491ec36a11a033ecfe30eb312fd327483bd64e9ed390f7c581ca1ab9514b91910af1285aeadddb7b6879cbdf8e24fb6b76cf059326761dfc94c83258eef658c7197c8e586c38e1afd0c42cb5a51d90b74317478abe4412a88424376792a8eaf36089b02e212c420a9a07532ecda237a5be2c30c592d13098145b05b9b7cab2e1435065f576d2e9db9c5b30ddaab2daa7486b5114e9d86dcd8f302da3d42660be2e91ef140bbcc6809169b374c9aa379a5a9c7bf196bb0829cdca5f0f32b7afae7161d2f1953af2e43a224106d955dc5ec33c6276d92dcb9cbdb714d465fbcb06196945749e6e4b42b4e0c8399e5888ba0aead4e8a893ce09adab9f48322429eb58964b738b06112a29ea5fde6b1f62bef877f0ebc65cf7923e7f07481e6a426fb993e3d62697aab18def1ff536d5d3d85a8bdf17f92f7b32d48ea9fcf55dd166be822dade2023f6ae2b4920449a7168d626dc1c76261caf56386c5c995442a64968505b07403ed61600d7aeb1d1d12c50cd315e367ff2fdcc9b63cdb126b9354023471cf522943c73e5e2e010f2e19ea8e38313bd2e3ec7232ec553519c4ae88a58084043aa39832d70dbcfb12882d74279a4778c52a52e5deb3b76f0c3750a06ac6e0acdf3dc226946ff22cf451b26ed82e393d8b2b5645f7a1744e4b7e4f109f301cf2d2877672792b3565aa40a06ab0cd1df51f0c1be2e383e9fcc841997e19c2d4aa7dd432acd5f8667cb01a641a0559e0f41372e32111f246797d295c65a389d33a088ba6eecd1088dfb5e765baa4f7e5d43554f7bdce8c0db2cc58c28027993f3ad546727fbad3c278008fb9b353bd043847e93491c185abf12d81b6af6137947e702e0f0b7f01ae1a0def06c783d6dc5d50ea90f7a944b8f9a1e41e0b404ef250d7d75bb244897eb72b5946bc0e3f046752bc765231075684a708e1bc0f80e2656de52dc26f4826731e3fb047350bf931c65991b518a395944ab05e1cd4ba35fb8b690f28bfbb133700685ed775164a950da9ea0cd2e5b7360671630ed8cc9bba272f6798065543e4d11d5e829696797a1836e368e1704711dc9a06530d37f123c03547fc1f27f2a5a16fa12bb2c13819bcc55c1e1f5e004ac454272043fbfa05b5e41f1f0ea5d4d4d31c0c5d9fda59db8c48a46b8d31f6fb108bc3b037f86e8ffb87fb43504d7a57c91c8a74a9a9a1e823c9921901d5a9835a9af527faf6be1b120533bc3cdddc34aa5952e56aba79f4db2a7f4568b3276708102a54ac8d2a85a8e7216bcaea5336116e55c6eb28f4f9a3d1fdea882e512f0e1ce17d3c4c06fc07888a17dce5fe14bcd3780f470e28acbe708420b97e9f7854256f0dd1e9cf1ffed3632da66adf8fc7817dafcf0f031fc40f80374339d6f963b81afd72eb6bbf8dbbf53f6f74e35b01fc03336c17157817bd0abfcc29c8ba9448e2dcd85298405a6773313fa8e0973ef4942a21c3d1bec28cdfd0241f3445fb3c97acf457badb6572a132061c13ddee2da49603a3520cba8defba48add5fd3fc6f24ab541bf7da3e3f2710ff26f084b43922b7a52874f6cfb91b46605d9f650edd1b8b6424a1082c6ca1f6f3f35f0d0614cb7155c6b72852066d1068c03f5b40474603e3af5148fc42e38962ef6bcc5ad89a34767cc9508c4b26f35ce3633f370e33793bd60d5f7cd0468f6bf0de241d374f4b804bbbb6563cf3cc6b5ef5f834c952dcec1d73edb1b63e8b8fc40bd4042a35143d473b08d5ef23e7262324a7261e1ee141ba7bd5295915f6a1af898c26e2c847b2d916ab53807b070714ffa766d78dc84214256970982c1d5b0aacc5ba66ddc2e98164786663c4587081e0c851572d0a8e295f101c8ac4cedcd454ae93d9d4f5e63c2b146c0d150b4cef7b064e3c24b3f259549801e64a9220309f88540a35f6502c073af647f1fc0008473fb379f0da8a212d13abcff6f8c2729d072b0307fd4484994420e5288e7fecde65b126a79678d7816e92a821cb0b34e24979a3c84d448ba26afb4cff1e51df2447e3a8cfd6ad42489d666a4a68fbc0d15acdb03f8fdc118c850e5d8e943a3a481a10d0c9b074455aef338fe6577b0114eb3f8f01f207c7a28a75222b5387f0124f1a2b232b23436571cbf1bf6968460686ab222df989cc2321e8ce55e686ed518bf5844ddb39d34b26acbd226ef68f2ee66a5bcb1d44590a3651a747850dce50d1b89ad802f186f73330d8a57d017471ddd6d22c2e0cb6dd9c3fccb6720beb5677808603259f1061df39adb94737e2d016a4a54473797b091af59b95d7c4ec6a31d449c8542559f88966ca1e02c88a863e934a9237a358b91c6a334b42a73ad413db204248e5de8ffc6b45e92394b18864dd56cac5c819d58e5d4c35ddfffb21fbef3c4d81251eda5e9c8719c0f83a312dcba27e544984682dbf9268b171478f72b1e187cb41006c2a835507581f189a0d36541ab8e8d8c41850c2c85a456e502aaecaefda91633206672d84abf3dcd6946cc05df30f5d7948784d3cbeb46d0c6379139587585975464691da7aeb4f62df2c643fed8cd46c9bb07182d72f68befeaeb361d5f4c865329910ffe57334c72cc00a8d12c0ae31dbb19df4cb2ace56178206bd246e482c116874382be31eeacfb63c5c9844cb6d323a74415704940f1146631aa88b2a943e40f06653af2f7d975fe7b9c2abc5387a32448e4b0700f82ced37d0b7f88708a69a7022182fabf760584ace7631133ce41dfdcf0a74aa0102c2e41bd85f2f36a6df2b8a2569a81ef6c450d05d073b4648c041aae69a4b9eab3164fc3ef22ddaf2208f072d9579497c7af8dc9092d92406590d6353f0bc1ca5d9344a440326928739ee3de4a87177a4d89e93827a9668138ceb27b6adaabb4d3512788de5a92cf3a3a4fb553de697605ab1553837d9628d84b263d3cfa40d213923d62183d5fbc014e10fd15ae9f97c0f678fa8332b44f884b4e95683794438b4e2aac395ee0433862a12f9c9b386c396b658bc3d726bad0af4bec62440d7b5ab2a61fbc324e691a763534eaa539f03876bfe9496963a9fd4e0fc234c3b90fd9ab8a6f4cf3a36cb5f76f5557220d3af02d63bc99040ca7aae93e3eda8aeaa8683bf4c1d00858aa5876ae77a8a0aa0e7cda79a97adbe88a53f3da442474142b453664ef7486877f5c20d7ee79c84cdf896defe0881d139f762b897ab4472e0ae6b717885987179efea955b27141e6548d137cadd83d253202fa4b0e7eac925073f5e99bb86e1912d321078c1c1d03499f143b0daad0b1b7e503dbb9f8734718f4826e8975dd1f42c7197fcc360e5584ff228bb821aeb807c3e4f2f6fa5c4312fbe23096005b8cc569cd54036ae2b6b54b12de148a853b7056a999b4ee7cf19cb49827ae06d7c8ac107397fc5d38624c49a3d800115d14f5b699d9aa14c6bd62a2ab5161c937ad0d3b039c98cf438870ee01e386fb89fec563fb1fb393d803b9d17e0fbc05d1afad494c5f793118f0966fb73fbea8f0e41406648c26f8309705e3c579eaf293d6180580cbd88072d9e30482f7e8712c67bf53fc4045bd136d5c6c2610aa842074f3feb2bd8713f9bc5ff5dffa3bd588dabc680a529d6b0f2b6b11c4b0c8f0da0cd5446c63f7d290f85d5aabba16b8c94b59acff802077f4ab6db36433061d8daa8c367d9c5546a38004737fdc228c4cd021f9af810bcaadaafae2bea5c9d69a51f86a8969aa6f665c3baab94ddc90113096e69c6259413c6907bff38c032ccb55a7caff944eb21c09303bfe9fb899319f05619e4e8f5c672602be6aa39d08eff52b5695be9ab2894726545200593b37921f0a1e1ca82ad3c2f06eeca21c7bcd68baf2c7d2247e58f805c71fd950ceafc2ded794076853e6adf7087bbc826cb21999d0cf3f1b98f06a9c5bc8c907577ef9d0459a207f05676bd7055a6048eefcc234b04fe0d48fd3c16115de2133c672bbfc6f3876a4215f21a68c105c53bca99eebe2d46d6778ac00bed5120e5e21212eff3b4307939851da044d6303a6c5fc3dec9f3ded8f893734d7fdac0128337a7e0ad6772d104f166ac4d283a6b4dffb533484edcb2910090a1dbde0c038b0338df352a9bfb2397e1eac8522fa7a49059ab4747ddec6b5c4bc185181fb1174f2a7318c61ff54fa89c742c9ef693d491c7420ed9451ea30b28c2db5978f97783f06b4c4d26cfc14faaf76163e429f1634d8bad26cfe78923c371df94950257b13c66cd5ae1f109e31e18a6b63de361df72928878156c27cf685f66e05702f29a7764d54e55bfb4ba0666b4805d30e70942a9d4370a2750ad1536a2aee3d78c4f90d8f51393370a287a90f7e3ebf6244125eec7eb8e666082c4cc5dfd6ee4055284ffeaadb1202d20d2c8f2dd1da2fa09e2af142d6a552b07b0be8495b7a6cc6060c6136d904f88c35ed74f7170fc4bda091243108bd8a2c2599f7f4f89ff42376210496e7b09ff6e8317392c3b700e24738047768f2e42c756556a7d04493594ebdb1dbeccb593b191dfb492c239f27f2ec07731d33a9c77278651b7166eae77c3ae63aa38aa00b35b596dc33a9de2b1291989e39c5e4538e2d9988f8fbc9569330690d1b6d928b1cf8e64625436c7f94d98e66976e32ef42d7ee16815c34f68f46aafa090c1d2d6fef83f3c9b7efce9f59691ba139908c07c2a4b82675170ea52a4b0077a62beaf4a2e145352dfadf32ccbabfe42cb6ea378e2e8d0b032517772b475db97c76502527bc8a9f47e538bb6bb16b88b0bd1ae7dfc0e8e5b285c40484d15ecacaddc951a9c58150cfdfcb16589e6802f4ace21ea7d5ea32ced33ef850777825345fe0a5e303d9b34df20cdc34c41d01246a614bdca703bd2f03e627d9d2b977415d50e048c1892f84c297b47a4d3383f784ceedade3c10f3033a1d8fa6432a8df2ea6d18aa45d25dbcb5fe830e6af0794dfe7d2f2c706ec6c60ee97542a13339f9512115a9ebf64be422cd675bdb917008028603814ebe3e433f31e2bfadccf25b0852d0c186e0d1952134ea6effa0daab2b2749c7f1a271d2f3a18bb012708626c9c542962567196de08d6aaeaa662cd6d34663e81a0d97ea4308d2ccdff3eb0a5d33c6ed47f9d8703c9e830737939da2f12f411d7222da3214e3f55b5ddc0108bec9903a9278dddc195bb7fe6d9aeb7d6ef729f7e2166799d2c669fb9f16517de0bc237cb06a8e85f3bec59e264860355390049acecaff4121a1c77572558193f78162fc3dabef5b0b45fde51283c60ccfd39e4480d64a2b96619bbf4fa5ebf518eed0160f9848abd98ab100dd5f9fa35c5fd2c92111f44c977000e14d5228af52bf0566844f8504c780d5f69ea896e54e1cceb7e02096d0333bdb5baf6119f135c0a1fcceb87c181c2772e4c5d71013aa08f9ac2e5403984cc4adff7bcdd3449dcef9c71deb8d10213731e2d2ccd6172d6efa5594847eb77c82b20a3fac9f6cdee0ad1032a64f8ad1780cd16a7f9dfc106dd8fd86121653bd1272a528967c5221a510a18a31443338b41600fa0dab41c37bf7782a09dfaca95bcdadaa01f9f5de39d9c5c6098291ea5a3c11ccdaa670863c78bf46edcd8c213aaa9b47d5422a4d692c36011992710748ad949fe3415e314b12ff3fde87e91d95db86dbedb7ba8a0e45a8139ce656642fc79e0d6f798ea29a5d7679396ce0dfbbb6f44086b38bfe8861ba73a3b05973c5969fab21f3a18825079aaf04623563b4dca0f4dc28c9602d8137255a78c9e6233ac74a3eedb83afc8f90677ab6dca8607982dad6bb73dd1fffdf59665145a8ead4943c8422f4d8e0aba918b93fc35bc6756cfc0811736514ab5ff6c9fcfd097afdaac02153c0bf478d7ee207c8ad1ff200793d5e74c0691c7d5d9e78e4e32f43f0c0e3dab2e24e2701350cfad12b53c36854a4d17fab5007f96cf51bdf78e6239df53897bdbebfd7e900ed75c83637cc72d03ca1c664187d7ee8a0ccb47aaf4530d0c8b0cf4364208afaeedb2bfb0e897afed412b91855294e804fcd7996898de73a8eececa75e708ea5a6a785cd11d9a0dbd1dc7f995e3c9c67a278c9059618a1b2f36e6b7990dc2b5964d8333d8e98c3b7aac9f1069ac86bfb325462fde24112dfe1962c1af2cdac4adcc7c2e81a918d4d12711135aa2ce948e84a38220706a342f51892fd02b9d0ae8774fdeee39af46f85e3c71722f2ba788e48f76e07aefa4a4b4ef9c4cf9ddc06865d06e27dda285ae884273561fe6c7ee5b6c0c709a4c72c0d28d7f89a23c78b99f516212b5fa6f19a67449c67b01e5d230522e8a3e6faffacd49a5f63107765d9dd48817780d414cfcb24e5342e759400decc469c27eb3757510ac7687630765869ce3b67ec8b9d3730277881d3c9b7343fa310ae9d1a07c3c54f63d26b68d9f0b9c01abca1ddeb797f470bd9804edf5aef61b86cc36a42cc96f5742da56fa1c976a873bb5e8a0492f406f4d70c715c2b3fcd607d23c36bd6113120dd23c68b68bf4255c009aeea4fa2279d1b6ae0e267d8248e15ce8df7d3ef3cb73fdf392c7e5875f26a633ec354a12de2f48452c291eb4ff67f6e9bc252dec6add52d2d87401f61f44ab0a35ff90bb5ee0c8102fddb3eaf1b99c44e56faa0ae5a0f4105efa0639975d889b206a5ab7156c404b435ee575f73d8be7761f194871e1b0d395a813e6f8e92747bb49d50500a2903dee836e02c6a87cefbaf1e5d3417fd5a339032d78f84a45cc5db7878ef6acad296c6d545fd95505dc988515c9c806ce77072358e2f75c319e404bba3156846f04f7a6431629718de34bcf44e2daf1869d124d50fbb501ffe6140b5637298460c9caa5d7c46311f807c0d00aaec5ae0193db742e039a1e2168bc7f59e7e6b03322a5e90e1ab2af7ccc89b415468b711810442af896eb78a357dbadf5154f18188a0e6ef78cb019bd3a2171d64a7c5a771a711681783be5cda5dd435c1dd7643e410b16558c6eb5b5583d0e15165b54abfff5ffaddf318843a858c26cafb8b3c28d9dafce68713c395c4d0644332a3b32bfc2de59844b078c5dc50debb33defdce907a5a30773c0ea97509b34dac776b3a69339d6d8c52c2a2a1c81136cfcbfe3bde7c2d7cce3e2068852d310729e76e72584694a67260f23f77fa9ded42586b5ec0bb7d3316d0de3147ca305df51fa29d0061f62b93e4c39a4fba8b99ae095a39590dae1c25382de802ce406332b7a01ebc8912ed268ebe2589ed158936c1f94faa9c6d62b61217cdca628eb4fc927a6df8a8f6c20cff322baeffa24fe26bb10e9a8ab16853c65d622e67bda5b061e6e522de40d95baae7f2bdac1d164f1dda6261e13e2e1bc53ca818d703d278c6ddaa88a6844890a6d0dc1b1a98532e1064a23c7c099ca9dbfb2b96d9b473b2240a6715236eb4830de884491bda39e807802f5710c03fc96ac64dc262cb11db1c1ef1ef40ca43cc47aa80a9ec55f514e0edb6a16544a15468a3a0f6f675ba9c4a0441f0bc5f45b7e6fd36722e7eff43643c8719a1b0e5c52a6beefd6e2b89214f20e832a3e59a9dcfc7b4a7864bae0aaefadf505fd4ee95b5324e5be4e53ca1498d351e06ce252d7971bb7c159fc6c96d5d5b27fd13ddae49efad4c7b31b979086b8fce03af2c1bc532158fb23103dfc4648d85bcc22cb8b7724cc7dfa7bed1a3560257a8709a5fd5daee1cca449be9870aa100b1ec01874fe497089c3b19f7bd0729b3f7fe1d9d744d211ef8436a42395d87c392ce2a7c729dde29fd7a71ed9c68cd9ec13cd44760c1e39ffcaac91ec34419673ba7dd643dbd68e92525c48adf45107022a6cbaf5c5f1907b4a172af58d99a11363049edf5d38c229ec1c4acfe617d9c215588175028ee85cd68534500b27f8a77cae75f72694d1345dd699f316e2e30f4a95394b2424dbcb0b61858cfe0bd887fcd2ea207149e64de4a6388532286fb954713b92b0eb5504c34c0cba4582ff6879e04878e9be80e3350849b7607c126e478d9f238d88822553eefef7df4595b80460f343a45db7a9b8da36dd9ee6b75f22b458fd0614ce5dab4e43da21b04b19f669aeaa46e6503e6ed04bcf3fb09b45f33145154ea5c39ee9d0ac6ca29d70587645538f76f626f708841ecc12211680e1b2846d12650b073dba510c303ff00c1a8e9cc6396876530d610618bb0ff1e520f09918abaa665b38d3a3eacf982ff6a080fe6a2a6a69382b21783d376baee18c0625e8f28a44055c9ee6fe8d37dc1a8d02350440ba246fdd0e443bcda38b16135fbfcf72de92b9146d92f6c47449028e030156b900b49b6c6a730dd92f306a2608f016b54c6e825140bdb905a1f3352c29f531f1379accd41250d5bdb0d08add75f6b4381d9e5da13c5385ddaf2d99f804bcc63f5094e8c38f8533a2fc27f2c70bc48798983c1c76a29b23fb80f5023a2c1e5384b7f663c19c31179896a4e5fcf5a7f22125ea29c6d600fe4654291c7b6b1e318afe8d7cf16d4bc3768409d690ecb40832c240d276c064cdd21b04aeebc3fd7ddae435d3cd9749eeacdc6c69c85708fadf8fa279ed51ab10f2bfa421b5b3c04429ecd41020b3350c30a5fee26d287f564f011252f724e955987b5750a0a760d5e72ed0bce0dbc463ff7d0746d751188715810297ed1c0e58914261fc85db8b1dc14482ce7bb011db7abb21ca120d2729138438fd52fd77e926bbe75b7a9e2983c5a19532f9f9bc593ebde85d32fa7b0062d526b3b345fb19a0fb1934613f2d6d8af95261b538e69fabb421e1ee9a079f931ccea7616500f30f50d304f90c3c26a26359538a9cb33663400174784fbcdac121f970d9a8a9ea10cead66dbda5233a3ff70011317c6ed7374899ad258986bc8115a9e55ce7edd85839bc6ae92a23bf7d348b87534a2630babf529ce56adcd2afa0296658a0221dc81d55dc434b85a4a14ae97eb0111558aed0553961ed36ffe8c00b9cec33b995dd95d241ce9122c589ade8b052efae2bc41516d5d874faf3ad85163e50664ff222b15bfb879e6c59cb707e245f4dedf6f9a652dcb69bdb8f0d02595822d7a29037ba465b9f3bb71019897c139b9341cc4f0499af5b71749a40ddd209d8c49ef5617060dabfd77fc1840acb4d92f61e2cee6cc79eda3db50ab575461baaa0dfb1982d05aa5929634e7d3f2e30b44400c5fca74fef28d405927aa3ba12ac371eba1e7bb1aa28c69503da0361a8edf3b5006da4aa76f3e8f12ff86354a5eaec363867dea60d41470adfb7774be06c33aead2ee52aba9217e035d68bf9bef075e396c2b66a008831ac901510471e4591988ec261801d135a47b615ed1d0050217d2e735bacbadc5123b75c47b4de4eee75fc58cada44bc62bc153a46ed86dab2496eba6c9f3c0cae66c54180870f1cb52659b9f199d4db9b9f9227fd1c51d09c2dda3795811a5c2b8562a98e9c8a57debe608bd21c6f95bf39f0baf9f696521ce91bd534babb927230d33903b0733fd8985a39cc17741c12be02940146fd638accd7d509f872909705cc83726d719fadbd75e1768e4d2c3cda8baef8b71944a2673e00383a71fab4d39e8c471b32a6db8af38d3dd8ce2c991f64c3360808369f6557b0d34342392b583f435aa3df9db5c59f0f750d0dd0f95c440a5602bab4e7eec05038a88fc1c26a80926c5e1397f8c0aeb2bcab5a342618b08b099b160488215c2faa517949049c026662399c07746019cb2d6d2cd11a3f639511316976afb292736411b74e3a3a1359ef536f0b6382754471764e86ca249552136ad6e469865a212ae5152c68bcd9014d819489ec39a000fe0de28c57b59eedad49fddb0fb222f76e55caa65b1f55d899af91db1de91a9a09714e9e83b185410fb952ad15647191b1216544e38044ee1079925477ec3a9c46c9260c442d0f3fb5847e19059833a82c0e38e6a30fdcc86a3d27b4265d1e459d39015f3464202792add02605b009c7c1b28ad61f77f2e32f5d58f889d921001ab9951ee2be3b82658083610832336127735015667405778af44e9ac96aeab6f579490a3ca6369fcd74bf66076b1d11934beb1ae71428f32da210b1f3906ac6b000b6d589ed97b88ae840c51faf9d4690f1455b90bc5d052ae6796843320c2f4edad8f9bf5a7bc9a61c4fd4f461ff33ec075837a2f6f63e822fb3bb973b00a18771a272f738fbaa71c89f95fa43c18961e6b1e9885eefac79e568fb8cef46cc5a66d6b2d127cacd77f94ceb7e4fcb37601fd5fa5fe360fc0e9f9230da410eb74dc4309845d14206950e0f19c1b54f58684afa0ca0ce659141c8ac4fbdcd6b69d96566a61abcf84188fe8268182b34030dc715b1c9293a21baf90ceae8027c348110b52a16eb6a970ed24476f5d5612cbdef2f7474f2b7a3f881d96f8071d4d793118a2bb6b622b97afae91c09a6f76a3726f71af385e840eb6e781763b7666ff255f7840be5f12ac2af59b768e320cbb6e9d0b2498d3a368ee5260101cdf01621a67e680a40bdf4e7015c68175cbdb780f0708f5cf696b0338e22662e548806633ae333dfbe0fa84a38435cec5eed8c193adae7329230c0a3c34adaf2da9f48abf0f8a787cde964ad999467eebbe2671b73dc143d8217649d5fc67f6dfddff81869caf73984fee11ff3a8642050a62aa6d9ee8908e03309523049c947028cef828a91077ceb7f7e2b005b78677691b9178cefcb26a0d4be70970e412c77955059daee9a546c9148a46d9929499044121b77f3191407cdf66d4dabccdbfaa3838662a6e5e399a61a10e56f2240b7eee6dbda3de2cc2e9c92eb7354f2c995ff6a719f6947dd6a86b08a7b2fdc0bc9166603a95d1c915ad8815fd87f8917994ea09f660d6ea2a90e0a96a166300ca64560a45c1ec3db68783442906245fa913b1c45197e5f126504fef9185fe9de261160ac594c3664a06c0b6f0709eafbe019fa9969ff30b5bbe7a8566e71b44d0b638cf59b81b4af5712832288e52bbc99db123f4e88fd156accfccceae31ae32d80c077e24fb3ed69a3c5089b6bef958cc2030a3e0b49e964470d9c417fe53fa48297ffd6725c1bd93fbca5375ab95f5b8bb8f13713efd07feee16465708515aaf941df79804ac12f2b95c7dc700f38fa2c82b3abb8815d7e162d19dfff9f995e596e6760dd4687fa4e3c55c5b5adafc0ed6e42d53055315a5a93d39eeff5e7f6694d24da0042867b5c87400e4241dcc5c107264fb635a189d53c3f9dfdee0b6ef38d9b2e1e3a1744eb5b52e25f129da472eb505da26270ad845457f6405328c720a1997634101385407a3c5f49d0163f39ab2a782ff7d8e30d833cbc88731cea81399c56ecfd3b1eb41d5374302510d959eabd46032711d0bd9a658e2226129cf9a75fb35d21751a21e24f01eb18858c4dd07fe32a140048bea033e23bde50aed4519e31deb2e50a3909defa4849f0d8cfc1e9e9dc1cab14301c230042e07d3a70c604dae693fa8a2e74b6f6af4d0192e7adbfe53e1c46c012fa026ebd51752c0c9717b7258581fc8763bd5e64f53e047f09af4509906065670d29887343f96c16d1eddea23a484dfe113aa02a5479d64cf175bb70691e9008757ec1f9db335fff26e3e4117f0092","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
