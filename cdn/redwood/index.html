<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7784ea24e55a48d87b63c1ce949109d20736e5adaa4b5f0585e202d566e80bfc0730c7ddc6b5e57cb3de47ff4a19a364d1cfd50d3d05fbdfc180f2074ca9595397140db2c1cc217a1524988b21ae5bef4b16a5f9409819ca2eb92490f43b7acae14e4cd47b59f83049699b2b99a451528ffc6fd92a2f97123a54d9f868d1d6eff8c4926f0edf551f43247eb0a68c5aec88e39fedb85843575606f2d67ad66fa2b1023cad7d711a107d5347b07cf8fdf585f0b0b4a7f001f84945379edfc027492c92881a22db30015623a7a5c59cb5ad27bc2138778a68d9a86387dfb67b601558062a5578ad7a6b5bc79fa3cc2d9f8ce3f4882640258313b0d04fff7d10f1c72dd549c04ac32297c314113fc794ec8dcec0c52cc806ae4dab5a7ed911321a9095f8ed5944f1874afa864af553b817ed0d46774c33f5460a613a200c714a0f9a3287dda7508a46a6514c53e0623f7f14604577e275c76e0fccea705a932b46e049dff9b655e21af20124b29b27e2317bab5689d55bf30d71d5123dbbfe8237dd18425a73b584202f6b785de67d389b4567520fe6f9ffe8b25e38cceaaca18c995261b6b49977f4392726e095af557a4faa6b23106ef573df5fcd16b9f752f55f2dc120755874b429b96f9b330d28feff39343b1dfc18f43cbe21e0509f8171167a5af0e2f0e338be6c9d5413d915fce5b6fd084d977f9790e99ba9511b71c011fa2b48a079d85ec04a60a3f46136615113c9a98cb8d7859b68da04fd8be1959564281a47cc08e49547270fa44570124c373b717fef3852497baf71d11bbe8eee6b7fecd3dce80d8a02ee46b89b6b69a74ded2240e864edc1a5df7465fe9adb105a66a6d28fc3146ad63a86243d5cdc69ca1aee6b6a18c72d934c9daaa9c66b88d22b0a3f7ea7588fc50b9652626a601b8f2014e9ab3ad8b7d91751b29e908c126afdb3d89b97dfee151efaaae5a2cf41dd572c437098ddfc8c74daec2223bbe86672d384ebc13c9c3e0445c14f03f82467c8e2a30d16900f0318f59fdc372e616829fc0c58b85d35d827f817408904bb9f3102a7adb13b4974e100091654a8d5366e5a45208fc33e7d7d9dab43daec91641b0911265ee1aef00f6699580b1a93cb657791b897c61af13704116b872db018094b3241eb86e74942073c2b7ef2628451c0568bde45d85c621a35a8a251865254fa8cf21a114f1fb427440301e92a338db7ef748de67daa4a0684017d9a509cb052fa8640893cc9f42912218d1b0e31e45f20ee88f360bf76da208414e5406e04dca69aaef0c37162ed06dbf4e5f6fe4f4cf90a43c39206dfe95624b67f3e86636aac58cf73ef9d6965e4a1127e1825d449e3b891348f84390e67f04cfa76e732ea03579b0e7b96412644b76592840b6b767dbc69bb4747b962b39a5419a86285eb7aa7cc88019f4d82cde7b013772eabcd79a4148f7999396d755a6280b5448c92cd82c4107a048ca1a69eb826a88b9212249472cb7d1cf9d64bc64471c5619a651117c6d379aea4bc509fcaf82d839b233e9f3d90c4909179c5943e5d4496a25befbc3dffc28bc1fc6a741d3460b017eb9ff22362641ac596fa038e4fd625c81a852ed577596c9dbe2fbd72f85f56fc144324122e7fced3d4c918ee44a8055cd3de4b5cd83d3222246a182126d1c1df688930ce4918981f20114c5bb557e5bc6d18aef0c7e7e5fce376f780a97d0c2bbb9082c17b6aa9b5ed4aed9717beea43d0eec7106a54f95531269512eeb3273af64881fc8a7a540fbdcb6d018173a2ea598c317574b9fb89696e34aa2aa7da964f4ad03596d5411c8ece992c4c5d305762c47ef4e539a545f6fdd2d246e53abc9a3b486f9e5ab7ad2017ab7756c4da7722dc3d939498331f5af2ade5ff281e404450e02cccacdf62380affdc8fbc1b5e75f51526f77eee71de428250cac5c287e71add386fda0da934f9c2c86d14a91150819661b235117136a426ac22086a52385117258776ac4e3246047593d10dd9ba0a4058a9267e59a77d20bad49f835732b740871c23b7dacf324eeb9fb4ce711c4253a59b0fc5ed324fae1aa3c60b287f2032d822626ac505569ac2d630e16b3a98d8da8d340181f74058f6c8ccd1bb3068700ef21222c24ee84502f33c70b5d121b31ff166b82b11dc368b1ed09722f2e1ca7e73af112f31b239474bbc1bb0c016e8a74fc7ead3daa35cea9b87301a662ba19c1be9256e93da2b6d6a30b12f215caccd15f41e5c2d2ff19ae4bf714814d14c43e34f17738ea1b7a1429a71dfd32ae5297037fe5cbad3c2ece8b84a3dafacac54749e6a0710017aa572df5108c17776659febf7833a9382ec825c056c31fdc68cbb6bee507cfebcffcffc266562de45c24f56cbf0130266a7ac5b177085bf8b035c67a661baa10e7bff247979ba17b1179d29270ae99ab27a0336899e77b5f9bfcb21e882bee4364d04d7a546162bcc9894f526c65896ab25f81d8414d0271b9efde73b43cc1cfc2e33dadfcecd35a90b3b30a21fa8995b6f3cc82735e65059efb1f15103841f87b873c5fe0f706d773f77f246085e07ad346b4db02a1399c10597cfbcaab97813da7d2fe8c76b6690e69ee1090a93ef9d93de3268c2181fa067b44a5aa2ef986bcd4b91f0a239bc7353a4a0e2ff0ac43ae32f0f27dc538e311aa77a09d5072470d42c8e16f52d563298a7db3df7ef9d5546706697d3375c0c3162b3b854418bf153623f0e70d0a1787329ccd2f3c4139f749f36f940894ccccdeadca479304bd37490cc03a0a193efca9b6d4b2312f66d10d66c143edf8943e28606add7dc95f1995aa1789f7ab7fe5db8acd95661cd1050d98f0343857544388f1fb7a32e4a1bf3a0ab9e67678e8e6a3754922149d33bc91916d262e9313287caed7686f28d1c5b71608d95e439abafba24d98b51a6f463eb5f977320373803d90cea050580bbd8de21176d093446bd9c4f9805924d65027a6235f66f982c7fefa2f8665e0c295159fc316d74b9f4b04066a6fc99db3f3623c5426d439e4005a74b4cddab3a2a96a609bb46031ad3a843ec87af1c30293f2c52611b83fe8670fcd56e1824d1014344845d539234b3eab0b04f32274b30c0234f997dc98e05a865b95e4546dfa72890bbac0e67690131430d510e9bf08e1e9b47ffc005e14df2d565dcd9c0f80d61cddd843c6cd8a7a5774b7005fc3f7ad4df82748105baa5b5d62b913fc505b6ef5bc2f864b12c1e5fba681d998ab26d34463b3f96a708667beb56493032f7f84a830af3f2ebac49ee2407238c97adcabc8fa685bb24358ec4220f81c1e4fbcca3cdf2061efc7e720149503698724fd794af5b8cfb2fde47cd06cd3c71fbd9b08d2eb573c87a9622352aebb080c8ca9695f305acf3609ef57c1ae1f99b02c085ed2d5161908498a8d8babd25e5e8f7dd8d4ccb6b04a825cef31e35742e5ed03d2f5f0167bcd5349113dde5d9e6825e31a2d15fb026848734a65708cfffa34683f9094250e5532b9f14aef9c5eb50cfd3faedfdc9d1ff5d792f6f05265ffb26fc45bedb5d98f5e34ad83d5d8b6785b692d5f2d9dce9e8336bfa16905c67fd339f8dd5e0ba28e2f616540a290986c4ddaf261bc3246723cc1cd71055cfdc8b00237ab615fc18c368ce21490af86cc48507b9b5df7150a556977904df255fe39919bbe8ab9f3ddf71b7a46c00aec88fd5198f70eb0ef53e42756239ed19655342f4fa0d592d18ba134151eee4027a1052fca150f16d9fab3a1fa52b6ea939a534dfdee9454baff1672c986dd2ec7655b9f283fcfde69b51bee72c1d23213e7fbb5409ad96a89b49142ff5fda1295d7fb462638e583d81da191b87cf4d5dd600132ffafc61bedd10f1cb0b3385eb3ff21951e155bb7b4029ed2bad25129a3de5bea8cf616d632411507400af5a7b3d19f3ba90583485a3a3655eeadc5edf78c11833434e899ab43d9fa8840c75f3d290f5c52635869533f83d4fa560c59dae878138efaec3b1d7beed21a2288de6d3a2581d11c6eca20a6c6ecd8145e181ff5ecb970359b4e1a56cbc795054bc0e150f5f28044a3e11c810c05fbecf4507a968815f7cddff2553727bbbd5279226c1e9ac881971ee3f07804d92f352e988ec444ca8aa35277664cfd7223fb96101691004bb72b1822d9763b2ea51206d890a3819b22e4512c5aa9344e246374f590a9a3999c2af11541917231c0f1bfea41286846efa4b54b22a74474eaec997281cd1421200ca594c6d73bac22e976c5394023b6bd9f8146140cf7af3c75dd882b513a3c2d941895ce2196b2c200a887fc4a9620b24766c799a75e78e6a9d2e361c28a68d97816172b33ef84fbd8bb33fc1cabb339904881e3bc175dc28dc72ecc2d32b27e0ad7a83a28d1cc674da7e4049d1a84305db407bdec4dc30d3c1393856d21e0a9601a3224bd0d590fa29c6cacd455c7874ef558047d4e68569b7a2d411e2b9997fcc4067ba53de88460397b3ebbde01b60198691ea876cba17449ffacc94db5f942676b43fb89a294f3f0212ef47aa605a43ae2981864a3b316cebc14b1f29c2057585a3cf51ec66756f6c9ebef7d40ebee7c9f0ffca89d603cbb19d988bac8d1e7da560510497ab175cd59b4b3e75153051d9bc9cfec50a913f5026ccd536a7a4fccfbe489c2008f9ebfe9f73b53882071db0ed24d7b4eacede94e2adfc50583e28e0d7c930b62fc5a714ed186381140c97f8784361dbb531f13864807012408faa133aa9908b0bb94234e3a681d03ff4fb989038ae4a164ee0b8744237677a3d6dda9887b123391d7a7ae59c7e8db93255b9a83e39beb3d8cdcdd85e154187fe6fdbf894cfd1af022d9eead6de97319ba2639e1db7be52a81fdd4a245214a326ab9127cd9cceba90a091d42efb69c15a26ffe3ebc4be2caa4b85bb3bb8a8f1506797fc5c170e7923df7b393b1eb023904c512041e1915e4fc68f7ab115bd3435af465364d8fcacef48a8b7aca4d5d3244b10b27979a579060468b9177229402f557439a5f88bf128b176b468e371653ec9270421c5c9ade58c6b276bae69db9e6ce47589196d6f91c6e19b54fc4bed17125f836f811d37c6acb04e602dcd80da2c666e2c3bb8ce7c5fa0ab9075e5b5cb5bad50de7ebfd5f41e827ec0f537de6bf3247ce8a231aadb859fec3acc8d81761d02428590de05a0d2b528752f73c70387116bd1de9cf49d03302ee9d6504b80624746ccdfc92915865d030908a644bb0ae338357790d77ad181955dc854b6708d1eac33b331692aaf7f0749b90a460015287b4ab77f914a6e68fd12bc7d9250f003fcdf6f0fcde7181203802c8e0715337f5bd0549655addd8c51dc3755f93e13b741cfe4427faa262c247d10d24812cc73b2a623a3ba8819f182e8a9f7be053c8d464c6f7cc2926e45c7405673bf71aaa7134e9c60fc369ef7fd7b104b3694fa3ad4e792d1a5c277512bf06e674c5ad18a4f1c63b50a32dbdfc5a66d8be40d825797309bf5086e550601143b25c0dae3c2210ef77ce63873507a90ff9f3e6500a351feaaebe12e494a915c2fe5237bad638efa4f98e55993b60d0bfed0869d631cd5732ab0469261778ee089b014762c5907df8f3f17d1f1e6500effdc1a376e2aaa6553243ade556c3c7fe176ad01ff5bf1b36666c1995ceb160ea76338ef8c2deb2e1aff40a8cf30062d5fa59be60482295749cd27a68c5d4f78d0d68860770131717238737d70854c33a076e5cb145cb3a2b952f0d7c32b0679851c0b916758696988033ea99a1aa21f8280287f9d51a0e7e4c67482cb3ba76847f99660ec2998312f5c8f59b2e7bd854d1555c84247b0fc04f4a9e3682f75ff1250dc240199c1f0539e47c43f3e4a9d84344fceaf3a5132517e29c373092dc7e3e5bf43c1a2164b11699789f6d250aeae0ab554c274a11d77b187639d8227dec71d4bc7a6f1c2cd5b6c8d288c18e997e4ab6bf393cb7d63bf0510173a0264db9e0cb84ca0190153ca902a82543257ff3b03bf0d28037e176c8a4f9670f44582abc2825cc80df5609fd421f5f374b809f322efddafab9ee18224f96a9ccc6635c56c9f2436a2b58823267e8f5f988ee0050baaa3705f578efc646d70556e891013e732341bd932e98ec29594da0aa413257c69a12362352b391d5a1a16fe055e1b16767a666d69b81329adfa0f1f848b1f531149c6fddcbd462ef155a4b733f7640f595499954414db191b8f3ce23c764e5518457bbf7725e63e865c336ee5fbbab1ac0c0c3177d1df8abf5c9f04d4433ee4112ae1dbada132741b3afdfc7337f0a605ec3f9ec98a2ed00d540c97b566e36356175ed9de885e7b9145dbf7e2ed5faf62259dab2b83201703fd10aabf8edbb0a0bdf74012b25dae9490e44ac6232ecae9ce099ea23a2ef5b711fd8b73d6c3190f4603eebde8ef795f15ef2211db98cbc23f57d3a0ffd1bb0d878cc54fdc480584d1952298031f37af078f796ce3ec89c834f89091c25dad920f80a8a48790466d4edde3b1f0463fd8e230f9c6ed36c1d1e016b9be0903efce2b7c9f218b5be961d1de92ce68463db8a1c8be5e3fda3c2a06da0fa5a772e516ac72cab4083ad973b12062848683d945d87b213327c37c985e54a9c9e35498c368920af5debf7106cf5b1bf0a32db7f7c0714e024799119484f907d9bf875063b529a9308a43410df9d92ce9d2ffc4d50c9f080791ea392aa70729c928377993260609b480be81a5822df62c8d2164d2c4d55fd2d3211dc0e9969378f31e3ba2d00c86c871f3ffe35af9945c36aedad6ad033c95f5e6270c721c829c94d0a1351bf5b75a07ca200d3dba2779ebb12d251096c179d0d19946e670074aa5344e92ff221fd6c4a628d2e064f8cd374124029d36fed39d83a269a972b03bb3bc13b906e8896e32201d7df553b756b5ed7be57b3ae86c05b6fd27a03836d624da44b1f475fc037e25deccb6a02a7bca0c4cc408cf3ab6d724800ed55909fb0335e54ad26f2894dd2190d6dc6cbf2502d4ac2ff74a13f7aa84bc6d109063dae27f9a1809b00be41f8a9d487435ccc42fae1de9b95cf6aaeedabe97924ccb4d743c4502734cc04da07497e69bb8f4c1ebe8a0e2f70aedc25d52968934bf2db5ae4c844d34ba2d185864b46885eed5972180a3df478b17ff25eb413f3c47180889bd703105e5d351b38547b40081ea70ea413ffbc081cde16d47dae362fec8df18262cdc0fa82c1ac9b9a2ec2374e47ed249d01571d9ac78aa84ebc842d513fb56e3d56c233f9fb87af2053598c6532c4f41ec7a725e88e31f18c2bc0d600582e219d2c043ea1b5b79f08790fb1ec0b6390eaf3ac9c38a9f2516f3440238f2b0a7459c71f873de18c55686ce01d8a1c721fdb18e02699ad335c991f1ad149d4b4315d49de31d8122a79a7be1695fbde3def590ce061dbb3d59cedcb079e123ee86eed6097afa5d5b582e96218e10bc6ebbbe7bc7d54f4f4a5ef061948a7080ddb24343c5ae0a87234c03618f1d3ede4c635390b270fdc77e52ba531ad5c495f5a543efac94d4a4d46b916db546ddc33a42a1bf0154c1c47f5acc7faf5a3f125933bc94689b639db7a5f16fe263353e54c45efcce6deb5d12cda72ca56cc7095493e0864dd358bc334a722b3a49e01de538c7ee6ee46d766073bf91dd257eff88b564e4e926b6580eb162a029ae5de75a48870f98eae640ba4724666373ab712091d9521eb334b3b01bfbd3a89b59eb765f6667b3613c6f40d074ce097eb41599eb4e726423bc50b2b60c502741f0e2c1541e421d434484ab1d895a1aba5272ec430b3e5cb228fe29d83a8ff217e5c0fed063f7e8cb376562e44333a88680a954e0014496af164f73e5157a21f96ceaa5b709d5a793fe9dbcb75fc4819bee7e00f204f381363f98c19856171f30f96050beae47aa3cf27e9810a47bbd7e78b072c47e9e44be2ba3ac3196ab905d6c02138d7f6f6856f8ec24036bd50aa30a390b6cde132d6b36a78ad5af64d680e7f5ba2dedf174c5de5e1b7e92feb23859d6c436ca1958511a3749e10f4171357ca7d9d43e8d822a86603a1c4c6c2aaa986de18536f7b2fe764f4de377b5e40d3889baa16633a4c120d483979c2c1cfafeeeea0a983495d988f60ef4a4778a8d5d03036dde3359924465d9b3b0e3b1b39bf9d1682859781e70d4129704058006aaf0167901e15372b0eaffa6c8ec71bf25397bf9c5d585135a4046456dde7f378b88ae4850b166c20f3b5e7e30aa69e285cf38463bd7d9468f426bed37ab2902d76d10eca74d28b7c5fd623644c7851a2420c30511f4856903134b0685594552bb2d1bc25aa4449be2447e4a3787e07f56b0a217e0d29dce61b65c3a2b91ab62a5ddc88f1d176fd5b5bfe2ca97861828c9c514bad9a645538d568874bde9e3e16efc704f85220d5bc60c91f962c38dfb1d009fe35f96cd6d72df281dfb28d3ee1e2fc58022f8b582e2812aac9fefca7ebf6a159d004852e5408bad77f9491fa40fc59aab21cc8a9f780111598a12271d326e2ca9b3537032225cfec05191b82d2b89982ca04fa403ce6844df256cfe9a07eef105d0dd51aad74b0cdf57ce973d3309d55ccc9b4d05a93204a3c136013c24c7a8fd58058a7951eede32aa1e12337fa6a3ff04afcf7ec741d2f14aab8754146ba94ac852b052320780f02973a13776a08b756ea2f83af4aa098a6eb179e610a303800e2757c8a5e51f974379ddba32b2aa802ca949aa2af4df0afb8f501f53d137c1c6f9530c1b4e3e32b5fd9385f5872de27f9a61d1537dc181e9df940903b5c47011d9d022731a2e7da69f687fadf6d726700c226ee376b791418dcf2af58622a45c0544210dcf2d43f67cd0ed9bf750ab18d2685f6d45effb3283dff17fc19bd882d11d563f81ad1edeecced0b77bba4f4ed13d307b253fbd5df22e970e2121a4f9214990cee5eb63573f8eec254cc6e4ae5675d47b517e092490040c455b454438dcc5ecaf3dc2f81fe6a5ef11bc4328755df474f2e244321c93b1866887098dc0ea515ae94c4700e49a4211615213e6cd655fb99a74c2b0efe21ab3a820ebeab4bef98b582bbacc1b61b1dbb28dae393e3af5fe97b5860598d3d41d83877f801a5e81419b5167d82b911cf35bce1e43e6509e98c4e44c5acd5f78da45aaddf8da4a628f4c767deb189987a4d83015da8d69eab8c794ac448607305b516148ff58699f0c4f245dc4da09f370a09adfaecc2065a13cb58a5a65b56607acc5b22506941422e0683af10c8dbf2521b1560fb6e8e2bedeaa6e92e7be19b5b658392c46fa280c374634354113a1a1a58b3ceb6d8c86ba19a58dcde023b1fe1708b2e9d1db0e3c367c10f7e7a0059ba050dc01129fd1b612de9c366555ea252d17579c1a5b4850013c271c80e61ce6f8a3255e483cc0fbd3f6352dab3d1a41ac54109ede420887dffe58fee63c12c9ffd0b837e19706272bc0b8f8f13468e81d7203f81c34940ed1aa33492818506525ad97f0f298b31456a51d67240778d4923018e5db8f8a061368edbde2c4b52c950022fb31b5bf0288762cf0c3442b7507a174a996447f078172b6ebdd8c5083c2f1c55e09de2b91847b476ae9074f3a6f9abdd09e98342e9f9d82d79f41e74cfc4655d788c18f8cc060d5278b318fba453d213cc174bb6bb18ce2e56109e477ab46045aed37a7da934fe0725b69a3a1b2484bd920e9c6c6f24f15cff4a69f6fe0a05839fa15878969f72fd25d53f25822b1f1d036bf1e29d3aa4e9a9edf3faacd7f4c8156a16e915a80b4ffccc2b355280b7705e9543393abe845edcd4b20341939e5cfaf450b13d8aefb7438429d7c3912de3c3e4be16706834a57c151d21e057ce261460d88e20c85081ebd75831f13087d9b9c214c83d686810368735479bdca3f08096b9e2e26403cdbb539d776124d19ce07765df9b5938078630aec651536ee3ea4ccd972dfe58468a074a3c02de395c130095ac37846058f251d954db039c81d900e95dc711bf672f931e5dfe70cf9916ed3569c9f04a17f78688c793dd8d6d43b46787402493c43a638f02ad224e56f893bf2038af78c673a42179d73d5b64000cc77f759a3e5d12a8465ba5aebb198cf38ab49aa57fc40afc1bd05034bc454aaa2e52d8de38396c37ab223ec01727e8dea1bfda57573c1c97d1e769ac02cdaf5079f68e7bf6cd9d37ccc2913100a7660260d09ef11121f551336b4068462c32ac162dca99a06d2ef60e6e433c6c1fc34d2f5af7942ffd195b733e9cfaddb43107b5548205896500eec79b5549d9cb282f55a9e5e8841b14bb0d752b1c624a948d58599d8b61d3d539531fa139dabfe7f08dddc04c86de6f02886a6e75755ee654ba85970042d5ffad2c4800b8406a5c58302d218cba3537cef599d120196b64408055c3adb7f7e2548a8040bf63c39ac271ab70382aab146d218a18f84e64d5963e61be5829f76d4d76cb59136366a1645fb2134d81bcd337b9c8101e03b3ba6b64c0d8d4f0ba1df3f0f860a922eccf26b1b90e515f116e4f1e7e6ad4f8777cc3a78699716df6781b737cb8d60534b8ab3c6a770ec4fdb7c609eac98ecab22fc82681bd30aab80911ed5a4abac317a2c95dda40b2018f1e472aaa41f3caa99babe222ff6788f860197de996bda6d8969a81a82ff2e58590bc037f28ba777e11bf8863de38956e0834d325d0e7fdaccbe35c94d706fd6d7f42473ebf9148f0aa2cb080a1424a1aed055566a5d34b19ac454eca80dfdf985a95fee50407a663d51a95393840a7c2c44b87be7a12e5f4100ea25d91f133747435ac077920a62747aec0402ec9d84b9c5c48536f81630899fa16a01a2cae641ee914e17902f1c7f22755381937bf7f1d8e23e1e2dc147f9cd167d738e8e9d4ae0d8ad8adc2f658a4efd7da312d19eb1a8fd7e79d51c19ba392d4b94a8ec437e39a7f2fdbf3699abcde5535ba90d5a2160c04f4c01afc61e9e47958784a9889fc1f947b5ce8eeac25ddb268e97e4b25f72cd5594dc7ca8c9083410ab882b74acfb09748d873ceda2e4cf0158ab11dd01ed1c21058d2e4a936988f8f877e76bce75287b8ea6b730689e169a51e34fa4c5f02616caa9be72f5bb8304ae8d3abed6d3a66e155297b8d699544d907e0b7b7434c27cd506922c4413ff712ee3cd65ec5c11e25c11e2c7f037a4f8872fbb426f295766255300c8331b71a185f9436ba76f474eacf96173023d86fd4776e2edaaee58e98bda3505b1ae84189293ec08b1783a1924802835e424e1f4ccdf2dbee77882c022a4a7f84a8cb0c0605ad15b2313c5b6a3e63890180ea21670f1b24542915251a5a558a262e2e7cc2488d77c54a9135d5b95e1071f6552b8f15a4b1108e15683546e19b7dee9ada9f290d6d591e1ddaa6c1349802efa3a661142a83af7554792c480ed0917eb4fc1139df6e777c34c46372e8fa23802e470da0eb42c7b6444eb93b318fed803c5185c09b9cf75daff498fcbe75fa32f809fbe190641d38d35d46cddc86d26d9e42c3d96ea7ab272b2b9564c062a478133115405de56d2b62c4a61899a3bbcaee2b15a6cf082eb4d5f4d41625d8a8d41755125a0ea80b22aeac0346a9dfeff094c666a739cf751a4087ad74058f3fb5daa3e4c8a7ce6589999fed5c6df61473782fa0bfad30149c4d3d4cd19f458c295156b37b035fa021035f602fbe07879bf1c1d1213e9addfcf8fc262ac29426dff775c74b09b7957207cc969fd6d56aea28b4b8ac1bef5dcfd254ecf61d253c779066d630ecf1c929238ac1ec60ee8d690d868a5d4a721286681bda8cfaa1a2f7c112f2ef9532cdf07483f8399a5ee72f4187964d7dbb4965b3a1ddc1b3215b32c9cb661649f396fc3b3e9e2c2bcfafb57b995363bbdf2cc65eec648933844499d7da75d7b89f67732a109f0ffcfc5cb5160c2e46922401c1f109a8131c5f7c8b214aa7daf810d344a4c4c13f8184bd313a2d6646d92b91944c79af6de3a342a9d65e88fabb5068c07bd33528daa7a5a9add8a2343c904b53b167dc651fea1084fdf0c6fedd737e853336e9b42d086d1844bb481661d3071fe68e27d9de941d2f279583f61dc752aa14c259537bb518bd840947aabbbc3473277ffc837ec5e763342d7b256a70859d79339086b08ebbe9da36bbab1cbc5ad16d6627be2c1fd3c177864e13e5be207a6c3b8ac97f230482e75cf5b8e62e17b55a7111634420b68d215305c5fa0a71d579e81001b4c6df1294c30ea3cf549d35506dbd7dbc699dd6375c534099f943f4768b7973f8813250787faf76dc53569ecc1434952d35b553e0c6465277cee8411672e1d8fc07e28bba922982ca36b8dd45c2c10019e6f9854294c2d9e6a5376eb526fc108b382c9c9aa851ed58c7bf2944b590a0d989326ab228aa78be8c6a62c585b2986f6e3c9828176a30945aecc8806e208b7493cc1def3a7e02887259618612624adef50983825a23d70495a6a6f807e9f958274a5beed1314ee7580337b41565258fb56a758d1769f6c0da290a0ea43aa92cb4b0baa4dce56daa22f52c6c18c5049945df378652edc70a97f931271d0bd34f4ac7735062de57a5eba1a654989945649bd294e867071fa01fc2b12478ab1e5f65cbdf7df961430b62feead19c13ef3f63ae57fe7b9c0692b82a7cf80086cc96e5990ae2fb5f778dd39b21698e2f6e6916beb7f742b5c75f2e6364c2d255bd057def9f3ded2bdcfda1ed0168e4797faca2863d0bf2bb199ecb877c523c1cf4654301604d8f81192417dce95a4624ba9a37625d121d5c6bb0e71c966da24e90567d693f60b8ab10c4a4366564fb7ea3a4eea834aa63bb24966c5deef703212a8425d634321fd34e4a9a467e22e13efc9970756ba7d9a1a2e96d4d7267ff84f26daf39c3a8adf8b7b66884be9bd4f4675cfa9197c41958d05edb5bf522caf0b942964d8ca82ce7cb10a00df9c3b374e97957e660f574650013b082f4364c95f19afedea512af306cb452db9cdb4b18aa35b32cc6d9bf1480fa1ab07c87e2a6f87662ead4a36ffce7f2c651be42ca2dfd5276bc197e4016bd9a8887af102066307e5a5c364e063e54bc2809caee376cf9929773a0d9112a927ecf71196a77b89d39fed3da621a557c80f80eea7b316ef36865862b43fafd5132979367ce0752c3e4b4f14eb9d2d1113a5470cd391606ef65401fc65d8e73e146f2e36c562a393fb82066f83a24183d63b3ced1b1d83526dd1fb49a43e78c2ee55f29a0f06f41ad072726c42cce9435ca226ad791fdc10a21a9dff1921b95f7e88049737f4c310009dd5b174960c1ba10bec31623267998dc4783a404392f5312a7be79da97109df168e98979ebf5b619ea6a8562db41aa7d8d80203bac5a7f3af7b316b8689020ef0943411cc99c6a88e4408428178ceb322445cb7dfa6d5380a7e30eea09ccf359a215c4ceec12a14b75b3a2a6542e2981c6bec29bf5bbc1c81c8c7961cd16b96fb76a8ca7b13200fdd004bff060e90215486f67aa43366a647c8c1dde0114c97a4b68b927dc1e7f27639f9f7fdb5ccff44be8020a0f3240a94a0b60288ed1e31ec9dfd0f3fe437b20fb79c43fa7a83946c197a7c4a364ebff9c322a83970ee2ee52af515fdab73e97cada1982fd3fa9f8769d00d15666fd64a984164aa42d7dfe68c9130f84676ed7a0f04cecf2216a10739bb664eb66a6e5dd99f68818bd8fc77a4fb0aa42bf98b433bafc05242ff5bb393a9537f63618f647160ebbcadc632ada2abb79d3382e8a429b9ccd9d70a90fef71e70c81ca969fce927c4b9667e0a08fc0310a47ae597e7844db4692c802a5f5aac2b77dba9d54604c9d0a6f575e7b9978c293858755ccab1545b8eec1ab0e1075f3f1893f5db68c74e73fc15fa5361982c7a6756182099fe59c43ad406958f6426653e4d27e1fee983cdee9576cfaf8a6e8cc09bda17afe76fbfb7cc0f93335a1b1e4f7d7cdf1e726bdfd1e33ac0c5b108b871286119c1ce35775d0db36114374384f8e5c1a959bc3588c7409f5534ca6412821df111862235eae3c7608a6a9a690dd0e5fe083a14818f5d84704992ccb91fdbc50c28064cfc90ec33e6e8371c9cb9a91517882b9d2ebc3c67a62eca4ef888b615b494c02cf476d08c43c24852780ef106c5805f9d66747f0f37a16d3457b8a5dd85e0659b19a6869e6171d0ce6389a2c87941ad447d58c1d9c2abd318deab2116b87b06a54ded575867fffb0c791a438dedfe37f51f2fab2c7267dd73cfdaa16fc2b4b473e917d30c328f34dbdfcf1baa5ee257f78efbfa812352b534c6201511975b908ad7c376261591aeb0b262535f8effe1a93584ccc5867a607ada65d5ba44549950a36d849cfba6154e0c4516455e9f2b94b0c0eb44e79e0acd9f1766d424fee44cf6de6a4895697b209b70062e831116623eeda41cb842eb20a6930e70532f453ac901c527dca9fb61ce7555a2b561e37523e98e292ef5a65210e0b564d1fb7fa0093788cefd9007460829b5e2d26e2402c6a14450f6d1435a6eb91d155f793143dc4b6418eb751a3a2f35de2322783a82b277b08a7d3e63dfe8f6761649c31002906360d6ec6721558784b09c5c13293c1e5a627d63ae7aed0016d043c3f14f73497fbcd3026381d911c2ed72b22f4d89760303ebbe9d912f0a5d7ef44b342883f4b838bf1e2253cc1b6a9b2e0ac6d5c248b97cf20352efa9136be015db1fcee54029216a7fe556389506437a0bc4418500b2b106c74262b114d8f9c9f01ab122e452bd5346719c6e590ae1c9c171ebd01762997cd44c95cbd4c8a65f90b051d5c313bdf4fb6774ba53da5f07082605d2f3dbb81f2fb8b10c2cf58445528fdc8b1d548ddda4c18048f1fcc290a5393c66bd9dc87b75dfaeaecde6e0cfc85b37c537b576a87710b0c5e033c403e50ab7ee39413d263f7070905c58abe38925083e4945f58ce6663ec2edf097cb2093a04d120df7a44035e62c7787c788fdd0d97df87e8e403b395a408b1991b904f30d69def7a072b1b303ff1e7e5150bc435c3a78807364eb5ec6ca8d7b0776872848a1754644870fc5232cc3ed941a9221a76ea913df3e536ac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
