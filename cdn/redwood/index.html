<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83330ef9a7a7bc4b8950e0ddbd2b22497ce19ae802fc40e05e9abe7ebf20f0b943b472ad3cad890aebe599b9046f2e90157f79a2bafa2849e40098e56c1f6906946bd7967833836c132bcacb3a9bd5cc63e72d30ccc3457f4325fe90bc846665170af58a7274b0cfe9f2346cebb3503323ddcad0fcbc7a2bd2752c03028f1a822ed515466541fcde5923a48d22b9379628eb8c09dbdb7e3a11f1888ac0038dbcc9345438a119f710fe185cceadb0d9f77b9b54bdbafd2c16ee50d7d9e82a04cda2506888065253c507c5a19b298d94af3253b44562330a3f6135f620bba727f056f630ddbb66eadf4a673ec734780cf209f2f04b97b52eb0c323931dc47a902d5690b848d0127b0fc1828f74f662a9a4356e5e05d48d1c1f01c4c66aae2d8db5485be4dfc8387dc705ee609c0676ce2188372f923e53a6475087c344d41c274db5ddca81bb8041aed1ccc9317acfd0ea6d8a8573d09dd1d836d9229d852e85c9ae82828ff0f191ee1c91584290ba77b468cd437d81a2ea490d3b641efa6b11b9fbb129492fdd3636343175d0fa98efea4d9f86b8dbba482a642793bb17a3e4c0f4be8081bebbedac3ba2e9843a3150ee5e979ff576df92e8c8c18db8aa1c2a3f20767d0c9bb91be973d61a71c2c86ffeaf2d25452b626a11ab89e1799da634059098a1e9e1cda25a3511b89c20dd244053fee0888c07ef6bbaca8a15a71c7bab281b547d8dc816a6f635d63bb72c59960f4e8291a69670c3123a904bb6f4f5c788f79fd2968ebf5d86df127c35d634386ada457ec9075ed7415a73e2a0944ff8b11ba0d10c2a81c825adfdbb661ed314562c39247a4c457e415ad0102c707129c2fff3402e0190407e1e8cdb6fa3db7021d4f84fe54b25136fc5d3a25404a338de5f56beace0fbc4c783f3fa7d29ba47aa1d7f2ffb96e2e9f0dc4a3c55a1c630474990428b874211735d9a8d96efe75013a2fb6b4bd1b55e7bd739f381ce17e9c230d5ed3b443c135356ff2665e6d6ccf1ffdb8fbddb00ece968d9952fc967dcf3480c0f343536ab265bc41d517cc3181cc9de690ec8b5dd44037553d1ae1c1131c6575a14493c14ff3902e175a7ed14a4d21ec2f7ca7b68ac8dc595fccf85898fe667c963b0cf86cb66bd08b005eb7f7d84a2169440e1c7f7237bd6bc5d8b7f08f087dc3d7aae930562d37e0831a39224e2998b8225e89f6ef7fbc0ae2c784c32c19178b2c0fa735012febcccf5cc86cef2546d028734bd35ce05385b703c0d3a7ef95a0b661629c2a7f33a14f28e4dba9df0f70e3db6c5e1f6efcc23567c8b81109579637827bfb71ed2fa21fc8b0b09633cd02db27045ddff7432b865226c4c7347f0d43c51e78fa77b0b361ae68a36040d951f00f412fd21f22d573ffc199d51e900ca46c3160fecbc4c82bf0ffe779abb469ded19f5ef849601862397815511db8dd5b4a8f760efe812f578b6d314662385a0e9180cc1b267df706ef69b55ac0d6a9cdcd45a8a842a2df151097ca00bb6b878822be1ad7a0fdaa0579986bb602efbf5c064d9cff6b408236579fc98cb6dd182496abc45dee2144195753f85ab286c3502e7558852edf7ad80b1b40d8b1ff86a8c8945727b1a302281b12fe0d5927773d66b7857df0ca30ec62b68d6d0d7c7d7a6347531e5fd3a6722050ce4be365633efc36db889ed5fea1825f96863597068b151f7db0d6fcc9767468ced67d1aea57d384e87c9e6381904eb06594cbc6b87ff3ca05422d01b565f27dc3611f30a4a7d2ffcb69bb5b5d0733f27258ee2086175328b7d0fa05993ed21e318f9f8e4c59e3fcd9aa42ab6c8bae4917635a9436f7ac188816ad525c69dad36418ebd1ced5cd11bdc100e7c1e12b8baa7ada2172d0cebf5d626de860103dee0e02b5f1942e7936b0efa9cb28f2ed03bb4be55172b21974ba21244072b4df5d8f652a1d64fe91caa7337f45468411d39362cd582fb9215411116d0719b6351dc79f969b15eccbdb828bb362ee2843b73fccc52dda761844b7f7d6229100c8b15823201538fc0961dc964a3e94dd712e88e5925e71eff35153f7dd83b8aa176771a710d8de0ec60d568434e739c9172e13ddb53c1d7a0605ac15dd253ba2be6e114cec72d44e0b800feca9b858dc1907a7b8177f0fbe4de1aa0791bb15bdbb53bc959a52419ba4a87a87dbfd53823a7ede664f7210027957e226a0ce2eb347f935b52cc9fe5018f3f99165b3c38b9a92b553df7fa9ab3f66a66831d4100c9c0ab15d2e8bfad90d9f1634fd5b146124b82031e64bc3d52291b5001b02fa8acbe5c3cf99c0dad3ff11bcd80c57219c0d8de0051572a1189d3deca5c53a03fc1dd97df70806e16bf4263ba31509a712b889441c698334129238c39b01ab83d488d37a62adadcc18866a591c7b0e0297d7acce483e758fd1c6c0796c8e207b2890c7b6bc39e028133c6f2971666d8bedce626aee57992d88419b7d62e9bd94fbfb7261fa2181338d6ebad8bd72736768b0ea624765aa0a7065fa8ba85f1d3505f3e1d69c67eec80dfe7543d55067d1cdb1de092cdb46032e4a8f67dcb0b5210ef4cdc807275bd3e0d88d07fed37e2d3d7dbe682c0cf852ae0ad506021ff7ee0bab0afa8e14a63190b9d62c9c0d5897e9bf71499d04cf351ed6a6015d64313cba96ed1a34dab9199e67b221bd8e081374dd610054d1d22ee147f95755b99515f9e0288ddf1d77b20064b59a9d96f8097912f363c3374ba3b4cc0fb2adc8e059df48fcee86262701cf96e4f7a5a95ed1d8eaa6197697f46c9bbfa73124df4c2311e7d592af6501d390fd2c9d965e46d91d5c23bd3108e3b3d21405488c08396b5b98d687266149dd31a3f92ce1b18f5043ac003067ea1634022dfd925d1848c6ef03e57ad27050a55b3c309b8a6af715d312f65e0087d82bf4951fea30c2337a697e3e79fc0bfdeb9dac62857964c47ee71d3f4748c26c3bce80de11efa30010987fa8977ae7a415610807382217b52feaa8e43c7c0dbd78702f3bf563f36a30c862fd1fb78b01ba64c681686d0f7331427dc0205a7600fc5d564f31832fa9ef0993ecd6bb58ec5caf2e4453d40468d2105156d81748f2d0f9b1ad6e38a2ad74f7cce9c1813771ed3377b93e198c6040a05631170dc83e13e3389968298927438c7b61677570519eb0bb70a3f82defb2ee3d1fabf93df0c727e1e0b6475be9d508f2a6c44847335e833cf49f15c9e65e431b57e5e2fab79e3bb806ad8546d69f91b081dc7df07afde40b9fbec12bb682a1ea5b2ba1bfb2d60e475f5109cb952524750653898e517b048e19009d52ffa6d836a102deee16a6db6b7f4076aa657dcae6ee907f2137c26bf84d03cecbf26187ab9782129d0782ef530260f383f848f3f6dfa1fafd296caf40c9ac5dcd46a31e53980b0d5dccf20e1b8295d364a6348c2f8c44f46487e079814c74a29ccb26dffa4b246fa5e07e43721dc053f6479b8dcde50d7c6d13dc81d691a4da15fa4641cec36a924e3f522a742d1f6978ac60a03542c08fd116b45ecb4c82ce3857359808f50721661389138a9a20d49f4771d2e57e2a52a8700a4194148b8b1ccec7726367ea46f953258cb96505183e82ab16e427a0e268acc4491b918e9ddf04359171e0a891da82d0dea99292ac224db049c87c659b9d77eabc54bc4795546bc0a48e8dac02352588045b0dc604b89968b24cea5d95b5b7946bb5e9163b8a8f3b8fe62936f79734fdb28ee0e360be1629f9d244f4519e42ebfc4abd29c0562a59f72dd961966eaedda06e78b8d466d8f8d98ade32a2db711779bbf0fdd0e9a9c4cac41d1d6731d4eb52883ac89e7bf789b2db0dd517046c4aed3b6eb424e67916e4a326969f589e9cb0215db97b94c45b8832ce6cac8aae57e7f5ef8e41b4f5dda11cd4434326ad796bdc7597cc499d4682622ff952988dd816399d34210c82fc9d6c7e24de6baa7d65894705b6f216f1adce2e17cc231f5dbbd827fe00a27e5ea429a86d3f8fc8d04400a68801001a9a45376efca20b91a26d7f17e28bb5f331c56129752c853e82d398996a49ad9b7f4fcddf8e419be7ed5411421633ac2699e4ae709e33669cf65769a28fe2b7f588d587fa9734c16a1dcbe5f39f3f0f4c47025ccce51b10ddfcd1689c7e6c204b62b0ad58629ea671007a2a33d2de896caa93821d52f9d9596df8999b86c376d047a8f20affeb989bbc169e9103f8e3ea39d7a8a304e4f8709cd1c528f56558ec320452228a0e586d5315b9eea3a07961c1d372a82c8a6c008aec6f796f8437dc47fe10c8f98602c973a13ab6f6762888e61decb6ff55d1a8fd415ce810ef511a9d97dbf5bcd3ec86a058bac53765831428a20978737cf0b689481a2019d1a97049b4f622bfcae1e206a2304a7f30827e9417be8839fd6fe46513fc68ba77d4c7c25cf89b290bf7a3b626bc10f440129997391be0395d73dcad574065fc676c42e1c7439e42861503e9527b0a800a5755780b294a27a6016b1a9eebb3f7efa0079417b42f77eab8fa1f25c0110528e52241611fee9aa983620eb5698f2d7b9699d0dbcb21d071053dbc5c8712a24766daeea9522289630e96139634c822cb3d143498516b5e273adec237a859053f13b88a1f3f1b39ea7a257efafc1fb066b295f5e89b5c16026402cda1a468bb3d3432e926eefdfa81dd2ba4b109dcf3ae80dbe5b69c586270c00d76b454e296de8cd2952d98b01c854737b23a496af025d56372ec141f036b32d14afc649ca610262542dc6873da6b77ebac07e47740df6d8cdcfcb1f5ad3dfc8812cd85c363e8610e8a71cc1c4d161f952a6ae6c5c56c76ab12f1f20c5b5db525d70d714067b311ed9f67640cdf1dfd78ec5d8c74120c513546f575454bd978f34ade937c24565aca2c7f7808ca4beb5c79a5ecf4cb0266c6d9d4291a39af36aafb6982a6ecb0a2bdf7c12237cc56d3998e7b3d424aeaa59b8d7a5e57625f0053b0df62ecd3fb2f03d07586d6245a07b1b361b0a5e401cfa99ee0d859c12380a0f94f1fd3eb556c32d898a89dcbe5c7313b3131af8c691055098994ef78fccd78baaac0be7f0cccf7f6cb1cda987f6e7fb589fa09a64e23f7dd45c1a792bb31b75aaf35aa06c486e1fc858cda0ca8eaeb06a3c739b0acec9d15303b9e08c86ce62eb5d6e717b4574fda0947d0654cbbc7bea979911949afd55e199302a24cbbb7f4d9ac183ae55351a486a96d0d7fe676e85fd2924272e0be115cca5d2f47862a5df6db3939bd370f2dc917a56c0c2b787f8305a5d90c1f40bc2e4fb282c7735ea3b66d4324f182c87eded040ef5c9710c6a0da14c07fef7a1382b8cc9ae05ccbc9d8c0985de5581f3fd4a169444548b9554aaf937896f650001242de6afe9f8d4d75ba5067d78ea18ed3b2078f36ce699f6278141f215d951d1ae9c2d41068c2d45d2903e958f66f1458c294e87038374efc337308fb5f28b15e10bde5e80ec86644de3e4cc3ccb0a25d8df81fdebc55ec6f06026a21a3365903fdd419d7c517a1b091402184a4c282335509f5903c5f5462fb56ded30c0bbe7210cf10ebe71c45585c2ded8506e326b74bc7e0064d2cbef89b4410753c82c03a05ea16388f0284915d849051dcf7a6f2f0b4a6b54be944545d413f48986502fbd45c696aa841b489653092f5549e5ef743383db337476075883977d9cd486a56008359f10199274e7e79bcfde9c3199c9806b304d83bda9518b1acf7dd95cd519c776fb94adea804f4705d701134c5ea57e217ae25cfffaebdd7fc434da81c6aaefc460d43cf659dcfc873f34e7ec45aa33a08ec0bd61ae28105e80d1809e357d3b7e1d3c81808ce4235df6c4bb0f71d88196bf6216602e5898508d6535c94a03a54965f25811bec31f6204b9d34ea97f93d56693e55fdccb2cf431e7f5430ff22cbddaa61ba50d491a377dc7f345c84277c96e3d523d016d54f35ff35eb775f70aa0645030b570d60582affabc10c7de72abe6c0ddea6659a6c5d33f2461b9801ec010e439319c313cadaf115085e69e9b5ad709c3a1c9e2323dccf6879d62d6573f82ea3177efb47c3642d3fee6640a9f856b8f87e292ff8b3ac8a05b8a444cb59b2fb7c803a2e005f94d58751502f75777f5f8042ebafc192070a4c8947796185199a17d0174baddd67633f9efdda32dbb1a41a5f9ff3313298e9df6a666c4d4c0d2070e765dc92490421cda3f23db47b4bcc1935673b1681998376cec97375a3096ebd81cc955d0e8c3a43774c46e5eac0dc0413ea12feca1107af360011209a788aab624dfec0d8dc0607ef98f1c4a2c7e54426d948c06bafd0b4c24121db36853a4bccb086f55088e77ce8f1c3552096c7c00c0f0c51255d31f042d217c6889feacac9ba749824901b3de4ae63e59d95027c7babaa0e66bbc60f66dcebb6118a64295c91a378d6b2e6f6248def7ec28f94301c06010b970330618bcdca2dc9d25408d9620d2161bd59023b783cec6775243f9e3f9c755bcfb43c3bbb79dec4c1db1264d62634138742ff8d485e7d9da45fcf30ffbc0c6dea5e00615ffdc3866abae7d477536b1d17ef0bf87ee23bc9e630d1e645db7aa361c3c604795fca1ed51adecfa6593079888f6569f088799a7bd17c0bfeb818978d93daf0b4588e20e26b2ebebffb38ea2e937db9843325ce39df7c7442155868ef6eafb8c21fd01bcad883d9d1aeccaf59c2144431bcd08a17fc1004008a5b3b3271aed6727f629d24df6c689ff35c54d123083559517cd94b3c3a4e4bf38cb6a18eda0c7aff2b069dc0cbe82d34644e0012ba8c865906669164ead5b707f9bbe5f3a904f3a58b84efdd5a9400cd2d2daf9b8025f382b8b2c6f3131de7549cea78e11ca19fca391d331c7f6bf42b2db4483f2d6cbf797f2bfa1d43c1d66a9d14452ce1a9a44018949bd1af874f1e8252f27577d0a1ca1816738930e3cb78d5dea8f6f0e5c5b3f0e2a82bbbaec55daa272d62d86c76e6463ca997b6458614ed8546eb62c97c300b23df439d2fb878ef38be0016353b2fe16df054e7565827422ff13a79172e3409eeb2ed0b2556325879ab2a50f3e4ffab0bb04e319ffb4ace92cae905627687d767d530ff63e4211733737dbec6f1b78201998628fc600b3e54a6c5bfabd8418540b90dc126e0aa9bbee28c4805f723dac24b27092eb6073e846ccc1c60657c3373782917ccbb1c7e5ebdf7ac0c30ef7126a24e4bef5a606e4d0ea81ea032df0905a212a2f6b52d2050bf7048cc564e6f16ad4481d897e3199cd6a51252f0c6f734b5ed3fe4f57a6eab42af6e5841f1e058af4d7c51e4538e9f2048e266afa87c74d74bb4db0548703750b55a86d1df4705eb67339481917f0df56f907d453671947cb42c273b1ab39c56062f9b5f70986061480fdbda0bb95c6c5f12a1f51ca007146d2bbc69f315bb9868dc6bb469dc60eccfb9fd48c790766e39bc16ac2ea7739d511d19c4cee40c8295aa6ab59d2888497083239c2f2e8de054941b5f58a2a468ba5ded6a48fe0c2a97c53fcea21fd57abe39298fe8ed15e13c40c71b14c4440dbcd8055d1d6379b56660224c1012f5c7606806193cb1779d748b46ee98115f340d385666dd1cdbad94cb29bb751152e93eeeb2ae83db657bc4b616edec67ec8ce9804db1392a75708d487e326608e3510c2453f71ce9428b8947d57cef67b95775af613f925548567bd542742b74a2007545005be8b9bb395a0a7ee5eb0e82f71790c4f5dac3e134052599269d0615125bf64c244df3a7b175d671d706d401f39ad7512b0aab5bbb4eefb37f19dc8f81ed96b51ae0f3f92562701155a8f59d5252c948aa6fd28d1494549e14d6f9cc06cede7acbb34a4c2529ce0f9f37364176c9c99d44b90329fffcfbaa4e8b0acae82d367a6a01c9120e1f93503a946250e02f91a08ab12aa08b8a7f9b72d59726eb3d7bd0bfb3f03164dae4f364425b8b0f9b9360cdfbe3aea681278af1bfe48bca6e49825e98b99e887c3e00a11ad4d146ef38805b35627d6559e9df09721aecdb5401682234cc751fab3045f0672e3a71aead26671425683bdb9a08f29a3f8e479890028000db296bca348748cf344f6aa4f257ce15af8ee4ef7ef5a05b78dd868b6f9ff455bdb57f739c95a79a36146cb2558ce3ed918b496883677a81bd8db04c68c04eee64b545489c609e82ebbff16bb63570113131cb5ff390e61e9495b938cea3c54656fa3233f73a908b660b04b8ced08bc9f70109b6c948fa8b049b131617d3ea9af1e04cec626dd286077abe73876c442b07ea8cec8a9eff90f9eff8a912f2b1da8375ba7ac5ba47989c32868509b1f5838c323e10b7411db0cd3cb36e6d50992950e9833c584fd230d23fc66ccd82782a2fe1cadb0798de7998a291fde3a14d587087f23a2aa491c4ad5fa96c74613b1501b990150cd34b56ccf915a3e1a41de632b819666e6d338d8ae7544438cd67cd128a9ff35ce91b84bb5526fe528eb244a2e2086c36892b6528b790c13c37692832f6c1e09e0e47d0d30a73f517996563552ffc690ffad19f150dc4b5db74eaca48f8c0033917b4b2b93ccd5ddee8b861acc6c0859ff4e83a4180efa0e03b294a75f5af9c0909fb795d97750abdf0aa959b7f6fbb895ad88ad7757cd961b09c11db3eebe2e87233cc3d2d4b3fc063d108d95386d14f49f06199fe15fd2badcdbc6a68c35b16d55294f26b4ed2210efe609e0c25a278a41c8dd7d2e4c8a9247727f5ef6e2d5253c836fd4d2898ad480e3847b58dc59eda0bfc37e148071b69fa59a7d497dd325a5be8de51d8abb3f83916cd3f1a6ee720aa4316b4d4ad4da6305a67c1b11b44cad81bbf833b270afbed3e3959fafbb34740302c2fcaad59c1c8267ca637fb00cd77fedc7fb68a70d4e2bd91795cdbacd3dd40272deeed20e570e65e6d24bf8553314e09ac88068c57c91b5f605fa3622bee6b0c79da0880b88baa3c98242cbd666727574702c67c1b2e1c030a0bc9a50e20e6be0c085943a61885d8511c64368f5513f12ba96b05fc133f1a5cd4eaad282c38e2409d9db07e8030f330d3efff0fe2ec88418b918a2bf472a1f957961c736e5803cd9927da0be419411038a4ff78c813f058bba8fd0b2effa4898c1df0187e50f96cc68c00cbd37ee94e70a48f0fa04ce120e759597219cf63fd57d8be93f7909a435a4b1a9f9dc230a025b4cbc08bed63bf91bf75ff5143176cdb710a8cdc3d49dd923b885a675326b2cb86baa17beec579a68678544c3f8cfe7d3592405c53b3d5f375e59d57db19f3ef010dfabd9fbac7d18c1623c2ac6b785304f6563e9d97468b7df17fe07bb6582640b0bf164ae121a50dddb967b2e36eb580234ce5272c3be851f43f0cdbe27699660625090a79b5b60dcd103496b73ba70213b7ad25fff62b5ed403df48566527ebe4ac80c4cdf1905e415b0422bf1a15fdb172a1d5e67b5986c44bc8333e0e992debdf036667739d6f3e9fb596ccaeb34695cafb8fd3f43c663f98998d1cc2122b523dacfcf8f937caf09f427f1915bb3e3257f9ff44d2f6a2a4fb8dbdfdb350c4c5f5f43c6866faf05c2721e6ae575156597499af961d3392a4e133f226855a4ae7f3a1ef291ca0d9fb3297314202b7088427051c7469ed46976de0b51933ac1c81ba4cffe45515959075af47d8999e09879d9c87603e8a980f5d5ad58ba9d02037301ce07487b8b6e91901352f5f1df2dc122fb906fcef7625d0b0f06b342e93936e2477a26bc84bb6995cb2302e7ce4a394fed555b11e95730b03989299341c7bc4b1d59cf4082e134fd043c64b168631f57c3d6247a8635672063f9e2b5c2fb383954b4b491decf3f0bbc3e92aeb1648bc968fc98b9f7c0e3d0af82cdfbbb0bd4108f3238c7eb4d4c186f1e2f75af8dbba2b5ad187159e975941319971c55d762e7fb11ec18355b50180782e302f590564475e2d8c7f4e59334e7e556c213d9b3db2ab71bf1598e7ccf97d831f17357061793b413698cf5a532f2aa2f78c7a078ac4461ad7a1d1793e3f39d52ade746858bbbad1453ee9fd133b790a7f3b842819ffc3df54adac0d86ca0e33f6f571737b0914be3e8598711fa53c9142d63657c4abad1d7b967cdc89fdecee59d96495bb1971377f25522e38f3401a83d53806be06b3d5d1f5832bb0c6c72fb698362c245313bb954f4a5c04b832a85d6dc7a4ea37c74ab96ea6efaf5eac19bc828f7585c71ceee1802a520a1ab5e338d50eb73d74ad79fe37feb7140244918dd38e532fe0ab69896134fbcd153079593544581470d5e4cc07d39366b198521d193ebbe980bf8f6ef173a73f0d1df071096adb3fa7a88f69017f67c74d31c027954121432b49287873a80a73af68ebc656e0102efc35631dc9b260ec22efbe0b67c5ecc084b05d3e09ce18f11c1f438b79987cd8a821f3a20cdbb21e74330fca27795660805a28b08f2dbc20ef293c55019bc3b2fe4f1f97b1deb06830b08212df5a203a2e441d822ee3ae485c89bd8cf6a0fe42cec595d43a0f6897959c4af3593916f72952c5095ab3ebcbb5e31632df30f78b45c8953cceaab81ce3e0c5de095efffac73461531d56f334412349ac4ef901bc8905b8bea5fbf0a36f0c56f8b007c5ff942d8ec0cb9e63502d110d606db60bb69cefe58a00d0c96dbfe0633946b6784e238157a1147008f3135ea6001bd522f8f517dc4824f6049cc146fd0a898a73b6bd3ab9d5f0b40444ee92bad3f2f518abb62ed8a4e54a6277ad4c05fa3b5aa76b50093b0ed5b7408412b7e9d692e2d618e0f0d4ca9b50da18ff4dd557b734808157fb97f0cd97daa52c17a910b17ffb71bca52dbc1d9c48d4414325207d0ba1500ce24c73e5a499b78ac10a30b58a8ce0e1685d3f3e7aea9136a6b17438c072d94e90dc53d7c3ba59d450340ca450b80ee47e6afa700748ae9171204e159385047d08b99240636adcf8429a6a95e756bfa9d8c16b4e236816f9ac65234b21aa29520484d83ad5ceeb69a4c77880c2779a1e7211d80be2322eb29530955cc89987389f622a04ca4c60470843d3bfd9dd4a4f861c78b29a9e63c14c3d3f1307c5d005ae1e57275b6ffc0bd1eb1bd4c650b5e487efc45a13a9d158addc8ca157c6e2af42e96e099013260767a6c426311f18410a2b91723e6972b465d909c88612301ebdf67d7c336f9414ec0f0a982759d30363ab92962fbbb99519bdb0bb610005d94a542ac4c9d486d2483cf5522f2d5e66abcac4f0e1123220f29f5e07ac0a374a3812f921bc398a7a444eb701445229fbcf93427e071e2516232ff3baae74e4a9ffe37a4d2ca142a254f6dc4738a88c139526884c0abf3fa427738cf22867987568c1311085788262894f6da1216689d03a31f4ca261a1d83f3137b7ade723291fdc8845bdbd80e3be479290b36753414e9895e16dfc94e3737f7024d8e0db2d79f185734b98e8232055b7e32e0f62c4934ec1616c25b700381973f766363d8b0009a878f3b6e9f1ba718ae465ffea5857bcd63e76b555c52b32fe17d6556d12d36621800148af69aa66e9ac52f46d8497cc766ff792460cc5bd666eb3da5e36d0538da703b03f705d9c636141b95487ef240bf9109edd65c7149802337ef35f96980d08d2f7a302938df30837e1e8474ed44e22bbd374a8e8c28c7a501495a456550d8f7c2cb1f3044a7e1ca8e5862a4016901711e888ff7ee1bb504d8b857e808be4e354d0c05664482bfda44272c5a4584b395da833c29d9d9147ee91147455537d860f15218aef04b72eea9015456b6f6a078fd977b07a5196f2cf4fa4e2e71faebb65b5e00d78f9e561da7afb41aeb03f8c897d26ae6f5ccb66420eaf04968a3eb4285aadd5b9a6de9f805d1a0261bdd564e7c0d6675c85e8cf8a1d14415c7dea6537fdef3a5a05dc162e7ec4f73e431c7e6bd266c8f039dde7980512cc7fed690170c1c4534661acd21730a319e3ca4dfba0bc038890506aa9b495e9c3d9e8028228cc9eed0f8c53e8dbcc98eac05f4b0fb610eef843d7f18c6e654d6b5377cacec7fecc60dac940e0caaa9b2b6fdd1210300e426e8139d1fa10ff05b0120be50f3003c0e2e7a6499a2dc99675e8d1272c1d0fa32e8b68c27a187808875a15d827b3ac3277abdb42e3e1780aee9efab75d321bf7a3105c67bc09d00a3ead01a63b96c4d09750a5f3413dfa47340ae9d5f8292e4bc92822b12a34297a2c72f6115b6e34777dabe086e6667d953414b03e81d5003b5b8607c8d84b58368936edf15dc3be89478f516b2ae34d2920329f5f735502ea3056ffe6be8f23b668aae7c918f2e4b2410fc5d7b7a109da7944fc8c53cd48c21abef4ef5df8e223e81ac67017feab8fb28b5bed47e6c6c8da26f3c44892419eac16ed1330851dd5dfd9166abd1afc47498588131d96bfdf4175da401efe2d6561a803da2cfca739c4985da297fefbebd1d1f6f5d63ab3723c9abb438c87272381ee90182b62bab4204bc24b9287f3d623223873d4c61d9e99bf4eb78d8fe8e66aaec05838b9e83ff656911aacce128743bdaa4c947c18f4accc0b846fc4f0646cb4a3c263038ac5a3c818236921a97fb3f3580fee797575c8905f16c2fbcb73960360f29b460976b2279420bc7ba4e9c94157c7fa3af34ce2e26ac476b2af1dde6881992c84dcff60cfa3d9d720b81be010ef33edb00915443178bcee3d88bd4d5957a269b5a5b74c00ba951dde15ef639def989a3514d063603a9bd86da9a0512baa785d11f5ef9aab2d6304c6f6793d7ddceb8b2decdaf14089ef45eecd905ac07d489f701b4308e4455d0de6de0909ee178f83b3af0d76c9e494bddc8f1fb7347b415044b86467a677d6dbb9516c611a009602143b743bed85a48add60e31fa024a6c56ab32db55db3bfd75cdf1de95f5c1e0560b7b4d3a6baa76197669ea9c0ff41b077aeb885cd97f11d5bce106be67461f369ab4e4a6df9c0d0802a0531c3ff1cff92610122cddfb89608f099ff8f4c6fa9900ab85c8f0c8e25ba741b0a6215f2514439f6dbde164c1ffb36154f6e8dd38b0738db402a134029477ee12ab84ca1cca55b99f30a18716d56b5d92bb88c26ca4b89577bc7ec629ed4c621d8f1a58172e1db5fdea006a6c60d1eee5910952bf879381e067df4b9e962e5757c5f0d64e8822dce19e3bee40af1076986731520a34e504179ad23d2b06d2117691605f6efbde4eec428d87baf12dd303a659c67b3a9a3f3bb38315c4cdf30b938791eb6ba86efbecbefcf90c9096e969c50fa73117e23d759513c6c7b6c481992d49e3c1b3857c1896217e236669ab0a05eeed5e4c344fcb73ac311228b0ec1c011f764f2edf39d05d70eb481499b107b6caaf1dfd2c4f871c7a9c080dedb78b13a59af20ce96e1c2410fbbac64ca52b0fa7e100d49868fd85855dd9468b153157c00a211d8cd82d68298c6f21307d5c07247b43c0d095e49659b5377f3df8921db0c31d5396954c010a89a4f4f0b69e7aff9e3b42ab1ce8cd9dd09aedf7361ac8e065fbd14d6be7110a1ffad283acba3c262df875f0daa6ba3e32bf2c96ab031c0595adc2c64b95ce8a9d92a15a196abab411a78712d1d94c85a5d7be09c596de017e3003225bdadca946b242175878e92e0766a07883fd3b8e32780e99eb4c72217d69d3c1cc1923ca7b8480af7c3afe05fd7749774321f045d7df7a3d4e8eb4dc47cbb1af480d99b149e3479a10d4c3b81d375646644e863766b507aa825f84f7e9588b20ebeadcb96e9a702e05ff3d627f1e2633aa8cf79ba7ec057b898b25c695aeb128e0b5fbc5506cea2e9a701c490729fb80143bf0a477d67f0daf80d2be1bd617bcbe0428e587b7780406ae4aff822d16f1cf2492b18e1a2f3e5b5667062160a25efcf680ccaf639ee883e879604eaf4dc155db365572033a06d01a816e8294b63d230d5094f6d90f4ee66f394924cecf26311d0eb425fed8e2a1aab9d1777314cec130e1494cecdd4b81813575064f1aaa786ade098cec0fcc5e4e8bfe2d05b73bdac2b62cf38815a199e0473e1b3190c790fbd6630c94cb8653ca7089ca53f0a05696b529ad557a6ca047995bb37142044f2eda0d79f2d169ed3278afaae5ff1c09adffe329fec6139b854c9f124378a63714b44338a9191eaa07bca9e7c551cab397551f30b2bb250c2a46e4d30f28e2e0fb022e40aa6b69f05c57ca0bb76ab8684b0507976dc8694bde95c48326be92dd2ab693f9d4e53b8a4ab6025fdf11249b644745500bbbfd21d45b52bea18c8723dbf40738623857add76c2e36602cabdf9bfb2a816e47545a7e56c5894d147a8ddab0ce941e21ac56fed45f4e4096c11f68a4ccca99216df355af6a6634a9d13d10b1878245b3dd88cb7693ec05318141233cb0862727ee28758f1562029d0865811e57831d42f35d1a946c58eb6114fdfca9dae5a95c9fab387aa633c13b40490f5706feb1052995716892df3a4ffb09b1c00ff086bc793b891bc722dd28c1f7e5ca05859ac4b7e4b6c579173f8b24281c6d41a3f8a1235971cd697ef8153df79ae3d54270b665dbdb861b95954c3315a9512655b57e0b0eff8b506d7f1f4ee5976d5017d77a93e7016e602727fa675389416299be0d0c469299e7f21463b85b69b2d77d49027e2faeec4073dc27625b184a666d4af9687fb1e4c9c445f34af54436b06b89f7610e684b654801d89c916838bcb5c8f208661e3f3d2f77db7455ff616e76edca3538442f4aa6fc9f4a7d2a81e1200b0f6c0306c162c62e28ba11a9303f6238ed15050c77784acd236559702cbbee6913fdff46a4a7e5ef08e4d78ee2792813bcb2fd26b0ad31adff57fc191384338d096e0ff2fb3d2c69a56e594979ddcc960ec8c78c7918185f47072974a22a31f1aa2ba700c6c0abd451742f1461ddae576ae46af2d66ed0523ce858542d2d5bf9737a8d67cf889ece058ffee67537dba2c2da17c280477e0518bb36df9a6428de0754bbe4cd5d48f87122bb1e085e32c8bad4fddedde64a7f0691508955a09fd53a76a3bada126b51057053bdbc455755ff9deb0d59a7cc7d42601eef952cb7e6e1c4715adc6c046e79cc02c99e86a8e843148f92d27f54a297fbdfa00ea95392a80250369ef89812572a56a092d89b1030cbce33aacb9c1f9b07a542c1ec7ec6d6913468a913d7656ca15390918730eddaf202131a72ecd77f6de86cc89c68aff1785e179123670464b1f47bbd1742ca9f34a017aab5ff7aff6c937f9a05ee2d841975273a8483505aa961686da93993330d2ff3ab0d2db3cadea36cd364727728afa67fbee58e66f175f8c67e5a23141928ac3befa338b19bf780c69868779aba50255ef51b98697e71f2aaf5d07be144de0e4051bbca48c66af9b99e6937c78fe8453cc6a55a3eb7cd89e7222c0c846649c581b86fee8f0051117ae459574185f598ff805ed374cff28ec8b51d705a5b99e44fe85640ad83df5abaf2a294011468d389c991662355ada11e1851722cde90c8215ae72c50212e496961620041a0611d9138f81284839f781aa44c712e903abff3f1cfa67d2ae989a73db2e0d0437936ca41dae1c8e23c1fb6f63cdea18ce9090436716b77ddcd6b4d58c6197287b0394be57327d4e3373d71e16822314f1d4e0b643a0ca7ba0f6c36c5811669617de56c2d3aebc2914d379ee487e3d081cbc2a6e418a4f89b718b909fa800ce83e9959bb3d20f2bdfb6f895f018de7b3278c4e4697735d327d50b8a3642aa30e5e081f6ba73ea317da6e9a8ea898dbce911b75bf9a71c7dab21711be678008271c4985291665f1cd50681abafb91c544cd7463962432030dfffcc5bf948f5db610e81a49b61c853ffd5cddbcc71b2c11208bb2a7be9de92f73c924998f6908160499d92535334d65634c5abe667072aa6d21e4a62ca7efa77afce2691161ba37b7f15e60730d0e9b8d29c6789c6949e0172af183a1518f3005ee38b2fe3e83979d477d082ee34bbf98f46046bae3408d864efedf8cf73132331064a6a6fb2882254625d864c2565fe3f6b5f573ad03b49d3583c92d6279796644c27a5f147960efd861f0cb0da8d0689399baf382086ef8b83a82d23d607eda33abaeb89a65d426f0c4b0febacad355e7cfab4ee9e494633d8b66eda65490b7f0e16d8c7a27b1db76217b927fb40d439c6fca1dfbfac1cdbe021d177b24f2aabd5a9501e5488f8652cda717750f22829c99254fc9fde9c119c541da2c0907b943c650f327b858206d1b051cb3d89b11709fd263bcf9c244a4621505fd33e794b5475159712472ae3aecc6d30ee65ede2ad03a95e859f33cd85aeee3fe74252118d734576e2523b49d09bf534468ee3526b8001e89d1c6a05d7d2d3b248cabd2f5df8273a6e318c46342f53b33fa9b56a1fc9f146d844967c17f9f9fa935d3081db23bd20c36abe222a63a0d1df4a53702d332d597f6008d41640f5161107d76bb559b4206d27fdc31569aaf021dd695cefb7c7b76be943a5b2b7d7087a4f3d108f198c031057946030aa24915b29b1d4be5fe94bb69147c321f55395b7bdb5fc2a9976e490dc3d84ce23c7072ffb3a0de69b58432d0c93594ba73e524c6e6a497482d26a745356f0fa3f7c9d5f7f5296287da5446bf098b09fb8103fc8f875b0ca02e80de54f085aba5804deb5692371abcd120ccc92720b687f7bb5e8d3c6cf343d4ae47f226772c4f07fff75d57bfdbab87ed0dc40435c01f6c3c8b5d5101db60d0fae6e78ae98238fb260258e28aebbe913124cde0d6b46979b38a67aa23eaca36cfead7ead4c55ec138e676e4dbd9683a97f26eaea11a6d45ca5db3244c4a5d3fc1da3c13ca10dd949565a54c900e21ffac315ab990c0cd4600ec545b8c39d9b7533d07aee7fc48ab8c15cf9e5fc433bf417053153f7f600068fbc5b17c2cb92a32298c929538fbf84fd3c7ca4c19df359e4b0d6018e9586ac9801f7a99f97d9de0cd0ae2d151e50ce3815085ce0a073d0af9a9fa52c9431b26e79f3342a5e1acc80825a1a6b94463887f6b0e1ea26b821e361c14ea570ac0cbd8d6a5333244d868a736bcc1b1ab4262e70c6d2b637c8155ed42958a979583161e2cb0f388ea93e153456f01c10261d29c12acb579336ba957bf427c2a07820b5edff258f181e6b304830d2811f063adae5a60ece68e0fbaa839fd7ebf0028c6ea37612238f386ec001348549503b289dfbc53c5b058e4e6409d4d21d7f36f5b324faf09bce70bbdb9e909c6257dcf75a00e037fb89d768021bcb7249c3bb6455807e605cfc5dbf06fe62ba701021c7c5575adc7edf6b9f6521211f2d99ba820489a9a93a70c28a6f2762456f5e5dd7e34539cc33a2a18df37ead40595ebf352a3b6024c42f2429d3470feafed60dfcd6d72c6029fc81b179460f40bb99861bfe70bc928ce70afbea127854320b5c665af52e45efa05fa46d561c0318f3a16e9d3382d94722c335d3a971919b1db25dc9cb89b2b3f2a217362ae2a600857423d21d47faa4a220cb562d365aac2a65a4acde4c48b738c3d7beaef02c11cdc4589598805aba62753f0cb46e2b5ec98262a6841238509da3b5b1e9a8c50cf8a9543bf92bfde39f14c1a2761bec13fbd0a94e0892b65fa2b5b20a7ae825320741784d788e5f8642e6cf56a5fc3fe64a96eceab328f69f37ca1e719c3a6307016ac4a0a29c0b0c4667baf5982babf7f53edb43de71f4cb97f800ce4ecd8fc4679983735b3cac81b8936373177fb57173b31b720988b3944b7ef80729252d5a6be82b09692e68a7ea7849f35c60932893082c6b47437663a74999268aafb6914b56c5bb8d331301c88c860fc1240009e6e2e4887ab024105b6bcb12dabe2009c92b2adde1f2c818bb3993e2593c6c17d2cd20eb83836546e074fc6d3b08c60399ec7e3ed6a2e5db50998d53afa8823a1063cb7e44b6898679ffc0c77c3781821e71629974e824bce42b458d5c07495a065a3ab98433dba99c096f16b5fe1d17959081387cee616030e920e76e26b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
