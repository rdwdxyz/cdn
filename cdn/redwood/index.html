<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b552a7fb0226630462a9aec2b5d610f8661c6aaef3cc4c9a3dcb697eab8dc06b62c13f8afea2554f34d0c2792febb1dbe9f6c501854cbe376e0f356555dd5461d10edef35ff7de4ddcb82249f760314c37b3f5d1df342f71555a381f75b0c4b4bbcb6b18f29611005b99016a8e40d7b995001327a3185fa79ed7b2b188808b7c110141694a8a5b4487964f031172c05ecd20ec4030471323ddb6e45cee496caedde55f624d8a85094fa99a770ec4848b26a6ffdc6d0890eca375b3543f45e7339d1fcba9992e7961d0f975d0e29a136fe1bcf6d935cf40cc6a15a724292e7465580697be777004cb0ab0f7efa5d9d79ebb3e9ad365f4404dd502c7f7df653098371d88a7838074a37346aabccc57a84671d4cb12dfbb39164aa6f12b4d3eba025574fe30b3642ffed2433e078d7fa5439aa1186d1c2bc57d7fcb85d131e3155f0e5d3e2f5b39fa597c4d25a5817a83cfc4d9472b6144b41f21807452ae30deff5e57bb021a1e1e247a77a21d0294fec747a45ecb71b146504a86bb0788935964853146da5b3ef3e818bc0337ba19217e0050db595e95901b042f9bc43b2ff1ce9b0748cbd4e36a60a352ec104524ba238ed3ad40e7e2ec3e4e16eab317fcc0e627cfeef1736fd025dfd7a3d94efd46bea21c1c0f0c36f40724bfb5213195ce48704e4183269d098cc5e9f0f9a8994ebfd96e2df52a71749f2f6a3315eba18666ef7c03a3eed3fa96f870bb7f9fec8781226abd7b645bc9287eb85f3edf4017a832af2ca06434d7cdcf8e73c2ce7880dcfdd5a9a17eed07398bd45920fd2c0c7403a35b06d07eebc820e88db33430528d4a835a48bccec4e1e72b7277f3448899bec98a4b410e7c092eea19d7d2e194be6f68543c4ba77b1761825f2635b4fb788dee423c1d86d320567d75479e189de231275aba7158670e7cf41ed0878f613233c033d2d2d856928710ab014a4da1b5730b924286fe867e5bcf6d3c8b531f126303c2c3bce70d06cf61e3f73304fc1856620929a732577fce716179e0d43eb7992ee4b7e9bac6e701d9820463e4d99016bbf862702da089bfd96a367a8ff02566aeab9f6f97bb0a199a021beb29aeaae0ece4020098e0dda3ee4e92206d311880252158f0e87e2e575acce51f04042c1b73de061e830c9d05dbe9e4c033b61a4fbedb3dac050d0dc813dc970f32970b3f4f1d6b7c3c7fd4a9027cc6b0b6b7d08c00132091102ff7e3102b47055c307a91c6b960f5f3bbd4e60a7209ebd245b355f5879cbab03cd9659c4296b5bd3dbf4ec760e7dab16ca90d2bd7ce287888120a87c54eec81c8636542565e21cfe71250df674a1af0d563a5e905cd263f3a5965d15e9db2123044dd2e4e9c93781ffd9c805a256c04d0263c33403f8b85238f5ba89a66b8b3eee8887e6e0857dcb7d5665a7779244baf4328b40cabeeba9861179d4c3ceddeb25b94a51004dba3dc3e2968eeee58376ce1b9f41358d2bb35613bfebef839ddca5d339fb89424ea028f94c8367b128f70dcbe6e4f252841ef7c7587d1e4015a6241e7a9d84c15a69c55a6305d5888b29073ca7370e21007a9e2cf666f8a0f766dfbbd24e6532b7c67486d457b20cdc56e70be939c49c310fe849f0d3faa06a11e09ff59d295ac8b4842b7f943dc25b92fc6fbbc98c2360c3a4c91cd41aea0a8a6b9b24679c749cff8b309b6d0c62c32a236df8e3dcdd221dfa7cb5fa62cc8cf5072bb96d14e3a21c10e4c117b1f66399a6d02303d4c41aafb68289dec6ccb7d0739dffd42189608ce653ff3b0da0eb6822ace7f85c958106a9b5bb4d24e02dae4d40e9a89af7c602223366a1c25f68bc57d3a78ebd92ee2bf5608dde013938cdd205d98d584b93fd39c8c4cf24f77a44aeb60b9d7fb0573eb28f141c233946d57fee4239977e029c64b27c8bb2ddd8fa153c7b53d825534360d8fc82e833e39cbf96af72778b669321a06ba3cebc13112e3891e40696a25dca2d67504ea9ffc4cc8e48dd38354a57ed85aeda4d285f3ddbfa9f7f01db255119b42694596b24b53ac36192e57125655871ab64d38a6900ffb866bdeba86e7252416f0d304fc2db07de6c7bb5030d1da79b2e1f981cb4f0998530e93ae66c67a166a259fbfdb26d1a6ca94f4c60d0ebcf90b310037b95b86a9e111ec699d7d194fd8edf78e848a96fb791a38e75a4ff4a07bc7d0ef01f237dd8751714fa497daaf5b103fa0a4eab6f9f1a9a3b69343c838bb84ca72e5ba6d2d17f7fa30d0c08e346c744309161ab223dea2c2312af021ff0f75d3059d27c5bdd9e33c6258614dbf233337e7e9b466e462f7229fbdc7a9e481d535bfd022b2f9f08ec3ab7c2200768a3040c6b540c106e6ea1d72af4f2c463abdd4081c532e97045018ef233129f23fc3470d33129af1ca92c2df35798dae740cda95d2c411231eb1897ddf904213451e0fd3e8fd2a1e9c7cf2f8904245a3f3265c3c4f3353e22a555b8123281d9116f9e2bddbdc0675ade4e5caf2f4c5d7548268c695f6770b04cc4804d80fd153bb788aa33eaafe2de2f6a5aa3641ce4e5383dbe66ba13bbd69ee2632f465ec315d4cd8940394c31a487184807e9693b312a42e045eb8802cf2a770b61ec5f3ab31939065abb8b3cc717e2bd20d7c5566b1e1371261049183e1bf5b72b5c274dbe78d7223ec875813705f6a85ee41f867147aaee110c1d5958a4d72b37de88c3265fea5b27c5e904e9ce365ae9936d93a2ca16e2f9b8363b6206344ab4d6b4dd64c846811e0c69382b27941a9ce39a440336c06b0531ec016364a781ed4a9e97a6d9fab9b1cd1d3c8532cb1fa084fe1e4049b5ba45a7229f60214496ab69b0fc27f00c8fab0c5ca44b11841390ec4dcf5eff0a40c5b3481ebe619bfec4a9d8ff24d60aa524dd04d422b54deb936de8471ce67d0aaf72539731b5cf15a82cc73922873fa5c13f5be1a9a578d3369651fe2802728337e344dba85d31077129f3c71509bdf756c9d81549ffa03776613709fb02022a89645b7b62d33b28b78dfa33d3174e1de68b9842b45beecec258363260d0c90cbeca11011028798bca2a19bca877b482dee172674a8bb40620f3c5b73ce03820c77c8369ecb4b9dc6b143eb967356d046ed6dcef4dcf4ab350aec08ce4eacfb8c662cb15a36edcf43b1f2c49230deec1dc2ec0788548fc06e18d6b8107227e154465259032d9188930fe4f26a1189dcbf12f6244903006218d786c8f42f10871ca332df85f999d5b8c4eae89c6e9472a9bfbd4b95fc8000278daf82d1cbb6f3d09ed46f6cf675f7ae0365fd4acf6de93b05fc9c9c4d4bc90bcc90187927f313fdcbe0054e9073a9144608a50798a8bfb8d7442c526529fd25ccb21409586c80f99b26b1a033890f30d21cb78dcac5a76401c79f49e11af9c1f504f5a7f9b50cf7a0f869d865723f4aee472bfab6f78652608defab5ca2a101a4ec412858c3ae174d70cba1f8bad893ae1205374738bc2297750f7e70ec10ecf9e49660c2668b51c5dc9866cd8ea3929bcb234e83f23fb17038ffd3023f2e96950300ea1316b2ec180a41e62471b74e0a902700f2eb1c21d8626a30ba483dd0c04d01cbedaba76b5a3fa8d6495cbb04db18e1d45abe534a1733465fed35b318ba4e57b8368fb90fd60913d0396b7a7d72d26a2c83d768a42b23da5c7c64e79e2d39d6490e477f4bb9b940f256de07ccc81892edc80f0ebefc98f99b2bcd595da571f193a6e5281e33a9337c69d00011b16517c9be3e3747f60d399f361b58b006f12d8157506fae8b025c98196938d7264fbca187b639c7611ee3b7e0b1fae324b986894b5029d57a677cc78b65450315002da228eacbaa07ef2c91fd3b3b9f9a31f726f66b85eb88b3c0460e732e0b690b9d0a2f42fb5298d40fabd9c423f9680358215ed12bfa8ba7c20c489adb039067ce26312983950c1e3480cbab3a9506a5d6c8204880839e86dafb8877d7fd0226081d21eed6b3969e0607486b1d5e816e73a36721f96f42aed288ce2daac80e1fd447295681980b989e4bcffe9065e1a68d5893b10f3657b7148e8f1d895f6167b7f6d5654d9c55ef812f108c7c900cf2c52b5f7aaffe4361289a3acfc4cbbad21f90c8388c462e13760762c4368db787a8a006737a142c1ccde9bfeb4b3ce4afe973b1891e44ec267a984ce88a388e9e2b3c4d6be3bc5d7ec2ec0a53c99b509ef69fca28f298c6ed526a7815545f4ed51ba290532f52986a12caf1304437d8330a8fada96a7773f113f50afe9e889ffe5568efa610b7e9e84e1eafa4c6687df6471307e45fdfa2c41427e071844a264f266c02dfec98b27418f2cb30b8a93210a1e1ee43cc5af30c108c222e7e5be96b57d38c2e1f005a6f6b8f12ac0edb865d379e47892242c3c5c5de0a7e26c4552be0ad4c353b8ea70695f66f1da391dbdee10ffc5f769079b8835755eadf07b3b707fb567ac295004f3d287bf8ecfc768a08c2602c4f326ea4e3a7e184443ba6b612a4526ac9f621f4a280009f175c46058b2d4c1a356492af8ac90f3c91294fcb00b0d65d6b65df063f74ab028fbc12777bdf473f1ce916d6f7243479c15e9062e797fcb36f3488a7bf3ac6e53cad192797da9b53e8e06c517599a786ad69adbe4ee7be6ef675fb378414428ee27cfcc694fefc4f63b7bbafc7c0d88b422b4d5a20bd637ed76f3e482cf564a887f59b18b6486ba5f357623cb6466150feb2d5e7527e64e476682ff32367e88c0e2ce211bf36a77152690133d247c973982fcf54ce2b6f17fc07579fb04f5ea0216f5dafc1ffa116eb63de52b680bd91eaa46b8c12798f98ea528c8f9417718b026b3dad75375b6a62ebf52446dc03973872178c1d1ddfdd77d3041a9436420736af601d803efd5816515049b1d47a25349e13f828c5a9d5d4f0c6c588b0dce21801b6c8853ce8ec09364f29da06cbcfc2aa5577319381827afcf3b4ca135c526be7ce03f42593442cfe468f722ac066165241b5b8bff7749ee3138ad35109e7163341049f59a27231f0d247d27cd9848c70c1694fe4cbce3632b341fea5b6caa2ad5541d4805d26c09737500785c9d9e747161eadd0a278f70f71000e7dabc4fb023ed5a334a66792100c931e4a160934378b70cd47b59bcf462a76f39712a1a461f2a5b90c84fe37a4f90aee1b3070599cedc22e2b693700106a48641adf5574165bbb4dcaaf1c1f4682649f96f87fb1506311dc57a86b32d05d3745d85b6ba607d6bf9269c8b89733e57f078b547f9f23f42bf4c7fde913d320c3600b2847227b5d07439755bd4f973598a6ce2b499e88fe2b72b13ae8f030dfe7e61d136bf9e66b5e29e66008b1276c8465c034317a073d1af9d111fa050a98d190701c9c9b92e188dab7e93e6d57fc391f64b5e4cfde9c9b012fbdebb79f918a2bd32b07b701f4c6c3917323a95c46774190bb37a762267787cb3164a760f6438a1752edc20ed51eac8fd0a9e95bbe8859bb3868bbc5b71173cabbf2752a95b4884c5c20799721c27099c49d72c80f76dde1461ba054aaed1ba431f8625218c7f676cbae1a279c8d66426ba8183d5533bfa8575a49589ee7c19c0aba0c26b8a3c627bd14f33d57eaa707ab2cda25d53eadbb2f9ae4f9aaed7bb3926a6fa564abc2a5aaec85f96855c325e3ef5ddc0d9c2ef0b18f853c65c50ba567eace9f4df181d3f0de3594b4f7f277d1583dcce2fc63f92452a3ad3c34ed930ad35648d6cbe9dc441cdf8aabb4e4e9f8d272e2705338dc30c436fe558b7781768cf881e88d056a27e7acef1238d8db6e9fe0b02a4c02fa9d1aafef5e29347bec89c13070dd710de42224dbc3545d17d68f5654305fc44efa86f36858718f3c04104fb0ef00be936023ceb45744b76c6d51198b49c1e995f1b620bb9ce3c891a108d519a60aa9787e65b3566e8ab1bd9cb8add9b1521fdad289e5839c5fbf923ab8cc7956b3dabbec616338d211ead01ea080ae21985b8f57673a87c0a42a31ceef72ff3672aa43c523fe3f4c8b6febc6f86edcdb844a4472d8ba54af3a533e73a9a880549b0fe32627fb7145e00f6e22804bc9e53898034cb919feca9d0d95731c5882ebf567cefaf1b9b50eb47f8ad87837948db17521ddcdd6767f377a075e6b6fefc127ac0f92b31320be19c14e8224383466803057de4b5766ab833621c017f70b72864e5c2b7da3d2d2889d91a4052e95484272a3d0bf64e44341ac520677760271a270900d9c501e3aeb0484dd705c31ee75bd2f5d296eff6e2f49bcfda75db20c78bc4dcabef73c09479a14d461aefc8c631674874905c287a83b7fa24ed60fb5c1b4d8c58e3ae4299490ab25de6fa2cd046f559477713d6945297533bbed2065a6831ce7909ff59a90c3dc978b3e7594d490b37403f97c3918e457607a4f9857026ef1c54cbda203a82b58243861d645a36c6f3a8307a35488f7266da28c9190ccae80108f992cce2271cbd22b4629fea13659bfba4ba3b037f245a53309f3e976163de868394506f004b0fda198529952240e87d4cb0c87df453536a84b6317a7f8bb64e57bef4983b9c9c41dd30cee00b9129cd674811a661294bc3a754495d8bb46dd9cc95c613df3f0ad7ac1a5e499df3940982554a608495bf937c40098ed66a9ed197213173bcd48e014ba1311d4e543869560ec3f9e14a2eea06c775d44fbf740923e5a01798371d0c4d62aa88b540a993cafdee843f13e362b0cba1413b840ab26cba91b8b4cb81ea3c59ca45113d4e6fb1aeb55215e3f04419d8a3c767ed8d28905cb531eb46b81cf0f44fa7d4c1a0c49ff5b3d0f7d6c318fc05d6144c34852d172bad64497ebee6397f0a79ec517cb9fdf9da19b9410754b0d7fdf8b0b7d88abcec3e85f995c2f1482dd875aacaa8c3a675479c821670869dad3f8ff6dc2e23abf21ed6c88b7e7871d9ee1f4c36a727ba32ab0d0fa2d5605d76727a49da3fcba9fda4761a0048141ae2aee071122b2db91c1ea845801c28c41d5fa625f70d6a89089bafe2bd6c22806c13c98db3db408762cbe10ed12f314ab55c6608bd17182021fde2a70d5b9f8065ce02cd7deaefe14a9500bb7767e6bc24eaa57f9d956c433a173d5be0a0263cd22a7e7b725687330b899f5b88979e6086ef2c74683832cf0da130ca58dbb76f947359b2983b86badec2a2905c613315b9f713e954f02b2aebbccc81e9f6dc1b396309aa7c1232d197b43f96e832a009d1decc049dd5bcb0ac43f86378c9f8a889809f73ecc2469913db7a9a43baf421d7b48bccc93f4e6d1f1c9e5f947443737eb7d6e2c293d73d282495e0e91db5b16ff45d25f460b9444288f087f56ec4b1f7671f3b383ca3feb5d614ba688d4e374df3e3f1900c471274464aca537bfa33f6fa4e8d64ed3a970ec8fb3e303d30918b99b2a3f687cda5a350d021cbc82ff499f2e575208fa124e98f61f5eeea1a8b4093199e6465222f9d6eab0971892d2e1e32768fa6e361f26b808e435b023571f5a4cbc4401937cf143cef66cc3143282174a89ae09b9a3743b741f50febcc7a38b4cc882e7acf68dbf806d751feabf736cac0e25bbb92cf0c2c4b80e5d97004fc9812ce495c3bb0d43b1d3e5b1cca5c5dca953eb4c506a02e23f4429b8fd88695b86049b8a9e18265869692de0b20540f181065e85ba14b95e3f055dddf329a0401f2cb6ccf1cbf6f0eee0fd3af1fd4235b1c87b63699656a27958fc36251dd1e487e62bf9cc35da925dd1bcda5c946d4d6090a96f48b7b8739a9a7029c9e6dc518ca614ee44c5b9814bfabbef4b9a0c2cf94279d9e800884d20e62fbd0b89cddfbe586f4a64db4f32b7d55eb63ec7aa58156938cc97f67303bce450082f8529ef7c3c99ea198156c1c1c6f970ced776e1e0633dd63bc53cba1cb443024953d2f0e961a843623cd751e1f65dc02983960bb930c4bca7c02a928ce4d50667c5cddcea553c69a1af40ed3e1123cc9d8dcf446cdccd3ca1042f81d334b0152e429e12b7021b93f494295e0d661ebf440950f92530c49398e7866d95f6b00baad92118b5b6b0d6831e069b03a60a730d5ac6fc0a3cc1f131a52dc301c40e341681877711d07aa3c1f670ece10380e7c5cd4103a0f4df646dfac7d4db3dbd306ee5f7fbc92df7edd410113edbbee04503e45f5aab8b75cf492db4c5167c56690e3d9f5ee65f98eef3d0abc49243fb0c0bb41707d8469d20169d4b44b36da6830c1fe078ba6f9c493855118e2e34bc31885f5765d8806ede653a6a0418543833b68b028a21581b0e7f9bf6c7e5c233b86860fb67766f1a90d3d4dec1fb2d1b86d47b0d9dcb3c57c0b14941f6c7b14fea175920dc7e48e7b614c1bc23d570be5a12ae3af73a2d6eae041fb5741bdf598c7f39d3707ca37665d38c7af65029dc13f8af0abfe7c86383726d145e33df8aebca5fe71e77de811fe4b3350120352253153957a4fb9fe8890022ea6aecfb8b7700b7e3fab470374d525c9f68677112be585c389c823e6a2b129085439cff40004f80989f4734502c2eef2d96075436f523642129bf53c65ee8f46760392ac4c00106494f3a253cbc224df75fc02dbfd7a28c385dd21918a251c3266ebe786406e1bef0a61fb37303b3750ab097bbc0386fe55812c668895ab12b4316c5619d82f9b4912c8a51ae46ce262fa78f55e099c52ecc6493590dd571514f1992b083d6461ea75ecab3c29fa3d5d307df7cae8a826a2106a6c2f9fe250c42c9c55da4ccbb8fd20970ff27f7a2378154add045f76e56e4ffa55cd55aacafa2470bfe2a6f7478e289de1266994a9e4d3eb9cdf71c53bde6ef589697382faaac1f36fef4f206a034055842635c039347c9cb4552b11d96c498a93c1f0368a0be60cebc40983ed23bb72c8c378d5997ca0c9dca95ef590b53360a9ea338023b4cf2e5fc6c9df21a8570d057abef73da0ee2e91096e4c0f690e3f4f7e7eb544b2a98ce517299ecb0d0fc0fd73628ef6ab3c79be6f39db14e87372d916206ea396324e40a9ae6c343699d1f37dee21ec3a181c67aab7da7424b73f77d67fda6c7f98305cc66cb018a269c16c6a186aa5ba1a33faca5c9a0f4937f11df86b38379b972adc61c0c1656039df55aec97487a6a40644cfdb1fa46d20dbb97a5c41f075fc30b5ab489ee8e48cf289996ce5dfc35364adc8cb912a8f3c70cf28c2b3a72f949a63a915fd0da28284d7d286ae62fb4f0452f83550c6503312702431b077abfd9f5bd97290136114d70bcb5ba18f8a196d486be4acb8d0f10fbcb12eaa23043e71a6b4c661773d60669ca734b3b9fd67a8b5b5b0edeca82a4584670688dbfc3e0cc453e5e7896bb510a2befc0ca70dfd3859a00aa00fdfeaea366b75d808cdb021ae80860e6e91d5b186d752406dace36c02cc5cd4307010a2d8e0012a4091ebff4703c83e4000b66b764d1b6c0528308ae107553209a16612f5256cd1ebd8a2b910e3a0f215ea383c2f9978f70d19ff79286f77ad1b8f48b435bc88445af5ea94f6068580b454a7b55381ad6c9fb4a5f546f20e0856e5bd689e29981c41b3d193df35909f7c023c872de464541eff7b731fe740ce799e33909c13e1e57bc2d066e94ff2cb3287eb5edb57cfd677d5b3ad15ff98645c4131273a3f3be6fc0a5832de38807e2ba1eaf49abd364fa51ccc22f1686ebaf385aaa127806b4d4c82042acebb36dc430165032dcbe30eaa0d624ec73bdbf02c24f3b15a95d700d816a53dac59ae273fb9cad0f3302b45c257ab6a05682172ae9e2d36c0944edff5748093c67ae379069483226c5b3aa47a453daf328d288811c29d70406efc987daab6904c62479de060ca33b626310b07305cf448befcfb8c86cc2a0afd4318bb8003040c603545f642b94a3ad5772b338133dac85ef30abf09f3ec6719fded5d3e534df64bc5692cddaf862eddcd04a1cf6b2f0730fca67b39eab836f1bd9a353875a11b25a7c43d1523446d29818eabf723874f530cccd21a5f815cbba8bb2daa871eb75550d20d2c63d082c8b8b198b94d99c8a202a586ea4c19962b526a5daf10ed233f80450896c550198c26c57aa040982f7ac787cb2e21627504a8ce2ced6b20f3d19ccc8be490b5c3dc3875e18b8fcb3c5e961b82dc82c0b8c66346dbf7d336a902fbf11e34be3c7c581b022f83d3f97758134cdb5fc5ac39483491452258f49c2998f2270d7d4e519d2a2e4fa456c876a870f293acc755d2d56c04bf9af8fc551421dec97da5dd9e71decaa1d84f723c54cc3a8f4a175be8637d588e331302a06d7cea93f670cd9aee5d4d38be871e5c039026dbcd2c680872c3cf72e77912ad269cde70a4c0c8d6c7adb57bfb53249b4ad69b4372bbf92d98b5a3e3351741a963b353d10008fa6179e23f0e30017a98ff96e22a8470d515600f803f35a1db5e7b4d99ae943a0529bd086ee45d5d173e10183f664a4ae9bd7213c9addfc6c70e5623a7f340c23ba7dd8522c9a20ebbdae386cebe965a9995ae02a2733a60aa8616fea3df8133caa66f5695773f6a97941c93e25f8e9fe56379e45c6db8bd3401ff4666125fe9df0d82964d72540ea42bfece9be6ef61cf9022a60633b14df4441364dcf5a36496fc33079499762d19479ef82dd0630230a42ae2147c44a220678b9cea0ee9f9b9bf50764b0bb07e13cf336b2416f226914fb2200be321a8f36c2a2adf1b5d395828bbd3df2cd8b83d957c94aca92e5ec20884a88c732431b230f8705f1853649eaf66a721e8a7973287c67e0bd421908d32ba0fea67ad69c8c0e5f74508b2d6ad3db69ef07dfe3b6fc4aaeacbba98c9f6da25cb019d1d15686e08081d15282b1833875fefee701e917d6e04bf88fb660cd04c04a59469e12788ff616d883b885963532f168a8af701f2d6659585c34d0d0ca7d67daa616595d18f2e64c12ee751e928bd4cacb7f4da20e19504e476c9073dd7580d4e4dfde03de45c9882d8f5eb2bc3ca51a8d525f8f08722c4864163b2a22be94273556209c5c0ff6e064b953efe30d3a3b75a947a53ba1a893528fd0c3dce17a9b14d2224a6bfbda3e2a49d2563b2678d1323db34c85093c136bea5bfe9bb38e5284ba0054833b180b5d72ac7ce8d59a490e82c497a4ce8cfaef94a6467132d39d6a11d389eeb6a2e18181a6dd596407a8d7aa7dfc73ff52fb240eb025f73917c24ec3e7e68ef74bd474e1c938833860829141c4eb835aaf41d2a4a0714ca26c9f14865c1372e0372daf7447a5a24057a28166f37c948ae4be22b35bd87a0edb633ba30f7e5da49c014f487a7b0f7f4b505781d64f5423b309f26db14e4a8a49f4122ec1b83146a268dec568fd78428debe00bb68d35f18b6813b58108ceb41d4424c4e3daaaf9adf369a0e0c9b8131654c4576eae6662828c853bef74e78f0a94552340e5526dea15cebc345198b27916c97ddb3babb3296a08c89da18bd7d24654f0154f7630bf9eb18aaafec28de6309aa6c734ca3d4ce8b59fb30b7eefdd2eeb8ead174155ffc48aa4f872bfd36e80f2f090e8c46649341c6c9715d63e9bb4db6343c624ed468989068a4aa4d67d3f5d2478554b12b3bc3eed3703b5d4689fa7b4ef4587c59cd3c1c38a538c053736dca2f8a37af76f63fffc2d5f640b93fadbae427724cf5955b7b3636c73d140ee253b3dca2df03b80e6547b732ae7be474fde6b5add1c7d088963ae153cb94cc3295b7e821e9aaf87d5fecc670281591f4870482b34f31fb69b694e350133ec02fdc5f0c4a0d73c017b6897272a2cb6f33a6961fcf7165c3e1675b5dd532eea9abcb871f657ef081ae3c66a584c9b8e2fafa07868aa1f4ee830384f3abeb23ab5f9b00772e2d6bd8c9501a163c54b43bf880ebaf23b1b68e1a4f16b7a6bccd1a09b80e83668db4659bb094ed1101f94053f30cd64ebe9c86b3d76c43b8ce29111cee194bfb61c831bc21f81c99309e53d279e06cee6f365b3522500f7952a32431a50a89df94259b6fa157724ab0574973f9c32ec4a8730ecf2d8b3537eba581c3c04c0a6bd3c383376e36607124d3250a158a24ca425d5f69c8e7a36fda1ddbe28a030a7616c288bd30bc6d66fe9f6aa835af8f8dff53f823501d66c13e126589d30ea66961474c99f20562d489a82d9b91c04c55a6eccdd672d73c8c65183a72dcfa7ebdf593a5c91df00074c521c1077f299ee1ad2dcb5c3c5968d23f2c5fdaf33f49ccc65d7110e087603245071c9625c2d5761855d478ded064394897f0f4ae98e5f36bfce33edbfcc96add6b80d97c6f30d0d104aa517c88add67a6b7df8e5c5d7b9171101d71c8960742739f87fabb094712bd3de6afd02d31677ed33ea4f6d25c2879664fd01d1ae9feb23bdbb20fa44f77bbd0ec18af79c8454545acdbfcc1f69881efab7d4bb1df6b7474e334b00d285e5e1a48be0a727b5e21e4a78acdf16c36387978ed5364f8207a9ca6b6ec8136a3ec7750aa3cc3cdf5041f7150c506808070330b6b21f0a24e1af264dbd915000d4d57a6c37713f509597dd745be6bdd4f35ed88722baf138f00927e540b168d0820cd8e44b92fa4f92c66e094f7fa251183afb75ebfd282822b23449e3ab4470bd813a7c035133fb8edb02893774cac001d0a4d2e1963d374684b9609a0a3e8eb85c7027b12dc07daaefd6fa83db4d5de12f9dbd0a5a43624b9f6d62105e54c82a87c35f24789bd3567e9c04c7bdde5bd215dc84220e6b03291adf3479702d8ad269b8b56e1773a5d39d64007a064a7d6a38303c49c0fe513ca995f8b6fd922239f98adc81f1e8eab4d86a2b471d74487a5f3e09262004f6b3633b150883aa2c0b804fd74104b4d706e1927f41fd025778718c02e70b0bfd82c153075c9b79b077837d0eaef443736c1f9e0917420565dbe724e7722fb2384da505a3cee71a8a80cb69a1a267ff8f922f7769d21dd68513638904b4816c889e689d3296d7bb9edb7deb16b7cfe8210f4b71faef1f1f96eff061e3074cf74dfc80d48d582552283153bc2eec51083cbbbdf2b77f9f5b644c62ee607122d9042dc394e9a54f202940011201071e499f8620a3a316d8c4b1f77436b273808638bc3845130bff08d2370526a2a0666596344f71fb7db4ea727af49d581e2d3d75a6d579b70949f02367d602dabcff55c2608f9b10720738b8fce77ab24ed7866f30a886b842e4a4e30dacf35e04f7bca84eb2c465c1e058fcf052152f7070f4db0f2c37125d6b4d1da20fc8724b00e691ed895822d29e98a38fa2485c2dbd10815bb95718b5dab492084f34a71372d818a000fb99f641d84493d2f0a7e92e28ed58f6ca8e572db7339519c806d233a846a32bdcfee371f46131fe66ae93f07ed408740d008dbe175fa1da9012642edadf51e957fe02c37316cb95c4cf0b89597eebbf2746543a6995b17d11f9b1d05ca5d72bb283a1856760ed660e7863e6d33647745cf5086558032d4b05616fdfce23930366fba5210bc4552cc2d78543f769289fbca1f89b8bc49828bf755a0da733d17d6ce5bbcf677889767606a86b6ea399502eef2d23bee304a27958feda8579195f60e52cd5dc4ab614510899a0287d99ea02d3736b37be2d5697232885e043f5cdd8f19763a08c1ea6452ededeafcdac9755a56ef1bf0dbb6b5e2ec128fe12af7f2d99c397d994272549a4290d3ca13b628292409e2a19ed2a239cfc8ffb4283713c0cecc371639fb242fecfb86cbca11f8bb024d58060e5d940157527b1c38e82d7dbf5f8ce75e3c6047f401643261ffc4a2ba4a9de3539a3c92faec6de3e24a619670acef804e6b9f0f93d4a656efa31f9e18a8d86b22852417aa177b059c063fcb419f797b6306ba12afa7ce0cf20e2836e6e2e9062d39b892629a2cc9b57bcd60b473195a25a12bfd9b83ebe37b65f06c92550a8ccf7b4d90dc48deebde4df60b2b0beec019b610ac144a94464bbcf8293a8f0e7a988b9ee017c080175418bd8089d123e8b97cad094eb737a3ce84f2aa019cb5c1f628b9fb5a8c370a3cb0f416ecf62a63d652c0c3ebc98687e779cdefbef07e51ec0de49e8507b43f4fcf54df0629bff41248488b7ae4507b3e1a54daf7d22ea1817c8baba2ef5bf5750e9889d6a3e7dd90e18e66038978ad7c004d133cc8f7951bdac60c3641348446096d89e406b39002df396f8574cecee60396c86943ba8dcf41012d5559f43107e08c1dc275466011977235d32c394097fa19df89ca4f1ec825b5b84530cafb05da337127bf64e97b1e327d425a8baa309d949f5f695aa7aadf5b3d1bd86d40b8095101822dd6168d4ca3346d4f59f04eba223ead33478cde502755a9ad1478d63611ac6f64b99e686332eeb037893866f6f35d060fcb6f5a306c539c8c038bb69d9b8323704eb00707ab9be7ac2f6f938e96ac990caa66e648d9b8e13f06e27746d4fe3b15988b67ab9e5da86e7c9a8d63b6587c88c1cf7c3b9db095648184bf8c045ca4b840d013becec8ceb6b2fc86b133330767c559170b3a12b66bf756e5c047c3cf400838cbc2945b7c122740ae4ffabff4bfa00b1678ccc71d9c8f61ab37944f81dcd96977d7458aa07f4bad98782e67b013f0c514699a5ef0ef640d6189d7c5a22d3192b0312002de6ea4eb9f69d2d94d2535166c4e8112507dc755eae58ccc6e108ceb2f76033b4d00c0a940681e7ac7e44019ad0c9b44330a4e6cd856b3a14a1aa302b4d4e8a61732f0dfd9b03794e83cd8f65a94fe0743d6cc2f98124e826c9d79748422baec41a661c690dc381b62727ebf384115a71848c59508dd63cfa50fd9fea1bf648ed701817b1001fb3ab8084a1a3130c881aac09f4dd631c84c40639b7797fd0215a8e5772105bbaa1ed355abc8ca5aaf492eb747fee93164a9163421cd21d1cbad74f19f99dcffe12333e22d777b873ce9d16bd9a9edf7894aa469b48faec88d2698bbb41436d1b05b8e6ab758874894b16e7680998d6a400d5b4545f05624118d19261a3455d0d5d1815bfdf5957d0663ecc3331983717cc8bfe0f33a7c2436a3e07ca9480583833fc43e96564dc1e8202fec134b1469dc13603d56cf58ee14cdcea39d1eb9f8049b396844330e842878f71eed3fe90c63b76abeb1178ac8f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
