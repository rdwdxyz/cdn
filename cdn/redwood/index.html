<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8275f0681ca247e389623bcba420fe58713a47d3b8bbc71c74f9f09a479099ede0aaef0f4e632dd6a0cb9420920cc4b4bc37afaf2fbb129cfa224f0c3a24834bb266921ee297f0ea291503254cbf9f8e1a5fc9c41bbf30c55fd15957c7a63236c73a69985ada3c14523d62a4ed3a2a15d774f27bcdbdbd938079c28e7b3c8903382c6557abf8d5d69eba0eca07b6df3a5c1d69f9ff81f081bf6efb7a6e59ca9676ad33159462c0ea4cb6715d12d8e54d9fe963fea2dbe6f1a677b28f6eb6bbd5a7244de23c27cfdc69114c26e9138bc17e936ff5dbfa57cf5f2ff76c1a9ff76e092595e87a4ad0537c31ef51e026e221b2f14cca3c14335c77b53fe0826bbfab79c5cd5dd00665064079f4a7d44f414422c04fc1eba78c3b18e647ac468a8441923dd00284118b3a85cb1fb19d2838f14b0a4bd6b1ab06842288643a8b7f2f28d01134d76e21b076d8d8ab561dfe78a92a096de07709ef55b5fa8b1d36ed1866c1f65b5ae776218439671ea10b05458bb7f322db1e9ba4de50dfbb6355ff1bc9759565f96e052999919d8b9cc38010635389cbea79b4056e0fcfe8997bf1bc4d4c199a09cd79a2d09f6b2e4adfc3d115202768b30e0bea8b5482931e551da33bf0a683822f9e3cec8355f6ff8b00a47b50cf50bd30be33f17b4b825823bc2335c2412e90317c70a82fab4e617a5a89c6b5918c523dc7cfe23ec85f45ac95b4d13a859615ad8a97aab904774fb4ce50f9d3341a49ca58dee4a043f2a119e1f5d2ca730a355594ee3ae2f22ee51d26199a5b3ede05968fb30c85700ef21b07fe55f2cde2f642acef979a115d692ed7d862782fe4f1a3ee46c8ec5007ff3fa6e0fc6c169a3c3a5b58874c0e95909c2c6a2a42ae92a7981df643947789b0e29605e48928be3a874dacad8f64707cc45daeea3846ca494634778a4ada7134a87db9f189bb539538e8d61c4ae92ef4038be80b01ff41c50515b8223731d583b22e8995652caac11e457f2f2d678abc0bc53546f34bb118a98abce66e11f432ecc8fa4ea6640b3a07a0eab477dfa6fcf74c1e9f3f20ae7e42b5e808d2cc47b8a4c2a9ef8570e463c1ceb59ef502d7c56783ba6d1a91153bc7d9e6e1762b752ab8eb3f0c1aaf57befcaf2f08e4a47444ffad0ea9900ad374581724a23f8d6b7d727e6dfee63640fe8acb27dcbcf9342a2e5e47b54efd985f61ece0d48ff3bd445b12f9c29cc08eaf8ab982f2b29dfbb20a89ce4c0438e57f0ef11897c6853121cfe56cba7eaa3dac3d9164c20dd4827c986d4d582c78394474ac9b89267671b8eb814827822e72787f55468c06b17e7f2a572fe36125d3736a8ced79df06a8562cbe7955fabeb9aacf6cbf4203d1d5c96c13a361d52e696f82bd1d496e07ee2e7ba657b409c1290d7793244b0ae7437f545461cb40ac39bea2ea759bec343ff24322ee14e5313e3ab64c236fd9c14fd3d444aca3a0a9a1b97df695373b5669a9beefb047181c2b0c0a0fd5a343404babbd3d5a6998d1fb8eced7a48b7ece28fafca0105868d80913341439a2e8d72454e47e8cec63b7b0bb023cceac63f917ed0dc18c8d38bb4d2e370fb105aba455fce0eca980a26d4eeae6a60781b3df7d89b8a3d70719a7f1cd4b47e630f6067bc7f0c83d5ecc8d0518203538d4996f5a02bf1cbdc33154b4e2149f044d127fffcf9fc1906185a073b19659a659427fdbc8090192585d55aabe7f1d369f09856cf7e513f5ae10a3bef7c3dfc872f0a80e346d96643dca470ae96be3901d484a4b7cccaf66b7a1d8618a736facec9513eb7e1f996e4d140d2b60b720a7d01f675bbbf9a7e3500c833e689a86bed0fc75554803780c3237a5525217803676c8588762de16ec468a4fc32e26973f54bc11d8c0cabcb9f364cf8298951710eb9ac36ba30995fdf1b57a1be07ca49490da8c308d3c9f22d106623f02f53af0d5f1412e94b0df56d2f418f7835dd8289d9dced23f82a921300a6a3b16870ba83d1beb915c7d74b28f20085d3879c80ff28c6d4050356c0d50e7eaf80bc425dd50322312ff7ac83671fa02a8e95db496b6b6d4ddb2bcf93aa62b1e552bdebb93fcce7fea71c7cc1a47f3b0ab6efffe0dceee63be8245674f01be7eb74ad0a74812afd7e8a0b339e97951d74f9339e21d5c970f57a2913b38fe48786fa649b53cebdd6d2f62cf3a6ed46098904538790c1f917e067fe119125849798dd4fdc064397dd4aa87194f5cd7aab2bbddbec9c036f12d746084f1c21c84f66883b57a4354ba00c12ae5d2fc31e047a82017ccc029b300a1fb017abda836ed832db376163d0902acd7d0db40a3da551ca3e224fd5aef8af4676b20e53e824ea455c2e44e5b912e329627bfceccff0e78e5caee668be9e63dd8a3f0499425f5921deb1cb2d1c3fc618b871eee3fae4dd890497f3213bea1941097ab23056bfb884e4ace90238d3ba4c4dcb07ab450af196d7564d8e74befdfb2edd6f775a3f9506f45d2374e57694d215037d0091a900203291ef6a01c37dcc53d3c4d83240c0f0f57b93b2dea20b8b29892ab26f68787284a1053870cba45bce89753b9cacecc1ff8ffc0315df40b124948a5df5b6b22f557e0ebcb9868ccd644a38bb024774cd63ca755002574a1e8e387b4f754cb562705663e11a2d10a38be9faea7cc8898bb005f9b9967db259b93677d5817bfe4f57171c17bd8ac04ae9acaceb1bc11e0e044994987a6f8dec75d3084d4c14b23f3103c2308a3d2dae0fadeceac6f05aef89285e8e09d79d96549c028275934a6065c479ca73d857e6e47253ad99b981fc593dbfe84b81929768a39bc33f6f8ef68f10f04d507b827b700dda0ba3c0b960953cd105fbb81f6b71aaf9240d8f28b22052f40613bb850d784d04f697d896a7a5bd90176461352fdc3c7aad8cf83d12592eea5ad1f4e811a1289c4c36bebc2381521f60dfdcf931eb4b13e48e6b4c82f9a6e72486550d3d2ee90c572abdb1adb3cfae58e5b89268bb3061d56bfa41763913e5ab177bab8b154abcc8d97cde3a6059a3acb864e2b1b6955683f13ffb889bb83444730312cfa400604b2a46e961da70b5d15694f5f20857ebcda996f2df4275e67b046cc61ba7567d5e9e120461d3e12d46ebc4d45ba662606756fcf44ba44b2328c151760ce62468ae49f39cea8d7a99f3f3c8690d5d2869e57a5c1e10959dc282e0539f03f46ad4c84bb835e04a5029e447f22013e62ec94c5003a0d34d673722453b0d218b4b63e03f6feac7ea55e34834eb38071f27763dc35953914fd86ecaf7489122895349d606214e2328d2220d54ed040c5c284281c25d29572f03db1215822c152d8e7a16a5aef5489e178b807cce7cb7078abd012fc798d1ae7b9cc142f793fec458da83d5427894a92000d791e934ca29b0fcd5d547e4c91913b70746677306999e6e1e9ea6f3543118f474c139a7f5ae1b160b8b56d87352fda358a46f1734aa5bc4bc86b62c40451729dab0f0dd6ebadd96b828a69087e5534f71bdf3a3dddb0edde87c1247a710366d2997438fb1ae5b6477a3ad3b023d761603d69f4ec74a13df4a15402ed92fcb4ebeb8ae2bddd6a4570c2db5851d427080619da530c09b68e813bb59505f6108a83beee672035a0122ed3b6ee882386e709d4aa5467da7e22bd65d1201753ee9af3d9fabdc393324f76a9785a9c2585e900091ba7e2bbc09eb9cb709fb99f070be3cf7b2c045902ea2d1a0ee9b7778b687ac1c4d982d2da6a9603ce3953c67ddb88e7175e854c2869f0845dfe74a74c7d20e462b2e09ba3c4669df6c161e83f6ef91856554dfa1a407150197025cd9a1765babbf33922c28d860eba2644691017e4285364f8fa61d0d20a14c77977a5a7b8573393ab6eaaf0e70e9c158bbe0c5af3bcb1b3fb976ce58aef78d220de18984faef17b7b890c6495c4d2a5751d520ccb713f47347141a0f9de9d4f7684d8ff50d64738edacb5e7c5e43af6f93223f853cf2b0233509d9119ea5a67d177593ca3f81f2c55d126a8c19e056e3f8cce7b804e4bc0003e3b7f0d74927986c6299d702ab699516a127820924a8d1e0660343f6ae8c1383e9f52c43c0b631ace767d37e7daa25928b598432d7170e7fd3152817f044ac2dfa5efbf230e622253f1db2d4bb43b0ec3490bf81234f494b172c2933f675804d29d79c55135cf0222555cff62dc5e56cc74a91c0351c33da66af629b3379c393d1e1842a975d099c644c7474663983cda260bb7f02c7e27ff098deb8751219f267c9d82e10a35dae9c17b0324f2a554110a248a07026807dd6b2af7c5b6a8a85b9057ffd6393643bfc48b791976ad8ee4258c2c65558b4a8c93177714938ab4e1d0a2c06cb0854228c1202bc1a1f58467706e170312534dfc77d74be420d61a6e7b45e79a7c271149ccf315962daeb48a2e9ede9082485a6b34941b9588ab47fb760a88d3d5ac38343d6338b57755fc7fdac037a372411d2795dbe85b38d95aed7666d5c312b700ae351d26b9c2cececf37fe7c8895ef66496cf36a005bf63038ea77fc9fa10446d2c7ba93c3533befe8ebaa712b4b816cbc2722f455e23436b5760db274c39fe08d020d2f70d801f7ac1a5136364145982c87569a6d2e3fa2204dcd316b852296e1a1e6e68340d67b6006ad31dd34fd15d5ab15ce97ab7b58071b326b032d7006378b2c9000d1ffaafe0dea097835e0daf6acd4bdce2f35fe133720a0ea1f78935d049c950a338aff7b9cb5d89e2e4b26d817235ac5dfb748a6b0ee1182c585169e8345ebb43271c1fecef4565ded07277c2900c1780be13c10f137970e9e9fe31f706bb84b04d882f9868eacb17098715caefe0224689beb05defeb51741ef0ee68ed04de9552fef1eced565cf1ddc74061706bc04a302c9d158d80760c4c6a73c9f0c43071a48246996b2200c0e825bec104ac9de3dbe2d557dcd084d971c61c29cf305d8de48c76b11c138380ce9a3a148d838ad18b92836f618b2ac6a977d39b841119764bf8061353c0a447eb495266c8654faec95df26ec99df7df56c7f0b8019c5fa76e19ef0bf6dca96188a96f7c033af571547feb60e0d051e75b94eade62ff86b2163b9fe89349ab7cb911cdbb8ca57dd8421ddcbb5a2c4ca18d913f675ae114680b74c23e9a01f064d86d76c485f9cba5ee00a6091f21646a84052b47e6e938212cd95ff98bb437d9f011eef44e16bb266f60b532c1959f2c8f90c120e835258854500a734a26e4a7bbd4b973ae7cd9e874aeb624f0a02f2f605b84ed58561b9e587906ebab272de89ad60922a424111af6beb711ec11fa5c9ed708b63ab99686da2c50ceea40c011208a31a17b68d49dc15796eac75cbfee7c3685dbea8bf71bdca53ab36185671a7082a74053ecb28dbe4af0e558fd77bdf06fc1726fed647c3d0fe9d9efa7cd4161591cf5076f4ded51423f054e459f05b1b1123f6d6c1c7d696f8201be19a69724279097fcc76fc282bc482a9a6f1218438c9db716067a8e56ea0c70b5d952eba8bd7344186655cdf6048714ef251fc855b455bec8558b5af0edc6d8e13bbfd3c1414b815c808d6c60a6d3c1f02ea480ea0409ec069d1ccc3d92c465ead4f3066c6a519b935b35aadb24758c0b702c200072fd144726c437f3a358218268ef4579f51478695806b4cfcbe06dae1839365642c090ebc2e7d9cf1f71f8419ec4dff5e7043cd705dfcb4e05f1946623c113d90798f2496b7c4670e1344d71d482113544852b0990231227e7179c82e250133c113b4cf252c9a59deff2370b7d4d075bead4db887b21c553d97e9ba2e782de74ea52224f2304fbd94ac8bb0bbc17d2839b5e920e837b3d57b250228ca8fb6da513994e7e0eac954cb9aa283e8b38f7d9355ac56e62d34937d5aeaea5befa878c7462663f1be8895e2adac10b09f1aff9ee9b5c9a0071cf379e1e963aeb13d8b554ae22da28208ee083086a5626a52c021aa7c69df20f15061417ebc33cd75697fc9bb5b539243e47e620a9046a93aed8cf86f5fe4452d05975093f91459877cca736e97480cf48454e2c588e5589a892bf004ccbd7e759b7f147d6364ad15626f8d7eb1aadd73e7cd627e4a89c620b98c34486944106a618ace5f6b789fb9ee1bb45a53217fb153ba0015ebbb8e62208b5b18f0890026f37960b15def7c5787a1605cba9891041517e2697ab89bc29026e833fd25a6b3f6fb565cad60bdaa201e93bd455db97aefd8e946831b22ea62091c4b961144e930494f0250d28bb436b410600be625e0c8e1f5533fca41ea22fc2314e0927ccc5cec1508a493c3d90be3f0d54a693a1c9b21d71487f02dd248ef8846c09517514943cd33b2c6ce1c825f5fe6499e78e7388ad11e4c91ebda9187704fdefae8bc24632434697de3bdf630f5bd5643abdb8aa984121be3eba83316d25ac96a6ea6cd001e0cff1324fea16c612c4bc8a380e49391eec9eb44c3f6ce032179d3593fd2c66909b735318a2cd7efce5953fa3232b12746fe1db17ddb228f394bdd39bfbdedf0629904c831515d72cdc7a64ace0a4cfb41797c2d54b0285968334ccebddbe1a86be67e97bd0dc8af1b99b14ae15af122d6de177155a1bf8005e8812f02344e954e8427fd3a82040fe7b7a9b9febe1949f156c895379d1040d7b8e9e683f9b1e7cd847c58875b98244ffabf09f435ae2a1fe03b8b5666e5084e27d73cb5b64f93ba3fee35d6ff9597c97109cd2246993bcf29836e0c72bf7ae0384ec3ffc668f7dad2fc1c2ed78a0069147d30043392839a440cc4b1b16867a017aacb72b9a1429a0da225b4947d9a3074585a27cbfd7b746a92c23f8387fec2a6a9d935428fa291676c9be76feec643d3477ab9166f3f858ed0265604613a9f5b94513785edeebe1e68b17ea34177945817d576891169c1f1260237bd195d4127920e28e50733a0db145bb8be6672d6c5b21569295193b822888634b861cab800252dd4a6cfa9f283fcc0ca6c9f0600bcfba81c3850f841873d631c30801366efdf4be83c944aafb56aca60d27b0ffbc105dffbf27c29561b7fe09194cf01ab5d890ed3b34b91841f0198503f725e7eb7859bc6d26d5c4730531e5a23dcda010cc25ec728867a6dcabcd1b45b772daa07c9d568ff6c9cec2168537b2ee79c5b8e6d8162681773719d1eaa3253ee55d6147b01029731ca5fdb177278587da381cdbca549c18666565b86eaa5bde09daf7244fb5e1c30e296fe0cb61628309cf382694e643c6a7f2313a5ac778647ada570da2686f859320fe523f2c09870d4b3c65753c5c4fddc0692f301e0eb650b6312c92e6284b8decb72af32712a526c5e3329490205314127b4b1217beaecfd3cab86c390a9d9f9bb79a3bc8c127803d35c990b9c32162c277eeee5c56740a22f0b860e6cee9d305d8700eb44398bcb02774387c7561e3b87302ab566c03921245d6fa221e7162f3f5d37e4017644d415556b8039c4de696a58bd1ca490d6848112dd3719973f20d9e5f731f354ead79d141321cfaaa7790ec8187d6a83131d27370e5888ac919cae582bd6f644c6953153a85a756bb3c5b573b769b2df64d78ef371ffcbf527fba75f62b13bc15e529afe50694a9cb6277b65f9df43e14237eea1036ede1ffaeabfbba0f21faea97a54a5a876a9f737a500bdb8ce4b66abe6d68699747c8806d455869397c8e7652896f15da4acf8ee58aab1cd74d317ccda655501e555a0dd672ec90032595deba41f550c116f817db78ad3f61c2cf7975af373f8afdefab7a820d4b09daccd73f43e347aead6e949253c0d629e258a4d286ca9c1f73a145760e0e14c4b7a744f28721c3fc15f8deae2d6d0fff424873673cf40bc9014811ccdf9ec0015cfbfe9ee3275bb9af73eed4814cd831ef463730bc10fdfc01c58089d9ac50d5bc91401f01dc744071c3a422563b64cea1ad30874fa73316e4d6485250a1e1d3d109cba649244e1eba86adaab4747d67c3ad2efd09d0bca7d28a8eaa2be45ee5958543914eb8b80758e9395376a0c7b4ced7a6c70e3a3990e15f6deb97d67b87377bfa1d1ce30a7d792f94767a7b68d8af48c16479410432086068d61da0f01337707c5d330e15679f01c89a89b43bbf365d21b1c7255b9eec1116c9281b50161a65a814c97f8271715cc84550ad4d379fe063a3e41cea543434895a2fbb1842ba3a51e123be4baef9ddf6d0199a9d8d101d323a96b9f33d0360f1670e44060918a2224312b9e855e73abe5e34435196006d5bc0075c8c39fbd6ebd96adc15975e10812497dea01cf427f8b7eaac5efc33a564a20155fcdfa67b46e2d7a7e0e1a9985d0d3f71d0338f6e091b597de0fe5b0efdf8f3a08463d7fd76f74454fa7d92f250e30deb94edb1e968ffa6a1fd81893d14bcee193d37fe22f1a68fff87464e73c909193b970a6f6911f09490afc2aed6cccf28ed3aad03e32d8c6752f3657112bece8f8d6fb02aff9db2bd7c86d13048927572465aa34de7eac4947b24b61c814e192e010d5bb46e3337aab853659c4a7053e9bdfc89a2da843ed08b7471c70abe990020c03b9a69dd1e2736ac387354509115ad819d732babae7591d2e97460c34f450b21950736f9cee551b46ea3b2f1b9a1da4a333a75e6a2a360a429596261016e0eab081fba33b4704f2d7b0bfe5d7b504c1402049d488f39a5e77761e6a09f57aa779a91711a9f0c6f89b207856787f7961cf5a1b1b6d0f9ed97bc4dee2700fae6a1ea00fbf11cdd1bf0bb893e19175c0bdf7e2687034b4f10514cb6425da3d02480e287df27c087cd660f9e7c354abdbf7f5170dbdfa4c83974514cfa60dae2287f985de3ad03a4e47b57ec2a5754baddc21b1f08254a93775979bae837e51550810a243beda4e5d72461e3f2d5288688998a0fb8b387a05c5f427bff592e504d0c017d0cc7ee02e4528b01f1375c846b0eecf36c9b4f8b146b6be16306cca1ebdbe6a18f039ddb00b0f017c581152139415b02d8989618638f50368fb9f2f61f2813ca00ba10ec589b4a517b360eea520af3716198d3b4df9d96000afb5a173f36802fa2389a71dfee569085265955e16b53affaf188500c52fcfdf620845b033b9d8adc524513201422efe26eaaa7ffd0b04422b84da6b3734a867334166ccc8b11e2068ab5dc13791ead0b5944f18b1f96f66395e51e262d21e0c286dc39ecada48f02b581b0a4fbf3dbfc27b251737b2eda8bbc8cef52e44a144446608861b4c5f9b12ded9dfcb029dd1bacb5101e68bc138fcf6867d6d2ddc52eb1a6d6602b09193d321b0c5eabe9b617efd48d1d7009720bafb7ce76f6072f7b96975d626fbfbeb1b4edbe6dd986a1f05a0da4f87ab2a4e0d39204e4631bfb446da6a31dea957881f6f372dc80480b91145c7bd2ef20455c22c3fa020fdb3b862f5736133d336ed61c355971e95469c0cc28d0a322b7a86882ff67c366ed76653b13046dd9d5b04e1da8ad597d5579bc977df771fb14dd7b6a2983d990afcb2c60d30b5e566988e1bedb7544bd861307fafcfa9043a52cc860b0f9a70f9be7dfe8d08878c6eb662b5bb6ac42a5715c58fbf0cc5aca555d17b896ec0b32e686af065beef68048fd96afb1511111e32214cf637f214725215d5cf6d867c80f92875a07208fd8ac9d393ecb4198348ddd6c01513217230ca405153c40fbc148bd6260c8cb7bbeeff16b00727897685c43a6b2d1ec963035919befa17fefd15c8afba831505272218875536491db73bb6f7dbfa2b76ae1ed80f78dc95ca6e31bb7b94d76b893c117109cc12169303a3cda65e3eafca6a6407bf77fa77bb0f9833d13812be4fabdb2d126c8354e6828362cc6d510fa5a7c5dc78bbd4957982dd4877d060fc4f0a1dbf2d2f5d228b5832f68e790213b019a23789e325fd0d5d41e3ec7a0bc999d96f36864fc5d59d7fe71f49b94a314089ce054092667519f8a07c86291faedf414c438877e1cf62f0f236db0f475adbe1433c4126d8d8e9c0d41e91dd9357c599b806caf01aa01f57637fae655b4ac7fbfd9b929e69e810da4da26722f4286da94aced58ec11e8040f150c3ffd9a0b4882268f4fb25a0ed8573af701c7bd88ec78f1b55b2742600ecbf6d1fd8f751edad532cf3a8e40c8ee83e4cae077849064ce00a767c1a37e1c41cfb87afd7606b8cdcfa119641acc217070fd05d0fc230fc1c8446036af9083b5e617535cd3afffe3f3dc0e4699d12604128837320e55b9b691b791b1a1b8723dfdd4596102ac1fb1dddb8c9e44efb13694ca3c19156866ff50e5636a301fc488b1a60e91453e2080014651b64df5f2f5b648d4a8c1adc25f5e846610de88eb80a50f5ee437af89bcbb9034a665c4673b5af075c283648f3ca5a105b29cec8f41026c28036a9759427c86a2147a6971bbdf283b915c5088fe861dc192f5a96f038e7f55409a7c0692844ac3cd02dc7a314b802340907c23cbf5a8fac797c62caba06decc98b1c1a44969e7a1feffab9696073661b01ab5d46d6fb44ab0ebfc38f2267dcca69b5260cfd5222d2a6dc80adaaf6d4a019c3127c349a39c31a084502d0c0dd1c88a1f708b7198eab044ca4ffaf7515c2c3a76c0b9e28422d6036e9f2c8c1e4a1ee5b265cbbdcd093ea2fd58d94201dc132ac9e310dac67bfbda228e1e9b7b88524cf9f74bc53bacfa5920a3018e2d16ad4f558a66672340440034f0fa02572393f42b56da89c24e3343aa9a8cb02dd2217a2d53e12837942ca3cdddbb328e8201a31b986da63b1ce1d4f92396274b6d34dbb17d729931de9daedfa34b5651b65f18d6fcc1dce2edadf849a982d898ee7fd150ba7834d6342d0ca6027118fc8bd940cfe8eb686f2fe80d9568d587e20b6d1e099bf5da53db24a6b9e9f00b1db5316d05841f8522fce2576fdd27ad43ec6b34aa470642346c4e141824dbb9c5d8b2a60ebd8909914235110d12f94e7f5097723afc5977a3e11458c9e48221f305d705ed7b66ae6dc3f8bc4fcbf0e7a3fa90312a2b3aeaf32977b2ec608459f500b97055677d3a16104138fbdede7f176c80e20785479f7d94d905ca077d07ab4b1628e352865ee6e0a643ffe3550820287da0636a184cbea01327ddc296f65bee79c0b19787d6a16730e9064b83d0196249fc5e71e38124af1e94a5be5a53fdcf4f5b9d634813155a3d09db761d54d7124e6dd18fe421b488282d75ecb3cbaa8df734e4cb52c721f8aa66a35e7ed9589e1ba902e473533f776cfa3f893cceed4c56e20b491181f2cf4ea4053c0f3525e353f8127e0a409d83a0167acc75b53b6e130ccc22090827a8ccb9a9f04584111ee8d27f9733cfa502ca2226c661d84e870c0d69a60218099274bf0edd5b48f178b7843ba743609602f9ee8c1bef2eff48ba5f925cd16c9570a2c24604ed9fbe4568c98a3b9ee3f896150cda0af238aa81c5370c32c2657f74ba0d7bd1c1bba4579af6b6e6584a37f085babed990c3fab02f3a41fdea7fddf79a34be590f869b20d33b28e3271e1cd4a76cd4283aa6952944771020099719212faf3f03f768da1c475674a3391a491e191c3b732ad9cd9d7d9270fb7014c74b183fa95f6c6809d9c54091ef9e8e3a3777f3615159812119da7c1ff2fa974b1bb55ce8e63f9d33379b66f86264812db83c3a144af8dbe81ff248490b62c9dfae5a8220b05a44f9237f684edf364a5ace08d95ecde33cdda95c6498432d87fbdff4b41491a0404400e8b2b1fc47e7c21978b53008361f922f9001de433b1b160a4b519eae26068c713127a26d4f65711eb03da297e3f6e482b851efae31f87b5a2521be29f70d5e4c4cd6d8d9fd47c417f053831045daa90d827c3ef750f4fc72ca8536ef55275a24546fd3cd38fd65cb6f684e6b58d86d82998e74fe46144ce75794c7232f9d09930ea00c2a3b442eab996f6a4c2a10456e98beba96db8ff502524d71c65961bf0e487b2b2519f9b871647089f11ac8ec8d89000a15978e2f9935396858de827c016eb0d3a0265f19affcacf4ff6f4c6310a3437c6f77492c88307b88084030d3473ceaeb60a627842747ec12b545fcdcf33abe384012167c44dfbad333e03fa13f6ea3096b751ae1f0e99bacdc9817fd08f34ba771670f3c9163d3adfb545ccfce0ca88e849f5380cbc9fb4279a4c882ec572c156bbcc761ac9e74957a952950dc6d7a6c57670f97ff7c2f8fc6e5ee4028b4c2bba73917c4de0e20c80abbf7e96406d66d5a962f4c612ad7bdd95b13dda79f079ac6841d9faced955863a44530bd0d93277092342f8274436780569473f8da3033303839aee7522e42b18ad9d9460f4840b3b4c8b97958163e0eff4c298611798bf7aeef7236f2dba18f8f34f68c8174077c5d79c0b4249e53527499757d28d16333b8168d71996b20a368196a6cc0c88a75b998e9a56c4b4ee1433e3100f81fd88ce7a679b9ffbf0be7257eaecb98026522633353525400890b550cc290f8d1067c9f03a85475919c020c21af78c59e7be9b96547995f6e3fcac347d45920f9a3234759a2a215a9e81f3297a6824c3e537b5a0ca985a59edca5741367b8d8fcce512f127dafb5f5222d78c8c9b07f20bb5e9670c16ee3022f654767d820f5fdb7e75bfac1abef496874a045b81b79d2d5be337cfde6f1d667fef7b90541216066b0d0bfde0e90d4e9660c2c55251a6b7f2943f6856772a5ad7e1587d268731ef42ff8fcf6d3507ae447bd7cc6117344ddfc7299272e445b410ff26c9b8b5bca77b0e078169ae3f169fbf4fde88083274ce255ab953bee67076e66a680932510a49ba1ffb1a4340f2318f976fa3b73a4847600d61545d37f293ab6364acbd10942fd3612f64310ae6efa8b6a1551e4fcd79c3116029dacbde0054dc4c725c8d1f602129978fbcf3e737f4d41b37c666b5da65715a9901bbfad1e30c9300d2221f14de9887b51d4a5ca22d4456054b33592256780f7e7a16d107fa5d6229d8e2b588ed4150d590115733566fc86571e5a6523c912381f0c3423e15105fd60802af8dbcaae32832dabd0891d139ba8882ab166ba654c7ecbfb9fda5a947af06e2b42ada1941f24f8d39cf4655268193acd412fd1d88484bdbf0354e41e5fef397bae35f5c67c58fa5c15edced79a7712b94522602c7184622e2879897ef53fd2a958b2b5d1cb8e3ca0e4e4cdd16efe77eb64e7475d91c8161e5fec803f4fc3291a4cef9ef8eb7be6c9ab200d2d8ace9b80bb2d298b4737f5249666354781b07d1f7f26f4a4be9f2295c7075df9c512af41429efe68d9d04fe978abeb55bc3fffd49403949b57284e3affa0135ebd3adfb5c975cc13fbb8248a39089e754b10b58885a99719bbd4a0a1fba217ca49e44d5f1474889157820a8fce615222213091793a63ce35cafd6894b8418f0a057b55d0356b179915693b4f86bda1473322799b9f3e66a139fcd19259c1d22d77fd32b67f665baebe120f6202bf0a712d38a503a4fc90a5e7642b915622754e22907a1a43d0957046615570678e80e972c1744b96da35a812490745269f5607b616371b28554c649b575ffc0b390ae357f8307a2266d0010ac1ef11ff5a8add3a771d5b75c51a39541e14faff75a4a74a353c49e48ec47eaaae77f1c8c5f07c54705ea9b7d98d7dcbcb6736a82f4cb6a466ccc96498e89a0257ba80af9805db71f15c459587d5f7c7fdd468bd5f21c2fed404242db32922639ec6057604ac077f5c549c9819c2c2f7208fd647dea9d0ab2934f1f8b2f0405d11414d7a73b3fbd2959d24f7c035d8396d15693f474a165872e54cba72c5ded4d51e48f48677fa2e8da9606e64d863dcd4f7883ed29316ffca0a37f6c51e22b7a93b7229d1a503b1179afc55a676451894c7251fc2b0cf437ed0ecc26d9df90aadf38e2e88cb0f842259c218c5ae84d2cd0848d958921f0f761b53e63e3453e8220d2c8541519a39391531db39b0a0a31f30f1d677877951ed5677f47a033ec58e48a6ca7027957c301431689e51960c4f689bdb7329987f27caa07c36e90c9f65ca92191de67de2d1faa1793850078b7ef275e6ad3079e2f17d620925a06f65fdb8c36c5334e5199679cafd41674fe3a85d32ee59d04b8abd29cff28555ff240ca14eaf5d6d24af4a456ecbd95963c988b90fd1ef5d83421915fdde333a1419fa8dabd8c07572036ef7dbd2b4fb9fd2ba9138bf63f363b8a4063b7b39735798354ca795aec0049f3fa972fbabb6542b086c8159801886e0e4b1ccf4fb7127820d92e776f139e3e4ee9b67afd3d18d3dba1a058cbba10f8f3cccbb02c827526ce93efdeca7fa2723b24c7d9d24e41a03f86d6ff27c545d42748b75264e097fc32a8b8fdccd28d232c308dcf6eb12246a29005b79f6c5f7c1710456f15646e8574e877e50c0f45113426281c4797be97bd15efd731d913e31746f750f9dd05f12110ddc67ef68aa97b3c3fef31a4789fa1fa7d46afc7f9c692d7251beb9782cc6af1a6adfdfcae69afb1b01cddf8539e7d8fe9c351b30ee55c1619f5c491d68ec89272fb0a966409e69029f65fc307e53e20f6df5504a83e2f5dcf581e192d9663dbfef84a6038b9623c14cca3b6c37cffb12d5009905a3c49ae31d0981adf2e3fce8744b7633c17f04e307862adc0213f4b24583fc21d484ed3e7d9d8d5fb89f9edff7dd3aef9b18cf79be3ad529d2f036ddf670c48bfef152ebc890cd25fbdbedb6411931c393cfb139e017025301c1fe377260a26cd6e1cf93afcef94193c189c09e07b4ee76207669d16a4d5aefade3cd3a0d6bc9dd58a4464c35a4aad0928077c4010d46cea676472c4e178d023e40996e1c74b75f8196ad6002208912281be7835933ea023b14e5e1d49e1186c41067b55bd8058e6b954da2597bdf52db651e48ba0d59a7999fb4dd4bbf165382bf498f009b900936255b63ed942b9181c87617c71104bc669f5c630f2e956c515a729ddbb79a0a7de7c35e14132d67020a18a34af24958a257012fba7d39a9b5505105cab2ddbe7f2fa2ad1afeedbabd3e94e06934b2ecb1deb51610e873bb59a6067604f051d617c668629a7624cd1160aec13b59dc88ac599153206823473dd15848d399d041d9d3397f88d0e2d953de952abb595b063abc08fcd2eaedd8c987859466531f10facfe8025bd494bee020d0c0be0a2d97811f9a5e4d2fccb15c6afbc6e06e22262add4cf4fbb8aef941707ee1fa4478df5f4a5696598aae9697f5aa0c74a9debc5046897b8ffcb6fe2e8642cb412d9e6d666b9456bfa114f17b4ad95fae456b2354fe5e6ce4d094b4d99a7181a2eb4a438fbb87477f72ba0457fdce8ffb11d011f910d2c61c278d939b52185297aed64b9652bee087982611c300c96ff034a85d668311cf9db3a18555d1fe0b516800431942cb41553c5f3db9c2f3c154ceca7ff94434e359e5ffc0c6ea75c02ee1f4a869058a387ab07b4b08f7a658dff4b4bcc7d8af36460a9b05aa8ef40f555dadfefbf2a7e16f2aed50a97f6ae167a0bf984a38ff0cf8da0f9bb951d939c76a3b9af96f7a0e8bc03654335cdef5727f99b26ce55a0e8682de7ffc500784c977f2219909c7d582c4fa5d52ac55e2da0b546fcff5a5738c34d5d9b1028937de07586030df0a1e41691a68594511c3aaa2df2845b816c2bf7981207900303dc0189ab7349a048e11de2877d327df9a720b4bc999f72378d9be0cd6ced0044f795cf1c40fbdf99a2247e2408350f842fca9cfafd8d1207e81082669592c8beea9c865e079d0ca67dbff752264493f21de5bde3120522a102d30471530552614f5377166779140e2f5dfab4d4c0335ee755f0ac63b154d98ff22b24eb714d51fada764a2c0a01f9fc3a049009830852c0980725e5302f8d954c9ab5baf85294cd4a21c7e3917803e8536103412933ebecc32be53e943de9634d52ac196a009b27e83e7574b06cd0338c908bf45866ba36b059b1c8c15ac06d5b35f5d4fe5db79be973721f55e8a20058545d52ac82ddde56f7f889f240e176f244003266530585fe56a6c0239a68170541a8ad316a8dbdb4d6fc69c5678b5968ec82d921dd40b0df0235e1868aae5b4c97044b39cc1f043c4626e1bf7722037e4fc2305439373ddda858f63e2f05bb959d01a0c80398d57b9767dfa4c43e137bd2a33d462a54603ceb9a8650a6c8b803a8bb275340f14df6424c0fe5eb10c0b2b8e7c85f484f75881da549a0225b6363ed2f665d767ee39f73a76d680b72f2c85fce49a4e737ee09cb5bf05e272d9960cfc05d9d8daacb455e87f2bb6fc951472dfd2eda231f79f7b25ea3b3ffa394c92a86e7e2979affef1bae03c4cb30f9e16ccee9e0b807082d3789dace53e39b3c6a420b5c0f216d6104b4ba4d70e8386774ef3652af0c83fcf034e8aca220002835f5639a20873bd57679b9000588b4cd8d2d5c868e49aca10fa7775b701b41b143e32515d2f8de1f41597491a74204268fab0de331018881a968d2e549ec2253326fd14bae7bb4d1ee6f3064b6a4bfe4f2bc003d5280770528a732367f93a2b14c981582c09b5a2016b1abbe7318f768c4498fa99801a512adc04b9a9ae4507f99fbda325af5d8eaf6c02c0e6f0b98cbad949dd821c6a213ab9cb86427035eb4edda68f5bcfcfc8d9e715226be6f677523b12bc895ec16f49d34820cae31c7c8167f11950b7edf5b3dcf1220dd00ee45b87facb4f7da1f87fbbd2114487ad071d8a7a88302383ddadc4661422d7c96b14351c662ee25dc514c56ef6e24e36a0ce62fbaca28dbd485d34cd728c7830d6033b6aff77b8b67b29f5269298ecf486d0b70deaf9650c83c618e15106d1f1127436364e11588f96245e867177804346f1e1dac68d78c3a8d334bc1ef877a4d1521567cb8f37ebca7330f4c1e102b00a1ccc5988366cdd0914ad1c6ee577b3c34756c8d0be52650e2a80c6034bdfe08e558ab643d2cb638ae89f9228c8d250da167c271b5233cf05a8d9fc3531d7cab16d63f23dd1a081da47ddc9834c75cffec80fa6f660b48da07c298b117cfa68e76aae9ca416fa2602db764aa13b745bfd22c4f27885e220dee58ee777475a03db4c3d067cff55da523c4e87f0b70033eb1edaf193db8d03eb587d2444c0b71658a14a3bf976b15ab00c314d00ef82833a3124295689ae9c54d9391cc2feac310cef4cc0c81cd1e40a322bb1b2a20f06b2f33710a5e431d106defb8ea8df751e2da8b30383d36fbc06a290a36cdd70958eafda75914ee078cd08f25e58688ec97dbb3d7e14d655229fefee53723d980fb92e084856d78ec4e5dacc402aba3f0eb6b2da4af5c7664dc35de9fd18a4fbd6a122621f274f181c3d62268c6a1d8593f16bb0d7a09518dd8c3cddd87fede2cffeb872f4091856e423ced39b210bf42110fb3c7d801ca6b23ec58109901666dece08b54b0ca2579f598d3309efe1d972313d0cd1d8a90151a6ea09483c47b9942573efa7d6c20af3b35232cf9c21c57f1a6d34b434d7bbcb6dc2174ace61639dff45cdc55faee2ec7b03b446497e2fca6e5077a95b53bd7d3c1105ea981fa7b4aab96a110a65faceeec14ce706e0df6c7aec865d43c1c9d77ba38fb82bf8934cb83e664c01f247616b22920475537e8b8a5c57457998dbcf34d295e9da02c2f679627f3e5e8c72da211536f3e1447b45b0d4d791713a1e5d5906f9677c6014fb8e063afef9dd7d4bfe3f61decac0d511e5b1539386f212897535db383b07ecf624917dcd1b2b6199b4f94da81197220be8b16076272a2f65e95abd232cf276418bd2f545ba92c0b9ff70347d288c0c3d93fdeb3d19e84fa21952c7a5c5c81276c26393193d93edb2730604d1681fc282b400f1d063b1d51967cd1f676493f8edab8676aaf9874479548a3d16cfdc0012b9d8638ac8e3107e202a33afc003643774d7fa51c31c1cc60ffa3bfed100005c3cba8e563afd06fdb7a4fc5b1a35351f15da2b6569835d31b48ff3b8d38b38cee6e7aafa7a7983185ebc8dce8f73a7b68245f03f8d22ebfb1ec3aa4a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
