<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6b684f6857f947119e145ddf521ee14b7314be2aa6eec51e2b40e31e964239e87e65a636a251faddcb05224a195351068084c47de07baaa6350f3b3b6726262fb7ba5c4be4a56ceef5040d89a1323d073521d4bb04679bcced2d55ec643120c76476966044f7e4e90bf410fe2cb6db5b44b562baa0a4182b5ec999ff1dbd17a8786690f48de7653d8f10d23ac3a2e37b81d5addc5af1901f40da67fa67e011bc175acd565310df5047634bff4839b1b8875abe3f1bc283f6c8aa841c3449bb5ba58f34afd90527e884665d68ed56811c90aafd69368c4e5a79289e20efe0167401f56f938c9e35da6d5206d710d0f12efc014a6d66a9166d1047cf0ac49bc1de2c37eca42b9f97584de033cabfbc56698dd62d74dccd7758ac61c76e693868b6f9c98fa99895c68091ad6d70647613739467836decb78231bd049821b956be57578927c9c8328944963de601a53e1059bd0034a68fafaee19095a7a06dde9ac707f7a1912cb0f9f5e897c0f9bbcbd3c6accf209eff3cf48dcd2d05b0f696c198b730b084ed6876d743d866968650847cb18a034f306c42eecfd91a9d34a17fc61b19b29727af6151f7fd2677a781bbbccd514408c3d5b9a0a7e640d7b4ef671cb79d9ddf888a6f6d609250eec905d59fc618501483c291ce9302d46dbc4b1159b37987a3117d99b1c4f428494e2c77aee3f81b7b380e0c106e250d46fc86096aa8112ea4f8c70b397dbff17e66f0163759ab03780250c5f62f8e54ab3d6a885910e900c3230d4b612845aaf322efb99b850ffb3cd0938b95ea46b2b5f960032c1b648bc64516e6c9c3dec4b7c69dfa552c1c010f2e5ca36f5f3f1a7cf0de42c16d70f1f3c18b22f4ec70b4035065fcecbf6e774df33eef524a839add1c01e80c72a68fc9d4db03030902cbbdfa14f85e6fb5e1761da8f2ecf2b5efe29a500a66856ec6244af4dc448eb22174924360fb467d0d6c4b30c9b379d2adfc5fca166fd5bb8e4209f677c9fcd38c0018b9f9d57c77da0863c3a090201da23a50d86b851066e5ce18f50384b339b336ecd7e9fcc605b48704886c7d1d7f337bfa02db59840cec3192fff5c72847bdb4ba9186d22504cd4e2ac38a89dcb00f7820a423eba8484b5c9edbb3c17f80251e1e3779b8b8917cda3b83c49fbb1b05bc9f8acf987ac2ac18cfbbc7affeef664a82c47eef185eb7aaa5bb7c08221dd70ee7f5e71b3fcc05f8bdd6feeeaccd1979ea1775a1cdb8980de47a59d1556ea6ec092e2fe7f67a182534aa4e0a954ef8f8f0b90e2b286e6db3059a11caee8bbe16b4c0aecfb49e99e9c19968e7ebbc3d063b5f36e859eb8ec05a7048ef09b259d70dcb1b0859d2ebaf96556742af7caf44f3f673042f4f7d7d7abba95763754a7554e260dc5e731d26efe910dc93dcb9e0c9134ebc66a7aa5990a794e54032acbc33f9fbce70c15d035ed74095d3fd741cb052856b5c5dd90fafcb559d5d63cdf941586dbece286ca9899d8b3e2dea9d66567f2e79eb24707348195ec4998a62a7076e26353b104765cabe5fdb5410a67bb613cb1e6b03ed08c4d11443955f2a01d079ee6da638bdaaa24e3cb66fe71bd95bc27108a4f85f7ffa1f26134249050b6ae71b904d27eef66ac12b35c1485c03d8210a7f2e14b1ebef823c4a57df543d24383aee14d973a8c2f0a49b455c6e1ba7e278ae11fbbdaecb1d7f7b1922b8b561274cdc5392506337c5118d7b82e9212a3dbfa5053a67c9cb38eb5fa6b51affe6f2e9c7f2b5905f76eb958019129ed6540e15289aa24a14e2d6d95f25a933784a12367650a56e9cde0f55be13844cc8eb1ee350c158071d1faa8ee73af1db86eedbdd8e479e22898158a020841de9860eb4e5b68314c324b2f577c3709cbf7dd3fac576f333035650502f9e30ec2ef1ae56885cf34a813ba9caac9cb9563195f4e60b53838a8dd98f5bbe4ec821f1fbb4c8985c54a68dde268e113e3e99478af210f04ed60717d78dc6566d3b08e5bc5ed6d5735be77083170cf90fdb1cf973a33d7388a806747889cc0a43915b09984ea088641081624830dae0cbaf6ec7f3c90f8613a238e018066118092179addcfd4f1287cd5f703ea433d2fb2ef761cde3ce0f50410343f57e249f04ea35ccc5172bd601915b012938c05d38d001eb0883259abd4326f6c04b2a13b5cc1b163bd72435b0b9605923ce1228b330edbc7f96eac9e0d0b6c8179b0097154d9425b1d7d17a8b3cc88bb6837b0b68068c97a8fe976ad0695948b456faaf1d659ef4856a33a668e9c09ae440dd12e10c1363a2a87a6a835f39119dca36ea344ded5c66b3c51ed8dff3d0f7b854924b090c585a2e459e234a8ccc38c493ff1b8d125e895a679d7eda2f1f938f2ddaf22b608ced887509be83395ff01b9840be2f6524f1ad96abb9d157a4560c4795d38454c47211964ea5d9650d558dd550625b3016254e2c9d5857635b8b0334f3a4b36b46d311106888104e350a1f95063aa8693ab66ab854620d712238357bd3905d417fbafd3565b4017bc0f0ea99bddb869abddc89bafccf5f78ddfdff54467889423b38f4c6466cba8da5fce47c2fbc74d32fee9e45491aa7a6aa3a2b012ecf147ed06feffc9aabb4ca28ded1552778ee3fd48d5eabf89236f2cb1baa94d4fd27a7f9fc86a7c8c432fabcf65fadabd5f69a1cea82544e65d9915105b8c856dd1a70a81dca307a805ba36587e6a474887328513fc0fd2e5e0eec4ee655de071c8aa6ec4f50f416872cfd7d67c9bb6a5f5ea6dce86e56ac42e23de6c6e40273871b8049a1054924d4291da15407d9bf7e21533e2a80c49927162efa99a707a604f5e71404a55c8b40068cd4b851065aa4efbb70fe569291a553652ee5fa994ae1fef370514835d9d6d58fd58290d6924806a25a007cd13c3a2a8e7ce08c49ff1788914fac8749c7053f6696219ad5f5bd31f1d92a77d144c2b5ecfc229b2431e1eecff9b564abcee0ab660a1e3c2de04c2f0a7e759316016489be6a0a80e59a6b34d2382725c602257728f7b913a3e3449be1208925e5f5245d8dc4da430fbe08cfd2a53536cf44475f14d6a474b19632a5c73fabf5a849c9ef67dac5cfeeba6d5083603a2c6e427cf3a06559d62b490a5288dce8dfdbf92eeb7d76adc7ad672c1009054accfeb964bd6e7a4dfb34e73bfae82a5a491e386860a7215d221523752361e67f33b865d52f0a9fea54f8315323e4ea87af4ff68958fedcdb1b775534132fc781d1779d9fd526ced7e5862216dcd0a3c6cb1b852c8b45c4423f89eecce086ac3d58af1ccd3a81077dbe392e8052963d829ddd2e13998f4984346a2945658409c0c25a5721c5f7b249b7abd81c0fdb05e68403b388fe59fffe4d9650262ccfb73ee9752d8aa06d919d478b8434f8f55a7244c0ef8fa84cc8c58a915eaf7b3f7697c394c7c17281f2b3209e7d40ffca064049354fb8e4696a3aee508a32e1f133c575f0c70f5c6696ebd01a562d18b38dfe2be2aa46b47fb420dd7f5d4b8ad1cb1657100afe7c30d8d78d9613a265d2587790d4d90b413dbb8e0d8e18a62041832f12ee4b9773019e732005993bdcfcca2723f07dad759e393fdbd2d3b3477f4a6bf9d22865a041c3c67c101f588d6384748511a3f5c3006a1247e0a3f8e4d26cda09e46a092c2414e49f0317cca45208a6f7739ed2cd7f4e17f77c2429f6a22ab48799f4c2917136598621f64b91b993c66c1b46ae96c90ee2511da162886406eec8e22138c5948746c84d2705713bf9b5589337e900b6431010629026116ea8dcc9f515b9a349442226c95285d612d86b2b4b78d4b5bcea7285b599c5d34267e4ddc4a3af712988361f2c212f2761482bc5284da525698238d21b8e171171e4040b5aa3ecd35502c1528bf01eda816dfbe3b35a7185d085f0a22a8eb724b7ce2859c99f89a36d9f9a96e003bcbe6431d04f0a5781a18caa2054f34191cb892191535c19f41d5eda0f39fad26f976920a0eca9749e3ae8e532c14fdf1ce7cdb971b408abcdc499f99da232095b59ee9c69ee0b0d80de2d5dec1040a7b083919aee7f7355c2ed1fdf4572ed2c1cf5cfbaf33c2da96319bbaa8c158c6ba142b094a74151f3f7d39a1fbe80fb7a804bea942e90f6edba25c1103a52e0aca1df12b039b038703d256c8d4008b1f003a814aa54e6e95374eb97ca42ffb201ea8015a693127c1c9f80e1079a56c7a8a3aa6871b2e90a2677a5c70c2a2a69f31c8db8bd9a3bfdf6864fb87e44d4c843738b9d6f7e3cb0aff73af0580f170b3aaf0cb735a5f5c4c6cd209c380d2ee4ff89bde5f366fc75881ac6fe180a855d2d4927de3585d32a16c87a34355fd2e91537776d20ddad1084c92aff31eb40269fba47bbf1b06fe2e905f6bfe20e7456562855e8e114dea2675fbd0396783817680122761d690067bbab6525fad87a073a7652cd8647a58db7a65bab2ab916fc0c7aecff9c0e52265dfc37ef5bd0865b6b112221784956f1c30786faa70fd7a4c97612cfd34b4c9ea656a6a4d529a3e0120b6e29459af03d8c420153dfd6d34cd1bdc432ffc8c028bb196fac920d8e25844b9a0c944021a613c61c00c12a55aea8cca9a6980d5ec5fb758daa320af2b31f75c4449896e9ee06d707d285952d3b5a4abd3fb7478b07ad2e1b2e7b69adda4fea06fed5f2797032e99cddb7c353b01fc99475bef243bb69885211f56278894abc2b03eb615a66dcadbf95ca8ec5d0440ce330cdd33899733de74b5c61c7abf8cac1fe88205da81b191981d0d88319af020fe9258b30671e77ec52edce5947515afc139c26446e6e969b7666aa652f39e88a2a086d3c26a375ba7fb20533058bff80353c5d6f909a02b5aad221f265c973dc631118a9a5297fca4d46b9ba7c110052a656b0177213a8f3932c28c96e5106bb54e93602a55def7f3635f9aa9cf8443fc7d3017e1b26a4409da3348f6859ae68f9b1f255ee7a53c6c7c0fb22a9705643650b7fcb79712ebb8d8ec35866767efb9bab0c9d5b9f0303c4d0cb4b2293d9bcb2e9eea93d72df090ebed6edebc7a1b377490c4c85c30caf1e8866961493abc1ae3fc1fc63f02d69475ebc162f30c32f11d077a4e6da8e1a6bd75bfdb5228a060adb8f476cc2842409f8fd477358e28dea3f0e88ceedab6884fa01a3943540ef9b6a907814d20e40a4fd1266893ac49884287aee270e6c6d5d66065efdca7a38167f2e2efc54d8eb84481dc0c544363774f65e7fcfb8419c1404237b54cebe4631e192da44747357296d8b5c455106417eea978c7145cc539f241aa20c7dfd200894c412e517bbd3b2fd6c8cfdb22a3499bd7a8ef8b5ca5b7af7b9ccbee07ff9b330bb15480373d3e3eb834b85ceb4556c9b37a0e739bd60013b3412182587698170ffaf0b82ee7ae249b289c8eb725e449c4e607c6e9493e5b18651745202ab998640dc8e1c7bb7b78f7168f7bd757407c12b60c810457a70866079f85ad1462e581ec5fb9bcaa08fb22bcb60cba7365ac07514b77a3be7e9321711ea3664c457666d4d5498963c9937e45f62ffffb3f39eea630f9b6f9784c0e13ebde941f937365fbc0e96a1a371ac5e57d73d5d8bdc8e3c16b9c6595d1fd0524e820d5c719d898db4f2127350f953ce34c73f4e6626adcd2fc794b898a56e31e473fa164be5db6f5d9828d04d74f06a92a420eaa52fb517d0cc8a4bb7e97ab9d1acd5d15c2dbd94ef5f4b01a638489f15f25d637fc9895233c86db5f3ffd418ef06c5a2fddf718a0d7756606ed177105dd3609663491e738adc5e08359cf2799d278626fab15a99ba66d7cd38e0b974e58e457ce3b3bc960de881a07f45ceaad122e78228afb93be95b059827ac9b5ad2c1c174076b20cad841da426d6ca5f681a5d35151c790cfdf3aa25fbcca8d2d61c3cd49998c5595aea6d4159ceec35e88ef8a471b695ffdc12c32ee1c34ca6774981f229e60e3b292e0cff1e8baa906a213168187aaf669c11a16c8c6b736c03092ea329978ebd22ae45aaf5eb3514745fb7d7eb2d84da581145944e6e36f5e7579aff8398e84cfe62a64665fa659da81ba34f1b11a9be78f4c5a37b0561da265ac491ac5db558b2ec5960a42ae71d5283c3497f0425351b2c12e850283da208a0ebdd7755ecaa89fd911575cda3a250b709aa94767ffdf636b4712505f3d163fac2c5a1e6b0e9a3a0639b99cb7d14e58ad7a5c64186b93ad8e5175b5b1dc6ddb80ff7de028a420ce74600665d2bb746d607e89d1d00f6f0730d92d1a834d82facd30915191a380f32c3e0f4a919474423f2440d49aaf34418801ff77556bfc6c5913a9fb953b171201ee1c4edc647d15342ed74bb161a51766b6d4c13276664f7c3e4c73bc9c2e18de259a554ef21bfe8fa80e2064fdaeb04f4e508da9c8572e8c2557ab23bd0699eb13b98a323f9bc2a37bf2b294accf3e49016ceef17990c4e00e04c38a42e49b711718851228c194de7a7fbe4d10057aecfb550e10f0b291c389d50c844820ecee931c6ec17feea02ccd0bf67714e3db7ff64c20f184f690623e104dc51efad5735ea8cfb34768f01580f7168ce05068339ff30e08c43beeb24b43853acd8c442aaeedfe228e4010610784c10e56f47fe40b3b684c56120059b9cf068820296a08e3d32be325e18fc25958b66e114d46c27a14d345387ced1857b238032c4bfd896c97c01abfee75b414b644c37f5a965408adb91f2dd8c6eda691f7e5d5fcc9097579b4016539396d921323ebeb39507b57951816d8f5e9b9db4eec1b01008d99bde07e73133f78646975c00bd0d95c9b6ddba07803c672cf143008d9bd5a846c1ff7fd02d5d23d7ad404e82295a987e3942cc90adf5db03659efc74d182285014dcb5ecbb8cbf72c4b2f690c41d2d52a070d73ae7de6e52f2a519503cba4433a136f92b840c42ff7ba40914840644cb26bd2225a94811e44c963fd09391a6c0db76449882e7c1d80a25ae56639f8d0d8e6c8ab4e64d68c593cbe492498cd3f06a98381c6e48270f96de00a243d30f9dc86656d0bb768fda04fd66a3d471700fdaee88090780c384266a242eaf421ec2defffd96b9cf1c92c7fc95d87d7ff605c45ab68f258fbc536b412f959c9c191ffee0a32d112708772dc2357dfe01983f5a39338ef3d5783d35c8ab495487df9424e2ff9399a308e63795198cb629e8434d2146895992b22078644218a2d4af0cf06f43601c57839a006360a4433719df789a406cb24f13940573a2310ed9d78de1a8a988b4498bb5e38a0fd4b69c3f95b77408d263bc5a0b91cf59c1d672488bf0f88343224f40675f6cb90594cc018537177836b966552b69fbd9ecd3232945bd808bd5d59b5ef022aa996b1172ab2734262e24fbaf05a93a6406eb3aab70b1d443e76d34a448b59aa4b02d2268c1ee0ad3ca42f318c97eaf8c96665ca2fd35d3d791a87a9b7bb6e14b0fc129c0f17a1d5c42b224091552dd5f0fad5a9bf77c103d7590c3c3cd8040f605abb17a537d9c4cd7cc4b409c9ce0911a42d7cea5fbea6f953543a9065ff7daac98678ea3f0e81d306f899d9b04342aff195fd502e22a89d2696379550190960f1c2f67742548e5e95fb5139b6b766ff09470b91f55beb7427c3c1d11ed24b2a81bbcdebc47f3538bd8aac003142d9b781b632abd729d35875ba542f11913a74db05f2f434dfdc26e974c91e7c20520b4bf14e1592543b17207d332ae7ae80107064ee10b627a9a9a36cf455c2e1c351bdb856daab590f031e255aa8b9293d450f47b34bd69ee0ed47e23d92b9d39154da4f99dede19845f7d955c1180a30ad5bfa0096a2d518d533a9a3bf239c73ccf780a7edfc1c26255f10f68c4955d19e1602a14fd1176b7fbccb7a21b1d7fe0b4f679fa2ff553500053e9244e27fe28237b258ab6c6052b11d7c1ff02fe75118d2ec0ed5f6c38e605eeaaf7b526373d2bd80843873844cb67ba8e0c0a4bb2ee294d008c5b924db71c94923bedba8412c8a4021543aee9ac67119cc268c4af8d087450313e0f61d8667125bd9a7c8f82ee5fe2df723aee4268aadcc103cffc62096c3302b205a461127e8cf340a01e442fcd746d0e3c54d2fb66eaecffbaba03570be09fb7e20695a3a1f8e323fa82c44dbb3bc603ced709a04fe76609da80af259e740f2e5450b62c173a19c7d1cab332715bfa6413b0b4089583774f3c307389f6dd9de3c0311d37cf17153afaafba2998d860cfb08dc8ad4ecd084abd68c03cc842041cd0410d53fd9e321becb150f5c69543ab2386e1b4f76201361d4b7dc39e704aa99d70c3d8b39d075641ef912fa675e2b88e0b2131afbea027d42a681f77122393f057f474d41ba8dc0f7dd643d5598caeb6d64e58ae4ce887747cf23f37da19cfc2a63b97d22b91f759f369154d29af07f5d964cc625c0202921a4a5c382c46709890b3d1c33f78c4746c0800a15b30b5525ed1c69584a8c8c2dbb0bc916cb8a83cf78fbaec2bb7be7d9393d2d68b1ce5ff47bf4e9c14f56558f28239d12f37b6cb3dfbeab5a7f909a3cfaa4695d190c11e00bc4ae27d694c4dcaaba086ac6b151d50655d25134590472d005f3b60af78a84907fac48593547b4614bad18dad7f8f029a5a8246c66c5e249167221abdd93d2567d7c293f553a0fcdcfe1c3fdfc0fa79f48167380a24a9abd561cf4f86f4a3620903efb071c5a63d32fecef105814e77d000a85066692f666d06b0dc3457ba575e14f608d8188d71eb635773e34900d1e12cc36492dc9099de11111fc5012898be90c183828b0ec9caecfc9ee936c70590e8fae2169f20341d87a1e76ee5edc34eea83be3475f820e440a2e2f9c3e39ca18aad7ed5d260cde2317aa158a8e9bbca6154bff5acb4dce08b409f3ccd823dd3dae3d64f3a61294a069718d044cef0bae42c506eeb39af8645add016965ddce5f8c43918e14c409202a3f3b095cb92f863aae02a9f83e5ac07f0f719320e2e4e70da8e6fc2fd4d1967663f635d2a1264ed4b37e6138ebb80839693455e49bcf558f84942be97aa9c726d83e0d750ead6849f15f5eba629c54b0d10b1eaac1608b5c0269042bf52e11b40bf140c6fbcc4e46d111299ceabd5ac42c19e7c88d9592b193efce0a4b4aba6587c23fc8468b098fc335a080b48fc856956a63c8c0dccd3a16ca94a3d07960794818fb6d6e6a1748f37841a90b0840cf940247fdc716e381175a26a2810a05429b21980b9280be4ecc8fc60fdbd1cce6a9fe259f17c02dc59a65fa4e7574ebda4d875dc19befbe7917072bf9041c23729dd10cc3e6436b51dabc5410f946fca909b150477fdab1bad735575c6daf3f2e885b01eef68bbc7803cfc03abe73878c95185ce6f46924d23d6ea2558d1d635a209304f32d4bba04c1c3b5f823c11d3fe6355c4817eab36dcff74abd06ec4ec84347556746efe3487f9e2eec7701720c8c3ecb455f645e9def17374c815a37e496da93c559889a967a0f1e2126ba6afe163fa038cdd4cf12709ac256ccd1672d80cad12de0cde50e21de6dcc2be253251291c39f7ce26c758861f083f9c201b9ce66ac4339176db6402194c4e860acc2c26d6a33c3fb1e60db89eb697de540591010b59be9fd99cbc5ed0d7c72df132bbe571a94c02a94482b03d3b23c8c0d9ed2659134452aed9083411feff8123023b21b9934ec2f58b1c32eb352226674a01f408064d1078b5ca77827e687f862840b75868e987224e9ca487e8bdc1f723f1812e92f3e0dfc3bdcaf0f483ce31152d6b4e65fd2e9e6a8b1f3b6af1d70bbf93718b5e7df2c86746e2f46ae696511c696386e4167ae53abcb3c6aa9a413a7016920009b88da16ba8ad6bddf95665f922a01fda691be36b894e7b887182a3944b598d5ebd6f841052b9ec3d83f88733c1042a6622e113c08d1b904ce555b3da120b32a9346fa9d7f6e7273c4116d8c11fc77b180d84192ae01c2c57d66817c81083fc1d0a7d34c398e74d87c7cf10c8da6f594400599e4fe86bd3d6d57e8b6e69e12994676993bc2c35027c38dfe4c65da8cdced3c66f29e490b10f77d3669e93c6fe56188758fa267d02f767e347d490fe20c0f3687930e9f26f1694b770624e92049cc73dc0107d64129c4b49871fafc41cafd97954e348ecc720f2d3c0bb42024821681832529da4be473c891be7b10909380f65afc53448b3b23536beedf0458e0d8bd081aabeb463df38f781e1275cc5c6c8bf17cf8c68da5014a5696faa101f2a66ef3dc2f01e1f9d7d764c473c5630e0f5bf98330602f5fbfcf37a7e21a6c970f5461b08e10699d2bd8d1bfa74b7846263af3fa8232ed2e88cf934c375e267a724781089b90e818f7f32c02c021dca783e17bbfa8d0f8c90a7d66fe99175dcd55971f10bbb0bcc538cd8942bd72a0d493ae3a3252a72b9e8e475c761e2e17022278707d1e1b9b8c7e450a7f2d2fa68bee93a0a8ba6f5c279a7808123c59a0859d583bd63986d0a151ac3ef2b61786f8a90c0fa5ce957528c5770907290676ebabbd1fd42037e9ecb6855bcc4a51fa3db685d50515139839c600da3021f4946ba742dcee7734d0406ea4ee7e2afc92987389f8e3f3fb29fd5dad2621183af63007bbbce0eeb970b4e4d80b6a350edd61c292420f6caea59f978a1a7ad5c6839cf0ee78f24d928d3e59b7c9e2757eecdd16f7fd3866cceee9862434c879def44e902ba390701eac1c300707c612313a029778f453f5d6be8111ab94b297d315cfcf7ad09b6980e16893666b5c4f8895bfd696b5061f676aad4f9e2557bfbf325c26529e5466b119ad72061ca7621ceba207df1a311e3d786e09c769b772c07fcc3bac4d16fff84d3b35be8e08aee796c4f1a3cd9d92e239fc1b442fd6aa3df08d5c7cc9a37fca1f20505fbdf109dac91ce6f9f69872c01fd584af1c31420076a824d5be971d0d9af18f161fc4e946e27742df04b7e1869ea835201ed983b450b0ef709f2a40a87f91c566ad068531f38c8ed45ad50dfd29438f6b878d78905798c2dbe85ed3c2f0040d79f7a57a3303f6967191f27b5b2ec9094d156b278aa6265c041a309bdecdfbd083328ef64dd1e5e6e0418c831de22f11c876800d239a46110f90230ecb6b434c6bfa4c900bdeabccc68b58f2adc09ef63210cd6622720821bfced3d7a39b7dc0c35f2105f3b2d66c2e9e52efac1155bdeb61c9aa100a6639c4d16a6ff8c79ca8e1e995e8416742efc0150fd5913f14c545e095a7173ab57eaae167b4db1f1695f9b9b8c9a8f0384fa9ef9ae807b7981baed606ffa8a78ad958d7b84910329269746d5821c6614d5c4e8765f0524a98e56a7b5f78376b649f7c04e2fe63e8710ca38a5edc6a899f1c963e6bc7955748e2ab586d413c4c74a96fcd6e52d432f7e75561dc94a860fff410434e0309ec3b226456d3a7a3a9308301e86c20f1907d4096caa522350b3a7bf45ec59d0e4b507c7c46e0dcc0ba37d81c8501a78accbf70ee6bbdb4d787c0e1d2d9919a43e1988c25932296601de405c2fa76a13694bea5470bf221aa3c33cda597eb75c7fa5233f1a013df9fd01db97e2481d8643e668c9e29ca23830049599b2d58d42648fb0cf0421f002fe2c53e05b26c66deb18e63c72886dbbdf34c60f50459beb201a9b58a15cbe637dd495da23b3cf1c69356ce5a11423a7a9ff079463183e312bef2e0fb63d99a4f0dac1e6a58ff016945ef3492f9a8f17acde7fd604a8661b63b808449dbd7886dfb2dc4c0fb8989b7db27ca5fb63ac0f5675f1b8d1b29ba0801b4653a97d8db07b361771d8b908b04e3a8425f0a894cdd90c5be026fb969092f62a920293bab61859659c534f40360d367ed88068e58dde72c3d3607c0b9a954aeea8ca2af05de3ef4196679e3924b45ab7ff97616dfa1adfbcc23de683fffa7981c866c9d4f25d01ff26397898c0120bc389ab1ea55c7bc523101c6cadc8b248b34f9261ba06bcc2111457fae454dc2270c5189874001a9b85c243a4db72b29e303e5a8b1f7413ba24871d4562c2edc329b582f6992b83033b79748ae56fab954d55b6f0ca54602be011b3dbf0e04363629a7f251cf7697fc3588cee0f6487e0c5e113d2e9cff95914a0521f6925142bc65eea44c1c893ff3a9b603ad81aff2b5fa5e332c7de2d8d99ea680d4dcdfc2ba4ec5e6ee4ce8aafa93e0c189a4b7b1d326f66ca16f0cf3f8941774e59f49a25bf4adeb18834a6af68d513338b1480044cbe44daafb8fbeb35b07a5275e781a5806586cf0f3612c0dbbe31ca7acf3fde7337618233e9306f06d024f6c8c80ad2d1587d0b5eec07e1fe9b2980375819387416554e276158007b64e008e336243e9b36129e29692775444edc41e15d4a344a4a05cea6eae4d6eb8d80892f66633acd10379bce41891737a3b4fed3fd58f85db2af40d7dc51fcb8dacfa60b991f347ee37bbe3653cf79d7dfc35268cfb0952f0a2b9138a12d90f8c0619c1d2a55189635c9671fb39e567eee14c0289384f29810c99dfc308866e6a764e29bcfc5764c0fe0bd82bd1e253797549d982cd5289b3a94949430b41af658d234cb8d64640278fd671f2c51d99e1275c0f663df00ebefb63b7f788b00facb487ccdb614b025a384e6a4946ee40ba343d7e84cce4288a24eb611fb90d3c1546e2d756cc86b3c4165f3d84dadf0ea9d9b1cb194535e24b0c67ce32e238df930d2337d7c1419374fa3c188b8795ea3e9b1c11b5b82dda6f437cc9b9159d64de2be8d29f4cab7e4b65f03f4869b23a7ba0fc559cf2aa54e815f8016d9cab4af5c048dd5bb7327f13a4dab8984789fed2d8d02a0f2eae3a50b886eef856e05ab175efc9d343766824b97436908086e50620cf11dc6387fd9ddd8e0c9194ad7319350f43676b935583cfab2d64b4683d537e66132be1585ad6c9a594632c8e7eac95956fdc9a2274e277cdbabaa89f10293707c2cf1c0fcc5a8f3b5345c42bba34586dd2f0c165782662bd65546c975d63dbdbcaabcf5ca5a936bc5fc31c86bc5847f118c8fbbd9ed3ffc0bc46dadeb040c4f02a565842b42f640b9c9cf76da1ba7cc871b6b8979129a6b5ffccc0b8d21b422efdebb2c3d3458733cca96e94de083968a5cc2213545bb4261b90a4536295c191e7cd47327af41aa28c25f317059160e0ca57ea1822063bf81273cd53b0595a466803f424384228d3aa1babd7490d0c403b38c924e195a61e1d00dae0de7e6c53f97ef64dec2ff32c0efeccd596e66b2867ed6ae3e385cb4ae2b0124ffcfc15e7dc92f27e0f4ce38091d055fe2c9457e462c79586b517d3f660554de29718bc75f16dd8fd947ebbbf57b6e8cebcd30a6c27f3d53bcbc3ee46eead52b42b655ddf10e035dedfcdc7cf5db343ba68a4d38849aeaa9900a4ea6582f4a6c2d767cff6e796c51728c51e86ef4c18082422c9a245ca3700914bd76c29e24934c095487701a79db820413b7afb22b2fa473e59d6e71962bbb84407545fe8340e7d56db9a7345d9d16409bcd69a7cb40c29a01f197777d2053ca645602a793c0412e07b75fcfb0315ab6be4ebd9d2649b577c92ce06cc8f1434b96bdcf2a2c2f793f92cf8a71a089fbfca8d7f0ea9b5b9f5db8e1ac1a696c5cd4eb2dfd8adff0e434a0d20b570899d0878b2018dc861c579db7b0d29d64ccf6a870b8ba56345e2a72be9c72d917dcd1cbbce90be7acfb793aba4784794b023074079dcc5ef3f17cc1604df632e160789388b4f6878fce3dae17c1a40f12fed5bb50c807cb0a80b20838ff2bb9e878445e830020d82ef322201633036e838fc042bde52ac63b700e54692803b6bea4d6a49d7130a4ce1ecfe02bb5bfb2aac9e451896bf1f092813c91bfb7e174d35164169009ecfd3f42271f6929f8ebcef89f44160f089805c83fc476757a155019940cf037a047092e66c3dce00b46ead18d0d297a7169172f45858b1477f8282072a92b953b17be9cf421df46348e7f8cfb1cc6924d9d9eb1f6266614de14e3ac5fe6ff8a4c4e13c7a96ba0ef2110aee83fd547811334842f19c2c571bfbdadbe36d645b76440d3de45fe1ff45049d97117f859f4ea879858b9df107b3a7c7583025bd4a1942ba974bab05bac4f82ad95fd45bcc874e7916080e2221e5ccee69785aa70202e9dc0128e915173a0dde0c47913b0dd5c5dde4037b4e9e1ea516d43b2ae1ec7a5967431f7a7e7d0ffcebe8b78899d7cdef276a42dc563f74b41b4ccca9bf102ca89e2f489067b544b4e16dfeee8535504c3615304a038cfe1acec67150d3af583a589ddb4ac572f09acdec04cb50ac5688027e8e6cd95e3d0a5cb71f38b8a6566b9f2dc97c4e535a3aa8f4d16a26379d4a190833875c57496a3044e974825d8d6d7b42010d059efc2d3284ef2e915d37f3b49d6f268d1e42943b51b4716f677f1777afb6754986011eb787dd5068f92ea60d4dee8d8edb8543ddefa8f9fd392a675f42a875d37049109810bffa157fdc34fc0a726ae428b92b96adcdd2be49b288fbbb082a3f946e149c8fed58d676e3d115953a3ba3b2d83d182d972cd9f6d8eabab22950b2f52ca04848eaac333d4e1b692007df109e9751ba2e48ef430581303189f945c0e666ae656370e13d10f313a0e9d0a27b4d04a1479fa1d3af9304ac63a30d14919a4380448adb1c6b554d9440213b4d50b1bd4996c3e5f6cbc021f86d347b686596b7e82e82aacba417af4b6048a7aadcd8accfe481a2efd4ed6fa35e965bf1957956486308bc2ae6e2c2cb47b4f19866b267f380443c05b2f9dc80eed561929495a32da5da0339d41530c10504a49c59da0f21626fb2e5b8c32434c069efc1bf17288922c795c381f531c7f7600599e2d71cf80ad5a9db0d92249740a6bd9da9f94e922bdba9491493b662db512573ff62be582c28cbe7b37c4d5812082d3f8cb560546ee0706f67c0aa03be10ac9acb805e36a7a1c96d28230b240bca55e4dfac2ec7a3c1e4ee60c2aad9a38f401b356a8a24673078f8ded24db899c5c8a28cd2dda9a93843f65248a37dc1d4d5aa1c6d90aaa4ff2a3ef75023bf4257387eb7dc9b6c28e91ca6822a466caa31b4f7125fb2f7e7e5d6ab58986c94be1cd9b97597bd88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
