<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a266aca623c02663809b9ffcc0c70818928857a067081293f013194ad97af08c613111649cc5c164dfe598e33aae390f808e7ffd9803f133fe26235a57f4d3ae0bd851a2aee3b4005330858a9ac8d9265792d1b9f0fe7843432896cf8436596dad046eda6a895b878fc17f5be3e79a19c7f86ccdfe8dd7fd90092bd84a3e49b5319b4866e4e2511ab4270776eccf5b4de874557b23d5748b57a3cd6e9e78cc798e76d52c2ce1b86e78357f7c140aaed371ea08b4d6ad446fa3db8c9dbc79ad87b581cf82a2ba55d75497024ae95920848a1cac91abf16ef2c575265d225bbe759ebe3c7166c84e472edad89050770a01229b921894c059489bd6eaf5bb4c020510733562c5560c04e10d428f3fa6192f918a41d44b1760be1dda3d45628c7248d550b9e4c77ad73ccc315719e19840e6ebe99292a0ff8d174e690fdf29787e3b3073801ceb214a8635a665a2d07a7436c1e9e5039278bd682b119d828e8aa669dd47739cbfc5b6c9eb0565512d10d6ac2671886f9a2ae33fa1a8619f67f148416d51239c8ff799eea23e144798f57c89845970ac1a6ac0eaf9bf9739f9bceba3029df9911ee0aa3b4692ace570f36d323e6100bee03fcd17cff2d3ea15f82d18c70dd0ce6d7e3c764f135d1d4cead399ede9231e52a38d7aa53dd04d3b90e56077c47432cb3504fcc745f09138b3736bf1cf725a89b8a04b6e7103bf945e424001d46e11c8ff8e87144ae8982e9dba8af615b11da9da39357900cb32b697c84847eb6024628f9ca2116ac5f86fc2dc25ca7799b1f66ee6565419563483cf62c777f3bbc84b4b999df21262fbf568f81663f36951c6e582859c6e20782f4e83ce67d12cb73852fed0cbbfab1d519f5b7ca3aee13218d750420ecb2d87fe0dcdc27278e2b85ee738c3dcf3ab2c8eb96fdf0b7cc5855641bdc3c41963744b5d004a60a4ddbf8ea86e3f616a50a16adb7fa0d6631b04d4f4b0eba5f8f172093ff84f9999969e6038e928d40f0958858a3149f7bbf8f91debd9773a0b0a5c72365fc6b1140a082c8d55c9cc68e3e0e6d9307dca4724b41388c3d6c7c92be52a5ffbc05f23ce6e0afdc5f213c86913f608bef1595ce2df159a2dbda8916b7e2dac11c893c39e6dbc06c6bcce4e0be2dc55bc71b17876bf15c4d67133a871753b9ede2ce5ca2d3a95e860098fc48ecd62f0a69bceeb617ea3bea2b50a161bb4e7cd0d8ca9ce6a413856568a7729a78ae26ec3db3aa74e334d2b9debd07e8060d04d905bbe057536f00858d25cc39a517b3a3355f8989cab47d09d9f8b380fd02008713b96e1b2e68d2957952adc4e2a45f2a76170064e124a16d6a396f6d7666f4d2688591199fad1f20a3374ebdd8c869f29cee22b43f14264b431d4fa23ece3744525e5e50eff7094a92a059df2e907360faf158d3c34132a62a0dbe498411a6261a065f16d8222390c732ae0aac42575ae08d8b30574abb8248e27134532ce7067062050b4413012b250253dc01ab132f30324ede17dd4cd157f5808cf3ea48de352fd70616e78f93b8ccf545f79b716102451d01551b4c14e93de66364e00bd2fa7c4fd8cd4e4324ed29acda45b8a948603956cce5a7009e3b27af4825e5f37d74ec3825b1708cafbe115b92e8b0a7102480ca26b5775b1254b0526e9648b871340b9b47a9a878560343481b1de2cc5427007e688a44838b662eb005adfd1867e5945d6e748f5a654df3c37ce8bab5122f9091b60165f3310ea1ab20f7235d20c4edbe4840c310a37ed5233d1c62f5020e26006a7cfdb2678f1073f4977d5e4cf1ee6490756677e02f56380410bc1a1e99108624f77f9a431be3bb49bb90cfb1edcb22446a420df33094a2fab98e85cba70b9c73e29ff3cfe38b1ecb46bb18ccea406126da57d7c3f51dadc75c9ae4f2beb5f3a206c2b3f906e7cb22425fc1d255f47a96a1c4179494b295a5eb2186a252fa2e472af8eb6b7da66dd8bc339c91f03b03e59624f5cffafdc50d73a4fd9646435aa58e24c23bdc06fdf4e95c552f183d1e3abd9463d0a31a75aaf01bf833340ce492bc90a60a2bb78a54a7c997401842d11afd9ed65564eb9bd982b34448cc85ad5730fbcbf788e16cec6ef83591f0cfea0345ee48192fe04921727f38ac3f324bc783e2ec2c241b354f846d4e71805221414f550c36b98b4463aae4da77c5ec6806e949c98f4d8c43deb5665f06aee65f35fa46f0649eda73c1a0a3239bb2a549f14fb23af051055e48c78ff76dd0e57f94b5ffe470b2bf8a0342e2f69a837fb79a8387a919bb9fe463b6165ea28574e464761fb003ebbece026ba7b2c7982154bb30d4ceef71d5240442677b0ec593c0d4356c3bd7bd95ab6557012615c6cd0c0a7884e504e7adedce0d54ecd9b491596153668381d0809436bc501caf2f816856285e21e7c9185cdad130d4493a44e74b4e7838f005ad96b50b237ec6df3ad40d0565d6ad6eb9cdd90d54f3997da34a3bb8ed0aea256ef9084a6f954152592cadf05a252ad901b97bd983a20b0dd84873c8a8affb4b28cc5e8abb70360773cb6a32aec13965208fbd1df4b8ddfbd4b72a0d0fa63e8cc39e6be2cc71f157d9da0909f575ff558c19ebe6e0cb7bc05d3089ca0ba5b5419ad630eb81e72ceae4035d9209700c45665f48880c89f5eeb0c13e7fda3bb928fe63e5ebc8ed1b02ac140f432bcec5392711a69eed7ac0b117eeff143d92057ff4e2531eb81ede2eafb13a421db9a2ab86c77d8fd06bfe5d5063dc4b8132c463589430331ad67072d9136a505f06b539cc5d90cf1091fcb9964242d8b09cf7adeea60803fb221afe25088d9b8043f6388f8e095857efba0a3925ec5b45c03ee4cc82e075fe0f8a930d2fcb325e424bbb004f0580e86d33959ed7ec1e6688dfa7d647ea0e79ec06acf0db51ab4d61d4be39df8f8519bbbb119b1f6ee705f7846b5ff369c4a9608ba232980ae2f5d4d128762456f0a94653264979199771c6e598c5a21509c0a236ff70d45329c95ce36c031dcccaa3f0fcef58ecafaf448b4659806a0f1ebafe7c6ce496e0c1322e3e3293349f187914ad4e24b1b4eb53063ef94a3cf5cc27172ccb2beff84c2b4cb38f1a718d85c7b49f5145ec3a6f94ffce72d6d20ef05cf03571e2c14728f582bfb135d141875f0f35f71c219e134522ac5a37ec9564f62d69cb3cb6fbf989b1107f2dd85b6eab0649d64f12fdb255108075d81ea9a6d3b3238a3ba0b5da23b9610402f313419f3a590217ce3873483ad655f0bdaa07f8727cc181b2c56252b955d25e9fbb2c080ce14bbe7a0818825a7804ee5cdef8cc2da6877032d1c7990bb86a2c11fd345073ad156af25008d0d809633a6a653997c53c39ad3e34f82261d508b3d3c7c09c28df3d2e74c79763e7e2a0d889ee5e60ce6a798768a48fea36cfaa0b042c7a59c617e4e3e8fda82858fe8c490c4ffcf9eda22756e82ae03bb56ea5de43576e29e9eeef11f9ea78b49437dad4a88261ac6ed325292a85e61ee838ac9054ca6a518af240e03abbc8b819f6c4233e317c007adf683bf92165a703233148d56d0986e2576e724c25a19445345d321a262044ce982d9690fd3b4415c5d04ba2cb78a0bbd46d5ad87c2efb110b3a69615ae80ed24ce2c23be5faebe5e4184dd656c7fb2ef9b4443c61cda1ec137ce92b24db2f7df57c72a3408e625b02328a7fd7287d2182055609ca9497e82a30cc39de403907159dc9916ef67771fad9c9caff5b49d313bfb18dc66a2b9fa564fa2b8ce672d2c28e0d3a1c2456fd1646d371d7824fdcc0ef4e3a4b40f82ca904b9878982a7da8871cb63f0ce3f253c679aba291b65d2b4cbb3703ab8fe92b609a57f781726a9721cbad1e064d96042ad2fedfa60077ff0532ef3d1f8ea4a504f6138454bad8a022282d80b0fe6a68afd56248acd878f8572b895cee7d678eff6040d5d837f3b43dd24e07f5d6529dbf1bca904903fe7a914c285cdf487ccca5e0109a5743c4198a950a5b154bf1eebf12203b8ae7e0215e22af8aa8d1e4ca7d06ba210255e68dc22fd4d1e55acad95e77db38fba6e3807c6fa653f94c01b10890c55b4aa49da4daeb206affe0754db8c656633fadc17e786a1af7fd22e2e45512921774770eda98aeccc3d3f68a32fee58e4854b924963ed739fb1926274485b54808eca773c24a8c60f6a0d90b9fe1430e14bdf361286e9b1cd749e70a5f27ed0884e9eab9506361821a2abc65507b7a1a0a1195f1616f7e44e7915f78afa77947b0f9d74e5f2679b3838df8a78173ffa4af8b99ac6012157b875e1324dff937f54430d85a96b106eaf7df48c1aa494e871319ca3a679c755270ed365cbc40c2cd5ecda4ccb15ab9beebcae082bf96ff6fa61231f89a7fb25722f90a2626253a59e24284eff3d175dbb6f3b2237a3cc5ee48a4e50c9e5c6992f62f01e452df41b8679018b6c9d9b5138fbeb803d1157d0f564a8b13a2ea02fade7f19dc1b7a6a6754cdd05837caa5a65a5057af552760ad308408011356f29527e2678c8a1d7ff3927b64269f3a183ecd6247dff19a8ef4fb912a809d0429c2a37b522449510af183ce297d228f3b813a32bbab3946f7aba7f7b883b2b392ce05be3a946fa4a1a15c7d6b757a34cfdd753ecc8e632687b1497db93778d8ce85e9b72b0db27d5910850c3d318d7d68b79d91b7f802b0696a3bb71ebe75af3f6e1800a3371c8fa73cba5bb2e8c22bb076dd1452bf1cab2353adc2a79f2ffcf126094c54114358a5242922380ff551c9fb770fdde5e29e7a0456f459187a6076030cd8403145960511bc456161866b7ee26469e21130835f34f3736c1c4382d9d22d4d523de1a9ffc5f2ab46517e3b45ff5617a97c2d8eebdf6853f970795ce8a6a917414affa08b1ead4d6ee928795c7e9120caa78aba1f2976ddc75e6bf6ecbb2bf9ee54310199ddfb6a7ac6523692a00ceefd28359e39c347b54418dc407688cacff6010225728aa66de6053a4aece9aba4ed27bf0e438d14bbe6c4179ca9a2ef23ee60674e6f7c2be6c85e343e86ce0f993d38bfdeffd9ea6f78465655c433643774592a90a74fde113b2b47409c6a308c683bbba12388950dce446ce7142ece46191ad1e2bbc456f217fd9adb542e22196ac545d5f87de714b3054c2e4a60582b8472f2a76c824dea165b1743765f09dbbcc80d3c94ca57d160b38605b5799043634c48b3e2db20c77a9d2a8d7df8ea6b06d91d5023ffdd32858211ee9552c5086db24feeb3148ee505ca29af2a1cf0c15e64aa3d851754b8ee6678a9401749e2d71a1f06d1dc3174a41ec389ae0b4d435b2dd90cf90f3633c80df48c30d35b30c4a680f6b83beadca0bf1ac3712e4c1d9d6c8e7ce91c99e82351221c892632cf79e860a15b7f023da03fc0724f710234d0436a5ae67860d2832c8b198db0bfeb93fc4580611e0cc93fc733c2b3643b49519063437cc7d0bfb12eb005a2b9923a0e8269c6834be27d2f9db2f33144012004da1bc9aeeb3c7a6a43a4c9d4d14f772c036fe1d33f9a061460aa24767a4ab703c2c4a6643354c8565d4ed2cea39a2372c851ebaedb8e34b39a4bb385eb482571d1de1b5ba3dea1f38b102586da881f65abdd2eddb01be03510ac03ae94e8658b0f439455fe3b86a83dd9b485adb626f27038b89a0babc9fbfc97e6b5151c7e1739b48af7ad553c486ef3bd9f9b5d6f01e4fecaed31c8cf2b02a25a0180d9ecd15bb6e2c62203b820c4ce1716e7d25a5ff7040548604bb6eda4764472bbb5ded27f4b562a184f9add7fd41c416dee6bd224a09698db448b70aa30a7859396b2a17ee1898ef2f7684b95170cff0d594643459b45347de735e7c51c5d9cd71b66c7a4e06a0e56eb231e1d9644eef4dc82b00bb0bf6306563f113c10f12c493e38e588834b531a1a7c09db05986cdc5cf7a15ed8a540d7c79a6fa3ae451a37b6a4090941772cb62b1140fbcc38c189fca4b5fc66519f7779218f4faf0b0a9a720cafa70bfec96e58c8135c2ffa51679eeaf0ae02122866c37d03c7b59248e1e44e409fed0acf964d85111c7d22fa069641322c4594620cc431fb197b507ac9f1c7d881b4ddff12353bfa228067fd630df833d785c93c6143242d6ac9208fb56c14c507d19dc21e90e97c35b07cda0911231c0efcadf1b0dd3edd977a5776758d12881f231a3260fc8095db52e7f23c24648431dc003e7863bfef54a1d33217b1713b4c4e2f2211eb6483b866043f40dbd9a63ea07ad1e71c6cb5facc772f125529b0efd656053493e0e4b01fc93bec7b694b747dc884bcce07c27e566de96bd7c1fdae88cdcfa58be0af24a4c76d8934b538363d67c0a6232a5e106d4b30923791575edeba4d58d70961df42c21dd90341eacdd9fca4acd27a49a1f47f095fbccda4ff30ee6da2c63a9c067f7904a2297aa31bb790b1a7f055fcd2df3c7c7199d9b72af57c5a6213200c3bdd8e03f6ac71451f8b1b62b3663cc5daf4665e2123d56a9c29197beff92bf3ad5ccdcba05b84d477529c3aee317c2532338b5cda079426818bf329d5b545f0e07e7e430140cbd3012f1bc81ca6ad1fa0643efda48f11eba63388c15acec5c67f926d66148453002c842e7c49022052d176da0351301f504f23058cfeb483172e668ee855a684e1bac3256173e3b5709f218c28c092e7bcf193cd7947a8a1651ae6b53aec2ea7d6161bf69bf076f00da7376e362ca704a51fa261492463bf1c791ad3ebe38d0559c4b5d1c4c32db4c7c0ebf40e6cede0b940b690c954d9f68d067ffcf0433e9c91ae04cd88e6b7944a335aa6ef1508da91198723b598b0c7d8d9a70c7127f2570411951da9060fae331b7bb9bb31f6c9b3a003786f84590661dcbc882d2541acf540b40efd63c72db92dd165854bed8e8c143da3f699d36da9377caef422d1c53f3f17b5fc849b902ad4c4ebee4be12fc8f5ecd566c0be77dc1495c235fd84ad8e9c1b5de5683541143f68adfa2fb0c9e2cf5133579c2d5f37efcec513d88c88a4cf41f8e0c87db8e696a87816365bb94795a21ac64ba316f7d5c7dffc497097a447c38da5d557946f904218883856ddd21a3b7483bb1ef3d055524e92a2c02853434f4285c4154be463b46a6ae6aa91f780a47544eb05b131342f4e2a030392abca1fc2daebcc0247dc4f353f0514ab465badb6cd25da1502f2982d2b79e2f2dd1a438533993531b142593432415ed525b1fb308cc2b663fac30b4ad9976efda2c0f64fdd68e6bf8eaa4bd84542f9dffb30b859ccc2ac8810bcd0f76233bedd7376a0565e2a4aabb0add4f6cc0fe8712f8480773af7ebc8ccb3cbc39a6c45b31c1fa9c4426ede458a6a76e159b435659df152f46b571bbefe29ec428c5a23acb5727f237ff22f1bd44e51d22ed296a1f912314cdeb7a986727e3d4d5843a38d6377c25525509eec77a314d0df83b50864839599205fd2e521b8a3d4ce794bb552210c6ef26882a46fe8a814006e15a694e8037a951f81ecce73a2c2959b62d0308525f5c0831c41e7579086a149f877daa0f5b8f918ca32d993f4d8fea3b9247229473567f6f0475d2e0a818f9d653bb908f7b202cc658961ac270b75c1b66df52c400da208be92190044ff58ba624c5e7f8e93d870b11912d4b11bd04e7bf9a636fa868da806398ee4a2c01091bc9df9d8cbe612f65e8d96472310416a94d77d8d8b0d70a0b4a40c9e969d4157c0643e95d5336d6adfe6d1916217123c9f716e2e3bde07db062a9911bf2f781f4248f2c5287e891aeb7a45513bcbf7578e7c0ca6bee8c528b7e1174105670924b4cac8e7227031899d427ea79e954a0cfa26f8786b20d2a518ae66cc40ab189a6bde8117f860d9e0fd6f02af93dd5c5c085d117af088e4214beba8ddead93fcbeb93d17d1fc3451c68a1780853ba97840a49cb4afd750613900765d1a06b86056d26c960080167cbae0962802c5764f856e0653a433aa54e6441f4f86ad95113f1d32270db94e317a62a377ed35cf7d3fefa463dab68af23bb1aff7dc4354ea29a9655e595bd0eb9a6cb661130a690fab25795ee726bd62af2390f84a6c8befb55118e7bd4b6a22271afb8a8b1e9afbeb9d7c130841b3198979aec19d026ca7ea2cf3be02f76ee9f0ad24f8d1c49b30b39851db8a4afc5c92a2171e7ea136191c6b8e725e414fd343bc63e8034dc66a414ce3c51a23704e7e62b2c36ba6182640b8191ef3e36306257cd630a64ea5edcc2ac439aea0f67da5d15708da71da612122d4e9fad9e1ae55a26c36949e05be3231b307e582b4555fb6206ed06ae87dbc8efab34bbc555ad180b39597473b57bacb6cce4434216c2af525725b1d279d4fd1804f203819b94f30d56caaf6f07069da515e5e9adef1b7a00cea23e4db03dba50d17dcc8609f93779dc8e68a15be070a04017f9b759d4891431b8318b9021f23adc4ab1b57ab239c4ff5c78b170350c262fc0685a74f79e47c6821e92553d96c3b045cf0e862845518e67135e1325067d3eeb472d5ad6e1153d8c9af26dbd4ac59af96b50f02d85ce7d8a27db6e63f4bd1d73cae17abdc0b61c4c9536908e7c4c326a2fbc4c11fa3db06141df67bf69dc11e7b6c0cbe6c8513c14d16391e4ab00f65edb51f98346770020fb10f33cd2b4dbbc9beaa21db1354fe2f0a1cabfb9e58a2041509cfd6bfd01a0a72d74b64324b9366b4fc53047861169e395851298c612a153cb3fa397b1a50a2be64876ddef72e34727e66b40737cb88a0ca6af5ccf8c84bafcff961ef7a75eb37803319d467044a3a3b7a9359b58d796b8a614299561e87e95a814112c650e915d9abde4f895b17c5f8b313b7707082c586802be4b6bfa2aa49bf366f91308ae4076c0767a8ca904b439447171423e1478401d8f4c79406b9549cbe26f1f116453864fb58edd9fdd46f685824586f87d6b423679b7960a1bd9ef02aa944153d28a6d4e11dfb741c46678bf4b1b4296b3e245d1cb251c6475fe332241c163abfdbc0df533ce90692f22728d467cf4a09a60be43296d139366c3fa8229da9c432caf63cc1462d1a4c214f9c3baf7b36e5c1edb41deabf68e7ea2912b6cefec9830a3afd5d7a2ad2e9639ecae4db0080b7207d8e4a5433e624db81c1ec1a3d82b6c8208a3c273abc4c69a6e0316110b313de0db2615015f684cac426946636c3fec7fa6b157d9b4507fd58d9b1bba65c577b32ea659b66448aab592c08277340d08738b6ca22c6fbb5be8ea95a1ebfd7c58c3657030bfbf0dc3f55985e8c4a61fbeafad548de828d7021c8ea37fb17d46e00d268eb84e600b4a88ad784bb10ff038f3920e8832479fcbd3c25000f25c68dcac94996737c3e75086819fc1939339190392c78e0eb8d8a9a7ce58d7d896b3f890b0862a94107f8bf11a66cea8ff95e60a01196040a080b39679491700c3363e8195b05f20361ea49132371923219ee387050ee5ca5518ce7250539cc771764ea0d839ee82c0591ee7722988146e64f86ee91f497af5c5e14ad42446da6f87d83f31ecb7af73956a757a0d0695533c041dcefe6c254ab62ac91c76a1ec8fe60443d8d208dc3f64b855c85845a4b2d2ee8c06cc24c83bfda5a4dbea1f23560083478b560404d6fb565f85a3aeb114e5244c87669f1803b567049dbf72fa6c71dc5243c49cded8b9d83868b1b5b7ec424d222b3e573b78801833a48a295b2e42a92f618dfdd801dc9abcc945dd1e513d5ef339de0b7d1c011b6c99e638a0d8cfab6be4ea7e4888e59958637935c951e8f2d4fbc7fc39f4a8b1c0d46525c008e3a49574716830e69b357ad42da2f0ba6f8ca55111f2b2bca223ad2f138cb2166b97d2b207b57f952d076f7b365cb902998ee6e9017f21aee37356055d6dd98e7a4dfe9014c6bea92620dc176420a7e29a26fd9b94c7ea04b8f1ec2ba0c65ff49e41a984f930aad16421a99ae86a96590a02f771baa67a6b4c97e48fde389a26a73f63cfee1d4809caa564ea8889534c3d2d44675642611dee0dd7bae30467816b7d34d911c7990bf5d25ad611d85613a2a074efb51eea01c1e9e9b935e349b91e4ce21377157cfb16042af52465775d26ef0dccdb47dc1477787079286424e4bb405b3517843bd23407dbb0255b807aac60d398d8295f4c1ec397a8cc061480719e3f0d5e9b785ada6f95aea40f5efef9c476dff416f740355b95ec625320661a708e4cf35591f4eea186cbc3767d8626d49639b96226eaf883acbf8ec8c531cb62ae48941f10a09515ca70107c61950ce6e15b6dca48993a186efa7ecd3c97e1e9981a96f0d4ec11a86b47e90e2e1ec75374197081bff9c03445433596514c035b9b9793c84cb2d6365346464e43ec89976821cb6ed046e36a340245d5ce7c55ec87ce8c3f9f016076cb42b400f00e4ca175ee918f4e553255c8276f84ae6d4fd2ddbaf6c685c4db0c7e43f980023df16532a87c5049436697d4a2fecaeed4331d39897b807f11aa10524c4d4a7d3a951eb909879b0c4c738279e8b33ac15712af09ccf72f57028068d36e135592732bd16604d70c5b1778e6a540a44425c63caaa8382888e26bc52853499911aa76a3c413190dc3bb9c2470b1e76d07d5a00b99d89f111b5d24d03c4f438aeefeb7b6c4f116b7416e7c5f637866ece17b2797c447620857aa5b4f59b08263f9222f42a9bec8b8116def1ba8b5b725317d9fc319e600e4c4cf6afc27db3b9056c02da0ee9439215dea725e2931626555656f66d6da22ee16b129b5e9f11599c44329d3104ed3d1cf0b56caa6bea1da07922de2c877d61a2ea52482fa15a2b25d9a02f8b045d4aeef985cae6639e6d7f7019529d047a6efda08b05f3aeaba5a000eaf9b576abee2f6e542ae20e527f5c92ebcd15cd04a12679331789534e80b21a8dd8d827b6e2d973cb84381167e17b3678622ad59b10bf9f5b9bc8fae7b711b2951d01caf5ae9e7652a517bea9d95be2a5b5816a19afd11ed4ae2c6c53db7a6e25d98639f52f017b9a32a7b4b71de6231701a188f4104768ffc7660a8cda825b4c5c719de06ce3b99f3aaf3b31732f31dca801822c077887561d8b419914d8d5720a3e3921fda125246655fdf19fbc73d4bf835127046e50e1eba92cedc73af8308c3cf901ab53bfbaf3b550e4de34e0e11bd7cedbefd24dd60247a0c25f1957759ca7df682a9b7f079982d1a29fcff3bd09ff4eb5f0298eb0ee0319427a5d27dc36dba339814b3b1af32398d6fd997312af74de45de88182c5b523bf14d90d7bd9a2c67ba02c94f74a84e326bc97d8c4a012fa7fafc311a844a0f02739599d105dbee3b289d0891c2a6039d30fd929337ed08a24ebac0348efaf6c1aff161a010a34cb7c71268dea0cb982c730b116037e2176f6bd9b38b14035b69a99570de75d6bbd1f1312f331b2faa0cd8932a7ff1cef2ce32013463c9afc3249dfa8bb09e1bb5006024bfb70b35fea0019c1cf17b71ba490186df36e205a3653099ef454944b0e1daee730285fab8af637c21557c1b5521df18903412a2ad11917b1e7017789a7ba4ab5f43564a4cec9e1303cddd190885966e70e3703b22e8ef36922269ba828d67717a7524ad7994807b1f4869a59fdb6f426d2479059ca91869a4b143fc7b9c174593508ab802be1bd78ff4775ec3dbd539b4e5f1b3034e0ceb8477eb36e42831d6fcd66c1c2e210846109f25f4ac02583cbc29afc975f76fad50afedf7989d2cf7e35dce0e2cd7eef4c016b9bc08db989673c7542b3402cc03a232c77f4530c80c53452558c439a8f43e612c0564661065b34c58fb56c770cf381a363d7f482c321f0e0640206ad8e7bb267e4d95bf8b35ef87687c5115b7c3cda446de9e0630e1976688fe66a31c9b1686371fad1844ad499c916c10a7e52447df61c772a7afaf819cdb5d701069c46847a4462facb4627e0a86cd317da6964e4fcd01a08be3cee46e32276975665430dd378abd4811e3d44a5689093ae6c18510b8d301860ef149f1e8d6c5aa520d656636ae9e61feeb96e524b069d2e8993020435ff185cf9c056d21a80f1bb6ec83382f958537d1560ffea1c7aed621b6052737e33ef4e3cd28df4661435c902673c97cd72fccd9a29cc8fb35884863428519bbf03f8e7125bc6d97c2c87c072ce968e80b6649fbdc7321c074a70c76c216a92e03c27783cce7265e27b4e0d8072c0d2f4df03f070a9dd068af04e42a40ecbe5f547d26203165d518a2eb4512284356371cebcfd70d9d7e31a1e69f96a19a70cfc2be60fd490d4a35b7cdc0f5e4a53a4f5c7c6f1d763f24fa6aa966c40369bb915dab12d3700b5348234bc6bd7495438793f0bc55de6934aef8746644d9a5096f9f1f901cd842996a5f02cf9fadcf65c92029a55a4f1ffa722d6c556670dba9ff195608131c24f73dab0ab8597781f85e92dfe1a96177181bfa4544948f3dbe99e7039c39cbff04d564bf4b0a665fe3f8d25ddc56eae06a74401be7c10f2edac11ae8ffd5dc7aa27aaee20a0bb01d8b4dbbfa97ca88b772637031e964fe5ffad2ea95e594837a6084ae1d860b6494f3565e9fe45c1e5d646b04eeded6ee8b64a65c76007745c6622a5a7c5d1b16918d646d36bc4fc62178baf9bd2160e53c26a4267d6baff2507b24250beaad3ae0e8010fffb90d37e5665b46c4140b1057983d8a2158bd5f32b4038dc6ea064991cdd3915bdc3213efed41b5848f0dee8e0afa6e0d27d67bb3270fddf515ea69c195f0450be65830a6a69c038de1fd1ea84a80b2d050fcdef8b967c27782eadf422a0fd72a09108e81d99c5da430d1cd95cd22cc966841beac06c8ea0efbdf730aed917e05b783a397a2fafd34ec0b7d2853db874747068632b8bb023761f96046ca605584201d49d5d21f230a3ab4aedc7f847f5139a2f0916bc8434d87324883f1ffb0bacce1bd43ff3beb75d0f6a74abdcecb5639c7c420593ebda85023b6e2169edc4fd13035f531ef889126d10909de51215a05fba740c322c21ccfd77688e6e0f4451f92a8772de09ebce406edbbf71d7c231fddcf6447ffbb97c52273cef9052fce169090d3fcf301a65df9fd4bb75fa2f4faaada45cdaf60106103c233be37904c5ae7836d8448c6aa71032248891d4e2990a33a03c7edb700741e0be8e418d254788b4265f4293f97b1cb5524c528b2c2e288f42a06c370e864a999415a2ce86e6a4ad490f65bcc0000e576c759403c62bb69056fed8daebc9eaeef9665e74f0d99c5af746340d7732d258a581a6e6b184390179372cc29af99457361a4672ed4aea5dc6c2560fd3a3412a5224e93c363c34e2228694f6543f4b886ba6f38b5c14785c471aa1cbe9ea268790f3cbf9a9fe146b5878bfa435685006dc27117ed8979e369e652634f90024122bdf8e04bdd8597acdf6b6a2af7f5bff2af70d094a0dc206aaa14c0552edad9474eee5e35e841b476992972621a042af17ecd1665b0aff63615071e0944ec9f06459273bd5fa263001ce8e2487e0d236a465835e3df15d4cd7e0263b2e266b58a131448c929d5908a1a3e42b09a1684e0357a1c584e8c68b0f9fd6e75af8085caa1b723e02ca21f86d171ef705b20c89f107722544df7d633ec948ef9ee0acf8b47285b8a06c0707de810fd5978796b4d8d23ab0e5e5e31aee2db5189a2790b5bb14059900b17f42fe4e864d9def294b8ab0a2be0a7c0d3ca1dfb9f356fdb858bcc919d00add24045f57988541b20980f494633f3aced8372bc8d2e871dac4d5d77d8cb38fa2297b54780d36e13778c0e184ebbeb3ef1dcb5f7b297d68a01d785796bf42afc865fb7e31f3ca7e3a0a2986c268b170e59f47453cd3ec1824c9c75cf832ab827d6d0c8e1b86a913a635055673bc5a52588a42889582baa12eb94740f937a0f9b6fc1501d8f91375c46a5ba86d71bf645cff082127a5d3f70aa5b50db2b317f061e476bfee37b3de881815c72100edcd648e3d7b0f914d67f4d1bb49c4c8273115e9d710fd38e46da26cbee764905dc81385c25736c5a0a7125165b85c50fcc8cc56d041a229378314f84e0fcc9ba2a38387ebc63dbeebc8e0c5140961a8d293b49080c3f305cd1cc11b6fac2a45774aa255495bd31724a23142fcc46f18cff10eb8b334752c6436a2af1a7b71ea5be6cfc50ccef71d5426a1dafdab7b7c08269f9bc07413ad72dc7194694c544cf11914849e8060d1224a2c36d04fd5530a9116215249092727df7bbe33424da7370c6450a868c08a8f9ccb16fdb13b192852f2ccad35c31e5a600db700a4fba36849be6bdda959da267d1ca9c296dc689abdcf9068b47122b0f048f0c700d17eaec31e28db0f95039e652e2b27acf2879e0e7826c404054a4ff5e589f7fa9711956f02763856b174be28bdc38da28ddb37e25ef3bfb10f0eb29771dc1d57001fbcbda6443eb750c4876283c0308d7f09ed5fa44dbb7c17ca87e5d0af8214eeaad369f0c5fecba7cfdc1299751205e167ee6e1d1758d1436f04cc341a954c70e4d05370e6690cb8bec87dc8bd2cc3b93731bae6b394f80e309fd70192bc78ae81b15e719ef4495c7d4d4a30757b9441abc61b39ceaa3b752ae6656cbc98599115359e8f859743d8e57af81fe7ae07e6604297f61fb08b05ef0de9dd61449e90feaa1225c682635114e9a79c43e0b405a03660d79e16570d242ef1a20ac0eafb14d93add5c7bc4e7bc595ffa00bd6faa9bc3228aaf23ac7972010166c954a6e43bd7ec45cd7176082fe7d3eb41c4c42212754a33d46bfd366e09b3314a9a7887942ed6b5b37f0d4d55074b028a937bd9172c91def703096c894f6817ebe06ec19acba8c7b569c8742a09fcf555f66db5565f205435a1592992e7212831fb5ca9dbb84e0d9160fcf01e5cf9d0cf07e1fa5f65cf38b947ff88b5eec4b0336d940be82cfe3199b41cfa5800b9ba919ea9b135583f21c795acf4b784d4f6cee9af04fb7937b1a9a38b8234c5a4b2848fcd8b8a8ad0c5489d888dcdd0a636fb6f1563ea862e678c20f03a5f0b24fda8e6fbfef36a81961adf2f59e5df913bc2ab7092b79f77f9c5e88e9655968776b71d1f9d48d64141eff3d656668f4bf6bff3500b319d401c6d21bc30af12651a5a4f0195e32cbd1b1cf829a9d282448ff7a31a11993981622f7343521b2fcef23cbea8eb5d5e93c55d560a9913d64a259362b9a662339689f054c9a5b1e724549c5bee2fec4488de53123f074511ad9ec413526d2308113a47e58139eb3e2b3f47937c0309552eaa01a47f4a233b470dae70a39b838ac8c79ca34785f1061a257ae84f7dd4ece1c6c03cb7e64fa5b31fd67ab75c501105b43bf2f51f95f563685bb42eceaef0576a0159f6686c40949f4e4a401b2508256f8f3bc9a13989f25f9b620a5f1da510a9294fe77c2b5777f1d4ed3ddb94bd6c200446db872ba02acd6018b020623ac02dbc02d89c903cd7cbc3df3f7218cd36393f21f540697a24e99cc3bd7f1897357561c4d605f67915834248f0bd855d755fd375cbeea40762231cdffb49801104bd0d6f4bd9f37c3da646b906e020033deadafc1fe32efcec7bd440dd3e37e772a3960bb3fa4dbe28ad21e0057bb1635015b9048b9d283d5167fdc4553fadccc907b1dcbe9994516213fc217d9a3da03846a0cfed32a3cd3d96f8ae6334bfca8d070d4c2e05495d765198303c25067bf9b218f127bc9fee0609605eea8f908cdf8527efcba7c6dabe20db61b62dd0ef8d849005801d7504d3392e01a42ee439b4e1631a310c61d543d0b3e0e420757e2fab1c02fd2786a4a3b688c9ecc7d1cec734b5ec5cbf4d2ed68a81bcabed46827d5c14d4db3ec202fb98e1f611fb882de5cb2ba9ddc053d7080d6f59242cada34360cf0a2a73d4836a2bc0fc439bc07f9f52723f79c5c6c8f1bf5cfa01cf88f9fc4b7bc1f8e2c55e966d44f2b2430837dd92930ec53ed13157057b2b5c0ecb0c4b47abe61178a1e4f8199b59f09889439f4599d868ae6dc44a3740f96ef1f4354a20eeca459509a68cc505edf228a588e6e0212dac1c1eb1479605c4cf8f10d52e5efeb2bd0f53a739ad2181e441f4d00de6c36e5bf4fcc9efd4439ade66e960d99b9446b4e09acfbe56cbaaab0226468639d9d84c7ebb486615d9dc6c175c22dabcc34dbf446f0c557d2b67942440c683ffb3c7016b428da695acf3014bbeb6fec13a669946a6a8bbc05ce257cd0b8673b48a7738f3b5cdb78ad49273e9b3987f136cdab2088b9b0c910a2f360727fe19eb2970c1b15abf746ba9812bcf96e44e302e9d210960f62f09791905ca2da3fc5db386cdd9a2b99f4de1ede2a8114ce2003a8107ee6a73311e95e6766924c2f30ff2f8467ff9c62dbacd459f37c6f0206256df463635d8ce86a0fabd7092fcfb63d8c659bddc06eb7f2d42c792809cebfe52314612f448be44f31c2229fcf97b77da6a46a380161f65fc5ca0b90d401ce3192f9cfc3367d3c1df19b60ac96baf7e76767e1d5e28a10f9066bb08489eadb30b2cb45d5595cfe69edfdf64a62e3403fb799325a077b101c88a644b4c68f5e6052ebebac8b20559a76a36b469c91f15c1d2ad959cb49e8e61fb95937fa4c5eb9dc6c64fc5072e1c24ccc7569de029d762b765dd1f5871d60165844b6128594a8c16e8a4f1424040d54b43b916a7a3bb5a2305a5e7674843fcea15f49f9ee0191bd769c0db525e6307b955f6aa544157459f9728bfa302aaffab245a2aba24996a6f27a3cfeb36e26740f92c6d697c6bc3eb22665be11bb8dab4937fbe6e29aa3f3b352f469114661b6a5025660e8abd8afd6328a9462c46e4f6d055078486dc2982cf536c9178dba6332089c52b981478515900f508f771935fd9f548af888bf8737326dbe17fc15de0832f14e950a13e57918ca24606048f4037b07e60a66e4aa46597a8154c56bde715343a99b7d942fc8da5a0e1b28eb8fdbc30652bc57bf68d2abe748e8e3bd8e5048353ca7650338eacab3f6a9ced1b407340ba771c39ad64825b38d054ba703d6f05b21eebb09dbae4bd8ba653e9c700e1cda9ff09e3e728699aba3d303b775f951090c364517949426692d032bd9261ca6c6fd91a17a685c1baba924508f99effd1d207336dd427d8249aff4028425245d5e1bf87ff51ba6a8d82077de33277f7629ea5fb08bd7b16c8db9fc69f5bd04f8fe50c32e138cf2b7baaac0bcd7bc6f6a66c7b17ea0920f5754efd6aff30872f4512b00cd47dbecf3c04e90daaa03541238a6021a16baf2b67cd056984f9dfc77feb6bd63ff7c985ceb89ffad90c1380c4501d9dd79b5726016bd6dcd41c60ce9e101de3cee32125af8441d2021c2edacb9c4caf67d78500c80de82946a20172c4af1861f6e8bd41d72d78ba5b7db5482ed679fbe502b804ecb72314c6a16d5be7c3e4691b16b016793bf7c8ebc07de484cba4853e3a37dbb8a6e3dcacf3bf252168f5118469497e4c6a4075ae74426c783981bc010679432246332e2a2f07698fa271c545171650db517c6abdc9285453e357b859ddc9e42aa3eb43c0faf18258c4e462b5fc357b85d3b921a33f5abc2443eb345f39b49cf3e08a77f163fbb7f73d9fe3410284ab4deac55dbe7c1603bfdd7597f8a039245a4278b95141a64d4ea0debe322886503102921ead1abc4cf7294ec8341b38c38c7101c652a88009d7d5c270fd6ff58510c8e204dc667d9de915a20d1c5268f5ce7acdd662180c5b252cb9c692ce2b7b82daf04eeddff5e092c094b25f796e8ab656b933ead5663a663b2dd26f5558b1fb35428e40638049b3391acc4bae51e87c4d17e822cc7b642d3b00463f1392cee53a4f6372ed13aa748a0614a75a28b87acf486c49c2639170a5b1c15d12a3cbc7dcd5430730a547de7c667d68db7d600760c559fb43f1223ea24474a169720c4c93f3429e2c361ef5635b0cd970e3cb7c3388b1052672043d2136aa08b1438f18aca031b2abace5f0e8f7ebe79a8dc4296990d571cf58261708ca2c951ec78935b7d1d1fc554bbf96358fcf7e8d33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
