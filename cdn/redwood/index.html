<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b3f10fba3be1d79b35a326ef3ca2d1dedeb81efc82d6e6b1175abe903d7f380d9cc203e6bc592b5ce434fa86fe5c7f49ec6e2f75a9ff6c17ce13c8a2d7d1b818b8feca398f6a87b05b203fa546c0e7217a021d58e087a802c0b517db76219ba48f2cd5dddf7ccce69bdb41fdbd59f8ac48aa6f65aa7c94ffc035ad6a93eefd6f69635c1a473a4d22db9546f89579ee66057749acf155e2c0a32e8f9d1c5fddd39f7fdbb8fecfaa0f2d99af0581fffa65366cc9df4d9117caa4da8a02c7b87194e2c4f4dff77c01515c2a2a45ef597bedcb2a97637c5b4b8c20f72ef9ce8f3226f12d7298444dda878831875096eb56719e0d144c3ef0ed6e303a844ee6d1a729025b34278e6b683b94d5fde00fee078fe7abf60beb9c15a8b5cb7635acc91c5e235dc0428a4e492958c45fa88067bc836b25bbd21e81fe6d83051e0c4a729f9580a1272a22eb03cbcbc7f343d03c7d51cd6dfc3585e5e57f2570ca6210c58b9782e8b8839fa649435eeb19b5c01ee436fe410b3afbbca68a7fed7071d5e2b86922745f3173a0ac398832076f9d451217563e23641a3ee7388a4598a62dce3708e15b62abfab9db7087b12e5f858160fe33e9ca3cd2931b9b7557bdf12ba3a4cbec65a2db6b17e20f21f052e9b774cb041ea944365b46182caf8293709e60aafae64bd8108130518d4e28bd71a26efb6c3aeeb0273f98ac39897d7f33454257a36122b816ba694ddce60f5b3ecd5ccbb7a6b8ff6052a2262d9bdecd3ced3265b03bc3e2b7edc2bbd01474fb930921c53d8575971aec79af32ad13b3a77a8c92632f7d7eb902ea0627927e6edfa03d8b89e93bc1b022796541b2e96dfb1dc271710faa1ea38b94a1bfe358262d2a87e827f471218b731a772d3d9daaaaf3ce47da5be71248e40bec6e03c979d5c0cbd1d634c7c57f58d7a0f31db4888af0e39895682cdf6a3319ff621f6da84a335b36200399ff09c7e38d972c394128dd5ab497f99ddc636d006958812922a868cf0a38e11ee6295778793ec89dfb96e1d85e935c0d3151e29a48c5863c9ed66e6b2ba61a094c87af997f1c171eae858a52d207d903c899db7cc225b9dc2a9f0c01d624e4685e9c149b5c8ba56052e032f55afda3aac579b150e61c006d4e30ddac78e8f493ec3f183cdfad938c4e8ce4b0d41db2f4fd3f6ae4ebedbbeec764175e5607b5cf73a184b97e4adb4e53284cf3c0ba3e405b65c6d29d584793ba4bb171c5b0a62026716cd98f52ad24fe725753bc780be1ed894146be4a2ba96c4b90e97da44696a169eedf088af2b56321e8dd9b50b0f46caf45d984bf4fd91529ab1398d8fb936464a0cb7173609291fe837749a8af0856c58ed9a6235d899fb19bba04e0b02effea45b302a8dbdcba2f40d5096f30b0863c3aa64e518ec771452e52edf206e5d2630e1ec4b4b472225a96927d8eb915fda68a9fd55d212fef8a5f87d8c5f9a64511ed2c178af22fbf914e977c634b12863d5d2a3416b817d3de6fce5c1fe21cfc71a2f7770ae97a1208557d3e4cf945a74b28b507c138790c230c318624a5594f63cd880f91b8a3d66ddc68dc29ed86da7194abb3cb080027991beaacc7b181bcd0f13da4b7e0fcfb5e5dcf2e156a312d2ebc9aca7cd23ad9f53d61a9dac81965bccef85fd201616b122f9673aec1a865aa174c43a999fca29ec8bfec68ade6016b6d974479da921eebb98fac1375fffefa66c8a9b94673de6aed643d1230946e74fc1a27746516a053e799d3ea6aed9e9d43f096d720f16c51e87754579cea48023a6525fe291142a732a5f5ce122095b4adbbd90ce07247576ec90f39c150264a02894f5a77d5fdfa5ecc5ec40f13da85477ef5df8dd6e1861a2da74e55a20b2e14546177f328d820a6401eda880292a992d8daaf48d9f75d92eeda8404153403b321579739dabbe8d3a813209c820b8860062abb86b3a1669db606d7e07bf73af1f8878dcb5fcc1f2744d4528cf81ce5c316381a3544ae2cad94af4d956465da0d9ca55d66c1769e74ae766ce83cdf614188dfcc4b8e778ae50261cf13bd03e4bdf4f5f81acf02698292ff38eb6dfbf8b1ffac9cb65ef57f4fce02cecb6dee352d6bbb9efbf0e01aab53b7091837ce9215a5876feacf7df3e44da7a94295c8b3f52e331c2c3ab263f54446d5778f28f6887e20223e125f5f1889325c16e3bc23ea6d068c2f169ae1cb99d5dd32c8c8f5d9fd7d2fdf97fe3d7b2eb3f8fd09df812a4758d0238ad99b608142f63d33f5e9d65422b30accefe290cdcb5e961eb1ddbf6f94ff871ba38be4c0fb48db9e491e43c0a1e14cddc670944df142a18ef6b759edf907e4560f09a57add99e32229c93f403a8f9ab2c2d33bc5834b37911da2981f8bde6193faee27b247bbbafb5be47459fb0e72023fc24e12f3c18157e71c905fdaccb13558faba15f66a0acc9200b84bde28d7cdacc6c8f73c654d77d708dfdfc42d629aa2c338e838885ac8f76a3d1f81a5b50c275d985646dfc7426c824ff8b0332470d5c202dc370cbf60220a71f38f68393a381f3d0cbcda8b74918f2ec3b18a3e16da9f47d29d845ada42a6f9026974c0141ee99d446637745afebd698bcc553b0f37f8a4399675c790e47e4d70ec121405c42267de76b806b524acabc6ec0f2386737f9a17fdade086daad71f5d9af36d4da9184f678b5a4a0dad8d3f856f05f862f3ba6695a4504cb3df83906243d4c124c2fae32ef4d9dad312ff9480a1dfea905ddd901f43b8967c6ff861f0c30eeb8b66458044f3b9dca3ffab7337542d72ef6fa5a0df2291309c53e5f7d4b4adfff083b2359e2a4bee4d8f480599f5520f796b2d21c7f5d8d8b00b1bad03df486d870a60f1bdb30be712a43ae8df41848abb91392307e3ea25ae57b06883e0872727cf1ac4ccc5b2d1d3feeabbbfe0cb4cabe5f3103d0740dda007c60fd9c6888e1963933e47eb066a23bd848e4ad120c4f08c953e003680925d68afbf0aaf2d05d593a37538f9e59ea6e5653956898138281df78c1021919aaa489525d15f5e58670a4fc9834981c5458ddab457fe95e5e6df8347f0d2d9761219e29e808a38171f9fbac10142a1a5acb2a892d058e96824a602ac78d1fe6254f0075ca1d8f3023390342df11d89c14dde11049c7dcabbc112d6151408d2eabf9858906d26dbcb86bbf97d4427f20eb632d16c3537ed7f18b91dc3430b2a2fec07046c9dbf4ad4ec3b8e450f6f0b9aadaeafb7f5d7f5a993f6b68f4a2fcb26b187eb39f394b483a85afac6cdcb8e5a9978b2cee49821b5c418964e42cfab238f60aa609c6ea968c2dfaaada1483deb9f6407ad2c23dcbcb8964f2e4ecb7b75676a1e2550ca2675a2d01314492e5e9ec01ccf4ab67cae298b6bc4e2c105ff26a153fcb42aac8baa2fdb787402aa3207e8e060081ff4ea2dc95d4bf594a73b34bfc1e8e845f1f47a307a0f7338084ce3fffd1848bc9987665779dd3fea4e9e32b10b0b5724d2e645bcb6b429ddd6cc4ddcff981dea0396c02244b0f6df4645de32af9f696589c172598369fa1e729e4fbc2a903e3d5736679c279b899513f70835230c78ba7b2808b6975970eb1ccc1d1c364405d0e1aec3a4dba23f43c5ba17b11eafc54e1539d8bc9fedba0712d5db37e161b124ebadf5c3c3b267754745efd1061370a3832eb86b0143a1e617ec84b55b841f42bb25d3fdff80a90cc4286808ca06388f2aa1b7f93f2b69aa663b29c6918c16059232bf5c2d104c2caeb276778c39c7187b1540072b4fe63c185ad418cff3887ca8abd24a41a328dcc68e66f7ae01c46bd57de2009521b64a8573b6314fded5125a80df2de786916dc1401f80537c1f42c132ee501519334c9b79df8c8bbfa9f00ad98340d00a9fde79f90eafd0cfa7fdfabc3b50cd047bceebf4945c58e93d268a482a49dac35f7780d6381f2935d6e58a3ba1a212121c7454bf3b9d859269eb436d4f23db1f1b0ef0d898d373c04379e10d95c3c62e6b0d5e61d87cd6805f8bab38aa9d11b32f90c23804ea87c80a69192c8c5cc794750d391508b8a49ee766987e86173bc61fd39ce39acbb6970383c4ef75a3c53e2829f1cfbf5da1cf50bd6c12af76fce54546a37c05d4b48e3a38bd27ff1d193a9a339bdc226c2f06ef25fef81716cabdb3e0e56d7bc6420a2f592fbcfb3241549b154b5905c3525fab708fa2420bade62909c54ca4230680cf1aa6c2010033ca76ace10ca284d8ea9d56a1a6f6aae00657811bb551e6ad05f197a1a5ebfbb0ba5964cf28cdadc5838d01aec33c714e6b33da97e62244daab93ec031f59714d0312e806cbf94bc1bcbade522a577470f50e9b5c522dd4ef685392175ad29c797fed13e6f3bdbae49692cf1660bf6b74ec9fc69b860e621c181fd85a2666e6c06e8e77db13f623d1c1ffd09bb8f334e8afa0a64b843a17f3bf7a9fd3e23e14ca6d3a5cb37a447cd65766623bc5c92eeefb2c351ed2534ff8103b7a35118bf0e4272e798163da2867ef1d2db7c50ff7b46d7876451a381355d05ca82761c49dc47e3f525563cabac4445c02a2dcf40b610f8f8aa826e03212e3bb08687491c7f8b96fd7afbcd3ed048920195697a2827bfb930f7bd9565bb63762fc7c75cbc33aaaa295f79b86ee5c2e0553352604a70dacded85369bad2000678eebe43a19cf4e00b56c4f88bc9316bd4e4b7653703e35fbf22f485ae7d8e0a59ddef3a219158c57bd61b674290b1322068229760ed8a4aaf36ba833e1dc5f140392bee8f6e242c574980cd7fc0d8121b19fd174d03f15bfca16e4cafa80f0131b943b800588b154f769355fa1a96af13c053ca307f1fea78715e6301cb630d5f587fa5d6e7d538fc884e444f8da2e285c2f6449146571289f44ab947fca3e01db152d71f5ec7a63bc9769cbf3c249216813d9ce3a6f79b24071b5c77b52f42c4de1b665b0e7deae39ca94429c2bdd629709c15c87dc06bea31359f1e318948df94741d9aedccec4e21f15d776e1daedb115aabd340711fda5320996bc20140458a7103545ddbc1331361b6de89d60d3a6bf698210e120cbe38fa9f7fe7269819739e6a14375eb5cddc8db45eb612b5113525be53ecb4203602f05d119ea8b9b5ff29302175c2fa2c277e6621000e59ee94129efa1292dc1c6022056a3eb3b45a720d4cc803efcdb929bbd589a1452be1b8d4be0ab3a15a448e8c2689a4db8492487ad66321a3f27b020a0d4287027eb3f83b9c8eb85e29bebb04e40fb9152ce891ff10d493c0c4af3490988911ff0fbdc84c3e1534ccf952b133281aace4e2cdb696a5fb4b4c5231bb6d25111e4ca08a36b1169577701a6104b377a1c8944f0348af2f5ceb1670174aa565dceaa4c89ffbbc68f4990baddb75336dfbccced76ef79b4a03c0408f9b9d14633c9e29065a531630b01a5f7ed523632f3e5e52b88dbbd8fd342421fc2e0219fb47c4db43467ea6fc22ef2e2cf44ef77ef83c2e7ec822c8539f77c3c5e710eaae71eb82e6c46527491aa288123b86b9b138ea3ef20011b02f50f8d637ea04b1f689ca5a6822c497f574db8b16e0e4373e208b59586789701a6ec6e4bf35171da2963dd733bb32e8b9184b85b61dd53206061fb8301c00c5021171633df70472b35021e69c183b0f312d9c197d43e1f534c10b3f219fbee5375405769c276f8504f1c886c8e9409896c8c028bceefd4c452f027a9d5c86ce92253b7a2de93af77c660df3a88357bf16e2fcbda12e2106dc13429c955022f0048ce034f9002244f07fcd4327e7eb6acc01a5fc6db752916b9e0a5c3dfed4b3b2fdbef56dde71ba1ad83982857715b4a444d400bf7d77202813519092bf2390041583ff618026e97fc3ece1069aa1bf6728d510bef36fff55f863f90968e497b8a801ca45d72356fe981b7bafdf4f27a3fad1af14e9c9d8c97d9b3f2f63927bdd49898373a07a43ec90f23f42420b427c21347b7334d19072a3904db2e73b78a5fa6117bfd5b64b7defebbc9cb907eb2c692b70cfb41c159d14ee3350c4ebbc47ea79ea674f69e87842ef1229b95712c44483acfb2001c72cfcaf7075604725f030e5b6d8abe183101f03d6c99cc223db88cbd2c085e62ffe48cb4ba030f1da175b916002d1e96f2020b63bbaba3a7a754e8f0cc7254698153400b3eaf668b2d1b069fdf1a4f0ecb85b70d0de0bc34afadffe861379c9b2b7ab1b52fc5f7811aa6d5d6fc11682099a91000307674c79a6217e88280750777763e455569b5a2c315227ef4ae18ffef49ad00321ad837f8b4ed054b7841389b625643b1cdf732e4f6f074511a4d790222305484c0b6fab2f999c8591f6efcfd17da74975e09ca5ad1486b2cc6ea71c368b5fd1ac0a38880d919b03c678b60578e9dd1d417b7a4b666b8248691ae69ce8d34eb4c47dab1bdc1bb98d76d258786f1bb6b800fa38575e47a2a5198855e8aae2811b91d003f68b9741b50a6440c623a8a109d530365fa0a173b20eaa66aefaca6fd585cd5b52a8b749591b0332ea3399a9b33a4997eb9802dbf7d4565009b83da85fa008add9cd08ccf0328343a55a4580a07ea8d918c48b21a8fbf340dd6ac81fc28352d017b7368fbe4efce2fc607f0f6d8c66e39c6994207012c72c29348475d8fafa387c699208a76f4bd68c734a18bb43151bcc96f8937a60a19590b53f256e2ab381f3726c9d8eb7c5055c5befce1ba469cb25d1f9fb23e1826685abaf30fb23cbe4cd9e4e01e3e9698de30e955a411b0624a3fdece47dc2fcbe54bbaf22a5747ffa15c2e142d87c31a95779867ed6863719815aec909b654911a7af60d50778362cd0ba622ecfb259878bf26cdb3b862b8e9f8c5e56dd2250113c1e500021b2bee7a806d6cce28ca537638633b93e8ca0afe81be486d84f449ddcbb7f577ae6886f6db64359840ddcfd90edafe351dec29d1adafd459071eda316cf1c65ad71be85b527a5c590b190493575b9c2c8b895b46528d227c944d00e0363ed99207b8f8ffb4c7835dd1e636de852290764c73418d07248bc7090acc2bab36c0473a20e5ea4cfd723ffc49d1daeaeb78e1aae017103438f4e306eb8dddab1461eef4dbcdacd71af82ab85cfef390b91eee68d5d4eebdb50d9f8f85789a2928a59090bee847220d27915eafbd0221ea16b8ea3d4ddbe282a55fb6f6776c6b9007d16360d2c992fa18f6db7ab23433897a1cbec7b74ca6da758acc8ace43870007f9deb854be30477ceef923c4f907b3c69742c192cd9ae5b41a0dec5535b1665b8525a9fbcdcc86d40a8a05d80f43e264dc5cc926301c5b2eab66af0695bf427be32570502ddbf7f005bb7e61c978dcb3ce9f7a0e2379b5795124ddf42490730b7ef184d81bd09490dd369946063f1b7803edd3ee2de8799803ef6196bc56e1da18ce7139f79b7751184346d37f5fea68f4535e093ecb72c06a3eae56a1ff8a24cb1488ff4f4ccd7484acd5b0bbfa904494db8e5af57ed722648bbf11f335a59a9a0bdb54f5dbd19fe8458201af9b144f14f35a7f3b238e66c5c4d9bc5e1760ebfcc36a298651c00d978f33ec20ca31ce63471d7e619ea5b5a771524dc07e78d965fb0438a8d46331af6ca567cab2bc16eeb53e9616d1c1549246fa9ccc035a3e5c69074059ad58a75c1db78233f6c69ff64aab7b7a518fee915782a2f4e9181c98b0771827a068efa721e17db2a45c3f96c2a4abf50bc1fa89e2b5604add598519af47ecec959d9f188e6b9b53b7be1425839fb662c6c3aea9b9084da87be2b175c787c7d7f0fec6979fd7cd2e5d1d980b9da50a71bffb2c6636f6e5faab2be470e7ae7e8fa1d43f44d0feeb9f14db90cfdbc9ac4343adbddafa99a4e9d2afc3e4b3b94ad2941c60fa1275b2806624a8de8ef28583ae85df3d31e2dca19b02ae96e3300b3296f34c196dd76528ee8cf87afc9f5ff7c242058b65447d58d0d00672ca4bb4eb9d5cbc06069a08ef969c3ab208066176c3a0ea0266d9476e4e6ae7398629cec9755e7e1872be368c33741f909b34e87044bc62e4c7ad6e0bc94b035df3d319f029139994f9dfda816480563cad76f811f5da707f33589b83f5b8fe3a6ea0fef645730351ef32a885dac0e909b2f17e24e397a82f094ee32fcfeea552cefc1f4606a2495341ed03fdfbea354f17cc427908db2c3c80c3693eb8ee13f27c09fc9affd73d968a80fbe3efa2c33658f02c5d7f3df3387c23659987e1fd04c1bc54c9c2255ffa0307a8460bb3f01521eac7f903de2fe97d1e7933aa65ef0e08953ab9892533df33d3f86a2e967c4ed43f3a9ccf8c6a0e913f680c8d2dd452284ccd47df05c51eecbf9591b67c35bafbe143f0c7624836e4a43eab13fa59e6e3b6fb3419f192a237637f0e494fb152d3eb2901d037f952e822e5177e49e95963eacb227ad260134a6d950b484a7d7d61c4b76f58d0602a6800f4f23a33de37a79943bc204048f2a0ea6de3a5f3fe35d729c0c920025d5509600e5c8240a923802cdf66c3056d582265a2fb9cd4ff6dfef8a5f6a009055503505184f78bb3bb85ac163005deb0e86f97f6d87ab77486e10b570ff5da4e884755878c615827619da6b086ca66de7ad6e56e6431651d8fd97b9d630313a4a7885a272a134cc3018f7222d8d61bc304b213a65fcd767bed8d2c318b896cdfc79485c99c3b580629c379dac574e80113059762d4df29be1b3058351f05281ce023986c65a0e542e5bcb62cd1a2e4b1454aa2e6aa7d213e6f907e11d8dfe4916404e3bb47174a28404af9f2725469e1e2de4857f576eb970a65eb3ecdda7b8bc380fe6768451c4c55020b165510e792371ff98369fa155c2d2d320b573824a9f6aa2341fc7c37dc0298b0f989b128e14f6504f1b2a4a2d957a7d32dcc278f2c05e7438eaa88e7bc2ae4095fc85dc4b80fc67079fe725aeb9dbdc980df9d09f59be0355aca65fd5ef03ab6ab8ce5ba9ae2a765433036a42900717a384618f0014d51caf797609f71dae4a504aa4a61e9bb06ef59f82db6c0734752fcf09e5f35e704bfc31b88febd7a7ca3861b3ed9b2ae264848193b0ff758e86cb808e06f1debaea53da690d62b7a1d18b03086439369fdafcc1ed2ae9398936f91c67bd611ad57737920a1cd519fb55ad598069fb272fa5a334c76589f23ecc9ef95d9a022fa6b5db4e69729fb11a1318611475b003c8ba4bd06d0a911bc49c676031250b9f696e7fcddedbc33ba2165ffef81793204cba0ec4f3ccd537c295dfd1da9cabc85629e6b234dc04b6a7ea9dbfd0443eff6af07c34e6c38c0b2baae88f364d4db50b40e60cb6a1673b4bd4eafa3525c0ad00ebb0b85dd77a4982c3828c972bfb2a9449a1d485df783ce56f40d5df8e4c0b0ce532537e06eb1fb4740edb6e8a6ba5ec82253bb975d69b09eb35b8f6c6d86ead3394661b420161ae9cb763ac55144ebcb5ba8d2f39538404fe8ec40df1195a26cd8967387e9af4f8715796055c9ca7e1e6a103dd2c8329562e758e2714b2eb06e99f3b6969044b2f8e021f5a7d9527ab3f12d4bfd6a3d2a90c087a62db24e43e6daf216a22dafb101ad6f25fe99665fa44db37f22f5a3d9bbaaafbef22faba86567a305dc280523a2dd0f00709570c5aadfed61b7b599abd6d44ebbe8f72605195831593f3c0df031f684126eaa3ad52d25698b235aaeb9b865ad0050174f8831838b7fdf32da7ddb4525ae20744850f4c07e4bde27b5f9d00ca78561051fc08e423a2fb4964799a286b3f5e2fe88a3939e3d5a458143941399d49bef1574d4aa3451542a129f6ea868db1a49d80186536a71eedc2f362be45e132f98d843b13110abf721ffb5f1129788f9e41260fabe0921c68152dc46c4a2dbb6b807aec7ce71940e99b5e772949d94fd5f308c4053c1dac34539bb70974ef27a5f4106d9fbdd8bba5bfaf49ced35120ccfa9c94a24020b8a22d9f62e7e33810c105127c80920e9ba88e752520db20621d584e4e974ba7a0b1088a086e14de464d9006bd1fb8480fad62985fa679f4c11ca8cb37d7c1f72717cd28294030e755fe8f5ab38c820f69bce12b41ad528f05abebfcce708868d0a9d6afc77bdebe56b2b5c8ffd7560d547d4a5bdcc5dca305484941d4f40e973d55e1dd9741e355b8edb7adbcc507faa1ee09884d259444af58d36d3f3ee3a9356ccc6d68048cdecd0c09ab5a718e19b7d1ab999bdcf4acf573729ce8ea1a263aaed7453becddd364c62ac6967d851dd77c8fb7a73df65b8c9f9c4e5393efa192f866490d6b07d27a80aeb39c3ba54e652c61578c446995583ea45183d2d3bb151e4922d8bd555901372fd0d84fcb4e56425b9764861732f0c3005d514b027588aee24503b8f8e8301c259afe9c5b6b55df8111bfe240a18c44858571fd570428797ecbbff3f99dd74f1dd434199fc96c6b6036b353f70195c0f49c9ced5f443bce59086cede378e5c1a09bc4986107fed17653a0ebbfb76bbe35415df168618dbda56e2020fb622a7f531ce0418c5d6af6aa5f13572dbb3552548a6bc9b9cc5a859c6028ba2c3a252440f79d1ffdac0e2a8940b2227bda9c69b5088995207a20340c5b5fe1126babbff5db252d4ddc013d5141dc96b995605cdbb8b94d869b5b5e7e7acae179e07906a75672e1530ce77996cf6800270a9d656aa8913ce57166ff372142ed53c9d267ecf2acaa612e6afa78197fb1cae50276cb524e5a704ab307cdc263adc205fc9473a1ea825d2cfed6a68f2455ec04ea5e018d744882ac3aa5889fee777654ffa055dee3638aded5deec4fa6d48a9d9a8d8e70768050958bec22d0fd5d2405a4443662e18c25a2c586f7e8c515e4699cc71516fa679055414761ab4652d1cd3554740f0cbaff006c009b790409f8efac2587dee941a0f9b6529b3527409d9f3dcb14ca990ee7ea6b35e19c3225fb51be5eba3345cb7de73851e32e97842b5408ad005a58854391f732a8cf433c95d7f01dec5f26bdd7ad5fcf98a8136ddea2880d02c9d275df3cfd043d608afc8c1aa6520f625d3eaaad00f4435e9fcd204c640b4d437664e70b1d25470b3e7064c63d587e78dbdef7fce40ecea7410397333f244b4f99602150c2a71151682423a65e72ace6899a813107398016c107ee4305b4286985870380483fa0cd8888f1ba9990910b5d175d0c7f23a0575922359822b5e8d70e7b17bc4d1364bb9f0a323b6dd3d9054bc532c69148fb0ce23d0a2338edacbe136ea8eb62222aef72eb62d640f0d99b1d73d249a12a5a6042df769a3e0e5db311c88e0e56f31e296124fc1722481839f914f717c9ced4531d9fa7c7326773b5b071cf2730457c862b70e730344a5c2183d4e3fd0c01cedec007009fd83867cbac1ebf21b4d78f3f775b3d6c92ed5f167fb82a79645ddda768172a941cff34c09ade0013e6c398ba5bab2c3e3b4555de311c6bb13a08d0d5a43ced371c9b1a3ab4a49d9ba71118b09597d8a297c652e0c44c41b4463fc1767e6da969e71e50bde53f7ea8605ea5420db1930f445a2aa63d9d60d46fd0ff40c7eb737715b844431180bb04be7e19a10ad22703ded5865157054cac26e880c46a83dddede6b4c4c0c78c0f107db04e7243e514d55a14bf6ba01726d8562a84f08de95f2081d7ae4e46f10378cbf4b81739148b546d359ad8e28ddd8ab5aae2b2b9910fd44c24f5195f7fa4dd8cc44dbbc93e680184e10ef6c094758b60ecf4220b32969b337795e054debfd22a5d134a8d3829bf626b58338967cbf30fbe8f10803ea1af2b5ac6848c577c742c285572ca64e28b970edac77269507d8f0b6e519ecb21165f6ffcf4dc4d990051a31de06ce238ddbe744da3b2a4343479bf5e55977e3a8f0ff38906e0f66499e2517c542ca70054d677c598b7734884ce388876185e2e9688133c28e6b968a50c59cbcb106ed979859b0d50daa9a49983c7ac50a5de41c66f08a4a7ca11cab01286151b8f19e8241149b3a678db7c611370de472dd0d390ee45d47a1aa3ec2265a2e00af0444369703911fb1f71040d4826a5aef5f125d09f2bf35109914cab4764c20f5ac2e5024ad35886115f4a6d8a905be19205a564f3651962441a0fe396b54fa8fee3eb478d8864c3dcb9a67d90d824b615271ad1f30f2eb543a60915246980a46a9522b817228361ae7cdff08be9f6471fb97400674ce8fddc7b035ade60cd3720ef6b8de0e9613c3254445344727c72fc99108fad54ed79e7929397126541907ae97a9dbb3a5ccfad6462b46f523275a07a21b13f4b989d9ed821ee8bea69801000cca3f7038508e77255a5504d805f9d04da1a84fa1d37f2b57c8f38143a0e02c44906a78cabb14e97c62739a4a94b32a20bc281721361c658085cc355b4bab1d18b5bf93041919aeb6a7319c57d58807c00b080c9da3015ad44f5a08fc49adf3acd57ca8407fe20f137bb9966afb0e22482b6ac8490b00c7aa1efa59d4d7108a29a9c16d65f7eb8a9a74371b6f3648bc7697702afeb6d931d8c34c90f1b3a48f48411f7845d7d0efef4f338a48e3a23e3e49754f7b0c7b32027abda9fc4be6f7d395d4f84744c83f483db191496e3954b7a3731ad5d2473af98fb431e34d6e7ad3f274d0661f8d65cadaee543f9c8212df5fc00b328281c89d82b025b861c83eacbe40b17242ba7b6bceecbb392b5da93caad59c5ca999d33d7ea14c23245da4bd0b7bd520a543d8e453dcf24ad7b6c567785e0da715fb1fd5b6acf137114d1c101f2c9222f7130207d31fe3bb93a509e5fc3b01da1312a2f8d628fd66207dfca7eca634f77a0646c1483faac2107d4255517147d12ccbe4edec5f007effbe29d6b33d21b1d169d9b5226af5e13edd7fae75a1deb32326c5ff78021af06631fadb274c76e0f14617e6ef2e3e70c4c76f0f93716c2e838e7695257961997fe177b500c2759db7781b81da81abc9c3da7fd17588ad7f04188659c8ed44bc9199cfca7b623f31ae5ea000607a0f8dd8ce1b42667566602b3db440de3589117509089d0a2f44c310a7ea2e47408a5dae1ea59693fe085bec14cb6c04f3e770f3a97f8d56164bab4618da34dbe7ac4f9a15bc016b9851f85ed3b019d76f73ad2aef906b81f1a8b6208ca540359b51021101a3cde1f2837b0690da3b6f91a4cdbb2f0dc53c3a179ec5649170d684d7e7a363a488970a6703120ebe51fa2acefc041016ae1e657e7daa6ee75353addf6eb78aea8bce99624d4b29c1181e0db2283fc7029a2b23d1f9a0557c1498384a621b06eb44e45b3d81312e23e75598eb29cebee14e4a8f0719828c4f7417037f3e390c155ab053079fd0b13cbeb72ad41abb5a8e55d9ec8a6010a0184b672f95afa902d42fa643d30149f6938696c8da200d4b69afff3b25808778d5c0cca60cea8586e03b422817799b53728a8761b030c765913d3a6e1c945156ee718344ff1db67f64f1f081c3bcb173b20b64c5c14a52a6aba3611210934adf06b9cbadd11b37fd00b958b98a895b755ab0a3c26505dab0ad8bb84a4f44844a2be160f30609eb79a0e2f80c8cf3d100d5db4b3c9a01cfa79d51d648fc7fe930c23e793e28a8cd30fbfb4cfa2130b6f95d8aa467966a5393d4b1da1f937367b46f651aa7f82b6993b8ac001e925b7b992afe143eb5d8f101f7d3eabfc11b3e9e894038baac3ff22b4c686c5a51a8dbea6193370147c1c1b8c7e3de4d2b8d5a81c1e6f9656edd6a78abcb4cb745e24ce7b5bf99e3676d739c5d9abc5edfd05119674debec9b963cda26c46797750d92725295a9b436eea39cacf7d7d7cba1ebec0dd979389fb025aad0e4197771b33b62d821bc563a1946be2382700373a410a438e9f8ef05abe27c3e3ba19b403c112e2770a461a05c3036bf6cd5db93f3ae2935df68175a587c40234bdd55b193b8525cdb02ed84ec4fee70abf562433ce7c7226d04f7bedf7b5f291376ca8917ffffcd2e33ef332af7e38c41d82c45f3c204b2103ab61d287b352619a87bf02b315c77399977cf60cb7ef058501f35520ed96100d7cb727ce2cfec23bd550c6e021898495f852aea8f0473b88d8a2d3183ef77437df3d8ca6a81a80aba8f2ababcad510ca9c23f6c696487763aed2e8f9205c9ace793fe9dca75e005dbed059941bbeebc55995a31d0d5a4c0f8083dbe4b0876269f6e31a8beb1ab6687f0a16eb64b9d924cc4feccfdd004aa98529543eca11e0145f950cac68cef86e60d668743cd285fd5300cd2d376c7325cc0def576dfd2e07b52f90637508b790d5a8a1a1834ec9d2737f6a839a86300b22c6023a8bd38ac0b7b67a035180938783cbb2e1f49d4fec2d0a65e72a50735a93f45dc1cf12fd8cb3cc1f0f12cb452fdb8e4da742e6c6d9c06c314f991fb4bc333112e6b37888a5f2e78863681a219270538ae4e0b0cf6d3e6250776635af45bf141764957d1301648f72d66f95d482dc249d0b349cb3a8d336f81b362db1ea3d696fe4e806ae4e4fafd9efcc94b34ceb9b909245d177382f291774690fc9223cec89ef52adb94b1c921e2c2b2bab2973ef38c9b9a374267afcd69f6e4929943e92b020261d49e76aa8796dcbd2dd10e9e4f289f5c113a2b964eeb76620924acd4d0db4c6d194ab798088ab6c39b10411e5b9d4a04851ec3076d02dbf6e0ec7a8cfc17209fde3b7dc11ea667427a8f067c8be427be0c8989733b76ecb73235c1c909a0d55ffd2b836f68a30cfcb559c1be69c4cd68dc74075eb015d9848d911eafba589c2616874dbb0c2d8e06f778b703fe22bc81c4d26937aaec294fb84bd11bfba7943b67057a737631572d3c3df48bb00ae2d297653b9414404e1d130751f7145925b43196420222d14a9e6b45acb40418f56efa71a65e3cdb51be9fc3cb94abfe836432b62394d967b9502bfaa22bcbc0f3e60004f45bc82c42b51e78bee20a97b708e503e6090fb7e7e7a14da4fc5e9efc82d5fe3096a1762e4ca91f0e7ce7b4a4a6d5ddcf4fd6067d0333a4f0544d4c645eafc1ba08cfd123cbefe93b95b484214eb61a208a3c3b71f51aa554d1cf4ad8d4dd11d9c3e610f3e27c7b7b994a6dba85bfa94bd49cc84919beca6f78be59284ba9b8cd1d3d5da7b057d11678640ac3dd0fff543d1f7c48509a3bacaa72e011fff71915b707561b888b5bfaaac687c86b794f60c89789304a85dd8a6d7e84f25e6b401ea25ae530647d7ff8be2d652d06dff30ddc04813fffa4c50610bdae068968eebec59ea825319ad825d70c6e8b8426cf67ffd2ade521324e1a5cae01074bf491037635611ad8c7640ca693dce77f51ee849cf69b643151d379d78b2e711df9c955dcfc931f5e1c9b71ee664ee1529349df97209ed8d8dbdb1aed875c02156534e33bb07922e6d618d4f7c0ecd20339a24a266c4766c797116d65327c7a6b79d0c46fdbd2ce04481708565f4fe397f6e8a1403d526dd19ff37d2cf578b032a0bae481353f808d9daabe76dec6834e234dbf29323309115432f599ca711bcdd3422d90e7332bc7872dd888b82212f2c76ab8d6f7672063d3e44becc6b909c2601b87318b7018bdfacd0f8ec676d7defffad6b714e9b47f834d0b7352dc34df7d82f9fde806d9bfa4e382790b18ed8813e87068b6bb8e1ec2a9f9caaa913039e5a1c11b8dd90205cdfc19a3ce1fc8062faa61e34bf2afcd6f8a7ad6a8d0b081866b4d51479b0d88b18d07b0487e7b473333672fe746687087188144f302575b9889b42ef6da77e7bf2501936719ce7b956997d41601a208b109f69ddfd4cef5615517adba0537e59d20be811a5c956a058f736d2a65341459281ffb6199332fb37a262eec4eebb415eb04c5570d79b50b81f4c6ecc05b19e99abeca7a11c8c154b26654c6ef73b252d32f5f6fba59fb2ef626cdf36743d29812b984a503281ccd6ddad3ce9fbf9f9e163a1d2c9a0866f5f51fbe590ea514a624c40f969bd4febc003909a23b324b20024c61f7474a6cef175867b540b0441bcb5646a8c2c59d36dc5ab2f74c8afef2a4e66e4fa832f14dd9b5d446649bfcffe36bea0430337a3a4568ed83a11ad7e90a302c88c253a2c5835049bcb6b9aa1f59956f49c494caec30ed5d1c20f6bb1eae481f058b259c5c3bdb37f1cdfb3b8735caffdeffe805c350c6d15beb45e2da8e1f37f493f56a15276653bfd076ad96d0372e816230f6f41bdd7f1b6bf1908fed8fe065b72b58c1be46623e06d7025fd1289966af0696f59f9c8ee98400657b09c55c1db8017fbdd78c0b9e18c09b938d23daa29c1f6e8f50a96d27ae5bfe923de97b4cd23327a0294a4722ec204747e6dbcf597678ce1f02fe0a19d48d30e5a8c4b4522748b4f91de18ce946d2d8ea554ff5ec4607748829330921695562074c2675a2a76e088f0911e19be620d62d7a313ba02f4d4b39abbc261d0a83d0f8dad2c5389f1fa07f23255ec577297fe3e3aa8613eb6099cf4db1edcd81d55268fb166b1bcab72f19e5ff64769976e8fe2e39d15849f18990c4048b69367638180b1435702cf11c53772dc1a038a8571f634fdd81a0e17b810437a9fa6b7fbf80f2456da79f8499209a4764da532a697c71013fe58b57ec14751d71fe337caf4b75addfc82a6e0bb3cf0e9a83066ecfb86927d1a565ac98e9ad5abc55fe10261e3414ccbb36af560b124138c0735663fd87d0259baa6e0aecde56023e13f0c722353baca6ebc7ff33a019c6ab28a64e6d9a6bad0cfed4766512457cfc47d84bd270b1400a73dfa88e4fe2f8f13a170455c74b0eeead79ed1f161345300b9572ca99bdff05e6beebe4e94c916d79e27a4fee55b0ebdeedf4c3e52bab625f32e1c1d7dfa405767e5b5084ccf168f26067a98287dcca5c0b016b6338a7fd07d3b6ad17495b36948572e0b88b2ab868145f46a5b2168ad521d39f7d7eb80e809880c33ca09b3f168b7287a0d10fe82156361b717fedc5f23cdff0c4cd837d8957589390553bfdd79d390862924ce1ea31fcb16c45be5bea7750c81986dc08e26e9481d68bd6fd1547e0be35729c6df149800c74e1deb231674d339583e141ac98e400d8249044e3e1d1bf0acdcea06dbdc3b4a45b8e24c02dd5be0b74e17b1e56777bd62dfac4508765c7506e686dec8dc7c5d8be465401c464e9366e5963b2fa18b489ad30dbe7c2dc710aa145de1699e654e37eb7be55a802a6d2a9451786863f0cdd76f2cf18e903446fb258c4631715ecf0f3ccab95cf6deb78f946984da75c970c4a8c28b031025bf939014aded05abab74a019a47fbec1c5a2ab1706fd75a9e9ee20cbe1a85adc4d1058b01ec2bf07545bf25adf3ba8db969128d3b429cbd5243060f1fd67935744b8ab11b1a9e39bfa8e2a05ab0d2cc8ee7c71b85aaf4d38e4aa47a8afe079989989f65221aeee09642a5b93ce9149019ec1a561a722528e06582aeaf19722a0c1296655c3821f35fdce28c8f0db13cf274568039e4cda032691cd9a1a2e7829bf7f5334590ce5fa93ee183a5e9ea889cfd4b603178ff74e100e5cd86de92b4d393b574e495c2827154587be394f504e447df669197a600ec90d6f79dcd1e2b64c95ec308811fc31b491b48651d2594c00bc1cb2648df55fa63b66780213bc7933d9f32487433ad619e83a9c086971b02fcf3d2fa8b82eef58025d1d40538219c07ac67c6f26ad26fad6cef5ce8af08a3536951d6114cb1994d466a1f6f2046e9b9af8c1559a66607f0bc53ae046b871fec49ee5ea88b445ab057b1d05d0484311705937dd387f3d023cf35b08cfe312157e81a4f7bd3af15f817b84323f9080f6234b666f882b635e46f5b2b460927f628e059d600f961787db5f767bb631857726ae329cc7e8ddb39fc364ee7c2c8f834cf439c2fabcd1d1515eba2a253fe945c9c31462158dfd4cb9ef37c619304089ce817b5c627e04542fef6c4c41e7893610a28cf87238e1a956af29dd8df4434464db1236349f606f51106dab19cd18d9a9e552c5b9c50f11ba197e49056601b931454ae28d14f086c66b287911a9abc5890b5693e0a4ad6c63596173e509cfb587d1cf8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
