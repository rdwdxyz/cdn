<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1513fcc3f24a291e60d2cd61aa45bb74a0845c9cc907794bf0b6254e97224d04fb42e7c41cbe9a270966a29caf2fb76c2bdf4241c5aa86f3e62de9e33abc2ad1fbb637083157236956945f50b03d0f5f3dc8a2b1a94d54a1561a838f0605fcb160d780368e0172de771b22f89a3dd4b8de1a948e940f8e79d221f984871911981fe11831736f4d671ee6c50bfb19e8e8b3fad65040e8594f7a95da7bbb95fcc6217066cac8e6453422ba4b3236d007291006de9443a66e260e48d6bcd66251c4ab8ecb58c2b2a21fe06791191048d3a7f942b63e5fe6932ba2ab44713ca5f3bd8418b61eb51bded8f29d64ba6a77b99a56fef45a97a962240ba9af81152e1740aab949677a8b184d482c7c7837def92c11a994b9658c411524a973cc54c138d753c06adf5e65bbab98c45364b4c8909e4df9fb253e62fced6e55d5e3875e82901d302234118f38547def92480a3976b173a64c6f8a754a123b0510872b2966956f741b5ea479fa133d39d51429e65d6b71f66a9a10a43aab309907f34aaa07fca7d7587381631a40718f11003454a373168627a6fa5e77c97b4c29cf301604cc870a3a2334be4cad50b51c328bc3eb6a1c44a7381c5e033f0c4d6fe27bf38b269935f42f275c10dc1b1ff278e9ec56b8c8fe156d93f513a6aa938ef4e3840acc26e6dfd983a1193a0d8f199187a7695b9959d3965b26b195f3d1166c508cd90935b502e9fda336a62519ebdc34832de80150c2828566b92e374e086b6c7cb15c7e29aa7d8a7b4f4d454dbc218fcba765664bcc53a687207fc1a2a03b1af00e242c73bda03d91afedaa6ce996fa0a7fdea60b1efca7d5d442cff667947812c125270404dc1c8ea87a8541cbe4cd1988bb175aea244abfd5ea1f8b8a04dbe2e58148b13938cceb454a9211c8d1251361f671bc75e12006b3fda43baece5a2bf1b64a04f100cdc1aad1db36b9e70b8e6bbfcc24382059e88713491586c320b54fedf06424af76120640a1c7b2592a79c44658e9c4efbe63b1bf2a1c02d706ca7a01b073e8de98f77581e248e89471508f3d929b201665f2f4a0c37cdac643fd74be6d1043b1fe8540a87d0c2b38884f4bf1eb809d13efe34d0a8a78ca81250531e88cd0d725c0452dc3045a9965b33807e5e9afa112a8dce6ff2feab362fd949636e7b7ad18af34b8ed0db5d78eb8a516290d352e86f958eecbb2856d51502e956a9b323e81b01e9fae21fe3722c43b8143f9157e2cb97ef384914f6923895a515e5957535ab18ea084792096c74dbe6e75bd9273744739f9ef7970c21517b13837dffdb3ea5b686dcc43c58d0611f7dc95d842fa9ef3066bcd6084a6aba796b9dcae721ae9f1c12e7497dec3bf188952f97f7e85e000695fdc6664d071a7e4ac56b1180093ad8ac59748afe3b3657225329354fa4c24cfd70975ba7ccce3577685a90c502f91402f7f362885ccba19154ac7d4b958c49937a1f23d6a4e260dcdb891892b01a76b889ac2cbf4579d796cadacac7ae922285b60e3e1a56db92881bfa7346e7f03f3fd33088c1c7693f51b79fc7585fcd7025a70bca8a5be04859022053ef170342e7f314175b6c65f7a11771e4210a1fe3901333825792bd9a76fb1ae303d3339a8dea789de2113c2c8e8ae3737fe7bbe2363a9caa325c205c4d5f9f685064c050d66dbdbd52486950eb44db2458ff0d6c610a4265c4a9f6680fc8cb8199dc4225e2eb91ef4b04997d881314fc550c72cd525668ace329b0ca9885c295aeadfae29c3ec8bf9abafcc5ae1932071c8e138c6849a5582affc29102114d09c6bb6bfd408c3280a31166637f3cf7da08f655d02cea7bea8f152a7799208acd3397e7e5c180da75bf3b7b12919332c05540e37edaabce5f7012b8c780193d7d9838991873e53554d4915e331a7c7bbd2f9d2420283f3b933150f29b5f98822341d15607beb979e2b4810494e6e9ddea10e14a53691af0e3603f10c8591810dc2f9730c15de3f67c445a5f697704175657809f9836e2ff2f39208db246c3adaa76929db8d8e8800148b0d110402af1e581f0ed106791109dcaf89b5c3f3611b12429dcf4a97f7af18e98cde074cb28094495cbb60efb27e597524c60064efe9239f4f948aee36b09f9eff488630761f146c6235aa015d22200c45c746bcce4e6a845386b62d165d47605f321dda95b252fe9e3e4d09cdb3ec6654cc2063647290f7ff4a4e588da95ed8b4bde441ea0ce8305626aab6516f82a22b8a9c40eae0ce6a54c6ff7587fb07e2464613d0a412a6da12d8de990071e91bc6e2bcda9586d0c2abed5601ddca0efe9ccfdba1fcd1d028c93840c3ca63ab0cc5095a8bcb8f97272df871b1a50b94dd55abd7be385fee302cb76fa13c839f90eb2ed2a68c198440286aed581fc426444625e4c65f1803e9f2ff7f5bc31936025a22b50651b2eb96a7eb19d52fc7933f70ad6ac7e96b9da6c38fca401b46d454c5ced8b573ea13af22ac95fd37a721c56f420eb3df25d9d535369561827cb38e355e91d0a9e48988896640bd10c98d3bf8b2c0454f833d101af33ab8cdb9677b16c92c34e095f618e780637dc52d20791f07d1814dea0a0583de70f0e85d170f25b365c5da3dc9d17869a4cbd1c310f2fa92786144e774672fd9f9f4634afba972ceacd9fe61377bad40123b51bfa41cfa7da0c4fff8f453a45dc787ee1a2bfa51061a35e84aa616a4084f6c81fb443b5afa5f588014c9ee18b70f2e4c5094b2c2d04b5ae22d850a8a5410770e7696701dddae405f33d744862d0910b26031ea4f7981f0f6b01beb54586e182b030ebe3af2be25484a8311fedd6fdb41e3d8411bf4fa117a03a0c3bfab9186e7b85e71226f3026c6ecc98e2647890aa6f82a87640229c589d09314eb7775b204328d25988fefa37e0f00d64dc72a30c3cf3842e3ddfda14f2a9656e37e9027acd1428a003c5c2d5c550598fadcf527dbf903035a1e69b3aa8d908e543e609d671091fe23732cdbc499a0e194ad86832db55463d295174c7f63a1ad5db9dfe73d54420b86dc547c725a7df76cb942698676b00ef448647b415ce6afacf3009cca3d0d6bf33ede1cfb12c52e7866f555d85feda7ab09dda83083b4d23d08e3a510f2ce5ea554382835746e6ffdb9205e6f97d32ec65c12628e0ed2f81c4510669fcbb18a2f57ce9f61bb2405c45f6130d26ddec1914a270e6eb5e08e0c2d6f4aab01289ca11efdc1bd4c9b7365c23b9ac4401a212d19843ccfb1d2b3176f9f540265bff3d3a6dee3cd9928219fb71982888e3f0a33e0631865ab93b82c7d6a126cb8074118a6fe7797493e6643925f78230401b0f9fe0a49076000bf3ce0bd6d3a5ac339a15b2d85936693cfa7404b99bd78adc58b65358aed5b376932fe2185a21697ad7b75a323300098678352532283e97156521a4d764c93d901383651b7ad33692e71ad03182b7d11acf93db594cb9a3dd6b832717209837159c0436da19b45e07dc231dc31de5e9aa672d21982c18d41a9916734ba180bc15c3b98f7d6940a6394d98a7d1f2d2b76c916506a9a5873a33f6d1d6ba96fc19d4392d70c63e9ca2b9ce0afb774a0ad7f7687a386e70eb7a112cddd473de03d8a03ea77e915b67f5122938d602a08c30af6a36b7b804871ade4e86dbea354cf87e261f2241bbe7f9dc63ad66ec8b09a933b8425303a44cee379ef8bed4b34d5fdfdcdb7e723e484ee1b43ad3c9812cb4080494add1e2029acaf9903f44f78b4df919b0c5469dbe37f3bb8db6f7ee17e9231a99aec3306123e7e9ecc7da424b6f1fece4fad104af6dcd010c1408968071091cba10422fdbfdb2aa00a5cf848251b7b79892a1cec3eee71b43935be6a27abf5cf14e7f715a2686031af582f0d7e50d2feb0bc4e352910ef0d8c748adf9ae66df2111973e771d68494a52e3ff315e2f3aeece7b211ef99b1c7dc4eec9db1fecb17cf53963d10ff469717ef4997b1514a3f8f0a72a47b787ab53e71251bb16bd2d20f58ee9c505198c2b0ced2b65209eb315be2be8eeb69a706c8d06b231b7dcbe1ad6e61db423ce6f3971a1198b8a16231ccfc5e9c51ee023c6f8b9ce3462232e2ec5c7c255b3250d1c2028038c78e0ce0b659926576ee4d1730d922bef70d1fa4ee7ae1b1df90f1786da83d5f37c3950b462e390a530c4936548d11934a011e057a096701e3aaed567866be7ad900bb8160a7ff0112dccc371c1283d0d2e364e79fc9d2b369c2337cfbd002a61164ae030ead67ad12802969a0d0cf1d37cbb541175a35dfeed45934faa71d8e10b850178d750352cb7d3e59dca04c8e088f2a809f9d4733da0528cbbf604edeea6d6a67b499d6b40b1f64cd89cf82811538b5329aa6e849d0dfa5a24649b20263ade093f2fe45047fbe7c3651eb3affd4886a9503ee33cf898373f524bb19d60653d15c132b6bcf1927002ec44d9499d6ed677efdfe5a6e57433d09fb9e34e5b609356f508ad9670bbd576f00f46f9445adb14ff4c2cb4d572d016baf3e5e18f9a0dbe81db9ac05081797d85d952c6d417d61cecfeb28daa4aafbe7592b7345fe0b98920a33bec40fefe363abe5f43056a16196442280be57b35877fdb34a98c75fa15be59d686f676b626ed053ad1f47bc76d2842ee114b8459ef0287de37ad92c76fb5860fe0e0b51fc3ebbfe92826b917f174188a6674c745410be2f3c5662adc01bf0ba1ba5871179ebd7b4586eef3fb31addaa875541e2f4d95680b8ef7bd0e9fb7edb983c5ebd5c5b5f9ca3ec1b9c77d423c3262b74ff0a14ecd7eeb5b8890279b46cce69bf3c837bb6ee4dd92368f5f9419636769f5b102d85c7f54afc0a5dda4b8b8ec16b3e912c4c727c05e28ddfb390350692f674c832851c623ad4c6769f003ea804d42f876f09aba32c0fec3e2821b870b1cd93eb5baac9bce6631b2c9a8e755584d2e02f97a7f2e4143b48e465a4be054d897fb6595e7c8413e514402a37b11e495decb80d7b329295f1a0889641f8b44832a7953e93b73ca5caafbb856984cfcbd67448c0b7631791f5e2670f193d637fedb56e0774382e66886b486105c297098d4ab90371a84e05aac62f8095903b788dd5a35c3b6d271d64393fed98a55c37adbb060796c3b0533ed02151bddac8a5c45370221ddc477681cb1680be68a3c0f2b8ae81a6d3bbb021c687df9e351ae082894bfc7fc29ee72fead251e6b7bb20e80debe7dede4dbf7d58a6fc160eeff75157c7fc66a80cf3db77df2a46dff3c1255ae2b1f239f0f253067521068794fe043c63140105a9873b19e5969b4a463c8d355e514795fb43cd41f5d31da2bbe0140e5139d9029a1268852b6c8fb811e2ae996ee6b2774024891753ef2f3d15ae59baa17600cb7819ba015aa7563d801705fa4a02a34d40ccee555932ac326263a8318593f4b614d31b12916f8e65f7499c3e2a27e6ed1b3104504f99d6810f8329ba2ca1dfd6b50fbca399f8dad3d0a0ec52b5aa66aeaa7bf604f01073da3ca8f64a1ffb28b052694c521bbd6ff8dca4a049668902e3b10b2f7aed2bac81f032e20a3f504220b4050a94259df2ee74630228a4cf53deaf51349ba052bd34f47bc2dee6bb6949f2ad321463a90e2c29639500910bce02eb9da9cc5cbcacdcce132f69bb3a87a1c6d887062fd1e088cb7d7380f6485515a28a1c76f90768a443f4d3be7e15f6963eb2d9598902575a45817d5f5dde9fee62460c3702f8d025663cf4fb4cd8c3dd9a2c9ad1525bbcd3ed0b773f1cd4706ad0f7881fdd8b765e5a9e4aefb68abbcdc07ae298dad9f987edc291fab181a7f82135666fa99d5919b6a41250767401a0049bb7086420ff69579b22195e3fe8bbd2aeb0b888ad080330a9e6f9e9f3aaa89011235c5663fd4d52b92742157856a06b6572ffb2bb9716f857ca42fd5062f9ec40ea98bb84963ab8d8d64707e10f7b66e0cbebbbaf666a4ec033b4f670920ee8cd4f39900876a10d1c91bdf532f24b542902203d3e71066fcaf750d15647d97b086724301d5ad549ba59acfd0866bbef1673cb2a1b1eebd0f81fae1f734abc08a8f6f35cd159d96b66b6312ce1cd5beba4077e1f385f9e33d2d0a12f45b991e010bf678a5e35c17c88105c2545e0e860d2243d69ad1175d1736f373d70b6725cff554b94b9f06d49b422de266e74c8c5043ba08cad73ec28968511a5f46888d60247bd5a4116b3bd145fd70b0291a34414e8700badc62351ff8bbc637d69a26e9624f8ebf1bd25099116e5d9d8ad3c6fc37436083aa63cc0f33e69f803ca55cd468515f8363687c18fea47fa46978d5fb885dc849cbbde9677b396efce87f24d9c12dc2859e44c26be2c38c4bf02d11c61598e72333bb77e074c746030bfe07920528c86892547051c9899acb65ccae6eaa7225c3f4d21719c2f3f751c4a0769cab8d2004575027a31d374a68d3e43755edc786f026f5ffa8f23784ac5cb737343d9341b889bc8fafab2592637d85114b4605e27562143e13657c7a4db53b90aac890b2bf3890abd951b0aabe55fc82b27fc2d5c22574fb551f75f456341b487256c3af5787c7db4f5eb4eb2a581fbc24deadaae97946305809024015db087669e879044b2d22bb24b40fdfbf9e839f5d68766f3e8d8e30525cf362301e6406f92734ac72c4df104120d0ad810520cb4e79c5fb520602b51a1c84d759136624abd922b38028808e67c1e6a954e188c08ee6f99795c0a6e4c43db20d874187273f070d3c9e323bd416c78b81dee6ab5b82367b80672edb3e30a03bc9c332618f466f38221c3b7602a6f5c4b3cf39997c5e7db8d7e6112c172050edf4f5315d36644234a2a6aef37f781815de37649944fb2b65d571aa1d8ce8109a94baeb28acd4fbc9865dc3d98c6f0154694303498c96ad6ed32675f07c55710024f11c70cc14ce98e1a635ef7f80cda2f4a5266af39a2cde72265cb977a0fc5a87ad27730b70a83e386ba124d1c87679dbd204a0feba93dd1ac0b96aed0c20bed36f10e095fd63e2088554c8c5e4f7ff40b37750ba2908abb2f6b6516531b6199244003ec32de1086f209469cf237e00a78e17d37e2858f329763f4b27930bdcf0cb9288f198e861c5309eed3bb9242c8d9b0e5c5eec5a90c9b40b041b7e3618216b96a8abf0dd3d4485f409f183b958bb59de6e537131f4aac466b218ceddd0275805760399264a362d01bc4781dd3750634c8530dc6edcd82068499fcc83cdcf90e83fbbf525146764372a0e5e9d39e1becf80bfa71c2649289897ea551a275282414ebab357bfa8e3c5aa6be4b2e326bfdf62972d5dd593399a6e95ef587312a2b9b6a4e2bbb4d2fcc12048321403bb0a428819afb815facd081802b1534f9c3f6ca5a26660f10c289ea9291be07fa8c5ba2cb5290d91de11c4e74f0ed9b03ccbff52e5966967249a8a8e728bdd975a6d23b7ce714767b347dc86184f86b24bbc2d76858b570a3bc74c7d74aa0a3050b25b727787a5510fde705e2c8f2ada42a5bd5dd8e3c5d57e8f2184c8e34fc63cab28f244eab7ca26be587da59cd30d10bdf68ff5142fe8bef40905647f54f56cd97dc315cc94225c2d319acbdb06fd439e9d4a12c444f2eb9e87c7ab64285e7dd3c6f6b5bbe4e735a2b62c27140f72025a7018e6cd82b57e209e619196554d94b48cfca42064e25f2f7afbe5e9393294f14ff4ebe90ac395a2e05df7414bbd1196a656fc9189ec9adb9b942fd6dfb940be08c1b82815b97bb1837cf6176a80914fe8837b66a0271539931aa659282d225b275e4a0b6203284956dfee0fee1bd6f78df2bc5afecba9dea55ac1ab0d7858b1ac437c67caaf2244ffeae21fcf140e8b399881c9eeb7e98987cf72c3baac71671cb2ffd9ce11d11881ed0ed0e9fe449ec2ea481a7016b13c49355b3b940c38e113038f2ebb43aace7274c2b1161d23e44cea040775a9de2bb6bd3a8e79b98679315c1bd236ab0f46e2d1a04cb360f907040c259ca99b3d26593b2e35606efde1e2987af81646080c882f747c3a4a628eb604da0047a431fc27e6650ecfaebcca7ec778bafd983187022aa0a9018edaf12527d98b16f85ce12f57aa8c56877924032b6ef426cbc07b434f29c5ccebec48b315003acfea540802ec46a7781bd7cba57562eaa47642ce30697ff6a60ed0931b2507f524e2a6a3e9af38598f02a939cdfb850e137b93569275da73c1208499adc83598139d533bfbe608637e25f5d013d4f6fcb7f03a45b18780119c39c9d16290ecee2392cb896894c21982d528ec0eda719d5b5a5714c2c96d46b497fa4105fae7f08405d4dbd55eb814ec5f46cd10bb3e092afeb3d9d2d49457fb76301252920b004e87ece932f7072b30cceb34258965469380606f7b4d4f6ab142733965881e44a7c22b00dfbc9de3ceda19875ba32fc2fdbf1527ceb7a5b234baf75f3e8491464990c04f442c6adbda47b279b9ba2b038a4eff7b2a7a553b130a7714cd5e79fbd5f3e62ca154d4c1ab230ac9ed05dac0adcbc222784f520112f0132204cb278f35b4d0d4b498b1e550984e09d30a2209dee05d909c9112280be8c7307cd6c126ea65855e9e7101114f292da9ba6759fb24345fb883e6a840f97c2afb0041a324db7c397397a150935ef770ea9ddc918276203d48f2ad6a862ee31ab945621501c25fbaa9ac4dff9e88f52b0604f56b0d844f4a82317c55c68e270e384f2bd041e2427ad285a651e7736f66d73cc731ba72a24f0d343caa5f2f70a3850b42764c96014e8ae6273f8bb0c031c45fab47f68ee2a822575e21d46ca15fb841fc08516b107411533686343474f634c2a8bcd2ceb303ea3b6c8c68e2dd28277c2a7b7537382ac5008c6a542c879ef2fdaef8aaafeba1e92187e88eceebc2dccc1f8d14716ac75bb1eb61fabb374bcf77cbd83c0ac363b12630fd23fb5ab35ec98bc966f984d23356918f6d2c716b1b75ec7fc18bb7bacb4e8cf6ce75fc8e7f7a59e24f1fa31481679c7cb413cf259b34ba4d91cbe864ac6160e8c589f467c4a06b1bb024e771497ca1527d377fdb05b4c68782f0375e8a22ed2091bc8854a4a84cc554a070685c6925b3e14b641bc6986bae0545d6d02116dd932633485b24eb08921d8ecf77ff3b072c44791078624ce32e04a27f67e6faf4ff979712249d8d7ff65be8043df946fb743461065bf72ac1d9a232b94e05211bcd6470e7386c0ed87a52db474b190826d0b02ea55f9ac4ce966dfed5bfb0df721b55a53dbad2307478457702267af4d65a3639b1ecaedcfd180ac68f86068270605cff27f3f62da0e5ff2a147bf5da96cd2e94a82a6dbf89887cf18f3c113d180b7d6478e92b8cf11e1178115e73b64fac46e11c2adf00212f78747acaae10267c09c5300a4f11f07199ad47fa4774998f5f7424b28533ed0d723026ffdae50640ce9a4aa469c512f5edc704caee162a98675e3975272cc3bc024ca17a74d0f3cc2de150c6fb5ffc84f2e803fbc3a1840bd5f702e9e294141f1b7a2e0f9e47d5713f8910876e2f5d496a6ec1c2b78bb7461eaf87599153ca613dc811921c7e30eec21a5c42cb9d447dac27346a985f3537b337b31ddf934090acd201d0100b447f440c4eba33990fd770f0076a1e2810fc07bca6e702a72e458becb3c5c2c1c3bda871a1d4ff64c1d6edaad332634cfc176b10f888ad7144e68e82d33b7da15d3817d3f1cefe44a828a81f0efd7dca71064d7f26d92fb550ec53a838f8fcb8589b658a7c04c1a3675595b7b869978e6e3f1bdb3dea6385296869561d4c6e39da8002d9997de1fa841b46d84d457e257c63fb135d1baa6e026c1a42a06e8f905877a8aec89aa222d85a8e888f28336c7adca2e4ffd781c83b4af8b4906fd9ea46e076382b24b34f5b95ae1268632df8c2c12e7bb426690f3e65b4fb238b7a5f5ccdac3d77cb89a14032ef5170bee37d6a1b5fc699c6c064b702083495e857a9c59619a66ed1d8497d09c1c37f15d982317f54904608a435758c1f39168b23cb709608b3013a4167ffb3c61dc4fc0eb03cfc829434f125722a857fd891011e709eae3afc7c12b26ab5d265ff6da2456105728800c1cbebead34673d15d19af2670f52f3ec9b79f360d90492df053a21437e41254b18b679992c2b860cea4fd668fd0eb64413c8e47fa209f70b702786b9cc47084e6eb765bd12d6aa7498407dfbd38ce53bb9c31799829c5819232e30d555603fa65f3165ff27dfc6741ecf478155fba72a47a871725e270ec704ed52b47c61bafccb9e84b953b0989b3b32a61b4202809ef24371a13efcd234459b5db151321e84d091fbcbe271f2e42c8996d3efa4f0e88cbe71c2a17d053994e9b6b0417d4084e98a1be0e327e40f65548c079c14a0885b7eeaecfc50690c2df1da9c72c95d288963f953bb0727ea8886ae5978871ac83379e5803e43be6d5dc2b411f8616c04f51db618faa875b75c8724e04bba0d0fb1d3db7bfac2ba585b968c2ddafe9cc347ba0b91530e4d7b2037b70c1f1b5837f787cc1f1200ccdb4554d6a782f982bbcfbacf2bd1ff0c06bfd72faa7a9c6bdefb6b91176850c4e9cfb854cacf1dd0fdd2b13e3cb1981cb4fd9aafc22bd6bf37184678a9c38f881b2623742f7844e5266ae454c6825ab94deae947221645a1d91bcb2850c613dc9f11ab6484b047271622d0b8ccbdc258308a156b79c8618a2afae29d77d740abbbd126e73facab018d3cf31859cebb52b647145130aa0f6cfa091d5c4c77956d3adbaa53f7ae1251e3899b4ea6f1875e5d15a7329834a3f452817e917ab65f7b5b7651012583be6bb97de2e2d5491b58d4cb4310cc1085db8c06915a79e5cc73ebb6eb3b653b866e0cc5be8e766b36c7c6e87106029ad5c082bc66b77f9c93381d2fd5b347b7e99642852a0bcc7db1f0fc971f2cad6b90374f564f475f035135a86ceb7a80c347ddf989f1fce638b38ff60c079c6a97af7f395e23ec70b895b828d9c34e76090644546f12cb5d87f4ec9ce11d7a78887d42188778cae93e9729e1d7542d408e7a07cb2134022dcf074d61232a32b0f7d6afa86f41edba1583c8aac9e5c183854a0d45218c6af34363b5c3bf6789253070de99f0e221584a4028e2955c3ddddc16757c55dc14429459f80bc77ef1877fcefcd646ee85366f742be8c03b837045a4a9b92cfa49692af34446b68cdc2d7870769daae5dd9ce62fc25bcade35a8f1d213c512a63fd230bc84956a42df338820c21dc0254afeecced468f42c8b7e64077a3d36ed77d5f8b66d2f5e4b80f3d0374d796a84880c23e0cbdfdd1752a2936127e42e386089c62a8adfe3f8880279d187c1ee0acbd174d57952e72fdbcae091abfa80394a9731075e96923ea8499f9fab9b80632ac625894128f7752b6b92cb96da071c8d766e3601592156107612a6d69efdf9fe0dde46a7fa3901d2a535a610b15cae70b15c2d92b3ead678cec4814b136572c3e3ef952ce1d251e98566e1806474d9368258924e1c0ad3deef8ae88da0b3e746cfc222cf8e5831db5691f4f438d1191552577ac16a55d977d4b33d9983f42cb07acc82c88114a9dd80f1023a32a8b8a2c79faf4ef5722a0d07a0aaf389a2809668868be819c502b0011b4413db4a7e159e7e2e386eef1f00774b26451d3a2831d85e57b770cb4e1d4c147ead2bcaef8c91a2ea8a1a7b882957f1da52b87fdf7061095b97e80318ca1b090b0c349aea65f0c95ae804cdafcae06d63aaa14d69ac59f4d661fa0bf4bbb967cccf3cc7d77a8db2e1801cf30b03441b4539e0c784ce30a90d3a64de8315c0433c24c5faa39d96dc7c6423e3bf90ac4f214d46f4dd87bf48e2ae0ee029cb51fcc79dd920c7d7a311f65549097ee4ac1f40ef7db93c476515cd89e79e7d9c800cb659dbda3639c79e64e89949ab445d039e45dc99c83de3e6b7d4da3a804aab01ebeb6b2cf089f1415b53393db918dab518484a7d90d9f9b18d9c7dc78948c788c54d426f19e95991c19cef1de8205b2f9a11142d6df29a0a027794af61e0ee518d3b3da0ff4ebfe8c846b684b88d5f934c33d232e9db088cfd60c94e9b36ae0daa4f2a00e1feffce1cbde151a2b0fdda3c69b89985d2a8766310f936460b79a4b83bb703371cf7fb04ee955eaf64f80e0895a5fc26a8da36910578f8775b475dbbd94894a7b8d9867e833256432227807c2ed5a0443713017483483ac3cf4fb6c8d605e9dfecaa2c592ae78594c191d520968df115d123b176546aa96d66363c8e34a1be8a908fc74d2a88eeb1e5ba2500abfebec84bc3ad4611575279a1b48a7dbbe4ad468327fb4c5e7f85a369077a7ae37cd17ccd6996c9581ee9e52d4b70245db8d49befba61b972ced10c45b905b08164b23df30479a4e657a7cbe36965275080a47939bb41b9249e02495fa80faf7a811be6733538171a672b30d923d57445a047c7c57781c375ec23a305264f9f0c6135e557bddd1400ebbd33bd402f1c08f40c01860d709da59a4b37216b027b025fe132b9ff079db755d8746f519ebf7a9de7bfdbc92aa3e12c09671c45189b10e614fa27e57fa2a1cfc0af932df9894d352054ac9e413fd7a3003bc842cc40262f30ae978061cb7787ef15e42aef7a92c3a8f955ac01d4c8ce6ecdc0f10bb3070ae64a63a2e1818c4a9c3df61e53952a0bc955878d2eab1a7a04b15661b62b03189b3414d5c56d8b8062dd8dbce8b99e7ccbeef3f422f7deb9aefe5547a43ede27739339df5e6e8dba317b9168da73f173d27789036cf9609c902d17310a97d1cc3271c4838945c306fe29489c0d91226cbf6819f3d8e62f5e2161557e5fb1979e61996f02d64edc21c4ca2a4c9b36920eabac57df8686dfd4ac1101a8cfd3b908d8c5d72b8f2538687baf8c4b1a307e559defe8148f63bad3c27a61b1420e9f4af2d73bbdb9041200c3b4ffdb524ac65b2a5af909e90ad65c2fab6bb9a5888875f697e64868d2f9a4bbe83433c48be5de2e9c0cf8769715be144d88610d8fc65443fa320643a155e844c1fcdf0296d9af5ffa2dcb0e0a72cf6df8ea17f72f6b1e424af0ad27e0a1b513911741694512a5ba8fe1103f762a8e59b32ec95e2208b6fcdaa99eebfcbc870cfa4676097485a8fecc4315ee58b6ba0eccfb110d973cedbae85c51c6c12ffcdb4913a4c7c46394b3d0b5b7cb4e22d34d5c9c772fe71be83ecd13d9296a1b9e45f423cafc2a22f0ad3afd7c21e6e8b973f3812ab98f0f80383ee4f605d967eee541e8fe9ba65d5ea0f8f2123ea07fd6ab0a540afe605059e4dede6b0d46a1049d89cdce1d5b918a373595a8ba81cd67a8fe99e8c9ff57d94270ad1cf55d5b30ce13c3f0beefa4e1be00128c9433cbac1c8a94a37d71744714690f4cebaa4516c0a1df12e4bd94cea3c28f2a61a4f7f768f6784a06aad5fe97b4f9013c271c676a2c3cf28a5ea4542bf3fb29fdeefdcbafbae50736bc13499463110b2ed627cb6f30ecdc52a38a87f639fed5c4bd165d97fd101e46e33f04d80e468a03ef7e1ad4914f995f2002e4f6a45c26027f2d8abe2205f1aff01384d923b3b207ad523d7a1eeca61111ac3e5258fbf69a4ea5cb04bc8c33f1790b30cec34784bf520a63991912b106268de7f67a1c29925144978076fede4d44124b1322fefe5674e65a6d71761c14df3d62fe26ecfbeeee60bf78d9b4ddbc48efb7f4e609a0ae8058bab1d176d6e5d077eb60a1aef77876d27905ba3cf458c3c7d5b920255dfe33b8fad0ee0a20e3a35699b97f3d342bf58124d3e3412433cbcac3f47d393ba12aeef45410c443dfd721d82cd46cef02b28f231d8a2469d552b5dd04f4ed7797f4c9617eb2bdb5ce5f947cd52c76a9907d5cbc3326e675dccb845984717d9e7e0fa3d632221e9a3cfb991e5594755f33b91ad2f07002bcb085414ce98860b74fed78c1357064103de13a7b585472ce6ef97461a8c012ac053e946e88ef315776f06b493041ebc0a088579f2bde3e7781a59770a283b8ded75d500e8aaae55097ac2f4d30b196eee68af5ce5205144cbbc88b8cca6137fbdba180fad5aa1154caf0acb622c36e460581f1fd016e216baef7422305b697e8c48ea70dd2b53027eb060b3711e01a2997c18d2a5392d75f57be3f0c326a798802d1c13a78b7d95878609b1af455bf47658ede3d1b88dd7c1e00b366efe58aa0bd9057618446765a989534a168cc3dc5564fb607be85dadc461d001df095c81b71e921bfe4164da1200c2892908b9c84eb63db314fff05176b14eb68d435a83d13d27fd580ee3a2a5a30db284988f2c89c7e25ae6fea957312a2b45a81873e1b45c38c00cc6763422206a5444f536a9105b255c78cc77c6d7b62cf6d70c23d5ce526ec3b0babf9ecae9126e47a34cc89e2f26dafca7f0c9cf9d812e3a8dd1634b6c50600e6584bfae9bc2c49bd67cacc318a32d337f926dcb3b01f1db3f83eaa7c5a8e6dd1b2fb9d4d4bb210154277fa7d426b478054cf7c0419443e2d92499e678f5ae0ecc0d3c079ad0faccb25f2994368b7407015c890c319cc3ae4ba489d9662ed2caf0d052ec8f57e20426c087ee23a05038d8d4bb831a1494a76341f9c06f1612f08e47f3d9ae8a1cedc7543810ed89439804cb89d20b051033909dc2e1fb166f1a132392fef578b1bab55ca0d05c6796477c344b15886c2c7b38da4c3bf5ba3914a7750bf0486985261a36cc72b1bb6ba7a5cbe7f74543977cd7445c64882bdd77890ac771024c0857eb50372f39aee539e010091a99affe950bdf1fbfbd2d339c4220168e03c8a3aed7e98ff8d52f73b9e0c4e36b77e1d7e7c645e1349f3d711243cb36ac86cc5d6a48ca17198d002eb87aa24180b2868a6eec4d7f54c0166efcb68b8e0af4d1e31869b915bb7ccb99d1cfd22214373777eb29c5b2c3a50abad08cef037024e2d64b4650973bba10d05006520916352a7353e447775a58c325be034c45dd40c75a068c9e6f5e4184b9fd88656755b47108112eeae5b15d3461e98e3b65eed6b16a246a9b67029ba39612cdd3756aa7c65c9cf68b0554fbe50d158acac8804baabbb9cf0fb2eee7a172158a38a1c2ef906f478cfef1785f51dbbc71427bf99fd7cc7f077f86204d59b0d017ea6d455629c60c81333e7832dc4fe7817080a220a2d8b0021f05f4de70caff1378a66b4f9c8e0b75cfbce554a3f235551646da16a719abfe8babd4ff96fd96ec303cc15da6235ac2cecc660cd92c529ccc08cd95a435aea8dbd1001e7617cd519c11a3490e7026ff84df979a7e54308fd88c95089e3487e46baa9b6b6092cb59fb8618b9e228e21421153cdfb1cb6647c4866cb55f5db935d318b881852c40918dd5bed2d63fa58a8fcb300e123b1df4bafbc2e3376f830abd033b17e98b088608dd4a7d137866acd321593d0bdda320850f294eb3c89802148c5b8764deddcce96de67070a21ecba04aa77e645719ae14435c55311a6f4aa623661e7aa69fc1031f920687fab3070df4795d151e88379ef86606ef2566e6bbbc0e057f11274e489d091cded9464baa5bbef04e7ff4c1924d283f4dd9dfc203209fc40179269d09341961738533e6bd86402a8807a6b6761361532e3b640e0ceda71ae231ea409c5c96ad01bce2cac94b6bc9bd4f7fc6cc1eb3d864f47b0598f694a6ed7a076c2bc7f4966b8ba74548f3dd1c5bde320735ef38f44821dadb0f078f879da523ba174efb714121001111a9996076119fc09b49eba668b3c15eeaeb1eb21b59ef0cbf871b4ca0b25d7103acee6a1dcfdd69ae211515f93d4f1c0291e5666c844e360084e63e259e4c8b8b5ef1ecbf263a5d5dfa9bf4035eeaf584a21ac892a67841a29f934a8d7eb5a490c6b14613dff2efee94f768ca58704eae96984032c15f3b902631cc8d4886759e8452ba49d76781a2060f84ba11fc8e683eae5c0705a51a75b642ee57615dd065d699e4aff73c1a1ad73baa2cf7572856a3d4c9db56d8f7d8ae26c8458a49f59963289fff2f22a75526a46e4c5eb9e5eee753ba705f7b7e99b98f1db283ede71246326c5adcc84154c52a6da8ab0bd1f33ea55e0d9012010ca8ba6e9802383d8c8472f89ac8cc4c23dcbe80e21ea161453a21373ae3d2b8bbce11ee81c60898da6635cfd0992adea6b1b6c05b9df4f5097d8f113520b37f0934fcb222495195fc6227c0191431287e32d3635aac72ed47cfd44cd3734eb0d729aada42ca73a677d45a684adcf80e57f3e206e2017549eb6486615ad401bdf1d6cb2995936548e23d157ce6cc5b960c1c088e741e22537a0a9be0122e450e0131a08e6050b97749afdddb6c93bdbe629f322e85b460ff5cbff9f74aa4bc8ef4a17f12c57fe4d559c606686da5fe2c5527558430a1f58a11e2f0350e063e790052d8fbb5c1601d7e2cedf01cd749d3f03e1a61924d19267713fccb12f8fdc5cbe483404f23f3fcdd739e76557ae8d3daf360de99e18d1bfb4b0d48a29fbc162beb37057cfd0e0d3dd0b8e3a3dab99cdf3da0534b386eba3db785986b2387874f03cde804cad5b63f0b08e1472cf3555ee4a85919a01b4cf0e5367c8dd1a11e69263bcdf4e90758fdcbfe39b3d896136f54003a148aed0de76699ff358dc40361a11b02b939680498be56d2b33fdc6456a2ce5429922c4ebbc089b15d99c728e62f53ca47c78732ea7be3938900715d4232023e0b156d1dd289b7f6999a687ce0e94a335e666170e62faf36216b4b47a3f6024300ae0cea1de11bb7a36f2b6f720e2c93899534f3bf767e01b449acb69d4f83a436f6aaa3bd292ac698f50705c393cade357c2dffff69466745773428572a019da8c8c9ba41e500bff374ab1af6f1597ed2b9028a0a2de48d3f0536816be69b279727ffbbb5c4ea9eee79e352749d33fc66e77be0aba3e1cdccbfb3f56d7e6ddcee6bd8227335947fd535f99d8450fb80a9205b94ecea3dbb519bd7b309bd5b6749b89276f1d79d3b83a04a86c06e58f0e179c64fe90c28f608ed4e0083509fe93fa06bd762c1106862ccbba0533ae3a559982fdf8fdfa0772f6833428957d6ba5d33af1557d3c42805a81bb5df067e6eb59f4b314b8d12ec524d44c7ebd82d890caaea1478e13c7cacc07e01d863ac2138a50d66c19f2b266b610db195e85b6038bffb22ac0fc3c1797fb76152dc3d383cf4d012a4045a4ae9dcf7c1856445a8fc6fb95519b187b6704aab95959215ac468c994b6868e60983280e3682fb584b3bd463edca95833b21278fac76737d574814654c8bcea5328be4696179c0f1c039909799b70b4eb332839cb89d1a4413fec37a8e7cf9104e1291e792862fd6e69af09a8416a690a72516b6db4afa9c4cbf070c84d019c1286ee53525a1198a4b8affe7f01c74a3722e1c0315a7012120b121e93f90755a5d0820ef46c56e63b6b75a4767e10abd7c4d5e5628dd3a51bd41acbe7f993a98d74fb7a07f2999013bf9cd880cb1b4045d232728eb74a0e70aba5e8df3448555c2a880086212ed4a3e5dccd22aa2c6f2c9d38b978af0b393bee7e97b78f27d9c239a2652a457f335ead1f946cd607cf1ed1c9dfd4602a6b08e89e23d4fa27629356198313a92ea3985a50f32e10a79d0fb9a6390664872e8e1bbea84092574c0975d6acc7a5f8da500c474c57b492be90531a48053d1940e5205057dfb048aa057662022e50e7d8e6301a863302b941eb8fc90c1b2a9a11a4f0366332e78474ab79a15078a0d2323a9548575a61cc34a0174127f5147c782e1bcb661be0a40ffec4aeaa03921237c6a79b2ae9277763fe52460a4b87629d4b01d75e7379ef27372b80edbd0d892b3f69c94363098c29f95973e8cecfb97f45ebd6f145d096fb08173ce2ac795767de4f83db963975b6e2ee73e1c7ccac2f8cb5ffc1642a26d7e658ce1f66715649a0c90f90603cdf8a792faa5499033e90bbeaed4a9cca18590eee147c475788c9533862e2f05e5edbd66050ae17aa5addcdacacfdaa7ac07c37419d96cf97230fb9dc55fbe7edb64d93153f9d566973e43dc66c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
