<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8c6159f637fce1af413f62459e9bd574f80bf16743c9013b73143edcd5a95e89c6b26f48cf0c18997f9b60f4ff53bc5bef3b62ad260f8268b240ef1dbf78aeab0e0a418bef05f921e62f4a49c65c2d74c13445fcde33415a03387b96eea9bcfb0e8a14708ec0b4b20d1dee58329638fa1fe46c6519106bdeb2a49f11b993797c00d5cca285c3255942e019578607b970bd91b56347f2ca69892a322768e14767ff212e293f9a3ffa59cd8d25f2aca9c6632ec0383aaaf69bbc6ed7c2e3163bab11bec4d0a7842c00e28859ee28dc907fcc47dcb0f70b3df8fcb096f282e1bdbebae19d0fc81f9f5f1d5437f92b422402e8ef611d81f62cf7011079d39f9969c5506d21e05501894967380ff6ab891662873e534afeeafbd75cdb53d3df33b77439a1f03f61d88cf6691c8f1c6a9f100a4796fa3b21c9774e47b85de9c329b4c7e7812eee4e77a3a042712f8b8d81a5a02e82b4be22be5b57eb42b7a67d13d5d0babd1e13c2ede4e3a5e82c73b927f33cf125d5b6c0ede1b703e66241048a2af4700e3d5ce0c6f1b510569dbb3d1db14c92a0c9418450245dfcd79c1d840439b377df6cd2f3bf326222153108776a7101c7b3bc16bf1f19af192f7d4c19f53ffffac4f0573fa156d4ea7540707986090f55a5f81970c6577aa765ec02628a5ca7deed348f056254d2ffbd400f5474993f5764c81e2dff4fad193fed540a841c2f4962d26196c2902336012ddeec565ba59fe7ed33b95e7335a5d9f0c27851551900a4d0aeebd929bc74b03b30af05b2ef57e9d237819c296b6d86274ebe37f7c8293a6bdd724c1c22c8e30dde578ff60fea4968a93b215a8df09dde739f3f293f1156793957c31d2a38ac4c1746e86c7d5481d63723ddf6c6b53128409964f86ebb092f696f1aec4359d36f67827d2a111cf9a73e762d3c3715063deb0f904b7f9565eeda2a86d799c8bad63fdd178512afeb5c441a19fea39ecad0687404d35d1f33e8cca3123433eb14faff04ff086dfc92067b0f1127e8109a6b06c8a30842e36044b50d71f55e231ed3d2bdcb4ea9a0913370aee216375d481db674830ce1e23357ea4a13ce00404a2a9721026fe1dfe3c95e5c4a25f645746df7f82bc57d453288325a565848719668165f40d19948d2178033a955d889a877af0ce65ddefcbe9aaec91eb9a5f39f250543600d2b60d6edc43973c561a0df326928e3b6e6e8b389eb61426f729c0440a7064c722fb33d77fdb9eb98ffc0a64f8df7eea3ab8d7564babc8309f94acb1294c5360e606ab62f604b0d9105817a929638342ecc95f4049b225f6f760dbf051b084fa331d14b344d3a627be64b2b70031c28773e1847db11c0dfbc13dd041f9b42f9ea7dc5c312d96a11f500239e5402d3383c19d1cd7148623a1ddf6815f7a3456e3e881607cd4268149cedf14bb037f0ff83a224472a17dd701cf514895935ab22129eef38e0bb3ec3aea73eac2d2eda328e3f90747ed3ad084112c3b59a01e4b2d56521a327839a0158c4ee84daae7ed62b5627d226d8c33a787f02babad2d544a833c22344dfdbedf7f96ae97e6f3f13a8b43f79d24013141baf71d2aa5a1841fbc2d9a226567a958ccd4313467857105845d2f5f59548bd5da7ef2e6fc1656fdc76845c389913f280ff5d6620c6e8416e13b29ba6a127ad6ffe95a42560288683df3d9e6a7c376446a58aebbb88ff2182109ba1b1a3fcf37d150b343af84038b388c39881b74ab9ca327e69346720cf8147a4768e5b9db2fa85fb09a841e57ba97756c81ec4b440d16579af0a179ef16eadd190b80b168e66729ad349a954cec6d7918c431117f8aa6eb4181d7da7610caa390e7e74951578ece54e65ccf75674f8310b8b0e5b1b637472ddd8c7da32aa16e2186038bafc475ab735698ae7b9387eff726e278cad645efb56a6eb5d6b410966bd531aef4756004534642e673519c2c7ded7e37519dfabaa3a49f78713e870ecacb211d24752ee29af8fe776852f53d8b720ac28f844117e43b9e81547874d8fd287bc70ac481cd4b4d4af3b00409066907aa5fa5905af7df26a53c816401b254e0d06d9fbe88bbb9e1b89dafb98f5dfe4cb4322b948e4926d9aafc3770f7c8551200018aba329ecfa3b639add5ab62392351e64603e25ff9f68e7c341685a02076f9ea4daff7afd7cf7ec29793a2286c391db671975c8975f05f06d100dcad0cb4da17bfca03e6853701512cf2845b41c02c065c2766c2609d7b3b526549904aa03c66a1d82c21d5a28b48bc9b16415fb3c1b6b32b5f7b2cf9df37f9c8bb48e1052a76f91cda152abb665e1d3bf0a97a87bde7857a3529b6bbdc87232c6adcac45979ec89dab92a3db87d868c08ce055a911daac60006e1deb5675ea41e622ec1ffdf207886a8bffe03243e663c5585e52168dc53d594d3fcf792d7835c0924e059aa577fbbfeef3d5bfb6b6b2a1d1b35064b30ef74aac30883b88378d01b6b4800e922acf53a8f6cfabd5e8b1416229f47d6f005c73b25949d2aa0dda1f6b1211a67b4f4b133b8c9b9369421914ed706ed4d770c6bc1f17c85e92ca9c1a65cf8a0ed7b69b56963d1714ccc110a080b288e3ca2667ed7711a4d4d7f8e54cbb5499f345d54383ef6ae9b047e916208d6e07a9ec6918cbaa3e6b174be21cc4ebc56dff034eb1b2717d5922d7d51d400645690051265ae34a4eb34cc7d6f2f874be44d0b229edf679f7cc30fa5ca53ba5e9d2a3930e4c284f164be71f2818a82a5c5f51a23ef25968545c721acc23e32267b51addadac6f47f9b49536b8e90f2ddebb4af871a7e3e025528f59006fdbf0d0561653414228ad5337df8924375a5bb48461e3fd57743180ecf7364a4ae62ce18eadc4ffe6328b2ca1e25ed4f95ae166a969396bbdc4885fa95203924744d57d0895d60875d5c865fffc7ac356858a6f2509155c3c3f3849d8504b9c1a023e6256fe3b2b2a57c7fe86683d22e859f0c19314b7c003728b311b24a9e964ef71cced8fbea5b1871a17532ca0a271a40462264d5ff1ce0bd077b4c99053356d2923545b15e74394ad466ee8d87af584707efef9c33d69e076f04c7bd47df2d4ac5ebd8974f0ae5b78482de5be6b2771d00c2d61d837d3c3df2ee9a58ac6b8a3f3efd85c62b3d147f8aa43d4935abc26abf80f9ae6fb7088134ac2190b6b05fbc443a4313d60c257c26e82d0bede0b6ac1c0e5f3377fd0c5bfa412ec92c9e64c7c22e3b1479ae4aa6efc92e61d4fc859f6ecbca0662658fce7d78d4cdccb1aff8882e448d0349105f2d14105b9e6223e752e45b1a5b2461503e3f03018a7e7fed1a0c2064ead6d95fe3960615224aa624beece0f21700f83c7fcdff02e05d9de647331581990ae7856a799cf92f3eeafe14704b76d98225f09c171b219ca04df52c8439c521627ef5885387beb0035a0282054db7dda47f83be8ac31443200dfd4eccf7adc8cd11137f5ebf77a57cff7a54ee2e6e4bf00d1ca4237a96fd78ce1d453c231639d8c6966b62c0f5ec505ea13de8cc274938780bc95e4678d3c3a70c2b4d577be3c131e6273766d3cf0512498e3f40cb917a7c3aa493d916ad762a0404f92f2c5e19f0efc6c5c7de914216c72f1dd2831e3530d0f50eca3d644af686e460ac0c95daeb4a1a3b2809af82d9000d63c9b9f36f0fd9d3b7b0d757ce856ecdfb0fc96584628b878c5842c49909c80d9df59899f615452e1ab73699d335ea7cdc993a6b0efee99fcf46f57ac13e463cc08fbc68ef7a1e8c784537d89a5ebdebbd6b9144d51c976622af05b2f4ac1e5534182152447e18f860b434cea2e0d0deb22a12f57b61e688b95d738600b4b583ba543e0aeda1de179ef039272c522d7c7e5eefe7fb31c614eccb122d394849fe5c454ea368103fa46a33bb8a9c7df2f386f194ed480f5f8c269f1c5a5d8c3c69a34a5ccd2e15b210e91d7d0c9be6bab74f1eabe461a2a9cbb28ebec9038215cecfaabb5445152d3ab764d6b4b3452fec96366e56c33d0ed5ad69ff7b29ee4c6e6ce4347ab12da6dbdd25778c1504e11b8f5f219de0cf1f423651f17c150371b60ef755137e897aec12d5be2a4b88c65ef00a6e0bf0f649df11c50912cefca9fb08b7f74df35d60cf239bf831e9f59f0b581a5d17793726263a7f96ec62e34fdd27cfaa967c0800a5709ce45aa2af5f8f3052d8f8757b4bfe2590fb9ec44ae41b4741469e1bba4034a239a884807b4eb46bb4f477f4e0a4ad9a53acb50c9ab7ec61f894ffacc473df75ae4a853300f454cd7fe722478af46b4ec7ecd22051e8b28b06396186f6bda18948ccbf520b96bf0a4a3c6878fc7270eec2ed430d024150400602a113add5c6280bfa7d14e8f38750fc5fde17894ff58c3ae7c80afba4627d734f98bb6abf696982c9d209c8086ed04236b2f7ac8fc4d460fc5397bd88660cb77e0010b3168011be51c67f488b23942e034794630e4dca92e2b61d6354cae3d31e16d4212ee1dd20c7d315c4960ecf9c188ef876ebedf058c92dcf4b2254e91f5a95402d9ec0ca0fcb48651b7780113431be030fd69660436a04861e7570bb37fe3b4bb7d385ed9b7edfe2f49e92b57d2e8ddfec5bbd662fd984804ed5c459531deecaed52b80f8d3d80c27b69cd0ea6c541b916aa9c6adabdf1eb31e98e2affef6be50d3dd2d7c8ff5a33db352d58e8f632314d85f8f3a5fdcfcd08df7ca38e05470b194e9d2c6ccd84d9a355cf7a6964d5eee29cf86cf9795695807e9b436d1347340c90d295de57b73eb7b61d3b2adcaa84d89be8df9e7b0de1f65f76572916bee34532f989092d3ed6a122924033e03200dba9a5b51152c23ff3881f1d7379f8350129020d0a52cb6470b0b165e0e06cebec1cfe60c5abfcbb2b550689b96d12cba384b33c73a47016bb989ae182585ab3f7586623259471f61f6ddb78133c2a96edab6f147690a1aadf940cd9ad6de8d4790c2ee3e7df38efd1e1f8ac89b36f51b84a8d9278a6dcfb510cacb1f4f750dd00c92e8e13a1339ae3dcbc1caa32df940d272c0315dd05b9fca57b8eaa3e3d95218894527103b7b7f881196cca1c2ba2386b404ee8a6274eb070b80e04b63b4babcd9868e9683244da6270417a553363ca8466f3050d0933a04db4c3a25839dc36c458b4b7486ec52152e14e76a1218a65b204b1d421101dada4f668cdcd86c3a1a5bc286ad6ff8845240a0371af6e0e52a0a2cc869889bfac1d7f54fc4fcaccd38145bdffe8dda0a259cac2d59e4e9f06d2475302aa0df67f964ed51c1d8383954e70a814c92461b9f6ddbc46cc6ed5ce3af6f1d8ec3641192da8892bf3f42997fc75c85dd4958b2ec43d2aec6c8114e8b7da1219f5b45e82066c3bc5a201a06f0281db7633a9624c21a45f99b6a6aaa28885865f92c693f4431c5cbfe3b123d36cbb5365d3563cce30d38428cd1a5a352c4d73b8c7d216db544f722091750e5d66ea5233a4647ce3f7c61dba029e4eb404b9a58a06d840d1159ceddfabd8b2ed5a2ecde511e06fece20fa7392615b46981b7c10877b64d5aac77d248567121c8795a5af5bb82acb84ff8f47bdcc1e045df3994447baaf9e1503d64e9ce99bc063f57c7ada3e17c8610b18d7442cba7594a709fbc12f8ded141494f27161e1eb8e761c34c5ceaa1cdeb685852c1979da0f4b1bd92c90bfb716aeb22b9bd6b651e7fed0171a584b94a01a24efb89c33fe910ef28210d9b60d775f19c889f31d8136d55c91cf51a330dab95060cc27bf245b990cdc1cac5399d7ec71975db1bb55b7ad2c8794fad37f9019cfff0193efd98b935858e964c64bca6cd95b073f72128f7ec4de57b295066146af1e9006abd61f7b863a7bfa12f2a30ebe41313874a4d75c4567db4452d6f5005bd9e1440f741e9458652bff4c6d9db64cad0e2b37ecd1497f9aea7c0a88de4d3835311f25a62e3ea1c436b8c84d1225480ec3107984627bdac9a3c03bd2468b2d17ee248135970da9b9623bc2c0c0c34f30e5441c986ab2a654c5e7e4685617127f36cdced5ad92384796e3ce386c5f486cc76ee186862eb8d96e12acc26c4a8f216b2e67d6f5f00b3b9f3d02b8bc5b975d3d28ddf8d9d868db01967e0b06272ac52b00643fcd531816132b6055d441ad439eea1f609ad1ad4388d5ab660e219e72488ede3e4584a503c015a18d53ccf1a8fb509d941772ffa92d26b6dff9e56572df3efb18ccd0cbeebfe44ebe89b082ea485915b59acf1f53b560b4cc2c7119b5b0b0d4c1d60c2e978147852c132e4e2af99a60999cd1d00ff78152184893ab6bbcdbed7778307d9857bc21b782a969db164f5bcb764f128d4c8a4d542380a82fcc82a7dad84b4ebeef42f6c087424ebde754e4a0e40485c4bb387d74708256a3efeede8b8c8758639042fa77a3bd2f94e7a89f840350f7d5352b228ec91e47491e300aecb66632babc0334378f67d28a94255b2583fbc98ca4e0c0d56faa66d43e9e5ca1638389a25c2fd79e6e0c3f7aeeb2ffac539261ffa197a61c81b9d1319aaa4f8fdf3744e07ce7f05f08eca687e734d6afc084f8702c4e132e66db4eec73233e46dbdd9aa32368b822c11065956cc6d0e3b5a31a3590b834e58ccb082917ffde9d18317af92e19ec3c3bde003a8d4eeeaaadae48da330e484b598eb61b2a076b2848216ae00cc2b04dca84a6ea54725969e7e1e802aa17fdfa623cd1d533d0c85b7bfdb65037c26719579a95171ba9374509ca605f2bb3876704c1117f8be5adc80617ebd008955fa06d7b246afdb55e55441f8761be359ec16b02ddf92372f28a41b095cf1d99e733ae14ad5a85db4fe3b4aff82cb8e0a2596dd99dbcf63e8f02d1e86d44d02085cf5cce0b58e454573922f4416e96a7b050e653d2426f4184c8f3397317a69da8c22165d0747ad7fbce5dee3b2e85f500bd8ceea68d4dc6c53590dd6cb44588f6f3cb67b43821d361da7b5a9c1a4ec451bd888f8508be3246c270cbf502bd2dacab1702febae8ed0ba55d7dcbe9327a11c4f43a31237a3d5b23e9864224a4670a73b49fd020b91661aaa3aeea02c9ae2f0dc89bff90c93a070f8c317861b8e04cf0b5db1a2924323136eb42d040e1e90578ae357f72feaca61efc3470a0a46ccb118def430a93110600573db5ac433e321fcacb8abdccb707e26aa672022bebff1b34c4c0a62975d9ed4496aeb8135c16d157b9ff6f546129d218e16d8b0805dd1db15a70be242297062b8a272ed3571a208b2c24e5585b27b2638b5bf62f4a138856b2bc12f85e5c1a85c6c62c9ad099dcdaf97533c7a28fc59d729e9019c95f06fe89250b1eb71afad12d21c9cb2ba8d99fa5834f15084aaf6c3c48a56b1557b4a6fd66d9d949a5461315d965732566125abc38804907f2bf9dd56a1841f0ec8dece42043e2eecfe0527326c7879c370ce70db05933f3a52576df0553f1d8e14d37e6b2bdc39f6105f150fdbd6eaf0ebe6b2a0455760c300774b010a29bf1c20d13ac0a24490c5ec628bc538d8c344b7b0726657bb1cf9d0b425f5367b24c685be5639059befc67612c90382d9dbca2290338202b3c321ebee8b1e5e02d63432c6831c4a8ab158d27611707f62e431aa3fe66f7aee11c5738862db0e97a40e5f94c94305e81c64e1fed9a4247a83bcb82cf527b352429ba1f3c01f4f4b66dd09d600717a2b9e4c0dd405fb14d3fabbab1df94bf0ad9d589322244b412b731f11700535cb0146559efe3b3b6378b28e35ac3346d56c39e47a1edd3ea7b5eecddd44f4602c69d661ea967aa75f59662cbb197b0849084ddc604933bf4076035a2c89b1ccf4428d59494aa65c97311d630b997584da8bf9871ab616b3fcd38dfc3f37f4ee375c136f2e1415852d11714fbbf980e459f6bee3271452c59cba240103ccb3060666f946b582048518ecc61b198a211f95fc8d22761ecba820b2f56a8c94cbf92e4a0389c60d20d54f928b7e93def0194c33530d8ca15d17ef51714bedf267825f0e7e9dfcf938037686c4cfbae91c051c0213bc649a21c89188753d86c1b01227f9882000ce46d3c5ab742d0b8771f214a7192820640f89df587e3b13f7b04c54945628a1adbc58a4d3743c254912636b5347bc2dc889aa00551074b6f7cd80d6bd456b2cbe7af89b9f11a228a1e1a897422ede88ca7926871a59ee292278699b76743f15173f80375046ebb4f0c1ec6f1e8f729dce8b579588decb0623228ff0eaf7a964bbbfe2db83ee1eb7fec34242faafab873987979501843d7dcb4ce0aca4065014ab3d032089ea6df08ac8f3f8b9950a25da15eb3ca6a8fd939d1f85d2e06983c8c53243666f3d0d41ae43250fd0f4f14ccceaa9842bd1dcc3015e854f17bc224476c5fd653830654ef7e356e2e9fe4a237cf812ce40ede48d0671b9c9d8b49d247eb2306247358445ee05587491af755b913eda2f12c20c4b1fd2dac261d5043d5d989141c3237ddad309ed13d5d8949d0120edeae4483b0c33ccbcbbe8f7c01580ae54577a9b71944ec5599ce0d82276c977b1ec978bdc0cc31d12dcbf3ab0818ccc97f712b221dacd501d060aba9fa09df5d1256686fef60fd3fede53b40ce7288ad749acab09bad23d4e3e7fd3009c79fd4e687a0d8c7a608bbd7b12699959a6d9e721036014788d600ce610467f3f76ed7ddfba33ee5a3d05791d00f8969e2afb8f3e7850433df8f0cd16755e743d871ad44a9a96b6ed8e89df249abf54b73f0c43c4206f40a1d3f1d740effa8e15816cc3efa144bb314b66b316384d9a10c84262bda4dd0fe17a7e8cb42db1bdfed09c473b555635ee9a4c53d278864463585341a11fed4d7ccc31b75333417b4af42b983a18e12b8e8f0bea245f0e42c78c75d2d60d93e9b313599afbb0a18c44e0a2b8dd4b39c0dc71e4740a9d4a9bdb8642aa544499cacdf330dc139ba41a106a2a87dd23d0c5ded8b27d731d4a72014d95545a4bf46903da9270e271eecc3733a9001df5d708a06c007c88d4e3b71ba463073a088d11d8e98603aeca5cca3b670fc57a10bc6d6736b35411f29c1a4e6cbeb6c60cd1c23c321d832c28593bc12e08a14d045e521cfd9f953969be9959d8912dba77c37db42e41b1c6a818057fe8effcdd101d21b73aa96855cc2ac72d7544f396ba0e090ee64e244971c9d80d058cc622b3c11a042fc138789aeacb830c6ddc41df7df08d5ec5f6d66a2ba2552036ce3e5fef53f8a64edb62d99a9686207642dd8c65e25d222fd050dacc7a7919e4c3cc4208e9e374237dc665f399b05f0ccc3055c699c6f2ba98baa7614c6ae7cf093c273d33766df26e31c54a8d40bb38b10fec90f169d179b081dd365c13910832d37dbac34421657ddc624f53465088962f6495d8f0c035a270cb66934a8156f6d9d471fbfdcfb381f18543713e3766b30e4c2852eb462511f7a7841fa316aad158abd7475070428100a8a31d7eb750285cd4c6376194ae53bcae1e0f9b5b673becb76797649baa12bb7f8500a3e1c151652e3f5b018ac805ed82affdcbaa8bc96d19a6101c70d1fdd2160ccbab43af96184624f542bf9d8d0b92a050ef3e93cc76e39a7a0172c043b414c8d9611b4a34c5b0d9bd71984cffef92692cd1494250d16a03d869a355535465e514541ce199f6930bd6cd4eb15c14c73b0ec18df4e820b88ad422168d29421b180dc326c78b11c358a0c7dceec03182b8193e1c34f7eba550bebae0fce8e717957f81bba397b494e1f61d1c02c1c7fde4f0706aeda4b5834c8f60101337678fe2fea2787234ee0b7ea30494223c462fa35661d6f7e9aa464b8792a0ad392cfc04401b44f7611d5528f2331a29c6e1c8eda243cb86ff5b3a2dddd32f4c09ecd49135fbf50f146cb04d93fcc605277c14674174a9d2c5487ddda6dabb90d8df0dbec364ad84b1e8eeb23149d73b5b065836f381d2d5ade223c35d28aa5b5e18fb4f6b85f408b7b4b8970a40b46bbe9f361963a2514c79ce298f7f39bd7f838e05e62db8bfb19130b54eeec1640e27a72b92130f299cd6aa4e7df931c9f4a999b4ee3498a481173624ea19f106f19801c92c255398877830e3543cb32b8d06e19ac31aa53977c80af9e30606e85e7d45c6eee20467fb40861003614a9d219d4b3708ee1fa769d54cdbdfc3623a21f0fcc3d6f501b965a3f8d857160fe9891d143eb7325826dd688eec62c69d0c462d23ec6dfbc07b63a5315acab41306ec35c1b96c5d84e0cb88cba64ad2742d34b1006fe176b97f47d3d0f451656267832d3fe6212b98cc139e0c187dc12e461f913eab4f03c4f3c77c336a0844d9e6773b67c45687f6b05f810efd0141b37f93651f3335561e17158d48c4e56b998be2b9fee03d38abe5a06d8027e8828552ad82225eafb58ec50082ba47127f60b3f9d728abd840578b37da1fa6d78854aead60a7eb6456c7f4b497b204f4cd1e5dbddc3c602b7a5f40e2e3ca45334bcfc0e568002bd7fe053796bb1f3c85bd3fa7af7d812ea7671cbcdf64660b4942c9d054ad96591137bef3639d85500ef0a429467a01c246fe87d9b0f3dd02ed94f4eb039ca9bd0c9f3558ef7dcf217005f50b217b8c316c43ab03dc740c0f88b426fa27f6131644326399d0a064db3402cf72e889c18618ecbf3ee840230a0a7094b201aaddabc314ecb29d8b0d228c1176b0b5aeb79e1b86d129e58cf96ea0160ccecb1f6b59bc80b4fbb10a85d9872e7eea60c0caa1febdd407de39ac16c64ffc11f9acca916aae6b1e6788b116d0590ee931453f3067c3808c521c47dcf6c5247d90fcac1757bfd747e19baaa894b4365218765bf42a16dcef47f7d31f00c98fac08a12c2383ec4469730add4bfed2596b30a59e3e398f7d53cc47320e526eb4d3409cbde60e57866643951dabb1e148e450a578e7a9067b35cc4fd787d9775d1bc92a13da8cbb362e70970fd9a5d52769dba701af823ea42387d62336b0238c6e6ebe4a78846f0c5f98df1a2fa9095a5f778c94044dc990e740980e7a25069aa533b57cf20ce7db8f909d2417945d34d90310b1666c1da4c2645f0a7bc793995fc129fdf29a6ce3b7c219f1636b790befb016e04412e879c40fed444a4e5291eb3097e3927afe59abc463b4912b0b8e91e0a75f233816c9050696a3e0c8054f22df73484f85eb668558e64f9b2449821bff8cbad908cb58d186fbb65fb67befa372ff44e829553954bd5a7ed8c086a2f412bcbd00fe4f867c285b8c3ce0bed93a677baf9dd3c3a94abacb8109384472f11e4047006d3ed5529925d8fc56b30fa326edc4b8e6de71e84479376c47168492a04f4f48e7e86beae3da3c247a52891c7287b0723b5136d27b64ee3a52aa371f62c8c0faf0f8db7eb06b95b459fccf6a37cab812a83f05d2245770926fe2e6214f92fb67dd600f2fb6bfd661e28ba8cacad05487521255cf2ba6e55947d2cacd28ea891fdf977a7dfb4aa74b24048f666e3ea8383923c8211b0837e019e953f0d4b9567b6bebed3a0131fa276aab688891ecb6b528eac918366b12c9cccd77c7a0544e54ae1e4a10655f5ce721d676c861956f1d6b7deddaa0c05bbd5c3c24cb43421c65a8232b1e4fae4acf41b6a732fe9c88d386454959ed456ae953cb389c326a2642aefdc5a3ee1c69c2f2b909f4b2e6bf657a03917452f30c6ae369cd30f872589e28f469ee0167d6d8ebe1525079584c3842c5598c1a305f9dc066dee085641cf947cac1c222d5c542fc347384b73ef937178b54c51d4c93a67b904826ef65e994398b1c5e793b075d1cc2d0ce64e6a18b4d716e23ee77dca662106d15bbafd4c7ecf08a63a146481626d4566a30ada8ff6a803b7d30e0370ffb067702f3725354fa9cfcefee795dfbfadf2f6ba85e2b03577e6e835764cd9eb3074e6d1e27911c2450f5c006475793119bec05ce7c033cd1ba99631101f55180940e7efd04f1343e4b219f521e9a8dc97284b840a9d3ea6f6ab3eb8d7dda939002a21e553458ee06ac1bee55e8343953e0db746c3716169ae48bc07173b5fba356be84c4edbe0bb45a171a02ff388cb45ff47e71edb4e7cb8452e4058fe9914acaede22004a721ec91f2743fb9a260b81d28514a8bb217add6c4c819371459eb4c6fd663942d317b89d18d2a9d93f914dd2f9dc1d7c805909937340933b42b456766fabac4a747063222eec4dffe30203cca434990871c32a93ab149d66da4b48e31c0ddda1178191b19dc4e56bd95be7a2ebf6f9fe1976363492e631c1caa4a98769faecf3fbf8d93327c5811bdf78861b470a5a00d61dd90eed959e0fe2a5beba6bdec92d65e7ddad5dbafa55b7aa1f8fa5895e0d83f42cbba3d09187601d71fe3a40ec95757ca8e56608f644feb9e55f793c24a37a3b2fbe3e6318d4d9875e8106de5b4c823b35bc80cc6a8291d5520040d0e6c7f0dca75763cd17b086356a8ed61190ab3007580cc9bf82a35ed84385b21fc9696b95e14706c2c57dbe388367b3ce2fe1d8cbeac66d3dc1e283503c26c2bd81b7822aefe235ab90a45820e28eb0b5cb4140610c7c64df8218a6498ccd8667d56cb77def37cb37e1456703c976ea74f6cda25feaaafa6b0a7e5d7c52d8758e5735dfd84ed5e26e50e4d86969ebaaf0aa9b5482a921b3f1818c1266e106a42460b5235d9889a39678e120ff547707f72208ab281dfadcc770b6efdbc12f763dda10d078582e688cf24e37e52781db766e3a7fe3cf7cfe366ffaacc2807a5c560577300b226160709831c26826e653e47bb1e8b933e8b3a57913f20bd88bd92f230fa2c01a019b26e4349018e44e9f365beb42a16ff673e6cbdc0f403a702efedee920ff2bd89df5f70ceff7b8d38a3bae5c8ae37218b5bde496c80848d26f2da2493e3e44354f3864914e15e232a6d855d7933ad58bf4cd5f2fbe19de074fd88f8803c7f0562d2b23e930bf576ea0c96bec6dcdfe031fd080cae406db4ce0de96cf63bb1cfd0bfe54e26e5b60638673c5847669a6aaedfe0d2f9d2e7b25c888bcf81902ae48213bc412a20aea8dc28419530df33061ebca4eaa34c69349593576e55bcca73b06da512e51f50600b04aa2a2f8299455005dadde33d38ec58269cfc30f869b199c7e36f7bbac6e03cf25c638d1fe7bc9e6bd7032b98b8575b8b96fb687f17d71ed69901feef2a5c655b08aa5bb9379ba9e0b700b3cdea5dc55dd2866a96d72188d9c8e670d91dffbdc4e1f6b3a0c8a16bd7e75ca2689c4c71454c3976235bc27760d81b7b4634fcb227e217cd2a107e92613677aad93fb019de5bdc1c3c1d7f860a8a6f5c7517b89e5a97c69e26b1281791ec3aae4f8d7aad924dc9245f82e3be12168f9cc1891d3e3af341fc9b6d30bbf34619ec77470ce10c596177354baead92aa38edd3fd178977ec28ff64a494aa547016e00edf6d7a65a2d2ea8792ef8a5d3d7f7bca0fc77cf1d987426aff95796758593541384f1740f8694c8051c48306bc5098732c8551ca454ed61b36d5388f478235514523e7b6808940450c9f0de040af25e8f8d6e8097477579ffc805c28829c5763ee2b3ef5e982328c54302ccb331f4da9d760269427ed574d8d8af0137f081d543b379fcd4ff0a92ad8c4993eebdee28ca5431655c2be284852e1739fdbfe4d335ee152427d6182e89670726d5cf034b123fcd7d5b15e0a344b84e057f131934050762d91811a7169d98f72de4529f5bab22032a6023a6d56a5ecb3b7e91fe4f5f0c70997dd1927b27996ce528240c1eff62956d207e94e8a650fd1ed22c0a2c1d5172f8225040b8abf7f8336b5ab77126e28a023e0a744bb108e45d74a248e5a08c04e52bacbda6d0fdf551f764d065daefc43dacb4c54d9cb7225e5dde5b2d724dffebdf5fa96e46e4b31699c02026936f1596b2c729b7deedcead79cb3f4c10bea527a1a6bc5165ab5176540a0e1c0add0419ae5999ef50c59824310ab89ae330900f37cab1d8e39026a5bcc6278d6a5d17036f5add8786231dd9c9fd51162058f790a18756d8991a3f95c060a5073d1e095cc596ca66ff379e76b487b4055b1511d8f5ad3d02caaa71cc88241415f3802c3f3123520823cdb05701ada1d27b7341287018d33412987c803f38442819b9e0a1ffc63b5aad8cea720eea563f4a19f368e837a6a00977dba278f5fe530eb05e2f64970368a263975711f6e7a2c3bf4d74ae78fd72958055fd04594d47f717f6abdec187ada5d8d37aef4f7ba6c3f7c5b858a5c0c0af72ef6bca8281faf9e71a307333aa4caf9a4d23fc08f296b7eb75b4d7060b93573d84d41349fd712b4f10c2c1ce128e9b1f39970e83e56a6fbc48fae1c95efa649b8b27c41ae6ab0185c2b767db276da1bfaa43e69decb4fe9eb46357a0368aae63527d0dd3473121a3d6080c779147a7b868df837bff3310c8c8bfc6d9e7a166deee82ce14d60de4d77a56842ac3f7b5f29c880eebdf0f4162dd29e704fdf19ac2d426dbc9cfa2c2da2eea5d4c53fba976956003aef8d0660cde1af0c9de14bd4e4a2e3c69cd0395ae7e896357d03ab8f12ac94e4bb3b0c0edf961b67eea7a5d1249807a65e9e62bcfcc88f8f3b20a57301c230a28b338e3c45cfe3d05e8236bf0e9efb279da1621ca59326e35c25d7a51d883e149d5c1c25db38107399d935da83837a95cd96bb00edbe14335d7a28991683c886fa8acd3020c14e977966944cef252a12d27bcc5e3bf99e43675fc944c35bd6ba4cbe25b0500a2e6e2c90f99f5549f8dd7ede1bb6634bb54ef2d86dec3443d21e4b4cce7b5617e216ae5d239109eee230a8f2446cd92dcd059b29c5424422da04bf74382e43117c22ca7c198de4bbb3b2b6d8d14ac2a1e18a8699dc437f35c984c3821405dd46167785987539b50a558924261e03b0ad94bf25a378e54634cef89d6f3c2781b59f42450f9f0f5d7aa496da06005fed40690cb840f04858ffc6529f2c177d4062c811e44c8a34a34927c83a087bbeed0b8889b66034241b37de92fe14a94cfe7b46a5743715056cccb6b2df3ffeb941485f8d8021de554a10960ede1b58b7eababe928893a19a28b6ed57ac5262418d907f5cd0a7fdbfe2c52328dfbfcaaaf886e1f201bc8bb8b8aa17227d74ff89d0f71a4150281743c8009cf5780e88799d458f2af6a9a9797b558cc52977051cd687b801730a3ae7e0b8deab24aba8443a6f2b6c6f4151c7bdc8cacb7adbbb4bfa9d25a4c493d4d17541b032918dc4f828a85199fc3d64273b9fcd29f360d9dfeee992818dce30335d3733b155b00ab7deb8d05df1eab3ba1589b9fa1a1fa20160fe9bccf32f84714e541689032544210ec27ad1083a867e1d5f8ac7b8bb1c94c8866f7981b71624d5a01ae6454f71cdb13b75a972e4665c14da970c7011cb333730912cac2310c4b9a902b223adbe29d0db834beab50ea286f77b1b66c95efff51e468390d1ed0d3cb3844a73188e67c407cdb77460f426d4dc3d6c811fa438237c18c5c7153bbb168541bdebaeb00eaec32a9e9eb448f8c9a155218f2e5db8f90a39e72c473c91e8ba7e0d1a0f717ec9a5cd0629174f76f5844fe02642302a721bf4fa7a2c3e28672ffbdd448ec88a8140b1dbea40b141c19f4ce214b08d1d37ae270a7688346666b136ab47783c12df8140798f95d12dc50e5a8385cd5088cb257f70eeb022e66bc98786a208f14b2e46b05e12dceac88e7e98b96a9a6025181b3065b9a6be65ee949b5eafe8750c62511646a1bb617afa3e3207e84aff99d740d1837d8f56da3403c26ccf8791606ad356d6b24fb1b09283a1995ae7a932411ce61ed8447e56b631b0a0c5f3d487715af8bf2dc2d10d628458fe9f1b5ffe8c81c6f4f3e4a6d8a93934564623314ea8611f8d03f64d52bde4ce499410e0a0706a68e57ce8b891714721eb86720992f99fe32a382ae864bf5ee1a62b32a7ae75861347d96d1d8e617eb084e34a9e7feb734727716e9e949fda01cceee512777c2c014ef45f8878e0f8ea298aebc1af92e7fc312106dc4e26388361027e379c424c9bc04f99c50f40920ed9653d0397badff0b4f4a039465a38ced1405ffa162957d19a6578afbebfdb8086eb0771de3881e274f0973f96178623da77583a0af2d02ba0af3df1b089583ffc01d8eb511860ad5869a8e26d11eb56d3975990c8bcac437abe595eeaaa5ad55731d5a7828994b170b8fd44c378ff234b9c43510458ca81b20c57c0e5331b72ecf758c7e29a939154e20a26cf4a8b88af800b65eac0520bea6009797aa572fef6c8bd5462d07b4918199ac728b4dc52878ffc9c3c2ba1754c7994b8c948564221fee9e76b1f67085740dbc040b18d66fa952b55acfec0c5830b2b55199a1a3339af0e5161add5f5589935608187ab7c6f2d5a075e85918310edfbc50ca16f1c1064238e68331f84e3465f9694768842304fdc5b3b25fa6efc1469b663c5201928c3d1dbbe8abcb1db35a1c796723a6b1d30607c2783504536be9c0a68fb6c333e7a135792f27742fab50f236b0927f3260e5fbfe73047544a4e47a7f9cd23926218214010c2f050c84ae0fe0ccddd2cbf50033e6d088d6c342a07c1d6d5857d5afe2ff822e1faa47476a869f9b4959444f7dbe275250ccb80285aff7374c5e67a9affa56d4c3aa0243a85f35163a718a372e1ee606aaf60157f124906926dbb5d1a1b333cdd75545a9b00199818665c9b829bb8ffe76432da67a75d3a1874ad7f9a9a513f6ea03784c7e615e2ec595b5ff8428affd6b3370bad134f7346e3b8725abedc9ab82d3e74567725b1926a227958fac69466ff58ef8a8287f57e7946c65cdf876567ec0e7b46131d93d50dfba53dff801b0ab36a5c7c4e6d7c537b716217a556362888b62cfe11875e94217f4ced8ef16b6aac02796a4abbc3af60a9583159439587ad6a4ed0090035e1dfb392a9a7a96f5fb39256241cafa20e5651bba9c64f71bccc6a131604a1ffc289582c5ba905f91366699c2367e1e0b2e51f7ec4391432ba285b8f059306f4eae6dc0436a93cccbebeb5c10c79307e981e45d1d845acd08712448591850e6b95bf38446d7b5eca7ff33c1d407d1b49d990c5df8713e504642ec798adf1e8e591c196dd0579856eb0959b564ffb19451bfd16b80f357ba3d56f3ddc37abc1e6f882038f1c00366e5d82ab2e84129d3f37271cddc201569562d391726f2c438e95a642bc27516ed88e6d1ae8e40dc392d9fe1bc4c98ca03c45a419e52eba5aaf40f1f5b973296f90d389fbb244a774dbd4c6a327f35f0c94b4eb8be264e89465bdd7bfea1ff4ccbbf943ee2e26ba0f1034fb3f569af1a5e9a06f119cc027c00349a4b7cfe217c3db201f1df288962f941168249874a894cb38d3f6278fe5cbcad29a2e311e692a866cc6525b03821747b7b2b07c1f8a2ef105dfca484cd8bbb1c67a07ba7f7be3af667db29023d00eb97d6b51eacc2eab0eb49be3d971c39f25650a1ae1057de2d050119efa235701f20b0fc952525c2e8dabc9a2d2019131bfc6590d225cc6eada494a758f38575ae789e44f1d05fd68b719c6178f7616675920042ea637ca0e79f3c34027f9ce54f740ef27d343eb7b1213104ea626f60877c7ed68249497903575c82012be9e588dfb843e0f7131a21052c184750a1457fc3061f3fb7ac00d40354009afb03fc02fdbf5e498a9e8ecd57533ef01298fbe4d6eb8811be59ac14c4a6afbcd2f88b164aaa10757e4f52a46bbde9341f760463322e2b52a66f99da4f6e9871138b984dd0a702e1a774679ce3200fee0adf108ecd15cc3683bcae8ebe4b44767a100b532ebd561f4e1978353d435dac1f0ce66de4a2c2069b0a8974babacc7a97f9fd3a0483e659f10e5563a3c80a0e3177735164083745a227dda76268be4f583c612f2702be9a1d7915d0f5b17dee6780f85a3437f15a3dab84b928a6ae1b1ca992f1c324e587b97fe633ea8774b7bfb9def44a962532a9c5ddfb0d0da498a6d48dab8e1d0c4be54836b74438e85a1d513e6656261d1ee964b0716db28adace935267b2aaafd98e6e3a6d3b0d0a32","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
