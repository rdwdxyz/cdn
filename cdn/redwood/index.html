<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ea93031ee5a2eb99b4bad0b0eaf68381840debbdbaf0850ec4923b0dbfa6df993f3ec33f1146a7eba42ed0fec9b047c9ba8b3d24f79604621fdba9c32a077265be376e965773aba02186c0b2e22c8272bdedb1acfb3a4668e6e5b790a33352aaccd069335700f24aecf74cdd304f3a7647f05c0b311ffb77dc3ef911a1ef02ddbf29d84762353674554785e52570b07adacac5ce78bf13b9dc631d258d807e50ed8850162cdab35894ebf1ee2ddb3ec65365323a43aa5aa0c181ad865c3010fc7208400b4b5f9b713c7a491292c0cb7e206b7b0a9a696cd0b36bd624ef4b14d2b2ad740fc0bd78887da8d3d52821695962b1b516ad8394e4bbc2c0cb6949c2223c4e3ef75ff40d46e4b4be24ce2a9a4a80f7e7f43da72262191669cfca19635df7056ab21f8bde095dbf98cdeba1e9755edcaf7232b66f72d7e9f1236ce79f19d17e70fb70a7d6bdb076f5b26389582dd44265e8eceb02904596958b4205eeacac3062d80e0d2487f777476e93f5f9a1eecd2e836c49a90f0a235d0c19cfb7c6ecc010b2bb1014f67a8d0f564b0f783f412eed4ab806ba874c46e4dab0afd2c5d774c2014079fe19e6c96e5ce94bafd9ee48552ea0f1080d86b416f24a291b87e398fe02d7dca1fc674456281bf2e52da43ded78a54a56efbc6a02462cc5196a2f2a07474ba08b496ff67e958f161145a6c098a1defad85c24512a6e34642f6e2330aecb8f80dd301658ce2058e958a43613f893c7760ee715c0dd10c14e80182c18f45b15c8c5de995f37b4afc111ad4d286274e5e00ec0baccb86e5710943e760cd2a5f492fa45a13b74be82fa6c82b51287605e35efdc8bb196e70fad79f0157a24f85d08e5c6c0311530191ef5354346ebfb742d476d8b2bfbeffa644492f4dff72dcef7f04f8c1cfcf3855137648d868f32532b694996bc66e51bded2492858abcf85ea1c77e0f832b59215c67500c1891889dfac6eebdf2863fe3b27c0fe42f0349f0eb3c9ae40b709860bb685f401f0ad4f444c63eada2e88bec596fadf81ffbedb727894635898208ece281a1dd67aa812c3b20935c445d22cbb812f23cfa77610a7b43fc1d6a02e04a57dafeb55ca2f83a34ba5987ddbbfe6691b7eab859ae217e12e43187c39dac3181cb0bb6b8ef554f3359884f71d4941bd85f9420822e130b25db2c3c0b3765199ab9028eedcae5168ae0ca0ee0976721513103a01b8d857dc322970add7ae7bd01319d335c6f06850d0befee997010b79950527c9f24ae4cb8dc1843dcec2d2810d0855d0ec8eb115d3c79bd9bfa5d2db78dfdc8b869abcdd8057cadf4ccd6951089cf93cae41e8464a998f17aebced9955a8a49e717204d0f0a28e9bedb7f102e1e91877805c2c549273d0dc23a37c48147e8c4056e473e817560e172cc0d03b9381df6d29ba4e3fecea554d0dfa3c328efd48d3945432b5598e944733a67fd901bf000fd5a8c202eb55bb3a02c20e173515d697227bcc8f4bc4cf6e24d60e3d185c648dac22a35d88cf3011277beb648745434af7c3d3dc3189ec76a3db5f320c34bf2cdaabdaead484e16f5c95b97ead268f08cdc66b6ec1ffc04b10d55b4f3f2b549249cb5ede246180d8f61054e207edad8ba07f3a3b6672c9f23ae1e0d96c18d60f1f08ad97c5bffc5596db0e277f1bc2039af8d0ab9e4a534a39128139903e2798063fd3414558dadbbb219c35075fe3967a28d17fe6b0f4cfb8a7fd9fae2a255304abebc120f4e83a9e2a83264d91af512f13aa5188a0afc0ca4e86b8cd87018589dcb64a6bbcb149c76b9b99d7c59ae2e291a8112ff2beae664ada91ad043f7f3db7790d015dd9e4fcac368d24aad09077f73aaf1ec6c132222e842d0d337d1ce085c9a5f718624f665c2a2321b58dadb98aeb0fa207b77409728b4b82519a91b29f79ff8352b55039dd11a7cbe3638f7b23994e8504279b83779bfba9f5691c9af25bf724c44833eb433fe1f0676661b5a3d965bb658b18f3efb27d0f850ead393610fdb3ccc5ce8475b8d9ef0cc0edf1fe67fb3325fea19682215c5fe4d346542e80cd6c692669d49dfc6571305c903f569efc1e432f2e559a2c77fa914e9a29f7b118df89cb0b6ee7ec270152b2df060298bfa4e255c2eaeaee24ba0cc0ce706777a4a8081293ed6faa4c3142888955e1eea065a3205f71989c0c467b0f2c9120a0084cb17f2c3ca65aefe63a0cb1dabe9f1166fa60ced408e956fc5a68dfe72710daa35ddaf7db745f7c757f9d8ea8f9a9c95b42eb5f0babdfe7037d0394c1e651d8779ff6fc38568cf84ab0629e8a7b01305f8dfee03bc9d672019333deb60ab575bdf0e336f4ea1ec13c0816dfbce79e70a93831ffc82b2e6b9869702169effced9747bc557a919951d2c32d9dc9c9319fab869c61115685409876ac728f67ec56618eba11a4ccae79c96956e195a7e3dad3c9fb3547ee027414def6514207f2893bdaf07ea01e4418bb9ea025a5234b045553b5bbd5c75949047da8bcdd538da4431155dc353b356ba7c70cb18708d096fecee8d2245c2bf3d0fdbec22fc1bec2e79beb20e0fd5cf0a0d42051c93ae1d81707c1a88d5b7fcf0e9bebe7527d0452aaac90cb0a8d9c6a5040ac8eafb960b27d3194802274bb604c9c62b0f3f9422417b8486e5edf44d67bd365f05b9473612f97ed1d66d4bfb25958ceb34814eeacaf7e711185e5b01e6898112d2f0081dc3d6373247d33856442edbd755942b4da338f1b45f73c925b9671bf4edb0fd5bb1d430e517fe5414c1bf51198d36732dc27d2432b24f9f368270dc186c91e04f88d8ebc4d2a728c7edbf0fb6ccb673f19f50fb6ef02534983b805467e47ae04f08d4e05ce78352d03b3ed0c4d7f6cc027514ad797dc02e1fc2cb9b2e430dd942edac29919d54c6420af2a12a073e5afdb36a9674912c0eebc8b7145f6f48459b5ffd4f27d7b9397ad7bc33344e19621e53cf407c5ad73e92b4e861d95e899cb06a59ee6ce511ab85ee6121517b65b9eb657021199e3be72ce48926d62a7e6b178648b440b927b1d124da74498ae13dff69e2d3ab8d083e6adc90383e5bb0e5b93e2160817ea7105250c2adcacf3907abe637325b33253f4f6973f6f9618a693407c46198d74b37d20577c32b5b57ade9fd11b86fabde3b577478502752d02d530cd8303cc59ecb20403a78c9aba2c744f0bcfd093970fdc61d8ee7cf024817934959f6e57166509a36061af0b2c994594db7d4b6a2f5c3f7adebed4eb05dc6b58c40c8dbf46fad29ec03aa40c6ba164aaa9626fdf3b8317ce9be2bc423b37790fabc26bea13766df22b9b202eadf8faa8a605957728455e45233e09829022ac1890f889762c7fa17296938396a08ea09f3d5b817dd050353985567061f5e9889289a2030f813de3611c53f3068e8a800d7cc0db2a2eca276f5418a01f873e0577163021bde0127bb3d9cbed3e0762db300b5e5743306e7dd2fc966b11f4e020b4de6e4fbb776ec5bcbd4c4ecdfdcafe875c33c14193d83ea7fd7fc133a229e0ebc2f15046c93d459bb29a9fb3a2835b432f9aa8687e21cc2df740437d36329b7d60d40068b892b9d125535530d6732a0aa6750cfb934fa3e5e283fa7bb0171a12f80c02ee7d991d83ff3fa4d3bb717582b625a3765edb5bd3424dd72795ffc6e2ca9d7f69a83db83d0356618399fc488b62a791c45fd670b6037c6c4e9ea5153f819de87c2b0cd9acde8e3297417374e5177f52bc58d70dd826232d77b0755bec255339e909f910f71c6c1b3f2a583cad1d1cd9283711c10d3a495fc63f1f756d1b772070ccb9ae175143ecb2fde391067476b99bd7aeb556ea9559c180b89d894203574a8bb09f8b953793bc67821d9b51926f44e84934e67dcdbb92939418e95e50717102922dfe97ca00931f7fe9534275755163b4be3e41911d8864196aa32f34195fa54754ca5db0f689cf2b0a5cab78819384e8a5ba141a274ef20232b51a807fc1111a3a194b55ce94e085bf138a957fb05db516e075d3524098a2b6fb9c62cce6d62e28c7941eb5b753053e9a35f8c8abce18556bd769d909f656c9cf9cd0fb66542ecef57792aae204c6ea6205e221dd500c1dd827baeabead529219aafbbbab855a1a8f94150ed8f5cf287fffa5e67110019b22b2cd169b5d0ccb4d1b6f016db6b147b9251db83d332f66b07ea3dc2b1593c4b0a54ba761c0560a79b58e7914221563695e544c44578b310d2e7ace25ed4914d72412e1f65a2f7cc6327c7feb2f7d8580d45ba37ed124261f52e804102b551cddbe0d27c48a391ec9b47afe3a1c60c5bc7ba0bfb801fe7e9a954618a45941981d5e391dfc03d354f42a0d4e3ce01c948d0be1c6f481508525cf81411a5491ac8294b7fdb50a6a7868bd27071a1b551b98fbf79d334b709bfdb10ad1ffd7954e4c7baa157d60c3d24e81978a1ee9047b136c8783f6ac45c54a643259b97357b5d88cf9adca81e3addae128879f819e1c28126a35dfad5a4fcc9d6921ee3fddfa9886a263e7e84630a6baadaa359e3e6bd43b12c8847b1c9082f64f72495a17c2f54a6f99a0d11982b4108b22ad2eebc5273b0df5f81b75d0513104fdf874abb84ec733357f17547a2d6af70160848fcb0e1802dcbf6984a84a50c4adee937c3ef393ab501cb504addff2ced93635ba2791741e269c1ef5527a194bfd9ce9e5c95a88cede8638ebb22196a0a24e3050d99648fde491801298e5647333d4ced9b31e08bd652ca3b0c5de5fbe6bcf5d461a1ebc19bb54114fedb2dc13472ab2d6ee91845fb18d3c3e37bbff19b9140fef8867cf2ec7da2167e18e23be284447bd6b14b25367a6d86f9ee521c5f7c172e4e38ca9ad328d59f21a97d7f43e6f62dabc8551a38ef48ccaea8f5180723b54490a0a3494dae490f574f50cfcef3a300b4b29b69583b6229ac1982af4303002d50fa7b5c4486772eb29da40f16cc831ddeedf419c9921e27deb68dd5056cc3498a3127b7a34209179a182b5c7736dcef8773cfc8ef6042388803a66a6e2c36ea35ad31d8f19345403cfce3fa20fa3c2364a316f9631bc86e1b9c4e0aab216f29e783cbce45ba70a1b692e8d8e41720efb0f15da46c947f88332dde0c8cfc812914a422a287120b0e89e2eac72e9f5722be49db651323288cb9b58adaa97c0841114e54eff0f3e8619cf4a16d4f8e2b38e44649a2821f7c379ba98b3ead74d59204eacdff210b1b09751874fa37c1058d0b0d4c6e0411e498bfb760b5bae3ddb29755c4f5455b7d792c63a84e4690c95101a5eea4c67c240d06e4c60561db53816b5466c0bf9bf2f3d13e651b2224da95a025eb8d540f426a4d3d624019e1acd55a6da0eabd4ee8bce351abb9a6a9aa66680c9f7a7200782743c79eda4da1216b8f7fecdf6acd95acfd0fefe67d78889ee1d0c0e12ccfe8d6355af4d5d3e3ac48dab0959fb896c39ad8da318bd244cc3b8a7329d157ac0289974ffbfb9c61122fb7e9ee4e179b972eee8c4764da50c25b70383918e248f7a677e2e05291e7e6d254821bb5b2342d70527f3a2a2b74478aa12ff837b48bf24528685eb4f8325b47d6a0c3eaac8f9c555069e7a8f468536e071b0a1af62ece208b6712732dceff9f878e7eb9862041a738c719ff5f22e6e19fa55f79ab9ccf08caeb7404a4c3bc8326a7b952f4c6679ee23e40bbaf4d0a450ed463ecf323b9abf211695b5da96d3fe2a3a3a39fc78fb7e0c886b65da1506c5430aa827ebe0eb39cba9f6f3f1b680cc031a554310b051c923a1a5917a8cda694f32a0fa162e4a7248b58c1458d1b1bea57ed4f9d134819b16c131ea1b7bfa3261e49eeaa649c4df6da9b66a8b26c35a88ad9441d8b44ff1562c1cd8c66db0ec864837147aa7df54fc78159279554241c31b750b2141fd9f5ee984338eb31747bbbd0e94e873d407fc767407c7ebe0bb9f16db5d3ed7b0379d4520faf7e07f2c6446cf69f2773a49111f82049e2877048777bf6535c35dd648329a72a5b9ab46333d97d055f397d73ee7894e36da9bec69439a3b465fc0d5f01071bbba9d4dbb0aeabda616ecb84cc31a1072257b09980b8dff547e47b911df0052572239674638f268bb66796cb881bc62ba1016fd57a5cf11c1eba262ef1c267bd5d2f9b4c8ded73f5401b2d002815d07b12c1839800d6318070de572eda3971893b41314170c443c46db18d869f2bf77b50e14bae5f962f87ca5400c2f6ab327f20c0bf449326238417feebc0119b991e4d25315f6f614e5ecd631a0236b041810873fd9ede6141bac21f336535fb00d8deef52d02cf09af11eddefe1a06fffac14b02e58eb3cdcca6c095c784e46baab020b0e00de072449731e77ed9b0431f6f6d9d708ff1aeab2610fc30ea46e3376711d41744c484c6dda1777dcd20e4ed9b40472518eabde8190b30158d59f70963d75e7eb2f20ac3dc1a303a4858a73f38b54dc84d08bd91ef0fdf76fc46cd6ce4a481e739a420d1341eb3410e6bf242aa255436c8d9cc2cf40b2306c49fe5af42181fc5ee4a74019614a37d5e781d496174d3e9cfc727c357f0670dc9f850355bf9bf36ab3caa995369a7e2fc1f49898eb4e54a3e24be3a0f3b838a6cb7f561d7ddfc1a5ef80bfc8dbc2ee524dec96771953e897c4f4ef06281afe8282faeba70359889059caf3f200c3cf2c25b18273fcea10e5b292933dd2e087e4e43b06a22eb60e3693ebedc9ee055e0b7dda1e367f93163004d802308fff93118ec9509dfeb4e1fd019b74c9c2ddaea1a83b44116ff38cb0e62f133fd41953dd4f4786fbdb3e0ecadf7b31246346209dd7a61079334cc6a02af90456352250c72be4e52a6a343f08631207b5d93e89f63e8931d118ad367aa2ce358e2305abe817303222697eee2d9a979ed335c866439fe91e21c7737ff94a11d6c4ea793ca802dcdf335f34470ee1dcf8453530ff1bff9e21b057829956386e2959deb03cc031f293df8bb3dbfdfb1020d0701c1eb5f16470bc06940e7b16e3cb80bff2ffac039401a639bf7cae302c8d54e70429f2f958614d81a704c8858b9369d03404bdd230b51356b10b5419f96025d2c6dc42013206a41ebe2dad9a7c5ca4ea9e9ea5d3d1929b20e5308ac4993b3113a185285a663b312d612ffc2d674c5fbeb7871ee3b2cc806e6c3ee5ef82bd13f2129aad334de58d8966b565fc0ce2e76dc5576c7bdad318ca57b3a07f946e178b11c3066603390d6dd4233c81aad418c0a01400c83a77b7eab16f489c1f20359c515545ebfd833406c2e82174bc23a95ae456a7cacc935451612e466dbbd38c32ff2db8befac3bb680823b11b6642738996c90f9e062dbd91eae0d63cb2a93df770cd399b7dc2033a767304e1706599a28223332e379a6d9d04ee782aeaf541c4ec52f2d1f4b992c4705dfa0dbb7f82e8312709a47ce428ec0420c31e00378db482302d20484fae16a8dca08f292eb5fc3d478921d6f389d2c836f62975e5595987b01be736fb36208e24127907a03f0d112a77b62c410c84e6777925a635e572dd55ef99a5ec87ef30fdeeeef2d2930c3c675254ba8b4dd7b4d783f94d549d1d9a75f310f5da41098d4ffa9f1bdbab962d1e8d242612bd6178e844148f6dbc536a745259cdd0ef6bfcfa1aeb2f9655b9018b7772a3f4399997147688b2e891bc74375f6b239444032215efcd5e6cd39a12d1f2f2bf3942efb982454e6818ed94d5914cfa0b53eb9b262bc2bb78ee34fb101ec5f1922b3ca701da35cda29859b2889d6a5777625fe7d0c4666a7e71c87174a1b16b596aeed0ee885755d115ee67220a69542c14b887c030b286f80238e9242204ba9e17741df529949342c93d80330ed60d8d69b6883199b681de598b64d78d53a5d16eec2b00f7aae2ef43585f3e6fc43813d4e22bb8b6c26c06272ead4e8c3ecb7aead4977e0cbabf58e0c1ae6aab98f8a5dc0b587c8e31031371656c7e5724b609a9093fc2073de21844870f162dfecb57cc7c205f8806aadef584e2a44c9b168916f2d726ceced982417700e6d47843a8e84c52ed72e56ec689a6561956ee1a7af310395059f62dd6ecf9a165ea0ab89d34fcd20f38b5c0aaaca6f82c35f996aae9d2536c2ebb755e1d98a52d8db284b83e8b8d0cac97691fcfa88d1f11ba76748b63188d6e43ce22a5476180cbd50879da4bd3ff216b49dec22f7d223b24ee55b5416f47abcaf66b57b80c08eff7fb8feb61db9a0a5845a0b7eb7279c4f7e65ac8294aad1fb727a17b9110e2207765e55ce9b32824b3d972c00135135e14b07cf01e04460d67378a4c28d08bd5ea0a9e0ea671669e382777d5f3c3fd348e407547418f30256f7534aad06ed0047b5d2f18623ec990cfc29949d75edc96e25ef8065da87265bb90f907c0c35b6409546f1bfade14a3f4e5ccd8640528c6af195950319f1118cb79de810435193e209ddd16ec8c6168ba4d6963f7212d92ea0d0cc5f86f76faee3249e5f928b0fd3497e8ccec48f4179e211987ec20741bb4a023217846f4683db674de6d3a834ee51486a716cdf6e62e23ebb3c2d8b1da3f293b29d2d41064eea69a7efdf74926b3f19ec26b451c261d351ce4f48009a31805ad7ac9aacd28252f129779f57d13102535fe1ccb984a9dc8799618bdd72236a9d719afd9f313f49d0a91d3910d0cf24ba3cc446040d1ce3b25bd7e68e47f6705ec66771b088b963f50af924629c76a9d970c1055f40b9adfd3b8040a6fa4e1a9a5cae0312c6f0885138da93c697911de2a0682273a287ae939c1f54662fadf9d1567871c03a195c07c888db9f0ce02e7e8ccca51b6d3d90cd8e2d80a5f4c4b375a3ee754f9edab480c7f1096e340f1a2ac8a9094e52b4710634be2147d7f4db4773e9b8b0d47c0e8acc293997f9a00e8a08d60689d9c899b8386fb3dec0124ae353d1b0c4f1404d4ca2e86f937d196cf864ea4e53fc2ba06b2a9be0efa6870f32ab6355aaae9d5580e8ab1ee74c190b284ce1b0c021bf5061f5388224d2b240ddc621cf9524ae839682144e37099e28dce3a4921a21bdb8d2ead63a64b81e63c3d437ff9893589b92d5f6c34b327598608e72a77f974d9a706ce1480bd6cf32fb5e178494019a7fa28a62c2285dc9487faf058108e670d1d22e812954f17bd3c4fe63826d844ca04a7037d7600aa262587689ab63287b970aaea13820abc380ef7f36ab909ae98b4597324659ca050252c3b8ddb21e572afeef1ad3ab2e54468d93964e8b8ec1f93541993fed845ece851f068fce09413c4c4665715dac421c4cd40c1d112cf56703baae85fcddd852c453adc61a0bd6131a4111a56b08c5f90c4f9a67def648bbe7eb131e13c1899f26c0f1a43ef2d979ef536cd6818e18f98f9e1cba5e434202ecf427fcc6b1bebec172ba8ecd78ec999d350999acaec862f003269a8d940d1d43b6bc4a3d478fccec2d4428c7a337328e8edf2e6d80ef1207b51a40fa6f352e1835e729f84d0f196fe3c8af1fec30fc2eb69121e83cdae6a971e92db45fa201e504bf90aae1f6beade0388fd0f5f8cad5ef81c4cd37c94177e79078767a71e2e549aeffe3fadf67b3e7ef4b563c88ab31e5add17e3931fb9ea45904e508ee50e452a85bee1481e485ab8940bdb3f49351d6699cf1a1ce6341cbeab6db6eeff2b0d1d031da5a91913c113e7eaccb2c616dbab86462a1d976c1fd3fff6b798bbd689f9787f574439acd9092c4472827610584cf588a0b85b2442d0cbd47714006f9b176454cacbf7dc72e55349a2d183e2a1b9045d17cf67af0163e89b9dcf145ef7b54eb80495ec8dc4e625d86b68d7e0e59d6444dc7b81c94f99e3ea840b91df85c12e0d4863f5cd2293e0ff208dcae02d3ef83a06300b4d5857c0949a487b91fecbd6eb55c2aee7ca185f38fe81f311d4d364b8553d8148432597db9bc359f1bedeaa89254675bd518d30a1abbc7a2f30c395d26a2622f2a75a530fb44c5ef32893133d163bc6ba66ec99bf7be5ab63dec07b08cc7ad9e8bc8dad25f227ef25d7891d8a25da31a10568bc744f684d1b28d3e789e5bc7b74d6b0158400db810f3bfda9f20d48461049531db75e43470dc37b12afbdc50c1ed7a2be99b82e5eb588c23aab1d52bdb31dd8a2c4220d6173b17ea8e450068f5dde11ce7f31c1a701a13cd3b2154a2d7853f0f64219339f091dbefe4a2aa93bf664187c37f6cdb0ccb5a807fc68e25f71c57936cc3167ae03acf6230fdf96815ba9983c3de39be2ed5c71bffa3f317e74805115ba29b135deaab857623d69756ce784c9292c71a00dc42139ddaed6dc0350e4e736cae0db53c33a38cf394545ed6e634f1c6066ea229ffcf52233824349ee1e525d29fa9ac17b1afbdbce0a41bf2ba20d51abbfca9030e16487c2db71d3e2b81e89ccd2fba4b3ff056288e8d91a54c3611db0776b0bcc8d13c60a8947b15d4cfb805b79dea4b2d4d02483a29c1cd5dec9f5e7461468c9d81fd9e6599a1c387fff4c909e8bdad7fd52c87514a1951ffdee85f1842e737de5c49894544c0f49299948086a84acd756ed98b3e171c153e8e0324dd122a09703ae0ed6c8177d974dea88b5004d0767126670f48f3dc20512c70bfe9531620f9b88ab86e8227080a637b4ba012c8dc9dae7607378fb70365299a1e248db26c6d297da96defe5c05b480811282b90ea3c8c886ea604be7aa49eed8ab187b733aa3f803e512445958f73d3711d2dc5a976d2091a524f7aeacc736a13d22a238704af40d4393d99a14a6451d19b882a2ec97bd8b2d7d29f9fbcd18d034e3284b91657720b28f1a88175197333a89ce065963b35a2e363efb7488b4ec9d4d4255d65682a4cc0a9d1f49e2d4825b3d32ec97705733fdacf64b429d37dff30502d4a69ff94a8a262b4168d0d797c84f036075fe42ae2919a0e61189af07ba421fb07194c621e0d061476f685edc3a319b23c05795bafa4434623bc8ceda172c6029132e006cc9d284c307500801d4ffb125a50c5bc6ee9589b92287d9d4a19847a0abf2bbccc975894e4dd060e520bbc41641e65b1a3e6180134c25daac07066b52789d8048692ee89d69f98724a1b2f7dd84159425151bf226b760bf4b73b67e4434d153b0d0fccd087e296b7c410a131d7f5f3d678a02dc20ffa776afda6f0ab51b239e22d8a17ce8eeb3eb8aa5fc797012ca7b81ef30eb430887e9f224c405cc0a5155c32121a4d55f4bc493b61b5dfc2497bbcc90fd465b8b0cabd5bae5b43af02d2a4e6269202ecfecd8219ede69ae4b03053e0d0da0efc8aa53887e9c7dbc21ce215a4a3a1f3fb9137c9f08e21ba8f83700d55d7c55a0485ea3592fb80d660d190bccf279cfe5ff5ef1f53c47779809080ceee69ad4df98308ae03fde33ad975759be62d3f3f1436ca83ab6a0bbf9127ef8eb951270abc81c3ea7dcbd64937090299e5f378890d2c7c532fa2817b95f091ac6bc10021ce911048a2b318af5b3568ef8f327f75ee87f2cc63a25d0eaa95410074b004feea763133bbe15d60f3790871fd2c09ae3bf304900a2b2737d07ffb35edc453c21f40d39f73d6fa698fb5ccc2d91ddbb57b126e7bbb76a67883e22ee848166745154e76755c3869d7cca5bcf7b774f4300a4635c03532c68f2a3ae6e178485d38873849acec1c9ece06ababf7088471895003f8f4a10607de478fefdb0b3d9e34cb79595ff838d0cc29db41c5d37624b432690b9d30ec2c3b84046ad3f9b70907f4ced04c409ad70f0519f5a534269d8597cb4f51269fc64e348b7c5a503e3d7c466465ca9556b673424bb7d3880ac270746c54f7f012c49d5c9df92ae89829cc86669c22d914e830b62d8e971116b69ad5588aaba5ec856bea5d781d850e28e718f4ff7855b504ea24d93dabed02c0199b7fcacce5c55907acf7affd89866bfbb8300958fe37d9748dc2dd1f4333ed671fb5c5bb262a9ef90607f54421b2a1d90d83179c18402da82873a39778af43e0bb4e33d51ee73dddf141c3050df65e558c447b16ea3d4c64cd60f8513000055123f4b4acdcacf00030406c766c921deef60162bb93a7e0ecd60cf29ed22e56fe7074ee0c268fe4e49e42e3b333a7df7fbf0b603bb8687f6c808e5903637d2ddebaeb734bf9ee9e9f7fdc5d0203ba277ee5f5ea49a00c7a08bc97e286284d21fdee1d00536ca1a90488ebf37e0b5d5cceef33b036db17f38a42dc1c09fc214287a1a722d854ebcf53aaf9f36e55283d4db27aa4179f40fb3246911155543add6d18da6cd933463a45db2e01bdca1809502eb4cd83355a1f8f79976ade7ce2289b93f8034c0e8070952bfdd8be4440e4af3d9c88421f4f7071a7c0d878f5a7ca38f62fc537dfc11284aad729b90f3a1f6629114e717b9117c94fec48aee4e45a4c71c157d53b6de59de0e68ed0aa8c41ae6244373b226242ad30152c7e7e57ba370e87a79e2cc85ce2b1431ec5af200e1b88bda4fcac719fb7f51e0276a89f9ce09a8717ab41be31bebbde3028e5c2197e6b3a8d7b3f6a1dfe2d5b305fe4e3c7fcae97a00984145bc19b9c982d28ebecdb6276d8d9d8ca8e3256b441fe2e43c3158739eda1676e937f84aa15c61ba24f58435705675a4af616dc5729947035f5e0ccf0a2d88c828b452d55dd0d4841bd2972f83f2be42aba307ded3452f85266f529de50d4dd6c0c29780bb850d5880db16d898214f46fc983e3ae410ce7590ecb648674a0529e515ffbf976c23b87aaf75dff6ec3fd963ca9be344faab473022a76dc07c76b0fec83b1636df75954598b5aff28ce42fa216019fa58a9da9fca8f8e3c030443169cc7c309cf21c0dab285233e4e6f68bd5898bfdff304b80f488e820268a6b2b4ab2448e509034a2a87b0ac33f073aa06d4428a19c595cb0158c2e2105ce389ae629eaada33763a92cc678cec70eace026359d9ebd4d1f39ca4bb35bad208ece707947ecf0a67217ce6fee9c8e3903696a0451cfe6c9c242573cb3d8ea984d8d76bee326579c87f6f501d265d97b001a00779097f07eb2444b74448176d4ae603086b98d587dce7b1ed927d202d28adaf761f1699e2fbca2ff17dc8b94f2efaff6381a0189f63911a684fbbadd4d51c680885cd41229f26dbbb4cbbbf5a47f1af063ef73e6ca5c2247b7d162854f8300d387af922332953aa28f391ba5b8e275a525182832226e3cae59c9a3464f56443f5ace38be7e076aa40fa2fc7d51e4da693ccc2d793c572130b0a7ac959eac252222b52274695af0c90b4d4a8a5fc6a8ac7e918f48be6e75f27807d12391dd136c3364f43f3188258412ac4b1d5d93981d4834b0408dd809f71e13c3bb3293289cd97f5d4aa4176ed35ecd85741b215d1eb6f263d89f557a2331c96d8032e9687531929fac6310e7e844901a68950cf785f6845ca80d660a4f02c7d4d79eb5ecfcd45a01dc39bc8ceb863dbc249fc5a31bde357b56b4dc45990ddec2cbcf5889bcf0c7578c811b0a2e2ce1d9b266be0ee3efe28fe170899fd7e9334d80c1d31600b1d32f11fa85538e85f46b8bf8c089cef99d27ea7a114892a05d631853ded82e20b45ee5e2dcdb8936dc49a175797aa450846290de230a8faafce57baf10e6ff845e571b4191b665241064aeb5594df64284515649e48c0dc329ff6f42f7b705435ec677621a20f0de1beb496db26be116fc2607b22603f5a8845517c375bfe19a5dc79a37053f751e4f0e3e127ca221cb29f7bd3d575ab059dc5529a8005777a8013b246085621f095928e5ce5e93582b3d379dc32ed54c0aa1c5c2d62ecb96ea9247e5dd55b3e068283fb4a0e8348e25c605fdfe3971c3a7ee8d3ee19232949d4960a2bed72a22e3b2dbf3389a75c80466688e7bedd8c46056f2cccd621117524eacde8e15a7f2a2a1831aad5397d62a575309cfda03e310b4cd882caee8a962315dedaaa13d640c4af4a305fbfa97a1f606b12586c6fb7072e145934ed2eaae6ec5431fb5a04ef812bbe6f0cf62c349176d4a9f235b4e2609f976e29cf5f5a6fd4d92ae72a15fd51842f4546697a062d99c191b9b218875abad3796f03282afcf9452603bc579f13cf3e7efda463df40fe2c3d0a3971476e7ef3326d19c6780d6d6cb07ac5b627bf2436396d155c3b47b3dae03c3d7f05240fdd0718c65e5b52caff35d447622af39c3b736a8c7eef7fba20d79911d7c84298ccfda8ad659ba43d48b866f324ad276d57d27c14b70cdf46edd7a10531fe754bed9b434d67c97ee902c881b5fd3624ecc25578df286ac187ed1ce2ea57303ce83852be3dd3e37596c63bcb5358da7ec5674e67e2c0dc42559c80e953378232bf921267db36c3c88e6ecb1446ed9ef009f1406cb12a40bc119f5e1a901012c4f44ed3708f2e453bbfa5cd6cc6a3c6a319ea159febc78d643567b87a7628581b84cdbdd42709402cf89697098a745a30d80a5b5b8e7bf093ffa94dbe2b382915bbfb5aa0bd1d451802dfacc955c48443b85436a3c7d33160689987e4877a8bcfcc4411cb140914ea39d0a611fa2e3fc71b7df862efbd40a74457b4b6081eba1549828d4b431325779a357e4ee02eb3a548fdce76a498677d2af08b963ae4b772297cc94a350c72407798518292bbb282a76ac2c04c064997a74ea846961c671b55759e8fbce9d86ef61f387252688f245afc32f140eb91ac194d14672fc571319986a2d40a89589a6423f999bad9096fd3e0815884d8496b3f7dcc4b79588f681b548c2d9163bd8317f75734734eee3dd8367b3a16c0a1425abd589090b1e15547aeb47e3c133878a9a56596b14985ba467d79dfcdd1f156dab2bb1bc2b209e034ffbf96867590a59aa357a796d38296d0c288825e6b2172586147f8aa9d2f30df43ee4e8f2faff9a6d6e05d82b1b2862014c159ad6a5326d54b8a35a61363207957f480ae6d4d84e67b83d1dfbf04346f2d287312b2ae96248daab4845132638cee4f380339c485eae71df895b0be26019b4f3377a5e1c15f6876083147b0460b2be77fe475f9c4b4343051ddebd31cf9a1f686749c65fcf35a4162aab969927ae97f7a644ecd2061481908efc983f256fce7bd551f6d2c54b93bba05419f6cd01674532feeb67f0cb32f766a9c831a891b00070bafcb511f43f74cf8df6c2dbb22a25ec0639635c9f15da3078f7954e4b4f5179b895d10d504f7ca74d42ef8a7df44df1c36d4a2c41160a7eb49ee033269adbf8bc019d6ac0945e4f51b49dca1e7cbf81dbce094f9c7bfd9aeea0abd88faf71686c7259a76ff36f4496ead512638e54130c70778b724845944c547dc8c2be729c757a8fbb23329b6fdd463be10362dfa497a8f9ba9f5b7ee1705fca849e86fd7ee7503df582c677fe2b9985d124e09a00e750b3096359276e2782a93e3ffc6d30deb629b89c1db6c5c52809368e737e9c4fb31a0923267c4e74d3813548b18c929b2fd03b301f292a7b26ea05181a7b8e9e2e376424878ec3d76d89a337df049436a290af7f67814e252779d6bbe8905ccad1fdaf6e7335d6231bc67d59bb30453acf63e637396891985b51d28d0a1def0741d44549209ad9bb239dd830b7291643d204c851721771a74af26040dfd9668350f0de37fc13bb11671dae7e4a2f9cf3be9342cd4cd4c5ff5c9758e1dff78b5e2a399e9b88556139e0937b3e05f1c2a537bedf42226fd0f2238c369b8c6999da0c67dda10045d2e1809a3405ce5bde0424b64ef6cd2fdcbc9871b1b2e640da4314e653707d18ad747eee618fd0724e725ac1cd7bb53e69987daa78fab0e4e1ea1c9d71a8feae186df9de81b44b64090835972e133d65fcdd14b90ecfda1d178c498541d410d27e23d0887e61fff6377a2a6d2b53d4135d59e0028e2a6f2238b13f3033f0acbabea85a669a4758f56357ac629316ece7f328801c963a49fe320f8dfa521fbc456071263a4b141c9fe5eb5f24e3b14cc2eed462b4333d2405c8d79ad164311a65cceb927d742a4c195a433b528a550502d4e8f60d93102901597e2bfbda3d338f65f094124019389d87067d3fce56a5426f3f8a55a1cadced7dfaec9a48b5d4331c5df44ed907fa1ea64cb50dded60349da646ebe1b069ec65909dbc2c9c1b5bf285295a164abbb42f6464ca62e5d77807c34a29320236c189fd80907d322b8db9bdb9e729281a7122703f4f439407cadf5b4f09afcfa63bf04d90d84733913ba23755ddb32022159ceb94f9fe9395ec2f50034f5e6a1e5320d8190815f3b884f70b07ec14662cc08a8bd7c3684318c087b87a06c1c8f68c6cd6722c0300399cc329a93445d4ec61222a014115c4e3f5dd711f0dbfd6d343c9f9e227b11f5aad4d889a7d73d85bcb7f2de7a26569671e65a69c95995912b5fe4d331f7f1fe60c44848f11ca9af51356c63a6d17d1e7c4258dd08c290f17a14133f62464e210c1fe5339b297a56aeea3428828c9975b92aaf1ac593f9aa2987db75bbe22adbde37bbeba2cb7ed419acdbffeba407a5adca45ead2b5550e4b1b1c25a9dcfaff454560dd7fbefdd61fbf5fd93d35533954ed427daf33b3ff4978f475c35e5e7d4d3d2fb568ce8615530b0e0649bf047b4057b2ea804c0b3f2a1c719c770600e86ba25af95472b6863f4acf3ccf4def10d2c3a0fc60bec206bfbb6d8d110e2b526e7891fb3309a348c8713c65e25fb03f8d1911788b469bce88022892fd8f1b10e503df4629228e2e6e1a00ba890f33983cb0f477875fbdb005fd67efb7ddcd777f7c56f521d69b4c141c912f64fcaedc4930900358283c0c4eb30b8c8a2a1a42a8231e99e322b75132d9d998d95c5595691db454ca3d00bbbe29720337a1346feb74f3db499725206b84597516a7634c9e8aeab2ca70f78c5a175a270b0e9e0442aec00fd556c1fa8f5bdf931d524c02b1295cda90df55b5d696f9472e8b3291c5d58715720c4625fc3073737c8c5398dbd103a8a3dae8f81e0cdd2b73808e7b59e73d17a29598c2c10d10a866aed1871171583fe0a973720b1b8db7761f90d15f30f25717a9a110c2d5ad7a1d2b4df809a4ce1389d131809a6d8c39add83974a84ce8376992d39b1c335bea89cec3ae089ff79e55fa7c1ecd2fc1e178c0d0c0765154aface03e172199f66e15d77fac420f1490182f3c0c572e990ba8f67671cece0d9f2b506bc27e2a69fe0984ce10b66e30d1ebddda4cc16a4234f49eec5a279d8805fef3520cf7d7e092cf18be81a21e8fbc87b3c9cc5e19e413e054aaa22c9b059422df09e4abe382eb88837c0d40aac57382e25b506982656d1f9444a1be9704877dae93d7385e02ca9ef5a3e290f7338537d064409a999b146a6f620998d3975beb815808209be2db0a5b685f9033d94662241c4c86a532d409ddc126801d6a4086b3f72b40f9592882307c5f2b2e18052b9070c5b75eb21ee72e1e9a5fd4f1ffff382bd6450ff967c9e13ba5b53125fcaca83ad531295b90d34352f91bc5894b353c98e5c5a2b8353e47ef6c6e886064016440c09bf94126dce2d72b7d0be87d5854bcbfe015210a2b62c528129a46dda4f7ce4fc33add12523c90e2339f3ff9d77468598f74d28f6783f05e6b42040d0146a6a59b7c9fbb879407eb568c1840b6cca4378d0045f6697fad4755c50d426ccf659e53ac6544649ee02376908220e1fd42b60d992f5bd160aee87c0a843a6fc4d007653102471ffdfed362a40cb63c78a18b286a50a2e7ebc42ecfe5dc47f15cb34901e7c566c59b2988ffd8bc44ad3d0a9e84abc1c663ccdf4bf88f2b43a9364172a4fc3bdfd2bec35f7d89f4232fd9886dd80538f9ef91efa7317dae612b2ceac15095f3e98c873b7b6338293d72dba32673535e72fb21a240995c53028f2f0e1ed44099461a012d7cd753b1ff81f70537dae49752cc6ea7b7389df1716813d7ccd83fb8bf5ac8f855bd43623edc2843a5e3c83858bd200156c80e774f65adea978634b0b646988ffa24c614eea3d4ebfc72e80f8d314ab6d1af1a2118ffc7904e41d61d52c3d1c715df5412d94cdb2db2eab6f7afbeb0b0373961","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
