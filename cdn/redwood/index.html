<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8babc5eb90b3722af28137aa9d90b2299b296457540488553cd8536452fb86fbdee4ea6b1294147b4b78b9a423f0a9c6fd68c38a7863c76d665f5262ea6383d4b010bcbe31eedca01451abead9495a92414e7fc6c010943a1c5429b24c4ccd5462b247d73ad3932e98a6e1f741cbb523bc187a425230b2f84175ca8e6750541c8b8cb0e772a5f30b995fc2cd0c01d763ba14a74d8fa0d8d503e1c0f78d6f8829ae498d7157b35be279d37fca9d98501ce651f9388ad7d6c1015fab3a85ca784e2288c3158ccbcf800b60f1f4c30a7a7184ceb2e42c327fe84a7bbfa5a94c709df2ad8a99e5b373ad487bb7ad26f74e81380fe40563775b383c5e3322ea33bec94b9d8d72518af078fdd74c162db4a3a724602db05270f444fa22ab1b1655e086e097a38e42e1cf3d385931867ba79ac72a205a728123d634a81ab5627f641e306dffc6c3ba054e83c659d121bc6f4ac218c3e240db17358b204ada82ed74c630f99a295bc99201cb6ae4e9c2f76b7399113c0500560784ced293f50260ef069345efe98b74b30e7477965ce007db0bff55ad0389dbd87ef1c2ab55ffd84fa0bd03d83604647429a38bc81e0ac0e76d4fc9d0f7be7458ec5160614df69876039caa702c812aa8c09d5469693f19afe84d05783227412a374ec148a827401bb46fa7456abd1fd000c3a62c1dc99317393678942ba79eacd1ae8921b61cd2c7d641ea15e119cdf6e7a5992ff3f6b55d9697f20197036f6e812a9546ef5c20413ec4295f5e2a9fc7ccbcf470aad229b0f260c87ab43ebe4a30b2f648c49573647da19ad2d924d2d7296bd7292f01b84cf58ac7b78e098cf023dd4ba50a681893d56ba785b7db3a3c4e8b82f9eaad1129f0d64dbdbbf67fa0ff5aaa95847ecc546d26489296fe090466462a944938a5c8304a8d71e34b68d97972fc53a004403707ee19fc5ad710a4a0a197d7104b449d438fc16c76346e1393d9fd94db223e565affc11635cc799fe690d9b572fb415029125ac220fb37e571ac7c2d1803bf697d55ed2ac83f561d81fb57e0df7889ae4b7883cc6fc3b3ffba0fb7f630210dd0284e3dc1701d64457ec8f508161ef2c3365c56f4552fc8b68050ada1d020561125d618581a508306c229c3d4df75f7fa6419992beb0f5967c08515aa61ecb2c211eda5ef115ac3566172eff5b2bce90458540b22fec07a6975fe557410946318983ca2657f7952d34db75589336654787905d177443fd23330d55795c2787d7b8c107b4f1957aa75fe0237ce05879c897cda8be1c6c5b1c2aa133c2d36f87534c26b6e96433698b5d98cee184d8e4d038da469f0644958f8f166d42fd42e67a490fcd2dccea6eaf07267541fddfd8d88cc38b7c189a7cbeacd8ebfa630b5cb5a35d1fc7e7f79ea5ba25c17614f1a60bc07de9debb5781202337a8cafaffe86f0e0bf9d0d6c65937e4edc92ae2734eace12f9079bb642787a8ab629a1c24719824dfe83958803eea7401090252ed628ff28afd189bbc786b316fcb1d4393e8c4501488f3c72d1c5108b8969bfc9c64dc951196dd3150ecd56d64698fbef44fedde1ebfaa4e0e07feb29d7c3cfabb995290c1710355fc0d91537bc1bfce5465815f7be5f24649d53312c8c5d9f8b203c29da40fafa4720518450375fab941bd2bf1717e648d01359614b1d5ecb1594a83aa8a853fd38a0eaa5edb53daf00465f5e611090aa04b6f60754f7d109ed50e47ae4f32ca42226fa223669a2b14ea01c31e16d326ee5ab733a42c82d3620bdad1eb42f63666c2e17c43887dfd2a5928c7bd14ccbf2ae91dcb06f1a546d3ea8297e70680d755f5126e56d1e542b2e69ee39bc610c2f5fd80a47c0e2152c44e28a8e27e73cb01ad8e1c387d6299ade69d5840886060bd3f7bca0f3abbcb65ef3e15deac2de5a12955e067d46f2dd4f3977cc3ef08714faef93aced2b31dfa778e2bc28e7fdbe69da6bebb59bee638454c7083d50cd771e987e92e044bebd6e0e4881c8b18b5ab3d13d39617af71928e370a8a50d2b06b6bc8659dc31e3639aa865c68253c25d4642d083cd668f1627c8331103aa2aba4d24abd3cab683e22455a5a12e0a8f2f4a5f5145478acba5f0eb2ac8d35330786be72cd4320ae0b247bdff80a2d7ce9b45d596daeb20430f6942ca6b594f1af31e48aa1afd4e268093143760c70357cfb6a464efe30bf20eb0efb1a858f0463d252c094419215627db9092167d1d3c609d865df067059568aef0bda9d8987b9658e8824b4e273b0bb96ecc5ee12a50a626a7e3b54eb6c78e99fd4dbf76b179f50524f811ee0eae831c5bf0b4af71e727467197d47321a217f15c13ad43b6e17e095a44a74ccd73ceca67f75e7815025976191430b5b7e582b75a08e69ca0697b71d308e432e096cb4537692b206a26ad97146502fa9b079f6824ffea3d00006fee26e51decd2ff9a3b0d89d44e941be1e0e0d4cd9714bcd04270e05e4858f45406f32324d8760ba4b42ba3c1bb67a9cb6317fd473b0bf694b91804aa1606aac15a2c01e51c0cd53d1d09dc52bd4efe7a4a4f9fec6d00f959675a59156081775c6cb51794210a10f0b9887525f0c11130ec70f298535e7152e1b21e6309dc37e82608b4280ed88434ca2809773934b8b119494f17148d4fe5d7f9cec63f7fe20802d0dc875ce43343dbc59ff0760a35b31950797cd625c4d8dc94c311792c6403a63b097a4e0e2ca51f366c23f916863733699db06062a4513ffc6f738ecab0fb7e2a13e144e054cd992081548f93559fa8da7e93aaca124911559a25842186db9392907062eb8d2d8a48b90981800dd751f832f7db032420e00a9ce626441ac1769a014b00334e4838796ac441a8f3cfbc4bc33e0ef0db33f04870bcb9ab4195858ace61a7faecd568de098ef3aae41a9cabc2008cfe7835377199c8691ecc22304ba035048b6c2ebad2bf4b79b228986fd002be3b78fc4a4720c1f533fe29a24b4cc8f4614ec7b865387e02a7bc0ca89a9069a85461534a1c65e07f04e3c2622051dea9953922c0e62d4551a1993067a5b20c2873c86bd818fab08d37934afa2eaefcb6406c826922daadbc72de519c6c2f72f61f371ec1c4a0a8107bd4d4444101d388b60f9659ac295f4bf7031e19ec4c36e93412688c4cb8dbdfbb200bfc005e0453a35ac1042218bd8bc34d1e1369d5f0e700ba2f5d5f4e60d51a669f3f57770a24dee5128109fc26351036596ca9ce66778c449f682dbecb036f209b241cffca09cd38cd7094f615a5b9eccae5a575a782eb4933b29778fa70021390885403b483285ff3995bca4a527e2172d3d9707707224a0c2b73d4dfd445aef51bb4326bd2b008f00218c5622d766b0da494d0d4c1d680d378086bb2569c96b31c1c61ad15fcc96c0e1974517cff833d6c8cfcef86fb72b5e15a5b6982c86961a3e15a318d77890364135dcf3d4c753941fec9144f7e4a80b2b3f6c2a951a816910baa3c539e48ff6d4aed341018f719616442d45199f7ae05477b362b27068f1f087c15ec6acb238c53c192595f1e488684d496c2ba00fa851c5bb16b421b8748d832e8e2cf7dff450cba1bbe0096819b0d38ec8047ade08da7ea17a10997298d40a598942444012ad39e06ed35da406d5cf1889ef4536fa2c3801b4dd001f532ec06284de7b7b046cb04f6de8a3642a5194843367c2967930bf69f1899085f8645eac87f9e9fff634fd46389f1d0abcec77fadbd54b50d968b981a87af6ae87a0005918109a2a27f079a789f6d9640a16daf91ac1bc5d32469b690edeef81f786f9b3ed62215c7e4af4b3fcca3f2a7772ee7994e200870af83a7ee10681a7a1e1b432534387a07c2d4987b8c3c82acee01c149d7a684cf3d23f23192a27d947fb2ee355397b10d99171c55a81bf6fc2efa615af66b8d9bf45ba361bfb46be20e1d973c8755ca33c980718e85176df3ab51208f49d48f042ac1a9fa7ca720075c52a703cae8e25264b77ac737c101f8fbaf03bf1b1464c0af1248ac6627cd3f794aa2b21cfd7575d849a89d1c652e7bff3ec2b72171ec2ee684d9b298c50cf3ee3f6f262d9b7db4c3accd2aad7b0ecd3bf06cb1de2eaf606aa340d8504b08acc166e4b769f5cce722c2d725aaa87be09a0244d5b2cdf0ed94e4e16d5b1bba18f22f54c57942d71c878bf012f1384e494f2fa813cb10427d1af69cd23c648410842794860a9342445853a2b10ab2c3eb1b4ecba3c68ced89a83ecc313a55254087e7acb808f4e348cf17ebb11998d39f085d4834a6d2a43bbef93fc012414a9d932df472b8b84a44738501cafe0bb2b2534f473e4ef47bf50fb843b69bffb13c6c362480054d20bf0dae8ddc4498888b27cb8d3bf7113b87f36f33f43afc436e131f5a9a3e5626eac035d8fc366e95833fd07b1e61bdcca9c6123c0d0a7f906fe59e5919829f9a3b1d9e6dd13f49fda68876908a857c7f94a9e2699ff465083fdc6d79847d24e11dba1824bf6a0f1f8d0cc56c67f12a2ba86e597bbb848a6209e9acc12b19081cebf2501e354b243145f621e1a8b05ff52425713711b8870a3d17a73e53534b1a60d02d26643af2ac07b3dfd6a3c64ee7af4b0db7f12397581608de650841d914d15076a41a2bc8a5753e703ca85c02d23610a0880db3ff89ebbad6d598f7082d13fdcf137491edee006951ac25920a4e057f921365946fe2b2daeeb87cc5447e5ad61184fc79c5322c65382043b0dec1c76c821764f712ef144ed41e88a9d1abcd46939390725b585adc428276af7a9b9ac971db74fd28e8cdc0c323fc0583ec8e9bb738b7ff8303f9638c51087886b07245c20dbb8d8a9894a0341c0f4e6a6aaff66a57443e7a14b2e05a867c98e32888055551c5a18031eda99267c081e1e6c2389b5ca1bbbc6589bb7b1c6491fa4885d6590927bf47b1511ee33c8c0c2d8ebe5e1413d605e0e4d2d407731e7317bedf9e1aac158f5d7557595f4606a95c213d49d394d7c767044246d5357f7f119d977ef96665f7d695d950f1d99cb2e87b2f26ecaceb706f32c53122526b885c0abc9d81f05ce25e035b478d8c02127b8d4ecca1692662f1e86bb61d0f9fc0ee31c34a6a34ff4ecec354129bde9cf2c651882b48d36a36dbdfb546fe1eccf0ee300feeb82c8853c18216de5a3419a8c99c64e0429fd640d52ad71a605d42ac9a7072ba57e9ddb44e226fe4457a6ee904df2e6891aaa4498177442646937c60cfd6aae1d9ffbda329dcfe1331da1be9fab1be6e1b1ece01965732d6c5c59827fdb46ed0fac100dae91b919cce0f288c1872ee65a9257eb98cf95febce55133c9bc27a53d515168082f3d5d3dfcefcb7fcc9af1d48e21681805b1c448bd04dc7c3a6450e49b52d006edf65aa0ecbdfc3f0da1288d84482179f8fb4130da35f6cb5fdd363d0b5c20e2572581af71a1c0b8f359bc265f4fb8d9b2974377560f4f58d5ccb85352c5abf343922f11234632686dd928161147f63004cbafd8c7a1c14c1d12aabc254e84c460d3bb4cc7f0c11d20ab9c6e269303617a7bc915628c5316de5e13fe5f498cad7f15e78221296fbba91be375901885c842845cb456cfdf8b43ce814f3c92e1154062de792eadd8f681cdd5ad4e93bdfbeb797006236937444932156bbed9085d75e738963e2835ee708940efc7b455a7152fb234af5e2dcef789f33594c7e025971c4fe44ff2ba3449609dd4056ff18cf532b42c2cce3ee620959316f62b6554116c0b49d4406ca7743f6dec434e36dc7a8bbd78b8e2f4600c866fa695aa88e884a4b2c37e2f166a6aa300ab05bd5a752eb5f9d89cc8f9f58d5a81205ad1c085ad3f8f607d530e60570505fed87cdbc8be7a9f62ff9361bed61423f5359a74ebf74b2576d8f992b151787c578dfe2f15748714f7644a02cb27b423a0dea7fafc86bd7a4f3cc0e585165093288c981831b78650f6b44d0532fcb3413c8e4d96fa1eb7468bbf3c460dc73a28772580608135c7b6857414eed7f2d5349bef3514d4f6bf30d7f4f23cf36fb2382f34d526bc984d010cf726d37f37e98faf96b316eb21e611e0cde9165030d79e7e36101d0fcfe9df87bc1d834c018262ac462958245bfb2a297f7a527d93125eb9fc9c0ae5c747debb0db121e65560375a183469cfb1f79fa843a1c570ebb94a117475a97dfeda53e3c8d3306215ca436c8bfa0aab91b1e961c41023ee0ffe085a0ff802ebe4c8c4f10d4c3116c5fa8fe71b61784eef4137678751adfe8b2e162a5df60656358b25e8e9b70a4b0358cc886b2a737e18df24ab6498ecb677e863891bde36192e3f0fd332331a267e09926e3fcd29eb54ed42c0f92cbd2e19b4394d7f3f3b16d9274a7d5ac40292b1a08322dbceeefd4ac63a5cb3692d8d5b0491a1ddf2ad8ac6742083b4f0b7150909b493fdeb44141a766ca328c1a62810e8bf63685172170f207b94795cfc1498770a8e4d33bf75581035a94d758b0a5fb0571865f7de158e95e9e69f3f20cc287ed4a47f92356fb3cf78160b15f74592bb7ffba21050df78b04638cda8ce1c0a66460c124afd68d56b0608ac668100d5e8e6f6867c4564f6795651efb9ca09e06647c325f68430d967c4e2c41602ef93d7815223a425fbd6f8d95410f140bbaeaca5e6065f6668212936ca516ffff0069515dfa08e57d3e27a45eb752f795311ecfa1babb24d1f273f593a7a9193bd5ac79e49b724a189772dfad87bcea76677db623b9fc8be3ea1ac07a7e52465db64c253edda29f1f25e53b41707f28d9fe35fbbbd2cac63d86be54b6c78c35f126080f11816bc3d1425b4bcece998c05e1955e71f539a65530fa6594251f1e91cfdbdf38bbba922918400e90491264664372f37ea7912022c92a809c53677ab293055dd883b9dca7b8d3c7a58eccb966ac4491fed8f6c0f766f98d4a66edbfa141ca51d4fe3aebf7982b1ef00390b18bc0a1052d1ff3d5a30de67d1c5e48236e2f00f4d793968b4d80570dc5fb3e7a0a14c32651c6496a2c2168ab7745f8ea82e7f8481f665199a7ebcc31aab62c92ac47bc9a46cc770aa492f6ee26d7028c10911ae8cd25a29cca7c4a39288f666befc0c1976ffd3eb5ece9128c62b7997efc4e6ba0374f52d5204842d99ef0e34f8b9c71e88e767bec8cbb37f81182f7e3442f915b48bae4b39e18611eacf8125783c59025baffca45e85ebec87d3da94ee0aeaf3bfc8e8c6f9d6f8df18dd7abe29de45e2431ab3df5c957da267da55b5849ce6fd8c06e8760333ba5347873c648d56580cf55faea6770fbc6bc5278763444ac3b00f48163cedb72ffc568cf98de2ccf76cc516f6767b5f59b9849db68c385c3b9366db680d3796d12930f777ed042e5d91c084eee3e5891c60c3b14e075258bb430b8074c20ee3105c0cef4f7d7741193ea7844020a35e4f4b56d790847933b063a38ddadac490296de5e1f26a3bd722f4a24e4a9d3929b48376944b2385cb9befbc76bc4e11de3dcc1e25b4d005dd713649d6bd9ba245b867ea45f97664532b665d8cc4a6bb1ea82d1ac7e04e97f4f822a2a49a9f60dbcfeb4ee2404847268059c0dd9cf52be0fed3f4d449cd7a5450be2146363d9f0875025cd1dfe56bc3797670138aa4adb0167351b33a45f2256cb33bf08e9a801f87407d6bffd31e9fe8c090e9570bd9b6784ace1d49e993078459d1e1e81606f559cfefb1251aebaf0224585f651afc0ddf1185cbcbff1382977e83f574c79d2c4630bcc763c2a5d580590941a5f7b25b4bc711c20105b23142aade18a73c251e25a6345c0186aea7e537e39e467de897aef3c62274e5cce492615e01cf999a3461c72968832cc5b5dd85f7ef68bd616903dc21a0bc7bc70c2a5a8624a85622177200bd43860bbcad54aabf79bfd2002bbdf754d7fcab8a00e81f8f6b8e88e7b331a80df5f1275e0b43cce62c3ce4a1246cfea551b4bf8354a3dc0009409566d3c2532762bc27a0f53fa45eaf721dcfcf35cb26737a7105f5f695c07ae3abb1d1770c4b1598e5bbbc2d1ab359b72a5a1a937ed1437ddead892f5c9a9d21d5b82d5edbb2d6baac8c6968fa9af3fcab4a976b34af015e2e22ecd26ead23b03b79dbb48f7580985c69e6b61cb995b77bb118fff23cb644e2976ba87311339b8848c8cd6e504b5ed96880c03561758656f7c6d284ffa2247b331bbcfde44c00ee0c73e80dbcd326f9f4bbd22313674e1eab0b3aaa8017252b5212126b15eac4aff011da5f5e5062407a61160733df9eb94d1e41de478f371b04bdb106fd4011937238132e452ad9bcf0fc26a10fe0b1004d145cda01a1853cf58699ef12b3c0b75d91082ed97ef6e0ca1bd36e6a596eb957bc07ebefbd913092ce81d473a35dabc8e70e688e66d67cdbef6e12e8785badf2fddf8cd8f20f0ede7eb13865f4586168c47d155e9e90020badd8f87d51fe5a3f9463127da636b6a6c75d61f98136c77ed191f142f5811209e0e3fb23c3b9c062e5794b3b6d85f4d296e6b40e9b745e89c151da9eb306d35dd2ea7830c70a0233492b61780ae8e0640c7000e95e528eddfde28c18a7f4e713d1d7472835c73b73779aecf514efa19955d6fb1f89d7d5d9294fcffa8e295dcb71a91dfab24806b47764cb4cb391e7bdc2fc69a600573a8bb444d9dbf240e002568eff011e5079825683e45f3b7e3022f17b6a11cc657438b09b4b47fef04de901c6cfa56de6d95a3dc2bbc992731e04b0ca37e582ca8fac4c3364d8f5a810c9cb68e67ae3f7d93d09dc0ca48cea9b43653c07e4b430f59b3da746fea92b4e3f84e45d9e5f4d0b3db7aaea80b5603a8a27ffb670ffde9e1809958f0dab87f8fc58d5f7f0c1aa2933feff7126d24f4eb7c8f77ba1e6ab16fe174bf742f47c0f9e29483337ed91aed53a885e4449145b440ed0e543b8e00e2a4b9376041f97f966e20ff4896c161f2c1eb3f85de91cec4d1f64614af90598698fb6288b58e13e701ed642b7aa220bce93631c37615918421190099e248b1233711f21c892f67da258a8109abefc6bdfe07b3642a74789c70ae458bfe18358c10dddc5d936024bfead377eb6e5523a4febb821d34e695589b9c5db031f9303c7e51e748af65e8fb54a4580ece5c2a8afbcf71c5ff8c1eabfa3e547fd337ab83a5e7a8dd97898ca83e019d47a936a399a67716e06dbf03ab3b923c7284df75b2316a52fee15d5592cd105311231f4d35791815657afd0b19536dec615c519a730dc0e3353dad0dc05356258dab2a6838f7d964802f7a79f23a9077dcc413b3b6e3b77c9a91fdf3c698d33d02b857563db7b0c8fa427a0e099186307e806b91ea16ea00322511650da164ae93c2cdc2455fcad9d7d5c494a5eba856cfba8c722691784fdf3c47df06974ab29975dcd415be4681acea01c069805f9c14b57a9490638f17f19f8dfe1009aceceb851984b3ed56f2a125f456f3297758f69e66d43895c5d98397db456db6d2eea843da61cb28696bd570a5f14e7ce708f6d9653631e0974fbf4950baede9c6150cd5d893b08ac62bb6b8a8cdc4c62086c3c826db22982e7033b3117bc665f4171836f5700e003d23fcb819768fb2f8f95ee85e39e6603aa107b6b6ddcce489907ee034ddc122e1768087fa959866f5abb970ce8a1f3c0f491654898ba8de819b5f51fbadb0a0cf5860a914e85fb8a7d4cad9802eae95c203903bebdc24f48785666c0444ae0ff259e27bf5699e019361e5a66b5cab2965db6473b0606b4bcc77a049f6926ed4e15a80b7398d546775de58c7b9a0bb1160a018b499505a7cd5925caf8f3d509421318176cfb9ab3604f8e49cc1e33e6208decb9f8143b56d96bfead3675f8e3840e1c9e7b972e518be9bb3a60d08d177aaebc2c47dd12a3127451b4ddf73666faa7a2e009f6ae4590fdf16672d4d31129a7d86a89c59e6d48a69568d3d9749a6b604c2523a159ffe350d182d5269f64e47295393efff138dc8f2647b285761227471a7054e3b02b6e2f4ea6d98630062c1b5aada85a3a66ecce1b4d60deca98e9c64e6f26888d175f3dc2a3c435e68917ace12ee9f297f76c52ed11ef4b1628faa74f52459af8b57cde2a3ccce27035a5751d1f965221e8887e711118617feaf850a7ac02830d5e64f966b418beb1c8654c8a1656ccab66ebe5707be7d5bb4684f20f465687000d3143d46c1dde23fb43ea0f7df3776c69f4a2f1c8bef3b022fd476fd51042beac63ae2d0a2eaeea474e2f9143f193aa7a4e2cd05675fb8df79d2d3d37834085e5477138d42de13124c605a366f3913997ce813aa756803772a5c37a9c257381710ecf2e8ca59b9f76105b8fe13194475f04c0a8336400292023643967d835280f703564277276d3a66e9e9da58ab4e6b7519dc1083e2ccdbb33a2b026acd3baef5df4ab96e57ce5048af9aa92ca95589ef8b988f7c61154247cbd93d73537957249fb857bf73ca971985e76ca5d47631c829992084828263e248ea06c74e0ac090132f29b257a0a81f633b31ad4630a71c2338d1b1e1388c24dcebe781e08c0455cac0061a79c292af611bcfe482c90af2402191f8c0e645206e7326ffefdb6984c5c3cf325c44daddcd130718952874e132023dec918f7d6e845d84e6e9a94e9cff5140323dfd384892c76ae6fb86a4b44a581db7171f059ae4fa40136c86b7e27338c80ce82df7c05bb8a2e1cb587fad0fb407732bd7f5d6acdc008f225c1b367ac55336195e15c8f31e628051c5591d5fa2704d18e8d9171ac5f83e60ccd2fc1cfabd57f0c515512fc8bf220721930f5260dd3a22921ce40037917f9f90083fbb323da2ba180c678c10596449c5c66c2c3cb5118ccb79279d526cdbb20721bd87f45b6ef5c33b4aa97ac3ac46acf12ccc707b90bc1a0b07ae3ff3101f275c26ef01c709f8c84dfaa4f96f8331a55d122503113a4707c196d6ce50884c790ed02cd3b223a398e4d13edb8b4e51555e5428e87c838549ccf78494b5eb2d7d918d6f9f55296037d318ea9a10aa9624d008e5dd1ed36e49554231d5c951a4f61a3d2439b02a68479fd44230bacf2517291348f70db66c1096fa781695ed376ed0485c2ec6dd4237e4d00b8af5124c4dfbe3efebb1daf45cbf3552d19f7aea99711f2a57d0ef93235834ad2072126e779e1c032b250ac12d619f84e7a9d51396a63505cd43982e7d53cd62f253b92a246497f79168a1e99a1cc2045cf7b50315a82f782a9b77aaae5b13abab7fd632f5b0f44a7a355eaede2edf08c078188b611d40da820581a31fc32d87be183e153c9c6c9b9355d0a374b2489037bb9119b040b3738424027a5c0909a4b45b0ddbf2f713c162680fc81f8ff81198de7b38b28b033fbca1ad5a4a128ed439ad45899a45dd1901b3f062baba37dc8cde10435366252b67a0e2ffcf8fc1fd9b6752d1296e830f4d6eebaa6a779ebb3c9f6552f8623ed12c639ee22b7c3f424451acfd3c799c0adeea09f71e9582b399177be7ce5689302a6430f179ecfd5911836134d0cb932aff1a206498a0092f6468ae04ed32d1fbb1f731c8ba40fba8b25d6913ad3e7b1b1b0170edfa76f318e7586da193cff0afdfb153c21e8d8bbbb17e5ff1a8745b26f85c28f73de40dd9ae4d58850a8c818580a0dad036ff114d9fa029d1cfc1038b98a7237892ee27ccc7a21ff3c68d6adfb80533dcea42f90a496be18e1fd046b1e5e3c811ff63ecbcfee1a7a7633933bd9c8023676a750c7ab360d8e67de537d11c1b705c48a43b42fe6a92d455c77f74a8dc967af97a2d6c8ebc6be7b6b8fd37dd52f1faa7ecadbae5ee9dac985ccd3bc1867b3449626cf870edba840d7b394982ff06fbc2a33b702ebdcacda81a18f0ac786065d080a1e3aa4c0473b0191a41814c9c1a1c8fb54f60b98d97968bf2d64b47f3a001a110ae519cacfe567a5866f0765811ce224874d461d13831c3fc9ce2f4cd6fbe494a78acf825005f25fe8098c77a5226bf95a8b2c509759164e5eb3514de7d0e8f49c30e08e9e8b05c9bdfb52da6f92416a062695700bdbc35c4ec382ad84415f3f31d7494e0809279c4382adb77848e3194a6a0193edee7bc130e1b8cc8a6570245e796ac3c97b4f34ab9a3bc3ff0ffca220ae3b08e36b938bac993dc24f14f16bf846eb71a10c8b8b496bdd95c4ff807f74b336a35c25c7c92318ac9086fbdcd18c43bfdfbb10fe656ebc6f5c16f97f6bd72a0eee4196116996c7783dd3b742f18d0924d111b220d35fd1dc68d6c2813f244ced8d47d4747710835178a0776c1887174423aab6ed2cf2b82a4df4b556fdb061ac28584d7e3129befbfcd8067b0c28dfe07ae5155c91cccb8f8053db8051753b2213237c1dfddbdbd3e4bdac98b3d1d5059a41ddd3af2cb264db73bf4491c8c4d856c53a5a109bf8c6d38aa36b2456f7197e3611bcd27098446ba0792f302ad23c070952830f913a796af504144134a71bdd52b3491659af0282bdff55f843e53c4e1c84f4f5c295faac95aeb988fb01e6b034a919a7400b62b18c7f70693140ffadc80a6b4646828c4ed26ffb23685d41de982728f05f8329d801a2983a8ba1ad6a63408d49c18bda3bd0e1cc3744338934c09af4cf6fed738eddbe9c9045069c4269b80787277f6a78c9794d91ce53d554d2e975268b73b0decc2c3ea8ba9449f9d2c0b0ab36458ed4ded5eb6c654f66ded3e71002909dcd350c84dcaa951a3e3382f30512bdc58959d8703752c94adc83abd0f64619774c305363bc306cb9fc3e18af74b93526b2a03b35b95bea50ed58d785c0b8a3b44da4c4fad5fe38f2ffff6c160cf9675425663081588f163bec2e301b236d3cc26e828aa4ec926981474dfebd4124e51930b407eace53a237a2565912a92700b0f35d197caddca7539d319cb6e6696ec52ec123158129369be4574971dcfd928ff9d308adce091bd684603525de3f87816f3d2b62965a09b56e59be6d8dec27c1e0a0b16b1d7ba23f1db0f8aa2c5981a0c162988ce315b68f6de756616578c7f75f2da8f6bae06b661ee78905efd87d7ec122e625c96e479cb24ed777118d51bae110005b7e7445aaad2c5c54d31658be3c7308a0c41530fff58583481977654a928f8eae20353f27b51e6ffc7e4c22d08d385351b522c3754a1779b9849edf7dc85c88e5ffed0c29e3837597edff4dcda85216d6f419ea772e613ecc461d301969288d3a457394b3a78542ef22f855eed4ef14d21363bb8b772dac433072fedd05d62ea9fe4f773ce8e0b277d2d859dde97bc1f15eb6685615469361414b4b68da7133edd52056aaa04bc9f28421ba7cd2ed004f299581d260260e47987c0ba76ef344950b03fb749cc1833b8ae1a5925fe4966fd5032eb79ec27ea19340c7b04573431cf7f596373687503cb7c77823a47d40c2a7be2c223b1083e406c3a34a0531c1e3a0a1adbe1d978c0adffbc75501d9745ae67e9b29b06b6b42d72d0bd41ccfa00bb0553fdd57c6f42cd5e86b790cd1043d5e5d1c5f41221614d5e95607fd83106eb344eda20bb9724cebed191aa7ec3e93c7025dcf7177568c5e5b75810373bceb5c57ac9d028a4b2de2ea0ee6b0e1164bc746df17a3cbcd769e28748c80d7501e5f7b3572891346c433d63e4f7a94cef433d5cd3e255cdaa682b3c22a7613858a33faf56b04fa0ab2ab6d10eb32cc3d2dd0a042b5291418aa9d56ee07e3fa55616b3386777a5cb53930f6178ffb7e48df49f2726d3b1e6513f7294827a05279d50081a0fc96afc32ec3b33528b156ae137ea6b9779d4bc25241605283351b222289afa931bc9864be6f205464c7608ce6e69fa9c77142045e88ce2726600918c133c4ab637250824b7c5aa57831b6381b49a504b1fd2beb4e7bdb637787dc23d021387c830e32684fe80b26346df44585a8539d0b098cc294c2c471d97bf4da9c68babcf63eb8c5fd49afc3ec0f05507475b13b3d73fd41ad36b71d127237bd3c559fa0dd033511ac534b20bc5c2e6223e3c70d9e28dc17eb80ad19734038c2f73e95477d6339a1e5a70ab1b539c2290c7c5a8ef73d66d357d9e15446c60d1a38bc97c4e6a8569cef18d174933cc6328596f78e25c68ac350335476f9a68d9f16d23dd45941ab03619c549c21f556679089eafd3c76251a452ad4284bae5d02c71e24e8ed927d72d36669a96285816db987b40c6cbc547512dfb61ec7a5e835632efd6dade18a853436c8ab812118f815384d5452d57548e5c77ec1a0bcacad2f4e3548024ff2d13c3fcd2e4629fe7f50db369a4364983a987dcf0f64058cc787b30f8a6c33f362189104762bc9854c719e7d06b40db7fb799208826ce04838fba498082d1ae0523b7c59ecf4444df44ed237fdda427ae96e9bfed642fb4f91bee13c767629884c0b62cc2e734618f585f569d18e2565aeb11dc585ac6a955f01a62cc2f67c20e894dc2745608002d2b5f7c1d4bf53180d0783ae23f51de06b3d8d0995528d9e8f415a461f8fb6f325d7f71de115a5be8d7f9357e091f1d61ef36c9b2b105a8f7200f851e40664e44038ec1daef57c006c3e0a27d6fef5134557a0b80824141ad8cee81f184e5f47720b765f8c3073f54309ce39cb58cf0825067a09129c6b7160347b2db9e7c973a612fb61db31e10716afe54ba2ec0a199cc9a5caf53bc389324a61917d72d1e85e88ad64507157eaa9664a82502364a01e241468f93d6fead7e7791e510a8210d17895b34a147aa84d60ee6d98e8fb395392f7756fc88777c84ac0bd9371103aa1bdd79b107b20d796774c961bb7dd948f6e6dcde9aa5d3ea5035df5ffd46b6302b2460b50f573bd07f275ed7e855ce81a5f6d02ebd98eb48d77f87924711af7c5f1982d560bbfb9cbb866b2a31e4990fe6482fb0e14a1916d215c2f21843c6ef78329d920e50096de568ce0dcfa990c4eca889586588b79d85601e9a443b1f3b0acbdec7be00de9ea08b98e3c2813c1ea780a233dd33bc8e17847523273ddc34f5635b959f5e638a9231307e42cd17ae91e2eb67214851a63e6f013b4e6651975a85c3996ad6154983fc1f9c623ea48c512d5b6a67b12b8c3e8ae6db0d7ff7966b8ce677df7539030a33b6b82ea8cded0a5bbe588572","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
