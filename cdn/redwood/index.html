<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e17e7dd7924e515dd7d0ebd487721cfd40849c7474043bed5098426b2773894e74ae4d2a3b300b86ba45d469462689bcf45fa73074fcba7812dba21fcff4d43dcde04c54ac58b2a8d3d7412572dfd98e5db2b62a43aa4012a3e8b57388243e8adef4fb7491c6f5bb160b6b89cd547f5c1ba69a24708dd6dd6aecf88f4681f584643cdd7ab57a7bee71e561bc64541e3e1b4b7b2c0b0f2cfbaa8ba713babdb7d54f5d308a79f1dd71a4063806c5e1d26ccdddad19df822bb812c0f2c7c8dcc29c07cb52392b77dba9e560413c9c2ea88b7171b0658b6f23c6e7030b1f870dea7aad4411952e6f0f838637a5b3e99f4fd715f859fb6b6fa5c75b5c2ea524ca1b51d7fe048e169cdeb8da5d5ea0240eeaec10ca3d6416f7cc4b75d9ffd255c1af5b25d96932f28787b6632583b4974fc3a4756400195d30657146ac8ae4989884971a9dea4bfd4a430f5836034ea7f9845099ebf955505a36220780289bcf1889d2e1a4e5cb2880e7614ecd42b771212fe63f20a9654b7e51813336752f5b7ab6b661cdee6c651e393759a06899942e80344dd7c58a82b61beb4af2349b0950bf2caa3c7595f33117b46c75e78a880cca9bc82811ca8e9f2e31f0b445dd9eda25c8220ebd52271385ac37aba42deff14ab7067b61e07c7fcecb1977d97204e9e80c0a9900872207f585c6136e9d0b33de4cd824f2685d0c20ecbac078ee05c96ac13e444abf9a58957a778fb3b859d03870fefcd7b5b992675097d68562e399bd8cb0fb7165adaa21ddde9cfd36a27e0e01acaed7431b9bbce6dff6b81c53647bcd79b1a88134c520b302b61b5856ec4ebd4f3553209502d14311a8a4e538b56056eb214948bd2b5623f42c156fc79174fec0c8499c9ec49c3e868e762787a90f68688af040deb7c7530a736fd57d8f7be35b55e6f38d769797298d58c5deaa65d9c1977f1d7c858c4e0a61e890c75d4319c5353a3f7ee96bf5a653712e5947478b55e3a4cbbcb38a6b29419458e89372f36605abda8a3927b91548c2ada7c9656a38578d01d54c3ab925308074ceb5a58fbc5a7006a147e31466df244cbd41d6bb32087cba0ecb35a6bcb79659c6cf2ba02320b1ce71ace13c53b2908442c3fb28a4fe98236689760c991037a79d03d360757672bdf9903ea8245c3052f78575f49a3d176ceb62fea824f78254e89a5ba1478b489d890bf1e715d04e73407de0847996027e0f11b5ce7946ad5a64d6d679b2d0e3007c2d6af5aab8c90c27b647a2982f2fd48a865ce19d590edad1aebba96303fcf52e53cc9938af1b845c55cdb8fdcf7334c325b73d5360bf9ebf49de45a6386253532436afc9eafd626f9fcc16ba23313ade4dedcfb0735d9015c005f6fc55b94545c5624ba50415a4a58ecc44dd44a7a65901cf4490345ce707d9e0aed456cf1c3ac5f235c6baf3e39c58973c44864acc5567a5e78aad2f0f6d148347c493d4d85d724d3d6cdd0746b90e90e4f743da975a86a342e1f095dc3eb2da42bb2a0ba5bdd6be7a2758aa9cffa60783106918318b13dd984b667b85f2232d1d40e1ec6511b3e6a4b4a43865984b8b9b2d38bd881ef77dd7614afd09f7b25b08e5a623ab2fb6e776f0e552d6248ede9db2b632cf5e7096853129459972775864fc51edbdc899d36a039ad8ae74ec90b92503de74c2893f6ad3628ff20e972e2e059d1801d6ce7feee72b9452f24e7543cd659622e19783e4dc599728cad8fa20d6a9ab134dd9080a03dee74e5448998d109e3daa80e5c512da9cff33368a449c65b5a92f0c2eb5fdde8eb3408f7b5bb4d601025d8f4a9280df9af4ff21532c4c908014377c57dba1d37a6d9522935a8d3f943c733539131a8d95d0e9e291201d9c8e2b27f14e4d46d3c54c77c6d90e509aacddd926fdbd10979d48fa0363e75ae8cc2674eb14d78ad6ca2148b6decdb408cafd7a4cd7c8817998d7a7fd82b4cc7b98bf62e74535c566a5e13f51780f36d8b16bfdb314c2cbd94729658639ff1c0ae193a0f792570bb74d61a13d813941c81c84f9362ef79c857c186399a740eef71deafb6c735e850267a487f32e2bf2a0f434626eb171269b352045979990b085b00af02546877a019dd2aa8c802965f7ed17adde9eb666e613ecd772478106a7cfe78b87bd6b2f8307d96a48c7ed5d2df457d9eb8f763026337db7629d8a2faf03d057b0c7a285768e6f64241e34e39d348cb89750b2eb6abe2c601e6e7ba3b93ac419c0d995894829cea64f233142ce87ca88f98126bea6ecb05d4a95dc4a31013b82bec072241d0e9df15b8d2df06dd5f0743845f5fe2b6da342829e0f11cf45a59c5d580776b0e16aad97d718910b235ae2b2fa205cc595ae59bed46dd3df521233da90d43c4c845b69140a794f8f7d68d96a824b6ddc8a4e1579f5e775dc9d4064116d05cee85b01830eae2799666ca3487fc66c827246960f4944677bd0e0024cea12af12374d9f3a950cc4554f0610709385cbe1cb993b888e817367b84fd8fbe2d18b382ed497086ffd04e95e0ef044fafabfb19ba0f19254b41066b36bc01f6db3b36fd8c1293d94fc2744f2211e34aa77d28f0dec4b7a0a9108c94ed2ed7b3cd7a1027b00b90d42e07ed47677beb8b0634034eb45744efe60b1abe3760d9e815f7cfee7defdad5b1f178f58c26fdfdd38c1dc37a35aa06dc12bf4c43af022f579ec567b7ce4a6b24d0caf5a3ec05fbb0cf229420fc03a858ede53c0a1a48530bb714b69594b1b4c97bc4735d0e79d007b945ff2958701a1992d50932108e8c5f071c7f219b4d70ef8e4e16bf6a171fc91f3c4175483f7e629a442aa972fe514e172a28410a1851febb876e0ecae8e57af21cad09ea9649cc4efaea74f2b8d101fc20800299f02263928cd2d93ca722c0868085d1b960b282bbcba7502863c013826e4acc052c21d7306ebb5b33e3f00d86299b7d14c7c1cdcaf067572df94ffa94cf759a0bdb359a72565e7e7bc29ff6e8335f14752d261a62c7ddb6fd94e202ec8e6de7af1ef25174176a322934a32d3d685c37d08becf9034633a9504fd25f7052d164bbe2dc10109c145fae70627a6ed969301cbcf1542cff1fbdd79cff3f6910b43a2a3b3b977b6cda233a28559098dcf266156af5ae703a540cb2cbe2ff8809a4102fc3aa7fe130398c0a38d669c4e978a8f5a4c23b29d1c9c940b90229325d2e261bed315e4e216dee0e529efd350c03c4c81d24de7bc0d38c1524107629acc4d8f3ddb6efd6cf8b2f36fc9de3207bddb2f0d932d574b540c0f6c24ac3bf42203c35e5101c5190e08cd1dd2dd32ce1da4a336390daa9c0e51d8448aae16b11cfb0047a8c5696bec51011635d00718f47b45efeee72250bbd13e8ba0ca78b44f81cdc88d21ce79722f07948fb4093b3eb26070bece0ea5e0c49377c805456308323547d54767a057e1b4918ec566140bbff925f13a28c96f5e9012998620f80affd405828327d1c8de2e5a1fc68e78284510711fe0df8146db74ba4710c64c6ad706da6fd1ceebcde6dc3ce286bf4db05240fa73b47319640df3c3d216b84ead70d58c808569a0471bd1eeae5812926b9045aab12e90dac8c2a75234767b8757c150de4852d757e0672dc2f73218095007e25e54312d41804512742d144a2b4490577b258698cca7ecd12390dfe44029c611ae6de610231fb7f5145c24a5648f1d4cbe0e4a70cb5654a110f98bf68d306cd2c484543351d6245252b1e115a0a7787e7e26b7f387d2c954e9c98a424e8090e873b74005a63387fe43a710dad545f9536547f01d7fb016d930bbdca85a2fdbb353d2148f7f66c7d1ba4e6efac61adde2d4ec8d456a34e84d2c69c543dedc73214523ca9c1c916971cc861427014c3a747b2dc41b6b85894b44bcfb6dd6da63f044106584b2fb6ce7fdd952e21b29d2a4fa5fbff5160ee9af8002a04d46cde775548274b04538e195b0459337f72bdae42f47629b868658c5baa508c3e406962fc5c1f3fad15a86874e3a4c30ffea747c57c3ef605b4a845f0bf707f00ce0d8ca398b1b8654dcca583ab4ebc8244fd87abdf783db7cc97e3ad3ac39335720a247752bc81738bad133acc533ae2064ba266be6572a930ac098048c7248be970139b9a0da39b2d40bde2f2b7fecbc7f09adab1cf86b4e980b1d821411041f03000714ae6bb87bb5fec4c6deae3ebfb278e027b6707d78b633e45130a34e46cfacd165e0d02a1d635ab20d4bc293bb5b45dbdf3c64cd5c9401a797e2729e641a4b6d09132488a60a1bb0cde7ae4379bdeee8b642f2056ea9fb6838d92130b4ffc7a752fb3484c0fc44d157c4f0387660529b5bb6917dd3f7798ed90ba0eec62fca2c3bfbc3b22c1ac7b120065ed2a590b776f1a3e062c4e1d3ae41b24ce829450a753f0549f96134b5541a1de988fb05ac0d2c4acab8656723d51ae327aac82bf6576abcf4948aa34c3068f5cc676786026819988f17b2a5b29a75f9e8bf05f82fc463ac8d39f89ef72bafdc2519f6216b2bd1d273103a4b39629205bca485620c9d1147cbb90bf515eb7dc609b174f5a92f1c6be273ace77962a6539386a805bbef9db49bc5b89218940e05a1a46a53e89f0164137c6efafd59f09afc140bfe26d2bb38cafd6666efecf77c50e3286edc75dbda1434f0daec2d69caaf7156141215e618eae4910525ec8b53a5c362d29f08bb305ef45a00231f10de678e1bb9cdee2534eac643be7a48c4f6eb80ac1087f6648b2073a82cbfbec8514993290ce4aae804c0f6f301a47756a13d4ffbfe295fdf3176fd94e6964e6dc086dd83df780b57ea990b9806c728c01a7c3151ede0d9dd60c9b6cfcb0b0b739d96b6b2b07ed875874c9446f6c74a094c1822e8faff0fbc89f9c9e72488bf9fde2c62f89e48f194193a303d802a7694e2200e6d11467e3fec9893e9a71230968f9e315a0b6e14875172c7981fcb777bd20045b2a49b42d2d10138762f62c8daa868aed4fcc8e607c757fa069d234038cf2ca853b1bf4b8b9cf19ea6faf202fd17fc28abd572adf19ac1e15bcf127d208a95092d4a1880d08e384d3eb5b18b85ecc1d9f23cf96360e8f0f66750add5b19e08df16b8f868436cf2d664109ec47c1d707ae762bd1721dd8a6565d8c9745e2247b6cc0e9cda13423ffd315138e236940e8147a78836fc2959830ee9d6fafefcfde01f2a27b08feb1419dbf47eeb36669276e89665145d9d3787cd132183958fd2c9af664c1efa0cdfb8b4c67fb61bf2f021cf9d602f9df9de591095cb672161b8761a537eff2da57352830ce1763c5557012023728dbe64a0564e6371339f8d922e468c7b1a3ce3b80e0e0fa376925bbdc09f3145ca90da209c48b376c3c867f942566484fb60d216a58777a34ae65d64bfdada5f76525787a2534b7be92d0ea75d93298507ebb1b5a462218075af1ab8feb3c810c04e43fb9adb19220c9e97b731e57c9361b8e09f8e6ae255dc302d40d101f05435f6d077098a6aaad7ff0377df9d3dbcb557af72178a43e2620c4284e9a0044137db95b62d69463848e8ce982c7c6bfbd05b06681966ee3e1f09040f3e7078333f67615bb1b2f1aa5d290daa1f8519cd4c2fcc8066f7b05c6d0b0542f2ab46006fe0f4af9cee082e608ed928670216360a2e574dab5a3ed62008e19aefac38fd18d51c4c1f2f9970c6f2b59e1f0a965d0e4c4597ccc4278da978522a39f92a1545e576b0aa2f4d521cd39651cb4b6fe5f5082c2dbf3da6b5a611c9ccf46c5ac5c66d3ea892fc0c437c09dba64ddce795d712029828c9573be390bd16ff09c7dd3942ed6a68186984f43bd61eddde1032a90412455b4d4d214f547a2e807a6169b15c8a1b369c6e9c5cffd1764997fa3b65d053a949a4ccb432073eb3b68d4f3a216ef85e891afa9ed754c4da7d2fc04b4b860a9bf84e4d735244ea7335f3fee0e3e77fb0d689f57c9ee468c91c228e18e4fdf6570847589183f3266015ebedf51ed93a9f663e9996c071a375d3f42cc94add897cf9f891abf6ed8f39fb07354c49d925495e70356e4ac1fe8f0690872e27a898ddb01d885348ee9191f313cb87724779c83a441ed11f35d6b93719d6e4c143d1c4d3a6f2ae45209cb357362bafc02c6e3968a1a853e550d8b43aa3e0da085d5f1990414401f5490e44436b5bed82268f14c8a2742234b0be905cfda3e72759cd6753ff17f7d516ac0e7bd0b35ac32a049e9b327cfc08058ebb8306bf1bce4695d4347522507cc3efb6ac7faa3d3ed672b7b75587b97976363145293e24d786b990d181d37f62493cd1ca2beba25816d83b520866d389c638059a174e9c7e7a994c6b5c36ad66f1f3f725ea23ff2b806b6ce0f0518fb6c5af0432f427b34a84be20c0741274ff44c2339cb30bc745842a5d2ddd5784b9e222285662b2b9bed0bb080f058fc236a228f2fda5ab39ba55e3f0d256adec5b1c1a97873dfa63f966528e7a57efb10af1a9fe97a65c4b7b5b35fa28d2542c8739bcde9a4069e248787ea7ee4baf4cdf68cf2c467f81aa34556dd186288ea85d88e7ee181ebffc0dcece1ed077266bd1f8ee0ef896024d90007e0f8d2b0bcf6f79b84a8b77f2ce5f0d8d2ff971d20d52fbeed5b7ba4a8aef9b63bb3936d899e00b80c4dd09b7d7d802a023946b37dbad786885490c1bf47230daa5fb465d2e56f9f39b8005c8b7142269173672a8bd18cd0d6f1751f45dad8c8637a861b4c5fb74653259957b8fee146641e49d7d918ebd8aa108f867940c8e229a43bbc48a674aa7d0d980df0b49633a7469b3f451b2d31e4684bf8861d82778da0b64ced7cf94aa6f2082f7e5275de6f5ab404607ef11c8c4ddc6fc0f981d6d8157f081e892080938b67d588bd9fe281ff3811f50b6fa444538cb51e520703858e6de5f65d3d8ac3abdbfb2b7abe30cdb58e2675dbc381a101d77c3865227209e3eaf58748133702f4965e786ff57b2256bee7348714c1ed07415aa908175db1f9203924368661d80362b38a8647f80f739fc5f3e57c72fbfd355b75bd955c4fed175fd1a2485dcbf4dbc369a6564b3de1c29d031f9af3406b8c0e24d00f87ea757d8c1e86eac1dd7d018459baabde1f7cb1de4178d055d214ccf5a4fcf2cc94c9f5f53f1343ae277a5d1f368aab4d933aa6783062e5dc6ec34182a9695dd8f541308ddc842f3333a08be14f9840a1c39a67411f125660e8e2d38e836b3f5477d7e283e74b64af98b831ea5427e11ea81b811c0c23355b9706fb447b0c73dc225af4ad8654dcb78f3ca8c03e550bdcc44f9fa9f543530ab9a3ebcffc71634066f371f863b69f7612a7cf904d3626cf8bc72c630f53035164e0f7f7ea77c7d952cb0e55d5daaa7b3069ada97e19bc507904095f80f627748df186dcba754becb0a8ba31d599dc63912580a2b6378f0a9a510cbefb28557a7d28279b9266f7c2bbd1ece953f055a244b8f517b5e8a271d0ad38aa34255c514215bd57826732fd40bba04e861aaa86e7d6ae76b7e0ff4a2ef3b0b8c3207bbd9924117e35a1f820661f8ebd762e0a46f453162c5c0c264e6d5e7f1ca82d64913ea14abbc39b3071597946a49530b1d88a38ed668f09bd7f1b5371fd9edcf3d49975e69d641e7bd7b172e143a74e08be6be5bd23c9ca389898cd121f0068ea1b02455e78057391c34f43c9ff213de2adde2aec0c0097b0c29eaaa6dcb44788815e47c195db89e752177297c469f8cef2a9ea0d231b9969b69e081ce5768c2675788fdf20e5c1c20bd9f663b166db7da27d9ff1e716f36ede7ba99e887fc8191865de2af7c83bccba454e2e5b6f4567e6f09ac47c4299860f03c6f29b0f010b39324d88c194c8ac335908fcd7ff666b2fd4623c0410c4836bde4b409e9ef666231b7fd237197d7c265dc4c1dde8914f2bdf8e1161cf6e8303a1a58587c82bd0a8609d0a655dfb5e7880cc24a54c12dc2ef1f07bb5f013ee7fae9a60e76ca1ccbee984525f05ffc36964212e91c31b950e968e85ecc94333c01bf17cd3de2e44062584e6c813f17af5e8ae9e48a8178db82ae1d44b88139178ebe1209d6ce5917daf93e680960a574721de433fea7afe595bae0fd9dd923df2c24f13a082693fa7ffabb5745a6e8e6fb769549794065bd4e2a820dcdae09d4a40cc4d3a485240a05a80e4cd5d10446c799377c7bfc9fbe12e84a176d2e44614b9d91445b6dbf50d3e218620c966042021e2e120bc520ae3c7a470e7389d35ac6f948351ac0d41d0cf18afdd917f808f3885456bc600f6e42c390273b6cf631a78484ca7cfd782e7de294c3c0b5df45d9410ca330de5baae7ec79926957f30ca051de1d80be09dc9c26833ba99498adb6c0c485d41d48f729bc76e042239092ac9925acc26cb9f53d8df50ba5022b79ad3ae96c92832acb60aa31abdf59608dfff2541eaaf77cc29082c6963fdbff1d1fc63d6daa92fce2c733fe835999528960f3a735a8bb12be66b95f287fa551b3704c94a9530961d94d6706ae71c97fb7809aa64c625187510fccf431b2aacffa6d57cb227b968b4133a66168ed6f5654c2072373e3f8c41c4dd5ff10b21f74a976fc8ff439734b55dc19842630df09540c5549ca97e0887bd0a0c3678b1c73042544d3e8b8c0da948945a5621dfb7f9df37ab537b14f8bdcdc7a7e745be2619724e3cc977dd05e290d174dacc597ada4744d2d647af4b70a41e776de6a8cf6e575e14ef6cdee1013d3c2e6415e74644b99d57f2e34d6b6a4cb145f55497d882db4af12757fab6134409a4d98ab5a85c6aaa86eea4327f60c8e627b2c8962bfb23de3a48f35c3eab1f1b2df845efdae90aa0aa7df0f46e1fab2c9f02a568a07a43b29cb9980c793205239956a29ee1ad570976cd4b9761c3e75a40a3432e88323866cb15b93e4dd2799bef6d27542235ee6cc7ac67e713426ea3c68179fc45dfd7ff8684dbcc6e4e1843cc327801f0e73e51bd1dc757762b426f304e4edd5aeab129c68e8adf0fb155f08d9c76c5a712a0c2414104db5f0ac7a14d67983aba442c6f2405da72f6cdc7298ae3ad485e727c3c1fb203adf5580907175132da52635ce17504e714dad493492562cd70389c041234b446c61253c01f1ec8beb473b80e2eb1c0ae54862d6f45f0e591880be9dfada75f19c0e7f36036c22584d32074226503a6cfd413641e9ac04ab67ffe7ce79b86310803c7a210c98d89cfea417944e07cd3a62c4d6e453d0e202869664c4c79846c5952f01793eb0aa9ee8bada4ba962af0ea8dd782b524ab0fb2473d440f9b6f77b8d55e18d523f55bcfac72a7a0b37359cec50f2ec7c69b012161e55db6bf773bd7cf861b5f3c26540498b377d5e52f5e4f67bb47eac1204b6463fce57b2053f3d4196cb8c14abcaba747fd4cd1d06a642790e643a800005ff9cd4bbf8a631cb0b11485d59cf910159928334a0aa1c56b599a211c69a103599aac839d3b5fa5722049113a35074ad48d37dafcc093d0606888cb65063aad510cdc170dcbefc0357b3f79afc7ca8dedfa0dabfa818e9830f43daaf7b010b2f001cadd0424e1e2e385d9ead9ed053cd6a1ecd0e1a3515dddb197b3bdba08f9ef8adf2649863d71aa580acf0dcc632acb20efa707e063a615fd5d54608b54f196d69b40ff711794195c628b5504e3eba5f2c9e1d7af915693b7357c29eb6ea35f605e0d7f2f25424fbdf0f5e0601bb241acd4d95bf1b8e832d2124ad49a724b7c0b5381c042522c3b9ea8ccbe67f8274b85cd5d90f582197a9d0dd593ef683a4f6749241f79fbc8008a06b7ae284b552d925ea270740257ae8cc6178307a62b9a073bee5cd19c97254e7893ecc0f84f02722ce95c9ff06b6428deee5e24f088bf4c7fb5aa4278e6af4db9faefff5cf4c6b51d7d446a8de1c5fa58b66703462ceecfea1923a5b2628998c503a58a3f4055fe2dd9b73eddc36f7cf7b31926003e1d5f2bf6a71349b3ce284016dda404642534ba7a6ab531e6117230e83ca2a0b36c9686dbc8bc20c02c4d150f3b7a33c7866e2d50c43949e568990e1eb37b786c026f05f94c8b109964a5e2d47f8b018bba5a99a366503f9bd0a1158fe96613d702a76bcf165198841768575ec52d9a09af8bf8c5daa01748476b0d0950f3518426b89d1ba0dfecbe6bacf2c02592c7d4257583c8299f7f2bbd99b6c88de7c61ad99f74c10ea2895a85af9bde5d286a203ddbf9c3ea938071e77d833eff413506433053219d1fcc6e19801dffb36e3081ea73803926954983d0dcd6961955b4bd6133e950892fe5dfca11fa4b7125edca7e9bc26b6e17eae3d641c60630003d479863f6757a0b3379716e47d11cec6fd75616ec44128a6ed28af6da0d25018ed708662713334b1e0d0018ff06fdfd6cb185a8bf8caf834257919a128275cea2be01b91b9b30127e0a39a26fe7870945227f9cb84a8075938415ade2b72188b5f7a1c13ae7dd41a3b735f5e7ff30fb945268e1e2b9bfe515a9fe975573a006a0cdfd6085afc588d38294faddd3717e8e814c700c6e852941fb58f45f8804d35e78b9a096f6ad79cd982feca9cd19a1e021ad4109abc284b1e97fc214069d8dcb6bbb4a8f99e116472ec7b7f983308feef5d533cb388dbfac92eee533a7de6317121901381a98e5a69d254ebd56cb4ecfd9640f52aa3d46e3ea58f5c3b7fa0a10965368d123776801053afc3e6bda75a8af49cf96ba0b49cdda91761c3e67a50795c367a1844baa69895e16d614b333a1bef7aa047c0b9c262a7c0200f3e46f19870f70b262088b91e1c3648b8455f3a2e29affcec6b83e9b1edfd8fd0839241773cd9090b8cba9620762d9779626a3881f6826941a5e55ebbc6587d84c4bbc9abaa66ee00eb20c0865c4af49d34b5c04253b1a25ce3e0cab694336a18a84403b5e62c10cc8228ba79cc34c2cc343a742754f468151be7f284e4a2544c1814fdc88c735bfc82db6efecaf59b4854f687b657a4ebc3242f9fde1c016815bdf4046f838f0b7e05588e3a066851a2ce26b7052a7dadb105211d16bb7734c1120ff2005d968ea1a45730091a21322bd6f13ef4e4876d4d46a7a6bcd6da853c08108d07094255747c58c1db086608d0ff176842c64f5d071a6d3b06e3b1f7fd81fc4afb299bb06297e21edb6d43f139c4b559470a5fdabb59d982dd4be1a56ea84196ec303bc82dda72b950409f40c4a8aeecc06df5ad4d7ad2ca8c7134705da1f1cfcbb4deceacc4ed915f20c3a234e7c9420286935971c88a2176d38a67c622b0d030bee29e37b795859100ceaaced50e5721556c28ed01cd4a24cf7b5505ee2bd4d58445af66760fa545cfa3db152f8a6fa32502ac0550325013ba018b0bbed85697f9264187c82a5776e8adf4428cc26d2b5a7c2783fba552a075fdba6e19bb1d5bdb9b3af5bdc2c9061a044c19869af6bfed0170145f54c12dc3385b5dc1ce1ef35c8f17919779e5ebc83fe4d7541543b483f2c622737b6a24e6174a48dbaa776355878d5c9cc99230de316cd26f3913f8e16527ea18b46e89ffcf9e8975d0140d47a96759a8e78e12dbac98e1a8de2a82386a526aec9947025e9d89fcb3b494b5bbeb075a401a80c43924651504d1ac6a6b71de589482fb3f96ca9d3a28cc06bc73638b35e6daef6f470652d481208efca06aa33655bb87c27c5d7629457cb290c1b6ab3a7ad4a265830ce922489d5681d7b413961b1c8498e13f05022f108b978475df72f55ade68dd9ac7c1e6f6653ca8c05857f2ea5f960e4c9e3592fbd3346e357a737268db8d7d533cfecb73e7374029840edeb7c9c0fbd18d452513975f614ed46af901b58b178ae7096508e6a1def46b1abf59845513a4c7393356a305ef7f1447b30dac47c7a6530cf8c2567f87d0a6a05b4b8027bda7d20cd56276a001514383117f514fb59aba5454596d8c8fbf0713948967164228d316470701080f098a00b0cbda6799128fb94b3eab2f78570e536466f180cf1abaeaaef57e488c373c4a28a33031efb0a96b2fafc05dfcb2ec37143a1ddb1f185717cb896679bf8d5aaefac8d2990f67fa4ab3b6185bc505debd40b37cd0d412312025d0c0d8b16b840aeac35a2c8967565a05e2311fd60ee82d06ef5298a634a5fd5e5a150f7d607df800049e87d316ad977a8a4b042cf8eb26b4a14615a729093f229c6f785a041b01fb65cbfc7f917d1184676ed6a660f33788e6d424af711e73446ccee49e0a4c9de04bb3ccfa97e10b4577b94ac4e3fbe81553adab67bc7012d50abf5a574ea84d995e74e83e40d01e10c5bb81240ba3fbc2aa23a8aff811e67efc2c47b654ba4e26df8179ec0bb4e7bf7b68525c3682d7e0b43850233a329c443e24fd75f5245238f3e04de116eb11518756ebabcde1a454accf7395dccf9f158057ce4792d8ed83e56a895f128637d96e16900a427f58080c134e30e5e5b5b606641f0aacb7be7ee85a34b7f2e72288f16de086201842d68815fdee370fb3ffa7608dee416188e149ed7f91a2e0cbd5fedb7dd33939b1f0036efa92cbcd1ae0307ca565119ed707f730767ea7bad476388591c595bac10f868b3e649a266146becffc0dd9118b148c48f3101cfd8dfdef1939c4afce4fee4fcfe76fc90fa98d8376658357143a772a31b9a272e684229c340072906f5dbf38bba31d00663cdc153c4c354c1a2c3c5afe4cc6217245f75b4b19e6095f4c4ccc8591ff4a379d81c4963765fec709973786572fc90b93aea55ca5b599493ade4e2b4e836f2fb206308f7ca8685ceee1eb2ba6379b3e1bddc6c9162c36c9d0ea9ea9eb192cbb1f9ca0146871bb67625af5ae547de48124b7b101608b120079653878d6f361b31203a80792e018070719b145f8c247cd9db2b9bb0fc9d5ba73554f8c7cc8fe2951e0f0d4f2945d2ce9787d1e72d62bc3da48f189263bbc424e807b7fd68362249784f7038dc692bfe2c5ac658b8834512cf2942cd49256fb63b29f8561f2280b66c9f2d34c20acd73133aa0a41d0fb03555fdce32489b526d8f6faf49b1bb7fe2412b4a716a80669ccf75a6708d31ea65494b1e5b55a5baffba5fa052cd7614cdc59fa7f15948fa119709651ba3f499d3b7c3f5b72b938219f9aa7ca6da577df4a27b064b685bf7533744da89576b33fd3841057eeebacc33fa6fc75625e49a1f0717e21fa4de3c440de5c62a7dfd42a42aa0a74ece46d04ffe62945d96318bda2965db0a9589be3cb2ad24ae36f231498fcf85d2f029afa7705ca70312fb934c2b593e43d37bffd28559f3d6e90723d48d1797372838b1ab35a532d8ced5921763e1b53a14aa35a88f18eaa9903d602b9bc47260c5b7ce99f3cd3163be966da7c5004979a5d5839240c9c2750986c126091fd565184a1cd70258d407e4889d9b47041882b5b3b58672285244da54e7a0f32de0f290a4d67c844ef4b15848167cab67c2394d43933bfaf5ab747f533dc7ec85bf0708c748b714d55c0337994b63e8eef6d3dbb8d6383e70d14da6bcd82fb5f1981f8e497e012ffbaeec70b5a280ba17b016075fd7e0f1f0fd51c7b5f787570494bd9a2f329968d208c14bbd780c80ccdc2c8fb37a6845770ef94a43a5af82807d9f43599f0277d92d9f7cb389b15f6255146d7686019d5e4f1aed1e79f1a97b2bb84e46b5a9fde71366e8840acd9bc1a4f6f5cc11234d292927126b057b24e971e207f6e763793502ef1cfa1a83a744aaa4dc0c1921b3d63e786611a3de4fad3d77a8810452afe35eae20cd8dd637e4974fdb88da9d4c886dc55ba8f846c5aa759447111477802c8bb50670e14209ac9e01e29e55aa7fd0cfdfae2f37f7f87179fb003bf23dce6f246f13dc8092033b8aff0bb8b635daa455135f320e534d444877f31584d995db2a54530627d4f2408c99cbdcc51ef05e53891bce19174f1dfc48a9d1803b0eb68fca034869a330f3c18560880c4d7a6d3810623b5bbd9bd22e9c8c7cebdb9f8525172336a1de025d3a016170e0760883cd9dc1c7307faa4616a5c443f0fa5a680dbd8feb2d3c3d5f5eb81a5de4e1105fdccd8d12d7013f48e0f229d1d3e7d15d563ba8b4994e901a9dc2bdd8b2987f01ac68ddeb365a516aa3f6f00de442443836b2d9386d6aa5f3654f8282164c85d7a5f5e238f884a1d91fe8432090b54d297e3d61b07cffdc3d407ed74d5457b72a568fce17bd87175f71d6e233478e720c47e43826897fc7556db8e8ac59a08e5777ec58aa1d828a46da266427270c74917b5f9723477f98724e5c0067ef7527a720df2768d6e400f9d62f14dd7fb14b8ca9c2550d8cc7793a02cb4b3271a047774b094104f599a3383a65e5a5e6710576169eb9f10969ac00c4cbe906137dfce628f9ccc4216916f99e68bb5d21e5d90c7f1fba03a3f3c1b889b4d2a1cedf067d7ef4aca0f39596937478f7f198190f04e62f47b379386a946161bc6728059b85102df0073dc9d4b037e6af8988264252fe89147b7f2d84e1b79a5bc1d40b715de06cb458bd4ba58e922d09c0506a2fc8ac89daa88da9428bd988ab4f363505e8c00987aa004802332acf6242a20dc2c70910cbbec02179305eaaff90b994c05115c63c475f0c54258ac1e1fb6e72b336617c5229ebe0c326398899ef2046cb4e8818f0e79d64ca706d649b3d7287a7ae09f23b87f8ce0e402eb474cb517526d5b380db1ea6ccfe15a37d6e5937868b88eafd9d1e7f2085c55ebcf3e6272aa38bdc2d6e7d1439151f44a073a9748fd68cd8e59b32259e4c6dc3cfd80cb103fba090b9ffe2eaf1ea12f4201160fede9fbe5f10e1ece3ec68abaa17d17af741d5ee5b5695f992635a978456336528876358805421a09a5d2c769ebe066757ddac81b8f5514651247f69df00e0c6ef6d5aeb32678faaba77ce7ff1915e4fbe58a06a4ab5a7fe526dd660dcd9596b0dd313b20213a3922c6a97701b1fe40b0707e53ff157b16924119c11057313a0acd9903bc7585f0fcc19747e25cef39795e58ffb461d0b12de75c494fa7e62a5cd7fe1121098a4e627fa87171d4dd1c5200e775d608cebaea92d46ca302d32f21a6fd657320e3447178b85e1456b83c3ecb79981b0107f5f02d2244ba610678e04ab68f616dca4fab50d02b25280108e20892408af09fa70ae2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
