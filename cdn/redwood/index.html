<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f4d2476774b2914f97825ac9868ce38082dfc06c5b0b055f598b5e4979cccd282c23b2d8d83f9dd621612ac5688b3f3ddcf8529c9cc1c4f839fdf6b087bf3d604cfa0c9acccd9c7c058063f82433c4692fd285662b2337eacaba33d0a601799601b71a75970843d09e7dce7af99cb9f7d59435c1616861d28be1cb2805e3a749f320c3866be18d5ce81cecd7fab4b48fb6db93d7cd109895349c7eef0a3ef883355b34a60114ac32b7a5ffe207da01c619244dac5cb398d81cf2b82b4ab604d0daa8265942f64b927f34b85dfde60d25466ec29829798b2e92791caccfd89deabf7fab3c8345fc3ab1e45751b27e8a06d27a44f5d4f9ecb53258e77289dbad50fe0124af24920a25dfb6792bec414bf7995ae0389013fa222cd2d8c16b476b8bc19410aec63ef06858c6649675629d0314d70f2bac2da30d17b7394ff78b98dd2f92ae216daf25483528e664f91c4084814069004500b89e602744c7594c4eb32b7574c6a391748419759963b85bb92e8db51e5a8a08883b80285c106f6f1190071d55ee8801d676bc30b515b5e7ca56e4aa1e99c8a0630e067c2aebce84834f90bb4a73580a984b33f42c02f4a8a745c655c52321be64804f1b79a72913c63b1df2c91d7684e34a2de3aefe5e566efac5acff7d04e440d06177e0bb1493116e405d725cd2a77af2a5d0a2a4cf455947c5d3cec1619dbbf4cea30b2c98f03afe32815fba0fd7f998923dc8ecdabfc40f53d12c24afcb04c02ef74e19f007b4f94c9a846f872659e39fa4488aba37d0db4f3d477bd504e433071c9c65b760eb64e5bfe4c6b50fa81f159304e87635e21420cfcd13deb6172790b1cd9ac1ff671ce886e0ac15a5d7723a959abfd0c9607998bc9a8dc04c9b631be1f96024e1bac60c5efca2fa2f63943c5f476a966c87dad414c09b6be354e07440a4f8f904cd08c596b704183b40530d78f943f9896502894ee703bbd225bfecdd14ff37e9f112372e642b9169934f88f279fe6ee0f54580a33bd8cbfdface3d7c4338e238db2db353d51f94183729cd9320fb62d72c705558e8be499459047d8192c591b58f521cdc8026cca3cd236397a617f2aefa6096c0012916b31a16d457087eebbfe3157dfc352f325fc70aa343d18d59644ea16f234cfd52994f1a9517441d04f4e7f45d5327939a96e6a2bbcb2fed5ef515fe56526dcc295abe4e43d832f5ab15a71dc827e794dbac5301315d118e6e4245855f902a1694496e9a8de95d61eceae0b49a7fcac6eeeff301332c291fe13c72f3b3c134f0166097b03de9f996ef25eb0d0372ed91219f58fa45c95d1c97b0a9e21df61c090b4b83d1bf27431f9eab95eec6fc3058a823346ab0ae9e4ad6d29ff34ce8119c00eb80fcdaa4f2bb7adfa67b1a5a854f10d292ede444828b4be9d3eb6d2fd5f6767266a52d1c3ba076416b63c4b47c1341105158abf4e7e7439e1eae1a9c77d59ac152359475cb3a0ec2ed7f0376f4516f7b37e255f3464e16e5f2f8e8d3d3d51b55708ee07c1570891679a7d36eb80ea9cb58c7d44b5ec828928bc9534976547e1adc09f0c76d624ac7279ccb71cd75c6e17f27323619cb1a8b0255839eae0dc70ab30fec27cb731cd74c5888e9635da6db64708ee7d424b96e64e4c12641d018444e5914a77e9cb31181aae90d8f7ef83f5af62ffd14f1f193dac5f6501a4681ba2585103177975182e00fb8a195f7a8adf9103db85e3a14af52859cb7b90ddc225b3d43e5028dd39a9ba89dddaf6f42155cfcdcd01834d36562fc3d804b0d0c9f2612c2834c8c89a7ce612f31b10ba2dbe799c15e17887ac0993e6e91cbebc763a2fe81eb6bedb1933c575e822c7784c5d24c183616556db63a3a3fd9a11603900a84f08ab41e85f5f54e37e11045abda497495148ae9cd72a768c8bdf8d9911951235bebf03a6bdb68f3a47a537affd727eab6931df801540e729204c9885a3175f6b750a31ffc96ec7be3b1223aaf5415c8813f20c8fc39f2d9d32480166994de60f47350d7815aaff03b469f157d2e900c5689f5767086dafca6600db8f73b3308161a8cd398be197849f60d4262c49f2699a75cd39489bbd12943e5a52692bef7f10acd960ed815b268d6a000f2886211cd05de56aced80a197eca84ee126d51f7d9cc2aff8567c2ea6c76b3b9a2e22292be9d9b7e6079c1c923b18977349e815d8ffbaf2fb0d97ba95ec732a418bd94813d69e83248b159fcd0e7a76cfb3c73773ec0fdc98f68d2e716ba7bb102a237194c5246cb7c1577778401f3303a8f41db8c8a44d812a628e2306fa33a5bbfa6190b9296e65e1c965b0fbe41e9b531a96c96f2893d40adc60460c72b3e6798fb0d85a1e11a10da095135275261e3d60ebeefe96de5ced504ea26ee0ebe5a936c67825ed24375b614814ec364cfd438d1bb7dccd758b51a8aebfac0c458d8ea62f5ff5cbdb794fa2d71f9c615f3ec6f1bbd758b5a603786973e25e05ce63102e8da7fcd6b45d855edc55611ccde78c5a8268851311d939e5387a0537e5fc4d898c1db6faf5f33fece281a75cc6f610bdd91916cf0b3e1ed8e36ca5e26af5afbdb6ea29b53dc59a1cdedffb72a27bb1c014e1c6417765df55438c1a2e44dc158b3037b90a5f1a76d307d182162a1e7445920df7630e5790a3277c3d3e4276237373e0f66f3d5e2ebc3a79b83952c381d1233369937b91014f20be41c527320b21443d51ebe4edfba15f87afcd91f2ba1cedbc05b07a82c1830970113648c1bd67236d033c3a146f7c39e4251f68223ebdc586f43e234a15277e8140630655b4266db43e22fe4659ba972182c2fc83fa56ca3fc899f2ad70481627664d1c54b0e1e905daea6eceaa9f497b46d9dfb08898ef4191ff5e00965b404050b40f7b4508dd1500b2682e2988ffe3927244fb9e882917a9f8cef839362d88ab92a4447465aec7ea18b587ae16f125719fc01d7a8565bcb3b4e929dc75b2a5e58b825b4dd89557543fd4cc23abe8e26483ae66218f2d188f9d9b0e0fdb18eb8496f7afddb9a28de64d38f944c2842010e1d64a5e6e55109c7a59aec803dd1ef3401c0e79b2aa9159f685fcb1f7183be902206032765eb1066d40056050e4739c805d623d5c450b21c1d9a0b76877c72451ff5b59808e8d9fd655978c01aa829c7629025e97680faf06359bc325c1a3130d62e54788e95fabe47afe79cb6c7a320734244080651f5717efb881872dfaae07f083a28cb09b02f8508dd5483f79d271316bc6c0d3be0a14ec187901c60ba7ca66ef2eecc1e2752bdc16c0b0d2d589817d42eb992dc0c588c3616ed4b37e805be4c5abf0d4fa99ce3f34988a451bd58cf9067c2a9244319f3c4b48274f179b7e5d402b6a2dd54a6fcff005b1e8077eea49cc869a650ea010cbf283605691d94655a73a668ce752419e1d9b6e53e712e6da359ed08954ea906648be912ba504b1787d0650da8a25f95bc480853c7cb49b9cff3ad1149b5941e36a18cff3ef559baa9288df460d33f14779e70d46fd1a0bc279aae4c0f5bf238eb681db065dbeca31dd04de2e521d676527b6f792d55f28750c3f6803c30fbcbacdb4f6acb194fef3e61f954a05a6b6255a22101b701f15346362348a271756fd9a197209802d9e5a6320e704616e00e0ac08a8cec4dd566387e0de2ca90c20e689a259f5b96a6db58922a5e48fc768116d1a02c3a7fd40e93fdb102cfbf1e4bfcae867a6e9dfabb79b9983e6972fbf4b0a1f3680e14596c71bd52325cbdb5856aa9536b372e72c533a78334af5522551de7a0b3bf5355d02010ef1fee1c0fa0061c5c0e3186191f986171bb5f7f1fc48d70d8d589dbcf26788f638cc4d29036178f8f6b73ebb22403a9696f867b2e82e187580959fba4f0c311b28a78cbd7a06f8059d9ea656aa762240df18a1e4e0a6bec1730ef94b3204d3743fd54ce6b58e09312db2cff505141fdfb0925a0870b6781564cd72b3da8c76b1edaf8518ab538d97b99493db507e6d720cbfd2cdbf2ce3f181f54fb6622e38044858acc89947c1387a5f5ec80849bb6eb3772e61f27abe952cca6d1d71aed613d9ca1442b3c17ef73086c8594767077dde0cd549c3e6aaf512fd6ebd3f2a0fcdf01f0d4def00a5e20d8f848713a458e7528b476da43ce7205251045b60946e3f4ff0c9e0c2a88fd2dd6e3b60009d9af6b539c984256247114ea2663417ae7aaf393bb110196e2945a78e477110ab9b285a110581d20b02b468c4d74b389681c5b938a88270f0571ad8ed0573bdb6462111ab4becc1d9ad670e2b310ccce5d8d7c53612bc83feac631040b00e059754e69ca29ccfcdae68e0d5ac303419e0ed38348abab48df4e14ca96d2f49f5b820a599b0f5822e5fa6930d654e83877b59ae942f865517993c20f6c7de9741e62474a8c9889eb139680a4e1e60306782b73365afc04c5544adc40f954e48f9910d8a6e40e7bca26f6721c9f9a6cded9201791812aac584e2589d0805d0577b108e8c66f5041046810c9670e03ca909bee810e94a608a47933888eb0fdeb39384b034dfd0d2dce1dc58b4e58aff01c2645908fd5bc081f04a94bea353f206543a33f3611708aced897e51ca7aa693456dbe7d105e617ddfbeb3ec5679edd968e4fbba99f3672e21bf2a9dafae61c3a1cb88a656acb1d199a3c523aa294e42a4b157593ea0f542d3751949f5f772f305913963e47ace8991d5df1e2fdec3280461128d53a9f11d49c30fc1912b333dcda1e10bb1391a832a3d1f3e1c11331fe4c2d7e0d1ffd62fc85c19cedc07aab3e06f2725a053c6ef30060af3fda28d7e25106817c88c1941825936cf269ac7672d5beb808f3f2efb51ed3d16c950678853456f228cee5e2dd0bc61171e12121e4aaf89facef832956f7bf470f17f730e88904c6b46bc8b1c557666923a4a52662eb2b8b295549573c4c35174b931aaada5fddd97b3277053fa642303b1ea11dc82907b5189edc7bbe68b45f7cfecf4d442490cb1223bbff2daf312c6cfdcdef8656389f6abe648cb73afb33693adfe752d349f66fa4e4b633972d0867922eb772dc57421b9da0e122df5db475cba7fec9dbf80793eb65a3f65682b259d454e27113594974f59b2619df7c92493c62764a7232abdfa85cdc24e7769dba3fdd8ff939e58734c947b3692676067dcc5a52a729295800e9e607b54fbd8290f23b3473816d6cf5188500d8b202347824cf94059bc0838c9e13cd7bcbeb1d8c77e2036f6db6cba2702126b345abd141f24a6ceeec0f6f026ffc66ae1e6015454f467ae739744cf386abb16717423253a343a0cf58b9bd2386b20df11c0a3b59f9a8386ecae9f1c1e2afe03c26c14c943e7d1d6da73134086f752c97a620c80339db382b42f9952eba5eb81478a00f7484017e7175cfb3e7a684767464d27a22bb502e6adabf4e4ff56d653cc917e8b043c6f227f4bb017c57f6ec16a414ed6492d61e72ea13855e941250209b5a8026f8b44ef56f94ae82b67c5cb8b740e4dd9fa4f8e2eee2c95a1226a7f400fafec9e1c4241d03319293ab0b6e905c04a37947c5f23b57600b8c9f70df34bd62d825eb46a683e1a11b1830e80074d4b325b4de87b6af2b1b33afb31b807544bcbeca2974722140afd71f2905aa883317f0ae9a3515707c4e4e3117da76ea86ba40fda4f0270cbd49bc7059d426b70162d735306a325e0d22b8a6bbb2ee2b33f8ca0e4a87e42cd3c67ef9539c967b9d2047101318df5a0be14343c8be161adef4c11428a0c0e7fbe136cabc0ea08416d98bf8d98930232dc66c5a2660b2b5fa807c30b54ef62013b64c9ddc6c8bf93e9684f83dd9d9544fc307fcdcf4b9147b54d13e444f6458ac63d8a263eda11fe0bf027c2e266b7bc6bcbcb51bdb1509e33fc6b9e26a640a18d098e11c36731166035f3a3b34e9b4d595a6cf0ed88e472aa6b5e561d8e4fe73e24c4a2289b0b6dcbdc50ebc2d2d0dc30d2196d5ccacea272d3c13c2b5d841aeb20c82c32bb4de4a3d48c0dbd4cdd350c75f0a98a166ee700c5486a4233e2e3181e7e5d26c21db191b96dccc6f36440071278ef8faedd71114827d5bb7f329e11bcf8ab7c19748ab85329d800b8fad2cf742e485ce9205542496e91808cb092282a6a494c778cf76c3eb1d21cbbe8b54f946e281b74fcf5a76191885a6217d1bc2c20aefac76274f722599afe12dfcd093cd94fcf054143d6923e5de7b206dcf7440793e3c3cab06e97ab4daeb0f54b568d4667967794e802f1ab8f9407de0725be86a81e1c4d16d38f40bcd9145234534868ae94a771c03884fa90d721fb0fd495cdeec77e67c57a8db1604c64b971e5d4f11cfde10519d4309a73e1adae39a0582bdcb588001d19f73b5faa49ae67936623bdaff97dbee52d6133fe76fbc5b910388916e2668be4fa318bc847131bf873bb96f8a318c6278f5578f715e080088c09032f1476bce18da1bd2728d70ac98b8d98626306f610e5d73155b1cc134a4a90ae4f1d5a6f5c7a6106ccf245648b9cf22d303ad8f5cb8c589f8ac6004d978f44f43f9bb54b8ad44f557f5de002f7cb65e684b998eda0aa1959e58d0e71f3217e1e8b9672dedb6fccb4938b4b5bddc87d2ebfda06c74a6c2e38529729b858ba0c456ad6a7c90358fd2d6553ceb3d416399c568f77a65a3ad7e324c5a66aedeaacd853a1bb9e0b698a2df32b542cf6d9a0b1a02835319d3b4fd314158bfda7751238e2b86c03aa22712ad3e2d889941ed496c8608dc836fae9e2a3f26a7ddb0db6ce0bd8f6d276e29856514f64547d748e00e52531b942967c1d5fe1c633ae47bbb3c0a7a3de739e9e1c5f072f43feaf567803569e0f304b9cb24c338e502005be5bb6e22cdd9e521d2f8d16912628718fb18352ea46791e92d1e677aa9eb09da9f455e8ca39b9eded22dcfbda2d7ffe3abfc1ad47a5d6a83358ece8ccda34f5bf43d785d69346b2346bf6f069941a01846431a0f1bc22dece4ee17a8ff9dfa650a865a816047aabae809aaf45dd2356924503b278fe54797a677a0431bfe5a970af7976d65fb0f5ba3acaf06e966308ae3ec9f485729da1962fbbe39c95261f0c8484ae81e205230b2347aaebf372f4b7c565ecf6846e1271183acc228e88171a13b35b2759194402c68b34aa5c5a5c6af1334318a3dff3112bb18e7bcfd00e975539f33cedba0c2eb0e9f6238a8baf1bb997b630fbb9b4b60fa04c9e5253cfc9d240b74b6f41281148af7137923a8e94ddc5c4b56be65009497ef6f8a19b7d79b0faa30de47d9b31f4664c3769a7bfa63c8b50d1577182e2e54575d28bc03e01936d2d0f5e43b864b66f8ee92f5e612996034325de32777c3f21ce977eef0799b2cb277f7e537ac11c3408cf0796f71e72d379dcd28236d12b071a9a2436ee58546c46f8bfc7a3114027cd33976693eba55477c4dca4f3283051528d180b9624e4dac0a6649114fd7f35a63634cc9c9fe090973c2ff2de308df2d63635e23d73b91e2e463948cc774b3bb6ca5b9f65c688569419435793fe008319ee968de2aaef41c91441bc8710641b87d6db5c43c8ec784c0110954dfb5100debf9a6146535eb08351d6bbc8db05baebbe84040bbe97d838e4de762c90e3a7a8878e8174506e188c55257faf4a2adf216fc7ef8c5e357c47e1fef41eea54c87548b87d5b33e13f07a9c0b9e787a43a8cfd2e35c94cfaea2d891bfc631b09180fb9401c455ca8be5756f9a283984261ec5f57bf50153844b6934952b461404c97220551404aa49fea075191ecd74b5eddfb00579375ae104afa79f6815837f74966bce781f19d6c87419c5b3c9349d370821d86ef7c84edee91c8ddcacf4f314196e0d16206dd3c39a13acc081e7fc237d1b69402cab84f513ea790c69dbc5aa3ff2fadc7855c13c17c3176c148473954dcdf839062d49e2fa4c477a84a75707903158f5f52ba694b13de37d7d9c3e2ebdc902fa31785e671b3b5b31254e363ace2d3e3b21dc2d80ca2e70ac984a3d63edd24282a7259d00f5bb678d2aa3514e94a05e9d2e45785c3bb9b844b21b59710a2aab10a0fa1292d51b4574ace4e3423ba84d6342e37551b1cf0d8a3320ade923b10a7906404aad9c4f413cf6c429e2533c6489e157c609f29c158debfa4bc214db6ec67b09e7c9af678402b719fa5b7f92d63391c9ce2c7dcc46ad71664463474fc05c2374f8e39c04bde79051df901df8d3fb29245751846c33afad2d93586015a5e0b58260a0848f61653f53db380e97c9fe8cb8b70f9b3d150e8a4893f0cf1a5b0927a04197db7b350b32c7533e2fc3f30ff66b417d84f442a6e70c726723aba30a8ba584761f7b47ed4868804b3f0c08866facf6a286d663cc10af42850a3951116810805d65847140c3f250625d1f5389f2cdd1016278c67b3aabdb3b72b55e446982de8dcb23afa5abd3e951d069deacb2624dab4abd34a6e36cd32f66f1a214cb225651929e894242a26d51bdd4a045da0aef9506e5f9ab4c6475ac8970e402ef16efe0f5857b3869ef911739ff89df194cd1efa2250f2911fe004ca6d31187cb8f967c0f762cf36d74eea38bc6e2abe75e5f75838d00baf7ac837f237d72fae6dcef43540d19bf40ad747f8e8f4c89062034d0f6aa97b0c5158c3faf9e199a0a4db6f52c9f6afe28ea57e6e0da5b7f3ae9e0e8a15f7302727d77dad42e4ecff4b18785bdcad9fff83daef0f38d7d6a890c600a8127965169a474c8422896bece5312f6aac96af67d3e6d2305237b2cf28943fddea61cf1dc09d2983941c301d2d68135aea03c7c53116f7f30dcaf0fb9c9e04801b633bd38ea8611aaf37beb57da636631f9db9f277e91f19a4670a635f9e4bc1de634dadad98431b887f057926aa93bfd69803f06e9160e36aaf40c3c8fb4fb57da4ad9b146c792a8708caa90ff4bc2fd70a4f2e2d736e7d755ca14ca80bb306c6d505fd39a693ede67b951402bb15b85b830c2883f3b5b12de9c0f9d57e6bfc30360c0c5b1c4dfb8a3b37cd74c0e98ab4545efa89da977d9622eb7e4cb5638eaef2b9722cdc4efd69e319d404c725ad72db856c0a08ff634bff03daef07d4f62822f6a7f0be111102921991ef896a353dfa5b366e17c1f381224b04d2fcb039fea8684e31e9bc2c6c7c95a454c68b8d3ddd39fb82fd010b0c61b1cef82bd7975c57a884d7d39e9664fde789094c861a5714f44f8463a6a14aea68f9a7b0e1b1ea7de8adef5c4eb513f89d410897b21925e19b8c29d94140b75df05de5a247d29572b1213ee93b11d103e8d9413135720afebcf08ecbb833baf11a090853ad1bd2eb0d3811ee5fce61d277a3a947565a4c7ce4f2f84c6cda916164166e9438f1dcd367279be4ddf2596c92e445b1d4a7c1de9396777f338a48e04f60bdf7a2ad59f00dda0b0c5d6cd07f1db14ffa7deff17ccf4443d86102f5c5cb1cb0bc64a91c2277e51fa16dd19ad67cc2e15d2a57021b92a071a5e7abd0b01088fa30b08d604ebaa2cdd6aba5576307f7c90dc109628015deeaf509256b042932a201b2a5eb3c1ffd926ba18f1a2ae2ea41c9b575e7efbf0de1b4116e3e51ac9c8d70a0419043bc1d8b082d66d649ce5b720919cc4b72a748750b9731b5f7270ad6f95ec4d441d727ea55667d57fd290cee8601e9a98a46cf8efba0ab7245155777a87e4b86c55458703c83264ecdfb3fc877de054fa84233557bb4daec20eae4b2b98228e535a974ab0154a8997db6e523b4ac52c7092c6a541467a1ba03761e4e89728b79b3650045f7478a1e988eca7e7fed52c5acbba617d183d3d811091c16794c8797f6639c53db2f3b637b1a7bbf9ac4a59f39aad9a15c167ecefafe5e6267b7f0b543ddf2ded67287702c6d7561810abf39b4b70d8540fcab84102acc688e45bf3ba19343acad39f0cb8287aad81205822ae5dcc03129ebb561cfc1a151ef1b2a09a3f2f39d7c68b5c695cf29fdbd05c60d7afd391d302b77520eef551c585df2b8b77063c4485a7d06e444b2934ba7a0e71e8920d369ce84accfe7d8793de964df103f43dd4ccf03b1e74f00e5fd9837ccd48c6d620024b442d221982c6916b4100e47790463eb26c102c5688aa1fe5e8daf42eb09fdf24461d98aa62c91400aa7cd2c8f0c64d54e10fe80ded582e4ff88395ac05fd36dfff543ba8a62fed6b5e3b22622572edab98b7797104521ee69b24f01f61f2236f39689dabd5f041b2b29b87ce2f7807c9512201b1dc6bce70acd045dbd8660f5bbc798c3674ec6893ec6c0e13aa0e74056b0e994ef87fe60cf8f3b68780003ac8becd1a006dd25ccdc941abf6bed6bde9248127d81c1c19f9ea6b67ade234d3dc1b1b570c604d946284e4a4478dd1d9f218b81efd0cb27eca05bf306e38113562b9a9c1677bb5f240fae4c1e9dcbd78b71fc4bdf046750b9296b0a26e0d54f48033f5ddee0a33159bd7f12f74f830488ed1cb7312151f17dad240a730cd71490906003d251f2615592c03f3abe44a9049959666895b4e8ab98e8f29399d60fe3c5ad5f6d95999eb4f7fe76f693737c8ac3aa5091cc0396401654aa1a23145ecb3d9d2111008dc0f7640d25ea70b590dff7fe27d8953b8b8686f98d4d730bf63be4f179bb6d5ec93df5d01db499e812268cf4ec0dcdde458e53b4b03cdeaf30e207837e95f2e2155b2a22b79ce66e3d78de8f7d071c615ef9b1b54fbb2216cc4b65811bfe34d1dcbca122e2537d94cd43d035efdbf8e21109cd33f3aaee2a62051b7474dac4eb44b07bdedcfd0a8d7c2dc9866b63a67fc6a56e536661121872cc67f1292befb29c0ee26ca52acf3be54f207c9d812c223035bb6c92d744a9c1e8c3a8e4eb5dddbb167eb3326135057a32be7a2022f3a1c857051b8c81ffd5521f79e29c21bd086ea2e5382787079595a51fc3799f9130978f34df00012d7c53011b1ca9ccda6cc55c29bae894f97187b6455438932e4fd8d2311eb769773745911c8943cf0c0c9af7c9d56bf1945b5a690bcf4507a1169611b595fb0b629edeac7846751470da6fb0f84449fa6cb5190b944517a3cb5760194fc5dddf9d6cf3de6def10fb02f35681d6e9f8dee763e8224d84c589cf3dbf57f9047d9470c7ab39add174aba240eb0acef23c4bc5c33f03c4c391cb69d96d54450c3677f9dcddaa1c128d079ab88ffc8c6aecefc4ddfca86aff58279e5783aaded5df3b40047b83247eb330c7df75ab74289d7339846dd9709c5239e79b31279544907b690f297da3d9897ffe9361f7af33755fa92c44d564df15ed39dd117cc45f99da6563075799e8fb62eec4a0e8a11b7542b6a5c12b7210f2b2f192b815493ef944fcb5ff6f584c75c3b38118a8c48cb4cc7f8461bec03c6c46bccb23e0ecf2bfc34fba58335cea3aa8913a7ac33ecae5289430ffa9b3366336e6fd3f884bea6fc1767859912a72a90a55c2c67ed43e4beadb0c8d50c5aa67f9ea74f766d33ecaf77d2bf0fec9657c12cec85d35e010341516ce3d9aa34382c73884c9ae90884908cf47a289c165481d0a832cba25728cce12cee4ed4a90c543eeabf2fa47d82d80fdcfa97db88710b8a5645bbb77aa726f494edcd6c7daa1fec8c370386b9f7eae965afae111954042691bb7755ebc5ecfee87d032463631cbef6ca035171afbbb83bff77d602b0e97c32468f8f0f3e02adca2bb0acc5007fad809958bb8bc133f847d4c878b7b96c507e9b27f6d77b5bc64ddd42739c67694afaba99b8ffda79c212324a03a5003c5f46de9b26b32f61f7d4584f9eb9881841ec4755dcaa33ddfa74854f2e289f9282d749ab1cdfc697424b18134332aee5b4f15aacbc6d26c6ecf81793db7b0ef23c0259ed488cf46ca15213dc769a43f02ef40d3495088be0637f5e71636f277419b01417a3c3db2499ac38c451bb2dc9b2927f3d3a6ba45b998181e066de4cd65ff9c519d4dcc51a81f8464825ba2c51839e8dae4b8876e79c0f3b4e5b993ff8699b7da4ac29a924e9282e45bf64f35b45c606ae43c0a76fd57417838a929e6c625b2c18c4e675a00bf56058ef733d884dce2710c4a38a24de96b81f6207890a1d2fbc296470e10402c9ae589b5ec60c0e9e75a965e0a15b1ca5e735ce6589548140e70290deae2074d42667d0dad57fa95f4f286a9be8b606cc49e3c9a3722552e6743a64449d9090767c3ff609414195e1011208d71e0872b89571fd3e6187e2c4b3373ec5c65599de214b810c03733bab9f36e373bd5759e4bde8b7770beb3c1b6098933ba30fd7bd9ccfcc939374f161ad00577fd516ec909f30edbb4457b88301fb811a743dff06614944c32dd42db016b3168e9c0162549b27618eaf248eca6734c763481439d76538fd495459738fa20b672a93f9f22948afcac1b0fb106031664e7fc626f64f4596d7f13282088afbf41ea2b1938ea54f28e6d1aa04562981b9b8b7bec5e1cd7b1866bff1f22c21739bd149dd45b01554fa2214235d6b207e4a9fdab937089ffb9ac594fd292bbbf22effeddd49dd055e6aa33dfbc67edc229b896d863f29e1c412fe308c3915718a27951a8815118d55b55bd98c9a29a6da4ea109c5387b3297c567536000bb0f363679c29e30c9149602fb30d6d30c172d8dfa2428032f8bc5e8771fd8c8d9dcbe983b7d05c323c746beeef794e5f0119ce1e300345b7347121161190fdd2fa554c5b307569f8a60af81a618f8bcf6013be01e5c4d21aafc0c9db4cbae92ae519e58b7fb875943101191bc2b6cc5eb82b60ff604952fe5dfefe326a5a2eb7ba2d1d5da24e979bc88692993c525eee66bc20a22a534a55a400c05d3c91c40ed89e79d2ce7b2eaa80a86d995e4134706f1396578fc24e30307e8e17aeebea2cee5fdc424b28955d83ee8f9005d7e0d2c1f267b31741c4b865067ad72575cdf163c6499ebd396b5f4615dc28222c0308ae79fd2927c3dc9c3019d8c1d9ff894d3a0a57e3c6e24fdb0a7c488284986e80e51f2c550d8f457a8bec51edee4370e490af5c55a0a167452ff9db547866b7bc5abba5412dc023a87c9b359a906f1f3bd21c56db6f7608acf1a85513c33b7f6c019f1ca14357080b962e42ff5b8b6882996f9b388d8711d59238edf7c07529b87c41b7b2aa23e346ed0ee0ca34873bd7c9b7bcad3be6b249cadd74e920764cbec1896e5fedefb5dd60bf268370eaf80270de75b5948ebafdd5f68d4547c4ec83f1d4afc389f7bc72481f70de93b08ae60d39bd2b4f0f7776674e44d1eb4311e6baca722e2dfb4bf44d069fb5207d4bedb9c0d002cb32d79ca919f69fe561943c379fd17964882778074646ac54a1e43f85fbdff99e14a8d97d22a9d53c25c9d31c1b826fe3d656771fe9084107ca794e47112159d219d53c237451de9d973a07a651a59213f63726a7e2d52d7e582d190df018f5a3689e7374b61e30e9a3eefcd79b44fea1dddcdee4caad3e70afba9381af01f240cdb3cc9b2e4df6f745700b5309fcd6c97b856bed40eca6d9bd5c58ce74e9370d8233d78c6a1b65b921a6cb99989e3343de9dda659265d3f95ca04747acc6fc30eec13c99f49b661443190a57c5869351619666ea4106c3775fc8462ed8ae53f29cc7575d7871e69e9d224bc024b965b0d4efc9c92544d724dab6a07e4c1fc05e0c50d39510f8881bc73262bd7969fba686c522af7b62af4c045abc24a2d92074be87ffea2050058ff779732b8ef05a03d7f379224f3a4f42c4db09a6ae7d5d2602c66b26342c1c6deab2a01b138db56a5dfcb50813deccb9c5f9815a8a9f3002dd6b9386a7c394511cba69581380df24d25b07ad4f2d996462a43267a2ce963ef68927d5a807fce5a26ae9c4e7fbdca403d7f4c8e7152de9fb10def899225c6b3c95ec41bb020766a3b7f4f122e98e422ffbca6f58ecaf56c4f7686335d897383b859b8ca65540f91309e8d1c435d37e61045101928317bf3f3b5ed961f0128deade212edcbab668eb3289bc4743cc713b06fa6b46769a06ddcd1de193d08ab983875ee3d35826de02568b7dcb8bce72f401863f0867c5c57548ee43fcfbd9b3733135ef55ec5ceb9f8a703dca933b3d8fd6e4720da029898245d29e40ed9a8b102efa8f22d3d48d21e3cada66f3d8098f0cce8de4904e085fa8b9cdf629e76ed3ebac9567292c78822f24ca12e33562811d165fd7c9871334d09c101ab248622a89924cc3dd9a86a5b06e2754aef6c8a9c0502748fe9bad6432dd07cf47ad6ea644f2f8cc4e7ba39a6a3d7c53957d62db4312b06825da60cc2b3e3336aa169de825ff1663d8f597cb7d21f2c4ed5643c9e7eeec10bf252cb3cae139315b715a63674ae3eaaa6227d0590fd35abfbcea1cabf084af5f2cec490992f6946f5a1a80d1a8cc4f1d87da5b570e3c7f7f963e96de1fb928a0b97bc634e8088f8d48e152b78c7372c14567fcdb7d9a3da3ca7023f4478a806a605f04d0a3c1d0e577a97c841e672bcf2e0a78f714480718ae480e0722f134b751694ac41144efac4ad3e21327446ee74b1f426434a45b8687ed6e8d35b237a5f16c152df38bcae17d01a97fe1065b87042ac6fe4794c870b361caa52d9347da73a8975182983acfbfa34bf8f6e5a2810de23ffac76006b451fee3d0903af999405337aef71cd013e35b42d6128c8774f57ff8d695d80517cdb3d203ca86d6ff8071a47ce96a69742c08a879b7f73d9a7bc8ae24bb7926acff8fde742de13f56f24442140a0c04ebe0003e5a91024d38d26a23903f8c8fd2b9c3de9db3b1e5f7ffa42d4af5d267543eb3e32988573a7aba28c73e492dc1636ab9b0c89de31b6c5b545361db1dd43175b795a6e130358f0969644a041fd273758636fe9b1984db3d4f112e161dac4fe3627b2a9ac52c6f43b885cde4f22defa0e04f6334fb15a136dbe907c49d11d89f2ba2a466f85ef8fceadf94ff0292c306a64b810c02f52af6c707bb6a127b44c6af2ab30255326e536531ce84ff3b2e3e0d6c0ba27ba0163ad431cad1c172c08cd9b1d96404dcf31f1ec8cdd5bff8921f86adcf9740322530e1230849fb789905d550cb2b1d4b3a543824f8bb8eaeca8e0a90631e91eb1cc4ff3b1fd64067f3c18b12b400ed9575ea4cd97fdc1406d802270e029f655b75e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
