<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9b9d63da87ee73c4373fcc52396262aff33b4be6da89de98ec7e297413f8a3cb2eeade8ca4eb428e88820b1ee274c4daf7630556cfe2eca47bffb00a3ffe0cd66cdad7694cf88b61feb7c21902da70c3fb2f531242fd5248b1779c885deacb965d0403307a48dd77aa925494075def1c1f349cbdbf64f9422abacda41f6d10e6c8036be8a761683bd9b6b7eb0ed3df4628b18b38bb30f31f9886cf01aeb94482a87be72855a39cfe77249c2b1c1d805a3640dd3296f3a7588b408338d3c4f5f0ca47cc3037d03db73e49aa6dd17beac20edba87cab9c46ecc6ea70db2b836249b0a8a50afe35bbfab443a7b20a57f6fa31c01c66c1c4aa15217e9b61fbda6583960e342f208ca7263a18fd2ed848fa06a4fef392c38201d40153f6b6444933bfe63c457c371d3b8227d0cae770e62564ae19cfdb1846786c67c0e0f63a4a3bae2cca59fb8a70611b0cc31e847f575e30b89140cea92dda017352b381635b9ca2ca21c652f5beb2c3574ce0785793a2208707bfada5a34ed8e95944e8d3f4f4d38036c042c3a8442d3a7c61c3723993788c955ff43e464c3721c425344b5ba52484ab40f64763875c9e7816b9e178671e0b354881e408ab21a2020795a4906ec798c548f09c870c897660e1ea2f1c1979f4b5dc60184912e5a308b9669e3a2e9bdb02e5fbaf4b0330b2f77666ee1ec4c07aec808b3efc6c470049bf0306b277bfdf661f4dd3d4225606df448681d22dc795749176902e8778ce2e91ded2e95ab62ae3ecf9dd8ade6d2fca54e5f793b795376d402a50cb0b1516fe267d7c8fefe948cac025f8ee6c9bbcf89c9f030f900917c5ed1156da9dd1c4ff0ff65e5223609950a40127c3da56d4939e45c0efa334a5244993dd3ec01c01fdb501bdac4d5f643e5e0b9c8147277cb7d2f23cad0fe70b2e381cc9b9c5b6cd0bfde142a2eebb505e614b1dd7ae5f427720293639303f042e53533f62be05b3f38e719aae4f686c69675c79989a9b6e13831eea8b05feb078169db624b610ff96f8708d1b11501744684d658ce5c1af36c8df21a002c91cccc0f4e0b0d83573c3e4ad2fa8ec0740984c6fea11ec20130916ef3127ea278edde5555b9035d5bf62dfc04d2c2d9701f2d0d5e06c7474f45cda2d4556e03f1052b2588cd32d9fcbffc9cea868f41b3e595895fefbe28480963025e1179fe31158124c7f9d5a6b1197915399ecd7f0828478986742efad2757d71b14bf2ebcad14ab8aa029d7a9ac77b02ec1eb5e280c473d6c4a2066992e207e607381df132ad0090203f60bf08f7bf9e6f215b6c01bd5a6f0a4ae87d334d6e5ef46c7d87f69b508cb0d51506688f0a2729f36254b142a51088ea51a919a143120b409ad4478de024a599641e08613eab79b5eafdd0d06463f37516d5902076e00fb48b701ac08a02e64e51d965b26548bc60d721bfd154df8744a9e87d6beaf399748a421e2d259663e1a92910fa66d77a12310695de0a448831db83929708123986dbf61cecb48b256a6e0c3672c1ded497f8c7774f0eb13d4d7277d9de464502e020f84b1f285897aeda7751fd90857608a366d7ae0e7030a30ce6c7d2f37f5c0c77a4da613c563077ff13af32dc93c68e91056957a2812a37f7868fa416e39fd4d07d1b433ccada1d49cd3e5ee13fb0df6d48dd89d65103dfb29b9115a3bf7988fe5ea9d57910b5b0d8649300ff5f4fe91ee6e8382e4f92ade0cbde22286106504aed006476fe897a08e4bd7ed89e151f680c9cf2f5e48d6ba14c8d8baf5e73bb538a70ada13c51aa217f99f277c6ec88a5ed497dbcb2febd5388b2f42ab80eff93622ddef2e05e4ceeba1064eea7898046610f2a6efe5bd3e3c8732f2904b1ceb92d8b6237e922e43632e35f6e2999d0bd116e2538223c553f44e5f8ab53780419d1b981e849d56f39cee6cb24d06a7f4b476d83edf223e6bdf88c9ed622dbfc1ebd253bf49e77702efec0e5af7883b44c999304bca34252365d6d26870552d2220b630bf3977588cb68220bc2bf00c30192f8788f2f2065f8b1157ebe1ead9def569c635564dc7b5146b954ae293391f992d6aa983f0e2f267dfa41acd00d949121459c021d951beacb9d979b150d55799b09ee9744f80c3ede143ef503ad235364baac49ed3b60665f6b5e5b95c3fd55cd253a76ba87fd4ee2eae404b7522a83dbe00f9b311327ce6fc9ebfeda36360fa1bbd1d36dd86d8bf252c50a347a4a3a3a16b1d404e54f02a65c4546115d50e399c86ffcb82d05413840e8737cd4a275a76bc9ce401c8cd0da5f721627f898f2a8d50952bbc80e64550a2fa9810a304c0790b8e6518e503c614a80542a90eab7737a8d07f30452f70302434a97937bcbd0a90fdfad643cf849ab571b476c3c5e9cf99581fedb2317630bbdfc7798d2fc3057f82f0ad269f6f16b3bf1363d59ac286585269d38e62be4db83a553dcfdd39eb107512838c752aabf4090438715561bbed5f52871b7d64b9fdf07ddea8fdb61307a4679a5971a4171bd6052b0ea8e917281fd3ac0dedfc7f18cffb7032cbfb74e4708630fdfd81df87e0a1852a2f31840b2f57280b7d0acbfff1f81945ab42be8cd41bf2219f435f62cfa9b8126866ab2e29d85ceb03d3fd6444906f355c781981aaae804d637443e855ffb46f572a8d934c66397131fcdbff9829d55b4ca3248c59c7cb2ecd4ba16cda8443a6ca98abe8f20619f2d6195a68cca22655d7dc51cded6fcef65eb8f83cd29a0ef4679446b0941097ee570a98f8da7b280943a5ee1c541ac47ba685a3c8b5ef92b94c559782454be579caee8f8adcbfa4281606913942d58b929b667f5e67071e2b121f439435da91e89c301e9416cf51e5a8058c578f9cf95756b077fc828586507159948240558a6dbc11b798c1154ef0b1f05b821517330258482a2ed7ce04114ca06cae4a51ec608731c8cce5855d209f50955a73e64e8e5580695fc5849d753b800e46d360cd317bdf9f1985be9bb396b06be4b5b3fd451196149aa2e187ed7c9c4f98999652283bb910e0826eb865e73926d3ccf6d04db4af04d9b74f25d193d88b96ecc5d265bf6b4c8592c9cfd53ff881b427ad9b4551eecbe1c5467768f935f96867cc3ba7b2e17839954c6f9b3917a40bf5a86ca4d6f77b9b8be3caf297965a6aa217cbfe66f7989d3d01428ddbcfb310c3fffbb3f8a3f919ffb3a9f54ac60686bfbc35b102a5a90114bf9ed7b101590924d6566f46dd654a1a2fba65b6dbb5acdc3fe695eed48edd7625854ab66ca6a74073420cc72ea642aacf2d64738140c0e42c9c6533fc2d191317389aff080d63c2f8186b74aaf18affbaef8f11f4e32d50d54cc0a40316b71e7dc22432dfe9b1a75d05864c86e3eb93888130c5c35d8f9f110eb94fcce100360c14a7e13c7711718ff94c69e5c73cab49ab8390f55dd19600f0b2444b74bec56d22208be81b38496ba00f8a9a31950e8124329fdadfc9368d80024634d89d87de148ecc0aaa32fa433af53e374a3ccc10cfacd9cfc1d76cb9791e08cb6f77cabeb2df45f19b001697784fb096e5662fd351c84423046eead2062d09598e0a217250431556668f071411408e6446959f2e21fdaa1146f98b676c965b103b6302605d034ab0c49a896da91de312be871c5c7ab98f97c8cc94855d1e4aff505798727c8d913b311875f285dd44a1b63841dfd610835dffbfa9ff4211e6af973423b4a4bc0ed870b9f1b5ebb9596caf461cbae2d4718d49b6a9ccfed040a18a3c63f060dcddc94d271ac683fe97d40be4f1c5f98f37e303425a4b6c5b3d1484a4bd4d27b2e8d0219e5b5f3ab6e8375e14f7f129271659f6bce928ffb9218ef20c04124b765707564b07f902d010d42f8d1a7274902cb4d056aa7feca636358b0e2224a4ef40eaf4961e515c88c380017697fc5a60d3b2885bff209646970f7fd1a18a41a8741359e1177ac1b9febd77543b40be56108f0ad30cade32756df208b26fcde39436325343724ff7c3727edb26f436ef9d6ff71d24eb6a51dfea9596a657df490bd30deec623c780b5736b344d03925d34b1dd06668791ea9db84fd9fdde8707b626272dfae6e5871d7c22304175d5268772c55b833eebff8f1958ef4f19cb017c855f272fea8ecf4f1089b5a2b33e82e7e232a5cbda04d2a189c3409b8916135ce58dfb1ff3f0677614bd1280bfa06e140a2363ed8ab5d6fdd513b70cb1929f49b3fc68c3989d1324c3f29e4b3c60366f6096ff3a7979a3242434db1fdcaa9ed4f9654e7ab960b6211325f19405349bd3cfd7c2606466d234ef0cd272af3c28d755133bb2bac10bad14fd19f38375e9fde8c06d68833fb2a454c52eed95ad451c9508350c0c6157cec28dfa07698aeae4b47cae2f9c31f3a39e1284c7eb427c2e62777aa9aea201a176e6fa8910491b08c026e350f98d26ee51804dabcf1e872114ff42b43cb529cc9c7914e2963882bca20689eb9ee31ea2c3c4416ca8012ddadc75ea63867207652883667c5834c94fc95aaba3de209298c19e222799a405784acc40d3087169a30ef90aef2487fc31ac0c1fdab4db9a01da984c9293ef6e0fa14b4af46bd07ed68fc661104f414d63e5860045568a727b172e6f970d810002f63c7c1b91d08851476b15b92ca4ee445a8abaa806a25a47833cd1a80480092d696098b73e26889867701f21568ea0bcb3b4713316567a41d9ec7f9aeecd3a443dbc66792bbb9a26ae2efbc72ebbaa5ddba3ecf786959539a6854640b8998e72778d6c654b3201765af44f2b4e52798af67b07b767a08279ee0e5f0bd7a6413384a5c4820a0c5d906d43906310b59bbc95de8017ec770dcd33501c3cb6b9a6ee2da0ee89649a31da3f433d9af60985a091111cac79ba792ec4bba89380806eefb367b9b826f956c718bf1651b1fa495aaf88bf4a6f0970c492105363d9870a12ad6e9dd6c4545d6eb3aa7a141350f75def509ddeeaea7182f954314b988c7910cff6d4c5c15e2f3df713215484afbe892a74589c07fcb0a96395e2818b0afc95ba3e787959a2b723145d862ef14e5b25ade906cb360c55478716a5bf495f55e20499e43af6827ba33bd15c9573b3e86d1c59931deff2c32fbf05aaaced2f717cc169627023b72ec14344b65847732301d534cd2c1ba3a6fba29470af3f30668a13b48b4f9ae6a5d14d49e56654482414dffa48b501617323130bfb142f1b45ef83641847d460e4f5f029d1d33122a91cd61b106afcabf11ea90f67693a089bd052612513d32312ab8fd1c3e9882e9f26940b3f84b5bccc94abbdb9aa4bc518145d95811f19cf57a9a55758c4ae416e9b00d1d025ecae391cd2cfa582cf35c4b7b5f73be9adc3946fd00d35baf12bae2e4947d0a32e906ae31a626d4f74fd1c4ca0c2bd5edc473c1dc55f0035f53f24df704d71fec4cad8eb3be11e832f5ef5abcec332a1ecebde7db5676838d066671be5160a1dc61cde01a631ee8e13794889d56147ef4e60b9dd14cd18515da118dafcf7f160ae7138f4f72d03faa81e4b55eeaf455cd6400800de2445ad3d965d8d1ceb47bd859f1ec637328ee0f7251c39aa873bfb17ea4b7639573e264f92cc4c35e178211b6a4c1bae0e88fd500a9efafe12881f1b7e64d75cab33d14141d2581cda8756618f30ccf83b1622eaaca56f1dd0476831e1e2d8fd3ff7db1bcbb61affdf388e2f16925c8cca6c05d7e1205abb507b8b93503201842fe0f49280148701899343add84e73ba85f8044f34f7e3fbafc7bd5bb75432df3776af42f4c059dfeb9633548fa1df372cf5fc70db446155326e42586d103d5b00184ba5cf10c7d45204139060c08c13b2f74bc49a83953d425b12408e2666bed5750a59f5366fdf3b62b305895b7ecedd927c28ab586a3c89b65f8f5f63096d196371fd28e0508a33b9fcff38e0423bd826d921d1f44f3a62a560e48c0bb8184286d7a205ac062123d38be391946cd1591bb3f6236b26ef4e52857c365007b1d5ae23f4926bca9ec6ad87f489838d4b33ce808223c0388c8178d41b72c3a3cba8e4c18b9bfa3e6fc474360f4693e38bcc9c183e348ac045574448f27f91bad947c9e6c14aa5354704bce46ce6fd388db9eefc3bfacdbb603330f0d36ab7c22c38cb9da4f3362d5e2ec512924b8897bb007c514dae421795d10177cde529bf47c4af33d92919f2ef5554c052c4005433e81065fe437ef275099ae030db3eb6747004e677da466749e31471496cc6ab2b84a2430c5fb4eb2d3b7a85d0d1eaabc0273f405fa547d4b96fb205c2d9e8d88a3b7faa46152d8b5dff7dcc2951510bbfd2d21881158b98614ea8e302a198c46d87682ae55cdc64e7a5a9438e18e9157dcfcb0baf17ae430653ccdbc5efc996702098f01c3805793fdeac07da6011602b051fbf2ced3068281d8ff37315b8ad54e67e51b59665c05c02a5b56c40fd4ce2ca3baacc6595f7a233539d3546e4022aeb44da6bb14d16f1bdeca3e1efe05810bc554b1ab31395820aafcd85dc8bb8cbfa6e6e69b5f1b0d6fb5cb97edc18a0efce9e1643a1424968e451a18e692311e75ad5c5a82ad6d92295b38b526c2a16a3311a05516328024856d2136526d0f47816c443dad196c58bc5fd198fc2062d1efa0928ccd02980627a7bc4e643cb9caef18fef18155aace326b2f42ea20735d2639c3c55821ff87539e33f7289c0f7a6578769ef3b410ead67c13af8981cb68a893a98ddfcc3d5d7dfb51c4c618de158bc509f10d907dbed2a6a370b73dd8c6361a7cc0fd332a956674567c52c102e5bfb1007db001fbb77c5f38959ecb55bc55740b3908093a88d8bfcd996809afd11c09bc13ac91886c65205d701db82517e2acd524b6ffecacd76d6b1edd9f3363e82fd0bb5752ff4aea8ad3febf2e75b163edc88bdf6524f466d97dc8f95d7074818602715f2111e3207c2acd7d37fbf3ef74066bfc93f631922b1c5261d5ef2054166ab1c39a3eef17047c50c8122850a954cc88a73436708b1d1cc6c34ee6268dea1134a73292aa37801aaf194f7f98f214a7994a1c9833401289d9594e4de0f5c765c573b6c72a80e141483ef3be77490e31c7f55118b9c53d062ace3199b1680e2b67956d8797e2d138194cc5ae33cbaff39f8cfd2a33120b6a102e8b6f8dc0eb86691afbf73dfd0805a2bbcb4852d890554d628d80711d9c929717d03d14a8510a444fd0d47224d0a796b72c911da8727940cf9f1b774c820d5f5d660bbc2b7142619dc446f046705ae37542e4a8861b3340bc1d37a279877e7813943c4a355c38974df79b5ff5cb8695208e24df8e5b44a021ceef49a588114f5864af1489928ab628db091240b7208a7f9d1d8ccad48351366b5236cd370b7b67d0c954eb22504c0da66a9ec4b4798150edd57842f2fe9430952f7fec06c65f17d002fc1d846959ae173b1217aa3146e0f5b9dc18bac5bfc62e8b62d7635c06db64c24cf8bbd276288ad8377e25a405387d3f4e27bddd6892f3eea15ed356fc577610cbca9f56d085c3e1abdf30ac1b11996e6949585c4f77363787021de6d6ae97a93584bc27b3f8e48621bbd0d46629e62c5bb2e9342b12fe2edae77839c2ed4171cff7f4ab5c60ec4c8d3c878ba9ba0a7bad641a66cf9d1dbe5916d7c6b2318a9f665600c6eb47b703928e05570c005a1cae179da9b6dbbdafd2d6ef89595c12acde41487f53c78d50a8c76aa3979fd2f7ef0772479fcb2e89b66adcd163da0c8380553c3fb73c5a09db6a172aad7c6374faa30cb985f71cf1fd6ab8a4387a8eaab8dcc3058b94f13bc840f3d3e48ef2d360355e55cf73d9f474d6f7a13cbf0bc0d94b55c30904601ddfd5fb670efd03e3079e4ad3340f30bc523cf62f284050d26c47dbc318118fecea03985ff71bb045281fcbf3b634d72c6fb0962ecb73f4afb53cb6a8f500971e8c23c6f0476b82de8dbd2eb8c795750923354116bbf72896f8f857591e114cdec004eb47cfb1f78e3c1108c2a181a32bf1088a7093b382d420f800488344acd3748758aac214b45eba21decaa852b4a6ad8d920266fe3e4605e9d401a385b31c4842b83a079e32a2d0fbeb5fd2d4c6b2ec36926f02b9f06eabc075a5f4d79b57be40f88ea95ec501d3fc7b372520cedc188e18a2b53386fcc524bba2356529647d77772dc116f7e368f075d76d29d4a9ab5548030ff4014e361782cdeb23d06dc0579b44cbba525b9b3d27b7f38790c2e763cf49beaed1fdefd7a0e90ea6ab049e1dee524fff529e77d26e5207f78c7ad3ae9d3d4d9c46c30ed7650e730e21faa661f20f0483d88572662302ece3c9833edef81d199ad49a5cfd50e8b067f3c9291ef45829a5d0cc44c60738ce3841e74e19a5f3642ab950a84d5d853cce3024f39e0a6814bb90ddecdada97cee78d0c31c757decaa82d6057b55c869fd0cd074768bd8488b697f86d8d8b7c877207d89a5f93fb1f4e35ecd33cc7570af3ccd63bb99791d734517450028d93484c0d4bb711d0f7a8519f2814200071fd3d8691c51485317318bb8ee4ba7ee207f7a234af92f533f50ca90e11c54dafef76ca8c121f63fdf013db52659af68b13ce878fde29db8e8c14aa8256d5f9a685c88496298d360103c9420f0a9c473d9d951676430fe55cd6584e22a1a8e61f91203f27134b5f79047a5ef803b5b013e6292b8e8d88ea6bc8bd1341f8aca387db8e5857db78272ea205d9fa724cce460dce2f13769a5f72e30c5d91e92ff139e1d92506c8883af49a874507d45b303392e22da277a3f623769bc4f7247c0272827dea039e2f850c94afb4902e4cab8010a21c81f1b110591705b4b6f3e9cf8e8d6f0bb6369ca8bbbdf16c87d095c3799d7a0f90454955dc7043130ef811a71bc5a00c0c3f016f4c90e4a1064bcebb4848a9397952a3344aba2f70ba2ec4be7678afbb329f170d9c858a673906353ca989b71dc59af4d5ec534b5298f6a09bd400198557a77005c2b9f37145144bb48f81198ea6a8433151993d79d7c5266f4430c214a1966bb31194a2ecf2bc3f053ab32891cdde4fdfdbfff5259d4a5c1d925d06ac7bf2d74eed1322c20d92fd09c6509c524bffc25c306efca4e7242b4616215afc734b3b113df75d5fb9676c2b84bfffa97146480808e2d8b33b74943a363e3ca19f0b8c57b7b05b94bd00b099742695782a387837c44ef333f58e87aa0ec360edfaedbbbc8cc5c6a5c507ed219f6d91c8644d1e30eca057a5ee142351a27142b3c60b5248e829b0d2fecae217f1d15d86ae0baf127b661cc7c02892d81a9b35d9c0bdb5481e275d210bf7658c144e856a147ea7beb154f4577e06ca3bf15e5d54580850b3d51e671b78f1e8da7b91792103c713cf9e540e98c85620aa9c65118d045ce4b62a746672cdfd76d37dd1d93fd77742ae7e319b741adc7b87037be71140ecc5b8da7468d018dbbfeea5f192a8495cf153d4390c8372a1175536d5de9e89ef364e44a20b87a9175d1414bf195def2bdeb55de507a107ae0eea2db57739ec37dd451b13117f7d9288e251896b72750360dd94239a3feef379cafea7c1f2906aaa2201600ce60b4adf1bc40ee982c511cb356a6c2937f5c175704a7c5df5cf08a97f937f3f6671d21754d8ebaf2b018a40a278c29ecda2b884f64a9c36ce693e6f5ca6c402aab5eec686b185ff757c58598f6aa3d9bfff10dd720a009c90b784a7022b9aee2b10ff18876fdc38bd2cd69dc2bf940e3dbfe8dd02fcd10c4eb94cdebde32157083e8fb861e9ca3179ab4eb4e7f58cd0a09b1de34919a016eb0bdc8ba6f85bfb76492aa8e80450bdd4e127ceb031940b8b54e9e6205c81bea92b72f719ba7beb599f74c85a4a3fbf33b981ce0737dbd72ce0f9dcf31d54363c8dc3bab996234cccddbe356e0693dc46281b12b5d7fd5794ed51e53fb2e6df297341f0a69cb18b96d3589ccd871ec08f409b19cd915291d2adf5970426419e399233602f25d5cbd10f92cd77485c09359c48d241d827a7e18a2c87c0027a1cc1d3998b4fbd964ce72f6875146653ac7432b458c61af06b2f3dcfbc1b7052f703e63aa38ef2fcd5df4257d96095c24ecaf7b4b74bc767a39e2bc8b42c08197b9e686b28e9acd994cbc9dac23d2d431fba8d575b1e1bc84b03046de2d11d52e419fc6425b0a6ddb4aa067a872e4848ab76a8062f79e75522256d8b1d693ff04686ca316d2743b56d01736c69da79e2b995fab117d1a0426ea263cd00e34350eb98c5436fe65dd1ffefce26df02878199d9f2eeac79894601fa60ff9c6dc0b2888f92c5b734df4f70b055a58f7de18d6b6df99f470c9f647e6b9474af26e8634b7b5727850fb23d78b41a00bae95d9aea8b174aaa84cc11fa5e9b928f379717debcaaf63bc123c6d33e8eecda93e28ba0af05c790ef04e39ad2ae99c23ad2b13725a2e0a674f5ad6e7388407144d1d98c1f7c2d4e68c8ca255f6a2fdd20bb5a02c39f7f16b6369eb10588659cf2e8b0122053897a9ae65989c52406c07b93450800367baa5f0673c94a332561552b6340f37cd482658bc092629116b620027cb8bf72f8892dc0dac1e139fd625c5fbf290b3f8dbd7ae7e59a91d26577105669129120fab724c251c89bf1e2df8f01c3c6151d832746d3810933398884e64e1ae88c5108c030206cd8b3eab959d11c718ebd59fd4eca317e8f940c84d8968c27c187f37c198f1231fad4ab6adff6d0d08b11f81be78569c493f27cd3e4b0dade58acd3f8189656673d151fb64276124a88f5c4be69ba30ae4b1328f57a93bc69b5129f239a26d6ef8ba6dec74ca3c6cfeb84063b14fedf26d81933d13843a9be6490858741a12806deef1d6a3ce43eb16430990582b962a20610ed2e575572e3edc10a3d43a6544e7710c45d22c4ed33ea8a4f418e54db432e48119da2b486a1b6557b837fe5c3ffcabf78182b486b62c094a9c37ba20700198125e73db20c274625ce3e1d1ca0c917ed9c70943de39f9360db811a50a2cfcce34c0b8a3453093664b8c80eff06cf1f3264f6a38e3baefdbb99a17d8ca7a79fae7a51ecd56ef36dfbcffa02e0558fe650a780d310df6ba3b81f76851aa2aca5cef134633ffe56520b3d2bd70bb3757128ee10f6fe8ad3159a7c5430587edfff3beeec0d3c9818b5deb15767e9e6ba3fcf3f6361b50e5e66c130f7516b5aea4f36a845c465a10ddc53a07221873d76986829059e80a43c49593b067d7fcd33a36271eb3432268029e3c4853bc419bc5f1e1ff3e580d8bff6b973bcab2179140b2b93db9e7e753e1a4c3a1e2b561d802e166ae4e19c177370a0efe6937b4304e2c911ca6fdd4b79351942a8ddc0217027a36d83d30b1717b89bb9bc22a64af06f7714994fcd8a0692d43e8b8b7bf4383cc9285014041b1b1a1c77caad1d73d9bd85dfe94f21fc7840bf7ad0a4861da0f96f322921b71da1e602393d2b7120833c66ac08e9db7e6101f5da2589b1fd8ec901a2608a84b4c20c2355f9a6a3f8805657afb5ee5c20229a3094174eec05fe4f67cb7c0af19a2a98c9efd9f7ccbef7ad42d5e6705cecd9916264477e9963a125abc28386672b4c0a94c88ff9dfbcebc94ef854261a429fe04831526172a1fdecf9e1dc50b509f3af8df9217d0427f571ac598eb742f34283d0f4c6d729f9d6f0ecb8deaa874a19f8fd61745b59835183e4dc6c9de18cc757119f0a2eaa91a7d0ade03c15124affc7b9c90e3b98b565beaa3524b703ce5e91985f68469a6092fa9195040ccaebeff2c1691359422cdfa1d78c6a263ab22d843263f5d56a42f14d34884073e5a2cd447f554239f422ca0f7f87762da3f3d6fd4facf3c04c149e2237b5a7304c2b88f1878d92eb5465597a47ffe0930c5ba8cc329ac217662bd24bd0dd9cf7bafa88c4ebd0a69b6fc61fa4937b845806c1da371ea966691a0f388bf794b5a7317bbc201a849a5766703c7b171d65a8d29ea8dbca8ebd98ac628ce869403d51d7da0244ba0a7d073165c151a1ba60216746f7d3e7fa6c12ea66f9d12eab37c51f79bb27c3352a8be6d6ee9b8b4bc3f15bedfc13863af864e5e065fe44b9f8d3207dc758efb1af71698de4ed3c65c5cdfe0992dac734df3c97002ad92c8dcb25e7ee908742f482a2aea5d7821c9b5f16be49fcd222927bab5bcd341b8ea8aaf4690e89a666185e4499a062e8d8451d246cdf0d808cc952f5feeaa2e8f5dd7d182d89a4f25a9a89ad5975eb13ff51c2bf973f68f0ab257edf3463cf5734d219c3279fa924bb1a45ffbd64a68e3ab8aabfa8f187c31725cc4d9e1fc05f1fd54eb4568f3e367674d589ce36e01e255a2fbf96a6397c0673616c5d24ce81d15f0845b419d8979b055d361fbd8ac88131f120ebff52e17cee7ef6cf5895a28d83957035424c30b4e032fa7c32f84112d721a3af7e1eef0d4cd12596b15e22c9196944535f3bfe43f077de050d8ed0c15c2292a51d5a26348ab9a674446b7364bd45b011ac13179eafe6865b2f6a5356c9ceb391e1eff5a88296dc32457f51c814afc932d245bdd317f912789bc77abf9cbdd6eb25197b5c2d9d56391b428f19141d2ed3660f14c1abeab0ac50d65079d6126774de90bd46f1e0516c5e0d89f98299dce39de447f041ff0adc303d2020144cc39e8974186a5fc3f7cd05218835f75bdf58b469336f5b27af93c1cbbdf869af1904c011a4114c9e30abd822674baf3b10b48897941e81f78a2cf553f4404a5d7dc2de3187ec9afb3dd9e98300059ca7bdcfc239ad6248ec0f3b64859fdbc6dcf183861c24afbe5deae752947108677fb9539e61313e30c2316b998450feaa892026fb8dab78b249aa26f96afa000a14fe451dffc2006cb393997c5d9255fc04fe58991bc053b8d943eb9e2601528fb7885d3157135f0689610095d19c2beaa53322c89e55fffe83b1efa266ef41bf05234ec1eed3fc870da69a3119e68e449fa9c7eef972881bc112c508208b22cceb2f127e2e0b92b7d4b5287f958b2042204de034de957af11dded0a3c774111a0b98ae019fee119014e45e067dddd7e7c22c118c2181d67cb03fe5fb7e21944a99afa1488c5e474c6b83d37a6a693d9a42529cb548225b97bf4540b572e54ae84958bb4e26675fe01fbe0a3bb1023b8c60b103c59983fb491bf694600067b2347444e9f4ae8cd1b66eeac78dd5e2a5780b80691196c0c9c7671d21b2b691ead57b9ea0cbbdda6c751b87091ee91bd00d5d2104f6ecdb679b35a58d517691e6c332529e4329ff72ac2194857ce2c46f85eb6f9903a18a5f45396e1d2b2e7917a1a378455c0e94206762a9a1521f12973b9c43e422da0e055643d2797aacabc55a990d56c97bd10e90ffae1d41698a6767ad45ab2c477656e50f83aa7c36afe20ed8f12fc52be792e3d3db2df8ce98ab81f6fed49dae4607e5966362e496a9d191ffe9fa45a9bb241c791e19c8f60da6e557b42ca05debefc0324fbb2a64ba7958d736bc506f5c3005bc29965e1b55b76ced77e2db3420dd7d829d7a1ef530baadd35d74f5543ee152b0cd49880f5bc6db4ae2ca701ff0b1acbb0b850d74baade89918cc3f58ab2245eec9182e0d5eac9228f4f224f687774b93a075645eb7608aa39a109f31d7898e55718350d9cfb55efb1d774e7213d10ff7ab1e25c1165ad00be8bc1dd24ca0ccf0986ff247e814681ea0973f7098aad4bd453395bf06274f88e04b77a7919d366e0df44e0551a9c92d143ece79ca41669493cd5892f0ce21e2fcf7d78a7dc32254a75b9718dc4e2bdcf9c428af630a795506cf651dd694333d7a004f75b413e2b318e515286c6b7300ab2e8da98022d7e90ab15fdb3baa616dd4cd8eec7ea84c498220b28c6581f3a50f0e8865ecae0c5d7652cc2d8c1d8f0aee6974ff64fcf7a155e576f0946191686ab92c4ae858f5159bbd22e68f0075994f24076f09c3400b668ed46065ce03dc3d070c430535221b6c62dd269b55640af364d3214aab11c0ca8e86a72666360559846d6823a22193427d6ca36218e5c5dcb3308ee845333a4d08efa119a3c2639810a03ed6eead1768a077dbcb508eb2bdf6cf3f8f3b7f04e507a754851ac44ed60e7afaa00d320b85f3d474b2c656ab777fa19b96d009a6527ab1bcb366e26a7f0642f6a9a5c519e51e55dbef13c4f83a415021178766aec9422780d8998cb1dcc573b7c779ba0333915fe93c04485b23589debd31e3f583579216afc4ed5c9051f264e78c6650b610ff75eaf6002ed84957eb9d62885ecf0c08c9cba7e3c4351c12512b36ca58ca6bbec1ae98ecbe36af3c3727b8c826b7de532fa75ad41d4e012fde595b85e6ec5b54092dd30ce40173538a439237ba9accab281b6d6c1b957170b6457c57246fa2946279d6e51c8774413b37edbfd2621e7aa6d756e85bce1a43771eb957df34245a5a2f43ee6ece2313d30beee3bba216d6ddb7f64d4ebf96c6703c505b45ef2497fae5105724521e8f566cab49f6e2cb8f1ec30ea6d2bbfbe29bf4b30699d853de045959622bfccc57447d3332792473e2d5c552ddeb5d859bc8d67a5bd0aa242e070f0ae4aaddef9a8a8e7fbfd6e5f77fcf5583ba452bfd605fdf4ea84d3f15507283b452a67f69eda1678e2a7ec3882c774ba8dd0e63a773fd7303c79cbe34d70a66ed72afc0005c2998e900603592cc582c195650460c927d1871ea34127df4bd7a2c5ebaeb31bb2a5a52f7e2b1a24d8c298eed4339714f32e7105d1898112c0ece1bb45287575edb73674ac6dc8c36a6d4771f0cc740ce35c37bff90e78fb40f0bbe827b05c855d48dbfbf5536c0350aaa789907130ffced0a8248b4f059b0d7c8b45fccce28ea3bfff7bd03d72f09f6e1f176acc09f54011882abc310a4ef7684b908e248be4194b4fecb8a3b96ff6a0435fa084a85126a24c5cb6483ba0f8fb00b2a5122b0fe121c924a8d7a98d2049dee61ec1f3f38f032eb1deab9e8b3aa82810cf9c173ead4c977ad1c95d027d5b7092c68d1878b6ea421056b15a76303e666f7d568fc939cba7408764ed10163aaca53772fd153d6fe48da71e5bef81907d8cfe5d2ae7d0bec0ac320a584ab518b110d07fb07264031bbab9307c84e3461a2798aaf4406d4c2e9b5af3a62a8ff14bf1d7c1489cefd57973d3ab2f6e6e0fe2ccdda6a0f11463fd38057359c7cfedf147ecd1249ec507356f7db752803b3eb75250b64de5a877ee17936dbd1382fb351814689f93e7d1d1ffd39e39cb38c836bbd090166d835cc1caa85e7a002e8c2d889a4bb5afa1449d53fcaa46afdc6e431aac5f9350c7017c225545be8685201e47898b951f6b6f57ce0aae69eeef0ec0876b1916bfc5c87c3b885e31d2a0a91b63c07decf3f0a146d59f4f2e018731dda5513fc6e9521bd3841655b31aa62369ec22d97faa4e38f16554323a6cee072ed2c681edfc37e734c884972a4dbb58ad536e4e6e4a277fba19823bc099aa596806993d267b93e2fb5ccf9a90a36e2231a228be4df48b07d3ca5086bc4d0be4a47810a8d008f633b8ea04f9f502d1d42895c0cc9e6b03f5579c5d57797f776d76a85474e39b90fd7db0eab70c685232f8ca75575470423cb01c8c32a69a359c3352a4e34cf4132cafc1c1daff2dba6cdcf171aac19e0b64e610843114fda8fa5b19a4a2b58089b79899b78306dc154855cb7e80a4c56cd15b53198b82301b0892b5a1588d1e994bbc9a752b9113de018b6408758b2a006c4c01f5ec4eec773dfb62237a002dbc1f5e1cf0746b51b93335a7a6d79a5e2e392a8939beb31baefff723d25aecf36d414ba07dd4eb087feee20605022ea65dd0e02305c40521edcd08be1399d7dc9cc4f0f25b775636b493681d19c29cbd81da7e921a8a8b0e294f0e0b15f536c617fbef301c0eedf09e1609a29cee03784788c6acd3ff5d382e0bd486e227d4a97bf2b2837cab923e062ef805d82f8638886474e7af076973e0ccd07c9c8c1fa50bf6fab71f7e8d8e35cce27f7e1da73b567bbb43ef0cfea89f56c271736b0a12f7757ca3d99ef2e7f35131f4f00006c3c835ae406f1c63192258d58aa97a1077fd0cd66624681787aa7741172dc6990b19cd3c6e88a4410a20760e80944273d6e573dbb50093b29b3b18162de5b45168b7b3fd3f5cef9bd2aa18734d20135e542412767ed96ca757ee15b7a34a6d2c403264fb8a23294901163d9393dc45bf3305d5b11d0a9c9a7fe12eb9d09af9838b730179530199ea98bb4fa620cd555aaa622cc5b717935130823cecfd2fc60a2a309a172254b0b14805acd70833617d667cfdd024d2bdf035182b2cfb558f40e0f4dfc8491f0b00497487f782a03b0b5886c54c11986a44e1eb2b8ad05c76350037934201d72e98828ac81a859e5e04f63242b6747e5d737c41a90fdda456a049786719916d06cf92d464649daaceca59f097e937fa7fd0a130aca41b4187e7da626b31984c4b7805d0ae91b2d7eb4233b55fdb7ce201896873844674ee943ca01bb9bf2a45a27c9239ec124ff48437e61a0cd6250667f5baefdfbdb7ed55ec3b777cbea3492a3512e33a315c3bd3f5efc91164749c9afc683f622a02b1117a09e2aab4aa74896d293739c45fdb9401dcadcef44485fca498eb1b89ce5512e9a7e6b67fbfa3dbd811811672342360888bb52192ba2a88688bf24c58f130e2031798843338a95055ae6f34130a23d36912f41bd2f2d2e6d72ee93ed5cb9c4c6de5bc5c2de9c38a7ede5a25ee8b10093e8ec19c375df1e82559603c7a2fe348c2799a967c840f72475afdab371b38d65310ebaf4978540d174c4acdf03f3af4f8ecaa2605d2dc67314d3ddad88d92cf6d549b12de9122948db132f10f3e921d5598d9db09e968a97fb27c88907931e39d2efadfd4b66101d18e95eaff655a1634ca6a3696b5a59ce83a87060d6a74ec750b6c8b360852d6f828d17f12a2aec48ed7264bd1746c4cf0ce0397f92f20cada33f643af1b10b3f1a53f4993e9451c39e88b7888144f656cd54ff777a018818734c353bca283b5192e2ce548a880f80c8c436f8086dd7796fd81a4ab0e06240e7ce05666d1b666a7fd86c8a52e2056ac6cedc0950556c14a9d1d7b1808b0a8bb72513a96169e09ab55727257333cf91cf791803c5abecc6b58f59ab53b159a08be4f71c8249a4513c1e0f6127e21f7932e31d0de08845e200726cabca5e67f953bb76c8e4f0c8a3cd2502cfccb41507322ddee9bb5c70c84d28c8af6e021081f4c2b8e5a59720fd4adf7d14fe19d115f24978042844cbc31c6a7a1e511f6abc600ae2f81e728fe98b20e8b3b4200fb37a9568cf9e75d0ac3afda427e2c395df11f8595c848a55da69f6e565be94332825b2d97fde56ec59cb686598b1929deacd434f174993061d71ec7a3736a46b5702208cf65a7e490b6880f9602b9c36ca25f5e5f14b907e7bfa97e9541919802a438933033c3c91c68f496c6df8146a6f58d7d88395f2f8a60070a416b28a562d92ea264f5d0ce9bd9bc42501762ce32196d0cbf2e6e93325a8da6ab179e7961a1fc46b8ab876bd7f2be29d40a416b2b820d7ec3c692e29dfdd5d87200f67882dd271d34f7e5121a4d6e5108a92816490c6e43ef7f772a00c4a04116f684ceb0a4c21378edbd1bd45e706641336973a07ab53c1320a158b368f8a2f7fa90a1d75c9a0b5617d9a78c1db01b18faaa04e6d433d513bfd3bf4ad0a3f444350b5d9cc032e21d79fb8d4dc47b7f1a203617fffb12d1c5cb62d9cfa9b03c5cb56fc950a85224ffb60ab1164a415718393a9beccd5fe220bf753acb7a54de891ac054896ce7ad15516ea051a7a72ffdc99a13ffff02a76a8ef49278a599207b8ac5527e12f9f390d0ceb74e3c20a94c975cc551b75c632607bcebe6566e85cbf7c0c9404c501509887402ae575e2e9246cc7122cab10cf8f71f0db15102f076feb036d6b180583862c3c1fb3f30d499b76a4dabfcaf029c299a74dffdb5c64197379d30bdf66339c80fda91e51174fb6e4acc99216351d48185ad145ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
