<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d5353ac1a1924821bd8427eb61af00b1012b03b8494168dd9f19381b66d9aaed0201743f904455e0105e85a675cf939db0197589e9a4c15cc8799fbb8053d070b1fd42b11508087857b1a8254dd663fa05feca3ef2db2200ce81c3eee58e77fe4546d234418c6b5221da95549a583a4c066917c3ce1e69f45c0dd2be7d41f91e8e17d4a72ed6ba8a24cebb314badf99ae4910e03c76b677b52e580b7a3be026cbda29e3f5a7a59ce0335bc1498da4b4b41eb75d030c05085868d15445fb74c59d78bede2c3a291faf5ef978d853687a34cbd3de0205744b2196ac33a458f78950457355ecd2a148e58ca4e609befd80fd935b7fa01c116d916287b33ac532506444b82a16eb88dcb304f68b6707be22f52a45626cd20807933c5d3282d761969358f919a80f4f5b81c2c1640892b3554d24a942ceaca6e12c643f520b3800674f25bcd6685f326ee72a70cd0ad0e6b601e8c92a4c585c1df143ac13a3ec96163ddd71c3933220883ea65473951ca771c61c3acacc7ab00bcd3721f0d77858963080ab54647d00ff919891774fbe8e2c990dbd0e05673e3c58c93c65ea45dacce315a9c8b08104cc28610fb9f8789279d594803a3bd0c915cb66624dadbe00eba4e6a69f38988787ff1f4205018c958051d13f8b9c27461428fc3d6e7abe5e3fdc90cb315abb91832789cbb6a90431f826c9913e7c1a2ef9a9565762f669578a081cd6a77140f5abc037f2fe02a5bbcb4bafb64e923de7e0135f3757416e4f9a80db4bda5ac0285035855d90ec3badc5c6cde33bdb7e8d276ee233a56a6b4f74dbb3362c4a8b4c66c06acccf4ea2cd92c531aebd925c603d8c586c039295ac0c260e958ab6d77edc4cf0096aa6a415dea736b32bd491d5fc921618229a27e50c11fc5760b8237c9a5ad30df82e246c1c4542450b15c409b7a8712adc651e317ef95b865635b3d0193019d0db003a08a9ca24dac520d9c4d3fa1aa38f8f84bb2a51c1975c5f74b8802cae5cb93f1089e8c6a0376d994411fc8b3f15ac77b3850487ef6387e5b8d281e490c42b19f9d4c4b66ff99dc4ace25016b0d27df4585415016f2eef09d79475d49966db0e0cdf702c62ea7caf1607cf1e0e28c3d70db9c91ad3062780a37b071d332d574a4f222f958ea422039c1ba51b69226039ec7c06f3edada585af4c683e15e023828a0ab4f68f981ddfa534a4d0e702ec0e6cb55a3c498c09d9a7b286f6cea848b362edabb160b83ac80af27838bcbc0a87ad0d542f803200208c89c159788c7d6fc6db57142f8ca14a50a186a2a35f65373d5caa17197bd55ef9c9eb3c9cd88128ed6ff4cf94402fc32fea1875b64b77624014318485f1aede5b22d22fa792ff7b063372a8ec49484d74116f7e0447285eb01d80c6fdfb93d2a08326c514c00e1f52d5dc82fe7a13630a1799040b1eb1f29bf9ecfaf8d3e9a5823d034d70f21e7bb6b7117111c00ddf888b1553acd7f12f8f8f6c5fbfdcfca0140617c9cb172d422acba79a882c012622feeac9515f329b3de5ee403414145e6ef34641bf2be9400f019ae08737fb50bd90cf69df08b1656f5488b2efbd931699e581f653fa003d108e33b2c26b2ae15426ce51ef43f2f105ac092ee5c1ccc8639cc3c08018123729c0e2ccda31cf6a2d9bc3ec41e58a9b23aa7baaf4747f1e0fe8c86c3f8dc7bf6eea78b06ed55e1ccf7f3d4df4576637c0ebfc75790e535abba695b2fe21236ec5aeae433d4a953030bd63fcf10ae1f21c3eb6bbaaf89ab60029f34ec182c2a1eb44c29ddacee8116f56d312eea27986eeb1f59c4216cf398054159b7dbf5dc94e459f63c64538a43433368fbfa3ee7f78ce72507d634ecd7bb8226df464a45c69d4537064c6af0e9303c719b7e663fff381f606a478b790b66adbf375db0577666c73bf91529c0cb82a81116709508e15d3d616003095a0f8961a88052421fb9d862350939907949468068410b6a9b11323ab981d06f8f8835a3a23177b8a19a5dcc20f42ad6411789ae3ca36cdee5973438b201a750b0db2e0e1b3e15d8a7c8d7969252dedd5ceabf7a18548d232603b4b8c890071057b848de733e31d2513b095c1d77b3b9d0e9697dc8f211123110ab483fa4d2858db7de5e0a83d96bb72b137c7448bd7a0d588058ad770984815ab0214dbbf119ef085dadf4ba68f7f9943e1b9a50f6aff3a16f718fd4973f589c9a29d681d0891ef0f2368ff8f0c2bb12397706b37f742f4d796334fc37ea5c5b54598522533bf8f0244115d4854874937dde414b6cc726e732139a84391e440f896871b426adc90f0ed0b1dc801cfc6ae80eacc8c21a6c7044a70ef4da734cac6ce45c5e2ecba2ca71dc4989410ecaabda4c1024e0024d1bf883b76b425e5a49c44b334fdc2f4e9b98fa234921d1844a515c14f4286664454df0716a0f17d758081a7996f1ed50a97890fcbd4d24db1b9f776380d7c6788157b14e97f7f0b3e305426b16a03554dfdce75d5247dac144c3db577acc2a37681e8d8cddd92257fcbba8396c8970d2176ae242c81d8ed495aaf8a5a8e91c9131283716d884852e6fb54ce4a2460e4bbed90b69369d09445b8c21aa03c95a13dd1bd547f52464cd6aae04aed44221cd97b57738b383936d5e0734a3222e1c00978f11374c16d59914336d839be5602288828bc988d05da48d05ae7b0211550a1111e8278afc933cdf7f9df5d7cc6b7804bc22b794810cb57ca9a458291701117323d4a76b8c9f4d4d2e2e05a94635295dcfa3e695b4b1f12bd1395d3aac93d3c07a51757cd7764e41ebebceb1111e27cf16ebf6c99dc6ccb46bfe28b1450399641ce269b639df31b30c3696b03a80c8f43715edbb166aa1c15a72dc100a6db0aae3c1443e5749334e447e858f6472d8aba5e983adfb38f4bf903837afeb885089033fd1a9ee5e90d4e79db7d69a463b74943314922ddcc8691b6d79d71fe7463607c4b46953fa62e4c90b58d894808022163b35640d737922a247c72a76d191cef60679415fb1530867aea75649bc44b57aa43ae79c6338f33b97d30069957f17bae6a0a8c0c85ba536934b10fed523efc924c28587ae0e1d28bd0b4c5eeabd46c651f0ad20aac6488bd7305c841629a7b0f1953059f0d00ec5fa1172966902c83aad079fcc4d7e9d2585abe17a33cd2bc1bee7b41813f60225101884b5e2f67723b035d964726cc0784d16756b281d8c08562f297ea95aab2e2e09f17ad772e6a3c7d90575818376084babd2654d51fbac86a7f4386f23e3a8f2c976024dc07d756f140929a59d17087a464dc09e97683c809246c1967efaab9af47c3fd3782f1ddbdb9cae38921b41f838a3549c362c9460f5d80d4100f7af283e67dc58386dd5c88fd0ecac8e42083b31387e592b2b431b87c6062a92e80de7a009db6fac6ce2b31fba42c3360421a338573068f0db743c9ed68642b5cd7c8fd2311782d6648b9aa907b8d5304a359211c2ae5a4ca803cbfacd610f7335ce97388b6d8877a11cdefd29bfc172fe954c4cc64c0043f23b395ca94b6686c18d8165394f7a705eaed71202d0a7f65dd0800e14069a52d2a55f521de553fa5d9170a7285d82d0658bcd1d87d1628330c93587a5a36de05639dd6045c418ef41295e19b616c19d521d1ac80a68b58d24b9ac8f9e141befa46b249bb3f564e21d66781474a80aa0979b28026c0da60d04e14b7b4d5110c22fcc06b51057d9af84c783981170dc940e4ae1b773c059471344aa22f6ea3920d938ff0b713701834923318bd0f362982859a679277439da23a95e9091d20ed4ba834146531e3717634452e91c28749d5918a266f6dcf1f0bc74e9b3b4f39c70486202b241afffaf04f3a33d629886a735565c1bf6c6e6104fb03343b54fab3df78b910adb786b53bf1bd0c8da3fbe09f077011824367c4d661d697136887c96accd39b652a072178abfd54b33ae6c99b29672ebeb90b03a3f7a9ff685d5438f8fd1b700b637d071abdd70db8b6f18768d25fb686c9312e8acfba8cfc5bcfe111dda29c6acc51eec5c5775ca678268a2e04c756fa7c2870a4a1642a98ba0d5be55759ea297db3c75bc9b33dec262ffe0fb9d192de3c392ff23a0a08d49a40cdbeb4847aa8ca983ac23bb709b89ca5bc5b606526d9eced3daf4e5381d1d58c7dbd56dfaa4b940688cb5e9c053909c012fba7da5109583a2881e6994996b9848c4c8251da67fdc02ca6a3be0ae67d9a4b3c827bf4f9320850a70e8e39ae2260b5024e790a1b617055262098381efcf745675df876e1078dea98a8f9bdc7ee425724b24689ab746b7113063ed180cfbdec9ccdd36bf834e3c31c241d8207bc8e30f30549a0fccf413a0dc7aac87f2d3b1b03755c39e9ac9ed3742a4b490ae335599e643670ad25674278cc26a643c26ea32cc29a78c3abdeb2460f7776f1c72fdcc74cef14aa7927ca563e50f9072c3b8874d09f967d6a4e79aa5d2b6eaa230706e566979a4023a8beea7022333fa3f5a1c81fb1b90f24ff75caba39857cec4473c86e08e5678eb05cfb2ce6f84d7a2b396c628f2102a23eb3753b231a9378f77560b4c680c46102e3a5ca13853f4bc9841da8cb3f9004abca285dd0c79d846e1698093d273ea75001f8e23c7a4dd38e26fe21c9258d01ecb009918690bd83d5dc2f2c9270aa5bf5ddca2613bec77e2ab4c558cfd3d3e9fb0517558b095ea1bd04e69093168de0d1791be0bbf86324fff10fcad0e05401f46fbc0b970cf7bed1d5efe77278914231926fdeaa0f8d456ad891e0adb06f2372c4cf35f82bafcdf555b93cefeb00d6ec808c63523e907545782c7737dd5c10290410d8b9347296cf6155f5444d91a37fe231ecb8ce8f1027a98803144689460784fadc052dabcb81f9e411dc1a40b62e8f2c353cbfd05da744aa4874dfee7a73fcdb49b21501a914e56ba02cef22928dd0e1c804e4f388cc6f22014073758d8cf6c0e49b9481bc70e09686577e7a91e99dd398f2ed4c6bf05d529f02fc63b6b990b5bfcc5997f584cd90a8bd506aee99fe902ea4d2ba6c3a47c0ba60aef2e812b9d8ef6c4fded2149ef3ad25243bf5f4f5d466ad46de4305b99d898f5d4b681bf577f8a2074fe833de1e62da17c9cf7ff72dbb299a1420880b7948034b3c7a0c234661b403ea810336897f9da58d0ef967166ce8299ed19ea69a3c779d081e6056b99206732885eaef8a91b29599146fa26a90cc37c0c0d009a673d0ed0249b268af2ec3d62490d5baf1430804080a44cc6be34b4b469b8de9f9a236f4b1cc627b205e4f9cda9b5ae4f4b8dc1cf6f39eebd6bd8de6acf5cc2958547d77aa5f9efef772ee25d92e1017f74e27fadfaa129e27bea1f4b21aa14674009e1f2e41468ed1c16a2b06309098f682b384696dfece6af1f5e35e548eac9e7f32f676da934ce2af606f308e7be94805aed4bc6828f9dd8fed5ee2fc753ec6fe553ed1528e671b9821b55b944d35d7199f8bbdab017ed20a0c637fe7782c9171824eff8e35d57daa3d907e2db7b4589d30bea193921967d66f89e4bb1a72b98ed8d71d3e397dccb7749dacc2c2a7e283c3533167a849b22e3c896ed739ca615b473b8cc4a6354e0741ef00e05762f079c57fae0f8587128bf1a69a543b166fbfe68c8e7c0b45cb4641b0709ff6453aaaacdc7ae43393e9fb33a6d239f1640f5e2d589b06478ef87a6d0deeb350020073eab69918e1ea897851bb800f3af302af243c00440f4d2d886c1f3ab27ca30b03b4457512442d3d0841c2ca638116b56a3f7df6b1b39a3895348c7a7a29ba95d1a0cba6d9c56bb77bd6f0ad59c9c055c81a392ce2708e1a823a782206d7db21e20ced3840612c49cd9ed40e6681b048f85bd696da8f0f21155749f60fd0b7c852c3f0483105626aaa896b239cca20e327403105020cfad75092bf3ea8251bbe5f906baf74d7d1cec2e68f208a82772a14b48c35959eba4bd0773066120d9f4579b953888f7030dfac8c6b4ad661af6877e4a9c7899a18efd8165c43c039eb8f1c9e48464e80a3a6c14dc666326dd17bbbbe77b2aabba8309f1a02407e33b7335545072023902e4a192da0c5f34694a0663c6c7133f1c51a1f7286fca1442d69b297abe2bd5193986d558cc7818a560d8fed02cb8c6f3aefcec5a76aea5fcbe76fb55185271e7e4b41900a67ffae757aafa6a07fb6df73ccd20a5d97d0a8b056ba5982d791ccf7c872686ff6d40d1dc1ecce1353923a6518f287578f1f5881af39695d2398822f472ab6689c6635d28f57ebbc8bef8d99382f9fed01da9be21d854109fdbfe6820de7f8034f6e8f4c2f1882015610998f68c58265685928822481510e55ea84ab26d49668004f1c56fc5bddbcb069afa227c89d6e127404d329694542bc5d334bded3b258553ab20ea0d48b81bc86cc6b1bc2886b50b9559eda1aacd1f17fe70894d9b52391e7a6a3c777a67ab5e7f0015e711286e607375902da90ac432597157995cadebbc1b370a079ff7febcc74289abbe4bff7fc7a6f29c00e6700aef8ceaf063d004d002818795b1a0b9ec4844c8dd5907310fe7035f1edf10bfa7a0cd455eea2105df26c18697d2d2e8c824d025c5bd7f306033b97a513d66112681c479d51bbb866cc1288a24a6eb2181708e6135c523400ce8336a736858c0f46878103c76f867dd55f57bbd00312c87b57b2ffbfa5583fb9e6fd1d8e35459e11dc9b6c1bd63dbd30f88146e22475fe0d3c4bd52466071b3bf4c9b8e31da0e1ed1e86d95361e04fd0fc4558f03f7cb330be2ae9021f7fbef9a97829fa2b5006c3ed7ab5c98f5e0c322e3a105e9bdd3f2b7a49ed3b49ff168dca6e721043a4526de6277a3f70c1c346b33154a6f5b63159182f044d3a5b013c6ab5ee5a34bc0b5b8ce5584dc6ae107337d4112b9c35440da393990d78560d2bcfa4b2279b9cadc2e95be8f66371056e541837a3909b20a38a941a66493c43671935a6874b91367616c1df27ac8a699fb0259383d75e983e5d9e572fdeb038cb8001479ca8f6ea4256ca5a80f0ab00dec2382440eaf9952f82e31f5e0b8e917f8cf43c87c2f22e53c5868e9ee6d52b833a2f0a29e5c2209b52e1338c57908e7613c2615a40dcd427dd71a0bdb54170c01b602e3be3af8bd7a4445ee984dd30b217217b7452d18d60883e1e55065b353b0c879700cf9974b0d8c7f9f05b86c5a4f52e58ae395e986a7cc4b12d7c5c40757c6f02d87a7438a84fa1b86b8eec86228507dba21c84891dd09c7e5d2b7d3bd7a8514d4d722e95001c4dbdc7efadd12d94690c9e57940a53db6e3fe56c5344fa06bbb95d58be7b772605f152e8877f33423ce4ce995083ff94c68433461122d41fbb45e306e351465bd30aba6239e4ffc7ebca80838bb82a7d31b79875f951b06a37a46fec367cf3b97de3bbd3396bda2831183550e2664558d72ca7470e55d046c401abab78840f9cb77ef9183f10a617901c62fe6da98a490ca045499505835f23b3d18739105e7461b0cff73545fd8f072930a7e661bf1c3040e9e66e1005675063696aa5d8c7dcf9d457c494b408c2412b37a31d046da169abe703d52294d72d4e725474d9d1b1bcd86ee4685a7de0603b9796d9b43d09bc655fbcf4dec26fb314e7aa3c76ac625670f894371127c009858f9d1033500078618d487254354526bbdb08f8f4b25cd06eced71006216b9268f359b143cbb280f492291522413b69a228457f1793e8981cd3f3218c7e07a6b7160afafb878576a5030f1ea8a799d13ba6a10c09f455e850517e1d49dac3c94fdce2172d2d72584e4523ebbde95536c5131e2f6c26d6f261347350ea512e3977e8a399f733c014c69f9fce80fd5f109c0efbdc1d470eb7ab9c9f23a9c50b56f0d829a4b664c1ae6c7a28235c3e630fae6ba117d2fbe8328a039d5ed620dc7d1757dc7dca441585e1b10134655f657dc113024ed025017bcb3b36ef2c9245ca6bfe4427ad07abba6855995f7c0e91d8ab39b75ded82a5e49f8e7b813238904f0acaee616e8ddebb631410ecd7d0dbd6b8a814103f66816c321ed0ce5cf16f7b5a9a8d7003775386f0d476ef605ff9e1f4d55dabea4bbcf54b0bd71da36964c3183e804d00a3b9d4acd57a385ff4625d8c065ac4ffb6ad31b0a394dc52edc727ed65eab7a1d9797409a5816125dfd44e4f7374129317f0e8197aab12e32e8c15e5d9d7ec549fb6c80f12ebc362391a3e20a0896919dd5e76c4b0cecc8dbfa19fef9e9f2216129371ec48cf67ba476fcaa8e5ff213b6cade71af4923c73b91969c198e60aa211e4d49ff9110a7466fbcc3be4df6206043a24c8a51e89b5dab067f247b230d65a043116f1a55f434e3eb1f0207770c6701e6a5c9dc485cb2ff46fe932769705198ea6f2b7af76942fadcd219436142ef66b190a66f4f572ef22b5440d8cc7c5be3960a37f15f9c45b38bb103abc591a8975489a886523c060844a81caf185d3576f192bcb30cea3257321d3e965dee495e987e964d9030f596c879168d60ab98c2a4c132f4dd334623db81e9821aa612cfe7f6865e131d03efbe2ea885f3a2089b37d98a5fba0b32f1ef65e77a7a9d6eb439cadb90d545fbf9870cc8a14cd413cd4352151d64f43b1df3530187584500115d6cbf56079ed16a80f97364c0d284e6c6b4d4a153ba337fe8cb36ab61938e3048f0f9b20f304a3028891b0a141094d4945934c7e29674554d712a69f1b1bc75cbff0dd25ab7406f3c6a0c7bd9af49e5c60be189efd7c932cb3d19398fd0aeb98a63fc70e06dfbe5d095bab12a852b425909f013d1e08c1de48d10718142b5808273ebfb4a0db2de996b5a99f3eac34b4c5f7bd954039d789fbe93d5575e2e010098ff0256aa93ca1132fab8c869c595cb2502cf20ea7dd46ec920f8391faeae38b67e130f04f3d9e001bda053487de45c053ce2a816853189eb84c431f93cadcf088ddbad2df8f1cd9d906b90188446f04defc15794f004460cf7c179f186dcb24378ca316db7e37b720e071f56af4d4327e0eaef7259cac6aabe45992f8fd2e077d86f23c3be3a31c145138376e2cf501ae34727dbac2398f166e9bf94bc79f740182748c205f0661140da34412e4ef551ff7f859b20f191be125f05fd5a455460c59d627a1db551794cbb146d30a967dda9518793eb37f0a9c2e8979cdd8f71fd84e07a70df0d0a9c4eb8a31451ece8bfde31ad4abab0d709e94e98ba412e52b989ee5ec1f073a25f09328fa1903b4c12b780504b45f321e03719eb4533b4301646fdb76211bc4cd0059863e1f574bbae1257aabb0a19e6b0870d48b8b7085934bc53283d94ff893ca1f06e24009477d1a2c1acb642492ccbad6e21ca3c55604d78b8a960d0cf490b1ea98e803f3b0c9afc24f077d4abb84c1a5224705aab8642388f9e6674a3568fcad5e9462df8645b5f6c0f4badb50dc32e9cbecdef8831afec29599459c0d6e38da246b4e64a3f6f0a741dd3422419d83166cea297b176f84a77bee7ec353921c8155c099e5d9b8d0d74477caf2a46d28bbf7354a255b290e3c7e9e5fd7135c3b6912f76ef8d869a23915a4210701715e8015c8d49f0dbbd3d7885fdef0c0cdb23ad341fef05ada816345f83c069cce9e8525f13d91a2b4400f85b6bd8d08f9d3414668ad67b3b050e7b1b48bd5c826f56ab4d9598ade4295c526982fc1156466c6911dc6396cfb4e843146c892fe6d8567e6351ada7cc60ac2ba1b05b44fa9483ee3ffc0a0e3adbcce732f23ddd36cbdbb801d8342f5173b2535674b673fb02143e283180c2dc02a9f5adec078205c48dcf2c724cfcc0a9f1e10848cb979c6b167514b27d2eba550fd7b0554442cf99f6338658057ebc940998c55780c06904ef56853139d8b6d247d16adb9abf1c469fc140017863e2ef49bc97919372a89d0bb962ba3f469dd89c1a11ad403b19801e32e5d4bbde9c413372913aa1c6fffb73a4eb283151610ed617e7aa66c2bdc61e001446194787ecff367ec99a55a11296ce0af61ca0fbf3aa9a478808379a5ef4c9c674102bbd7c8e2457cf5d5159559d7fae874e5fc068aab86a3df10a049c823604378517f6aa5405b76afa0cf2710c2ef046dcfd835c36bbf8db8edca4be554a81d3c98b77725e9c63564d3d8c84fe8768347d4fc383e8d6af16eb6da5e755078b6b17ddcd34d8e913e114fd9a1cef15bdabfc389e4a3f2425f54232a8700909675c7c0bca8542111bd10d6b838dc1610cbd8cf83e62cfa2e89bf508298ac9e385235422e12154a4b3bb300b23715d4c9a6d30c29fb116531b768dab80ce6d1e6b68db195bd9c5723c4c22d22ed3433e5c0ff546050a38990f5b8500bf04e468f51add54b1df7a6f9e7a83515b16fd5c87de55cd22f7e9e06612378c042644beefc21415d966bf49e6643e8142b9dd94f73a51c07fc9c178ef80af21ba618b3f195e85cf2a0085298a96be6c3321e86d6364eb2dbedd9b53722fb4a548ecd333279a0fa6f23daebf7aadc85015fc0fe8238aebc6184429792121484fbaa1c039a078bf928a2f1143a6b4a1abbb5190cecabfaa7a25d922cb0d5f1a5ff5d95e974409350f8f0beb8a84611b3da4db3a96941c3dc2ebe30defb1ea116573605000e9a834fc7e20d0cbc1027be2956b3e470a33a5d2c64f539a52183929a9944b49e576ac9c30cf366b2d7dc47917222b7c722219772e90a48a8420687a78f53dc9edd66380a5a1da3b0afc316b29dd820327d17983811236f98ef28077eba2b55d5cf737cdd8a126d35a5f619a04ebc5a4c2dade0698aef8ae245ba377315152eb825f9778d6e2a85b358a65cc5b6b790e10c8f9d3b618e8d2e0077c87ceeef392e49678bce62774b6f202929d5d308fbe7350a3fba795face8512a56e24405e12bb3058e532764af3293745fa7cfe3e7834bd129067b3a69e389eedd2829313e3d6f5dd6c6c1168f221cf5e126f139d2e9e5e5a35e68f290cd50a90e60ddb1b9c2ccd48cf040ab3310acafc4b43a272adb02ddd2c572d8717d8daa07cbbcb11ad2a110003f6af0b78aaafcba342b6037ec99c5ee6be61334e85d7a53202707a250e8a51751af398c0bed131de73eba04b09cd9a4159eda63038b7c5317cac0bc40985d5b8e7155fa5457eeb8ac649d2b3edfbb965eb52b0dc87d3e42d8881790b75a5f0b23b6f58d7149c9b16e987be3deed42da499bb65f706f6fd4c6009b19cc7c6704945f12f078c621354564c6ecc77d62596ded490c3ce618b1dccba70ddb6324c1cbf393a48916780cd9094fd7eb438ff94fff915c1974c269ce0790fe0fb104e7f53d38ecdfdcd9ddaa4fd11fc0b0abc1e1a5415e49a684d2b7883e8a2b7e81222d98d5ebcc065fcb4ff6857d2e60c713f3cb23daa87525dd129b041d8d3a282f246e2a6dec2dc6b7094f5e8bb801c64a68bd0ba0efff9177858f365ac74f7079df9bc154910c7c2b2189a3abcf3b9662b669e1bf6a724583bf1015ee21a3527e91735948e7083ae1e76d669d6ad34f438d8af477e6539a262a652368eb9047557f721e58e8eca7cf1e4c8cea40cbdcfed6de21c8e70806a6b949fcdbb3377e64155f3a8f20ba32e6fd26c666942ec7730e3054d916771883400a2cadf65a1431dddc082b36ad5e12299a3e8e4597f674d283f68e4c937b73153d52229edd02d5a9dceee8632cbef175b79cb272c6344ac6dd13f57b43656c9a1045fb9d9048a5e6d7c962bbcb115eb587ff347e48d3975b7826a9f50a217d1f6cf91f0dc08f5b03b52bec59d81623de2de89556eae36cf2d43540d9e1d649728b208aa23d997bbd17da37d7f365a4acbcd7a3068a2edcbb9bfa963f213558c27362176ab3b3eb6a4808e8e9bd8b45af5062a9cc720b93e5a07f0349912976d584fb528a974333f896a880c1a7a3701a288854637c8fe208bb46fecda38d3e1b9c496a1ba721595f0997f2d71f8763c92a7c8a69fa29c6e47c42af77ba1ecffaa897c2c347fca93ecd60a525be4e55af29b57744913084c5a416a3c84ef9ac85af2fe38c3198a90af0c4656594d6a670bf8328ec2c924df4b4e68a0d83683cb326bcce0459525e35597007a9c5a3de6de48969fd91fb38edc0f0624ef8bfeadddee547c08c666d910fb465f5a949cf0c291a7c8d45c8a02e74b79f5042132cced87ca4f02f00892c04410e941f744d5095c7fc9988717585193f2fb804711e81639dc078a5f1a86fe17e421f21da7dddd3d9089cc90324856d2ae4beae9bab5093bb4d296d76919781d5fbaf0dde86064f8642a1cda7e3f550ac5cfa0a2301456bf7ecfe1aa6b202609da8e1f921788e8c2ed9cb55cd460bc66eb5d83e9114ee5e79525b4bfdaa88e92f8a7ac74975811dd6ad342c724e153eaf4ada8ed1de93acaf483f5c44c121b2af90dfa3a7837b123a985b15910d7045636746a7bc5ccd5533aa71eaeee435060ddc0afd3ecc26e1b67b560d5fddc57006bcbddb86c47227b7b4457d6b6e4455eeef62a3d78a4af7749d0b099d5bc7e68fc41aa155d079528f4378dc901214c2ba36610669609f1d4aac617714d36fcc2767442b3c4712f42e6f726fdcd83e55c7fccc1e48e60c6b1e6bdb749f20413cd3131dea7e49cda7fba64bc70b47d8730ef3d6a12cda1b7e2068603d3c59024035d466a8ea9db09007e0e578680e19e7202d9caddac3bd2ef2fd8589833c9e5f6b7c61235ceb003f726c1d428016f2c69fc16f9b9396d845869181f96cfbb84482e96adf4aa635b83c611565cc5449ac43ac95a3618ddda3f1872dd3cbdb648bc411d73e7b1f20d878c8345f3ee4443d71bf24e60a35d3c93c8507fa5c4055eeb0656026250db17f816b59ed17e16951d2c80d3354f1987af482223b2ea100e2403961d4e2858e53b79fddca036cb69aa6f34d9fa672863e9792dbfe6b531d5a1b29ab67470d03eca520d5293bed8bf48dbf7cb8e25e7f2530d48583b506a385fa009b8e2909db74a81c5399de86371d5d427c90f8d5b8085c7d7b54da91656c951930156a6297d9af6b764dac81b0000f02261f11dcce17bcdb93eb9eed82a222cadf54c4f57c64f7fdabeb4c7261c5ef977f24cf97e3b2550ff89bd67ce2b4be804a4a894b17754231b6a922e759760606e3bdfeb23d8f30f00a961d30462d2300a906f7d87ca017c83a02d5242dc7674249a222fa51a04218ccc37c331f27a64617c0d10bfeba11ff143870cd3d5c4d1769e80f8fed804472dac90185aefb48c4eb8c506dbc35b7a0ef2cf4504ae944afe4165ecdef4acc2caddfd14f9612cd7dcaf20fd9b7daf61938c91db311c2bc6549d3f752090e15c25cce6a628c7097f765618fbf1f9025ad948f603b573cdd9aae71126a060ecb5a9be18dad5e737776c254b229ef774ca59ed6283033dc0c5bdfd451e34fd3d84eb3a3e65d06935a77e126179f543b18518db1259cfe3c12aa39fa640fda19c39987bb603f48ace859bd2de696b5b1d7d9fb0b49a6e29d1e788b712757d9675adfbbad684171fcf0fda052ad80fdf63523dba1dc318177d380b21069f16e1db9f56fab09dec5dbe0712a91f689a5ca54710230a5c6e035d55c148ef6bb233bdcce7f0885d3c8d9a0e215fbbcf372d4b1ff00b552bc373182fd8dafd6bc94927c9fc3ce8010d7f967902a604405554075edbf91f885e5dacc7c066938f2f3bdf6cfb22e4dc0338c763ec99c5f5ca1c8e60072eeebf641b40cf7ffec6d09d97b92a65fff5bd21d0fa242274f211b72635b23ff6be1b7e824b7fedb2cf27a06fa0f3a851556900487f395f5177777250f776105d6469b95e2a317c32c887d78bf3b35212eee3fd488d40cb2dd7ac39569411720d6d16d61a13ed272907ff8d938426ae5dca750f8aca688256a7527048ec7cacfdcc446df80d5d373b0c5b257b82a2880f4a2ff57429802f9af23019e1ece3bbeea82a60fcb6616f24ec2308e805eb453499c146523e8b743ebb2c506e74c91ffa834c046c8bea497ac0baf00c1b554b3b236fbd099f82694c742f49f917e16973e6ce1bdc0615e6ec9ab5d75015092922b7134a27831648e333034ecb797b452fe0e1d6535726ccedd6cf1477fd8922c36a5fe418e1eb867fde7e143ebf94f817c98889c5c58f17e526530f3d22df8eb4810784e3698fa1c1fca400221775502e6b22425f18fa798035c018e44682d9529da52c913c92d273fa47573234741ab881b220f675176dc7fb41c2ac502b5d473b8e314924e3d8f3471e81a6ae86543f5ce05a3cdbe8913d9f9633b2ede5ccdddd9f4bc3e46d93dee15b10e771e31c74c218945dc0aa9bb77714b510f9f3b37262a6b0b33db9f9fcc068e1c5b408bf140bcf8255b5d311ba8ce4109062d4ca1ca6867c1ba38aac52e69839bab2544d506ac915c906c43d5549dd6b732fdaf37403e19d9fd6a4bda9f7ea820ffeca4f6111966a1fd42af82a34b4e5d2c76f66da07edeef6b3826e4cd337ca6b3e846e3ddedaaa97607e346a11ec4f64141a140060a4d2bde2cc230041373be5e92db623d2b5b58d4d78021f640a8419d72f2cab57408f0d76a62d87584e295b99a84dd42de502fc991cd7ed58e46c86ef87e2bd41ac25962849e420d4be04c05963edba19d3599cfcfd5f8109b6c32d32b1d4ffa55193e3778c48992c46fc2779104ed550b949c2230e5d788cda01e36f701f30131c34344f9f071d40b3e2b101072a5095d43176b492de909737a03cc137e916a2964a7a01654b47db248eb2776618cc0d938e073988ee1db67b1bc8668cc75b2da44f783ae92857ca3c9c1ba0c59659333dc99eedd1e5b92615c67a03c0690b4a128ce66f8c4bd34e59de1d790398a627a0b6daf9492634c16b3212a2f0b1d9005decc408c647c5a6c6ba90d8adfdc7ef44b02b58e45769bd63f9bdc1a3112294c1c8e9cfef1ba4918bb88ffe9731f642c0a630ee9e65793f2ec49678605c3b41adc598f2772713dfb691a9a258a13a64f067e2a2b669c5f23fee71b60fe4ee39783dabc94e4da7b1ec7fcf196840d62b0b15dbebdebc007be5849fc38a81b0c551fe347eebbd003da253e609d0aaba588154ebfc68932fccfeb4e219c0a3a9b25411837dd44f82e9b768ba0f4f56bf93eeaee9532229797fec2194af5a65e294b8061c6bb5b1fc56e9a2dbd847877efc247b419e975987a97c594c9a3cc89075c9dc859ced363593a166abda17ee541eda8ed208bc9259ff4095c6e8af39461da1377d78586dc4fc1d57eccef58508431bb4911d84c80138c5baab62c1a75e8191eb8c9cc073358228154188c01a07e469bacc2f20724e22085a86c20c43a2da35ef5f5a8b54838101c5f975f7b6641d6c6c37c824e8a54e665608243aafd1798631664772f5a844ad04ed2b10358381d4e92f27216f45eb651fc4438b5707d891ac943fb9df74bbc3221b719f75ba58d16d3d66f36f105030d50adb0a4a0f5a4f8b8b09b3cfff24438abebd5533e97183e216016f0df281eadd63e3adcae4dff233b1c05baeb15783f58de6abed9dbe51e7b720305f1d71667f4a8646dabedc6918374b43093a56f677c5aee09894bbd7c5edf911ec62bf63084ad450c3a268f062ca92f3c2d6250211c8ca0e41084e572f37a2cba5b5c731c5b67c0a6e19fa820e69f9137c9f3fdd39fda93586647b239349fb987f8f4fd7b9d161fc237258bfc4fc208415a82568c6a99a6c333974b8567e7fb8bbe874fbd269433a91d9b9a0328c3c33f96a375100e79fd99e8a077c964ec932f50498a9a4eb987546cc188872376c7a6bd7cc8399fda7683d0e3cb17aa6af3553dfa6cb34bdcf291405f7cefdae74fb7eb4b583d0db1d272c194dd34d5e5961c99e083f1da17a1bea007a6924363a948a73dac081790d5e31a32da5c34151d4928f8b23f999373cde83a7ceb47564ba7cf7388f3861aec5cb4817bf259ef4d4819709a35fece118cf5c14e420ff3c7da9ba6042667cbc7c8e1ad8b15f8573119cc8fcfcd627b56fd0ace598e87183cb1466cea58f8ced1fc89ebdc6bc70e6b77af9f9760c267aedfa45a040d4c3081dd063f9dd105cf0025412ad0bb574a5f2fb2aed01e2a795dc2c20246d86931f390c9958b749c6865159ecba23555ecef7009792d400adf461469ce10493156ecfe8a1b118f6b5aeaa16cb0afdeb568ee4536a52f31d9d18e795e3dd78b1760a2062002f9ed6cbfebc93441ca1443efacfa533caf49ed2a2d29a7576bb6e147d743d40e00ac0664356a49c4227c251e9d262e1da47c329cbdd358700e9c9cedff0e2bdac37e9e91547522fc38e5986d7d13da8500abaf93fa4c243b36a6dc6c4541d290c5bdeb5654b2f9b1b8e79eab692000048fd6835dfbed421d91e706542e61d645c64333e16974dd62b266532d8b208351b1ab9d2b3199afeca85740e5994f893646683602eee96dbc67fbe68f1d50615b833afffa296a99b6b8e927336fa9fb01750abc810b906aba4ad670bc220456454c42087b32a50e4d5c8a5343b4294a1d4fac05f40510beac2b5e1db74b8ce01895692011d7a93d32efaa09fa6fa9a8a7d126baef22c2f154d30427004bc9e2060dedd7fdd303d45c144a0b3b360b866362da6116064241cd0faed9f8757ac663609b6640914e9f2ef8994c6840a94fe9256ef79ad963205b7905156d992214dab464b56d9864fe1f2a69091713994f7229507c23ec8553369fdb4059fd65f24ba3d1fa8e8cd3da0c7b27d4f4b51294bba4afdc97af46101b609349b79edecdb5a04c0bde27a7231cf5dd6921ad65122ac37e067fe0c7d4c98e9a176ad20c412dc4cc5d187e8200370e0d95ff413b91c3622b82b91e6ccc587a45518800bd0ce01495cdbe65aee8f8f927df3122285b3f2dd35cedc1e457177432b8d4df462e35552fde81de509fd6f49c65899194a9f9e563d79b132759b51511f6a9e2e74eeabe38d433d0e2d8fcf04ca18b5c8b74294a785e660c88584bed1c1d6665f985f59200f231e85082445e455f0cf84a8bb6c9de87c6552f6cdaa7f8517e4e965785a9d425a4463310d49767c45eb5df3e4963acea24430638f5f7b9e1b70dc762e5deef87ee506ed1f9bfca8f4715083688c5f3a86c9a3cf79ec29cdbd02db834188521cd247633b699c8c30a6be5eee6acce76efa7189ba6f1713e73a943db937c5979dd986c650c1544caa46722d3e22dc60f7ef2687a05c92e5edba49c78d9f9ff191c37dfd794e1a3a3afc6dc8c9cf6b1be0e1db3e84825772cd1dc3de0c1c2db6949d3df0ddc14d5af4cc612fc8898ef9c55eea026c6076b1d26b5ac2b5dd8f11ed69188fb3b72d1ed9b07cc47ca1739b32f6f6cbfe6ab015519ddf3be7d00d4a778a65d3da033622358a967e9aa8cf9a7bfa5ba68280867f86c6b740486e83cef7500552abecca18af62f390abf543676460061ef41dd32198a0ef50a9ea0a4c8a921fdbe109ba6bd680d305e16382422619a800f4dd10277f0b967ebd985c1d1bcbc9ceeb97ea7fb375be9d686c98cbcf3a3a385b1cabb3f1b88dab85c5c8b36984ed09334a4027f249a18abd2e563e089b05e264e13ff721b770ef611520014c31940d16518a1a4641a1db6a5374452d9bcbf8e7b37bcd9fbe8b2b5ce084611443ef75f5a922f3890e0b1546c8563f60b4d759744e0127079406132cebdb8b04153b48b8fd68224f7c07f55fcf9b0f486bcd2286554153b8fd294e7b9003b8fed89edc29a270fdb97657fb50c137d6b9c8008a5c09ed6920638f9e614fb374dd31b217e8a037d53149385d5c8f152174766c51f35450fe107b437116423156b2ba17e4e6a005450de7026746cc438e2afca6f99656ee49a4659bbf566edc00310a8bf1bfc2951bb68de1bbd9da85d357f19be73d11bcc9f0a9b7b68ab633297ba749a04ce5e214cd3313ab1e2a4730cf5e463918f4d0bf3e2d6a60664a1384e37a44a3eeee9076513e31358d337c2345b97b52592e7d7ae0d33ee07767069443c4d666b799fcf8a8f0387e26d5de1b724b4bfb3999cdba2a55e08c49ea4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
