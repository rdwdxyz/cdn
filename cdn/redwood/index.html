<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"706ef6f75a01f80dc15e70ccf3d0fc55c9d35818685eeac6f556764ffad32e3bec87b9aeeffe59126f2acbf00fdaa8f17fd4a5ebb4a93a27e809b433bc42cc765b997bfc10ea5dbf1ddce4ea1bb89c8cd8e8a9306752968e90f05a8b0212dc9074bb92baf2c0f0d08515363d5b0759af743adc5a09ea7ecfca83674554905bcfd16785842e4d4f451e620f715b9d57ed4b5c0ac871841c35171388966b97a1fb6630f7eef7d86fab820ac00916cb06c3587478ff594926cf9574e1321d36573baa297fe276a9079155946af2e036352f06c08e878a7c191b0d7ec12c40f129f3c41ea7b0e86dcdddbd2931ac8ee211ef13b61ee60f62e79e0525aaaa6af90e738f771e0eb944a8ad63d1e9ab265f06508dab76adabd5f02f52f6185f5422413f7ea675dbf5b33e67f7abd74fa14e4b877ceb321caba9ca9a829f98e0d40361d9583e7fe28e99e1dd7cd889846a562f7a799f3662ed6b18cd8d4275a9509dd9dc8a1dfc441827420c3f6225adc140abd5edc2899a85a07dc540ca2f4e98fbb43e83ad65d94307869ea5a797f4344d9f2225ab375dfe121883db0dd4ed583e21a40065457103830d97ae3fdd9854207071d94936d4991f9761a5f184a9c22065f6e0f2879f799bc2b58ecdbc43e87af4968dd45b09281087ee8e7868fbe0bb62d5f6a1f0fcc19a3d467641aee85a258143b763cbb923329719b4f896bc41a097d476a72d5dc9e51f8d251c83221fe7d47d3d12978b6f37d28a4671b7ea8beff22852d2f28e915183c3b137540e1493bcd4873f8cf654f4921fe4bd96dc45141e2ee289feed25c1bb28a55daddb54a4cd712f133375c68fdaaf7fe31e0e568345b53194230df7b1e21add77ba85575eb04c76f60de22ceb87a896f8ceda25f7d97c396f21c6c9fbd7283dfa460fa261e904a85e0d1b1b31f5d4baa9ece6f17cc2eb1aeef0cdbf305272ac7caf75469c012ce83a19b9c6e5ac092b956b006c80925638b8e7b8ffbc92dd646014da359ad32bf21065a3417819c2d0a24348577b4b193ba39f3ee169e372fcc6436129ba40102d76358043abeb2a71c7f99a210a26097f72ad6240327eddd8748242c5204a576a144d6deb0231fedd1c3efa70275c91b63128acbe746b25ab64783b459b168a58df1fff0748f6a4b4b570bbafa05bc2f3aa2e131a70581584c3bc9e0c546ad1d624f09cf6185288af85fc2ce3412ea5963e365b385515770e044a6570d9ecf68ddf87b2243b2445ad9b944f97c07159bcda2f162323180b6ba1114a7f1adfea39bea072427638d60d232be543c63945cca3c76095ea6baad81d7831226ac9c3c17e86fec4fecd10c36f8ac93c9e60f9116fb8559cecfc9157d523f75b722ef25951c49309998b4b9258656f6f3c2d950bf12777e6026bbb6e321cdd163278f77f0a86083df8b70a97081854982ff185d382a32a22f293c4cf38ab45e714fe5d16d9a678ec4688ee250314b426672a342c2ac426a364d5d12464f368c301a0ac1d76989b881069eae7a6bf0e395dc9176fe65df93779ec6b042f77f7e47fe38585273955674aa39b908f8a93289d4d1c3fa3ff3daa98e22870f9ce4da16b887d75491c532c7f1bbdee7d82ae57bb335f5f340e7bd63e17da44bea31cf570d50e9fc90c89ec624cc594bdb2c2f5cdf6528ddb53a599aa6b0fe7750259c5efe46b0a2feb2a2b9fab78f65bfc633a7005736dc704454c360ae735d77a99f70cf753c4bc1ea6cd4c7bf5449f7f4d5f2556b01b3f6e7091dc29a26252e2a72af57a77d78a4d2bcec2c49ab5622a3115641a83af4a180095f039b5eb125633f74f6ff7678eec0853ce6c79dca21ae61b694aec9752f82f160f89807d25b378fadece246436349be01017854a166d3a5228ed59fdd7e9c005f1f60e55aa56c59f2efbee39a2d9162062f7bc116e91a4d56cb98e176c189110323bbdd072920d801f5cb9db7dafce92985723588b7eb005ffa2739ccbc5679c401397ee0a0ebef03ec762aa8936e0faefec1c90bc23831e784fe5e31d4c47b79b1a6652242f3229d75863007c4675007275b77f51f0a9b9de6219d3e1751d3d49f59815dd8973dbdec41deb5e46faae7855332b40114d92e1d17be2fd2e9eac6d50778a4433c7dc2f949332b48e088747a05d9ab8731242f6da753a69375b9c22ce26ee0695ff4e4652974a950b1706c930819a83429a8f8341558376c375ba9a002e3a0469a1e2b1d241fa1a9c85b09f4fb78c50ac3f6f3c9a4541bf22d8cd4ec4fb50aa2a44ab623a2e111f5bfb1197f592175773f9bd46988fb875f8d17f7883ec45a7c696e925ee1ce49f1e3e1ff4d4bb42e44200b39eb9afcfc202c69b3bd11970db4363b433bdab55abe46636ee4f51f85ab2b7a0ea42c448acac008b23fa33d7586be6c4d06357f38a5a95b7320d384d8ec41ca521416c5a95920453439c683b279729f7175eb1d7d340062cc208fb67b0ee3387a6b0d4c45b46ffafd853e4ea70aa997c579fc6d0af801d6e278be0252c31ffde62f976419f733bf418aa7caa6f30ec08361a7dbca695e58b5c1a5ad2ec61a7649f389146819765aabd30ee18ef1db354bcf6e31ff54487a32169bb74ef178a6b864c3e80b4450b22ad53931a89335e0d94410b7c8ed0d8c2da819924bee92e924520ea601b170b92e137ab6428f967803afd6d931dbf641709e3a174c8f4ac64283858810a60bdd30276304fbbfc1ce0bdec2cc5e71a250abc46df132bb0cc0d2b89744a7214489326f25023107f5f9360fdec3f882e9c005fcdcb381a6cbc6fbba7d4c0986b00484c36e1ddb18f5b8e060f78e306cc6e247aea901c79cf8573dcfa390f3c9ae8f041a86cc63816dee3d64a63eb14dcb58c08ee6f767a80caa1ffa43bd063f527c1c3d4a80c60c3d902d7fcef478c225ce3a64eb77b3a04e9380318c378beda9b2a526b1ebd0f5ee03df5258ca0236e08177148257d09d87a8e74cdefe8c9c8104bdf6ac9428285830c84003e04bb9452d36cff3ba9e03766e217d4ca7162b6238a934b1aeef10a678fe92264e6ee2cb4be39a27b693b3628e9cea213a154763865d63c55a6ace132924ee5aecfe511dd7ac50f9313d36e19ab2cbb7c9873f6a77404dbda33387d55a128a688a6831c607d25f90202a1818649e869e869fb694d79268226ae5bdf3e9a3b630bb0cd74590f70b26c094feec9700243d1e2ed845cb490f3285f64a8329080390dae105c32bd217eda12d78aa94e31d79787fbb75f12094e55a97acc229b17758288e33beeb27d747769fea298c6aa4dc12d33207dc643d47d503a35e69be1c32b37538f76677fe0c4a66da349295f24bd972530121818c99e2a688262984ec4e54b3923ba65aa57dce9752480f05c3e24043ba3766db3cfcc1e4bb07907c658c16135f2fa2acd5e671b04c37cb2093bee89e854757bbfa59629f2cca02dd7b5c9de4837ff5c9e48a34ca4ec5a6dc1c88b88510c97deade00c81d16fac1339050b4222238dc8fbfd184f6bc92c4345e7475d1bd66aad73fa8fde3e66d09e33cbf9f665c6c133f70a985f35b2d98bc0d043861b3409b3b59007566fd9d0161bb6ef50b251c219f4c35a39c966025e84b648d8565de240a5eeceaa902bd2cb949c5e225670295b7922d7efce0072d6cc0c29457efdab9642392bd7d1a8c7381b7e17703e48e2507249ff36f6bf002e5332880992dc18c7410e06ee0651960dc0354b6a9ebefb988a3af0b2675d28520e529faf1b6f20f253291637aa4934767b04f5a2c1fe1c658c65c29f4667bbf242789c1ba244a50ed44fb3148ce25a039e9b3f4660aeddabd0266a82ce047fb67ead74a68d8b23e200c5eb62db65bfa1daf15e24574628eea7d456f1f7a35511a3c50bb9346b658c835be15d18fa3f7105e9030cc2ef2ac6fc5130cb0c8cf3e9b7f4f375e7b2dc7ba68afa355de3c4596817fe386164f773ee7b77d20c8e4e08d47c43b937738e22bf75082960769dbfb679aec545c9109c76f382b14b8f39f49f34b3589edfde77a1dab4bb9fed12870d9d5e2c45a26793d80edb830d045ffbfb3b0e4ea966d900970eafe65b3bf9e22afda6845ebe119c291b19f565caee81e709c78d4afc5d32c44a107b519c3f60b1907b44a74e822aa43ceb9a9b13ffd6a705fc4e4b1b602009a0db8a195226181fcdf680d1b8b2f65767eba20e8830757629d6304866b39c1acce8f1a32d6e9c44f49cd99bffc6a0875c82eb99f6e2ca379dc6ab48b7bb3e04df75c2406011a7b644e789393ff99fc29deb85ef850fb8080af265c6d2e9e2d8226d6ff9ace70c802b703388e05dad4790758f3618e6043226f160ca5b90ca03d3fd72c5cc99abcc09ea6bb38d87846f76617a358b3bcb930ac2d618a4c49dc5b380f89316ba2b691ef85f88e1c74c6fe1d9dc8e159e64ef704fbaaef2e7b63053ad0bebf3a460e3bc071f17a7027a0de502d7c40f036d079b5f591697c0b334618754aef217c20cbfa2906b1c46b181528224a4b9ef9ab30070de24a3dd98fd944ff15f9633582c77355028dc9580411a1d05994eaa0203fe7437fb8a5cd806ffe3b1d63b2294c2d394441aa4ce3354bfc3276bec066f95ac83c8811aa66c6378d6a4e29757a223b9e13b4ceb32f4ecf62dfc6711336ff01b8c3511b560e631cede0671b3748e3e0a1768636760e048db479af89c2afb6f85128f540f392ff49cd4720fddc2b9f0f17a1345795c88e553a51f410937805cea6e25f972476fd30809ff644c78831198dcfbd1911b7730de36f300533c3d1edacdb0b5b38e27ed5379f2ba7ce421795fc4c67677b4b4631d1719389358850a642003edaa0b537d3d8c81c29bce795e6ade12d444fc2a34587b8bd1b11981bd60302fc119558b73ea0408f88783d4cf90fc686158f83249115ad284f7913872b7634cd708c827175269a5e1c9cc1b341fd5aa6ee3e6b99c94a71b9426d1b0a3914263df19542dc00a45102f312b0277970555ef6008a1a7adf9df62b94722aa1ffe6ccfe86b1b20cd2fb5641c64693ea2ba32573258592fe133b0052eaca67ad0064d254c141e12fdac3328078dec8e6aa0121b6b7c9a943be0c5ad82cc4fe170d2d3698c89ade8c0d9b028448fcfd7904a19cc712b5d619f3f0b37792cd978b7de407e5e964b47b152c7d25e7bafc8295dc98d786f200c90bf91b23768150620778be51a9a0024613e0db88cc7d029ca30444fbd50dbe8d7c0751be5a8617f4a041c30220c424ec3b516a90dd5db757e05fa65189f16decd76c0a141890e0a6d6a9a0c992fa3e91c27f0d8ba3f19f78b12ab25d0779b9b4dd4e18c6e28f47527291adcee5d491884ef6e8fda5ba9487d2414d75171bb9253daadcf393f5eeaa4061ce00a90a8d019d7182ca1bb59f8c45a5474feebf30fadd0323e891966dd489d6f67a99943deb7af185719af78874f951886ec490af50bc2bf0eb2f289f1e6846d8b0fb963dcb9d651e32204feaef454512a6fd637a7b16e9d025789895bccbf18b45e8b587ec510399d3ff7b69393b0cae0749c7e5988a33018b8b71680081c30db30e77262d5d19e5507d353f04d3d87c3b085f73bc6b71b0932a73c96da2e6c6fdabf4513e2ac48778f28953ba5bc277142563e3ec907ea49ea06e8b411198c44ee3878c99b508bc9ed2c4b3c89eea1b1cb20cf7e9921b38dbd4d5a07cf64ee00314d33ef6ae8a86293a07352d36a76d26a0906332efde68c8b8e810a45eebefc69ddd83b6842d732f52026096bdea8d8173a06fedf06390df18a93f6ee3f51d14f3d8d165c90434e66169ebd82b2de222eb520091f54ddea0da95d922c33fb26514afb9ad5adf8783f47752a2dc82e432d1704584183fab3c8fb2135525ff55740e4568205c17b11b526cd45e0c899a504b65e4aff93e3cfdcad463d67223449e2d5f1aa84e3c3bb381b6a6ba5dca71503b416dcd9ee6c474f41d33b5aec262f895a530883c988426d025f39f8592efca5924ef36376428769827c146616d9f7839c88bc94e71edd03b27520f001157814ea452a272111ec3be635db57ee2d57568a081f60901c02992dd21443473252daa09cfc4ac63692521a94826ccf7404d390556ad7e840dd50ed6a2ded479ce81ae0ac8107a8c0413152cd4535b21263816da7256844c37857ec5cfca3ef0b54162eac3c08bc1d3a5649b6561bfd123fc008913ef69a8f24687d7a359cd7222c66ec83dfbda5fa6eaf37d3a2b709b2853d90fb4eb11b77313f0091e6f24e3c5a0ca395001d16ec443d8c3b3a735b3ffc977fa4d759fa181b8e88d93af00ee1ddd52aea3ea428f2248de05cdfa7434e8fc01e3d5cabaa4102a3281cbd57a0594fd6ba4a491a794a6b612794806db9924b606c529847122190392ebba4ff6a9beb37342fb2562c1d2ae01f429d3c86744d6f1ba62c0b165fe802b9cc0c1c5b621a1af4b84484ad4d7469cb1d5f95b32200dabc949fd6172d8d2c49e5172536af7bfc3c68c08203a7ec79ec7de675e5b12d15961f7d390d00b23f302bc4574e66b2fa416c2ac3288d8e45d56a93736f21121582d552f6a7ff60d85e9523f93130235c2bde86e9dd89f7d0e10e13b2b755372bbee30ac33062d4b3ffb3adf9d4b4c9cd2f1d3024b47f2e7d712e37cbae9ce09d24c6575638ef03e85c7cceb192f18386aad4c307a63c60e69810fdf03c6446ff1c8bebb8b39a673efd13b1addc2f8cab27b5cde69da0b1b462280400f0c64ad8e0eac97b3e013791f7bb0147e6bad9dd834de6791f654c38496c7e15a4775310a0db09fc58fda2bc570146db2ac98882dcc9c22abe5ffb1d4e5e029e9655541612bf58dd1d4539191ca7a2cf4a07dd8c4d17c8b27a7978a4d916772e7370995a7695acbaaa25e25f20191df4b10541f1f1d9f0c532ba830369715bbe1c8bd198abec7a9e1c26b23857c9582f16b0dd03276c2bfe56a04579bc3c71e5ce8103369159b24c0280dea603f88216151250f63bab13c19d3dd4578d89536c61ed2dd526f342459079c0916fee666170326ed28a427c4399908862f07e5eaa1f990d2546ba8ff10a884b64e283ff64c0259d6f092eb1cf513f7f17bf3110a5ec804c5416eb874f80151999abe0da03d2d0179fc5d81d782dc5b76f19649034b098d58f0f49036b8a542df487f721b8539c3651228b86adb7d34c2bfe7f1ca76e309627432279eec1b2ff4d9ca23503c8f3dcaf815b02b728c32b87d15b7bad1762a1e652b80b581fadc5e19f4f3598d88b8ce1ebeac5db470950428c060ad24d433be9d1fd7ce3052c16aa6807bd7b53f896fd2b9b4f19bb883be76da51ba37f411cea31ee82b1cb8eda2ded91e81949d730037775e3256b2a36a269a7765a1bc6d10f329af718ca5739cebf76e8c31e641e6cf3e1be219dcd09b681cf3739a07e1e7acfb93bb432f051187f28ea72c75a99d770b8dda2be4fd624d9a07d3e76e1582cf9fcf8115296d3cd6025d912e3ba291f1c670b67a0bde92420221c36e7ed3ab4e9f167e5c094a04ad31ea48a35ad8b68e2b276650a285499436a8d7f1dfa794f3b360939babd4cf891f12e2dbbf949238b6af570808d12240fdc80b663899d5c612cf509cdc454b0a8e4b5f59433899d17186d60c89f994afd3e8943db4831e9675bf16cb25390b09c87328809e533c173524945124b4211fa37a5745c964abdc26e6b28e782aa77a5086997a959bcac0a477fcb3401d640bf0c10f7fe9581e774fc0641e935624b2ad1972d26f2ed4cb54aa18ebf99faa0712147672822bdc91f1fad05e717a85330fd75f370d37628b777923537757727b771ef6ee168a5d2c45996ba2f697a1e62f0304f428afa224246a3abf263b31f368377bd2aa7727e7f75fd1a0109ac4ba4ec547891b85285a622a2e9d5f3cad95a2adef766346357db5612e11812fd028d2dae3034e89fb3d12cc118ab38534e4cd6686b173b96a5bee64d377ed87e1ddaf8099b3fb157a2b0dccd94282eba9059e84e32f16e8201df7c34c7e8e4acfc477ea0b9cfdaa6dc5a7fdd25115ef3c54f576b3ac3e2deef44310cd21428fef4a995e56ea645bac7caef480792f57710fe6077b12febf32a526719d8110a67b589c9b8d098acf531ce3bf92bb739d1457c9b645e6aa42d4ac4c5768a0af9c74296592e8c6fd3ecf79dfeae692187408759d7af44f98531729d700faeb8f7ac91810f1ed1196542fd49bcfc650138c4ed2dc29aa035490b42e780704d23808c9d2132dcaaf674c11f32ac7d330dc5b9481add38a7a52f27142db25a00cbcd5efea73853b2eceb3ef57028c7a15df8bdcdc4739077c63be13f7be4690c376a1ad3ecf59657d100bb0bc5ea30d13d1a266edcc88b4f74a9a9c68928faddba189fe4b385beb5249105f3d034bb470d102c8930bc72446fb36f8d92a018bfdd69003f39b36235fb39cae7b278a2276fc19c863785ea0e99e3e16257c7d3a55b508afc518abe8d6466a8180fd66a71c5a381c958a3c6a2dc1c5ede5f6098a4be9ea41345946bb3feef4c0181d301a03463fd6f4bf8eb71e8addc58c14bb9a4076f29aa996307322d7f250f765bc477b172101a4ad47ccc1c72b4df7a99d9e2ebb7ffc1807a36b5cdd2c4276751095875db940a328e9eb3530c2d90e4bc422837fa4aff004b3274e64c3c3cb5204850c75acc7c0d6f2d6ba52b0e5be6ef1c955426ac6b79c458d4e2e4f39738450b33531938e44c2be5b29cdc75909b4a67092ddcf9bc612345d85588b8980c9ad4e59bb80bec5fc1439ced4fb77c435a3c0a1bfe22b5b5338f2a38f517d65695370e12afba4d452126d2f3a28a35298f0efc01a67ecbc49cfe65bba37fa30891dcc21a53995bd1b7763521010f109eecd0ded839492c581e491bb1e23ae6f53b7ce16728d0cfe1cc9ba20852db3e3a1b24a568334e75e0cc772ca1c619090dad72d855598c94e5f7389b9fd195223260be222c3db6eab3d7182ffcc7d033143625b95edd36f01b3f795fe5f91757d1df8a1615c408296aef1dabce703af3ae54a7622b830f400c8f39a73d2e3e4453d8ba5788d8896f83cde152fb72519244e11337cc88d0211defe831d08ac2b7864e20b0478a8d317665a0e9eaeda38a82d840a2b7c2523b41ae641ca94f8ba5fa1e9ab4a32b205d8b936b890834eb5e1ada6258fa40aa53fa6d1595b85ea705c8c7221fbcff24a94b6be473c28d792c229e0673cfccc05c1d6d51187f8f79762a93141076e187152ef946ed9ccb6226f24c8e151893297bdf8f5ffbac250c2f9aaca98459f122cbc4044bfeeb555a2ba25d1919adde96762b66f219f3dd449c7ed92e3db1c61d00ed2ef15f04ac8a1a2812b0c55184a271495e41f16418fa8edd014cfdcee55bfae853612a642e164e2559a52f5040d21dede04f1eed2d9375f242256afc199502e41952fbf9902dcd9c3f862236721c6f78c3e017a415f1b559854ee661ebc9110ea756ef6e136a375d06bd4c6f7edacb4519d133ee29ff8dea932978572809b0407fdbe549f848c217b52329731d6becda2fb18ea7b56365731a697da8417a79bbbfe4f466fedd630d9d6ea952ced3f62981278aa0a11e4e1ded7c0572e21d852136d183f6f6f53d9de44962206eb0b24746bf24861e68ff72b6a74038f9dda9c5642bd4f74efd2acfb53efcf5a3b4efde5aea3857dd00ca60d703d65ce1c78151c03dd112642af3b1b3f4d01b29aaec5efec61704e3b396b10433e3d50d329a4a7dd66cffacc16b3b0c83f0c5a68b85fa8c83b77ea15ce068ded68d0949bd575a8c7242f7c0f7228ed148198af3be92dcc9b1f25a2311cae0cb81ef0122a92885c50a211e32c85e624d7422295ea35e028a8850988f6685b4a46a3296cdda4fe332b0a44b1039ae2f069308314f68ab81e63d8606f91e000b913bbbd8a3fbc9ceec5ffb19fa72826b9038bc487e69f76cc0e2f808700dbc8e865595267d8a66a61a1c2f4f748a01f943905cbb55a26c631752d823e07c93958d230ea4b1bc895c7f4cdff418394d6b12255f446922a3d889701b5fdea4ede9bdc14cdf0ecb0e44753e0971e064b81f1c699931e99b5d7bb6191566404a89648c954c274f864cd044ccf04e46e75548f00acf97d3f9b14cfc9eb4b18bbcdf238dbdc73cc5a4b07caea1809962a0202e808d9c1c7a8e12b1bef06a70af2fd2b01741fc1f11e56d964c7b5aa97be6cffbbde93f597e0bde1cfe105cce3869a27e434e49a99c9485ccef119c174950fb7ef35cac55ccb6bc15b8a171efbf1021aa967bf296f85813f9df7293a8700c68c3599d7e2b862ee1fa58ba175ef24e41d185b9caa8ebe2d567ea5701ab0d3c72759b6d5174168c078790e118e83cd6fa140465baa3c53497f76a74a665b1b1929c92a47fe9bacc10bfee9c8dedc6a611d2d139c83008df5ef927c857a52f90eeb2cffd0d5c4b9ed67ab7081c8b9308dbcf18f7e4d0e30098e886d62e20f102468492afc0e727d5cc01874c4ab37178c54a5d5e1e368b0862a83297d5214b7945280dafc3f40ef51bdb18284ad749e11d6a2c06011e3b04d33656b53bae3a7e25bdac7b26175e8dedf46e6cbe685b4afbb094e47f01e4295efde76f2e51d0b939e1541f76eed5a55ad29655d8401fcb8c49fa8ad09913340343a3ef0206b33a46a716d4efafd64ce6a545cbdaef7a842214877dccca3f100be78dfdf279cdef30f1c2f642f7ab1faa7508cb0d6567fe6d903c030c0b9c58ef3fc5fcadd952ea6dd64aef1ae2b940fa74dfba386f0f889bfcc1fcab5892cad2f64e987721bf46ec428c353a740a4e3391f9769311987bc1400d32cbbed24dff41f5dff09e2d000d8c69edc62b3d1eb7453491985a25988d8ef8ce0171ce1a7e8dac41ae8395c79fee4786cb676dc9e2709710b3196fefeb888e78898051d6128f1bde69de2acc3097744a453d674ecb224c9d854bad55de28fbaf1b025988ec7d97099098fe64d52d7c1e6c42519971a9ade51fecb1fb93edc3ab7f5493677793ca4ce97726a8a095b5c77da5716adde5dbce1bd4bba17e4af956ead512a98c160c303bcfab2b83c829b16acf2a95c4637e6ba745afa3f51a25a890d2bf352ebc286ce23d7046ca14be4c6daec667278718b0fd93de8a0faa05ef565c801901ac770dcbda68751b0817f389ec9a1ccb02a75c5ad346fb8077b1380b47c1267422abbfe991cfc7b0feb1372dcd15cd81db8d94de37907aa326327441a13fd3cf2b02934f9c9c9c9264b0c7c8da9e4c1233d3aad83ce1dc436aefab503e884c1cb7fbccaefc26e6a36635ed08d2ac2b7c622f038e9172a39a94a0ff1add7eb2af71abbbb95dbfab47222aec8a187d2bda2601c6f95bfb0040385497f0ff55526b4a58e88f789ef41a7e5dd533660dcb6d416878f67f7c067fc14437c0e015ea9dac4ee0b27fdcdde43b15e57087506c0c0fb640457cc3c931bfb02a572a99bf215dad744d5bf1cf625b6df8b3b6e906193f4c9da973d653fa1de869b3321fe16863ffe5e322fb08274173e964c28c3996d92f53493d35a9946bf03630e1610928cf1144653ee8078402ee1e50ae74802cbef052e05c67feaea1636d39a49a4857b80974f3b6911869537a8a280464c2b7148c7d2ba908b5f3fdd5abd7f2ba2cfa6eea7843ae6a4db1e2b216f65eb366231628b27d27ce86b53f5b5dcc63846b0edbe63a8f37e3e66bb36aced7490b2bd7a23face5283b5d2dc410f5f5baf06757518caf478c08b861ca1ceff517ce14b286fdbdda44f2ad25625207bc81eb6bd439896a7bbbc9cf33e1388e5367cc65a2849a24b983794b9435adc5bcff8cc240b2ec0a51d0aae0e53122f14fc8f446966bd080b5bf99ab972e35d6b54121bde16e3781b4b30a5d5faab428018d1034c65e2e70195c4977a4e3afc503423fca478416e6a549a22f53ff1dba4591fc442888fbf619cca11adc1450852a4ef5c9b32215d852d67bf5efef982fd5ef5fa0292f3b6b4338c50ec0a527af5ef1757afd64dead0dc38e3dadd0461f2f9ca40ff318a0ff21d8eaa9d8e03b013b957320b9bb9c7de33ea6a2d5c8a159bac85f5dc26f67d523287a79cc21893ef3717fb3732e7d44e601995db2c9487b1064142367faa81e3da39f127c0ec01a050153fa9d73393a3b8e1e92079ecaabcfeb420c4063be74106dc24479eaa6532236bb7c97182810497394621a825993dd3b11e15791e79707c14935645da1c86996ca7cca514dbee51b0714daaf87eb83aae968781a3ffec5886f676967384320be3a2bc7a613ef2f7a939eccd0215590d2671fbf959ebc4c947569573a911fd52338378dc1e99a4b8a14f14913417e47d1a87f9f1bfaec004569418c83194e9a43ca7edb0844bd492a94354fc092efdb13062f1811272076419b11604a01fe5f1be8413623d473e7511ec215eb46d87a9fdfd9845bca95ca5fc40c2deb5064b13f7038405ae420799fd2313a4952b1a98ce8f3e03bafdc939dd63a8ea2d6a54796ae28c52d655b6ccdb4472c4201a9074fe1a61a3b409fa88ec2faabf3cfc61e80d5c9f418ca4267a469211a7e1ad43cfd43b3b007a0ab1a3c6e090c9549dd6530f3617634528fda6f470fda23c5d5ec4e8de5b64bbe1f66b6ae02c86d23325e8fb658d322160b28f85e4c91cd01e2b2e5bcab835ac045eeb313d0ced09133d17191265c009d023fe6f277ee2d4a5acae081024c6e2819e9b3e85c455ccb6bc97adab95dc3bc4775e351817698202f049692d43e5730233103639bcd2952b06d2af12d770bc77f0e301bb52323a7259805cc084085e3b3a76fabbc4b75171960742e8eefe1e7ef129184fd209480142cf524fcf985a930ae76a366a6a7b94345386a2b56816e2c24aceef17f4d4cab1513945311605d4b86ec7231180c35d1c014ecc939431bb30375e02717e2a5f10dbccf1e1f3882e9f5654e3b329613dffebf2a56fc5665463badbc00991922e7676700f3431fce89401f533f99c3d1e35283bef92cc016ff079dc8e21e95c03cef78ee089f6d85998429483f9e6c85ac9b6e4b82063db3fa3dbfed5f6e244ab5b641b0e0ae4c5f97001d6260802a9ec81f41e56635593eaabdfd88eec657cd388de5a1ec6721aaaca63f5be0d9545e93424f8ce0251d7f22dd20239ce24fdc68a251d302dda6137062b48e50a1a3a1afb1a594ade66f45fb2e21106362fbe86c7acefed003c37da270a79d40bb1d21973de55efda03b716cf6134534a2716b7cb3759d9b5409e9560347d2dfee2f744b18bd882c4188118845776174e93fcee5723aa8a59d4c8b74feeabd70939f2650d6cee223cb1f94a147567ae051a54ad302ff5380e523d92dac4335b833967f3dea6a68f267e8bdc650c3e7faac28d6c8d7df47351ea2cd28c96ab4bc26ad980afde28b8a3ef18e7323b79710c8a21186ae6876dc92a2fb7a3c1b7f587848df45df39e7ae2aa13e9c1f6cf1d7f004fdb808292104ce066bca61cb38a4123077ef73ec34a9f81319d1eef382bba5a13f17016cef7b01dc2ecf1bfb411a34602266d5288134fbb353750f29c06670367526367438a8499f3a5773cba23b352126907d766d2db25eb7b629d2f661813998ba35a54bd9c01289315454a810d0c23e918b9e22e76e4098047e7b224b56eed59ac5675272e21bf5b05c67c2513c44461b7d66215ef32b05ec2be82017aef93663e2ae5b2bd649c104190d031d0ec5346ab2b137500ae1914f5becede3c0c56e86471a6aecc5f91f29269654996f63cae2d7b4613ba80b27276ad681a43b7cd00293171564e5cdf66919c921b8732f795ba98ecfea7373d9d5e5027cb183ee9a418f335d26dfbebcfa46bfe2fd2d470035abcb7830a118bfc700b607725ff4c8f85fb400cb49b4e27b5565720d6f25462e816c9a32e735d44908450756bcb0a74e50de911396d50c78e6c1276465cda3ad3c308b264c4e55134efaeea7276f6b7297c3fef4bb340ab750d8a592dd5c0179af313f358eafec44c872319de0ff951eee8dd97c6e13911e479fe0d3ed1726b1ef835e47a7c8d5db1aebfb3f34cefb9ee6f2d34c48b0e0cc635492a6427e92679a749d1d16b38afe6c854dc4ff46f841d9132515a141fd33c7e1521360bbfdee80c7b6028706e5a0d02446efe7e23e1f950674e59258816ee4989979e5038d1a2ca0a5bee684672e1e25d1d0725ee840d4c9304e0a1fbbff3550d50fa2322c28e171aff8bed9ac9efe568b71c1300f42ab038a575bb0f723b43325d4458515e8c466d7af123c3b1ba39d624a9325b8296dcb5ce73fce009fc2731ab9b9cfbb6614591a4a46c628472fb46326b724fea2fe74fd5e1fb7273b287c4206e76c2dc90158af8e866dd3dc37c1872e6d4b59250bc20f0e695891cfc1e1507076a85fa0a01555ee754b1e80fb8f9909595aca8ca6df1020022424309bf97c2a5ac6df30c394420483271ea6ad28c075653a7a3daafa130b31e1c74555a506d0c94bb50edc83cce655efe1413ec474401e221bcf6e792a6e7defab0fbed6af5529207d6b05f8161cab407e74976ebe8fb016efe636272b97c4ed0fb4912a9227402b6655b161ace7efc1621bd02338cde9bb862aa21deac7c4326407fda0a082bc922d0bcfdc38fd0df527d0b87058ae7e0c3f622b5fe04372a7170eb97c1c930eeacafcd87377d9536535866544acc6fb27ca77c247a4d1cd6049cb03dfe7b70373450b566b32c5cec44e4d49f0d09476109c6e9966c59089f9d79452c46020351f19bc41d274abd82c3bd557d4997bbf49169de5781b8dbc56b2433139b76de965f60a6d1f7254391d520a5a73eefcd23cf0771c091a70901a4d171b564b15d016f3f70437dddbc558a4547ad0ccc18adad40bc30dad1a2b1ef849dfc9a166f9bf60bee0b802de35760c396d3143032859af1ac2035ac44ee7f59b40e2fbf01aee6339a2c7f89fbd4ce6ffcdaf2e850ea7127d0e6703fc1eacdc3cc7064087891d8d344161632d0cd1bff4f58312127249a9d6cef83f22faaf13215aba2ee5c4b02f93599cff5fb354059552bba1c7600b94783d63a3039eacfee3d7ebd8fb55fa7284d26b4240e29de02cbe543c6a81b037b89180cc7c4509bd98fa544f7c7f97dee66d47fa98f14160ddf81990de70a3bed349ec2c159248260a41af8c6d31819132a976de45427bfa51144c1ecac96e506195d4f254f41c0d753542ac8c4f15b32c0b1281587af8b0e852edf79cd5e702ea527f7762913eb38992eb1818524591f3c945e5f6411a67eb0aa3b9a23c0ca8eb45af9f9f7c25b92f2cd65fead28dc8a912de2f01501d1c1bb01dcb7099563d905dbb20084e409eba29b0d1fb8717c8fb555b8eba6c30893fcc3149712f68ab6d3b5ec1663a8e365895b813650b9d8a41a857cc4019e2ef7be508e89356f039134011c661eec44e91d1b137dea2da65879178724b557764b40d9d8f2ed7a29c819d156003aab0c7a186a897f1961d80a3261bed7e6fb0b6c49e30f621909f67eca4a31907c96d2de396d50176a82c2a1db9a3f767215afb6135f45185677c8ed98bcc31c0359fb32d3a564041b687a830e5230184f6dce5e137a82c213b396afeb90f65e7d4a81b74162b6b3849758f9de49c6dad9d48ec4213a19a27952f1b3052eefffeb7a44d779985c16193023c7ef4edab3f6abc9854cb3f31432fe9185d758847c8524374ba7d665a95638938c95b86d78b7d3d5ddd46b18ec3932b98580c65e7f1c068b6b8387f701462a8f0d7f129ee01533c4378918399b4855a2e05877bec3c5fd2d47afccb2badbc60a055fd4dbdebd16f62b0e2a9467c45be7195d2ac822d338eb3acc48db9a06ccfa37fd0d9023b501c12f7c649cdb97df9a9d5ce1ec7a19f09c417c76311a6ef8672fa85a89c81eaf859ef26c6d7a43461716d32751425309aaff1bea0352d5d5f6f1af268f6e0ad5e73a978d744d47f9505a5cc9ca96e8c93b52968c13a0c57e18f582dc8cebee0df9a315c2fd5fb2a54c136aa0e3f2e2109b4ddeeca7f605e8a96d6074a1edbec9c851a41c9801a7808e9e4f48a589fb75919e932d3a4d53a50bed7782c0717872f1d724ba403116708019ef3684fe4d2f54cab28d949ab050711234f7a409dc7fcb387c192bd0d9a1c27817ec2f40609323e85db73a2d80c470f771da9d25933a0d8288a3a7bd2c84fa99937ac87d66eac274feedff2138f2b9b1e9f822d6daa7a00ef33b8546878259d7d7aa3bb397ba2f4a1166689c613af9c1fae65502b1b5e7f6d347fc5fe81012510e066a6fd48e9b996a1258f46c85a245f69894217b2236c271e21a8508d77c2439a99fc9c2a7e315a22e9f05c64c740237e9b1b451a5814b5254cd51032ef9d6a8456c9c5d83ab1d97dbb37cccea29c7fec7dd04697129be2255c047f4596ce41e9d2995f6388ab07201d84bfd5081d8b55bc750b47524f6de4b36ed775d13b84fb8217247978912e27d799707f1a64c48f534fbf6c39c6df686bed13fbbbdec7c750697445bce44d1cdc9b640e72aed781d71a74a22cc2204f8c5b65920015c0e113756845891a0bea43a78fac72cac47a4d60de929a9d94027aba339a007c303253395675472c014773bf9f2f00a6559a634d97a87e0cb2cf0289815686631d43b7faeb0fa742353d81d0c687c515069a046c19a73c3013880e5bbffcbd08e06ef1bf5639a814073c667cde00d109229de647ec649b05992fe2ace4232da0a26e61c7d3a61b75bc6adaff802cd5b14abd2b533afe468697ef625ab26ade3fbc591de28b6403ecd28c9af09b1f9b8d5390895433b5d5e0d35c0b76be50fbe61442d6b3063c922b1843fd8eec20928ffa468996058c625b340e899bcf28569c2f292d78f3fd089edc3c03850658fcd4ac46576bd88a5a55e02bc010ceacd718f89fa8bf49144b96144d45e52bd5341de61264d582396d80fce75125d8a9d2598d39d491ea77b0013274a43c374281787a7ed9c0b3acbca6a64ed440e1a9a9d0003890d97dc6d0d9ee8e815f92f52ca66091f7003d45d734812dd90aef406d9ec7d1ff582903a2809725000c521e40f2e02893ecb5695a569bb62998ca1a10fd87def039eddc8677c1f83cbab81901bf8da659f9ef5f29fa402ddcb8abe3d33006dca6d0b97f1d516b05e7676fb441117a2c54bb21201daf088a2db20d2e6453cc064527b71bb8053b6df6f2446d986e5ef5fac87033f132a313b20cb4bfdcc7d1d5227aaad13227dad3194406d9419d7fda6e76366a0475c84a4ac21ac70b74eeeb9bcb79f34ca8b7785092ccd80ab3a7faa22de03a92d9f7e887931d4d5625c0cd73df04ab8e26c87c7a4f6eadcaa82721287e84a8467b3034ebb316244c7d900062213fb81c226caec74a24ab047d07bb000957e9dabedfc93397179c60d0fc40bc314c07e9c5473edd5ee2f952dcd9cdd2636de53c1648e889efcdbdc387f313943d74948f1ff54869c762365aea9707cafd55aa680b04e57a2d4e0eafcb4cc18e4fa08049f97fc2e6771dd8dd3d4749c2c4ed0421ff502a36bb52b689161c7b2326066433cf33e7bae72d60b9cb73d144f3c5c9c4c2f3fdd8e9169d9708306a0da04678979808cbfd54b8459552955bb2c2443e6bbceb681cc0e8a93a46a1dccbdb2490942fb3016b5eacdb1bff77eb5c4361bca0adda80534af82ae3d813bd88df1173e3a4bbb31fe6af77129e91d5a0fa2341e29837e1ee627b84f3c0735592d292da9f97d7f8db14513495f538ecfa27b45c68d508b8baf3c83b918ca7d47b9f6786e93894601640aa584fe8c317fc79be51886a4eedda60a95135eb9109405ae6c2311b683d217651dd7f7dc00cd9ac9125a182a1c2c527c4b2dc87871647bcd40d67df5f7c43d5f301501a820ff484e7272df692bf1eb42f3472f143e5bd581aba431e9c945f0131f678d55ef89c3fa24f766e68a5f62acccaf58ebfc27ba1d19c5cdd113d2f84cd8bd1bf9608db02707887974383e0acf646e4b2b10b04b87755880eec0701","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
