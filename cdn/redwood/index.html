<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fdd57ad5e6d5c9763447934721c910d1a492a96b43fec942bd673c83ab61bac4bb069041b2e561e340e639e6dc9dbb59cfceec43bb102206992d0fde758c2b80d5cce01ede1180d0a117abaa5c9e2f4650037b974cd6bc176ef09f452f7f9359be6b25317cba5d18ec5b91acb2fe8b13ada5464850df8bdb566bd5d45d6a190ddd3783b111c6ecd4a6757c047500cdf127fb1da5d5a8db9cb89a36322823907633e7cda84927cb9b6efbde1431e4321d295803e34bb9738b1b8c155ed15008ae1cd37d1684cbab92662f572b0eac9faa2df237ab2340cf1ba9e1f0fd4dcf27a815064ca77d53d455386d331442f00ce1d95664ec50f9bea71d84df196c2559baecd6b848efc2e641410b044360da06ff4b1f5921a6ba0a922c8eaf88895be072fbd293acd488691580dfe0973825812645165acfae1e1ff26a24b2e6cb1288179c256272d626317ab2b46375437029596efc42aa8a048599eb26530f7516269d14a351d0eb962b751933f788a793ca221ad23f5298e22d983dd7f250cc89f7d35b70d534ef98f9a5dc20a5032d4e822e0cfbf545ec272d15c4ceaaef7a210252661035bde9115c51ceee9bd5afcd07457b1e2aa3eecab5ff6e57543a915113c139a2cae775b7903b6b66596e5bc9f1b57c4f3a831430250334bbbdaa3ad70b5a0c15d213c0dd6200932d63087f1f277431244152748cd63dd862c5f29211c916d8ff861171ae1f759dc1c4840e82da11462ed8a44d1a38783d1cf648f5bf55a71c42d5cb14d1e3f995ad63ebd7a66c0fb38a0347d30afd4e0630df77fa1fae801de9b8232909c0e4aab956ef1599233e68c66b1261150cbc013caffde296cb43fceeba4c2f0240b266c538558b44710f39e8c7ae79b9e385edf5b3f5294054946323a5d74f41be3e8475e6d63bf1c167586b80e5a3edcc8463594f6bd9bb23f539fa30732357814e9923eadc9fa081530997becf657d06a83a9f50ff08f8a7fdcca9e6a099269fc26607a6ad4ba2c4560efb4c6817990d68906e4045a8f186419943abdc66ec99717dbad5aa834fd7651beb5c29b96cdf2a9ec2ad00f59299a7494651d359da8f1110470577f2177f15ab0886687aa41ca58c08ffa90521e23b95502f1f6b8dfc36de0adb67ecf33e7cd485a5dbaa044a1b1cda2ac2d25e986f61438fa5e0a6359d1c7aef9560fd3b4cf4cba66ad352548a76718ddb8ff37e1ecd00cfb7d83e61ed4bb5fb1c7c18eed023b6906b935829022049e1285b6767138a3075f579c1e2d4b454ae435f7d33f1310a3b5130dfc19729cdd584d4909ba6aac78749fed4d1d878cd755a08f1efce4f239feb54c10a09ac771e99c557272ab58c709f8eee8ad5f73eb465e5d1485efdd7b43f0de605f585b04035b722279dc315afef952043ee804056fb308aca48e7eeb5cbd258a2ba93a1c3f7f95d51cbef95f44a32da4409d06655be4428be16a3c205d9a5d1f5d451dda4cae7b758493f9d7ddea7ad973edf818d3c339c7637fcb37b107e2cd7db6b046ba36f3e368980295d44b19ec144f79b62fd9a4fd045e58f8938bd8df5e4bc1c5637551310006a9bddbc32c6f9c6bb5ce3105d4dc608ee97838546b1509ac8a7485e1dd21ebdb8b69073a86d492588a1835364b22b27bb04acae1322e6b5f5f55ac2cebc058476fd6249b76556022db050d4e1ed9fa4ee655341ca6c5bafccce5fa2a0d9f6cbb0436b68303639be63b6f4498fbd0047a232b366e8b97e0d7a0feeceaf5e5188ebdff366a717af176e05ff2afb1dd8de78c48bd40cb3c11a5c8602fc6638648ce1d7746a167457a03a4e610817dbf500ef1d03dc1c9c18d87fd50d9d5eefaedf08110c2169a4831da8a7b2fd8c1dd9745c19cba95f2c10361e2d36dbb5261bd200469cfe16e9db19beec8a5aa4529845431df9ddcc8daf2194e9d89f701716007026b9e4d21ef3f9f9af4582d12bb29b91fcd8f49a2d4074c7ddbf84b63593066f04aacd30d26669ea8ca73e50d9cffe17d4f98ad4112f56732ecd60378c5f171781487073bf595492c5e240d5117b44405078070f967c1b957ca2f1f91c647939b8094d80c932a1de1f7b2ff04cda1c455dac581dd406a96f7cc056bec1787f24596f9526c235836d420edd8eb43781e1a6a7814159d6170c7266d0fa61f29d8db463d67cb0fe4a335c8b5497e2623a754080d55f4f174cd4de807b1afc2b359986e20b26702374c4008cf1b7722d547441c0227270ef8fe8740effbd265350f9fac0a442ca0d6f02fae11c4ec8b5f54e1e0ce70eab941bb2166813df67f03874f12e7dfa9c3243d55129e64518ade9107db124c90602a5dd9f00366f02fad493fb3015e4772db990de70d334a0b120471818faf9d1eed8bd774947e74959446348afaa0ab6b7b21abbe0d453db1c5fe9ad03e975c52a80a82784a3cab0ff764a6d25305ff898adeb9acd9c36023196f37445909f1ebdd4cf4a0e59b7f3c1db5f47836b7ccdbb16ca91292534232d5bc86dc8177338c0c3286af919ba4fb2a410fd30772ce29eb51ec04dbe16ab34332a0dfc4336497980c08f1dd5281d943ec29122e4c9449c7502b80c703dda4260ae687a4e0ff8d4ee00f39d283fdc8785437f01c9876366f144318892257771c95de37cede8b6c421ec7065ba71d0ed3e868b8b01445d2ad954f7739b038b2f7635e6ee3878866bf5431212542135935239b1bc920e729260f79bff2beadd80992380a1f548950aa87e4aee68e2f8661ce26cbc6236b0f437368252c729c528072bcbdca43299e5c161e31008d316eb1a23c539a8814c7039ba4663582d976fa4539253e0d57425e8fb6684c1a4000f363b1858e1809e82b3a39e567718f595c61016ca912ccb28578599005cc745a3937973815585839f240a1e67a17ae767cdf369fafc31feec3d1fbbe8fbc486e5a314489940756b15c1260a8dd998cad1b1d93f0d85020c41cafe898a7ef0af6cc79ba628485931e0d81713473ba556a855b13069481b7a142d395c7ae36d103a856106baaa3b913074c1f033a66e6428d1135e98a4d77eac78d4fa6fa6a50bba18d6102ebeaa2a9843aa67625d6d91c894cdd249da27291099db3d805ede4b8c73c8ab64876784a8e1c8b1253eb16e0f92908171146885d48de4f585d42702fc7e94af86df2603303c75b06932881751d88bc4a92489935bf0e19c21dac9a74c6f7997e0d5cff15b62f60ff4386229b369154a6859245427e163ddee790fdb1763eb55b38b994012ef64da1cd978f6c8af34f42cec9fe79fe1d55ad20010576c4a2abc9441fa7806ba7b9511f131f45947b061f6307a13bbbca24f3155db0eff26584f0d3b6d4d18f7f1aa348f5994bd823fe7b76ecea514375d7f731cd0e8a4b9ca017419e8ec78bf3417619501c215f7074247c3e8653ee22c76a6c4871283753e52061e8e77b6fcdf3cf7d5cc02268a51e85dd6c81544ed36cb8c07801ef0edceb55088968bfcb6a3792e57ec0df87d1111acdb928a5804007ba39e509fd01b5d4d616d3c575c83cd6626fead7991bb8bad2fe48e7bd2d256e4b55afdef53f758a831402e56fb2d531d040442405a22e6a4c1a38b488120d9315ad64334f26e9a984ad52e0e107d742e740eed0a49095271e48a8f586c46afcbcb157aced4bbc4562a7dce1d8327a3c0a796c4043e4d8811a44989d3cb13b3c53418588541e4f389074458e191b698fafcafd8e88a259ba9c023e71a74a4ba2874ebe1bbd586a4e217714df8850e7a3268e385216ca5819c8e69f75ec6ee1ba18b0018751c09da97edef4eae835c4b5249801441eaf0170314453cbace56f61631539355a4890e7f8ec1da6216139c61bb9caf9e74bae04eaffae52929342d171dc0ee1465a5e1c8d70d3e55896136fc4dca29ca2193b058d2ee3f4f210fa87b5445d352983b38b960c9374dee52cf24db4f6477d3190f96039e2632fd3895af13a2cd64b74cb26fc7cfd65fbbb280c52da40e540c057a93f33db52f60f89f1a139d641adbf9c16861921e769447f546dc5dc3c9499ed329684316b48b5adfb49eb9fcdd73e59c0626caadf2401d03ecbc9c9755e2ba2ee92c1541cad4c24bfdbe44405d316279c4d8c69938960bf09affd73a4ffbae3142269ec83c13e5edb560dea12fa1b1ec4d2695a27b53298bd0320f64ef535599796ef0797d0e764e6c40810a1f63ab4b69df108918cd7d31be4c8eabe98f81b4a71b12f956697bf3f4aa60ba636f1fb966d2fc4aa63901b5be4d1d3b93a92f2ea87a40facfa91c144289e559c174496061f3314ffbd17ba431c557c1ddf98ca03e0081a1a0fa2b3912e233bedee0df8203019ad90ea358ea608aa8b07e517ff675d211b669550bb9501824fc97030daba544d93cf7b74bfd77ad90026fcf7908e3dff65a4b229bdf6a98921eaa6cfd983c4a738db110bf0d4674e24a7c5035630ad5fa22a8712fd36331979502dfedb3f1c7817cabb20af4242cbdc0af67e4c985b2e061e0089de640d3cde97fdc87e82bb0fdb5c9bb3ca320d817780ebe95e911227361607cf2e578af293a864e0170ff1c9e2a1e6873a6252aeea4cb5ff1c69f61cf3adc4f17a3be03fde4e25e62adb077d0ef5a74ff154e66a4b9220d1722087dd40eff159b920b68a7c2b2c3924967b8d39bd36cee17e7757d5e71b3d6db46f4694c4e5fa2540ee8d28b187498cab21adfd84cc3673ac15c2d6082d1a236e04315a9fd4da5c3b1a585b88be996c84b551f8a461a2126efcb6f8d3c5948189e8f96777e4ef52977ebbabae427492b88e730b71eea8a73bf843d208f9826fbc54ea9ee8e26bc0a179290eaef71ccd2a62461aa732ab0a36b548a058a43a838970bdbeacf18d78e89d1dadd7f30afa5e04e6c8900dbe9e7714ab4fb7ed258d08341a19c5ad03070ef5c2a526cc53bb36d383fc80a19dee389c132a168ee1f286277cf4840f21c72e912e5683558728b81e91aaa45adf6d0d7da35a646c959acba665135ba544a84bc7cbbb68dbea30df6b62891d2ca9c9fa5cd9b64f20412f0bfc1a8c1df9e2fc6d96457c0ad157cd981f307591cf53060dfec44e0f94dcb4c87f94fd36564a0e97a909335823f68ffedcab26f1409ff02d5fcd0f65a43d371c3002904d5bedda3863cbc54fe97a8d08c67b66b2435ca6ad0da1ffd3eb79b60ce0540f356543b57007f0b182685f57ce3b34206cd25ded209887fc807928b9cc32a316226c0ea69021459d9d1adf3d9d07e3e1597bc24699296cc6d863225a60876d8c15cc0c541468b769f01c5d8d1ae45ead4c8310fb3c0f9d533c2a16f30fb3f22dc2796ad086241a149874e2423f5400e1dee8b37d1ac3b2410808c7596155ce5284dbf91b566f859d55e6284b6070b9cab38e3b0fc4dae62bc0d48657edd3babf63e9d728af4c593020ed2b2a9faee3aae41d98b6cc5e316eef0044cae267493a45ecbe1f6db3873da7a64076643a4a3b7f41af12652c3fd786178c987a8cf35952127b61ae12b1cf81951b8defe2816c8c39d0c0e32f3edaa657396ca7482a51ddf645ea629d032ac4fa23c93af3b66fdf1388e2c5c54bb1d2e892aaf9f4afcc10995a59732739af0e3bd79e8daf1ead8632ea1afb63a35f6117b248416517429291161dee420252a514e09983892f4b09d210cc968b468bb8719632c4b2d69854fbe2937a3ec2291e6bf78bb80c38fcdfe18b9fe7db0580ed45103d02e482857b1eb6a0a0d2d9f4ecd5b72fc9bb885fa852a0caffcd0df31c0637e3516278b6459fd8be1ee51286efda155b20996db83c15a0fe0525d1e96586dfa2077d658c811aee80e8b0112d3bd9f8aa065924a22b3ada354a3a68ef686300558ff0e963df3a2e5d2ef72ad38839e8f8e77bec36507408cf8db6a8a5cec432ac003634f95acac0dcd3a931e841080221e8fcc5e00b689cdbd2ba0f2ee3f1cd9ac139f7dc5be6755f818ca7226102e503dbc6da04fb4dc321171829cfe7c020b03a675e128b09d1f75c41e7ea97b535f824db009098e6aeff8da497c2dbb306a15994e05679deca2aefe4489c829b386a21d91635a969b16718742ad91282541501366066dcbaa2b5ee7c52cf7d4573c866868d891aab19dff15bb6f49d79e048f68b58bc28c235c87088e81b273f047e07af2afdc1c114dfe1fc0cdf0fb88d70dec5f73a72d66dba4ec3f62dfa320a91a6108067abf3d0319f62ba6a4e1ad9fd3b5d18b557fbca3c6277a45c2f7af4384e37ce453b4d1dff912717e9a7d345a5a746622bd0ae5afa3d60ab9daa92aca0098c7defa1ae88434378242b52843131b19e43c684858463ab6e56b15db64394c1d66dced6d507335205688feae00376e6477a41d97a3ec6d28de586009ac46f1935e26e104136ac5c19ac60455b91cae53f48b62e462ea1c461dc780bba3b82f57d1ffbcf166fe01520b4015955d078c09277a31413b1b19247c6a274a7963a557d01629961cc012c90076ab71e57bf380086ed680df2236de178a42d580f1ae09c1d2e0bf91410883a847843d729f3355e9eaf8074c928904dd7f9c200a20f81f6bf85c497d378e54ea11c1256cc3a39c0ad6c7dea4cdc3f0febb380f2bc6a33b49c92b7f612ba668544cf9b6bb34f6971d366f9df2976b0bf65bb52693ac2b697215c8b18a1c7d3c78a96f4dc70b90ed443a05d51c8fa83be6af0c24599e1c25e7229579cb6d3809de54e0d286541b80a044a7c02d4c3eb928b62dcff7809318a66db4a733aae375cb4b5b191a0e83b91f574c9559e786beac984060ca7309f991613368c6ca819fa7cb03b8ae499262823f86d3438b1bc9f3afcedf3f85abc43cb933300625842bb68024bf57b610e3f92c7aafdb2f127035d8129a522d4614a7d5b7c310b7fb64a20a33bae536e8e0ee30b27b9e3ff5f135ea64baa09e7c36f35f146bb2f25d64b0ab98b2fb94737757c934f9bab1c18e8c281323b24a4839b44474f65fd246ffe4479f17965a3754032730ec7fe71fbc1e139cac708f76a235bfff2f3ef110dab725d885971a11c4fc5f628823a3b072ca3fe39933f87cc3ff55cbdaf7d68571c10608e128b709eb1c774ac571daae73ddad07cdfad24eb21b4635f179cfde3fb2df0b1b7d18ba6fafab38110fc88941cf89d7daa14630754112e89a4ee7eeef718ad30deff80a94567c491e8863affad3b054660ba68206343fcad4728aa6f70eecec2a6f160c592c7f08440b514716ec4d75f3117fa379fcf56da49adb80ad3f1a40bdb6546ecbf565c4403dc3df6d1172e0b658eaed09c327dace0cfbb8fe6d26c04ff8d5071a0cf9c062d47f69be8849695df21883867a3a95edfc49a387984661d71bbac05e56c6088bf9eae013bcd51199e50721d893f79564fa7428eb00d512f3130328c44a927120d9b399f796cd319c65497dadf618743ecf49a87bbb50c5cdc548fb968ff53118b9b3c9d34fb7dd0d69fd4f282a371cd01783b1061fc28a8364daa3d3c15b4985f1fc520ccf9b8ab3c1beae681db3bf2a78aba4f438ea86ad6588298d9c9abdd79011ecac98e77515be97df7b0ed3353f500322a4a452699a4a327845e093ac789550b3c00be05ca806a049d6432e0c431dd3141e2306f9cfce2ef23691ab50750b9da6e9df11c01bf6de9afed190de8162ffd6be36a491d123c942caa5fc767bf2c5c874e7c916a8d605f264d7845604144105613827c38452ea79b19e1e085bd39914a71e1bbaa4d00703b694cfddde84989341860367ea5b56e16892f2e8d30fa2f8e0821e716fdb74a5aa2729081e27fcd2136146cf130e2b8f2c91080aee16cee2f3207905f74056cca279cf868dcb9bca1b9ff4a13a9e7aa4caca58619392978763051dab7ccf52273af53fbcceec33bca7c5efd8177e2999e98991c823d56a87f20e16b47ab7096bed76457b1f115dbf9aba422a6223ff5f991c36f50bae0e7e59cfc906ea6e957bdb86664f72e5a1bf7b0abd76e3e5f820cfe8a4fb0816a1d579bc109246a02851955d1e859ebd327a30cc7d928d6d778cf8f4c6c280a99f6d958944bd1bae3669c75f384e2550f103ab00fdc05a66ac54b158534d136a2f9d0e71c76ec568e948c7ab8f21c5bb58a6f83b74aa37281a97e1c34e1aec15825e369474654d2eb5f8046fbf5656f03843b32e7c8192cfd8d22cf13487308576bf5eb4ad2bcb32e510fa216c4498e5e3f326dfbac95ad6a12963c4c92ba67f8ab7045dff2effcab991a8b3fe591f6cd51b0f3f39d639626270ed89640aa3a07f28682c8d4fcee47980eacdf8d2efb491b5af9fa4eb693294ef0e6c133c3400b6ac0fc0b746269b1eff708807cf129cd462b45aa7912fbd8b439f62c11fde788f2c965dcb09befdd7f5acc0c273a3d187747001565dba2daa3073728ce7b5ecd10ba3d66e052d2e55d7059666c346637d8d33c19f63726772ef1530b38b605f28f788b394343a0447c7649bccbbce1e51c78c8abb488a6d0704a4c7ebe1c16b77fc639856a9f854ff35712497ad9b8cfa10d1b024f87dd052207d9cf7b8c8fc66b0cf308dd62497b60d9d95d54111f02678e4146f394241a011577aeb126f1cef81b6b5bde370f3366465e1ece534e2e2520a24f934e56a3ba3a53205eda7043589db77d79dba1a8e12f88e8c925af9f0065b9ec8037c445d250da16174fda2818115608908d377e822d6523438f502203b78e1451fa51db69efdd4b5052cad3710abea39bb7022af8568e653f9f40bd8babc00f1b380faf17d565303562c30cb9b76fb56527544c1a87e258292f25c574b259b808e96bd2e652ef6adca4cccc4ebcaa4ea1d3c3db2a76bfab9b4ad2691139bd29e7de9e1345f2fefdd4f0cfe79197450165a35a5ceaad0c371df5775b459dc84e3e8984a893aea1c0bc703a1d81d9f75916a58251c8d2a186b67d0dd8c0b0565414098f07054db172fbd8f374583c91cc1edd6991933f3a609ae488ce4002a0638b7fd64bf43e023e00576dd0c48a2593bf0adb1db255356f3534142e87f51cffc2898e5a143a633c6fc4eba8c2a911cc3a275028907c4b5418a5be53493fbff16e67135f64bf82c05e735ff845822a510d8f1f37504a4dd568cdaedcdafd6e91d67b8ef41b50e99fee51dfc78bea15c55307688d7faf242eaa42adeab7bbe879a7a446f769fcc200e11ebc0a9373a11127dc6549ed4340c2747c8bf1f428768d356ea3ac82d59d56c6f85ff5aad3ef4ba062c7c0f5a09ede00aeb7649c69f342da097a5cf6b8f4a9f5d41137c2a6cf34d92d8c8fc9083e105c26fd0ac4c3a7b729e828713703d9be4d89c149cf222848d2948f32e6d1844f78b4b395f73ad8a76601b53a5da1034c025fb15aad848a82b94dbbea3ca19b14ebe51a0fd028bd43996e7d99ca1d323cd64f38989b821b7a4c0d33c45bb4e55ac70094606eb2268e91c5449eec605d7a27aa1d16623226616b55863fc763b269ae05c5c931c55fd66eee4779546ce28157ef0c8be28619a9472cc8c462ab1f6a9ce7f2c8338a09f580bde7c07e1db7b5fffba26a81be128c679d30aa00a5cf8fd5e095b17d568152db1e145d44b916dd315d1baf905cd507cb8445c4d347acdd59a7ac97aaaf02abfdc8214b0f5a1294f7245e1d3b4a36bb31b1ae9a798e7d80e4ef3892b7fe81c64a13645cc7710d58efd7ce54cdd4ac5a6cd66077d8822d061e503f20f26d85a2cda7ba1edeeb4a9bccd3e08930333da768cb710a662279feda43e53cd4c9216fa6578e636bc3b2dd67d4bde0cc72fa35fa407fe5f2c85e8046bfae676d33e69d72ab858aa46f53e79a996432dc52807bf03e5ad6d2dc0272c2326542247a3de90cefb5d89372741748c2244f740764c1095bcac1871f077cac661be429fbdf877620f33b005eb5a55be312438c187593df032ad384dfb4382591e3bb576b7d374f53245cc7cb46001f3a751514074a4f2cc80b2c75829dc092c851165320f1800b9742a9f3de62246a3959b009071cae7b0a1f892a62e90409f294c0cd7b8b6a3bf7bd85fd73366c48e3016a522142bc9a61b73b5c794201ec54ef5f65a1d32da260463ffed0b051631f1ddcc47337950cafc80562b43caa3b7c11c290cde785f10d07f306d1fd05d81f7f4f541aa9937663420cad5680c9e4fcf773759586b5376d95808282820eacdf2018716f8a3cfd05eece0608713055ffed0e95ad2a14de5c1582941313ef23b300be56a00d434e592c4f1a210cbbbc83d9a2c6d761b1c360b25423ac2af446f0ef9a455901542b281c95b2d917ba694574480b0fd27567797cbcc53ff146a5e7f0f97da4c014f6fcce3234725852a9f5e7db472f2b104d1705bfce184a357f73f2e827a8e0d42e5e6b05f132e65d7b883e0cc784d0846c93b5eb507817d3317ea0e02d09773be430a09630535065b69065444e51618ccc85dcbf6135ec6e795241037b99a6594bf2d1f1eaa328bd04492d0d9d01caef23cb875c45f909254670d968e2e7af20420cc2d5d7897997237b14653b4b6076df5b9c4fa62abe038abfe5a4fa597d98278f05d55ec0b5b92b9278fad54162b98bcee00cf6c70a71caf85e231af988f2c4b5c7a97fa69863f9affdd300eb2d486dad807b588259aa0ea30775ab998020fb8b40ba44f438027b9d4cef9a734e4a787e94cd40d90d361e6440a36f3cdd31d7b581610a1e4a0e19ae8c412f123192d330d28d84f06169c65ab66d8449950323fa6243557bf0e11fae88ba74cd5c667edd5e91e1f687d20169451bdb7c7865c8bc5be21de772fe2a390100d15a3ee8dd3bc0bad8bd2147c65aa85f18bd76ad7c41dea8d8399ade5ca2080ba55d837fad83a4adf0c8d303899ab4f03e06c53f4942364e5588bd72a00f5b8b692d8f42b2e01bc278b04af3928d7c24cd209a08fb26d98e5916dc112875ccf27d48143d4453f45f5a9f2086eaf783239e38b58b989141cacb6ea1221a640e91f338a4d4f382dd44880d12325b22b609cfe16f3e29308bf1f5e446caf999f21fa5ab4f3a85d65b2f0d26bee018c7e6a86a1e082d8cb3fe1ba55f2efb97ba922e2ad8234adc9819ece1835347615449948dd815e05f7b3aca6b7d1303de0ec38273d809c72880ad51e02a72689bd7e42e8446bdfbf3d7dd974a7101e1b0dacb272126d95a8b39a939a6070e1c4859bc7efcb8f9b97cc66654d672c3091033cada93c0c754abbf358a261c3675e3244407e4def48906853081293d31a8513cc518afcef69722766e6f7f9859622760bda555861054feabd60a3020d75bb4f54e8cc3934abb2622f598160d8665301430e63ba3793d890845f4181b18b3a166bb084760a009852de2e559646e33d224c38f1484f9c2b4546c1a2d1c0d143bdd21e8fb40c400ee429863655ba2423f43d6320bddd413a1a45bb9d81df6ef7167933af147aa9cd65c19a62cb9ab41f336e9840224049b237cb5ef2c6a1384e6740004d9b02c05150484f33859f181a141e46e2b514468badb7386acf41571d1aee505c5d73849d61de61bdf1cf4236606adbb92ca8044ec8e2601f371d9d2280b2c1a356f4a81122ed323b0f4fe59ad3c648e39e5755c7955bb648a150643e64f6c0a0061865a239b217a2dd935d774e79869f5628928d2024ecf55f07c0cb0e9611dff17a6aca5b309f39cd4b3c2c471fe9582ef797cf49baad0c072534e89549daf86ee4dfe0b67d03de532549613b3663e46c18d666141b89b08c8f4ec3eb50008187d99c8f70ac21e797e4051d425441c51621393341c97402fb8745ede34dfff2baaab203e66876c019c5da266798f5bd48af3c07fdd3779d29a339253d9011d6558e3b539bb02d45ddb5917db1b93190a2942108ec93e283f7362638729def89d47a9628bb84f7e9a281d4958a0e85121a2fd3ace49d7b6d938d124fa062828cfd7c676c23d089f6e535351c6a62eed433c23f81a335954cb1b6e354e0c67fe88dc5aecd9ffffd9f88894445dc95ddba05ff32685d32447c44874732e22e631172e14ad5bdfd7f5663bbf25618f11986ceb0c36fe95abecbbe1fa2ec281d5e1fda015f22e5d1d985af841bdeb7ac7c642f044f604986907a1205f46793b809470e0cfb225f72de56e7e07c53b94b99dbd4ccde7485b451020efbcde0c7e00d4c9fdbd2d0bcc0217030975286c345d5c94b648f192e0a46d86ef24afee2d716670ac2f6cc7624015c38e3989f781343801e6c3f1d36441d022cb40acbd482153bef1e6834baae4888dd1508ec88f7f9ce4222596d3f8a598f0f72138bb8c2e5e6eb79bdf6ffd293ff577512090b863b8a46264dc90f5b732b284377edc11a66f576330d71be8ec91722bd9c6521553a8661a0dadbde4551d85b2206861df5d13535b5e567861865b315e4ddab6f8bedf1e83ecf2b5f1c3f7306f32ab9c14a8526a4093c0f36403afa4ab0794183be036225e7860dc5c425db87fc3c4b54ed0c10dd3584b06c1b21005d63dec19ecf95bfaa46857126a612c75645c8ceb0f59aedade2645bbc79f911ec295e5dcbe10d4dd4a74496cceef2b884a2fe6163c05b1ca96b2ee71dad0029b1d25e9bea8082415f4f17e8afa8d213fd04b46bb519e84f4321b7a271367f73e151c3cd2dfb8c4d9cfd6d19ffaf11cc072feae2283cf054ee7599b5d28410073343e898bc3f27d521275ce72e9004e29c86d2fa2e4b6fb25126879616296b0c4e2a58fa2859d1c90c89497bbfbd57047f3a8d0421c8526aa47fe6cd87e922475ea6995a09e1d609eba30b685bfd82710ff3104cfdcc57d79218772a069a217b91c0693981c342fa82b6e3ab44912e704c60fb802a681f0c4f51573f1c0f549bfb70aded2bceb14057f583f0d2402f84c1c40329423a2539cc40d1ed6de6afb1fbad8b5885459a24bb649e461b7ddcbeda4444770ce114b7f5c82a668c0272d8a8fb2655cf4812aad75abf29194d516369ced376beed72a8100e1a4f431c14bbe46467effbc207ac85bef9e45cb7aa4dfb10f7175791315f6c151e0104fbb40d2f9d2452bfb635481925bd72603c5b4856b4a790547d647807effe13e45dae2879dc4fd4b1b9390bf7f0c8c6820d785eadb22545c272d7ab5b7e710c5f872ce5987964a9363dbbce4c082df9c32e73e4228d9a1b32e29641fb6d5c20b3a832885015e3a2aa0b8eef2c96facb1442ed0e7a37f0e3e98027af178ddbaabe9c7a5c5078bfa2ab8c308b199a3494d6c3fc2f1174bf1f05ec4cffc98373c43b7c5e1e9006a5a2f1be8470929222456ee67d1b09e460a95a25d7d12eb722c2005f1cb1d0c27e98166bf70433d3c15a4096d2d9ea394ac81257cb2f852bd8478567856516f8ada1f5fa7336bd36118f50c66f61323d68522ca342f0e3434995d6da437b3b5a3825d03ca893d107205866008e63a3eee9bf1dcc9abad6251d99622f0a5730a88c160666ff858a37e63e936764e9dfe95daf87baa8d1c1d32eecae781d55bbb52f67d703c6739d0b4bb602eb7f56e4dadf3282e322c6ed80184cd02c7629743240f939a4dcba25a626d5dd3a4b96c4a16e7869bae275d211ce534138384bf3d49ffcbec435d5f6fb9583ba549db3f8ecd1c4203deeae6394d6a1bfcc14800271d47217ac383dabaa1553385c5bcc29c595a7ed2c906deb23f1c2cb2c6645d84af702ee4242739ffd06c9f8ae91dde9c871f920ff7f7b833e96efb15a9bed606926dcb163383108066a516b4d43cc15438084d99c4de048064021cbdda5649731b4861e99552826c207da963cf01260cb47f18a4b97155654752c8013d533fd15105af418f7b077aa509802eed9687035f7c7dc756f72ad1e5a1ac3fb554f68d5640f91ea813f9a3cb1a411c74a96a25e106d8fcd383ac61b4f22249bbcf58092be9c079510c4c17a48df992011731180e8ffdbebb4f80650b716097d95ae91d5524971a0580f771ad49b8eab63b2c77d59f75cb4ddf1ac5b4d37c971921074658d741b84a2818e503e3265597974e05ccd6db7002597c34c74d1ed7ec54d022acab82b7e705e18aacd48a096fffb1ee1d1e861c368383970eaefcb45627daf43f540382924188fa4a75c2917b2d4e026562197fbf96ba48c20ef6c51cd63084349cf29808976db3d59ec02a0e68839fb7529dc0349b07bca264a7b1ec2cb50ac01c01ea44eb1d5cfc7ac27d9e2d68983e5e7dfbd6280267afcfa57eb9050ecc37f528e93f59e963a2ccf3566c187c4bd18ede4a17379d0d7ebdf15189aa81fc11bd71be6ee793232f7f38201af6a9600bfe4d439e64dd07d3f4cc10b21d19b3c857aa3de301988b31dba033d24c74bcf4b724d6c1e73b11fb2c014c5198a5e998199767eee169a0d8bacd9650dcdee565f455e412053ca86728ed0733b5046ed6271c43d4f86f414301def72774fa3087e9ef8487436f4e173c82f42127b0597a52a052638b5e8e6a253d3cf7ac81e345dc50b4a5623aa1aa50af5cae58b0bc335bb0ebcb32f63ce4eb6f7010d4dd2740c54993598f52665e306719a1d2366c8459d769f2530f08d203131d1d8fadbcc0d633ccaeec74a3bf54c1f43c6ad4a2e7d25d249dadf7e4cf9d5373501701b687cfc2bdb6ce92a3df92a0fc957139d77ddfdee1861314f5ef979e2b6ba871d34bcd5ee54224562c3b4c95b48f05cd93b2c2eba2dd576edbae4cf0c2eaf1220482d6c4fb89723299392416d9c641d5e290ffbf873e0b3be5e7bc177f24799b25b20389ab8c84a30b32e69dc7fa8ddefa0c5c6f740f313f6763c7448b5541ce3e1b07c6ab8e688cb0ff6122b480f92c7c821c2c60d4aed0e3edc380f8d634443117361d852838f101063c1e0d01858db4def1e75d260c1226011e7aeffe92ad95eece56a0f986b33c453df35cdaa7880cfeda71b2b50cdb6798c918d5d7993e0f2dcce76cec2a830e6857fa0dddee87b8448205be740dc0b9d61b39acade81377c14b6f61367077aa057d6fb1c52db1063867abcfbb1cc9e0a91dbab789d2c4321c08d61ca627811cebb14fe606d009f863fa7ec00addc641fc7c98f55bcf5677e7b8f05024fb18902a1115451494c1b60969705ed8b23c3c32f373b1657875539ea0801c319a19a90a249a59bf2f1c154ccda85eb65a365c28ef655e65515330217a5f6ee86ac8c43d88185935a6be4b425fe5807e5a56368aa66a1c4b83bed8ecafd59fdaf2cfb0345d6773c4ea202325a255fa688ae628fbc87b1b91b0440c79bdf56a39cef9c355588b2ae919cc32b9a72f772d683423466a8fc405d59e1d935b385a0cde8387d83ade1181001b7f6021009add646b0fbdabf7d084fd442006e1e376f99fe1d909e131e8616cbd664d1f3fc7f301ef131c7fd69237fbfffa2c41a64eff0011ed91f990fd5322bb38750575a6cc2737f3c00a1738f2f723de6e530b92211da9e1b20d958fc0445c724a1a7ebe36b92c26f145530f83e0b17fc1725633615d1f91b5e62a4550ebdc84e60bdbb2b8c78e164ea3d188aaff505bd1e3cf06e9e8224a3c1c9fc1ef206104ccd40548dadd72447b30b04f0aa14de0ad04f9a44274e8eadd287255b040b4fe3167c1104e70bed3e2d97ff952e5fe5e63674a24d674c26009557caab26148b3d96c76faf96cfa77eb54dce8c9783edaa8c46d73847faecfeea24b8f86da5e45036a6bbb73fa1f0201f3a31da86ee3deaa31c28bcf727bb591ae7ee6c08bf0423770e6f8e2680a9f09f8125d1d591438fc3748697dc51bfc349a13db876fe0e2398d76a58f2961609c522ea042d77242dbff29c558c5da37f91dddcbd9aa5fdf59e226089325378bb3fa250ec2a1b6a0c05b3aeaf22fe923bea2d747ef43640e5314f9cfdf24998d51aaf2978f6dddf95375d6735205259c74838f42f3f19db77c1672e60c3cd72cb6e1b849aae7625a26003eaf1dd7e3ec7b2c0fd49cf1e9dcf1629e152452f5219f701becd15aa559503db7f82366e0ce635c3ee493debe230c434f4a6a4aa3a1bffa5e97b584bc985d675dd0631c840dbbe690b00522d78ae08853062ae96ad20356195dff855b4ac21e6e5ff9091656d793e29ced7eaf247c07e58328fd156a81216dcdb1366f417accc47978a760f7fffe47cb58d943452b4efe1add3c0b831ca2cb4c19434c04c13bbda432ec3f6193fea30dacf34427d5753a76f395f6d87f261111ffaa7fb6b67f78e290f308202b90f11af7e623f19f78498db5c3bc55d17200e572d7b58074381184eb3e023c964be2d1687a9caa84e349dd3cf75d3320b87e3a9c3138b91db45f6cf94e1b5c679e11c26f473bab3dd5d8d10c7ff3e25171dd6628d994735f78d7e83c2151932efc88d9558911a254f54d9db63bd50100f02b7783fc72efba137acc16ed454e3632662bed5b29d582faff09c101fdccc7c8dffaa639f95d10876e8ba9ba80e5789856e0138e5ada9ca5e539a02956ee1745af6ecbc68e72836e1315b8bbb334ba4c106c52038d9e6a1cd2f056dbc0097a5070e6c847817b6c50d7c8d68931a660b81b69a200a7c9223bf704cfb79ec87983d628735dc35290154fe73560af5f6e8f8ce92870eaecf8bf0633f95cbd5b2f38dd13c93549df3ea84a76f4c3ec6087144278814d402446d5e4b37e0a84705853d62ae16dea5bb9dbe83de155c6932902fc05426673d2ce6b67bb884e4dac7d164ead4676d39c9f0413c68d6c3bd5cceb62be942e9060de1b1b83beaf8bf2e6053d644d3bb2a94e33ed5ffbf9731fab799cb5b123a1485c53ca9bdfc375f784bcbb7779f93bf42de4a26ad80db015f1cb4df5fea8a4f19f3fc3f02cd7b0fb99573b218ae2e0443165f60521c6341c77e1111da567ea4d7312fb66a9e2d9a83e4db0023d4b7b23fe00071fed5bedf0884a1ef4bb47589ebb95e8f92adadbcd3913e794dbb2adda4a1d6545b18a1317f27195c5b9cf5c3e93a007265d060ee16be7a8447ac02adc8a9fb623ecb839c33eec0a3ce2d72cabcb21ac715559ab32dcd16c196dc228004b50f10bdd22aec83675efa222492fe9fe65a9c3fe85e4b27a448985ab1e1129074a34e117fed129f4c8fa71a7b0919e48d03851236220b940cc091daf31862ad1cf35e9c28d1cd75a56991612427f1b4dfdf34d8caec043480b43ebcf0cabdda63d39b4b474f938666aabe75d86f7ceb3922a9400dcc9b409ad748826e3a03ce7fb20849692fc96fb0c5454880e57a7f8dc2066beb672274871d87409fcd4380502ef67756f29292797a5fba9180abd00e5654023491537aad933e0469232428b71c4365bb31318d00431f52936003099bfc795a5d80efbfc5db1d57aa58503b8e4b4a0ca7c4617ab4ddeadadbb44ecf76d30f3a02a91b231f5e5e7b8cc6960ce64cfcd7cc7e33fd8b686b02773e096ebbba2bfb493027bc254f3508144cc71dcec035bb1e11dd0f2fd1f902c39c16ee47da2b0f9b6987a3f9fd1b1b1e79fdbdeadc08e3ebad0ab7cf31d482604f53917137a76695aee0b87544f0cc0f1699c9acef1dbe41683b1d5c8899d576ab8b6c0788b3ad03c23fc0d011f60b3dd6e2c6c4d08af6b73c4159cfc1fe8f6376844ae5003f0e53010facc4c2ea934bc259913388c13af4db7d1b013d46514139c24770f2f12b5dc6c5e84070e3355b8285dfa2e6b0fe75bee3a4e1dc96cd4ef34a0756d59e9e3c3e431bc1da29201745d40e6fc468d7a6f37279e8dac50c69ca5314653f358b0cee06e58851cf9a964a763edf43408331df382a3596dc041988bccab98856ba4e22d0ddf0f6334597176ad1745acfa674ef7926a9f3847f73ce5eba4924ef4b886d12a362c3cafedd8b35dc141da0205f2db37ed7880b40aec263484e6daa727daaa9fe6860ed83325082dfdb6d2d7e1cb88954b4560a7241f3ec1921a45e8eb396514563d0f7cb78a16f9e09326d8fe05cab3117ab8815bcac43e6ea77385b2936e0274209c3f23af3e219709807a07f10d6cbb86824555d12462bb6501247e3b95ba243c8e7bc82c4ea28f4d6c805e2467701e5c0a45c48be7e86f72b564773c116aa28d8f426507","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
