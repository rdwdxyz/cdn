<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcf3f649571672df08f7ecdc08ae5bef1109cf42d7abbaa8dfbc2c10e1d3755d1f69cc652d81a5e41233826fdc15a14bbabf98e3bb977c0d34b7da5864dc39af706b1945b847ed4f5705b74bb445125caedd0605fa56be7bfc7a6555ddd897a344c2ff64b371752e0b9ac473c38b8081b4dcaf698a0b6ce504c920a43a38cdcf2ea7500ace4f0eae3e4344219ad2838303c5b7acb0e9266cdc5be532133c1abe03e36feb43fad7ce250c37035489ec670b9d616eabd8b03fcf637447a2e2c84d45c5d4802da8e0aeb400f472d5ca09355439312e3e16a86194dc667afcc044dc5467e2a53f9c09a2a6a477159ea93420a9c02cb165ad541096e705284baef96a41d94c9e09e6f71476981454cee396db77e7b804b51ae6df976f7fadff57608442ccab10004a408c89f475ab78fe93ee7b47381ca5249a3522aabfe1fe54c1295035b51a54608da845373a482dfc8604d53d129015d7a4570759c5c45190b664c18bc52d5b6383012160e83a8c7938a11bb3a94e12db8936f221bfe01f5c518b58e3c295f36153cb816823e9089676d6cb20f82fb1373be873f35e31757b9fdeea522a2486fe21d98a40cb683880a5c4cf63cca62e3203f14588d99fb2eb8278fa1bd9099d9b8e2b1ec3b8511dbce02ac0ceee1a5f93c4997fe6b441895cc121c1b95a144528d4e1259e6970da167e643624dd881e7adab7d9090e84c433690beb099dc49b95e1c2e697b6aba718936ccd9a5ac1cca4829debe1a0469ca6ada14cba5f4d283e6db38ed77f75cbda6d0aefb55423dfcd9e8761c2ec94907d5ba0d0808e34c320e567210cc4d1278b542e660a28ff87b1185452f27f224306e2a3cc16f518a5a7605cbc43c12470fb4b40bab65f3bf94d9632733e7254dd5c12acb175f21b6893c7f5e88a71eaea68a04aa491593a8aea558f8d74a3382dc16c9ac7944e8d24545f25abbe1ca59d09da661c7d2c278e910116eeae2f477e556e20a74ea168af5a0ace6b7b2ce99c95078698b2d65028b425ad7e237a0d5099ca0e131891b3139112098506624e62092e308694c30109442ca780126d7f6e29da70d197898776f3412a7e091accd9d2254faa9737fe9a12fff4a27ac3b42c929b497af5d0eb8b34eefab0ef546ec73f023f52b4d513ccd87b888c7cbfbd3c2c30ea4c2287aa1120b968c4161cd8932f03d913c321b7fdc5051928e3cd3ee34d60d6251b8839262d5eec80e1a6d982dde3b01478f7ae28620ba7edd2d0e83c0525ba4a3ad4313e9acf114329b594e65134a6144053b2dd39381d46f35d1127d26c43f403b9f9e759225e0fe0b3873b89074120f43b8feb2107325b509cb5af7e85c1521492b7ac6cb612d5f15bb17ff83c189b5657534eac947af02802d0733bf2fefebe2ce34e1e47c59fe0db875019050f74dc8715a0a747de6ab3a9f41f173626e0fcbac97d6f8d175ce17a578fd19e81bf4a56760df0e245de7116e61d2e9b16217ee620bd717d7dda1e73a2f2b237234acb0044f72a3f3b5dbdd87100b1e519f90e70eae6c4188846ddad83081358e63c1b05557dac895a91fe7c77cb5efa2ba847089da48027662225a33ac377d753041b27aab87372f7f5ed49b803dc8f2e7ecb4ca3b511da8e31491bd26dd405c6191df23c9bbce31f497218a4e8bcb6c81ac3841f863eec096009be19535ce3114ec9ad25bf7663e0e6986aa4c4c6ba39e925d8a68170fbb0d68d556a77c73a77c6055e1eed20a67c58c437fad6a7795352d5992db4d392b6a2da47978a238f7109e95cc0e7dee09ec67e40d89b1f476060b083904841bce1a4545ae35a765f576039ff8e49f2fcfe2013ac397ca971630f8295036fb55972f9aaa075b2751bea9730559dd4eb8d77b1029f6b2205e6fa68a3673d063e3945d6fea58ea2782e9844329947a37e3769ab0d2682462077cb578e775839a41b2cbefdfef4240abb400c68609b7f5319f016e904dbb77f803bc63d00009bdba5c26f04e53110e6fe6f32dc389323677391e4a22d55e4be367ad294beaf2f3b8cb6f56ad44f3582029d7c9437b9eef7e373cabea72115f6eb04997311031cf7303647253a712694e4d2aae592ed8522b322af0fbdf32c63754157c80e559ee5c002b243c1253f869c0ef06b057ca5e384b32254e077c671b44594c285d97566fba4810fc837c914880efba4c35ad845fadba59a3b644f7d7e954820eca28b40388f517c9121ddd56d99ffea418ff34103bf6c8328d3806b62118ca8ff2f80d18446711c31f548287894ad36f08818f882541e1d8a2f3f459748cd2f8ab1dca9ba000c2071bafc0e0c94695a1237cae44abb9dc168dea96ee8398d7dd3a4153df4667f6d690a658d2f45d8cfc59db48ad0e95e03e8b3024f89b6ec535987fc189b0b4c333f2e59329b591618de6c0a8060534e04fa8d0fd6e5798e6ae5965656f2a453b9fde13c41fda0299dbd79248f30c3a18a25e4e455f0d74abe5b7181f684b1a10b843fbae7137562035e07b9d5b15527826e1e716ae0ce3dec14f8e715ad2df5d122eceda15fab4591452ea7b8035b5b981bc3f6b668b86d6c8ed7e6bc0c269c3d511136c918b143add2df722bc25a7d3b777702221160aa31b8da909cba0c81e6268be158070920bd9d4b1d697fe27f3483d6d9d91d94c3135fe1e6e15ab9c031d578c5b0d9eb0b92552c32ca8317cf074f10092f202126f9e1b479348931deece46320aa49b6f3c3073fd540dba2a15baf6ad0deec7f4458bfc171f749951e9281fd4fb48b2395b381010d00ef91ceb4ca7809e7c8124b2388416bb39d89c6ae85551faf3e830d0f30864763e7d6cf116bdb02a04ac659f8d9a5a28482be28dd028a56aa92f261597b5f922f067c3c9c835b228ec36a191582f2ce563e9dac707d4fcfc6443d457dc0301b2cf5bbc284a52aabaa40ad17c24259c7767117e6108e61db9345f2583a3e1daf41cd951a2025672b7edf55c2cd435d3ec31ad804d1400cc8aea2bd0c763c576077784b1530a3d9fb132e8ef4be0044eadc5a3700f6609ae8d28cd33b02793506a8f6348797ea654ca315a3b016ac06d0900c7bc8d8b3dd0822485e059b790a6444229d452dc598ea94966840159a9cbe0a04319de4c39b681b633587b325f28863f821bce1f4dade694bb110b501dc2af0d02745c6de54993fe4a91b4d4baa917749faf013cd68ddd6e08d692d93d0a75325aa1823363a0449f8ae0fce674af9d4945928e5e1156c9962cce0ca25822719d7ad667bacc9d5945cc8383a1fec96b18d159a3682b2ca2d970613952deb841198cb0a0367f2dc013eae5458c90dba32daaa6cc1ebb06cbbaa25bc7845646d8b54477019afa89c755a84c710a0f4588a71fc1fdadb54c198c9616f759494f8cb571856d959b2a143c9fded648684bdab1333326d59f3d0bf527d07b9db9013e55837d8d251fcf2f86e93cbde852022e8459d52cedf4e28dd157d5bf0a4d213e8f778f97b5c2125879b56c45631e48ab3adf38d5ec9dac968a774100e103a33f9fa06726d7cef50b4005c016010a0b3e4b398fec5c6a466f011ff40a4b85783bfad5a2baefad92b30b578795a1d97f6f9005050bb26d5968e0695afbefdd812971213c956b896994dcb5def9e65af0fefc1e3ef38ed48aaae64753243faa602391fb1c37fb71438a7fb4d1f5db41edc9f5be8eb37dd12b7adab5dabeb2079cca98ef5846364bccbe976c2df57b0563ecf2e9f4a5b1b17875cd6752fcf6077433e2f17212b0b992c6435e98ad22f5dc35b34abea383b989c8623b6ee073af55bd146f959dd384d35bc238defecc10a951381afac968ed2fc79f20e95077e5d03d5a4ae026a7e8369880cc8df289cd1da8461ca7db4ad3569420711e35c5c0def043a4dea243c9d45b73c781bb1db00a142a00a0eb680f4ea43d7ef49a63d6b141fc6b3e8b170427e534e23b9326ccc37e92f72e56284aa5db09e114c04ac59becc07dfeab309f3a32b383c4dc762e99ed6a97bca07808bc2a4768c2a28eb9f02efe8b86de92856a7be91ace969a3d4b9763ef88aaab32cf12889dc9eccbcc311158d4ec1729da4a9e09f6d29a28a3082c5e5cf1ca7f17044d5bbf308309620379349a8ea80e36043ec36e896125f65e28d08317e6a43974a3a35875256e788f1a06f25774c11ecac70c6995ba75757a2bf551425d173b9eb945fd449120a9d25203077bd0d92dfca55cec0cb87011a6dc144d9d114d60148a4c4298caf60fc900a323b3b0a0f9579d1f13ba4cc40072991c9931b2e1ca29492da72eacf4cc44b08b9279e70f6b5ebecd9c362d6a0f7b48065c52ba274d1bb22a000542e3893da1f5262c83197b28f01b16a775987577225bd487ef4daf75b90d91bb146857c52a9f72d130657e591a899ee673049f23fccfbe727d07dd33f568c292ef79b2bf56325f669dd710fd4c5bf180bda8605a81809ff1b4d46808abb3513c0594f11c79a6577898ef4c0fbe887c3e5a5731c4420c35af4491ad56a52fad439d4d80a1fe9dbec05ad74ddbb662c65d581c23aad951e4c5d946ea69445c8d9bc8ab717c0be5706c3a678eaa6e0f664fd153c2b2f659457f0cbb43d2b02c343121a900a37ec4e1429a81c36b2f3fd8a86476abd742be242a3536cebb3085d012c7bf936d1560255631153094df16326c0bd363522b243f3a99caa4ad53708f6927c810f32e767e0ddaeffa4f01a12412a34f5fdd7a74f834445ff2c7ade02ace7971a649427e5a1d6a49050af1944f08c9a0e8a911a5c1649a803516a3811ac9c717b3fb954afdd3bb7ab224462b04d98677fc58e9e1fba82fde3d1d0738cc995ee956ee33f3e174edd8964c77683ce583ea5c9c7c5344d7ee4bc94ab98d04674a984625e7100d19d294e1eece71ffb5cfcec08928077b1da9862b9486458f28ab26e81b9c5b19e9738bf4822210eddd0dd6b31fcce078d7c9ada3b91034de18ec1c3f50c17d4b1484e55601804517522ac20bf957b71eca59cc570f3d4e08ce1b13261949abcbb8376680b59daaaa499c6b7e791d7b8a32dbed624170986b409a47a6b412b2951d29cbf9ea9963fad10eae09fc069f764cda9270587fae46b454a0cad3f3d82f1a7f8ab90ae44f20f7a533854e505bbfdf406966067b417a8e0a664e22a143ea6cd0b0407f26400c31e582fe37575a9b0084479929eee64b2c145707e4c32a243fd5e5e621f160117deb056b950559ec320bfc6b6da81b202ac2058f7193861ef221f144098d7efee39f44253ff76e71ee5d438e4a0861448c382799a02869ea45e0661d74ae8ce87f48dbcd7948eb911c6a11ee07e7d0cf11467a6002ed456809f19822415cc0a3bbd47952b1be95e5127164f826e4ede81d1fddf0e0aa8be2ddb99d8cb7492a18928c38317252f13211cee2b2698081ecf6ad228449ad78440cc99a2130bffab6581d9a77d4722babceb8a6aaeb632b5ca2bdeb22f87bf064a98115baae79976216d716d4d3d1e2d8e854d8fd99cba8f3188599e5944ca0add8ff1a1d65047ce018779d165d6ededcbf4bc752f16ffd985e90d4afc19a99cd1cfa99aa142748d190aec737e8b524f823a6cd8b9bfb8fd1368913792e2259a700703fb36aaca42ecccd82986ef4e1b28ef1853742c2e8cae1544a099d3d6d5907d2183db6b27814e1e8ff534693b1cf3e9e6a4fcfa69fd0afd7a64ed0446a8a2b64feee38adaf8bbaa4c00086c19b341853a9f0751b88d9cafa5681a7cbebcc8553ac860072b03e17336babe8685246dea4accf10bf59e1f4405cabc43c16ddf20ad574a87e791a83c333b8beac976cda65c4a80f90cc53f7583fdf31cfb8783716682161033f060e8427abf106084349ec07907da39eaf27b2f75fff057868d44b8b83edfa9fc67e38dee03c4aa38b06ca6bbc05b6f9e4f97a2d07d0688313cf91840af464d627b1ab722e7978e971a93442a806948eac6d1264f956e142355dcd4903fba9c912ba1d9ea1b192f53a10c0f66242ce8410eebc4434d582530ed63b577b86170ffec82a68dbded40dce52c0b0de49aa47cff7764735d2ff0b0a53841f8736c4e032e9918912f5ccfd3b2a0aef3532c7ef13de8a38f281559fbf5a145a8a629e52d7c2704e59686bb5feb70a42fcdcb40d8b270e7462061412cbe336a78463cda65d8e5859a7507b1b6e83c9e189c820daa3bcb2f3e1b78bab18ff81bfe987ff38e70985f3fdb04b7dbffb4c416217c47f0459de85f991518950cef00a972baacd77cefc23abf51abb40524422d3dc2601da36d8ae12f23a216f01211836cd57019b16c15e8281779d095520ab147ee520bf9cc4b5c6467c12592f1e1bf6b1bff36a49374a9f146cede8370b4ddfd00f00b10ddc4e9edc9b84e406d019db00d99799774f496fbebf4d654eb745e6f86736f57b9670cd346beec979a8ee2423973ddc4a94abb6993f566f61e4d9555d674631c16c5f36e11b78c140914cd7165fac33965cf2628158937dc192256444fe3bda7b79c7ceda22100534bab935251d5fecc4cc13771d83f82bcd8d4a80e8818c342db398752cfee4f516211e52f387729b2fa3b82ebd0f3ace7b25a4864ffcad43a06d1783d16aa2e8b0858792dd140b2354b7a20db3de1daa3fac2526246c7403eba85a276decaa15886b74e1c900f8e501903b272e113a8e0f759bd02f996f5fb6e9ef403d6d651dfeb8682e48794fef3ab07dd2048bf87569691d0aeca19c228c435fc9003950bcf09f681b4c009e6b4223a5eac65a2bb34fd19254bb7131444de4956a1fc5aa8584f276b4b648ee162bfc725825fd5dc8edc0e0858d2b1fc0eea394fdb75b21f941b4cbe2589f5f8bb90a6664e3e2b194f0e1b8a4035411384cf51ee0e6f7f605fb0bf53c228c83131132f4f1321de20d85fb361f8206bb9528d423ddc9512e01fb3d7095f168d12ae7fa83732f0d01943a3721f30747d35556ee2858847b4d48e896fed43c574115792594e1ea0c3e686527804c41316dc691201c00c97a832c58a32787223b8a1da466decbcc052fae25aa52110b083a70c1d5fde84d416837ee2a23856bb923ce5dfaf82bd669a43650d91333911f1809d26442e9218212991be91918978448a6d723fd908e5b5b12126c1d2d92d74626575294c14abbbdfd422553c3788f828a132ab2d66764c254b571f2b9031bf356e979ac80c97ee1fbb40fff6228bd9ca10c6d34fc42849b6f232f022fc92e9aa1bf79b04d6932372bf2b7f2e72ae9fdd2927fe5402c6ed533873591c67e0d0fab4678136499d3d49c64dc0ec49857254b26a6507c088051da64cb1b6532536513240f33c7b6fce461d9cb9002792f61b2f6a51037e36d97e43b94d94fd7c6453d77e1850ebe6ed7427a88a703ab15f926c293a5561b0b580b1bf56c05383daa79edf8184945f023eb0f2d95279a3e0469f10a426014c028e1d4feb0edf18902c641809d3335847e902594b2bda7f677d598326bed501f7172eb9b9bbdf071185073a3c8b87da2178c7bd7dbd390bae8dc8b9238108a8d198afdf186be4dccbfac15bc42e96a7a3dc14c2d19a261786269869b2aa0e5c978ff178eaab64dd8393da4d1a37ad5e107ab0d38b7727b6c210d5e329e956ec52f56551a896913dcc51bb6bec8e150e8ee426cf7b63287c6e7797942105b200f6c8e74d20c4d7cafb9cc75cade2f3a9c72b4dc6b38889c4d8e2f6b0ccab0cd66dc260e726749bf59bff4535f5e66619a3b1bbd1d02b29c405d8b70a52ea1bcf7e95c7bf6ccbf15d7fcae8f1d6eee411aad46bed97a1a456b097cd403976d62821f17c8c56a78d99fe9d36a35a53f149b96cdb438c2eb6687e6f4684117af1682774a72d961acd996d6a175ada9d7d11b0df8fbdbe6c51a2255dcff4c345f2566f61beeeea99d19c86433e702ff4a6b9ea65b8a2d8ea1123c1f3caf24627da355b2ed5e7191a862da1425fd1e53843c0fe726cb83085a67c840b53b15a336ebbc5cda22da97cac7d5c19b0d2ddaab0512e85fb6b365ca90d774f93395c7e71474891fd509a3800f084e4ef73488d2b12e4e487e424007f95ae4464b3677d7e1d2687e783148ab161fedc8b74fcb5366fb953a56748db5ba0bb250d254c3f18f4a0c2fa9a81450a232d685307ebd328c4715c8ada0f51059fe379fb1952316a8cd97db461408bf007ae87c22095283e18f11213822247c37cf5a650c548b3436edc29515138b4fd8dc287e9312232ea95945d03824d45258f763c24a94273c85e77ca4355e1ac39a28d6fa674968734ba19cfe57a00c2ce7baf98cd2339a73592d1fd60450f8f7562a49618fe13869c375d4366f0a2753f5e80b2d4a05d9da2d6b533d3f68018b74dc4ab53692d57a0237038a5c1979ed5499fc645d5db5ca9be71d02193546cf00ab168e7917cd9626a6f313c03a8e157b555cd3692a24c60ba71a78b53de7c3b8143401a8a2db0319a06060ece91872cd0aaf7cb6ce792b50f751baaeec498c9ae0dbb24c20b13717da60531fdbc58a44a1a1effc8489752c050d3337c76dd412a3a66b8c7660ce9831f9328535630614f871f83c671d142ddf704a554cf7d60c9d900a66d55e973ef557ac321eb7bbfc0b24c8d332c69996a1362bcf7a8807681e6438613eaf8fa1a7bbcde81fe04dc353695ddc96320a2f21b3c578008873232b41672ff8de8e4a8996de275c9491e722466f668ff071685bdc1b5c7946a05d9e1d277e9a842389de95b09ae52483a6571d4b8d0f482b18c0633b05dad66fea4462627ea9290ab66f4f2cdb1c7a820ec44b7f43f43f9a13d6e59c8574ec9d35c0f94f8edcb4c06b9b621e72ccd621de601c970e64f1a51f26f6ff1e8d605e2c660e16b62467c64dfb66308a47ab26bb8e64dff8a2d732ccdb25c7d12908d9ef1b4a37f261ed1bebc9b814622fbb9b6d8451cbeee6c2e81fbddd2b9d823a784cbee8829984c97bfcb4642a3d34dded17f742a9c59aa6e6292343062be55f61fd73a2b7c44cad0d574334abd62ca28a9ca6ab8bf3221f3c85ba605d78810771a65cd3ed45362d5987741cdc0310383c41dcf8e4f304256d79033cdb6cbab7d143f8c3d5f0fd133368ddf8f2a25b09fc51119ff09fc48263a882b941a6c01eda19ec0fd12d72a57b2a4c6de4824f9a13fb7b2780242a315f0f31f0211393cc5c539ea2bc30e2c66a22c77077416c20e74fe66984107a4de18a7c0cb94dd4a9e8be9df5e211571832faf508d89d15d15bc77d7229aa0c124ebe0184ba0c2bb07bc7cf04100ac27e649255681746a72d7daa53b2867c92523eba5d0f4a15c1d5dc474b6ce50c72717e8d85aea12e09174d85af9b1d09dd6ce4d0b0f3b4776478ada4c00e1b0bf66d53c6fde77d12b00568998a6c5bd4872aabfb64a237a3f48261beb55f99e360c256f0ce14fd65db5c44d0c439287359046123642854ddde876b5430eb025b388b4db01ec0467298ec03fc7518e7652947ae99e2a2b9ee333e08a8fe56d15a4b276554be589df07119b9aaf983250b4c541ac8ca9bed9d05c4f5d1e2e325cbd668cbd64a43105d3f57d89250a448c64595d3b00de30a38da7ec602c27cdd02a53d9bb4bbabddeec18024942e4e7770a3d422628d33ba52f71acfd5dab3ba2283e71db4cc01173b20bf5ff85081f380bef08983cc313a3b61d8d7f17a5b822d95090f89b1862138e0874ca49137a7c6d2d3eb1edb900b014773989c59355854b845832f2809286093c928e972837cbd2f70ab9206e2fa7088b820e258cbd4f9cc49b5c8d799743d7529d4ef3796f16cfd17425b03a28015f98a8e54749e5b285dc769ba11f330f944b055d5cdda14d371988f0b4c4659105ba2c85cadad7b4a2d55ccb74c252f0454fc117a88b9fbe8756b45a163d58b65c7f7dd7e77486cfd3ffda1ed7a67958f92a89da893087c4482eba0d92457fc0b3ccc2c613f07fac5c6fb3a8a9637879158287acaa42e726b5b15695941a62d9075a40d67eb8024271ff55855e4dfa6bb370aa151c1b0e8b1419119b3b20b39720d7d5d61bb05e831459256f916de7b5f43b742e74032f770cae8cfb3d4b99384d3700afca3f8a107e785083e4b7e341bbb5b13c389f22a0139eb310a7926566a5aedac9c752001f4249d7a9f4cc3ad57eaceb5c8f43bff1840be421bddbd850ed6fba7437ea1b840aabba8f031540fd339db7f767e75b571807820966b51a90f88117bee9fb5330aad2e3cd6f66b375edf2c26258e35bd29f0551f8a725ae12ec4ef1936a1a8208de7604edbe239a1280651a35cf959ff683cbe150f5fdf8495f78d0d8cb8803ed50f90dba8eb8d4ae3fa03d230832c1b3c0c3cbabc904d5b25dfd0c054979ee7a95c9259191c5053a4675b1e70e162f7045706a6ed2fd8c8d9e562de21a6099040c09ba1ed44410299c39a6819fba80a04c3f3d9b6320245fd0531ef962ccb4a6e6c15e3b9ed5451db390765094555ae9bd544b6e7ea3aa84506d59ccf03817511677db825e7ba69dc54f48b3c3d144caee3b9a952e002b58f5a75cfc41863f3dd17c5cc46f31334e6b481c6ae5b76e9b7d30876befd915cfdf154a12ce1e3ac7557d7c81192bc840933d7f49c4b3e21390c6d812a45198a949fc5c7cce9d2e867702e6565c85e19fbc542e8e6dc51bf69551e49f715a7188d391d97246cad8b68822b7dcdcfd7c1d5971251bfbf3eccc1b80da5144497c9b02f806cf980bbadb2f3ca67c54a4b2aacbd52565bad1349c2d14920a44ae3bcadc4f33a44d513b2477e3103c29dee93e9e585eb17b4a7ffab9a9e81a2c3ccf33a25b99b96dff06daf27150bafcecf6bfa90da88720d82f0dc7c57c7082e07a2f2d7322f3a942694ef35e8e0ee6db08855b5e33b49c18e12f70ccbd138ba1b7845e41c442e48d1e02769f56a4d0178901a9571f91907dbf287f2280480fa72feaf93317de88f880e083b024de572f0d697ebf6404a734cbc1e5fcc6c41a0a7e1eabedc18222c64751d3f1a5c402765d373d7ca5b97b4230ea6d47ca9de72d49a311d852bac05669deb24d284637b96ce12369f6ee99698fcda49e18513775dfd17d63318dd36cb9f98dcdb30caa2a901258a90aad9abdab9da110d176f482279c5a2f35f44eaef93745715218c63ee704d53efddaa14eb0d1d789660f1125b618d852c525cbc7168243fc5db5bcb625d1a3c2fcbe7dbb41cc7c7f07ce96961d2c3464233817c5b1e6e86e7d01870a5da8018f39d2588753bf6d3866cc638816383dce7df828233c38a30dfbab95686969f0f23838de934310a00ae855abb2b24266277509cbb41c249a6b89ea152c5ae5d375f675c3735e8efd9ee920eace4237423a09bc566ba4d9a959d68f02170c29ba4e71c54513c51ecc42af85b318ef360066654026626dc797b14748466da7e3d7246d9f986f67334c41ea7e341a1c89d55d8e3512aa9bef52776adabfee6bd106fff6ec9562bb5b3c767d30363813b33343536e7f3cd055650c2f1c3c4f5f68759247d1673602a67fbcdc688cc829db8f140db96f5132aa1190bde14e58591acc19b980aa6ce525674644b7b8b47aae9be385b4384b1ee5de7387bf481b3b8263fd6653e21d33f7d4c9882f66e242d112ee1e241516ad36185dd5c981da576f023313eb3acb4015906992c6bfb956733ee49efd628db3a078a2b120da2b6f0adbb7d643aead93dec90a2704d4d9c73c2b8dc9d28132652a5c2fa8f64eaf4fbf61cf69555f5b3faf889bc0e43638d86e4e3eb220e2a5d25f23f49ef65f33bf62ac03bd79d5f0a609c98686637ee3f34fd0d7412d8b06d09efe5827800b75e4e75e0d6b4552a38cfe431b103318abcd38e4eea36eefefc1b67655c21c7367d582c54a607dabdb7a181a456cb6b48299492991763c2ea404aca1a7b2e6c2abba73c35efbc72b33ecb473247d1d7bc11da0a31f3f82b7bdfbe735d13f1a5fbd30cd4248205ac28776d5ac39f5a79cfffff8e62f6512f4194919cee87d5016f5ce555113aa35c88a579ca58b67896eda0e81f6beae414b460f51f0d9d211f0d621bc52462e7a839f9296b6d3527a2677287af6a2176df38f2f8abdf8064e90d9474a79cbb2ae05f8c800bf92dd905d6d3c29e658d0751d7ab622df24fee6aab8e623278c3fd910bc4dd287cd42066e28dba13cd8943943c6f24176e2ed77d589661a28540a78a38f87ef1f5d66223ddc08d4cb9c0bb748999f6009fe0d76d79091bab32b5df39602246ca0d7d824d92ff042acd8e2c03f32c39bff3a6480977c9d49f4edf070045857f1ce31d7aaba0a42017234ddca7c7c33f5b3230c64e4eed03c6e27e9d918e4ddd4bf987ddbcdb1a3f613331526078e6a835e4cc67c18d72809551e1a957003f52acdf03194bc0f8f9ea5d990308c8bfa72aa9dae61f43eea27c319f9e19c59c96d46a81cb90a822adc6a24c0c725ec265798165d58809a56bfaeeb424463ee691a9e56de43f0380a26aa99e2c11784b62038cdad49113bfcbbe7648f525bec2caae2d3553985c8749065ea0f1ebfe9d1b310e2adc28d9380c604a4242014b8875064b7c60a005373e685d12da00b36fd69871ae69276d0afbb74882720fad6f5c4eedecbf5239b4e4f06f847ee4b5ed3a1393cc70585a5d220f28a3c7cdac55223e1cb5ff2ce023c740074d4b715f5999d7381fc780de99f97e962b85f9317efae429716859e5b7db2ff05c49a8ed6fc64f41fe776d24fcd44dbab3b12155f07e00d2b4ee1e8d70e6f42f452913c00db300a2cf4c8da32dc498f2a4338880fc97a5294aa501a0183470986ec4eaad8c6363b28e37afa68b5925ae07eb430ab43836e664023e4a6302393421f0954819a2e5cb0bc398f7731f615c2fbe3d9f203646eff77157f39facc68e5f4b1f5a4bdd0e15dfc59f681503e415d54efe26ca77168cdebfd48fe9c7f4c3ed9b08281c436fa9632f83c87a5f332b8a645db73b3348beafc8449e2c14808955fb379f27595f1c280c4fb54f44083b2c101760895051461c5d9cda9c6a84ab239d169861732e7bb6d47dad741f1cbc453e5b88f89788f3984ffda55d8e90eb3ed95aa880cbb9c2c1090b778d8e4591f35d18ecf48827e28b6f839575f96eddd3a39cd188d3903dd6ae18198db053a471a1f9cd738917a93bb6da5621bdaa6bda2266129c3467d00108b939e759ea2db2bd82e6298fd59b22d48b908debbebe4249bceb02d3cf9c2af6d7f04921397a16fc1650bf339a8c96eff176dcc1ee830dc757a8cfd8dbb229f6ed784bbc7fa7e0c9694f5d2d7a15027fbf3af0cc6c2e4325e5afdc2dd11fab334d3c64006082a4015107e87900a3dbc3f14422a032a2cc660210e088ae116938f61b40df1e62cbbd4b4b50a618a32a903ea9f3ea6152004e397661fca024c2d59831b13cb0aa441cef9a0961feb7506b87551ecae110ffb8a0d920aa49522a8e301db6ef1da98dffb9a70b09a98340884b788590c5f9d505432a534cdec856e63a83b1907fa5095cbd3cb7f718ef5182a12d88e87888f29ccbf69db3d70e455e7945eb22ff12489523f92ca184570af3b99c52a8cf3e1f035fcacff7a1adcada4df35cd0a4ba8f84a85d15d22653d1a1de20df0c13742e92a7b60d20998531345e0f550f1403ab99db869d9eaf516aca951ce158cdda3401f73d39fa19b66382d911fb52565490734fb1b3ed29761d3edf92d8e0fce09fbb201bc6f985707d0dca2723cda8b4e5e8d0ef1f25ac7b536a57ae6db369f7538203131481ed7a1db1284b27ef8127e5dd3269dda8ce7a6b39b6e98f7c4b04227904a6349e27b4d99f8376280303b82ab33cefce6bae6a43d227bbe973b477c3aeba67875d226c5fd39b04f86277590bb7fdac57dcb8c2520dfbad22dd2e3151d022a980ba040846b2bb60259d20d749f6a71793431f7a6e42dd2202f2f30c774bf793ef1196c1e3fcaab9223873b93f1783d9e1aec85892c6a91ed9a198a913a66cbc14edc6f94ae66f05b29d9648e622f7af1a2e51559419984f19bafb532267d2f2a586d8f66dfd8251abf28ea2e2494e307e748f3bb5955fdbacb70df062b50c878b2eb85698e0c1a087b7b4bf1488097123e5b3bc3a369bf645e109f3a68ecbc04974bc5730596f4390bb6fbe0a0a8a5c6f78cc2a6ca407b51a41f21809657465f587fb28eb7c3726eabc90865b779fe037414870560edff57b33cd641483c6134b832b3b34a89308c0a59a554fbb3457c8dcb645a471d64777c1c7bbd558ff6c94a49b57761832c4cfcd7423b0f2bc33c18a516979311df6175a3c2ca753907707513fb757e460824ba24ed857df64b6e3c1d52126d8d10646843fd9b223b45a4bdc96656a56f0e03de92a312992516805ac88bfa0f2af1f4137e87ea925b65b2c21e217e6f59a1b9e4ba887628d0c93bfd57d8b803746416983064ff0fd6624b23820e4a959a04292d649d255d8c7df9dcd945ec3578110ec4fa3244051a87097beaa13f208369231f00dc5d8a96eb44e2a78e258648e9eee0d508b599ee353d0eb8cacf1588e005a4fee405900df58189c23d776f03e1c66975c5a941d0c6b65be39403a3388dafc7ffc14a0800062b2bfed84dc8d92cd620e13cb27ad7c52ee1a8afe659dedf9783c2a7df42ff09ba4d5e0b4149bc0720b39a7098af09c8f71df03ba4776c74a531baf3544fe649f5d7d49fa5eecb5d59d1fbc5d7c46b8581043f5f665fbf6dc930565b75327eaeb7cb632ceb27f3ffb121031d7f2a70ff22bed6ac6dbc573e62b23382a24a260968481d50505c3c830f62392df0c3db6ea0b461fa720532ed94f202567c66070c54f53a13845996ecd455674e1ee2c562a7888961f507657f6172b7397754322e2e761b51489390438a0b95316431761049337bc958f6ad7dc793791c9244291617787fc4ddeab5144634ce7d38e7e7ec3c9139b766e61d7f3ec02a4835798c7af53f332097c9d7cbf730680fd43f025942a8b229403e8b02277fe4a17a4db549c7fda74f34182dc42e3f8834a913edf8e1bb16152212a6e6af24c0ea5180b0b0e9413c9735d9c7d0c76b957d13182a60e7f70535cf8ca1ac126a653a3c9c0742332836a5a6be4813e2bfcdb68fb1366bdeb31b65c271485ed273fc9562177d91675c8e13ccb12312a3c6ecd90d196d186d26d2cd1e1f9603a386fd4ba6223841f4f6374096a7918152cc250e928fcda38b721d852033a14da1b33c714c15e88d85c542a2429e5d66d99d34f8bff09b59a7a4e2441e757581bd2a7d176851220f5f96456ebcce49dc0c7a7f2f22e94af43ba2d6f124da90464d9ee8a294046fa7a6a11e9f9bfa73d2241254be51c58b5b0240f41475872fe4dce132deb699e225d6eb1965e9811daa57ec6f4b983ba240cb721bcae244a33c827d774db668553efd2e8571da9ee9204006cd5474fd339f4ef6602a9b2b76a48858bbea8a3fae22f2bece380eb0de606c9c2c1d7d31559e1252fb7679c367658b58e28bb5512fd25adea3c6d73cdd98ded66d3fe6f0f9360a491fbaa918057c8357b9237ccb1d0041f7abe081012bd94f4c9942061317db0f530c20f29aaa6b69f3700f49698be67b5736df05e05ae5346cc512beb4f53ea16d75d04af0092c304d28eb4d10c9212bd5604312682e3d8f8e1db60607a759004f390ed75d3fc1f63254c4549a8ff84e5412ad707ba317afeb22b5729545724aac0499653cc0e98c3c0e94efb3887e271abaa0e8e8cf633600bbe0accb4ab101608f9da25f77b529b51011d007e744b27e5af212ad39b00223d293f9ce6d4a2b7434e7d5becbc2e2ee1f4daab797fc2118eca3ade86c2452f298bd6c8a1311f126b638bd7bda6ea07caba7c4d7347cb0a984b21608b229e66abc79b71dc2b78516b0aaaec990f47cab87412e336464be973cfde1b48518722147505d5f01a220108c489b06f454b0ed6b4b540b41bb3686e6a81806e44fcdcdb2ad2368122c474b4f30ca8b0197f2dc366f26012eb2385472fe10fccb750ca97cd79ddd9732b524ccb4bc784db696c6ad8437e288d80b160ee9413490c3abd2638e458765d6c3476faa07a6184b07e082e1b640eee2f20a32866c5a2d574604710ea36bcf6a0638197896ca4a220919813605c07e3ad9487d82fa30fe7d05207ef28a50588df83e9a994af600168d2b0ea780e3b638d1bb3e6b234c00130fe7bc5b4e20484f17e9663490b9cdd71f3ab3f30c623065e41d4a444aa3a6126b1aff38f879bc875944552b71c11fa0d0cfea47f602092365dd38979f6d08167f17c0156e56d3abd5bd08622483c6d54c34b838f6235a05cccad70773f4d7c7febc9af9fa1f09465545b6533c947e095f5b83f31c3d81279ca347e320f7d683326a7402528752e87e433bc31d79f0b9f7b96e7a3190e4751df630b960c98b3a2b8cc5330abd38b0efe31afe86600a4f2df913347be98b2829c224788486a5cc1b1c78b581fdf27f49260a112eeca4ecba640b59f0573cdc37414d563fb7e8bc4a9fc9aa40cf5a8add370f68e9aa30eaed21e77675b24e931dac9baa54f7d0c8cffc15780114d319254250bfabb7f364f8fb35d1538a07a28507a781ddb7074740bc5d4493c8328af8ef364a31ad4a609411c2d99771de1f0aab0716e3280c07b12074fb0d1ccd763c9c59056a38e3b87455a2fcc9c8602df50303a63d96ae920675a2e26ee28b9c3be8ea596e4a7cb1a447af703d7a0bb39c3275003f203e108b1b732fb716cafa778286910dd0db7231d8e7168c99c0487a2dd86f511c23863a320ca57ddef62f55dd4d9b37e8188168c7951f2e1925762410c8607721142022947ad357af42b418b1e0a20ffd46075b5fbbada6068ee7dbc54b3199f47715da405098466794fba4a7d67e253e078e66de023b38015ad7438b55ff4d9661cdc8c097de611d8b2793c24c8b45d2c40b814cf834177763261d2ff66a67ed0b431df6bdd2389cee2dcb207808c977128c7c5c30a968d11bb535c9089f154c838e07978503019811cce8e315b83d87e17a41e20f753999df478ee23bd6507a58ae644d45f2b3301caaa36a045175e6f058a21d86425673f83478080aa7dcbd435d16a0abb532079b027ff3939e1ad4fe6d30829793d706deef7d7726c3219009cfddefcf0c90dca742e76983e0dbc980bb5246a87be1d50af9981ded395bda4439cf17f362b9a3a1b9bdba03275e1b8857a518d36dd4d8e9100f0894d707ede7094002056bd849ccd2d96dcee83e6a89a0d369e745266651c7c82595758e8147bebf1d7fad23e0d4cabeeb1c5953f68261f2aa59416e26472ff9ecc33383393144baf3e7e953ff2337a12cdab0d5278a47195cd6a3d5263cd97c6921f59ab87f2efd6695dbb2acfad0ed795f56ce05320618bc1e8921acb13d51ee7d23d3d8087d405be10ccf6590450c004ee193873319d25e0966b88a694176b1246e04e3cab1b8199055f6812379cb099a4a1b2289ab67031e7b0e233abc7908b47d23a2301b96213bae7417ede05b323870eb264086ae2a52df9560414df3aefabbfaec1ff7fdb5f8c88d6d0fc5f4d510ca34f4384ba855891e5560d32393eafdad0bef061774fee4add39ed57bca204a40c8a09fae63b260e275f1cf15a507d4d899ee7bbabeda6adab8998e7c854e008f271680f57f3376c5d84f8d53f9da1a2a62c7c2670afbc677bc32c8676d49c8ae6c2666eb2ac735e775deb275e2bcae9b1fa48fb5ee270a67735a9ba636007319aba143cd579c99a1115a0234cf5313326e044e2bd9d30054c6722dc2e7cae41c5b5191b3f4c761064b3e676541208232a3f9f224731544b60b352945c0523dc5cd1767aeefb3bec0e374e07b854d47f72713a2f80f5ee4a12530254a9af1e2deda34c9dba6f4ff85603acff534fec8a804c624bfb062164f402fa3e49e7bf0ae407ea52fb1a7f98360b2f6f3dbdc4883edcf34d06b9247106f999b996374cea813eb837bba2ea65cb88ca308ad9a5c824f28ed6adaaea05d477aecca764220","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
