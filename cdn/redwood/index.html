<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"156a058f1ad869ceab6cda43d34c91038813fb8973340012173e7c828607e6db2ef60e4db1b8ce74167e5367e1d157f19c78a796b3aee90ed340f31205c6555950e29e2ed015820a8760c4b37e41dba81f2e3972aa2971f24ab75da3b0053b5d5c76077e417b1e299e78f3a971cb214ca7e4906c860173da95a48852ac5ccdcbaeac4da5db7964bce44e78b67af9dcf0aa57a1fa93091324abfcbb5439b58530e5a9fbd32529397aaa28c44f084383eee35057bac9452b9179fa0af79eab1f1f23a5782eb98285dc69ba11e87b762b16cf19b554631ba4a816e6067db1491cf0a8671a96f70a4c97335263f36b743e013f039a16e42f79c408562c3c0f8ee759ebff0a85d2ce88943d331c98bf29c3fec2709c04f9cce967335139da555a05f48220d23ca689f61c98707a32fa1afa7ce944b446004e0890c3472a4b067bcee424f6887b1bf0c60abc61ca968aa4796d1a18f1c9a1869acf70ceb9bb92a1f8fbe380addb7209b96e70d2d218edc8e8d06b351251dccaaf9c339089cc28558a862cc7b807eba17f94616335caf6e937178ef1860f1425ce772e9748b74652991d74ca083b6c63dd615398bcb06ff1b9377694a85899e42b6121c3741ce6d00f5b5653f0fd630b26b1ac231d5af66f112d9c33beef85f4b8e0ab57d59f5660e57de86b2a158d1e81cd81e4adf847077b7398a651081d6f17228dd8ef07b95f2bdb321c05a22dc27ca149225fb3fa15f9fa31d76d191f2e071f8f1a8216ee291147eb409d6387da946b619256d2207a683e1b62887a884e2150731ece07c814d65e16f65209d174e5e865366d0885590af7ca2ff688cb463e76426981f234a570f902febd0089a0b0762a23ae01635cd9f2b5b1fc38c6afe2e08e24e6e669688216ff76f890eb3b956267e50b9eb6ce3ec7b8a669e3229cbb6507bf4f88a6eddded5b6abebfcb54e433528b0c58a393e3393208b104f23e34bc729d13467271438837076cffea8cbc4971b2095c41b330c38f40c42a3ed226ffa178ee34bb13d92e2df68b11f79ffd0e386b7955f9dc8ed4945967bd35940f7003284b34d422bb937a0cce51d1338546119b034a6242f21671851125b3b14dc5041e8881b08412cdea59d4e3f10c5b234466dadbdc0ab8bd24c76d5a4673bfcb63a938b5572e97b60904b452954b51b964f0fafcd4143ff6583fe79fbf452d065c7f4017af132eac1eb524601db8435fd9d2004ae9f7c5cd24bcc85456f62b8a278f5e0d7a9e11ddeb1ab523b596c330a7c687277d2f672c85f74bb2dffb5cb03ae12f1154f3c95829c6ad539bb572fa05c89cad6e4b7420dbfeb19ac0563c34933714ecacce6674441c5ab0543011f869e040b9f09ce6853699e79e8b4ad3fce4d12ade56a3890ad3f845015f85148095545cb87af01ac5792c7a4b4f74f95a19d6b7f6e4911b021ab115967a353ca7d9ba1b88db81875a46eef257c7d784087228637f7bed9bae088502dbc29121178684496a0c09c5d2662606ed4fbd5e24b0530141d60eda582704b01d83e39af41df84ca8f3cfdae5084772b89a9226d2d2072ec4fe99a2fd57611e46e95fa26e09d6110063e6a81d5a0936b06d61188f883a0b976aae03b1f1632df0193450379cc3c540538b9353de5513271de414dc08b4312fea29e4586784663daae16ff8793f57c55b8d7dbdbded65e5f7475a49bc39b9b52231e7106426e419dbc18f47986c337fa628306871f7b99172043c14d5a1296aa94982235e3001048ba60fbee2d31f655f3ddaf5ea56112001c4a642c9773b6db04ea0fea41536fbdcf152d3ddbcf6ff8e3e469e1bf3283c762617db1cf18b5da0c135f3253a4a57f091bb9cce6ebb9e2c976fc591c988b4f75ddf43fe8dc7e40177e10d603b8a8ff42900702de31e7d953f36ade147d3e6be136f7a54249f8674dfb856feb6c92aa1775de5b8eb86258b79c1eaa00d6db2b23c12e82bcbcf8dc40f1887975454211cc3cd9d4879d8110834b9deab5686118f7aa2e2ba85c3a9f3019424581e746a8ae4efbba6b6ddbb4f020649cd079ac241e17fbddf62958d28bffecbe02d712e16d34ba0ce27176b4ec98530ab8e1617472372de661f0fe2c5c8c1452baacdaf5cee1b8f607aef9da06a7df78edc3aab88a1d7ecf2643fe9e79a0a1f664065b1e9aa7466f48cac2dfef24fc003ba5ac3656a86aac0c960c1a1dbd21d8627dedc21db479fa311bda11512554c38f08a5a7f0e9f8b2191dce3f75bd311ce8740d1ba40cb613f4b852514277638bac08cbead5bcf62cd6c21b39f649098ba25f0f5f9d63d5da1ddbba51c432aeb81c35d469dc9acfce260f1e4e43146da1c5479892ff60198bf3ff1a104408a5b447c44e2fbbfffdc54d6d77e6fac54adf395164b88392abb39a59e650fc8e49397934acabec88276d12108ed8042f8f2b1c0cbee082cce6a7841a98486ef637e5b9e9caa1acd5caa1b22dc93a68837b7be2a0b4d9c52d35146f15cbe05cb10a74dceebc910ca91a734e8aa8d18417280853e7f8a504e96fb776e21c388310846ed80dbd711c1210bebf5de4408c6e220d9ff0d33f4de9d01f3b7f45bfff2b9f056fb7d6e260d900f5af52196d5d6384d887d9dacf5e3e235061412bc31657ea6f3cea930c7e111ee4ba538fdd3aa41edbbfecac8aed275704fef88d6181ce923b8e1f3cdf1765f8f0c3a6dacef00e3949e4419a39d54ee7667111b46ba8e623199841e391f6afed32272fe57a3796c9feb409c38db980bbd32ab030b32d44276995bea5f2cb03a77903c92f17e703a430a0a3dc74953c1fbade534dbc4ad62540d42d65adc2da066596692b12d485c932294ead01c6f441bd30417e1664544a010122a36f4aaee666e6b9e1b06bec9e3768c5d64e633205b299fc45c7fed3cc2300ba3e289ac726db4bfb8e42ffe2c4a93939e031f209233976a9b46f7200318781d92b2586158e63cf8829b55c32b9fc72036ca797a7e376de08fcc0d1bf59f7bdc633e4b3f38eb3713408dcc362fe32eb8313f76f0a696d12f84ab3a7e8572a185c7cfc88dd9026b8c1e109bc2f90c60bdeb8c61223dc5ec0c6731ef50afdc1d4dfe375cd6413ba676619d2a74b47a645a083a21dbdb2033592877f367240d7ef7d42a039aba032a43d431ba3746a4a645cea290b1eb0db6e27b02fbec203899aaf92a28336edbad7a5286688364cf8955a069845007a2d788440eedd623749ebd984baef56bff8e83bb487825a7aebb7ce64b56b03f3cbb24b414e125e2dd3ccc536cc3f94c63c612cb2fc0f8f801e31fd68a232df7b34922d71994d7d9ca75613087e844d9db0838de7c5b03f3d4709f61b9720b145017f7843c7922e0946f34da7d402611f3b479fc51c22667819182c363c9968a240e9ecc51273f29aada4f586949800320802f4dd265c6ed476be50284544bad6b521b12ff72cf40f5c413ab126a23e0ecde00c2f7f0358f9231b9ba8fa469b05767ce5ecd72e052a94ae2201cf5ec86bc6d7bc59307aa0ccb8f4843341072060ad869bbdbb4b6264212c0d3e8f979791be375c836ea6ded00054393889be266f233d0ed707c8324811fcee7b24247f6b1b1189944dd0732702e433ec813e75b91e585f11a91ee8fd838192f8b28c348f31434b48724acdc8161b4aaa6efc5340c5279fd954d79141124eabbb5574d15ce68029e6280a9eca68d8f10cfa2286fe8817ca57a48d09e89983538218a8d277e1f9c11b27be19a0cb12d16a7a696f9b8d0db2398f2968da6fa3462e43ba83714ca14dc49de1d441aea56fd86fb502bbb00287e250e650c36538309ff4035e790d9ebf3b22ca1ccd565176639d5a7cd73ddd0fe35a00b62236c359cda704f33de29a7d18e40bbe5d4d1d1bfc29435d794c3e4091b3dc2febfa1b1ac52503d33ee199af68a9c765b8a51e4ad1564802df192f13e55729cb908368a257159b6b1ccddca68c6c6b70e59510949b4f7c5c467c117f2cc036ad4b40f4fce222f2c288ee145e537780a744660746d61403a4b7c952010a5f066cafe2fa6fb7baf4572371cd9cf27dd07f3357c45ab4cc1c4edb1eb33753b4304ed906bb6676accc2244425da0034d06f107f138760d0a3a9ee2a0a4a42bd28debd04dbfc14cb11362996abf6d2e19967f2536d67a75190d8ada9ef054ab3d7be327082dacb2b4b4215494fe4cb7cd9d60c341c62b6013a9ffb4cf61ec0e093125fb1c77c437403c8cb24edac9add582095b3db47f5c8cb31b68bb3d699f8dfc46e2fa75e52f4d586719c2ad134f2ba1efd514eeda60ca6f22efa58a0a8096b73f9b360caad8e8ccee2bcfaa539b08860227078266b50ee976e987e994cd097351d6bde2612a8579bb0cc3035d8154f8e0967345d25c4fe50ba03c7c8ece1e1232d296f3dea3890ddcf27772ae46022d97cbf75513d262e22e4e69f6cf6a7785fc3c58e83645b74a3a1b715197981e3306dcd01c905243c24867f1043ad38d03103c4ff58f5e7e6d60a057830fb61961898670b649d5b9fa92ef4aa2ef77364694962699a075918de89f1d73c3cd00b30e83677b8f783ad9a7cec2f77ffb719731eda17338258d831f4f93c5c5adc914c1cf2a51258c0a5e40c06c396e248d71aecfdaf9de4103862ee07f60097ac7e0bb7ce21a7b3d6c1aa44ccf68fc419883afd6950a2d605220798714d50152033a506d0dcee5faedae2c12195b9f63c7061918067fac09b6d96690ddc2113eabe03a9d98e71ee4e5e594fdeeae71190d9a04974ff4b901f07214562c5619b116db85a8aaf7a03657cf81af3a4cd12433b2e49cfcab96f707948e9e42904ab315afb79f1db0589dea91269efe59c155d3c330a8cccec4303ad0a125cb1bf68d0e3314f4754aa7fc7e55c3eae37c29a93e6001fb21f39a03a967239cf1b85231c159577de00112bde1659274f530f30c155377b36b29d66d31ba12303688134afb94451df9a302ec9cdd10a3a3914a91cc24d8fe25a2fe7ca0094042cd4efa06f1354973f52e0141874569eed98c675d722624b1de61fdfe740eeffa22aa55d31752ee49983a715ed4fa955f57ccd4a8274b020ae9af3467d475cee4488ff329a2e73d4f91a69f09101a799d7e7d3350d86da068a6ddc05688d6f89002b4c4d43e44e1056a0e937f0d167a6cf5792e52eff803123a28d5ef995c8bc86819e535d857fbd2485e3a62c398454d00878c138706ee28e216a54765df01ef6d4163ccf34776c692efdbd41427e976144248ea36bed49493048712f3c86e1b59f12ade60a98ac1f5d8d8826ffdf911a61ccd9e6de79acbabeb9bad187df7ea0594619cb0948ef513cde0243096039a51e5c7987a0c349886c4da0f130af8febacec6a6f46621d0eb7393a4839eb35ee0f589b8b7445266e9aa5e7a819517262c855924abb18c6a63e1f769ce6d24a28d1f363a478593649edfc29a22f5fb544b0050d16a40759a179c3552cfa824420515d2099e64454a9a7a01a7109a10757a05aa482dbdb7bcf4d879a28d2c4b9527aa6f5e15f06221286c13ab034f5452906dde5de43d4a77154c510275615ed1d661f4ee998a7fba9c452ce5573e5d1dbebc596bcb7da8d6c32b82090822741319374da2b8fae3e4e60380575188ff9dd2624f31b840958edec706e5688c675351da57f8efffdbb3665deefe6730e7fe895ddc79993ca3025b91fab2a12b7788f4f9c5200066137c27bcf47b969a30d3b211576743e749e7b8efde6ae30e90ff80e1520e5b0e309f736737fd7af555771fddcf902d51e6e3204367d57e3542524308a9a1713e06a5c7a2b56a3e3f19180be0ae71468dfdc5ecaf79544aeeee168ec84351245abf90ffca1e3d9efafa64da7788a30611f8e0c0c2f980aedadc5ae377924f7b1d12d50dcea865e4f7271b5cafb19feac006cea9eb59e793c0c66d4d0c7f5ae2b6ec924a3ed66f4a6bd2a107157c66f52927dd7c3c588bce169b0a25d0d699246be5d8085d47a07464e007cf795516c6c7f52926254db1f5a3db8d1e38e7a43e17bdcdd44853a9f867258da1ab64fc5eb38fdb1c0b5ed55b6ad4dd2b8c9c99430471bd1ef6e7d0b8b77b24b7985d44be42c6511ef35bdb8800d4cf68f4591640b2a26d3532efd1e4b8131720d9b5fa5172d8f7b0d3344b3cd4d4df83daeb0bc85d69c15c5586f11e0664299b47d2635f8604dbbb7407aca3d7ff03d2fea41b294183c72237126a889c288da625213030b84b33b2c574b284813cd78220c9457ad98e456ee1f031dc72455f3fde66cbff5aac546460377c1707e7cb9896386c1108948639921292236483190f289114006662128bf4d3e5a24be971cac5569e2e07a13c72251e7a2b115f1bfc22726e1d2dc362d3364090f7da8701e82fb878e15d7c4b5b805e637c1ffe26dbac3c939447378d2f70132204e59410d156f4324d93f7feb80c1241854e08b566541aa67eb793c3ed0fc2880cd7e38db14175e1f39bd6a265ad8af89c2f81ebac7c9c61a01fad51ca793ebc9e84f51dd53bf0cd5b31243a8b5dc44e725ff495a9263064c05950aea5caaefcf505e8ded1723862bdf68b00ca3cf7636b3ac7632cb888107cb4e9be8eada44ef2a5013ec3a544239ff5abb7e7fc349197695f7810b319a141dece9c2bde75319ad83aa49adfb9c4649e9893d743ecf4d3c7a2e7cb87c8a16208a92b278a46011abd7914bba7c8e93a9c4478d38c04095a71e7ddbb2f7df88d9450bd675556f495a53e3dfd47ea43747d2df7b79c698ab356f475d46b6969ac40d9757ecb0b97b180f221f82520eade1be5d799c1e45f4064dc58180db4de59055324a5f0279bdfe31d30e91f470d75f41c6b1874093acc7064ce47f89b2bd77aa0cc8b111ed64744e0cef0b4addc1d16fad57adb0ddf799dcea7129a2ddf2d2695054a17b004ab52a193bda3a2d234b8ca3ce0989100e05be0d0899b4319cf74f36eb8930c50e5b8a69869d395e85c5919cfc3526585b3dfbc570375de317ffae2414a05ceedade6cd8024ee95b33bd27e836a543a6ca6613cc3a24585ca712c2a57572d3aaa95d82326a2277f971ea3ebe2de52e982ed8b95d5bc60681bd8109b716f91917c13b8a2673543913ff2c907ff119f9e60fa272f2c62ea61d486b812fd0fddd05b3107895eab384356489315e2ebcf851dd9992dbc1c714b46a2c20f1357abab3fbf9c954379060b76d24ec45645d730a8c88794c3ab0a3f2f3a579b194584c0f5f822c77f34636eff91e4971a05d60364abd0f8a812f2dd977befc836b0a7941ffb2f917316662245f143475cf3a264c6c2792b4965c0b0bb0e36c7af6a22838c35938574a24306f7602aee7a22a0b2ebcc926f1ac1599876085571d7ce4ff4c46dfc77c31f95b0c7e1365b84e1172e6b3029bbf65083fc047dee9e9dd013009fe2459c0b04513846acab3b30f6b167679980dc913f1b8e0fcaed85473b4d86c0de128f5fa64536502c6f46faa9045f9451769e1cd90b993940cdab13066bb5ec24e1a0c8963bc9412ea39ab8e85e39794a46b8fc4b2d7baf06363fbb6404c159a6c87108b0575d3bb1934f959ef98d612a343cc5f24ccb80305fc23d52ad8c1b8e860679ebe11555ad681bada43a8c1bea8dc085f665207d9f8a96a1b928ac3c55a7da3f44d5da1b9c1d3a3d91fe3305a744481ceec06830897c37f94cbb99aee9a1b818ba9d1303922228df22cdaf914b6d6f9202cbc0d5cac89b3f097eaeb19783db6e76758c2ff48c2daed3ed34cdd221507887f854fd05f4ec27c140065392872bbd31f9670e51ee5afcb4904d99303cdcb3bfecafdbb703a89f04b297077dc115aa43efebdddce51721eacae9d84bb7788cfddd1811e63c9762f11be5b57416867aa8cca85fff6030c4102cc53454a8cc3cba90e61fe049eb3d3d33d95f0207df82bcbd96f29e4af4db8b46d9405fdf7abf584690e16fbea47326d50ba17b251716a9404cc4f95d27fb36014469f7ca0b2cffc9b0a1b0635480b5768cf6b803d83c6abea57baecd235b7dac98dfcc0d9b64bdd62414850908c68ed40ae4514eec80519789204c8cbc335eeda7ed7353a3b54c37da8a5816ef36f8bcc3bf955cfabbed72094b555db1a8c45104f8114447d08d98d41ff7720636ebd3bfd49979e3ea0c152fa12a2568074a6b306539e18de6c1b832f01e155e7ca8287312cafaf3c2de0e2e58947967bb839abd2902bfa70182ce33b56982241135b90c988a59c4fb56eddb4ab5c77a3cbf8881cd58a239bf2587c27f3932758de5f5f1f5f8b80c847e14d8ca2013b58d33e9d51a700db44a1459d8439423dfdd04c3e94a07163f1638388f4fd699a9c1c92492ee0a9d73ce6f40f3ca7da536ed1722a7387e1e5b2c9f848945762e26acde7bfaf98b13a98c4abc9569eaecd4d3ddf3d2a82544b97cc49a9f7fcbcae1fcd8cec852ff7d849bf79e95f68ae6cb3d191eceb6bfb11f531c65384d28acb38a0f76eff5429d3cae1be3585aa315d9d555b06ae6960e63ec613a5f71283ae8762b72de1eb8ca845d877d286f5913ef8e3b13b6fa2c15b6dbab9329c5ac5bfa3cdd492d97960aa77f4c431b20c4e46dfe76389c32e32ff8f89ac63f0ef2f2afe63da6a63165514412d8603df3b88aaf211d1545492059e61aaa03b98607bba45ea1a7f4532c189f48fb97fa86cd497a850eb4363b1cae2cd854b4718e3b4e07958b470c4da87331f915d176a6ff3c9f516776365508d21ca698432334eae903c29dba540d8284266c03ee36fe92757b7f76c8b44c941cf92c21db320a7b2f57a1f367a76c08d1575b5adbdfb26d4869ad0eb82ea309784cb173777999c7f137e257c04e86baf28b7c76d2a158a2c9f34d146e4bb38434a2e907b39f60c380b3355ea1f15f46370cc0602613a69e64005fd3975589ee14570a2033538097e9a93bea6ee9cbdeccb431c5636a609a55cf0d1408bd2f6d893f96758582bd07af6d8f7e6703c73d6345c3a6439995a060e7b019515ecd7283c742fc10cda9dac72467aa445dba9960e48f67e237a9a0a7e1a309d9e4e95d7f75895d74837d7ca74ec435476f769ba6527e899dbd4bfbd1bd11390eab2724ec292162c0a3503d552663c9c0e3ea12718953b2600df17681a957b4851579df49993f61cd302218955cea4dd68ab4ba6e0906074fb2498fa57a6daf2718e431d13decff884b397d061e3d80f09fac0752f72547aa2dbd425994350bbf83f7f48e359697a45ba971ca698b8a40f3acaaf9597484b364d9ecf1bc2571e1e9fa9917d919b7352adddaec563ea235f2bf5c03fc8877063c0fd015540e0c0be7700c7e284b37f9b05144dbcd1d01568072780febf6ac6e8021b849bd83d804a456c824f503f725a19b1ba06e0e5697ebd36b99fc3433c708a7a6605a5ca2361528110f47a8e52580ad389b1fbf7ddac5d380fb68fd9f8b5396df10c0a2c28410b22457e174dd85cec7203c9527414b929e812ec76863fa4ef35ffcfbb3f46c625c6797b8c6a8ae262a9ce45e66421169a97caa2f43a563684c14083ef9529d912558a474b4eb16988f10df8b8d0904e83fc9ac7bd3f37fd77e77cd9f6cbfc7f16f4f9f63de00a6d04cf2cc9c642abd2ea00ed4b5f0a25dbdfc3deafd0c4c0679d8074e2fa82c7202d1a71d1c537a7e9f2cc3e7cfcc744e6d809cd4efd2ce085caa5379ec13908b8d2a5958a3807f6e034c7fde3c78e286fdaff71b3480153d574ead93adde274c7405f2de0479a872c4faeca5a58ea42d9298479a2d592fabe40dc3cde70aa185f8a83ea0bd087241fd51ac70450b6230aa71290c003989cf3331b3f9d4b1976236d350e48da05f1e2d0a6a18cbc8dce23e4634f0a3765e6a3537ee5c10a55708f1e8d321b9153d02f29a86ab86252af31fd333c7982a31270c3f823bff40ca3ea599601e31ed5b390c4f87f3fd817d89319e9699305407bdd1c232973a60ae5ed52e1adaea62e4331e400c1428227cf4f2941c29930639971330c1541eaa0bbd8131ee8d6851c385350d2d8b99be21618f89540742dc1313610081b1d6884bbfd61fccbf6ce4ae691e38d2579ba995a9dea8f1fcf4bc556c6dd9168197e7fd4d4c83a07411132663887bf29c3b9f5290e71b22f9536590fdf950724ab6ef7d49bf6e100c71b22455cb5b7ca698cfebf8aa2e1c4acdfb0e610ebd8255f8b7d114e4defcd1b2c6aba1a4e3d2a07c3b57709c3fe40a7fb1b772ad4b1b9bdc42f289a571727ce0c30e27a5fee73e0b2b90993778ea8510b05a53a598ec77d28561e9da3c9ffbba9a35010392f83bc3ac7f87d5229f4bf205c24d6208f876be91c73d66550f8bd67548a7b55498d1881527a3eccd4e3090541ade41f96792e6cac03837c065948e338df798dc16de1e835bddf769c22571a0937e7df8e11bee80c8213e9fb3ef13facc125f5305a39f56015f4197d0635bc9ed10881b53210511da4779ceaeb8bf6f4adbbe99ad344da9c2790b19d7398274f83a96e469c2cec666669981083473f93213ec91d77814ae68cc9e31e90bb2dec6b7b3467bc9d0d418fea695c12686cf122613fc5151b4087c70a1ea1f7b90742a07fee92ee7d4391aa10189cb292495766d859dbf6ec3030c64b321afa04c8b5ddbb7dd9c2e85ad67a97eb4040b0dcd231f963f470f519014b7bbd3a551abd0bd2928292006ae48bde355e0fdc000c523477d05f473c5fc84cb56d3d065e976cc652924b8bbe0abdbfa878832c163059450ecac96527a61648ee90b18ec8a5652f183a751f4fdc90ac47a031ae16317c7fa733ec81ffce3f6c6d6874cd0e69e1b6886615f8ddbcd622446e9e2d6707a671508ae6745b5f08c93ccffd0e135e25852c814b14bc71aa75f7541fe1b3677e7435befb30c0cc691a3f68d77116dc8a9859e6f85fed2d676d69391ae2e56dd50bae0e52ac77ee567dda45aca3fb847d85db048a20e815cd07be8b488106c1189d2164252f932217a799cb047190960cb47790a1f32d9a82895c0d4680671e0db77cf7eca868bdcd131ca72f3da9790d8d18e4315e73f5d54aa0a49b19c0cb2c461e6a3c94aeb92287a055b03b3406bda279ed34c849e786241df44570b0c5f4c3e7f1e4162b1840cb7f8caa801d6f99a50172cee6f70b0ad74930f1ad4314373dfd5bc4b871c65bf171f6625bed669b6ed8ad08fa18e78a9a0cc4df5ad22b3f8d9b7f7d95c89eecd3d60b52006d9f815710d9de8946c2a8011798f56394c81543c124a0c879e813fc7f9c56f8e18ce6107d9b38cdbcfe2c5f71842e76dfcdd7ad555e5b604a0ecc80c43fe001463d3768af038b2839b9e4629a1228eb57fe887bbfd0894fc58355ed1283c72a275d3c63988c161f51f5fa2929881e05ffb073fabee95b57adc7f0ebad6aff602e36302d7687d5cc6b2aed1c57a7373124ff535ca23babac6f4f81034150bf97f5d6c055289b82331fcc68e9172db50cae99e6a8705ee38f7b6e83eb6d71dbaaa9c446d546af54e29ce70a0fcaff709ccda3d0494dbc990306498f5929d5de773a14557e6f66fe7a7908f45451d6826db63671bebc2442023195d0ccae79c0ac6de76593ff7fada293776e88d2996ac3879de4e433f5d773e2175320dc226040c1e3723716ad6ea46b7469d51acc38fc20ad6f375faa3a4cb25d7403b50665ce3ec4f15d22e5a4cb633b4a9b74e4cb85a8030aed7476a0b006e851ad76e3f9a4ed3984982759feb20510006cd76543a256e25b6ebe31022c7b0fb8b809bd004a6ea4ffb0e77cf5bf99fdca10780860b9ca4a07177ef3786fb5d4c3c59c198a1b0b0da6f6bc80b7f7aeb0f4ab043ad35dcc9fd3048e5be1038c78da19cd215a6b34b19100bb44e56a8c258f301940a9e1c1f9e58682429a1d4287e2c48da9311a6672934cc9b6c398b003d90a21a7c84a81d4d71b9a5254bc0a5d8274c4e4bc08582528113422c53a2a1f9ea3015ae33ebb74b0bbe99f70c88b8e5dc736056e9c822df982be6447dd3c94a9071b8d15646cd372a0bce79d55ad9410320290d200a27d3e7ab4f0530b18965e726ea741791c18cea78a4244247642d6371da1fca7525954e6d8f641fd5053f4c2010007d60e0183ee1625f9b5c98a2eb7ac57c11630c1f2434345d31c216bcae4ce7239ae2b44a5d40e652e8e4a4c1c1d10dbb5f013d91f05db6e9a3bd8ac27bfe8212870513fd665a78039b3d80c9311e9468ce2bbfb46cfffa214a76e06a2a80d1112d86568343b91c7885a69de74d2601e72e7073f23f24bab9d239d281b95c15fe2993a133440459261e97493a6e23f309508098f21093d07f89f9173f108c10921565877309c7122cb5b2ddd86928c8e46b7c037393b4aef1749dfc21fade8a3058401d74c84591cf88ba362dad579be93c400cf1d75c233fbeadce31fe01b7022d068e1b10be24d35ff8bdb17a9174f7a51492e5b57eefd651b04b5fa1c4b3f87a9b40178ceef448ce8143cc474eadf388319f2c6bad5b6d7fea796a9097f68d01630c60c3029bece1eeb4c730c9086ed94611a5ca740cc7b968fc33fd90e35c29e68894814429a5a1439934c0dfba1ced1f6b9977d5093b6c555d1f1bdb877f91c3517fe38932a03e770170b411b022d31aafa0b41766cad6572064a555ef634e33511dbb4538defe458b551635ad07cac6ae6672b1b2e7763fb3924e96f716ac1b3870b2d69449539e34669ea92b3cc2cf6844ffba56b10bf659ae35a6cf0a97c4159f4db5d39fc55025b03a6f09977726497bb7065872327bd9eb059ffb4b61ebc80b9efc3efa15ba8b31392be7cc3db27af257957b1b2e0227e16b254810d6ea69f182e7061bd22e2f17ac82de4ae96d3aab3d05b031f92eecdca7a4d6f929c9a788f895e0facefd95e13c39704271ea61bb32d07473fd78b64c6738b06e65faa4702d208f62a6f605c51480255f62d9fa14ab0f70c9ee81d9ca380f7be15996796bb89837c734e3f1648ab67c9c385740bf83417853d02ce5917818e21f2cdcdc321dd3490083c4ef9b882e7c7eb0de2f007a5963aaeef4c1d5e0f28ad0184e22b75e60ce887294b4e96e092c35f33d3129e21cb16f9d994a1d964305435b40c0577e5512a6615d030afcf3aa65e260cd72b2ded962fc2a56621bb913f894cf71a18059dfabbb2ea5df705321fa7c67d8ec4e00563cb3d5112e6e63e171346bb382e67481f90c413a44bbbbe3cc83b504b26c46491339b001be3b0ac331238ec788733b528b2a65c80608ba2bb75d35931e71da1fd770386b0b127c7954279901d75d879a243c418eb70c7bc40d0a48f4f775099d465bcbe0f7e4bc63f0c368f13c8051f5ed693ad55cf5350e35c50b62092d8cb0d3555c862ffd146415e5140377b9cc9b4d5e27abfaed81af196d6cc3990a189d7489546f6b90b8ae34e85a201b45b10bd785efd05eda196410b2c9532e42e6c178229ba7e875390bba1303feb4a1ba71719f50f1fe66d9e331b0591b58a0598d8dd5c43f2bbfa3937e43433038cffcd07c985190a4ad6b2e65e4f8e92fe750a3ef94de6073fccda89235edd1dc497adb8832f62208be8150338a8a1173a3facbaee8e530706249a8ba5b0570fb6711c5a7380e3a5148a25fd689488607478b64bd2f4527b11a7c4db067574aefea02a8b228da0a30759b50cc37979d4ff2db0352654d57042c6b9eb1a85d0ec75835f881d2edca512d360cc7d3f42595214aa2b782014f25244914f4b03a412e37fe152d7842cc1140f46c527353748302d9f308e1c2366f68b77fcfc2128493b0201b9ac31b8c8603432b1fd249ad9ebd93862b9926a7ae506a1d7ccb52e547d9dc751d357d94ff6538c5f346e00fc247aab0bc36ec392d254509910bbac8660dba6e3c0de675b74d0fb2bb3516c12111f9127bbbc11f2db37a90ee1938d27bf1228d75ac5e80a1130b6a07dccf74fe3ecda870cf7ec2e40f5edf383723a4a84b6a650820c04816aa4d90b46cbd96266f66f3db6e0a510af472d8d8f21be3c4cb2582b9017c906dd3c340d65b2c6812b76f2befb6cbd5750edda9798a6ecce9ebf5eb62f3221147db914711e2fef6c1dd1031d0efc69b6d4c271aaab2707cfa02a3d17e8e9179119a2988b7a5b3645db97edcbc117fd5a385d9e42b73dc7beb6b9eb5842b6c4fa9e52c66d0e38ecedb2af4fb5f0fa9b2b2ee3b364c3a6095f405b65cb08f8f39a9f4068e1952df2dafbf01597dc44c385cb0e26794e612e6da193d38dd32b55118a072e5a7fdd0387a964a62d0a2d7b23141f3fb100fb2165c62d620a5c3e19449ed2f409ad7ef50f816c0d13db1f696a6b8a63d2c7629fc95044d2fcf0133de57dddfc84d94631c6f81a92eee954803a5b58584d2c95229eeb74e28cf1813498aa3edeb0f6077e6aaceb241c22a5700108f4b94c13a74052c86bd11f5a278ad1aa0cba598c12dfc23265e2cc83f4c516ff56ed0665bec4232c19d451753607c1b6a2fc1a33772f82d70ff0d8705c1233bbfe9b4a0f1272307a09ea41e9fad04bfca401d4f2602fa5d05ce30813c7d818331135f1265542f56c4b31c2953499571f402322e480c0601f3e05f613909b1d870c3e84c4defbe60fc285cd90b88f014cba4cad631bfae741570fd59ab942341e4f59dd6670e4f93eee4a08b4d6a9c4b72a6e031b753ad708c1d31df22fba1721ad8e70f409c803538f5f9dae168a102970d63896bf5c93cdefd9205facaa5455b16ce079a6e2a5f2c8b93f09af5fd132f491fe826b8a8209dc10297e42ba2900b95c16348ef22803facff80f50a276aa7d369ca2f116a729590d2b1538b8ac432a8fcee00d9e14b5239a745ccb571df4bd7ac0f5c3e8ff9fe178f4574b2dee37fa322063f4a2da7b2b41e831f6cb5428bcaf4d98109c7b017f9fc746f15c77ed5a69663e9cb7a6af7c2c82db39705e567d6bfa7525cf183c0f90d6254e80b76710f257d7e2cb98b58daa1e03ece1f58ac084e9146e85013ca65ccc58b3c9a63df768cf927fe44e77d4a5b399e1c194ddbedeeb6a4d247b060d91e391784103251e790d8cd362cee4e48508fd8cc1b052896da1565dfa493ae985b1563de4252fbaaaf0eb508c13a23a3e7b67ed3e87ffe9a661737c8b7f73","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
