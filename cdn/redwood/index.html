<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39c616e2a1b6e459fe87a5329ae2ad94e1bb287da701b013efebbdbed6b11fa7c3289a7cf0e30c6eac53ae9459b57c5602bac07ec297d2a2092a4acaa106c70b055ed4277ec6fe4f140a0b3942f8432f7484a213a3b946f338b57aab6863b9748241835a05563d3f9b711731657fd04a138ab452f803a6d98dc9139aaef71b809dc3afb28044f88bc5737e0c4ea033df193a52091dd9694ff616bef1257e0f749126a62b28360cda64a0ac3ac5b41025ff174c5d5a2eeb5fe6398c1a50665fce8b6761fdf32daf68683b7b52b2cf94e956a961ee7dfaa88651a0e14755e2d5621d7a707bca21de41da2c21031c53f3499c8c7a4958e6b1375280f47dc5f42cac2df7c78f305f039d0febd4501745c20d9b2934b3b6a24a800cea26c7ac8ffbe28caf4c341128fa75df19b6bdf1bb409255ec37fd4cbe593f095b2bdb2d35192603214a7c6916db5ff8d2e880ff9b7bb9ef3bb2493dc6910b06f1101b86edc3079f235094b981cfd3586802beca62331804f2c39eedff3c31508c61cc4100f98718498d3b18674d854e548bc5739e8c42c815226c680f263cd14780a2c263f0c4e767c444f9cc87ed33034b7843a2694d697d3d7bad7ca2df7bb45973a9c19aac05666556ea6550b6dfeabc3902ffe2cc6fd3542071ad4c55b96bbbee153c7cd02e756ce8a6a0cd15edc05c57debe0a771480e09a46c436f9eb8cc47e8a446ba87b2a7b49524237e7103be5f6a11a3beee8f93b6af88dc97691f712b9ef1f177fd60f5f5b3180308e86598c110414cf020b855c5f275af39dc563c7fd7e77548431fbd7978821983035b323b59f060e67090b2b510384c67a72b091c59a01460fff2a43512dd263d0d39cb0e32fbda3b95472bc23328130257dc1fea6201057844ba0c1a438664e3079aee3e72825cdeefaf99bbff8167cf5bac28134480c1e7ddcf85f20c1521bba29191fb20098b18ffba17872ad05cd0b686df157980b6a920dbe3a6dd173417c93eb4fd289550fd581842b791f5ab11c38e09c131a669fd773262d129bc5e785f746ac985684943276eea3852f6a42388406e4f4a463093604b6807b1fe1f996c60d4d99d901fc9c0fc5d29f622026dcdba98d5a56c7d34ac6dffa8fb86af7507fa3074dbba6a2ed015d265314185dd9b78b12ea8c861df3426617dd88c8804c445e10d0cb20e8807c9f488da95ec19a46573bc11084812d5870297b4f93e9eb666a09f20047d31d55b73c99a9909f4eb2d2c2931be9a14e497826a4ca89f5113f6b5179a87cb684a1eb217a3a0d6a805908b6a0b1f8adc371d1f442572b02df7417c6eb3d4927fa98f6edf354af47c220da8373dec348493ea96434073434a6c54f372f2557993c065926f6a5a96011e98b243966d7eab198ced987e62b4789e294266b30b5a1dfde3c8a44aa91becbe8f2a818f777f68fc0f05d1fcddedb56c2b99969c7c503ac9d69038b2c2959e61f13e57b35f4ad7c99e249359b3f08ca6a72e5c42d65b762193a076483c697af08a0782ed97ffac2b90e335a08950e4b3413a2bc4a33c8338ce995aa112c6c08bfc3491c32576de39cf108f1f95a8b6282505c29bf8e75d2dbfba6b1a4d684cbbb23231506f04072a05f7ed68cfa42243f6e919e946273a597cd8a52de01fbd9dd07ae83294b2956fa3a4ff55dfe4a8f1bf29642f97938f7ae78927b1c04227c344f8eea21786ce7eb10f88b427f30e19decb62765be0a4711b2d92b5f563ff0e3e77a9a6b24c3a3fd047c81df4c6749fcbfde9eca63b75ecda6f2f20ac6b4b4b1a0e162eaab227b67b088fe908cb009a252b562f51ba587f00763c34fed192c49ad9d64ec2dca8be00347c9dbb4dce9b9a4e89ab4af9d736d7f469f7cfa13c72b847605cbef010c81e04d74823c40d14b17dd05271d0a0e6b5dd7bfbc9ad30f4761f91a1c6902552005ebc5eb29bc620d3350e53dd6c40f2c9c5871accc26a4fe177f03dd3ff195ff444a85a3d1ff973cadb2ac215aad36fed7403de5f68e4146449155b6e037ace2d79cdfb88bb67a56981eec61e7aee527febcf185b9802aeeaabc64bc36f88c7f4ef3a48d480c1ef898ca567ed2137e6bd7335cd920ae504b36e6ef03e43157bf859a019815a52724307525bf50347997659c9151c45c44324af1107ee259d581422b9f7e37cef6a15bc7a89473f6198d391c2c5bec321b8c6d5130dd1d27972d296387ae3ae6e5b81c336d7580533589a5747ad0a446af2ce749041057ecfbb1b06cfb67fa5f83523feedd078c25edc89fa7628ed3c0a8f9f0ceda9382fd02fd15d8e16a834ef310b82714dab424eff88e58f377d18e5a8dc206df14629f88e849d5d866fb88c706a0c1e843f78193cfb08466b74e9634c3b766779123985ce226b74acc60e017dcee52d918d97bb0a35ed8678e5e3edcedf77430eb045a5580a8f5fd762ec37d2b36a9449f1bd255cf93758e5d7378aa885b04a73d202bfd0bc4c3ff723b6d5bd23da1268f61bd1bf76f73c3016ed54483a62c519378e2fab12d99cd2421c887be7e316f8c0dfce60ffb1de96ece671362bda587098cc84ccd47a9fb8718ec60d60f499184ea66e2238294ff6731fc304c478e411ad70a75eb6f1561b822f6c25f7a8c34836a28a40291e9419e89594589e5c5c4c0beb4be9f1dc94e615bdcc923b0499705ab24ba90a8ec935bbe18c8a0e52e6ddeca5916d2e2b2ed42b084ed7a0b0b0af257dc7a84f0c89ef1ac9ab8e453307350cd585f335500111e24a019411598d238177fdd505a9fe7ecbec51315e7d0bd9dc254e802638cbcb64d5414482d8690cd6961309c839e531197faaa357664e9ded31bc620cbef0133ec349f8a8487585c0fe3ae4fbd0ad2774000d81b073ca71b1221a0e679db8bdde25b170e16f2be8206149ab0f4da1034b1698422d5e1257629b6087de7b25314672267b5b4b25798e1199741546357628b87cf9f82506c20b4845900cf954f536c8c6b4cfce75e94e2d35a3a4b47943a7889bf91e4846fca3098cf42fffb466af87f94f46d88dd11d7c7630980d5c7a7d303606e414d49f589133a894124b9aa506ef0eac04c94a2de207ceece906bc78077830e50f638ad7752b08e65bbcc1449efbac8843003671bef76413fe228e2bea4174e03a3e27e0efcceb0fa875b94bccb406b809cde3c2eb2fd0bb79951d9ee3fcb967f1de6eb404fba8777ce1e0ce86c93a6786e9b25b8205f37902d4167aea1236eb13efe8f1423791d614d7fa1c3e75e41cd82a4e29cfed36c97851fa1bb734f6f96eb659aff63377e36349631d0862c8e4ebe6ff56412cba00580ce2bb7e7404c12c5ce4fe623af5e755769b0931fab7028dcfe132eaf2f1a8e29507018e2c1da30e4fd9564db6084d0f3ae0e044a3a80075457430ff1bf7343ed99adadcc2d7da4856b7c9906c0ffc5590e1c75a0469dc87da9b013723b1d36985e60baa786dfc1ad006d193089383b133cb4211cdb2b6c835bc332e035fa598f85522d4220b732abf847f3bf2d43cfea6ad6f0cf27f4d82aa990f1e2422e5263f564a754aa8221e99906c4cb93dc8aa15e4dac2d2a0477bcef10b8d4be42875d199491742c28e5ef7bc63b3c4423cb08891caa6bb0b7f07045a276e85c675e2f2910e8290d72e32d86b906c9ef40bb832ca74ec9bf3c841215aa5c9c825961321de1355b5e1d962a907ac61326615f86280f1cb30dbc00839b5e6e01f728dcb89fbe4c5a7b7803aabbc4aa859640952aa693ff5d3d7b3241c5749d0becc31882631cdd16b5b5a9df2da7e3d2cb69d1a45a0ba51f9d23f480681aa842610e5e89a4ea47d98b030b9fdc46ebeaaedbd7e32bd284d6231feb36e8460b8cee7b09b9399b7a81eea04636fe51d93bc8a47776a5da060f2844fecd8b87e69707515d4f5f6678f9f53833c16b851a4146f056c4397691c6f81675398c28834d5d9ebace956efadfd9b350103c847c274b1150031ce6a7e2e1396da51bb30f094c0cfda79153fdd67ec6da8832705624d07f51a529c66a1e2d200b95c6295e853bbb92339c4c0f126badc8568fec4fe6b6c8cef8ef541341d42f3470fb307aef3d85476ae4e0fcb4001aea45c8aeb9c490141b932dd70bcb1f0e6b0ada13144fe090f4bba041a74d70b8c97e8b79b85de2a08116497f90aaad1f6ea9a95cc94f88488adb500194ac69addfc85e0fadd2e2147bcb563395dc05dfdc25fbd6d9e0b0592b489d882f2ce71849c7be4c83745d0308d1f80b41b1e56eafb4e747373f9bb94098bb9909ebf6accaa838d36b57ca21b825f84ad7292f751d568c22baa760adf05aae340b9af5c7554634edd9444bcfce0c8b3d17c8f42681b4f481457fa085e7f4d50251558d9bced0fd87793d2619af3225f507b9db8f0e3d1d6379893849fac3a05f8e15a0341bfa415c7534814563ac638af389b620285348aaffc71b2a561b156276cf6652741cfbc244593d24b6f528dfcdecc9266f632b43e1fa28bfe4921646d8153ee2f3b99018613fa8c1564c2e44c951cebd9f6a3afdcad9f79824638a744146140c71bde130bf30b50cc4d8a63921d3c212a248f8c80763ad15158403a982cc9bfcb0c3e7ab3a6b45baed2a209eb27db62fc89882592baa3a437c53712f4edaf6fd5ebbf1bb484ddca01f908c300a8e6d7a2bf65a461ddd88f50f2dcf16aa8626acac35f4aff2d9f052d15f21b539b35a83313b380e3b488a65e881b6b2840c309780d7ee547bd5d9ecc030acac3b1594b41129f7b3875a0a27d0a4767f7583be73ecb9ef4dd82b5f849dc6324364cbbfc48e6dec5d14e835eb1437d76ecb302fc585c173866331bac0b40ad4b16a7217179bf631beb6660786b1f56336a1999cae465b34219f35790925885a872697f4f0611991f97fc977612c0d0e6032b04f166d24039d663466550947f539f058fb428387dff72be1e22f9b7fd07eff40e9ca2c1e99add2456fbbd1a59ec687e6a02a2761fd14692c1ef45f385e18c596033ec1f0891848e01eed5719ed6e335f0281c1e850ee136fde12a940ea89e9ceef2d13e46a7d0bcd379c5e335980a40c1065c96c8cca5abfa8290b664f3fd8b06935e14e713cf7109a5d98377c2c34ad0aedb5d78d3737e3ea1db858dbb21b1f27401fd9736f5266b15ba2957c99b6bc5a0179f6e95a938f3b4b4437580509c283d2d056702fc9e3a8a8b52394ba3c9dee432efd0856e5a286d9216e5abcb73515a57beb1d7acd9a4813c7c97e8941b8e6a5e0542902bad9c243f7cd27d9e4691a530e27ad1abc899aaf8dfe3d82b06e427a8579314599e4c7841e7f4a0641dac72b8058777d651bca80a2c07a3cf8c7311dd843ba319629850f8cb567c7322b47b95ae9829f8a5a1edf1620696c4c2e97ae49de50d26064558dfa543aca8a0a4eaad8f7a39ca4fa1960dbfcf637e7136022761cd34358e3e47235578640333373fbf9489b64a1469a91fbe5f1814c9e77ac540fed64b9006edfa668623cbc6e230a99e2d86ebbac284079ead7cd4d706e92049e70d888846b4a4d1e7df1a631ef14b89217fcfe515fae852c84f410f9f9048acca6857b710ca37052614216088395405ec8ed202e20beb697e006aa872aee37232b0acf8ba27528bbd4887db31e26d7766de7b98b6986c19a2e8dea5722934ba0a5d11d6f5bc7d423bbf98ed0f47f9e14d96bd72f0e56e288ccea196fb767346b636d378dc324529b2ec67c1df5dbbb5f6223dacbc2e7cb8ab04b2bc200cd3f0d0f16d20c6618bb3267f6fdcfcc582abac11af332a31bce201dc0ca5caea351eb4d0775cb18ae302c20e56d021e190bf51032ddf59f59f6ffadfde4dcdef8ff848bfcb75a7ab7bf28f5e238e44aa739cbae157f29e11dc194f5fc2f618cc1279678e453538b16cd8e8ad86f29bd3591b3d8b223eb105b0fe9928f6e516bed2ba0b0137070617d21aba7ea928d2bf7153d4c7c69a298e683bc631e9669f5c106ddd641d00efcc056da1c6abc69a37ed8386e5eb6bfda9176cd26da3c63fff102e7d70903919107313d6373eab06f115a7a597ef382db931207342209050cad37118a51458342c7d85a1ed94f4b6871f7bb596ef917b1dbfb8999f6138958d6b503a4ec328d2065ca424de2c457536faa6509fc014143172767f5096aec99c7131af15cd61477fbfaab52472d44e43f00f8904354ad7a914fbc0175d635725fdd685f17c1f538b5eabf7713173f96955ffbb2128bd15993dca84268f62c9a6ad73ab183cbcc72ad4b60c1d74b60b8f2cab7b788f4117b5941c5862554aeaed46bb4a435b716370d9b7372781bb28d9c85b259054542fcfbec14ff855b88c65b2d16420242da9f5bb929a42afedf9729edbcac42ce5a4bfd7513b2600d38dc30bc99dd8b622287ddca1ebe99a05c9e13dbb4d29462afbaa644d7f589b472ad65688077094a51436f92ae832ea4cd979ad98ad43e29ad010965d52ddd8282069ba1a3c197055451eb6b5955ddfe503be78dca782f83392872b57b7e7b0c4b8b1e9e6a1cf1f5dbaa17d01bd41dd2f25d7ea84df38e6593dd3105da7c05727b963d31853bd10deb96769b2616339eaa4a12df4490501628e42102c08867233f2bfcecc736cec7d315cdc78f3533d85a6f8d6e09ebfb100792a4713b2d2070d0e6df4e133cf4adbbf9bb54a29e9dcf22c64790cc1e35921dc3a1fbf1f8c63a13fcbc41e0d729a762f4ccd0c0e23e6bc8af7e031036426b24caaac60b855cbd23f8b69cab5e267ddfc7f3ee257a96cb2779596ac9af572f75f0f2ac52c6186044e06d8eb940902762ac7e4533926606378cef215c5770c3a48e955b9fe10978b68699cad05c01d5781a1daf896891fac4ff7cf8482173837da1e1d7d41a2a336661b8614cd938844e23834d8658d17226db43384374e96837fe350a7d9a74c259043878200975ced860ff443ecdd103d7fd1859618f16439ac92faaf1d2761e7f85c0c40457605b14a73f754901de3d126b8bef1db6b39518cdc35a9dd790dcb6dc11cce53ee1bfcd89009f6247c4b21d136bb17d01b1de455b1b0b132f381da0a3e0120d2a544c356410bdcf122899906445e2a53339bffb07ae1935e5ded2c63d3f5d4f5a881cc8a90c9045ba37efc4dc8e0d4b825bd3532a23b794f2a21290e77d3d401237703dfb3a0379b51857a092dc21d502c63e4e10df55f9175477a4add361b17729797896ac08c483383760650e4ce5b7e72085aebe2a6fe78f97230601b0cc83343ef5e3a926e6fc3cba497c638f580c5fe56a629be332163e91cf287b7809527dec78878e2726d10a239470f968e0b1998d4a885eea35130243b9d4b00304f1259ead7e3323f3b716e0e63e42c4efd79088923105e1ddf9899cd702997b9b2d682d0b0cfea0dbade5ce55bede0ad46b75b6e992c5f662ba6b3c9d4235782f99adc8ac08ce951b4508ed35f4d2f5eeab1117cfb66e8ac5d03a858bff349e1639513075c4d2750a0471602598b35b48aa9e8821ebf17a7e436ef2f918ca4a8b0ec9f8c55aeac02704dc9f4f361ee422b9624b6c4af6f0fe663e13481072d3872df915dbd2b96895f5bfa9d936d8e823f2e2c744532f3197b61d3cb785e79f4b9925115cca9b7aa3b233e44e42dd0e89dfe6489e3259f45d1137153c725d3adc8e21504461c4cd225fe4be48fea7d058db9b734515743e2e3f127ee54f933e68724abdeafc9b9603c556ca44d7ad6034986b56cc741a04f71fc9d0360fc07b81d21b2d02ce44e04178a702c5fa90d61f3c146ecd31f01053f96b45d41dc5648ce2ead645d3a826d0d69ad4be2f38802a1306d43a1ebb4fb5fd6d8d2474fafc8aa70d57c42bfd56a7ecac36eca80210735da630f45cda3470daf0dd6a812e3cfb29b2c6380beb5b88fc38a4f3bbe17ac6360b016cef4c889323721f79d7f6a70053fd3d08c2610e88e44a98d0424cd59d242effc2b93bc746b3eb41a097f993ca9a79a0cf5af32ffe2a903432470fed99e17e0550e9e007eebc54677d727a18436945d9f9bc570bcb40d1f0d9ca5e947b4c4c69b1644a2f680207705b7303830d51bc93c2ef74609be84a4112e76097e3f67ab3eed4a3bba5aad069fe471d1dabf7d3f41416ded5ff7d113046e0d684d567b13ad79ebc2e9c97ae5dd040bdbc5f902569e4a3244f9b8a1455f4aa77e5f965cf06c15a5e300ad5b027d1ea3edbb4c313d357ec360e0b970e21fd1a83ed32324ec939d7928f23e6e7fcb75bb041bd5e77ab014e3ab990a58092a5e47e636aa63c5b54e6d6aff1347846e6fb57cb023b1b132134ca2a16cebbaaf9c062f9f11eadc7f43aab204ed7e415d5a98c82c405b343d63038b7f785440ac0cc1e1d184f3f21c1a22727b144929dfa592bba02300a5b9134513dd1bf1357573d9a1f186f8eccb61f5f91240f8518bce1ebce2294a5db33dc6dda6b22ef442b51ad1ed4c64aa6997583b923a2c3588d910ed9939520d2c777316670d4acf9bb415a0a2ae4c36eb0628b6961f4168df7c1507984c2fd7c528d710af9e1fbf2ba1d0b4efa25ba5ca1f6d682f84b8d8736910b29d72c0e191ccd08777639ff55cfd5a4178f1676004930bbca7b812f69beb336ec275d33754b38edb5d4d8cd10eaf02c63d0aa7437ec23542b90e27747f454dad8df04424255c2e99b43a210e8c40abc6e29b9f0644b6b545435b1bca2b05eef20e381b341b978ea866f706828ccab9181a77dba7122d04821999c0c5032f6a3d4da81a89b4a55c20147386acf83d916f55073f7fad8d3ee7e742125681f5f6c10f4fc03f8935724f1c5e6cde8ffedb8e2c2777d0dc338b2b1ab9bf3dc0fff5dcc7bfd25d3d1f37f7c1bd75840885e2cf224f99f491903cdf7aa86e993bbb4d54df8faa6a0c3495668bacc3bbbda350191a3914f91bdfd69af0d1985e346507d8a040097c8d328b555c1c5b6acf114b6eeb3c71d013cf5c53d7223be64c794bb4009761a1af3742d725deca648a46e7d7fab02abaa9860caf5b49444a83aa27482403eae38a4190123415ff4999117ee21bbaa3766ab8db8ed097cd43a450ba7446545d5d48987958cd828e197358e3d65d648b224a5d226c3e0a65a1230f705c113abb57de14706a7cd494b22c2e1ac87f0e2ff427ab929df24314013ac5bba812559d997aa0aedfa9f27f20d7a77053a7e038a0600f56243ca61f15c7dac58f9268f40af80d4724d79af1e51dce266b98c9eca8595c31a17e40c4fae9038c17dc6d7e22f9ffb163ec36b69133db866e82d731ca62a7583645f254c1fcdc59cbdf406f5dd6fce29c66048e08f728c413c883513f5bea9d1cefca5fbfbfc8c32d161b11e468c96f3e56f099bfeb9685fd0ae498397604ea2164cbc48d98667a9a09cafccd579abb79b91fb702d94f9e8af59facaada5f8a43d689a26e8e91587c92f9433cced85b958e706a11d78b0819cff29c9a0a02777cd6558160348c9f5824c1e43c8c014f20db6f6d07fba2f8b516f672aa0c3691a7f9babb82da06100b2cef11c4636692cdb9693932c43779ab72a9fe17703c186781780de50c71bf10b752eaba4e94f6760f68d02f799b2a93158d61c134787e18de199ad5b7d1619b98f544383bd0f29a276f8726a6a0d3cb755fdfcd4449d4aed9bf8aec19f6a82d5dcb1a28c30b8d0433e681ca5376feb0d4c0883e614c2d003825465d75c3996125b4c993e081f04352353bd2b307a6683a7bc4d6d5196f6e3331408d82dd1ae9bfa1526efb4d6f135630e4f9890fe8e52ea4765d63454cd18d7edce8218e149eee4eca47f0a6578764c711f7de539608c80ae4ba697073cde31e2559538e3cf913c571369517091bfe971fa1480167e97b03a64ba1c8f869d6a1656b15a791cd3149cc6a180df4e0cbcb0f2680d63018a102ca855c8839cd82a2d2d53f3b9f13cb5a7e5098e44bc2e6feb458516dc9171b279a941d1cd1df30d12a3fdb2c31ab9198b9f2abebbaaea25f5c9f6e185c6be794036f28d889d16e59ac64f1ba9905deb57b46749095194d6309d525699f0a5d31f5c59f1a2667ab7daf97ee683bf63deb986e90a0cfa8a4ae119c1ae18debbc321de07636b7b614c64a9e969ba1f011ee1898a9e14fceba16e2874cd811c2731d453dc2c96b5ce13aacc30b0d7b293112dabaeacd5171be9e04ddabf311e0282b501f328814b3e600e16f2ac123d08882028cbd4e9333b00ec6c2792f94b93f2d002744f8dcb23ba9d75f565ff3127165ce4468c0bc8ea2dfd99c4855e8e091e1d0b199cb72a09c5a536278c7859c5e18748c77c66f520ccf3003d466491343befa494fd54e232f381a99acdc121f8bdb1765931e3f4ad6aeb4f10d9f7403d212e399a45657368b51a08277bc341bc03ba0fb961adb2d6a172251658f2c31531e8b36198c2fef120ef43ca8455bbc610e45a2829b15dcbaef065214769df2ebda1b50b79dc9d91dbdb8539600e17dc24345fd72f4c21c5f022835b07a0ebdc28b099b76f1fa8b06c7d904f6fe8cc3666f5609af6c6c492712f7dbdb55f48683b2247e553ddc817de5a3feda2b43a627eeb86e8c7a65fb33967af6d5ddbdc18cc453de130fa72d090fcd78a2e2197151fd7b4c4a3b0304053b75cfbc113a47ef8256fcfa380fb8fa76835e8432072e016a7c498d2abed096b74038945115db666d0f7e498518e6d1e3bfeb9314545f1690abc26e663c6b088390663ef397887cb0491c4d580541c105e86a3621e169dc188beb1b533a2044cfba33dcd56ed278fcf46e7663ccae94ee2eef60b1e0f93e5e63b281ba43bdf04eb705d9be8872885a1c36b2bfeba9898a3048867d1ba7454e79e7575ea8bf0886add5b70cea7c69d3a476e6736d8647fed359044006247a52d9390273a312aa59aa90512f95962a3794e7911c06a9d8fa4ce18c0413d2c4f1725147cb759895071fab91c240337625f14db4cb51f7fcbf654e824dc1a9a633ebc5a7abec0e3b453636af62f4213c6ca48f2533d17a403de721b04962d79076cf3c6cc54be5fda6b61d77c3f43e1b7e237d53dd4d249f33e17facef9a0999cc2082a2c60a3f9d353a4bbcac8a3b03a3b86bc1ed388798efb0303f49c03a3acb3064e04370ccc6209da5afb7f0855e4aed4b37ce1549e7675fca0fb0d729b34963f8aff8de98b1e9363a7d8199d3d8f39363790801be2f390bcecb5649718a830fe8e3090ff1de8b25936b5fde4d711cf0d8dcf9f0b1cd5235274bc648b225144b5809a65816425f3ab855e47698105a6abca9b6e24d6280a6010d6431bd399f8c4df8cf9d2a5e65e612054aab0d1c49e573ab4742c2193823a70d9f13d8cb361adbe77e97fdf8cd2d9c45ee3de4e67295c54bba428646750362e3b0ef124eb887e05f6cd1c1df791b2cc91b26aec9cfa04e92940a2298fed500344e8c69ff2f4fa9bdf8307d8758cef165319263b04e929d0e006492efda1aa930ee8f45f3c418a0572b808ffaebdd6e8f31567076648bd152f02fa3cbf3093f688d5d498b0b70e67a9826c4394c90cf9e85f2d147e99e789556c2cd04e24ecd31759fb6c0ad60730137a748b9532011fb2c48affb3aca1902ad611c9c2e7024b7d4edbe04941b78b133dc9f00da13450a730c17a8f784bf63df9e373b73435d2c5a3221dc10cffaadec0949c8fef40388cadfef8ff660c6750980daf1eedbbf3d35e28408e525af62201b10ba460e47a7b384e1d987db5d59f7f6838180d165dcad48cfcd1b84f68e64804da6aada806c42af075a67dcd1c6b90e43d4ce9825e0db5a2907bfb62f7af15822a2790e32ab88d50d7460d1afc1039565cf9b1cd9e64f2b086d77d83d6c81efebe9a6c78bc8496efa4ad050c8426cb5079beddb75252ac06f8819dc5c2fe2af9b6b4646e80936748ae51b430cc68ebe0c966edc14b2eb6e69480b289a12c820c1102fd54a8a3d93d08d654806f22729a46b90a3a55cb89fa5450a3d8f67c7792c71559706d5b9ede1d50ee7b8b412fe4b677bf3b38cb730e7b17f1e65f9f525031aa1d355b8bbbf1518cdba87bbb6547fd19f13643d06e23d6955c83a924ae8c7731599b15a292ef288e886aa35343994d30a6400032b1abe189147448ec7f79b72b909516372e62462a41f8e3ace108f3e189c05f7e3b693c059c93021cd6874d9d3e9528d90bc1eff4fa33a22b0f70d8d046cba421e103633b76a751b10747da90e31d7105a386c6696da38cbe3f34b395f6ac003172e5dca7b04fc9908b9c8faa907098d4cb4ecb023b42209dd31e2750a296ec6cad16f10ad5023cac3ae6182d992ae25685c256cd45cb4e8263c0ec539e10386cacac72d17e0cd5c242c3a4cea49f26465f3ad7e0eb6783600af2564cb3693632abe34345a397781576ff9839352ef70961501cf3f411b3b30b32fd8d9117de2c6f4318a5ee5bde7e1aebfb05282af35a16636f809b1bb44538e86f0f4f38427a0e3d87cde789344c99a968bb11200a28053ce582a6d57342cf3eae52603bc5fab38d884899ad4c1f3e02de2d817906d6629ed105667860f745f456ea6644b6ee7d3c0a83c19fddcf7a066b8a7d4e6ae80049fc01e62ea6e713c74687c2bbe412d55c752e2bebd0840f46d76d6bed5589260909533409b6162b91adb3f566bb7d133f0eda1c34b45ff8943423bb07c8f7e9b6bc7e6f35da6639d5cea278b98121365ccd13f1032af660e630b69277532eb9839176072f20aefbd69489860039e00edd59b9801aa533dd4d5abc254e7be03a6e2c2c7ad002e45b645a4cb1c61ff5861fcc9fc17c9fed47c09d462dfb021d994ca45f0e2aa7dd05078c99ed6cab049d622afb9cb0c513404503a6bd792ebc4d3bf412239f882c30f4bcd7b0f53824afad9673621fa6755bf9c53764c3000a397ed1a1892824b50513278b3a2355b794658219d323f07b9c278e97188844321fb55ea44b3940869cc45cf36503ba0d6b5c7b0faa224f73d40efb9892746c07b2915bdb5fcb949ec593e08afacb5ba736acdb8c49ad7832e2a905e8860f02d69c93e50c951a196899b0147cbbdace7262c666c086dcc161627442cc974579ce1d2f8066719cd6cd62b482f5b3dfd043376557dfab67559612ff36235dfff67d5d1559ecf01b1cde1fab14239ace924d260aae43f72544bacbd02b7354d6c184011a6f06637e3910f3272e38a5e0513f68a28451d2bc696bd679125c885a849dfd18b511fecd5026252df33814db8c2f074d4f15e35e0ea17426371a18a1a13f9ae73b8757bfce0a0c99c612a12bc4ae3491ca65793978916e423cd725d3db0c2e33084eab3665aa3c53e035f3c6d29fa0c9e6b4e3fb28866e12aa523e32e00ae542c836231636de8daeb40b5803c601ecb451513aaf4e5c190763547296c8eefaf5bb02dedf96381c5e0108cf5b3a7d2c1d942daa1cf2e5075ad6ab46e1325ee4d6b39ace5738b85db82b0f34600ef321bae546ade56464e2139ecf05ffed632427c3f84fb523e33374c8f271321bd896ee98740e17a7e86ad5db97c10166ee2f838a11c37d6072fd157bef666b62481f378ac62bf567bddec01d69e681ab2f7fe2834ecd2faf232e258c4fe2c387060eb440c9da0bee80b4e274f9cd8b45fb9fdfe6f64a7f29df4dd6236c5d97a1c873d1785be74d72f27f742fa5182a01e17f9d1b7b2e634af831c2ba10101e247feb106db78fcf578f3d6e5ca5558b3bcc04ba684b1921fa8473c6e376fff57e2382781a9271acc5ba0e4314bbe5ccf325525ed8bf476b5c4674c3d9bc8252576f1bd8dff1a21f532fb6b7aba5dfcdcc8bf00dfe5e4fb9eb9869e8d5102d5e7d49403adf34197e9aff2ac0eb6686f35eeccd4c269ed835780f22f5e0457ac80fc5b9896791c56a33383946bcf68b12d0d285a8e2d6c80043932f324b8644e727e87c174c90afc012e77ba91870eb664e32eec195ee6b3da7091a0a136eae46c5edad4b61f7751616680f0daa81d501d3c07577b8adb13f462de1a5fa16cca5b73ec0aec23117827ba7192e82420fd674798399688e527e3b80017a2f33bdf3d1296a3e9bef7026d4f1d985683b5f0d7ae4d1b901852934700ca618f88c4f7153017c13d5da6f000aeea91d12769333ac2b8e8ff16685897b36aed2e09d0c5d64c3d330f200e15aed21ec92cc357b6f50d113620eb4b49cf2a17d3fd83bf0d1473d97ad3854fd4144838c7121538916191cbe904702a7bcd3e88e3ea1f09e75bb7ee8515980f931b73346f55db5c27cb94d07f7028dcbc8eb2f0606fc5ad369d067deb7356abff41e33345e305a49e6acf1a76b497d16fc905278fa407a35fb56f6bb0332aa7ae1a6b3b24d74d4a8782218833edc35355c8e98cf4a2b8fea753140586b4582c42e8b9b4563b56dad902e85423a9ac6238effd282b117afcf4917cbc1a7e64617dedbec41e19529ec7520c95f2133228573e34955f835143e34ec6b32877135ecc573c56a42520fe2faf8ea52484e887821dcce11f9f08da971c08fabfc68981d12e6ab8d6be4cdcba2acde50ed078aa3821e1a8f14899d7f71ed5f9b0f72e51daf773971f1943e4ac12694f25c451cd0d4884a32439e0607dca644c9e9a10906856a95e88b1f17bb3a068d308ad2b7d5497edf286bb056fdfc1905ae27566094fbda801346b6bb79eb48fb5640bda548eb3e8270ab62a655f8ae07f69d26bbd8a8c1df821d3694c80cca4f2b557171098b17a3a2c13b0bb7859c81238873d2c2e1e024d42c0ebd74f36c7cc2f67d9e935a5ba9251c38dd630f172ab1fcdc9748e684ed128d751d0a881bbd9690ea6e8d02cb8df2bdbf9471de507dda6f80917be94533946996f2cc048bd38848d59def1b75581bf32be4099f16844d7b672d5c9902d0ce2e5808fcafb5ed1a82bc3aa8bbe96ddc31843eef585b1ce554e37699d2c6bbd40684453a0c4b7d96a4d97898bde928628cec875f5fa549061d048b59087420e414b4adf9fc601ef852dde3eee537059a01876ff74f49b0d7fedb1648139905fd8c3ed9910150b8b699b03a6926b50967a31294a52c2e3d51258b0bf3685335939782c31a6241eadc5c8a787888fa5d3a00bb2edf2075d02c2af878409a6c53113a526742a406ab20f26c480eb1e06104464a589a85efdbbe6cf0a57b3fef72b034e2ce8c3987362aba978e2810ca861b36cf58f21c4cbd54e0ae03ea5b6151c5aa8f35b2c04c177a31f0520bf1070e8839f0547abc23e133f7c1dbb15de10e35a75a0cf1a6f9f972762a77b59ed69a971221d02e6510221e83cd2fe516419dbaccedbf55f8b36cda61c3fb32403556e22be0ed91b78aa2ecc89c9e09deb9d9444af14436cc6b4f6830a0788002e1f7d5eac1dd131efc7e8bce15ceff7be910c6e5084ba35fd64ccd1e95d77282ff5efc5a10349fce9e4288db8177f2041c911cb13fa0b616f27455742df16caf9a0b657c72fe3b7d749a5654b11e5ecc67f6901fb0978500fb0e3d91f9b9fa18d68c13b3b0853ae5491abc2cfc99d1c4fe8339d3e0d89c5074f4100086fa5764d93dbcbaf8676caede477c98ce29c1e0204fa7a4d4079f836184cb5c9d99d3bee810d6f4a3900793782b8ccf0ff41622e817a1d751c25d1c331041fd9be97ba52577bf1e5c65d74e81322f3eeed0da187f4c59d5a4aab14b32fdb2b4dc8778d9f119777099292e5ebe0ec3b64583682d6965894b3c9d533eff953b2877a4d212b4b27bcac796341a8521f10ca3cb6e28cbfa53f70183a3e39d44293b854df7d9ce796359aa4c9545c596fa99e51d9930fb6e348f2004bc88b814defc0b79c5853db32940bc759ef96097e969517166479dc6fc95c8678a2c68f93d19e53da42188c699e5ec069b8becf9ea8bede023ee95e5da72a2d3a2f7d3371fc6f3bc5877371aa9544afb75168ebe4b10ffaf17630fd1341f9f1e7ed06a60c0a974f07b4d9b5f3e9c2f0c7be087ff6a2648229414ddacffe2ee609f2665afaad5afd57c064b187f8472270f0f3d6fdb9f8e91a0fac67ed0fdcda8fafd156f37c95c5c58abf47d37e1787589a2e5ea9218b58cb6dff7783135fab861836afd0394dedad6703bd9da75e90a9b53f8b2a1f3170be10d3d858574cfae1382814f84abbedb9d7805fb878a3665eaa98fe079e0970b4b3f47720c08b378ccbf6911084c69f3c3dc817d4ee6fe62c07144ee2a40b56723d17c5811160a8d9a40d9a4c7e127be940f6bd7a658c55d84cd511bc652a434d3f8bcaddff178395a58fd4df0c1559de56402f8125a17896620c23d2620e950b4a6b4b47cf93e0852ec47dc67d4ccae0a5ecf9ee984bca1af792b1d98225aaebfa758c129edb56b9816cc1ae3c3565cde1ca706114a8c8ee88e97ce8f022c39ab8b36dbec97333ef2d8ef1e7393a4ebc5645582a8eb2ccdfefd7822bee933ae9db9198a5604db6f5061e668eb9c9cd8049553e02984ded5841af0b44d80e5f1a2aebd22a60f85a6f90cd9124831a920fa1d398871147570a7f01c7971c02b8b921278f4cc5bb43c1e26da7dfc2ea02ddca4d817049f5c31e84e1293aa4d9ba881b20a0d439ced621b5d2205a567731d28aa75e10f2075d5a52f93b5d0d6b575848abe4da1caa6ccef2f380527d5dd6c2c45dd1d28bfafd1bb016173f2437792a6712545db7166cc088b1336393b8c2d8519c98f56777337c6761241946e26b3efc723ea8e1a0c4ef14e38e8b62227bd7a153e592716779f404c1fe4e9ea8a1ee59294e422e3cf454e66fb29d9ca4eb91b21f487a399ef089b3ab67d03672b3599ed0e076ed20833a31d999a5478e1b1b18989f4ce56782d530b54246efcd7e004e87b6f8845e803d19bb8fc9ac3dc476a1f30ce7d7265eff7eecef4c470c0f120b1ee38abce0c673ec1bb57c9c883e515ff74e0ce24f063c8e8e332c64e8806b16ae1590c78407129763a70c9ced7d6ddaf73e029763ec9f00375fbf66c949b6282b0330477793d061a63123d0929adb2808f12f64a1d59ecc710c043e0cf03ec26d294298cc38baa0cf5b629ce34a74298bdb05c48f99177e54b9664988676efd63d69ad914996ef620adb2ee3f2e4772130e946cfc67b142c642ba980b62116e3595b61e789f0ec560ace0c516582d1926f02757e6bcf80344fb77e68339e0fe35d6ac4ae26e48629ce75bf51d631dc8d834b2bedaed056d5c4d2f35638995d0dd92c9964e4e1fc96292cab5fea41b31736490d810aadf3fdf4ee2e421c196178a78cbe2b29fd5d18ddafe757056d68731fc84de2124eb34555c84fca67e92d6feeef25cecf346bf6850c89df4206cf8dd5fe432c15993a9e31fb5b722d8224c621ea53fa9e8262d3a6939e2cbad25cc0555640d5f3d0ae04c8d52b35f11f7c3eb0ad860a0167f60e95b8b3893cfbb37ecdc58d0fa18e0629b6f438f83cd5d04587d94196a43122ca4b22f27c345f75e1d7618260b36efdef8ddc35acd3fe1f248e0f2c4d47bdfb28e44f40645a0f37be17ab859386946b1ee6124d73dbf2e739f949e5af377a862b4f4be14ab1a6d5777403054d3adf4e00ff2813bc54917e908722e0691ccb80ad6fa36dd517c19fb41506a5dd6a95cf68a1792f5cbce3bf869aa8f07552e2b691a87420de694932083c833d995fd1e828d2ffb4c705166e47d8e91714ef41320398b420bb2c8261afb22a721b1b3be9871f974b5d7303d28d195596e7353d3cba2bc8f248be3b258d65962bd8282547f43e959f65e88a5192002046da1d896a7ce4719d3512ea35005a8cbf541d0992098851746e0b191934ccd6a8961d519e7e08bc7a47d5095d69ffa326670166e3d4d8347dafef8b02c8ec726ee5ba55111653396d9e8bd37c0ac0836770413f5157edbd759fe4043a93043e92263ed6636c56646984826deac6608dac120dec52fe6593836d8e772eed2f769faadf71eee5cef9a368e951d1323574578b21349c972b2d2880e0fc7084975a1a3e1558a130d024625892ec64ee4d24ab6d7c35db13f50c265d4dbf98ba14010285199a8a241a6737938c6a8c3b4e2d80","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
