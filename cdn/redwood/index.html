<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6272b0249a17fd3d8b63840f029e7342c4f34061c28667ff2d30f46814894342170bd846fcad8d7348408178d281a9fe2c088aa0ce285678908f670e7377869647331e0f72a12e90e8fd45599fed99cf0cb839f69a96e25fb27fd7a71939403135f3c826224927345681aa375e207d8485e1621d3e5cbb74509457a862459bbdb530d5123993392887f724e123d637dbea51f4a7fd31e470117efba1c044a932289730fadb565f538a22081a7eb1c686fe8ba3cc6e08beb9d6f412920c13065daba7df44e91811843e5384d2e8f9691209fb6ba5654eb52a4a84df0e07ff1b4770fe70604617c0974db3dffca05cd56411107f1303ab6b0c06aa3e9fff62eed397df75dd91cb8d363bcb9bb263667d2d3f211862c4615e90dcf5a64770dee918a46005ae40b4ac1ccc465f63bf54b9289f82165c2560803ea75f0c2577ccf0ed87772f2ff95ac9e1354cbea6ca903a81bc70ad81c167c085ef3ecfddea415dc45b04161370d01c539721ff2a5e04bbca2dc07e699d2fa10dcdc412f587a49238c840b04037c3c3e4c182306849bc6adbdf29b53dbb0f72a28ea41f55bc8a6488da24441588501ff367c93a32e7ec8e9c0eba9cab1879e33fe83593a45b6414367e80ce15ecd66ac28783bba3e645fab5c5e2770eb037238040d1cbe0c67b363d5e69866a1175446c602d10b95a20f110b2b7a9f76a74af3288839f3be9373a68d7419470f5e018ceb9855555c07b9375d2839dd7ddd1ca42abf4b0737b01499a96eee80d17cdcfc22d02339da96451cb6ba1140d85cb3ea0ea136a2a0c5066763c71955a3b0fd703123d28c587dc222f59b2fd1a83bcb9b206da0f3f88ce37857b9d57a5c8f723a9555558e15996848893ae48b57b4e9e41e7f519dd708947cffc1ab9473c87172d721b71e98287d84bb9c02a6ee009f69db5cfe85587f1734a99bac29a1585dc1e3df5efcf0fd0c86d72807f375f78257a53cdbddc0ca952adb8b6fa43f092340c25094a240893f03eb23fc1aa244184527d73155a344c40d3b54c34ec6bab8a1c262da21b8035829775fe01067bd2e6221f95e229be1d0b82b87d2c0b9a8e948f8b4ab9fbb9f42aa97983dec61a55c912793abb9c78c2a0ebc826cb406981a7aea556c756c26b9e3f84a92dac5a850d1e1c1e59c643a4dbe86badcb1490fa767ace62dc23db3aad3729bb0dda6121be343895c8c250305dd2b8b40c386f03d79811989ac8f0834de57ca84265bbeab87799b34a2ffed19e6e158bfa1129a3c0dbab0260b40fe7d0c4493825213e7d4ce5912537b3e15958caaf36210a42f7a767c2ae8c779ef1113c107dc4fece9913e30a261b4d5bf71d0e3a7b43e78a2e55283728d0057e0c5eace06a5240eb14d2c8a19a8ee6dcc46d9fbb27d131ad9baa38cc359371fca582711a8fbc07b2d6a06ca8dad43bad08130b616ede81c3f08eae7b2eebf031db004a93117698e8ec2553da68c04fafa7d441f850a466b9ddf25f65de728307297d680158a80804dee70c3ceb60d8b454ff6e35a2e2736e2a25b2fd4296b65500317016fc76f2f9dbfda26acd9e1dac9322e327855c34235dcbf5e25ba89267ac95e5ab3aef3ecc5fc7d7a72fa4b4570df60ea712cfeb77e2f92c2168f6155874a59630f56b8782839f4ec82c62f7bc328ecf88de2f92cdea7f6a84edcdd5e5101dd95c5b97e1968cf97d525b3c7bc59b1c2de870987f2ca3aae79138113be49eac4b60c7cd0fbf700aea3ceab2725f435e18ebac6b98d12ba377a5224f97288a6a158aa273aca3aaa5d98303ea60bac1a69463c06cfb2542a98b42d2d98938dd84151ff349cc1d046f014b30423173eeb7defdaf92f56a47276d95703d3d8991160115501661cf0a4dad1f066ddc9b0b1f00cb1e399e7201453f21e0ac089a7835118914a11b4cbbc614d538b31c99c176fcb0a030de1ceaec3b2b553a5a0887e1631271aa095a75fafa6d5d1a34d9456fc09f39307002086881a0e62676dea5aefc6b940cbdd7903d161a97869afab17b742a4e70b0190875f2dda19d759be2a9903e3ca61a0c629577962c386aa0412f5aa8315db4e760f8803fd60b224167dd14dfe31533ecebfdb1dcc59419dd305a816457e6383380c0bcfc6cb0095dfcbb70a93304cf77f17d7a04d68eb6c444732ca901595924bbba5528c792d3a5ebcea2d25c46bc0c8979a01d9378f89c14d85d674aa317aa35db064b426041a91d9f78302e41703afcca468733c56f1ed7dc9e998ce76b9529e3ceb652c18b2ec4a56661b422b48a8ab5a60b3ff7f097938e72a6c2ff7bc72fa6d6e0050d059a572d03f119966ccf7328774d6bef3c4ba2afb47c264d0d535534b93975411ff7b39d051234c43eb198a4da0744be14134a35deeea1b47d0e7b5f6443f9de582e9cff4abc7589ba29330d1ae765f00aed8b291719ccc953ae1c40b65c18ae52c0a0f10132387641c654eb7449a674cdcff794484cc3758ae6d81164b83cb42609eeac84fdf2315d20136550db98ba976d6b2e3671d65c7af76a8bc07ca45ece70afc92ea7830cb3b415837881c578d7d9c2cddb568cbef1e88d3feca6e87fb21ba5596e5ed33ff5daf47ae65c448d48ab07a3a4f199df8ddc528fa7c6e8f671716ef59aa4e431ed9e2e3c3113b793de302fdbeecd171fb4abcd3ee6d5551c7235e1b582508be7707d734eb6692327b3989eebb0618680fc3230f9c3b02d7b38824e80355f370c9f8536c1e4c9ce54a47e979d1fd824a18b011c7cec29749a1ed22135bf20836dac4ba74d78ddd03643661d58520e66167b48972cb7622872c96b9525a42a09be4b5281336f73cef4279f8c2dd5a3f006dba627bf77b2e14d31bdd21778a8ed5d4f2bcc5f37e58f288bb657dc9e9e2883c70c429dc1455546d9db5fa74f7e656e1d41c0b4c7b1249fd4b09be3023eac7fe732c839043c948aa1d46a3b80391997bf5385a16c473f38de983843c9024be908a7486b94a65eedb5839c9252a68e3994e3f9e30b46e4c49a8024820ed127d2f4cb3a669f5f992791e03b3aaafcaf0eaef2dbae8ba8125de1d1f9f348c18b75034efbd9fec67eb526e4e5b33a53eceb9b218deccc35e84b80b8690aedb0da25936f4fd8fab504e6050df1cf814fe8a1a969bb8452ac3e9dac65b1737efcac1e2e4f2acc0d4f11df299c410a70fe784556b0793fcaf4f581470a955c3805035de7afe771f415620ce1c7f92d7dff94ddbcd9f20b946e15675bcf3f6feaf95ddd078eb15ebf64ebeaa089888d3cda75973adfa039fb69b362956777c68c8ce9193d042ee8620e41ae2e4fd3060ab358cc810746e4ceefc2871404eaf685b777b8863cd72202d94919119fc74a8bf1b3dc9afbc090ca88111778a56c4ebceb4bca7ad2ce534e2765841b2c64421ca4fb6134d8988fa604d7016c28a44b0e503e8bb9350a248ddffb858492f214fa30d3e5dab1f93463190ee8514c6d534853b9de1e0d8dc7c8847f467c86ae89e83639bb4f49dddb47d083c2a2e3cbeee45039b2795a3d4406894572963e4237b1b8bc1d411ecfb74bd530560a931d41c31347c52e4c79d935d02adf846f9decd842bb0a3bd88b13f85e0ab99471c632b96cf6931c50d94f7b3593fb63d111ffe04e1d876c05f7d6a564145a74f73d8b84beb13659cb89114d007af2fecbb9f12c77b58d2f921b6d81d7f8cdfb81cdf0dd2e888d87cb2591f69f644600c8e162baa62110744f414fcad7fb2587c4e23328775f29c66e829d0b69393a44cc5fc30f48f2982d07a4f3b9d57785baa7691b3daef8538ebb8693002406e21fce35a287726783a60f6ffc96c0ef225a87760c2a6b0f25d64d66fe168ea7bb6283fb20e37e077410c5386b2e08d0fa3f33306cf9f9ceab2bd262d237567c138f9bb6bc1c5a72651c9c224095b4c84f3be1e6b6dda096a4a8246742a7e6c48d76f2f66620cc663adafb3b5e6426d057365b0e100a7d045d9251e4dffb85fa772ee6a95bce8e8d33f72bce1f965aaa6f78feeb78380066b42336defdc0257dc71a8837db29c93ead8334301d19e81d6d707c3c6000bf3140be6b2ccff975aa5a1d0bdb1fb309c89d71587e955c732109a99fcf24ffd907c41d44beb7b3fc060908bdf3eaccc2a6d207431a5033446c9d42bc9022de5488ce442ae0dedc97ec285b62e7ebc26f728ac371432c11ef1835561c7142581e15ae1a67f052d2c8efdae1d6d0d0cbb739c0901be587d8eab1b2dcc226cfe7cec79f96dea56ab2f01f9baa86b559c3ce7729e9d0bab602a28baf90d42357714f6b855f6b16d655648f5c267cd2475a038971103cd89c81be780575382a8ba39603ca64f0811e7581e136b9e835d3c03a2e1abcbe68e34a3187890899eef2bddd4f6f3653a03dfb6d51846493729136ac7c5fcc09ca4ed07b352abc48942890924e310463bfdd0ab8baf00d610d621018f1f38e615e2fcf43ecca4e8f5e74eb57fc985167870e9bda35c20fc284fa472a5e9c3744dea7b9271c55767243da7374bf0bb7b73a810f4bdeddfe38b8a39966c76d7beec039e36a35f0d3cae4c8b990cc157eec05dc96807a066de9557c2b3e89fd79956a0184d59674335c77a7bc1592fc950aa0c573ae80308587eb4a73af4cd4e84c63af0f101df13d027a185d9d8d80285498d17df14e67bde36ea657b183270a05dba51aa5c305073f9004945c052ae6468053ac6447c64a325c9930ca1fcb441dac79b7e3909d2d83fce7cbcf7fdd071d45ccf7bac49299f45d1595abacb1c788eb4335b886dd2b8501dfed7f9d375196c82c0a41d9e4cbe2837b2285bcd1b7ab088fd6e45450abb7d71fb74dc2170da0929b1fce5d40c2b02347a1371bd740d083ba977bc53a0677db533949616f7ba5a9e266b2c8d18ce9ee1c95371a74484d08bf5ec55ccbaf77fea2cfd966dfc28d1f68b33a81fcc8250bdc3c3d95d4fd874e77487730997ea8456ec5d5aa5ee728bb11815918a97de6187deec145d64adce50af6cb3b409f827bb7c8747dd84068db1c83f979d43795e8a80ad3c6299c39084e778cc5dbdfd4043feecefb14417bb986fbcc20cc9f9584cbd1f7e860f8f1d689d7e180da5cc9d9eed2e6501b9557433aa11db21eed38d4d869144f00faaab4de1ba6b0fa7f143b5cd822362abb563cf7bbd1ca0661184eb7286b400eb6cf0aa86e61318c5602e90adcf26a3f707a2b11b1134f793bdddbe8b2aef11573a95279e8068032b32b27399ac496844f4ab432bdff037599505da074dc820c8cd059972d8814d809ad9018a801a95f9547a658782ceb366ba9e10d9d4eec8c50c8db60c537573d10467ba0251d17cb07485c16480d9c1bf4e8aa9580f82ce49941b64af32f0297bde6f55e4287d15f8ec8cf9fe2c07bdd851829f4405d4f34ab002ff813205be247d90db637f6d1901c5d77bd52b827c28b671ce1ea107c67317947e489901dcfd7c1eda72aeb9210ed8b8a17eaacba7e65c9be4ed321a9b0727978dae2298477a7d9f699ede1dcb91f8cda921594928734a896ed790ab8de31146441346f35719e5a9bdcae8d334942a832cc00afbe32c62c3a3b76cb78fb4f13eace1b0df1e2a3bb42b159bfbb60ae40b4798a24fc24ae202d7a88467f3452b8b36d273b60372f5ea1b7b1b08745f06f17504c58bee69b49df06e42a83d5ab35feb0f9dc3e78021ce9c878d4ea8219b448160748d1e2bef716a6d01e2675a304958b43441408126219fd56dee8778a08052ae3a00687f7499744d3a5bd233270d308318eb5e2062eaca5e81ea10bd334f93e09eb6aab6821fcbc11611617b1d33e8f04a8e5f521dd225dbdd7261f2d5edd2736552005c5eb2f43cc5132e1deedf67193db67ae822428765d3f11f385de799109b75cbb37676dbb59997ae0b47b518083f2a5a1c56da686e22cd74e7003737d1ceee9bfb8ab45ba2f947eff52df9f82871a5e498881d0cada03c4014273e1db84dfb056d9bb44e873f38fe12bb3d49e64efc8ad5ee37ea3ec3dab4c071594b933c0ab885a232b8e3aec7b4d80e76815de074e212f2ba35d17a0cbec1d1f68c592316f015a1e762c4d14e6d41f913fe9ecaf61cd1dc39761bf7fc2fc565e30281a606d1d2d939f3ba27fb0566995f19ca96808306fdf5f18080e422454d85246267534631f372d42675e602c1d629e8a3028c0dbb91ab01e3673a28d9fc61bda1984369bced5da94c548fe3e8a39eaf3b858feae6ee285049583617eb490246466323a1aa5b9f2d1c265ff494b1d32f562d359454dcef18cabe483a8fefc9c94d01f864d5ee40344d0a18bf826b669874ba3361d34ab084c296270c532efd5ae827a2c9209310856214831862d6a5d0492e3ad9b7d608e3fcf39cebdb73d1723b50a00a2327589cb833c32b2a24bcc62b1f35e648e45e7d1b0def813678d0c387a755eab59e7636d3f5b98e3dabd3ad7ac3f455453ce7e5411ef116581576927db33891b5f6e86a87497ef4f60ec716f80b275bddd9ead5bd6e65320c297dd66eb846d33188de3bf4b684b620ed70e9b55068707387ef6f66d9f8c9820edde9d6498d7af8b4e5473ca13ba0e79f7752a0b97c4d3fd76972876ae00060767026b12ea89694fb44f9e3d0ef2f4625c459ee4201022e7d5514c44a3ee57d8a0337ec42fd10af5e0f63b725a3a3d9a92806dc7ba894104056a29d32e854cec4d5f4bc94b7562a3eea7d101d077aad9a7e20714ac91852a3231237ec732e09eec7ede9e2b36ad1d2dc9ade587b8960b95047ab2c9c8d324c651bd8ad5279b53421a8a9cd7694e0de9ec6f3f058666075307217711fc38dcffe44195a30fa91e5691ff665d28ddaed149e5522b4e38ed0e692100ba34378e9bc12bc127634e6fb1891f46d843c798233f205e0ab33b70241e84bea3817e7d1cbd9769f0021dd51faa7ae8dab44434e74239083412af98ca06ccfa2bb55e03e384bfd7531a8f5e8f46418e5846b2b6b4d57ff48b36d8ae11e4e6c2a23d93e5aa1064fc1fd1a7bed1efcb0780eff2dedf758ee619238e53982b32bef3cee1729c0dc59c12e1c23690160f2767e7262588f8f33ee9a5167c36168676230ea35b2ce9ecfc6ac28226535acec2d89d942db9b6544f7adf32da9a88d37dcaebd389ea7f75dc0494bf573114bbe9d3e5a34ced9e556cf5ca967c7b095c8ed1ac24ea931977f8478e9e06649c9e735cc236604c70f9e6c69359db2aa98e183c55a72f5a6d6957d181658096cba54d5d30d30f4672b7338ecfa9fe28f1b6e349cd66b9575c159cbc754821fc3cd9c33072abbfcda8f08e1882d6a83e9bbee64cc680892be4af17e444de9fb768aae12b9305a5996855ba9baf9ea0cc881c8aaf08cb42eb67eca0ea52f61b55429843702549aa0722b8ba5ba1a3d051ef28b67e05203346d149ec16fe30bb961f96fa396dc77fa126ab89aa7a1b660a2730a07a4d6361c7addbcaf68f7bbcf4e567ae46bf9d613282c788c6fc195e68814a2e35a30e5b22161c559e2a8e8a179e851e6c5f7326cd1766428c2f107ce17d3cda5ba05b38953e7ac0820f2bd8461bc0c26a083541da6d8fa10c8f2ac0c013dbef082d27a8602b3211e95503349bc23b19ccf8ff0fe61f6f4daeb120dc00e3616077f6006e07426f1e12e59b75951994c6fcc70a9144452da74ce438b9c59a70f67b711a68a75cdcb38dd9cb5ddaf51ca033842a90d357fed9d39fad6d5fbe4822719f17112b24c4a64e1694185289f2ce858abe1c0ed57d12afa953216862ea63512985faa1f0ce5b2a5be274f0c3d9cff22e20394cf30380e2fd37e72b3899f5605253a6606a6cb3ca27e102c42f31a7e5c7034769863292c15efde1f3811eefd267eb4eca422fc40ef651ee0e4cee1c410c17863c809dcfd874df2f1f863a8a1178ed10169b0ed8703ac828468dac121f1951a7b535e64a20bd97329d2d158b64036f6838ecf04f0d9f3d406ea9fbb229c0564f36a731b7cf2e5c450731830e3d07d8aa0d845ac171cfca49dd3a46dbfaaea8f0c3dd0a187cbe5c1a4bf3f55dc8be0eb2e4d472c43cd429986593c1f7b9108148bb7612f08aa7b5bc4cb8c1fd3ddb42b4301285ac73762d22f1f83fbf7071e32d6a22e4bf29136e04a325ea19c43834723c82f0acc4a48b2c5390c8196c031346b022f5d1746920a8c5108c525497dfe357da2c2de85e8cccc95209c5449d6b7ca2397474bf6a553f6424ee56b978a3a39c87c9350cfc7dbc430807e39f79ad20b93c78b2531f3c5969995dc44d50f7a2b8ec975408a0aaccfcee39b68123b355aa02eb327e956cb77d0cff7de65406ea55a15a212a288ba3e2798dfa61a7ad0f272ba206015d3d8a4cb3e8ffa3c367c319e280f9000fd626d68296cefd2131899c11c4fffcb65de6e5eedfd4f47f99426065e1c653fd1992d30ea2d21520fdafad91bd06135b69d4f87633fe49ae1c7d3acc0b3a73b6cceef6413a4a5aaab58a3d3e18e80845b182b5bd6d16241c230902a559686f441cb7b93b2392737cba6fda72a40f78e6684f26e1aa27ef690637bdff3ea1aff0581cd9aa6a311cb918843fccd851b8f2678b2f65c7ae89ee499628bcf3cc0efb73972931854d7eba7f644ec8be53abf43ab285718e402f49373678016626b454e533c2b001abe0204d53d759c855b42a5ee3def07b7e69c919b8fb233998b75adf4a290ca1f183c989bb01e816ba904c45e01005dc386a66aab0c6f07319897d25aacbf36dd00589db16ae1759e85ae5741125e65002c957d34268f0b549b7bed154f9a0b69b1d2646e2bb0978d8f744ea63ec2900a03de6ab42d2ddc52a63e0fad7e169ce7ad55dbd1da0778b34925cc499721127175747d36d6db687b6dd42fbb654545b0f4c5f0610b1d9a9efb14b9431501a125528200a03fa9757b212f1d8d4950681d63643222551cc9e584d75bdb1e9c5875ea452c5b60e351ec92c9691169f411f443a20647911297862e8c230861ce4dc025e9d81f3035b4da2c4a95a9026931c81b4d78355d32cb7bb705bc2dd5663e354bdd37cc7bc05f90dddc4c6fd4a3cf3e5a2eaa1587dc1057dece1444a0d9d6902ede1683937f562c8695260b4a0c175c22d002f1e75f2cd20fa1f9331b900c664ae739687a44c10449b0e7c163d782884f1186c1d9f5e33ea7421a8331ed76697a30763d02b0fa1042c227c6949783ba075ce77251b0d87afcf61abb4eeebf5e8e167eed8827b177470e7436407ccb30dfa51d149c13ca0aaa226dd5c7edab3c0c352837ce7a64f2bbdd2b85579fe6d766b89888c5d8b1c62bf52553576fe33294be579b7d94b6c9975ad148d6fea155528f047c5ce2b9965c3cb02abf7effff663c91099c487677e93c322f6288f0e469f82bbf96b4fb92df19881c0e070c331cb360ad7e22a2822250bf12e94904010fa313058adf6b0e2c03a3b37a70c1dd7f8654d2bff93f64ca765a971b4b8a5d7d9eb9fa170fed5bc300926d7f45be7ecdcae4ed3f17a098c51219d651406c29e1e7d8fb06c3fc7b4a3522b77e4d3998efe26a409277e39fcbc7b11fd31e25c4a1ad5a4615357851ebcbb4b9f864e14b432fb22412e9423b9612970ca454824d8d9b866b0abfb3cb07ccbee380fbf9a4b2bf04437d394fbd23b56046f352bd8ae46d5d44d01135f865f648af6bb8eff80f88f95dcbd7d1aa6fa1115af7f4218803bd558262a6a77e9c56a345f17f541a11825f353bee14277b6a0574bf23facb923bfc1a5cc4dffcf0ab3e380733a37deed5fd84772738a7fab9a3b12353ef6d404e4fcb547b2a5490230f3d9334a6754af88cfaed01fa0ae8142456306a77d92633fc4479252c6d4511e735a1f1d67f73e9f6b5bd82b8fbdf6c8f9ec860a2710dbe76a389c0312c7298491b04c6c559a9331d864b18965a6197edc4dd7cbd82c90acd769a1b92d91365e4298c74de7421903837e75930b4188e1e13a65a439e52d437aaaad9ce8b1faa4452ff6ee51cdc66c9f0d563f6bb452aeca87efe329b66240830681c2a1cb4c91035f8228ef1a54d1b59da3f2523b539f5fa0f58c7198caa1e277525e5376792e84571ec7e7f9e65dabdac8a4fa67a68a03ffbf0068aa94b6514ee6df34b77a504f90924b79972ddb3bf9eecdcf6e86e9d38ed9bafa98f4e2c7e4ffdf49312b62e0704fd369fc3289ff82aea058ef6395f0d74430ad5acd8b20c7fe15683c37af95b660a81bcf5e930d76a090b67a1a856ad162eaafee3612fe0ab1af0bc3d6baf36a183d103f4ac462f6afbab7a77c2f20715c19d4d5a14b09a565fee67a991fb8ac1d1b41f2dee9a6950faf95f49bab84ebd15cae04fa0bd3a7946b618ca419cd8340b6774a7c8362e89d6b36e3abfc3ac544486186cc9380270a10ab5c160ae88da2fd611346fdf4a00951849570317be5d25546df4ea11f6adc2cdd40a9b6ab0b62372702ce425c58f92ed2099d839a5b534697a8e4ea7843e99380f576c601e791e1ae35ef7cc28ae9a3d53f17b146bc549372c65410209de0d4aaf0133c5ca4943eb2cfb945a41faf2377c317d7467592f2c6d940fe1236bcc702e7e8ca17e7582391ab5cd395dae758fda557d57adf397b21dcdef76583b0199ad7abeab273fbdb5238e1b365833d40c46ccfa1ef0601545380c347b95591fd1740f7138e00e98008559d2117293bc1cff726619360cbc02ba4287b4b402b811cfa82e5da4da4593dd35483a61b68d3d37d05a133a20c8f872637b960639970a10e3311372fa338d0057260266bcf4999927b4c73f2bd80ab470cc6b8b73dbc8dc397075fad0043ad2c5d8b04cf958fdc874676c634a5ff2fdde342539fa011d98bc0a60a661388a481986daf38939dbb245fd14b7298d77d93b217315d6bea50850e0ef99c6a4b32fbf58ae06104a01aef6bff39288a2c0ca961177e9d70568a41e3e46f048db87412b33165a819fdb538e77ff3ffb8c0f738d151ebf64040a18710761c44ce484f624942c29621ff6a38c4610d714b9147a44883dfc8c1ce118360c4ce0c06b7e676def3972dd621a050f27a1dd3b68738c434acf3603bdfbdd74919d606b8f31ad86ca3247d2bbc247cdab187a002d936b62bd0476979232f426b4ad7b7ea76d59b37b0b4daffd4344e3c29263696a00d6f3c61e553a34919e1368ff2cfe3927333b8a684ce31974a58c707283ceafcc7225bd98d46b996978642417386acb8c7a0e97f11bf140235682564d53ce03ae538aac02d3570f18a3b777b11c6754c7fe92e0ec502009e2f590a507c7b022d4f4e0101b887bd98d5cb6daa6f6ede07d0bde42c5f5033ffd794c145488a45db46786e22ea1cec28af491408b37e4e932d65e7d7c20693ad62b98a6836b325f6bb2f0bd5e417acc366364fe5db3f7e7f1ffd75e05d5a6b5804aa84432607755602ff5a64652657da55aa0827882030fc2f31f908dffdd6de60deea6428415c9791ad316c6495ea0266bdae9b01799f3973f89f5e0baa0dcb3db6f597c72975329392c5418171e1df9f2b3b5bf5d33315803d3bddaa251e22468e1f2eceff212845d26356bf7e03ca76a2789245d6e9d9937530da1955e291aedb9bba1d811a6a6ca365ba9431ea084b3d7ae80ea4dcc973fd7d5ad644a49358f10d9bca39c4ff5374e189e1cb1c88df24c0b4813f6c86a3792484cfab9febe343176c0e9783b2612c4e3a1c89b8fba2bb4531f2761a829d52c3c63aee884769ceb95f8f18f4f3b7313c2e51f573f31a546414ef1360d29b5f2cdb44854f2cc0a5475b1a981a0501705b056d0e3c60120370fff194ff7f29da8134ca953667887e97467fd194d0d9ecb75931daa675ac88dcba8255cb340161902740a54bf5f310196cc423a87c4b105e9d86edc3a81c05deccaa350013941064bbfe8e13936fce3d3047568fe02600615bbab450d902ef38a5858067fafc9427567052f831dd3c45200d0abc9a263af2b1d49223446f8d2a89ab74869800f5caf152f5c0e66019acbda14355d84d8e6907ef029c891ab0420514eabdc4001ba304fe56f733d8daecb670c550d6b5354285392184e904d919037b978099ff4747b0f8b82dc6459bb0fa5b45b85140f83e68ee124ec493ff2067fb8667ca7977d810a99e0f864bd097e8b9c6bf7ea95c0cf630d0d7afa93e47dc172e2ab6b24f7173cfcd91ac01c9707177a9f6cc212277c0b4b24153e279a2955c680c3afcb60f23b12a2fd73795b667b88d4dfa683f6af867374cabbaad2b58fff3cc701937de7d9983363a127b9c36251a2079c7fca85c269eb4783d472c6a3958abbd31d760f79317378648d0cdd105c6d4c216885840c94ea9333007eca76e45cf68df9d949cb1aac47ccdb7508662c6f010997793a34a0cd282233e7227100e0dd9f7d851c76b2c176cd16f7618899d928d4cb081abc337aaecdca45decc5888a0b8ffacc5abecd9f7c246b2d388fc7267d7563356cae1a1307292d428cba33bd0d6f3ea813fb7c8b1c4f17fe24765467e055d560ac7cea69e84c383258b5bb6d4d0b9a42b4c776aa42c41cb099a7e841abc0d9267b6ef8e01a646bb0c7997ba8e8af14d4e8ab8c8374fff504c069b2179d10723f4d00cc36ce48758529d57ce62d4d67c6b8aabd74c7574bb125ac2250e4db71aad18ce597012a4355e2fdde168a27311b015bf81fe27c6b4813c7e42fe63ebe14d800e3b2e89f550977e6114983fec915d06274a3057c3490dcc18ee1181ed6ada03664f22bbce8d9173b2bc497c97922e8d31865e3d9b07c60c06f663a2319c35bab09c52ee987a490a056ab4096374035da5c30fc03e524a0828a674e9ed518a9306f116cb7c0ce7c057085daaae83bdda7d41813999e49c4f34db78ea12eed295659d7abe03968916d7a1a6b5c90c363feaca1bd7f425bd6e3466f3dc9159639cd6b18eb7c4ab142b6c3e32536e1c8a77350d57a9f671dc6d0d29d583444f77e9dfc892b3f8f937607618b3f41ea8f611d351f9f2155116d9e2e878349ed884dc1446838e4fa15cbc2c654c2173bee1d55d352a568e32558a9bec4aebc60560e82d5a13dd997678db38c0f42fb38e43e64f180be12b6b2a105010b664c83413bb234a6b6f98a6d3b249fca76a382a59e0ebb648333f66f9e8ed1477b6d817435b521884369abdce08748b43ce63263320a6da274623196bbd62f80272eb732c33709a346c7a1461a9ab068caebd2a347bb3261d413b632bbbf3fd791296f8585b281ad4f3d0fc0f36c691d738b09975f597fe017e9c7822cbb0ad579387636c3074fbcc994c07764a3fa2ccc9df4b07151622452d50ace24056240bce0a3c16a197acfeb832987dfa7b534d8abb68a61df093669c40d800b13b7be54e03382d514b0d3716008eba940dca5134a05414c9f98b29d5f1cc931edee22fb16d8235fdc67a8e61cda541eaa5a8a09458ab11863ab8d4d68a18c23d2bedad00efeaa03543a004f77fbf9d965c483ee5ea8902d48118fb38ff5d625972bb23a492c1fae7322d35be36a506e269ae8d0a4040f77a14629bb888c79b6c822ee5c28c4c6d1b8cb008d87e0c2e7c83a418e3f57ef16311a8f9e9d87d06b96c55dce9ba638a086e748ca70f126a79dbc3cc03f7c0bf47a84a490c702ce4cb2b40da6e84ed25fe127e0296dd8263801c657717fc670ef35e8eab55ba7f541ca194abc306eb9618c83d86242ba5761e50e1d06445cdc35117471456968e312e2924777d92879a9ec5c02183242107f24ea2e49aeb98db0d311efb334f195794c3c3a55ae8f008343ab37b07056c3999a80889abcf3e835c75f512e0bc20820c82bc1222dc4dbac7b892a8728e118bfc8239ffabe15460e2dfd8d424394f5f19db178af71ead7491186063ce99013c45b06bc4f364aa0a797ea725a5e609766edb12f6ad5cf1c15f356ea2bf54e0e5bfbbb7cc08a0becc511875e146072abc3fbc0072fa530ad0dc9530b9954d007898240a67dd1e288bb3a216ca70f08bce0838a04e5dacf5bfaaa06c9351ab434aaa321495be09cd22a0f9357d0d0587438b5231c6ebd865796e7f34677e2b1e6788dd31b76657e49d8c67b0c8e314b470db94af2ff30243956158dd1447a2be1f35d4cf40f9752a0211e81541fbd51c95dc1c7e1c1347c9a789d9e7b05ba1b1d2ead8a2d402632ef69903647d5bc9ee9701f064d3d4f868ea0972dc57265103dd387dfb337f383aca8abb0925baf4edfaebfc59e23059cffa9dd2e30d1ed4ed00cb3cab970184c1f6d63bbbbe3f4dadfdbb2cbfe27464e0e47c1a935447695b5303f0b173a6ac6475d97e1e6db705b7a6e67f2bdf568d4002246e375f4d60922499b9b21a69345fb3ea424e1694a43b3d42fe6ffcf4f52b5413fef5c82f1a81d272b7d372eeffaff9b8b678f1ccc5aa64d2d28b16b56e258b00063e58a644ae4ce3884bf0264fbde1c35c02f25e6e8969a1ce54ec8ede44db27779c84aaf83fe142ac2b1f1fc081fc3c81cc79c66c2a0e6614997260ca727ebdb27430bfb55eef8dd663422a4ddca89bbd122c2bc298c9f81468f65df68d71b5624d788d8912e0d0b32fa630b59c8cf5c01cfcfbd34ac93436596bdb0a5201a0f3cab5f651aa40f724ec4181a90d9b4d1e19358cdbde5befe52993f01bbeac09d3f1164aaf450937c3fff2a20b607f6b4cc5750ff714de3033c1123e154afe11914c5729301b30b50d6a2f10b30e3e74bbd099575f5daa383633ee0f1d8317b45b02ff6faa9534864fb4ca933dc30d9decd8f03e444d762ac1b5f24346408595a46b8ff65991199e657c1488d188802177d9daa3ba65d43443b1085bf78b2e749b86f6275dbecbbd33999b23f17aa2c7a0707a1825e13264fdb029bdc6065f1a24a6e3ffa6ed9398ec04fac47f7eb9f65fca2b431d505fa7dfcad1465dfcde6639d2339d9fac383d764b4fe8243cdfa27060b95e46a5762323e9eb99e6c8c0038a6c1bd4afc4a0abd519bf01d8e425b2504fd0572aa28eb9bceba6dfc553260685d76a713d913cceb527c083bff2edcff3a68c1c1ec798c0771cb4562bf4abf2b9c6d73d159418c13eb7e197f62bc7e8903b436ff244fcd598ced928d9ed6c60bac07d8644","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
