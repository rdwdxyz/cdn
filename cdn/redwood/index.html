<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b525a50dc67e7a6109daf5e15d251f32dce2813c2a46ee6a9b83fc8335a0e64211af602db6a2df5d4b0647f3b39538d4211c1b2c302a65f53c35fb29bad9353094c953c2468ff8cf1bc771e70a3edf02fa15e40d51fc0701b509187b0f721c7aa786718fa594716d2765a1a820deec74880e2f2c64119a2b20f95c4d99528ffefea973eea6ea35a11a3b6564e43adb4a7bd0fb065317929f36693386b6048fe61a099c7304a9075a9e80e0f9fe8d255b44178be6da78cccbde761de8372bd9a33cfc5670375a95af6a8b2813c49e27aba3ec9787fad1b5ff98d4adb854b7c8a955205922763c04d3cec6f9ec66d1e4efa3ce691b4c7f9496e78c17ebe6d39ddf70e78c18c2fdd5b639e8bc26715b1ab36f0ddf3646cdde07d18de8a934bfce24f311f62f69032974dbe46517c35e58d188a8f359a236ed206d9f327ce66b211d9fbda95e77e771b4b7c23d38293bae9d05bb53c75c53cb682ba1ef6d179bf0c206cdcbc3400111cdb2b0d3e9b981fa223e566d67e9b43d356269b7412e9501c92b70e37818f2eb395899891b0e3b2ad1493d58449d6d61606c13cae81f96600c50c747eb87127e276a90e1dd6cb5aaec953db45a31f5c5addf1a92e329445284194b76bb107d27c1e74e092e19444900b844e62fad88ea1e43c1dc7da9687bea13e8bfe063ecc222ed10de5102dbadb8cec72d59be29b0cefaeef92a93865158562c6954758bfe7a448dae23a08f30fe99fabe509628e86bd279f000a1f1240c1ba341cb032a0409c8d6c870716a92c274a52fa0e18a5d81eb24f4fbf428a229eb22427bb7b6268bf4db56b8b3a7a9686ba7b25f126a35114c4d6af011282c8695099227ebbe07629bdcde362b398fa4a9820cfd230154b6d7bd4a863f61783d7a65a1f3bc2643227d95ed596100d2f25fa666399256f516f3a762eb2c03c718fb9b0bbc819ed127370ab63efc2c90942daebe8bc674cb3ff7c52f651465f5eb56ee23edda2764262d947724fe4dffd06e7b32eabf155e6b39bac51e4d3ac000e29b6d5b25ee9df441f0ed6cbaa00185ed6adc3d8651cb496fb7d898d8e4861d6e4a014ed81efbfeab59b3566c5b7d41253fe7aa91baad865a5da352e59ebc67815b4f144077ee57cf4d6b0b95212c4d802777e0411482f4cdba78f43e54b269749f4cb3f74871bbfe0b7d61890d4b4ba64122a8ec906ae972bf8b2bd9253ee04d61e64936666b74364d54409a5ba09030cf27b10f2eb12fd3403453079d4c702c568ffadcb50b402975fab5482e3442fb23b6bdf6851bb136560916294efbfd5b53d59d943c361bc45235afed8089e24bc12ece35d9b47675bd5c8dad94b7d65e81ff5a5353961f8c95eb76452094035981e5ae11e242b0e99509b9c16e587a50b16ed17e7077c9b33811ff659e4bd8a7c377e9395b352682bbb685b03e1a881f604941b161460f2c574fa84768dc1b44c82785b6ec60a2a3e3d29046f1409641eca01c3e48f6d71e55e4db3c956ac9ad8b6f0c30283a2ae5c056e0d4d7e21bd7f1380069fc86fb521246e7eeda528bd77169ec8319416ad6b0cef77e6f1417bc146b6499a12b8bd5f5e7efcfda9b76563a7c9e1d909fff88091e96a44c71d184c096598c33851452b07668aaa2251bfe759a0969015d14be681b299d36bbf140383d3979e085a2ae26161d1db63b492e409ab2fd216475635aeee392c97280bcc54e219f8f1375139bcfd2bf3a68e5f5424cc30deed1108b7e1af70b27cadeba5cd5c61a599a42da09bd5b7cf1eac70edd2dc4cb74b73bd835c4abcd65b1e02b5e80b38e7165a4e01d91f3eb8bc83b206a25c258cd716eac037e3acbe08042a1bfa9c72728fde8dbb85aa193b95410d47dc74479e7a912b5997a5c9dff45e050b6a38bad3fe0f5493242be83d40c13c8a88ffd52793029972904ca774170288a3cddf9aa70bee2f85ced4dc9d4299f3e8179618630df698df3a3032d44f0f79ac3aa094f5f68b0e986cbad3d6a8fc140bd002655e87daecc9a3d33b148c62af4f962184cf1f7d2e2edcaa544c3ddb8ede00f2f40cb0aa189c24632da7301c1ce741ff48d5a7545d5621e6db69c4f3e5956ec9e01b2fbeeecafd0722e2c3520349c07ab0de4042d47cbb4a930ef1fbe08d66ee0bb9b90746e1e9a4885137bdfcfbdbf2f54448ffe1f2ad56f565847e4a72772d36c9039e66b102c9ca5880aa24f6f200fe6770b76398dc8bc08fe5b884c7b073a786724141ca7b5d5a00fe0d8ea680692d95276216fc6364193998035eab7f7dec76f59bcfb9aa8cf7d67de872f81fbab04c0b2c7245bfe3241e198e5c6cb3d6159ef0bd797d1f2b1b86ec9b3e5ab8a8d49800553c0efa38e42e926792d2077cd7575d244b68b2e3c06780285aef5bd747542a0a0770840fa49d984def97f5f62258256189539cae5dfb4402709645e5ba7804d4cf79edd5e2433351bf039d197b0e7e5ffc07d4a9ed279d9a6d42bd7a6fc226810f962b816ff20e47b783bc727f966b5dac9ab1818488a6df69667cc3a86c10c71b099ff43428734dca27c61c133871c7a4287afb4193a24c805aa6e34ab904a1cc0f5be6ee01ca8be38d5b1dfdd9b8320f5e6c71133c6e9ee954bf574978398009fa3225b496b3e7347b2f1b572f6273a6763366a74013d61959cf8fa0c2a3819821edf2b30662057d1322f7559924e0c024128f3c82a63b31103c86d5ba494f41e14e2062c249af4ebe8095eeba62f6b86f048403020f7d0d26598fc1ca5b5710278b5548a2d80b90bcbf0769b1d09d59c3158177e4d69f657c7e447a2e6b81e4079030e5b58d50cd6477ef42193abfa4927f025394ca59f31766273ec8d61d62cebd29d125e5c7318b62eda21993edf4356c08584024cd7ed9bb1078406ee35e5ebdd289907e3570bbdc0fa5600887ea901a141de2282af41877e77af024e01d6cd4f18f20dccc88b1a3f617d7913cddd6e3db3ba1e447b02d1f83efb5fc2b7b632a4e2511842aa4151c250fc61232026f6fcbe62b11dedcc5c74a6319f2ab20ffea20b69373502e98c896ffd0a717a28483455504c6c1778b30049e486970a0d12cd30fecb35cf65a0d3c1bbf89679d47523a5930183405df42193c8a1b9ee2b48d629254132cbbe724ed66203ba2ad1cd490fd38e8bd976eb5cba8024901eb1c0cb65b75b7d8084084e90882ec7ccf5e64055aeb75a045c437f4ea5fd8d682af6119b3e17d621c23a503170632834c9156d00829832eea0f9740126e04e0b977115da01dd0d3eeff987a9f14e567e0e5b81e7e58ada557cabe327b5d3b8ab4299c821ecc3a38c0921bf63eee55034533570977699a1b256850131114a3cde1c0875c608b20a344d20b73615819d1eb7b09c0fd1314244fa3ab70a5b6d3edeaed39f7a7afcc346affcf65bfecfb40a54423b00d304e5c02e7563351f411fe12890e93a33e54175880184259c0a5b73487e9bf86d3837c2cf07dd5536442620f9804d308541cba5b4233f25d741017fdb66e8118b5cd6fc49a2bb793fc89f8c663a1ac53c6fe2a40c3f19680c62df9cb406e7e357e644da3106e7befed8c798abf5481a8da0a394b6ad48927399086c5eb007b8f911c79256afb4f45e48938ad7e80c9a7a8d15de19525feb51aa526d70c2869f7b5488a6deee2f3e38624652e4fdbf2e26ad8168a007d44044b76ca25011b7497dfd5e6f6e5fb92661f22c6c97f182a12ce0bed181a5fd1fcbab78c3013c96db41b465c83709181dbc134045bd0eec2dd0e67375a7c15d4da76314351fbe3c1b5c16a1cd9892f7a05e24ebfc4f6980bb11e5cf7d666c8150b1b22d7f36e87a1fc7dd4eaf0a5e8f3b88a87c209278a16e0c66ace19550ff66126e5c3d6e191dfd2263e82635162354f7d0ce474929aef284223afcbbfd6f7e20fe37db4e5528e03a1f3d34260734cb090a132f50dff43b778eb9ff89f9ef78085d35e65ac5c864b920fa6b61aa5e58603d12e988c62172e18c62ea03832085e7d6ce332e1b5933ece3c45c57d31574a6de4cf8ee34f24b0343c5182a2b039bbe4736d964a7d24e80d3deb4a6ce4bc32cc1459d43c2ff2c5687b90bbf250ad33fc58058a6f11a108e4889a5e7d54cfb2010ec1c76ba930acb0c658163682a02599393e99f60fd382d62e12f46629e283997e28c5cf0a176cbd072cebfcfa742617dc9e9c8f3c84e325777902974ab8320df8b69859f1424df5a36b5d6cfe961706b9b66429151c23c0630b916c5ab4755746bc86b1b144bc46d003c0ba32823acbc9785c31939c83451b0d8f46b810ae3d02b944f9bd82df74a8d4cec0219e4a526267291645e3035b03c01030a291d15fefdfe3e660ed30cb502aa8d071f0a596af01f950685798667351a03e2c00f847325a3d7ff5c0e7af7af4459958875e76af27b74b9d1340f30d6f4d66a15001c2f1bae80d773097518383669d6d35f00662422fe36ff3a67100c4634aa7f27c069f418ebcbb0512907f071b52046b01cd1ecdf9a0231e9545b03f89f8628891c91fc8651eb4db22c1d894aef487007decfd3d5bf0269080dc885747c9c48c36620e551918f69fb1742e31fefc98d05f182b5c0feb1cbb7e83ae7d7e6e274e73cbdd0d9429533079f6d0f7a73a620d3b9d367bb3ff219b05c6a3bbcee968740fd76850fb0c369fdb3983edbeb615354e2ceaf28c96889dfc25f2a1dac219e249ff80d3cb6c752809ec8429d2b7e36f13e166b1a90628a0a709d97416742890fce7fb47018e3380a365e1bf0359ab6826d958091804b9c22118d2a05690e84483230c578c3036acd7558873194b3cd93414790721fff745164fe5ff97a6007692bb6b541db175de078f871df0d52bb92766bb282c35360d48f1c58433bf4280a174fcfb694eea1df647c88b1be2163e996e83f7804f89421fd1e0e2e0ba2e72ac55cdaa0f2459dcb699728ae40bf723d0cd8519768afb411bc26c1be22366ebb7e271c98f472d5655a337fc47156a2ebe1e2bd0b613f7b3d5adc963d1f64b62c8de1d448670199f7a3f166db7887f9f0b48bafdcdbbb55473451b6f763cebfe653788fe7e00421d0373189b18cd9a32f001b962408e5f0c0d27b13b5d086bde8714e632f874601acfbe98751a3b184f021e5d1586167ae8f4c4ea7b04b29363bc32e92d71395a72ec46eebd541b87c1deb8d938c8c333a59d34f3a4df4f97cd0005c0c8eae19d1196bfaca8a32ba485bcc89b2131aad29398c1c8b64bea7906b5b1beae68f15e5fbc3dd6ab8ac6c62cd9b85eab89f49c72641fcbda4db0093717f438e88806839a8092d73a5f4bf2005dcbf5c0f25180ae00bbbdcc0febfc6ac897d0b08fb5e06529c8fb99c2c3f608004f3bdb0fae0493dc022f96bcb3a5976aa30e24c92737383572a18b1666ad0313c72f32adbcb4db52efbabe68120b9091c2f537e003e36e3f6e5ee061ee1a59ebc858a6fc5dca9b9d61cc4522421678a9ae215d7d0ccbc2495e276617f8e21a01942313a5101c394e51fcb6ede9800393cac9a4a1fdc495dc02913ce1e78355191b5fa243588fde946f09cd67b3df092030fa7d2b74217ba367289453939c716ed5ccd9cc7ac59fe1e387ec896be87eb827a014f384fce025cd1ed0a6add93b5f649a0cfa29722006d710fc1fae845cc9db7ae7c4db26f73cd4b637e2b2fcc1c9bede9a09b8e73f888083489c8a9491edab6751d1b4d633ffb40841200c4d49677df2c33c13d52a034ca496ea2ec7c940cfd734b109330dd03cf6d77f57af4ea1dc4d08ca7d440a680e6e84d4b170a0f4144995bdf1d962d90914d78dafbf708ff642bab2f77e080aec845fc2f0d1314eb2ea3e0a3cd6a23d3df6f03e38aec3f7ece21e83ca4addb1c101a2a316d01535bd41d9245004d0bfea7a6060b90bff9ec256e812dbd2a08e35df258d632a6a20d2d5bb96c0687b1aad71e4b683188ebaaf480221428210dd4f9494a219c72d1fae9379e94dd126da4c81d3cf8962759f163fdae260ce080d231b061ef2ffae1462c0563332f4f42d331dfbfcf7b8ea87d1bcee47bbc9982fa28b623e3058bd93097ec8df815c3287b6424d7dd39c78189031d0c8843017d8ef4db20817fdea9e52e48dac32fcd7ee3297c23af83eaf216870bbd601647c95e30dda5f6aff8a936b5c01d9fd5d0687afd03c69a0ce8fc7360d9bc54b8d3a8a6a63ac3f0a4955fda56c45d0f3b46b62695bc3b56333d3f816ff6a89190c91d8ef6105c165e48f3274ea5ffd4fa699d9b8d4f0089db724cbcce4b53203eb2b8b1c82dc1e9875715c3f2a7fc4d4d042d2a1154e3ce572f3f48120b24f140a4313d8ee684924a460831861419ecfd58c9b10b960122d05b41a5c385ad260efac8faf09d80876a4008e6c34d476e36d8d2725ebbc692851dbb2490bea5ebdf2b9cd26f11dbaa7271c195719eef450a1b69ac6eb3ad47b8083f2aa250fc4c16b734a3e33d82328a05fa4d7d61014908ad0ee144c5fecf996667fbb011fea25fc97557cd9ebb10d9348024c1f5c291932645486a641e6bf2a59c83704ed4bc18d17ff0c0fe675da4afee9b62829a5b03db35a21c1b24e3b145f5fdc0d4d9395e3e2ddf3fef276ea67c4800cff94c1e55b8a08e5843c30895665883b0fd87d7280994dd0988a7f8510305598f94c8c5180370aaab9745da18bf04b489bee0fb24286858e4f59b273d15ab66dea8096880959c5c13f9f3187777b4cebb9f2e909b2b3587ceaf620ad3d6931e70ca7d1808c080e531381e466f2f2de95c44cf37a475dba42a7edd2d51e3622c16c45dd12b1f679a159f48f89ca04e658bf2cca4fc323c295b5fc66afe54cbda311f21031969dd1155ff1f4c9f27dc7e9b9aaa242f3a6bc79ca3e144a92e9e48e64d667cb0c9d4c8981e54c068c5f2ce606a98e22ce20661b83c883a630e124c4e17dfe028deaae43f189ee8a70ca0750e4729b2487236ac22bdf61cf6b488a81b1e3f2ec0ab47cd6ccfe72d526c80ba91e3ec7a51c5b2cb8c15bd4b7672376f4facfa7c4096400e5cc1bc1a9e8b5c0e12eaea6ca924f2c52a135cda145249d21b62c30c4f8b63256d4e73ea5340beef4e9c8e58ee4e24b39fb787411b77233254b5dccc8275182b8520af958b8a59bcdebd768dfd0366f5c3395c67cc1e4471af385bcf192aa0ba051ad80c0ec3f841247940280903d712e34663b8b1bbb53434f00da130d726b33fbe835485db2942d95c78358a07df0402f7d3aa9f4af1e1b0e819a0cc15ee2db2f357d65ec74903a4a7ee33561e2b6d76fa467cb162d73ee75c95d4ca067459f5c90b2c4ac4741960f5525426d02f54edda86f8a101e120e59e68046216cc562cf5c7150b05167ee308534d77980cf74eca21aca73a252a5bd03f525af6bc5454844cd9d8fb70833a3bf58c37cd7e9cc72119877eec76bb950bb09e0b98409880ce0169316d8e627fa170aaf37d9f551f451c99d64f00838c4103484c5a943031373282d0cc9773dee56990be416fc307e408bec3400fc85a4e28c4c2c11fe4bd14aae2b0e83b34047e61d14503eb96220b46151f86e7298258d762e624d4f9b6fc5e015458205ab2f2ba237927487764a530cf84492b0441db0ff6261b3c7900233bd2c11d8f6c688c67edb5d6c92a6296419adf3746ba5dbbba8e735a04d8b03cae33ddd2c143b8e4e1b0833d2c47708fb28ea731b28b021a7ebc7c9db3fb0dd856edb055b8a7bab212db96ba41b817993c16fa9d29d9829215897ab162bcca1e0199e6f34401fd7c828009a85404ff038bc0dc006337ba6ff6f1018d55777b3414be3217e47edbeda0e957b67890d3d310226a62632ce4e9c1c154df6b4247e9dc3e04115b8b274ec138710f030389825a2d65910d0ee9cafd6aa7730ff1e5dde7cc83907758a8b31988d65776ef9d7e8926064e6280de005a7f0935f9c954cc70ec86c1c7da8c29c7150fe84a36e665b7de401acc65bccac4bde9a39340d8e49d64b8ca3910cc07806a20eba91c891de4d1b7fda503da3a6c5a5deda5d677b6a88fea774c83b258f415fd211ce8cdb5fcdc650b49adcafb1de4c6013d659ca8b897a9807142acec666db410d098531d181613cb466fb0b0719092231089893f71cfc155ac5e534e2dfc8e2ad3b7333c9df444750e26833aaa2106c80eadc404926bfd255d70cd1034b93984f4c550c02a10d512a331ec20a018c501395baae1a8f11de99e89eabb9b4b69863843f80d94a575af138338a8496e36c3b7d609d68e70934c1c367c806f0e6384f0856017d5916b6833b57c26bebeba62c36a57849102c279e8743c035fe26ab59cea38d4ffc835b309d8a38d45a5a686f74f8c79c066b8f37efe0cd2939537c52c3d1838f592b7188fed501a8c529844be43a81662a08702efd471972f79537a8565b219f4adb70ec508a77e3f822c81869d65183debff7d04d306a6ebdfb62dc4c32e51e755b5ac3fec2f2fa5ea63bbdd0780ff67a2bfa05e636e4042478d273ae189e976402abc048fb3a49dd52261866fc0bb18aa89ea6d886c894b05900da1adaaa18d03579c56bd6c5c5fc3a02c162c02df4727ff678bd86b9f24504b6d44faa08d8dc42a87deeb0c8b9906edc2dee4bce37993984d5a83553257768e9b3216d20cbf95da1cfbea2a32a8e51be4bb150a384ca6839fa0c57050af3a8295dd68a4c5d3e951f7d68bab41481e7b50686031053b71e9cf5ff6bf3f877fd0d380ecee60a9cb6c56ec8cd73fb1dbf841795275250599b0fc469e02e8403719ffe91c11398b2da271777434590e800ed96446ff03eeb319b60084824f431b805c2472b7c1002ef298431d9a04ebe1df72d663b625d85fe7cbae2437814ba9de728fad8e8315a4398c41aa188df3b8ff9381e371b00783fb3abeb57ddfd8bc84a109f11092c02afbb510cb9488a5012e65e2e0ef8868d4c63cac7e7f1c83aa75fafbfa2745cf3926b468133ee86c4f0a110aa8829a22f5e53659d85c7c33b3b14d2e62f00763eeecf68681b755a4e8ee2c32406e68845de8a8a4f05c1da23de12630100eb3ddde3a829eaef65f10888e654d9ad0d496043aabb316e3f34e54b09c7b844b76ed81c27c352eadad82ec1862b3ebe3dfff5dfaffd5c76b42bd2c740652c379e93f55e355e59fa2bde4352803b6b6ac4d145131c405a1cde825fc47f7c419d8fdb528d7e21bcfac28c22035d39bc5ddb9c40bc95b876c26646470a3cac3f239bad86601cc50f202e85fa1b2ca1721531977750cc01ca65213cfba57dfbe1f4fa44e6ff991af02c1e049b9a4cf352a334a09fce5c65705390cfc450bbeb6991249fc15cb6b3cfb7e3e471e59be91619ee372b4a639b10d69adc372d0626fdf04b63ca5ea4dbf8bb8d1aba5dfaa8f51d65045541861f787da3da053f852b571afd566b1ad4e028c112252a7637c228a1ac98e3e44bacf45605c5c0212a9567b4bef102d15974c4faf70c3b7c33c94640da3f53502bf8467dcbce02496d6b955f415e74a001d44224e83cf1be6fbbf05ff24ddfe8d80e8a8bd06e77597a96f0cf606eda8d85a1e95e61de6ef3f7c92002eaba92e2dd7b12c1e2a6c604b1f6a0333b946fceb0f9ac4d01a2d447915a1b818fc754fca3214356712002a326b03c89ac517b2fc029b9ad1906340a564f9248b65d4fb01597f699fe682205fb1c1172d687d5f22bcbccb7210143586e1d2aba68357d3e9b34ec551ed60946a5886e514853052755f581130c574f796cab9c9f190af5644f23494b6d09de2317832b760e533aedb512f1dd331ab308ed9c45c14180efe26a223c6fa0e1ea2c337197e6fb0a16fab2a3536abd34a4fdce1a26a5b6cc468f0374604aa3bfe7a3c8adedf0f2f620bc616d50897446ec395dd06d63e2c3491dcbb1e47e2d164d8fc63511f72e37269bbc0e87fd42437c9976448d005c6b2d91e7d25065c98d1e10bb7251d2c87c63ada9e42ae2dad479f65d2a6e7c1af3aa5920de789e9cc3f7dfbd2e27b0afa96b1d5e2a6695139d531e1f856da49f501c52a35dbb11a552237373683117f7f6cd2627d51f2086064df17bc971694bb5a26ef026fea20f986476f8d1d7bab875dbb4ce31040d427008d84a320d132629710ed82edf3e14ada8963f6ec890557c86cfc41b45ab551c92132b15f71bc6d61d0474f7063eadb52ccb6c26b2d6c975dbd99a7da12ea49ffe650c6766200ffecd00e7f96c2dc0b3bcaf1405e20d999b5c0806e02d264c340217815dbbf2cf9a7a63aa44e51932cb8a4375ce78e4334d9f61ee08e43637ad4c617ff17e59646b621443c059d573de16afeb2ad3e6d38d7aef9b0677614bffd4d7f91adcd665c499a84ce636345f188f2c86cb059ba4f82d22b897728abbb69d531daf6e6db5eacab66dbf65b8c7bf68b028b40da2b21a05d1bdd5fded897702066c0bf2b44e2ca40485b8e249b98ec2325c0666aa7ae4f6e52c554542f46027ef4618befa2008fc1fe7354cb3f18785ec9fe7016ea68a8f5971a7cfe62ed55740668ce4e126583bc8953302091367ab640fc84c326beebd202b112ebd5ec375dbf4adac1a443b9be00804959b70377353ef3dfc41bc5ee02fd91356c7ea5154b860393a376ad0f5134d406fd5524cba85700a8d03f9841d531669799e4b0da2699efa34b37e9c27dc0ee67f1c634c266fb911a75d25309fe525d1ed1de7ede96f9e8956b16c0ae60469829a395f18e0d0dccf49fd6b37744a714206bfbce52fc7142babe3bf1517cf2cae6affb54bdc7f8576b2e1473df06d87f4ec241d8c58d2fcc1c9ca3c625b6348cdfa5cd42b8490193b48f1266b1e012e44016e1487491c4a4c6c262d9f5d3bff0acdc62051ae3bc0776db1a5f21309427d9b8f83c41dfc87e7b7dce89fc23116e21f98218899bac74ee926bf02a02118a30544c1882c09dd1cc16bf8539ef823782915877023287aed6cb2a4f03641a12fe28895b96f911dad33b1f87e232035f6814e5680113f72648c5f2d9fdd46f19844f076c6c127732a94a2642a151a8ddd1bf500a00c10c24bae28783b8febb53da58c64f684f3ebdf03be45b35e9afa8d92cff010264a7e38cbd900103e1d6a1a0a38f11af020995c4a1b1aef5b4127e40df730e762df6b586b08f2e3c3bd3d3095e5bf9c22c6ff2ab28aea7638ad0e31ff4f691fd86524704e172fbea0510f15d36093ac2befb570199fe6df77987335c09e5c671594a6995cadcb59b8f72b07c8ed540814f252dc17a15da63b8c0243ceb73e23e3550d9c7833430b3d828f3bdf898c3039c58f3705fb98fbea7e51087c0d56288763204d8d6f320b47fe61f396b49e589d7d52750476e4daf39de61e463471dea0f58f8f7c86a1f781025eb054eda2825355e0af059c129f9ec25243d124c379ee73af091292a29736db4a528a2bd206fcd133fee23576b9b1375c781f120c00081e180af271030ee94da9159aae4d923152e410fe24d795e4d516a48a1966413f6edb57db60f12ba4e4875fb358a6138ef18a6c4b73e5ab83afedd4d68987e67d4e83727b2f5da11330ca2a5babdacea0a601a5a1179bcfced13849ae6f8b9b50f254e4058243c1152d562a5d4bf20c0babd475501c63f02b9843de632da9de9018ff34c22437e943fb7fd276ce5734d0ae944bde93337d484ab62f0b8670f94c980eee6c2c16dd018f13525d341d36109f58a8420f78b3fe188bbc2824f34745748e473da25db0b1825601b8e2753fe6ec8f97047426d68fefa6754cfb0cf930e1203bb5d786a2f8d26fd6d1255a025b2f0d8179e43ddc8d2d0e2206cc1ff8a4a4262f12155a610b3b585addacc322d9bd6f9e57b780685fef9591c653465a373bd4c88df9f3b9309fd5db500d52bcfa268de040bdef093baa71d7784891a6824058f1eed906e0b802f6b3cfaa4ddb27ee205c99f78d5c0c7aa34abb5f8fbe9a7301d3be4a6eca3494ff77f94bdd12dc26a2567ef3895c1a15b749a01eb57b5f4896c30bd466dba57f8fdfe07892b09e4fc3ff649d5fce35f0adae8f63a5495435e05d3da8aa107457683df50e9ffa5c00472423ddba3d5e946ff786377b7965f71e6743c8725f11f4fa71d0f66ea74420b66a4bbe840b16de9968ba8c31e71dd5071ce6d4d75758c5ec842160e522280fd3a3d6e9d78a4d99cd7b4217b6b94d3f448646eb0662bce76e425a5ef6475b139a1b2da624df6006bf4ad91ce95d57fcc0631a4977251009bd8ac96b0ac3088a29b4d58e440f3b73b87d7ded6739e299d91fded7c3ac3d61c90372a9df776c2e54bbd86c18692bf673bbea849bf1852aab8d5dfe0444b34fb541c87d6d6849a1946a414ef0c4aea47b41cc30406813bc3949c7f32a8d89ef44a5790a8d276e58491d7e667358c987b6f5b98cafd41d335a5bfbfec26555a24c5458f3e3a37c43fe64138458bf3c673b05b955973975e90e11eb887dc0cbf967b79d0a954a849ee257285a90fc641b435784c0096fe207a317562fcf7c4952af2916772991b3b6ee3bb473c9f13e668bb73de5ee14465eb5331e0964682ef76412eae3deaf3ffabbcf70e499ccf29438ad3174846fd738408117d71cc4be598b6a8dcba902821529034acd45f1aef3960611354e057adb14be7acc49efbd3517360da0f4d13c1201236b8bc3551a9dd31ba1f06afdf39a197ae3d3145cf25040b91feed36177ab25f44500739fdccc636f2ac9ebedc241f66b3f04590e96328f668300289d4b43ee437166f2e174dee45ebf3388689dc52cee374f80d90f9af8b0524a43325b89c361e65e4e8cb9e149e528e8388024a98ede94247b2f92749689bfcd6d1c0ff5c426e0ddf8b44c5893404b8af099f29cf1aeddf38f5786bff018e54bbe439b25ac1655fcd81121e4b5454329056db2731e236748166b123de5b732a17bffbfb7d5f96b88231e865dd0db2f7220b78799394f449b35ddbba362621e1e86fb5595b3a5724811d51f054365507502d870c7a9cd4027572c56cd5e1f6cc3eb9c145194725cc94e2a45757a3d7c0070b89e0a7820e02e0472af5001a1c8ff3e7c75f584cf7f39946378204673eebafd88b81c0f6c28eea078d4af38cdd3c3c88e85b2dfd4d4bcbea68873c1bba6af8bf7d84db6753ba1affc427bd7be2b1b19dd03e76a0a8a5ca53c168f7266a52efbb31e57e1877535e32cf70db7fa155cb71b43cbca3ca86bdf029f79ea3e016f489d908c116f80f87a82a9abfd3e7ef8be4242f83a0de8fc937b4655abe9041516d4bf627fe846eaecd3d0de367c3d75e080238f47a571c5fd361e4afef0cdb91860b32a3124c35e7b3c7edad6e737296bea4cb0bf4f12aa45ea857b9e4acde3b30f703306d7a86eb5ae7815e93786d1278086fae4b856b70ea0310a5a97abb3dc685b23c7112eb0f99663d43726c9c16e8a3fa6c4531c45236d83afdf3f178a92738b4eff0aa934bbb0b167f5dc08dd1d744d7d982047b33291fbb3da41d9d00ad065a99780984375b8df19e29ca3fb36b848e877d8fbf4b0d9d1525316e70b07932c7287d430545beba564a6aeb32539b8b84dfc6850b046d2b5a27051a6783bbbd2315bd84108c5dc5085fd3029db4558c621a9261fc2403183158a5ad9ed6a7c33711d833737c5a42bfcc0ce3c9ce7367ce8143b3b3a2efd9c6e856ac1b70e675c3c2426799b7dfd1908fdcb6ec95c9baad0c72e7a23c147165058a7b9506d9db51a7a3d5a99ee59d67cb7798193f5474ea58443c450a788ffd5901cfffa6e311b581cc24104c40f71236bbe5e0feb9b0fac752600174a9b31921c1274136971958aebe2a69bae1571a39a106037a6cb643706eb9c23bf73b1613961fdd01885867ec447e72bd70888c3e7ac3b9935eaaf3eb588217eaabfd35b44a411e439d6938661bb2d00c5dcacc1d979556fa55b1827b26b73c0b90884bc9a4932a297a3ff0a426845ed91372471411fec72f77357dca488db21cdd9408c963a2833574369b6b83ca83627b9335d5d5116ac145a149912dd053d3f1a21694f7718c9faf7d2f06d3e67867b1fd8a82e6ea5b523ffd8d76889c62baca4f1fd85ab9948df6279677e651123889b18238ff8a5d13303fe8a7cf12c83d8d657c7b25359b1250fb043b4319c10f3755daa13e22134dc6cfb37f94402970d133438556c71943f15165ddb5d5f3f5c36fa520b4a6513de05899692f6391fef3106c007cfdaf5b642ccd6538b14248b4e9fd26fb23ab78d6617238383cc0fef61574d9fc6d500ca07bb6f9d038d76ebdbb954867b86a92db6220e26aac20f36c40baf978bfed0e39943992ee2bb446c2d1bbf09ae9fed28c92e74889144f701ef37b08188d78e5bc8a85b547752622fd68f3d27497891b57d8e6b802f79bebf6eba4214638bc2a41e5e2f8a43f10cf5539d929427b1075a42483e357cc4655cf111abb4dbb6cdb87a17edcd6d4105bba67fc312ebd479ced8908947f6f5882d6ab18a7193dcb0d74f3d2b86450610eb10291f97c30d21ba7e1b5380dac7eae45f8f8c5db58dc5926d793077981a684b478e3b1a3f7eacb8bda02aad96ee01ce3382a4b8d9410b3db23d59a743baf8cc09bedcae9a5beeae97d5b4d13a4f17b1eccaed907986b285e78997fe2ec159344ec1e3f8b7d695ea50a09cd6a83385284de72b0b8cbd31627044f00b4b956f61b04bc5cc2196c5ce4abf89575a145f4b22ea81285656a25a7a87fc52f6c3573b76878e1073d6d6dcde234db62b47d0c0cdddb23a19f5db2e23799afc3c11093fde12fed7d49b44bfbc3c25922c442fd57a135c4ac6721cedb8e0a3e3beb2e65f755670a215c3f9dc3545f0640dbbdf5a0a358a401353d569a5e7c98e088bf22534098354a54f37a8d56fba17c21ef7a5c3a8732b931b2bcc17fd39c0a4507d4b4fc3ff2f247dc4f27e513374902e7018a6d24921c008e6622db181592e7e3a4c67bc2e0623f133b1a0a25d725c5d5f259193c9c1f822bbda3c5ac1e80ec895ce956156f770e12abcdeee4f4f7594d89e13d2b93ee5a2390ea88f63eb5f86711ba7c0909d6089b89c1f13267918fc0f2bd8ed1ac8ac4f90c612c8a1489d62898214bfc940acdfa0d9c0722133a446c76ceba1d4076aad29e9d04e17006bcbc3ef74f2124de03f536480a74abf05bb399ce187b042767946500f27da5dbd0445e57c2fb40aabd70e6a2f71141e967ed2e42bf0356f78b53fa5b3c6eb060eec54993c64417ecba79e20f618fa468178b0d02580a16a4bdb1b3ff47ce49bb81046e5ab030f0429ab697cc9546f4525ba3ce340ca9e840796b85d50ed49d9c6e2db7ad295bfcce28208d8b7ce51a82f6025a1e3713f0f602a33f1240acccc35758c064bc91970883ba75c804d35c45d7c8d75740a2dc06aff9dfcb9a92e840252faa5c53d149217e0837e3c77fb8e60a62185129c0d739022239d0a5030614f803388a2117ee3f47b36162f8cd3901881007d0e57936e3e51763b9901a9535aa7d0ace2ab7d3d67f9990493147df44f7c5b2fc41cb7f5f3aa4bb6fdce33f241b356bb4bceef4d8bbe66264c4ac0becc38031704b324daee55fcc3cda92fd2d761535624859b83f33bd562d8802c3be5c2db76b44bd9e242a924bcf1fd92e3a1dbb4f750f74800494a3ef347d4c584e0b06847ec31dc5e5613e89b619658bc5a9462680058ebf73eac5e5346fe327a0f989ebf1eef998a4e150c3a870452220baa64786a3e1b3da2ec60588a877782f4f44da7909d8348485e2bfddddef3e460ab2706894b2e5c0588a33723baf0e8e690d7a588df852f57b083e6414bda53f66a88d9bc71abf34c8ee5eae681bc0d871257bede7d20ccafd3ee8e8016e560920c894b3a21a5169358cb1ada3bafbf218bb9e8470850b9ef41b8eebde332fea9e034452b6922902053d99226dd9514440c3b167a640223d2b789dc4493089cb31461c4d10a1d6c15104eb43484fa7e5728c9aa2eef0416a89ba8e83f191a727c243d3ef763b3d8100cd52934370b937993c6154822e1faa54e3146783a44d4f15325665c6313754b194d2ee8118cdd93d9c513fa32564d63cf038d8f5eed5690da62d05b49265b4628d00069dfdaf9080834fad7075390d468764f4c12a47f2d5eee14e7e8369b7c48fd77cd297ca213e543b25e6aeba5fae5b7791ebe4739243d5c82d2682b64b8c3df79744b91fb8a1d8ae16923c771ec08ddbe34e17ce423da4a1aac9aa5563509cc7489d0572a9937a4699cc986be7e508ce8c43a5d02de94bbd3b98f55f1f5d1cef7ee5af7deb7a2f35a1b880d0a9c4abb467cce95830ae1458cf7f4bf8453cc5c84ddff49e2b4e40fa1c4fb11594fbb6f395b24b851fb76a113ebe8b50929d4228357a41bace5ecf692063e31b7756a14b5996986aae7257f085d7eb39fc386d5a218b0da2f0a75f7eaa45bbfe96c752dee7a276eba04170f8d72929ce107f1ebabefd3143944b3b0be7f01fae7b3db582c4f8474ee1babfe2e2741fed81e95aa2794f7729e4ddd29659df1efeda1f4da1460a15a2ae20733c061af02eeb8694f46b6dcbd7fb7148386c6fd1c2f5f011319d3134ba58476fb3ad60797f5b0b26ae12a464c7b60c322a90304049bc0d556aae7b57f1064aa8a90a17df28ed6463daad2f58413699747535d8bd39df684a54ddc11f22af7fdb6961398c4c7578880b4987b8e3c392288e99f8caa54202fab94cfb59fce5dad93949fe71bbcd714966f8ea5b0df1f0963d5cb553ec01411282b418b42d0e82f06450ed76a0f6535b5ba16d2314dc65f5df11dfe1a9870f6e59fd36b9189a060aa500d384027d77888c4bb3fcae8d17a6ef7bfb285431a42cbf967bae22b680da258cf58df0c4c943c46d113bc7c8874e51dd218e28492e2e512a24a4dba6964d1061db0b9c412892a6bb849c60972bd1ce22bf0a6d2f0c8d484da211c36b3938037189cd6a4c1442f6245709cc7d760f531cb7b5703efda97263561e2af5f80d03d9a6ff4943d87499f74df8768835fc5052422fe2ade1f6a4ae3250f10184be074a352be163093913c85d05d27e9a2ad9a7cdaca967aa44eeaed0b741a05b4aee25e7de9eb62bfa473ecc1c7503310362621fcb8c91128e86f4e0ed1020d1530d68ca01572b27f07cd1cf6b8068c9d178530c7232025b4486c799b5fb4d6877557f736755cb60a9f24be42138ef018ac5d35255c1cfaaf3ff9903e19b61dc3aaef324e6eb988fd2c2b09692e54e4124aeb3bc4a684df3c7182c0c5f7d7b98ad07fd87505f5eb21545cdd0da403580c808dc0da330dd29549fc255fdac88cb3bd921429add74afa78d48b3defb0fb4406e550b6eeac0120f1a1360a4c2c32fea896eb2b1aeef459d83e6f573d5059f97a48e4c21f2d37e324837e4f00b625046287989d56a6a02132320084327b0298969d2498b6e1b8e5833691625c26be67d15a31e616fe8ab32810da8ecdf10a139bde1f36135a06c66a6a15497e906e60397d68e71868a321dc9e09db5acf42f32d8b23e83800b08e8e74ea4d1bd32b4f27492b3bc09844c420383040ed259e06cc418cc6d9ee71d3f2eb77560b9db01e6c9abd94df5328e852033ec1c06d791d54fc798778aaadef26bc05f7490a90fc23f24a4a366ea44510888ce2dc273e326945bf4ea612c9844245b60df8486699b01f182fdd396228920a2ada84f1d364158ff02bab15e3b9bac4b0fc589d4c7c7d8483681c6a8651b46c3f41677a2cca634779c4ded828a25e16404a6d490b5b31530c948462c585efb0b4a0b8035a778f3d27a2d5100bb39b8068cb470a9a4a537b23ed8f90f3875fc9e8fe46bc5d274db6b4bcf801bfe6c8cb0b82fa83b92d0cffb2959e9f965d09161cfb7e07fc67644720d06924c6c0394cc451c3bc47b5e78488a0adf4ab9e7f0d49995a1c7913169ed826ad5567641a532453930bf40fdc0f0b9adbc4ea5d20fa176097a143acc5147f6c139aca5824200ade0ad5e351d005d539ee08982b29509c8b944ca4040cf13cb4c3f635cf823ebcb9ddfef9cb769d32","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
