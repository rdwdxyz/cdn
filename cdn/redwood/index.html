<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7c16fe10d5704d0755aa036bc77bf77e172f8db0b28014f00f7dd30203735a2635496d2351d38520ec1487a183c816a2b553c9c568b848a15c2348f7e4a077be30841ad517e72e316d2fee56757b907b68c901e4f884c85695a810095bceba4a76919f3adce8c35fadc02ece00afdee0f1e7bb03e6084882cddad6382caa884990fff471c60aac3f03ee24bee66c4f51522b4d481f65cb561e9c3c476f02f3fe2941d90857d3daf2e29cc33a4d5dad6f81a6409181afbd6c0996cf38ff1bdbe64f33027a5e67fbec4d518de86a61bb7f7c89b7e70916e9d7f3cafbc9c585a74f1236eacb55a8d71c3a735b8d536b1258e860748fc7564e2e6401a2fbf1de5ffd6358c78e635bb85f1dfec16b21796eb84c19326c96bd5cc0cff220839dbab73ddbd73de53259df4a42b3bfdbcd7e43212840baa33da41817f922476458e9142be31453cbd484ece3ae5426d5973151c7849cd1bafe91a3e42a1d97601c3b58ca55e0b0cbf0f531265a63580e77b11b3efbea645acc2bb796d72caa7198e4053a40e1fb7de45f015c6e0a18779bc271edea80d35938708d1eeffef63ea962901241ff94aef53611160368d9925e475c66510d14052bc8f1af82eb9d50ba5fc88f5fa42c3a1ebc4cc0489032210d31684a1a17b39333f113b9b11c19ead9b8273b342b569996eb24bbf6216a006e372a58142e7a1f54dbadc559d8338a6d2a5bca7f6052c6d06c6c44cd48e5490f3dbda3fb1733a67c7a8f7a09fa98005fcad2a3cc2c0afb9ac9488ca8e303885aa0f1dc42146d4e2ecf6f19f633ead941e427c4bc6a9381e5b67137a64aa8538f0e63967e2040e4cb642f41b72d5be5f17c7676474adc0787dc1ba74ec3a066769c18a4d90bb42afe9fd2a6b632002006456e66bcce0c6bcb2c0d8814f3e417b71a4c28f170cff634c554010680f4fecf03fb509151a68e2738eed49a1bd9271bde53d00f636d6c3d99192e4f39e96965dbde9d22bea92771ace74329b616264c63aaf2d78e9907557ee2ec8203ba748682228a219836c010f513f49b841961f6e4f42aaf79350a09c6f3493d497b3aa51b62cf5220a2d35f6971bdaf29eb204b94d6acd970231ae02f7f5b2c879236058171239dcdc00da28418f392f88626a742bb019902922e9ccd331a62f9cca77de08e2dc631203a54b97148a3ef39224238068f818391e8db7e5c23df0b3b7073da8a1dd125a5cfe1f2cbf12b5edcd9323af13e452b059a58a31fea616c284a149ee6bc776f2130c6224e3aa25d4a9f7f95a8e4d8e833402e7c4548eb2919e701755346d7875862434d056266f8e0a648e1521efc3527cd3269b3a044bff65dd686071d53136afde82a735478ce2d366f781356f92e9ecb25b7876135481e1f824d727ddbafaa960e7a60f39984d91c5ceb05f3550a766a17b044c715a7675a648cf53df9bc033066c826231f1c5713a23db098b915760082d797397974518a91a59251cbaf391c3adbf80c2d45f70549ae95229c1bbcf5eb38cb0f6c666b85a4c9807c9c74b43c42898b06b8ed0ed53ac6ab474afa9a41eb2f2ceb321c1d4ee23f086326a686f55b52ce4f22d1c9f6790742dedabe66692ff1dd3edc440e34e0ef702685521bf5e52059ccc12b01bb89f079b5b8a504b22097f40e64303c4dc3297b24f719abe35a3ccd989022bba4223a004a43cd30fd85422a31897c33b3212a26414f097dda4059c5e8ef4ea06771745acc7ea55b8c7c1f947a405a5abf2d19690b3511a12d92ea528571e9ab699b56ddd540fb8f4204519bc53f79a3a34b022a748d9e96e864879064a965075525c2ad2603fad797e061523b7b9cdd74ce15b95afe93109b325245013ad97bce1bc67106e34ba51a6568ab49d8627a198a8869a227cdb9862886a1fbdb488877b0c7f979fa2bc312aa9f2c19f6583abea50cece6b3d6dea68691ffb770b3200d2bc3a7244f07dcc15cc70783dc4e38b52fc3f3f33020d0bd404928e1263ebccd197042ee005aa81270ca786269613af2db92048b2d337091547233e0bf451fcd39d389dc449775e7eda7e2bea2d92308d0e158ee82ac519839ecc533fbc76c095b8920fb17b3a46d6830ac74a1feaca306ecbddab8addd6a91d6a52073e0e8c2180070e1ebf3e4b56eae05607c5ffdeac8fd0fdaa940c71cc259ff4c29d4fafb16036c2d5fc4e92cab8a34b310763283e72f0741aa0de3b8baebdc7fca7f677913bcd3de34b11913f7edddc6e9c05e480b6e22599e63ad195cd510f30b2919af394738a2445dc3f1455af36bf51dcc6a8c9161280f36fbb3e15d6c7f83c58054c15ed0b364a2300571173780a7dce76de879ab38fbc26cfa34cc8a88d25c71e05a43afcaee2e5a711a928c1ae81dec4fd34659364ad90084b0761a8f8cb06caed6f36284df0c24181a8f95d01e964545994897cf32fc291bc165e4a0cdbf11da545d102f53941d92d7c2177f3ce4e5e561fefd5b5ec35c8bfb303ce29e89e3d3ead51e19d3aa7f2a1614a760ddd4843502dfeedc8e59614949eb66387b995857bb8fb2a901493bf20cc44bcb5214bc4c4cac2e9eb7b7f18e2cc3d30269f671f6b4562f5d29dd5f57a6c5b5f20615d6edf16ab0da7e0bd636ad099135d6065c06347a7d83eb7fab6f35ae8877bd20c8eaf9e4a8b7563e5e3a01219e467df90f3ddf09dd01aef2f49359cf1abc857c06eee4951178eb0e7a8f19c734dd38d1efdf8471c938d80c2c67317c1cb25dd96638287b1282e9dfbb12f0884111395f0718de5beccc920052db5396992de599a3618d009bdc6f1a40ae52cc6c0e89f728e817c491ea09f3b58f129bdd166880e9a6c628477b4eb78ad3b2cb02cffcebc4e5c4de9951389286dd6b1685a04cba9875b05a510d6a118ab6671040e1d4152a5959fd7aea413b676bce41f0d9dcfef6209c28eb2d724ed3b77bba70714e19dc83c0d0442ebf74d78e88b400e1c1a9fd2379e07c9567c65fb6cff4dd8c57a7733514b92033bf039b4a310af76ae4e59cfe3a7c2cb85bd2efd2b0cf8be06962c142786b5288470738a5331e710c43feb13a86c937aad73483169fcc21080d6d2c08c66e02d62fc17cae0dd2c806c79a517cd9d2716e2cf9dcbd1a52170fa3f46c208222b4ea137ffe971e77bb2ed4d310060c2ce952c6a1ffdfb403c2833e97833fe6388214827a235582dd30468a56fb22e269cd0703b1e3a7dbfd2712d4b1038b07ddc9874d6d5256fc5d1a42e7dead20146f081fcc0ea9d9d954aa299563825ceb33bfe46632226bf382101de52f9db52be857262b6fccce938a1342251da85a83dba056dd172acf980ff8ac88f797a0b0de1a1912e503d6d17dc6ed560efa6b837c6bc208c7c3605088209be49bf3eb8971d6d4f2034c054cc1e717fe10661a206f55adca7921b1178a793ad60ddd1aa620c516963806b05ed872fe486ca37a2549fffa0823dccc1b48d260561ff39d601f8001e107394fa3918f8d2fc180226b87aa9b276987e071e71144c05ecf030bb02fbb7fb79be3784a786e2c6191e95523699fa6c6e1c75b8db508d5158ded074f21f11d5d741de294baff81af497fa7e3150b695b746b4234986a60c492847cd776d0b3076d60f61fe76a49c837b108d7a6d4e3c4cd43340b97b37e1c5814b5fe263879854a970c6ab4d036bb9d7b8c34a8f49d1f50df09cc998040d03b82cd02b438561d63dbecef1d1346ed1e4e29f9b0097d6ac3a91df0e1596655dca436e54388e78a5ddce1d36adbb542ac13fc6dd86fb8c6d17693c8ac835682d044d8e98b1dd3a1146c47f9fb64982461cb8926ebe1632f09a38d75f4dea6c71174b73663a4e1abbb5d21a602a4c4c08a7e9070ec479c1d8217a7dfeee85924cdcaa2f9d150a67b832a1e29680fd981f3bd4bdce5f561720d52787c4f3c6918d5514a705ef000d49cff84f8c6c3413ea0ee303cd0fb2d455bb537a8d6d8722deddbecca6b54432144f604f02e26c1b5f9321df12ffbfcdb0fb13374026783e4e81446b705537d5cb5c0812ef64555c6fc9605fa61f09d82ccfab556d34fc37360e0c79a189cf720a027c9afa8da49a6c16848501d4dea821b1baae8c54f3e7f8402de517eb6c08fe022b3cf48bb49002d452770374bd1e192d2d8c84221d03a79b8c3fcfbbfabbbae007b7a746cc3bcc74047050301845dcf168599886b598d8933d294ba22b21fd8170e098f52ea43c9f12c8eaefd7f3312329c96c43886d4dedc0f4bfc4df8bfbc53de1c79a655329b0ddaca5b13cf6fb14f823b4730c4f2adcc066c2d602fb295df84eae2728b96372ff8ac3af305868697580237907f0776c0fea2d2a03d71a4aa2f909fc53e512764c17ede4311c45dd5289c0630784993da74d9e3dc5b9588995c23fcfeb28766138b7c1b7508b9918c4fcc004a85993a5da31462148cdb96989594f0516fbcd6f0d4385135bb8bf01283095e7d3736a64cf18edd10d8c3434d94c3341178d153f7845eb07e7ead53994ec18966911b9defa14be2ca3a63494dd062309f6570d5a996971b8c121b6378718a5b60327fc5bafb145ca2311c4d012cd5be0432fae58973cf6abd43c7b0daf34b069dc4eb6741f16f61db25dc511613ef5e1df639fe2fbcb75bfa400244f086675bac78d9004ec544137efadf7f3d33007c7c021c0e140163020856ac0325a8640356369c288c16338920a4855097d84077b2f1151516a606c80e7c583537484da80210185f37b3c2755c8153dd30d6e75b9ac4ee3cafcd27722f28be85a55b60a81e426987248176e3857a402978ee334df5954989ba35e02a99b3d6bdaf765d62c6ccb0be6295a39b803e6479925a59106adee63f97e5658e3d545031df2d4fe410519798faa33e1779f31f0599b1e35befa1bd043829fb171a455dda8d7ade29a96d1e68bd766c9216af87ee64b759d86abb3fcc7f34b716dbcd903c428e92afef6fedc3c9fcc69689048b7fe848a0b1d90be6be64a4759dc1d7c01a6518d580c6968c79ea8a8b503b009c48c1a25ce6a10a17325f55b4bb0de529160f4966648ded3643e331bab2b616fcda3f43036cf536147f741d97cfec9ee72b6f23d8433a4299f365b3f6d6b77bb98181472859d4f58b6e8df0105ea739e797cf29edc794f9d540b39a72b485876b5566e3d450ef72f258b8e6f0841455d70b463efb94bde8c247cef03d1af5d32e2ee4f0d46282c524faa212c06d4f2b90f72bfb2d1c1af2d3153d2f68522ddda5dd87bc1b9352421306167aa1546277278bb014ea3556818a6e943b03eff0db371c0df4f67dcd6d99969b2362afe53d3531ed5c346a343416ea2e2342014ea528e82e9c26f0340ef4a293bd8dbdc49d04eae2e31553116cd909b14120988819afacf74d66ab41e6f46351fa295b2418f459d53ee02c2b2e08367f11b4b02d42e245ac0ff2561d1d415346f63216849df647fa252f570d3fb5ee3dd101980589aec59a41189eeeaea2993cdd158b2850db844f04fa2291ef833daf3b37892ae80b17602e82ef4de6ab008c4837f5a1beb515175ec065de013667a097b891bd3c947ebec11d3136fb0f6018f5130db52d83e1873a5d63059e5914cdeae7716c23de6c9b51e1b8ab7269934affa8fb0d401b0c56197aa96136e6936ce4046f506fe9c1a91cf8262d0802e160f9cf28da63a9daced5fb67369d57907392bcfc2793b3d6f0ef3f3c4c42bc8025951dfece8214c221bca8bb9dc18143495a1323d528047dcc38b675f4876ea4dee407dbb71f7c852301079063d2eab7e8709ab6fe2ce1917d4b0e98c3bf58ac90fcfa73b5b62d0b00bdb212141b3f3864e973d9a6fbb43b3fe9f36cfe4e367b58ccf809aa1856d9d0d34f36cfbe73dbb3468a4c571e6a907a247284c87ca6dd76fb9e0b3354a240364115958a138207714142e5d1c1cae3e5fc1b7498f388703a69d4218e80086a15142b0f161eec3777b9d230fe1c1159a369102c3aa6d912193316dada404359857211f4fdbd8d6d71803db464f3b6a0f64f7d9c6187e5385c195325a2912950477b06ef925e40a487a1d85d1e9bba244ad42307fcf2b933dadb2c4869fc919992c072191d913a9e98b3534c7504ff7c45d27df7c2e2663b3f85cc91f299f919368d304e606bd0abd88657f3445f9c672461d0318e8a753459655be1c6eb01b0966f62c46fad61afe45ebff9e3e7def9b27dd0e08f8a196d06552d1000b8623d97d14a3462c5fdd3715bf78ac2c720f29cb4d4be4493c2fb6f8820f7a526556b7715f40a230af99eb27b4e06b2fd8bc8d3b57b49f1044625c575c1644cae091748eb1501f7eaa15a94cd1e1198d84a655f8039c9c1d12e9ff2026e9fd142f7f7506e18353e3b022edf2ea5515ae014211692ae774bf639f41459660ba93e845f9de283f75977fc281740da013bebe8268412f283262f0debcf0341dfaee34af9f13233c5a5c3a1c91d5d19ae6f350656b715c20cca563ef3508322d0aa5bd795d642579be6c453f0dda0042ad1fd4e90df736bd4ec34b08d5ccb0cc1262684799f617b6e2dea0e3a47440f1730ab000eed93413e78cbfb4387345ab0aadc34c04c4dc70eee18bb8917f6640101ef221c4915f679768cfd12ec8251ef95ef75ee6166e0d5ec9a1c1dc7cb22cff4fa9d5a1bf602fdf001811f706b05bd51e2c034d71fe80f5e8eb6967bb036526db5d25b53bf96104d4580871ced8f1023fd2c5251a4de504f904466d302628db043f3daa0e2a895dfff2c954548262d713d753e917c4b1bd958085f3343125e4b7afc59a5a1a4d37dfd53e00f9046bdbba385b31fdb7b99a645cb396e7bf48563ff325b79e2578e00ae41c7275f2230be975d9acdbcd6d3734f3da789a3cf4ec7b537bf58ef25951eec6a32e3ee26b00394c4b114cb373caed412262df449ed58c4f795b0d27ff6f07543555f395d02071e234ca7dd42ee581751fbbe3e476d025c88c2267c28d568183934c504176d9556ebe8d066447a92a8dff26f334d53294a61c8283dfc982890517ee257c5e6d1f2e76e85821d46f0bf937c40d03de18bc8d1c8b25fab4f6266d54e2c8ed092446165cab4059308e2e87e974ebe961dd570b13d019772c08edc24b71a3bab6558c33840dce1ed52045257733fd59451ea2c71e2ccc3391b4a3a810e6a852bed6cc79d6203f15c31241dc35ee11332e1fb3486fca35d0ed6da82f6754dc0772d36e87c58330cea9036efac78cebddbfcae0d43a771a8e1af2f7bade20a740d72faaddad50cc6f6104a8f7509904a576ba088e8ce4f96cd378de0e8ecb69fb6de0fe50edbc4766518d6a39ab81286d4820c5563a37d647a4d78cfbd375ac1667009619499c69357fe750ebb78d02d5966b1012b359a5254c010faa474c7b596ea36d3285e872e8b4556750d4ea10057ff4b96e945351af606b5bc05e966ed30bf045a1b6bc4433251c9696e67bd30f234e8a84043155b053e71a278f3e2e41003c6a37ffc82a2f698db01fc936bc6c5d4c9c870d9a3f8328abfe225267190d43d00bdbd9a74121ecc4b1d09fa626827f3354df6fdac0acdf3fdf24779e28821f7eba5dde8a92d35ad5c0ee93dbd0e9de8b8226b379f5bc9679f3e7afbb801782822f4a8b0f6dafba876386fbfe60802e9aa25a2a70ab3515a83048a1f061b7fdd488e151e6a8d02888f6ede4b2522802432299e6ac95e07cf11efdff4901c3695ea80e63c118137f743eb907f28f9c6d1af22ec859d8172fa77fb4f4370015193f52ea5fc9651d814e383e4938fada79c6a7eed7c31bca24e1290213815356b223386c91818b8c5c4945bb52c384dde4f18bdc51562fd2586124770da48207126b10d4372fc46d68f1fd3d490a4659bbfc5f76411db66de8a77c284eed98a423a98314cea358fcfb29426508046f57916b0a48b5ccafb16cf11799e86a68a789524bbab9d6c519e60c95423cf529455f4da0461efe342f2ae5a0b29ceac0f5cc03c433f6c0d6007f8acf1acdb398bf47d840d4e4b0e083c418cc046c4ca07ac1850517afeed2871be0fe9f888192f8d77614f1575c3f7c24a18ee0f7f51d54260a73fac063737fc4eefd804fe00baa779d98c6fc49e99828676f81cc0ea27edb51f79fc89cdfc00758eabb7553bf34b56d405bd9a494294c4873fca193c9e219b76fcfd5450f5cf0edb76acf9561471d92f609a52b795dbfe8a5db162b14c0496f563c078e74a6046c8592d960b3b310ec444f0ee3cdc4eb0366635744d186e7a3b0f20bf85ddf513277780960cf92744a601054292e218a3899efd8525dc37cbbf4b341b37e80984e8e0d071e008d22436db5c2dc6ec79ea6dca1b488dd20571771e9174578fa104bbbb311917de0784160859186dafd31a0a7ccc32bb9c5af4db43b00851c94101c882aaa08ed8b33a5352928fbac20275680ab3c23bd8343815377d46a8e6bd8ecbba1e13792ac5ee4d8ee7af424d33587075aee70b0cce515fc9e019365c26185f15da601eca87decc00d00a07191f94b69e76779e74912950d56dd221a99a5c6e8d051b1828bc479ed2cdffd4176d8e2f3a754cf4c360b059d140b424d4c2a3713cd4db6fc56a0adc2682e06259175b1dd2eddcbe559f0bc318abbe953f10ef314a7347c4c9106afba60db909494cac8476af05ec26462f5894561281d89835a4ad6da597ef769587e326292772653dbd4641a383041ecbf3c8f58c7bc589bdf3d39cca70117a87c2fde23bf273a9886e8cf763340574412b4ee489a2bb5c89478c07ba0e1aa037efc7bc1b58781214042ea1de9edd5a2c0c9ced9708c68d5c726982b453d95f865718f8d50609b333fc6195edb63650e123b14e165bcba1a0f48878881a8e2fd73b2645c791b7b87440542f0f9dbe8ecd04c04c400ad2f858acd754f973e3cefda95fdf5628fe6a6d4401572df9d73484c5d9c8bd770601124fe9443436133c39a1b4c0de9734b5ce49371c3854c0e5c6e515cd248fad68bf4683bcb6a880c6f571b6a8eb700ad2d6d24d854f8e83edeb385b0635c0623d458cb83947475e9fbb897cf8c3709f1fd33acd700fc71366070a76a0f69bdd1184435159a5956b03ac685770dffebfb6496e784b4737b7442c39b931d5b1036c26f91b3880be6375bcda481e9be459d2291a2d6eb724aa8572ac33f8557f00999302c3aada7397e95c589deceb4aa9b82f59fc9c197213296a120114dfcd3286559b860cb8ebc68138bcee4737ea1d96f73eaf6863949834e3bc2c654cffd82b66ae437903a4866a6fa93536d306e186c3f79bfa783f5567782fc6d24a6a744f4310019cfef2a11b65709fb6e3a2a27c1069105d491f4a6fe17c7ce52f60bedfd25544f974173fa30e87dcc58ec0e090d01422ce4579ac7170f17697ae97a1baeaf4048e4b05772aa03d42a5ac3818c6234e7ded376bc2e63f923c883f0f86cd44ff0655811cd8bc18695c9deec3392521c605d83a39a698d483134cb772e1fd2d024442fa0fb9172cdd4881611870141c16c422efe41ee33b45d392294a762de17563ecc56464811d66859b93c5389f34c27f2bf7f813a3a31cfe71995af8d6a1c8ac31711877d47d43e3868f3b553f246dbadd610a3cca46f79b42bacff62f850f0a2d3564d4ef6fa32c9c8ddc03bd7358015fbf032644eef655ebc6b81841c33d5c4cace947c165d345678aa63315f4cdc99d8a66f0151cbe1f4ff3eada6f03687da1ab754914ac8e207f6c5310f880ec73e67dd878060b75d79692a89e2881666d3862fcf16246fa09f2e51f805eca9a8f1c856d1e8edae47019e43ef2719f65455fe70e7e15609b3a4d662167fb1e0f4212470707d8ee0f53634d1d8db9c72e3301a5ef8cc378608c748558c37b9a2bee75be22f46d45764ea6c5e2485a457b87ac47059f54cc8df09cf2be2ae01bb7e5bb7d769d5e6d3d64b6b480f466fe23210337c9cf269599913b5edb2feb28bfccc22df2e3ebdd5103efba77dbbc1d6d8cae1593f31a3e65472003a34486d531f38dbbb7163057415fd69eb4539ae4b569f55b798210ab360b69a22da052b1b31fad57bd1b942360ec848699a1e73746a466c126a4c42c72fdcd3be83aeeab00d06b44fac5d04ffb9d1673035497272c326c1634fda7e39e6ec75cd66a5f67b954b3c730949e31acda62d017ca2c221a519776fa465b3c52d32227197226f70157fa859ab936e2671d9b3b98621a4f6928139f04a651b9a1242f248220b08b5c801abdf09809ae19ba0b171ee58de378936a510a711161c708b62f008c84a70642702f474327054c2911891e98f0b9d2a1bfb4113d624deb76599167e64447b3f1940426ee86469e4d86a5499ff5b368a704a960af3daf8191898a86b1e6ba45e2d344ba473da299dc32db1a1813e115f822186b5a3d44603d7385d9256f0f82e91b5c74e84af5dcd07e99d6e94905eb7d4a9f04516032f9e4de227d3b57e37cd7d98f1a4d06ce2162421e733ba8b8c50da285a355e4a812baf6758da72c8b7a4352e25ebdafcd18032989a3eab3aaa60be36fa4224ca2b208ea84816743350c438abde897fc3bc3323e7f153f3e2961948fbcfdedd5b1957d57568f501e36d591901dfbd725a56ceeb9e04f9033380ec5b6a0a6778c95ccc58a2f80cb5671b61e95cd3cc8020d9b674ef13546f00d8151c41eba3daa3ac5336ed545a37a1e4b2ac686caf3bb725918e45ccf1119690402be9ed3530629827e47c30ffd3bb0990475d23cd185f03516213fa29cf91777c70cf486e699d6677b501265fc9842193edc379e8de107bd35f49f4014ce39c3e13a94bfb0ac20e70d4262a5d0b81e5ce83625d18a855690416535f30f27992dc023b227a0f308a97fbb7d3cb59780b3d5cfc6f7624a6c873d35b24c2413fc90117d5ed4f1451e9f00f9f077ff51542a394eb89bba0f519c655a9fc1e5e526d3dfe29e6b14d321b5e4903ff7613d303753e35eb64531aad843639ec5441e76070c5cfc30bde0005f0069a8c4b30a861a5396c8d7b7b13094af44bee8e90e167b2cd3f2e611d9c46a872b4d4d77452ca07f12cf518daad90f93c9f7c634bc00292488fce83fd8bff55a9123098bfbc0719e7481771b7b2eeb6cd080c2212c7778f5429287f5d3147278966cb4a8d98efe7eabc5bd2ddc70b58abf4018231246a4c415af4f302125993f9d7b3709caa36b80602afe8b3a4d819bacaafb747d000108dae1c7c0910a79db6f623d1a6f84f0e401432a6b4bf169da9fa0b1a7aaf0d219c8c026990a0db7ae4ed1ace4828e5c03f97a6817af2624f0f8adbf0fcb81721c816b87db5056d817da2f8177976d1d29390da99b09884c69e11a396ac0a2f1071d38bb11e6a7cadb6aa90dad65c856ee46cd8dae5c58bd54bbdda7ac4fadff87046d693af085c1bd8b834359afc6320e92721e3ec5ef468d1e536bfe05f72bd9d8c1c360b7a96238460aff1b74c1524d9cf35e8b061d9a8269d70b08b32245f871cf6f8b14074da2f16c0f97c56b22da544d990ab55265c9c2b00ade8995e03551c560520526ba9e8f1046fda746bdd9c29537227d1bab4e07a24a7307a31e38a1078b109896a563f6e918cf45ea5e4fa6790abcf0a28e3ea8ea1a39541b03fe542fcbaf12f5873d0f8baf62dbdb46f8dc60f741f30cf4054c31eebffbb01aee86195857a3335f6d39a37e0f470b03a9c6ad2ad08771393adf780d7ca7fced2ebdd4442fa11073a246299528a3b26f46ce6c656b2f0dec89eca4609995b533bc2e393eee3037e84ff86092fe17b658a70732c6d3b4fb2133f67f12ce03ae1e908e3259a3601c37c301d5bb05218f1082476b8ab0a9117e62c2a9cd954d7908e45c8145e80566fadfed0e4b70a771b767410aa3bf6402b9d5f8b2a397df9251bc9c2420d84cf37c8d12cc00e4ade94be31550a3b3625aca8b28b39c6761f3c8f6e6038502da1e606bceba641e122c2d8793fba9e5e3330b79d3340a4ee6f9b9fd198a233ffb20853511cc1c2dd2226827f124e05ff3984082fda8a60d6c21b4a077a3e32f83bc618f8182fdfb45f7a7b2fb59b0eee2d6f391611cccc9f236b204c051c425be007a8c66543fad9a81252a7b25b0f28c1705bac4d4f999a06dfbd50ea7ccb0b9487f83763ba26383e681020b5cb2dbd524371812b199e84f8a2cb25602a6a735224f0857fb000c501d3fad29ae2f13c74e5fb6c7ba2247972e3562fc0c7c12bbbceb87522e240be39c268b69cd7a37253f7c48846da02675f5ec467fb7f27af57409c9da440a16c6fbdfcf9138391b96c0e8bd5bf925d01517e634d8810df5ed00e4ee225e103813abf0fe19c566723d5d36338b5cbab5e5e5c07b9e9e139bcb80a520e4195e465032df3583fbe55fd6903d8aa69741bcebfadea6e0e98d2057fe91fa9120780c6581a9a9a0d54cd2cffc3645692d9bef06334c2c0cba7166e210b16e6b932982fc90a71b8fb937f14afe0834421ee85aecc08df1b76d1f9e57b173cac2d64d0cac1d61b15183adcaa0a11ae3d24199ff9b965955c0800d4476e855455b155b1fd81d2507303fd2522304a2600090b5dbe0b319e9bd7089cd37f39c529a9100fc4d1153122ddd33a0cc2dd99fce58e2125c052a41e4cc3bd98afdee3c9ec64572585b23b2ce7fc504faf34195518e3e593c7777609642956eba36ff87845c80baad6daae0894a27478b45f5c86224f709dbea329a47a5ad2b80243dba7b732e657f04f525539b4219f95a9fc78e833a127fb6f9c695883303a969383e6df2fadcc6cdd396d3135a4725f9ec3a2719349756948895365165467a7a4a60cb6e3ad6d327e108f2456d13fb890e064caca784655b28905e06567633ff9d1bdbcaa51b1f7228eb437055f6696996ce512fd26a14a35f35c84eb79ee6da6cbf469b98b451b46649ae6e76320e1957ae6dcec86fff6c6095058c3afe4502f981d26f8bf1dd7a5adb7eb0bb39b9c69b5ea454d1a3c53784469d8223a20bd54c5cdf828ded7110d378ff138a574587f29611b0be7ac544e4f9c12edb50690587cc594cf80bd1d09f8eb4a79198a03ba7fae4fd0874112df6d44fb89cc5569dd663ee349d9d0cfb100c711988a060f41621ed62bd85486abf8a6e90dbefb25a5f0c4e91100b3975e0dea579e7e1c09fc2e806effd698774626425734af602ce6d52822803aa0370adad6c1a8ece6ba7b70284f161925037fca12d00102b03fd29fc5c4bf685b67898aa1ad217e5a83f472fd6e08c8c4a79624dad20aa5791706596126df4485e25d21bc2cfb4232640fd1954520a6755977a218cb6bed71b795a428fabe3d5baae26da00fded1b3b78c592b153c6b838fcabc335f00c9088265ea7d48ed56aa771524fe5066a3a86458efcc517c3565636a84617baf29b12fccfa70237fa3af83e21f354ab26f30fdcd97af12b334c0d2314a2dbb413953d9168ebc7ba4794b3ad57abd4cd5afe85ea66ac29d0e17b5b845fe77ab7714bea88c7facf83ea2a1926795e5c086a454cf48a993897e22202e6467863119b10c892a8ee4ae55febc5cb3a816cb31fbe0fba205def553b2fbda1e3a0325aa0258556f93198b95b8ecf4c80de7d373c3c984b86d426827ac578ede6b865c66be4c21aae079176f334015b5752687ae8ceaf1d038ce7c4e6c3fe6159a80c77f78035d395c923a64e8edb5a04eea79507769fb9f5dbbb1be91f48e5e1ca1fc01b5e35519b4f353600dac0a46e57f003570f503923118e1664d949f9346ecd542ea251bbaf5cb73e219a0b6d566f5a6f94a829fe01657d7cc3ac9f20587a1e5931cbace9de755030f443fab42489822b5a90f1fae550d38bda20ce834a7be5390942483538acbb82399dff1dc6e7755fc60bdbe380991d9d1555324f9273955ddf473fddbedb8b322b35aa616458c303000af9ffa2823951b971127390b08530305080abe9f3a171d90cad3d36089fc1b03f48e75ab305d5fa1401cf657a9783e12d84459fe59037a85dc076d87ab5b07083e280452c2a41644f9b6102f947ad0b9ac5ffc1dae3e5e6c4e0c4303fa47680ea0f76736cfdf928891d1a38735a40afb7dd127ca214a3d3d9893f5fc74dd2583736b4054c9d5347c9646e65005a7c8afc9029542ead34c50ed5f70877981077aa8ca33618fca64ae2a0139593754249dd4b5f9e527935d55fd8eccde9b607dfe8af40cd64c19b5d9e718f8d5574153377694af525094e5e15d3bdde60d05424878d42efac6a4a6571d9d001128398f40e823c19f68a0dea9c32662a31f924cf45a7ee28798d67d55edf4f0b6a010db7330e3bdf043cfe731f99014168bcaa8c0ddf48f958966235dd0eddaea76cc6280a378dba440007eaa3fca03e4e1436bc1e59bb57a068cc7f7205ccb9c31bb98e3699080d5a211e88834d18b843775076db7722d594b580250f53d2377cc03eb4d115e12b8bda2d92d8819064ca7dc0d7799833953bf8e2d894df4bd10936892fedd93069323ed7dd69f2164e13d9b5474564f9f14c7182d98cfa9ff3000213885f6324cb559f476eac26d7df8f4983a0a09287baa8be77b50641eef903ffaf1ce1558231b83e23f882771cef500ed038e67f188f4cf610e5a3a8b7f70b9ac3df9c661459ffb1149e6640affbe642803805e64ad0bf1cee2f990bcb6dbbac3dd643e2da2684133abad49fd97da0a0854426217e67da9b0695434884b0506b98a7473e50de5f3cb84c1cebac377a325a01b83c1efd7cd9561d3568d3f4f7638a067c31381de34d1e6bcdd6e146e199a29f6c1648c66ca01567114cf6320ee275a030533fb80725c55564b4f8a1175dea25445a3c3f9fee4274880e45b27ea8e69603e6c22111beb2f496e526b99db2b4508994488f231468d5e8c41ec5f9bb04180b31fbdfcb1d5d1826f05d42d5d5f305f2f78dcaeb4218470772c04d8e5cfe6cc66cb54cbeb7310aabc217f349e59a53953cb5a485e8b6c2cfe406a84b38f66c1e3a8e80fa4d8c21ab59f2f001c488c05f2ca15bf3b309e8bf1467afa25bc66b0ac14cf8d1da9842d5a706ae5b2843f42d3f36538813c79dac7dc38eb68a7d1ed7b0390b4b274fe45f8ce27c03135a5a417a2a2b8008e9eddbc23ff529fa23841c54becc68febd380d951e615190c5af3d058b24b1c359ca0b08e5e1364557dac1b17b865281e554efa52a83049627a282e00decfbb9b9bd1acf9a0fed9f00fbca17b702e477dcdc2afbdbc0b49d5c1460d46762e7fa9f0ccd4472ce2c2c7b036f6b274d1316b371044722ce95f51804c68693dcba251cd9a8c03c1788c3ed9e86e8e0053124f26c1c8dc7f17de4cec34f7da8c8e5ee3f37beeca6bbec64bd129073f67ec22415920fe03dea9f3873408acb43de31173d8cd0d1b27b83f7ef3769435fc78dd6446a2048f390cb1ab9df76ffcf32e25c8905018dda83ba94b7ad1f1beebccd4b35d1f75d7442f06cea4e7b5083abff2b70aab67f643c4794d5ea31f53ee983b6416ad6665e5baa6b68c0eb54aaf3fb4952c6a8d519dfd27d01475ba3d50a41038ec236964b2480fd40cbe48b777cf82f47ff57974ffafec087cbab89dc081863d14df501f37aa7ce1819e4629a760fd38bd83dffbd9ec51144f112ea96d22e362aed52679a3227ca694610f888c101e53d7c3294b1472bc47b00af0c0932ca33ac01f855a47969af86d306fa73671221717facb34f2fb16f87fcc57a33b2b9169adedc3082b08b3dbf0ec4bd57e56234e11444b1ca26b94087557213c69d2613d3227a731bd7bb814f6911c3cb873edf7baa677686dc103866a58e54f6ff5f242845ca6e46d2ffc6a7044bdf3479902526b147a24113243eefa4d71b107d286349c5ad920351192a317929cdbfd2e585c46806209f81ae558358dbd2f60dee910ae302a1acc7993859bb044e8631889ccf3d354e701929da0424e89c8f8fbe7783b69495ca7232a8ec6f347b17181b0edf9e9f82b1da36169a2efe2cdb14aaee8fe198783c01defe6d88e19e4ca75de7d35cb36256404b24bb1f687047a7e3196f5eb9a4bb16212117a0192a989d10d050bf5061af8bca40dce28406015a1d743d4df6f164c1919e690c92931bb808da1e9e26fc004f816be25a516fe66c96143f6f10a491ac6a937a604120f04f16ecbdd9e853d71b4ad62ffaff75de242118fddbc6c962f7632be05b966c583c89e5ff8848d0e4682b1ec4143e5ae54527a87ffd190cd1a8ac5e9429672cfb21f650c15ee03b65ab7c806ab037afc1dabdf02eaa7c60db271cecf8aa5ea212644b65a6143db712b1032d148c007e3ced9020484b31fb4ba45198b46592078f34b5c1abd3deb98cc5812b20eecfca94f7cf6a550e481d47295670b4087a1616f932f056abbf2ee8ce3c46f7dd2bd0a756ccce4cc2038794f0460d91ab6e01b5f1622ebf0ec0e7f4331e0d3fd0ba8a099f5635fc4fc3354027f5b4ae46481f97c80d034d8508c567062f765dc2cf77897bf6122ea38f604930e799fb4de0a451af6b78c1130af72a833f1cfff0244b7f4304e69555963925955b2243d49e43a1c8aab57a0b51a2cea52a3e2eff205d697d5b62cbeeef805ecf20877c1a2c9e3c8a8a1ff338b51667b07cc87d0ecbf0372de7679228fe252f1aea089b2fcf8baffda30e5f64db41f28a08392dce2a00bf69edf4b3379843c98ec59b895024b3563a7ed64086121cdbda97366990d7ad2caf49806e2cca724afe64be309326c4a8f3c5eeaad04986342cd75fd703861e0f88054fe956f7eec6e8ef9ff4b53af784d579fcad853e0bf76cfb08dff80dcc35e60ee72fa4d75782673bb2a02b16d0f6d2fe9f672e7518a0ca20fb256b5047ca79377315a36e5ba23e369372fa3e337dcb9839ae1be46c38d08f64f365407617d2558b75dec1c8afc56e3d536d3b774ea808a9dae5e43907cbaf7bbba5924a6284c63c6d8c0ba9014429eaa98b6627f8224d3785d52a2c5b33230399fea9ff110208fe26676728d5b3b7e3ac2eb9ebbf1e634c6e5bd77b84e19bb183382cd1a6b5b80dae0ceb186c257d8b1177fad71e572e5896b80b24fbe977ade9a8e77bec2d55b78cd3da8ea46d83b90a700ecd3d97442616f3cb9eebaab4594379eca50c35d548ae856ea8f5a60746747aa11e626751649110ca82a8bc916a489b58b9999acbd64729991104a1646a13ebd3e70b75feb6f39b9e721643d2613d0729e12ed41b4e947906d91a3e4d0d77fb7ca6a37fb7a08b5810fe24d9bd41a1872e36b4f8c791d2df49d0afd88e94ccd165aa943f0fd3647fb033ce8aed42e66e78a4c100deac32be2e042d4256729bc9963718756a78f080306aca6ba3d4c24b352562ff8e46b0dda05502ea8e87dc6257474841231c3d4578c07215863a9db8cfa76fd66983bde9899895303ef31f66a0825384a27c5718debcf23d91d9c92a0b87c8da389ac5c02f7206d38630a3f77ca505cedb1393cb23826f1f9e26268e6f04e216546cae8b81f1d21041ab57f80612c8e99bd0fea9785e86a678a0ea5125b79556e9f58fd10855ff107bbc5014e852f0ade34f5b684f65705bd3b338599b99cea43f505f257ef98ecdef304e41e77e69a47d9e93d1900a688b27ec1ef29afcbf866ec27d8e7239c01875c49239c2f0d259e68701f2be66e26f87d9370c3c7bb1c733beaec3c3a6953a8acd53340eb05decbf2609976150e3f3205c730b33fd722370359bdf53677088b389930e5ecf0138228771fa4e270d42b74c04a8f9259bb3d94d68a65f940e1169fe0077c338f2954300b6afb94629a9c52fd4d5cc00bfa19cd5ed7eda8a8332d2936e8a8faef8559fc0faf0b9085308ba597fbb96223dff581198f6f3df1665bf034b69f5e1b2c1f4bb4779a84df39c915ef381ccb4b19c87b77dd9a14a4e05d9d21649e2671bda51dca4d14e60471a3e0c5f8cfac54f74aa930de622d7580f2f1c498043b4d5e06566b0b79dcd813e6a7b9a2503460423c520f00dfeb94b6ea19521d467ca3d98719950f368ebbfdb3a01cb892430508","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
