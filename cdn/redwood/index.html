<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af8ae37137753a59273557ac0c4dfa11f8bcf99eb810a77c9c61048e06fda5c61c20933a959a04dd61405f3bf16da399b15bf0efe9dfda80e170d56f811b8e0eebd99ee6958a02ee9eab796ad71985eb2d410cf3c40afadedc6cc881a2c5554ea677287ed59e9e2ba26bb053e97c73002f94a62e751853a1d4e3596ed8b4a0824cb8d2fd3d2543421cdfe5b90ca53249002904d577ff8cbbe5c1b9e29d6e8a5085a68ece3d10579c23db620c5738a22839c7d6d467cbd5f410995177005040b7eba0ea71b8e88a97ab2ab57efe9f32c75d9bdbf279c518f4c4fbb4849e0a28bc9d33921025eaa0bbbb654e62b9b2504b63093ffd28f4dce43aa243a91c45831f5afb90316fc6ac88ac6a750360474ee886c9455fd0996bf960e513a975590033311a13e0dde398013e9c6f6cb70981d980544d03a43a196df6f03db36b1878084cc4b75b045469e5c6fc99b8bacd625202eed5cbc693c5f4727321174b4deb447b3c199f03839b4417c08584500d97daa5022de431a6858699206d1ff78b2447a66dd044232be6f041a57b7d97f656dbf6553882b735e769eddf6fc8fae35fcabcd5fbee4b676abb7ad37834cbbce4f591794018dfcf9a1271ad2065479c6ae1a120b458a01d896a5864eb69ae9179b025b56a705c237cb995e5d0b32b60ebab6b76df3c3692a8dc84dda66ed87860b6f4e3d733d7b290dbb2893c8f5dfc7956722cd9a1c7a404657f50411b97f1f0e1f6b98fd8cab6b88797a351762c8a8124bb7448b619e4fd943f23cfb78433fa97eac210cadd348997752c2d9a007749465d334f5f501eb3885521eed6079f802e957509a5092b2d45739135dcb66e23f73253cf3eb1ede2be82397e3e4a11ff6e417379c1d568cc887570621403aac8e98e0b19d614ca1f9d6b717da1b1273af0c7c6c849842d6eaf76560f1c651a234f031a89ab66bf8a66a9f5afabb2b6cb99320c24c48a2649aac96a9da958d5ad7003095ec7c6c306c4c7b2fe7e88b8b46433235500a17ee3b0edc4991ebf314612ea6a40e74231217ee975bacd13eb825c5c174b66e0cc5c9f360436d76e8964537d63aaba064b31c69801956c6e652e41580edfdc14dfe8086793f0cbfebb3a0c2b9aed2405b5a72019f21868035a417e8c414dc11f543da944019ca83f259d55bf0860d5b7e0f1a7ec7b5b3f7b4ed0aae278b404d84054671902ed2cc78f1864d25fa09364b4bb5755a688686f01b350b54b6cfa59455e0856a25d495072ef7e7431f58383e8a27a68feb6c459c085117a856219514386d53179cfadaf3d098415bca45457fceb3cea1b8ce97d9d04dac6f67f266530bd0af8fec1306d30e649838661a10839073df43d38b30ae45df7515cbed7fe3a943bfecab420d974095b16a3a70f8e0e38ad6fbbab0e108c888e28123adeb2f86dd4e6a28d39f80bf9076c21f000bab795b879fa386dd3f13d90cace94efb7b2188f0b41be2ce0a0323cab6f3a78b5abf60d343e165de8e536c93178f14e3e8e349ba81703fd05bf51f543bbf17722095cc5b7a8c68a448285600140fd80aaabd8697e03bdbb9108c92f0282828562934b2ed0e1be1fd75c3564d55fc4422db9eaa2ae740c86f17bde4b0c4296c1f3bfa8310350ab792a3ad448dafce5d84c7d0faf42186458aad5bd20ef507b731a63cc8373d7463ee648a7f4d904a1d833ae33d184fa0502f9f9daceb11738866170f833d148cfe5b97b7bd4b68d47bcba2a49b9601a50ca6cd1778fa698313e1fd3751adf81314d35c434f6ab5afc7ac8a28ddf85890b9e1b288294830badbc25736f4f2acb75704b68703de8f14ee29920efb600c63f93de03156384cbbeb706af6e4ff0e7d86c6da81690d6573d453457f270e01b6b34d3dbc7fb47cc179e6cedf4815a3e5c0b41f3b68e969c113fa555c837607a230164a09cf2b79974a731eb81bea3b0001e39ee33566af054dedb31e09ae6abb3667e02f6f86edf4a82897250fe6457494e15eb3422b37bef133682548ff4ee476b896791d32b69ef22efb781227a23810d9c3f58dd3f92244e2208f4da05f4e7e1a99c0f6f810caa3ee10fd6adf9cbb3201b9b2468918e40cf2521dac2bce971648909dffad584d6ef9cb2f283e4f7f016ba5c2570d778a11ced203c67dcc344e88e50f0b0849f7cd87babc2cc2c2b21f5f9a9ae7254959eb3d9a05c7d9d05129776fe7ff678f4a590c0c7720095ed258458b406bbaa35ce932a1214f5817f5bdf88e3ee85a669f986017991113f5deb60190e0617fa2d7a898dbc8c22290a50588bc3d6c3f1c4cd5dbdca4909d21bdfd8f6f7cdda45b0b6514f9d4716c8c8acf4121f303b9c1d46287f3376d439458c559fc5b498ecb52085889acd46df7800e2e5a40e784a3750ed213fdb3ac181b11cf33970333cf49a43349f7094858277a460446a498e68f34b9b457d57f02c6fb84ac49b047b4a5e65ee5a85b308a997c28de2515581c5b9d59bb2c4670661bdb4bddc4a85912911a4a7e1decb3dd0397c4574c5e6481824290e6d7dab0cc7b4951c3b12ef03a35f73eefbfae237c9cf47836b05a0a8be2700f7fe036caaca92a6c50254e94214c2543c6087ac3069d50882ffa8bc1d4a2fe9b403d4ebc01aea65b8232f9f24e00c8025eee77291947ae728a5ac8214ff1c9d790cd7381ec72c4687d74d079dc2aab6510e7a4cef573860355728d2ed172722595628aa59899fa5d6efbb7e8c4459e533d0d8b375c410dd76e38cbf34ac32bf0f16a5fc9964ee8a0185e1144e8bdbe88e2b3fbc1eb7afb2fdadeeef981648f5be1b4661001ea4fcdb88d8ecd8b2ad434a947e50bc8cb2d49ebd3b6e295903bb57a5ba33e716170111905f9966132502f3728efa05b180e08254f288acda26948dec5c64e02174647c17bd46203820b93a0a463fded3f5fe51ac16c59b5c18d7567112df4ba3ff00c25595bee23fabfdc79be9fbabb3d781a982b3e46580d054039d8e68011002055384b99fe6c1787f75abe985929f351b6c9e74770e57bd0ae225ebb99579a0109177b7d2cccf38176a783f10c754eaba9943c9db5912980dad33f86e5db06ca6d10a0f28e671ce3113da972d59064dc5fe98f50ee4bc83c87bd70d173abc7e65754394c05c3bde1b6fe52122989b107f1a3a0f1a571b8a97f6bfb6ce8c974e270319fc41dcfad46bcda6e3081294ad65bdfa34f59bd9595b8f3ce24d5ff008415f611b067f1262c762b667a990ba839687925687d2dd28e35e389f964e3b67df15bc7b744873d64084e454826ed53313ad4f80dd9eeb97bccca6b60defebbc8dd4343eedbcb48e8f2f2e76014eabfaecdb2a17fdc866656854aa3c6516a88ce000d6a3e2d3df686375fc0f8cf40b91e3641267d174a08ff98c16accb898d596ee6c5ad1d09dbfae357a4bd90a62a1544d6c98ee08e4c2f91a9895006da40db8ca39b6c95b3c8af924570d4b8cf587353480dd841adcdffb6d727fab95d9118d3b48babd395abd3e33afa465af476495afa000db7aad1449e0401fe7154bf1d12e9e0f61c5258683650049f067ea1cfa6d2e12feffa33c5da6b7753c44691d8187f8d3abbeb1889d8d87880327461efda7537be455e69007623ebcd47a3bdf3c18ce851bb6bf1a2059c503fc70356ac0d358d3f290d0b02b04ecd80b7eed2e0d2197c96f04fe35007883bd42059739d5f1682af796b81cdd27f76987f81db1e3f0c3fa4bfb67fd35019934725f35d9559915c37721cb99558d67c140d8a66998e7b4648a3193380026f37403f26ccb5cd2f79321e65991329dd1a073fd419a127a8b97842f61db6bac19bea9a5e65bbe01d135ffe00e11c3f6a282afb0e8f1d4e384a70eaf165c201824ab1a9a7ee374483138ff1d13d7087d656f3892c2ef5f3fb8fe899ac4edba0983572efc58f1e44f4037cfaaf9f6a00dfaf80ad6a0d829eb2cb4363c47f823cd9b33f031f56bf2701c15ca1a3fca1911be4724a19513a86bdaf40684a2da43edcf4c875805190e6b8e4c17b55548e92ef9a0d3a9a7dcf4e459d958bb0d2a7221edf42a34710f8c3abcbb0b1f8f52ca8c4bc69ec206775ab3ab06027868cd88730017705580af6ce634cb7225407130ad93180d5f68db41b113995900ea3df3056b571db9a1e17035aad9a04eae7a6a01ec163cfe8febd97b0bcb871e1bffad017ce807d8f398b7b1997075b557a57e7b280e7ddd49dd0f6422994894601bcdd06e5487ad1cc07663121f95e7769582c489bdb80fb1fd3bfd7e35ab404ed2e78d5efa308bc46cbb52233fe327d9793ae6ab4c273d10d931fd507c5928d90ad7227f45fe88c5d8f08c47fb85d6c575b1ccbe7000ff6ff708066e7171006139e428d16a9a4945c416858def6f04aaf186a3bced1989513bc8f31f21799bbe49c9a31365225dcfb392277ccf9037f8b70d7d5b867c0a1616850910cbc5d8e56ba6ad783fa048ac7b4cda3fba54eb7481b7ece5d6ff4643494664282b626476dcedc0539e00d5a6dd7ef266740e37455644f96d88d767f221400a1ee31d8c974c3ff727fedf2cadd122701fc8aef15e8053aeb6567c4ec1cadeae3a41b66ac5a5c68a08f7e354270af6462d97b9b392fdfb9d86c208ad7733deb60864872403272f523e48d394e78cbf9d760a8e2bfea4d3c00fdd3d88d44c3adf2b08481f0d8cdf7f49218ecae8653acc718288562463174729e3f9d2d9ec946156024d96cec108fad670b26299616d2590176b5f869ce344b27eeef90f4835ed98739155184b047d7ba0eecf5e804b2aa70734cf62ea40babd3086e4bb50747b74c0da76caddb398bbbd4e0d9c2dc03093cca4b406d3e577ae37ca2ca5566ce3e7221ae29760e5d236673371fd9b0546fb3f364db7ad87604fd3383825e3616190eac012314be9577c1b774f7cdf27aad3e1a918a5b718aef747feae9dbec0dd821a88d4ed2a579acc906008624780dded332ccd42ab4ce237ebbe470c9e623465c7dd8fd996f5d8c1bc66effd14b9ba67d790d53cc5a68cad4f92cd66e054e5b2d4234050705f2ca9064facd90c5a9a863d597692bf31e8593e839f6cc0372ea8e4eb20c05ff607f33b6a58c465eea1c683c8f19518e51e6cbf4c0c4f312054756aef6384fb697292ca8f702a12981d8612fdaa022bcab0aa84c68f04ddc67adea867fcab2f96e1a5e2a08510f0af7a1f578b53379be4093e733f9d831a8bc84ceb85eb287402528206bdc9f98c8beaaaf52fc500970e9f7cf319f6c57cb7c1b7a63bae9b193fae84e9dda3bf7c1ae80cf3ca8d813fad9597b0156c103e5fa1387266f209112b5ee522d2720a86f11fd89f088387679634935dbbb8f5000bd72ac7ce66013f9f8e1d60f5da7808da38f6a629975c3801accfd0d6e99c5e1ada381825cc64cc62cd3706ddbc3cc5ab9a1d26d62b67fe164ca437eb7ac6a8258e9eb1c95796e61623b0ae15f927dd00fa61fb4f62ca73e59e14af1a2508d25a3c961f03bf6a03da4676bb707a1824521f7c8721c493f638fc78ed1a0d087ed2f0161ccc09d414cc33dd45c1fed9d83e809d990998bdbfef560b09ddc97c7abb0ef33a8b0507015afe68280238c08d88540249f6046e2716b37f2a8f09a4c6a9a729a68ecd3c6425288805e445d905b2eef21c0be3200b161cd97c206169ef21bc5a2aa925dd3f799b3b0262784ffb13d095c85dec87ee142049266eeaca5ba715841c6639f31e45eee2ee4ef26b3659b010009341b543eea384831a4788b11217d6b6d34fe6c9488fabc4dc9d4c5de2b723ccab8d843d4118a2175d598b07bba67d1eec79039db340c3a2a37a761c55bdbbe249576d6220c079973febd9846a4ff4e6807a766cae346e0442711418addf54ed30c78064767a6635dd2bcd6ff7724be79cd3ab7c1473af255cda527f0f7c1b64eab3ed1b5d3f134d90c79f5ca60c585956a912c1ef7fa6c96fade96e66a323d3531e510a6d82b3c5b0f95fc27c689a53ab34906d072b65c15a5fff97075f988df59edf4b0d5addf69e14f7f9b461dcd3e391b0d189aaa1c61be43203410cad581786320ab736686047b5007d27bc8ce01a5d3222c5bbac9afc32390001587fe0eef6736e049288370fe53d20a5f9d55a5f378875ce837d16ba95d19d9e308338a07b2e34e8a5ffacd0555114f00184c134cf8d7b353fa7758a372bb4b51ecdf3105aabd63c41da949c61328e015aa86396911c77512af1c01050d59d208f92e4f5d2938b446c7a21107d42c10175bbb36b27dc2a47a865b0290d58c1d44596a9ae7d2ed30ba3afdd3552816087681d8e8ef4adbb63ac3188f16d2ecd9c71df060f13b7315353329539b0009428372e252d2135674046860a43974c09748aaa522fbe13b3bc8a10b34f236861f183aac451c9c0a557bdb25a2612b8737fba3e56a39dc885e29e6f55f7d411df4cb779c3bb0006bb2ac3a689e0a2814bbadb175547d56933e632dda396f964b8128d8514bdc7df4dfed82521fd86349b871662805b6a57b55fe8cad5aa4e129bb5f740f923e309dc374e0e4db2e4d50b622970a0caee3b965cd346d53dcd6637c4686686938a47dd5d700bd6c2dda60ff355970ba9aad68e9eecc34da176575ce587ce67d8c707b41ace2926453ab4a271b0a5fa378e0a3311b8930fa5464c9c89be44a891c159f5b0b0926770467f72323763c35ed9d241824f622e184d66b9d7fa72b56b7a7963b3b9b277cf32b193c301fc9e17a40a3b252bcb47a9a953fa1427d74644003a750bcbf2159f3b22f1475099685cd3d6f5c61b8c35840ab8d0ddb1b550589e3f373e36c640e46568b5e3ff4b87aa084d0e8210ee033d2237726c3b0eb207bf5d03e6336ef9344d57ce7d2c81148c4f627d590007ab64afc5e8ba93c1236c8cc7e34b0586c292b0f5da5de63ef5d2e18496ad4c54ae49bacaa78488dd587d74cff891a640d3e7aa713bffc5e0b83d8a9bcb9bae010dc16bf344d83a1a9d03df0ed22a1838c31e031a8fac94906a2b45c0a172a3fc0d6479495eb89cbaf0d6355c623ed9924d034c7800c54ee9a1876c0a29072ebf4414b74a4c3de4ff5d776b90bea6741a40a614bca828b04e255231208a50694a29ba794898a3ee16817f83472e564e350d022b73b1f3098bdc43bab3aed5620f83acc9866ec3cff607c0b54eb030c74f8a9760f478198bd8138ac896fedf6090b9bea119341676231d1d2c1ab6730cd089b39b0ca337a3b58eab6a2372d64688f78fc1268e639b4415632d3e91c013cff54fc906437b512f012854f778a7d44b787db5f7006412bbdec0c8ab8b8a2dab763adee6c020322746d9972d267405385d9425c6c409bc4c19900b4b0a58f68b9a5961c82d4abaa60ca5c14afbe13b6e45d053721634eae5515e9590aad4b8848eb22eabb1c192ee622682885f187b70e78192e66e342a433f9da41ef59dab7188d05e413b7c05be77b811e0dc0a918b0e9a7389590932bba1bc776ab4973b4343ebcd05669d8cc75922ec98174c3e4ef8742ca7a4d0d447e73dd5dc80350254c2d9a8161fc7c343bfd3fc8b7129ab77650aa1fcaab35810a883f32246a0baf678fb3e9f64c1d84ec3434e0437c6ac7d05e638ff4b4dc01e8b9cae4cb3522a307f4dcb01177a820a882adcfd366f51b99bc81cc9117e48e840544577f5cdd89d07682569735d2340363684ce55b6dbde32d36157ce3c688f7551c19d7a77221668575f54f926d585f3cf67c2080a022b85a2f15419975070e403f0225f0d3085bdafefaf6ce1ff389c0dae2f53a15d927925abc173f2de9e1bb8f3de7e450fc6365cc65159d78115ded0d9a4c4e9d009465f929287a978f5e701eaece408181aea2cc897f8a7380b049e623d2583de2fca6987005d535afc312fccabfc79cfad1ed580c5e8e804ed320a7000793580b18617c5c7b6b9d5fef94bc4137a955212e01b3a1a9ad6897a86461a770c3660f3a0aaabc180e2b9bf01db1e176a136acc7ffd14e732d69fea2fbfdf02c31b7c48109fef4849a832fea5e017834ed974f00de50b2cb8bb2ae6a4710e2ce05cc4ac7d26708702a8aabfbb00193fe26ceb507e254925babcbeecfda18b575389f52879e4968b8554977a056be04b2103aeb6412ecac3d156af555e225951fea8c8a7e909275225ca469325ca438b2c58c1ea7901e9af0cc722df7452d067a941928fbbb4f5cd61f497f1d9372c337168110cbf1e081aab76ee4cc983392e892f9d5df7b677f12e24dd8213ff54120defc59d44cc553e1c59fd0c56444e76f25e0acf19af75bfc4f8d254fe7c7107c97a08260be9f55e26ad3e22e79e0e3a7c9e15207833588c6be0f31d40b9751083dfe23af0fe3936a63b3b0f990340dd7e82151baad43a478c108044196d1df7f9b7586ba68450a857a40a155ecb84357cfd490e0b00e7f8ab9bab4985ea57a8f958d831a87b6ff39eb8e39f92e19c8c020578f1276c353908607d4fc71c739112c991ab7307522bf91a845d9a198d57cb67b26494bcd72aece835c438a04058e5d7d8baa4754f5269191056aa6a52f0af84f68cd8971ad9aeed9a7bd0b76a76ad29fcc047d42a9744ab5c6f77346537d1d6acf252d333d3c3396ef55d6958b08fd2f3d739aa125c73a46ab9b7c5f9fba1fee2a19136acb7f070da66434b9b11dbbc1aba998afbe39630fd6d54c9f6c2c083a6e053d668ba74b126cb40dccfaea06aad5be0b6627483119e0aff86ef54931bef76f61f2958448d16fa6e1301d6067d7a66431aa30a3eef81b1a5e0d72b31dc6a35220c68d2a9429f55b4b70e7947927fe3a9294933ed7d29b2ab215d747c88c78d9c556187c46d1c7231ba9ba2e89a77ac3c9e18bfd51bb4e53ecee175332fb076dda783146efd016ae9c7d27376c0658ab8e2f01b14e151ce6197dd12558850e7db27868b8b66dd2657297f14aa559d288f8acb4fb4f10ce690c06637009f2c66677856d9518b14f259558fdfd17242126e4a1d399b9cf367890c5e69fe4bc7844fa867d035f89776b3382b08514c7d22b5d2846086a661ef6c9f4f60e6a2af26ea3cc17cf90a43e619e527f829e246d05b644ddf3aba6a5ecbe658d03a969ef95a102d5e767e62e929fa9af54801c30a2d49e04af25daa493f99fe477010702e0897216d8b2fef44ba99fe144d9b51b3c0815175bd081204399cad19ba153a68f7793c52def33d4e37b41a302b53c49367d6aa20890489af82b15afbae69cf73cd99e748ff41256cdc6ca7c79df70d84f1eb8708413e392905eb2e4354e9f3bb07d4bfc4cf2607e730bec4c2943177c1ace76b127d18b643a16ce8421437612892d1479b2aad040d6eedea728710836aa175368ccff35095a8227b3ff81e6a4819747c5fec690bfd4bf480aef73dafab20cbbfd2180f21196d24448fa14d4839a19fe25607f1d9f39b9267684e6ac14d067857b5ed4c928aa147400139547395d6aeb45225ca37f2a5d9c1c29bf372aedc040412d650f3d8e86d15c80184eebf85ad7175fafd19ce18d57f0077fb5a48157e0254c9056a47a30fd16b70526b6a19b45e4e09756b634e655815047b393b46bea4483be4817524aae13c4c9a486cb5aa6f244302165c5f265da874eaceef3f8dad40dfdf8ec6fca6c6e36d0ddfdfae52019d3d821db62c00873e970efcddbdd126b6d089383cce65d1b361c59a04a87bb8700db0f6dd27c38983f2990aff1a0a3d10c76161114383dad508910fbb2604c0df6befed3d8798300be09386d0e3fe2a5d59cd94e5a0136ddbb67b8a24a3fcc77d952657960a3dd9860309e2b38111f0eafd47b6e114032bd904e7e97eba9a820f6e0aea1568fd40d9c6349286b7d1de32289accc0c8ca3592d85c6194adde705dd46f8d6f494cbd96853aace152d5c0ad459eac2738555f2807fa5f58b87ddb2dad6b58854e511e37efaf08ab7bdf0c7470d55538ffcad55cad92b8d20bfd7bfa239a2dd38ca2020ecc451c630b291a0d6de1fe723bad3ebf864c8be719c4d5875d50244ee62bef7f72e71b2ddd2cf74ea278222e40d34be380fe336d7e4b62c25e04f85310831cad254128a52c470ecbc28c64b9be608e348e5a3ce277c2a7fee01be8797b5cb924a3adad65996c5e23c0d44c3246eeb5b01d38a8569f56e80a4455fe483e8de9251681c973dd74f5cd444a685b6bcbfa35542eaaff3e502f2bac6a90a83bfd8189aa7d2e82d2791d2a141056d713c0231ac7d4e08bbe67942faef31cd41178efdcb57e497599f42a34ed60481621d0ca2fc4cae33aa6a71a5affea1dda136a3afed90ecef7adf2a4ce41a5a13de2ef0a5663c109c74ecbfd97abec81431830ce9eb67607e268645e67acf1596f1e123df542878e84d49d785767b52f47bd2b71d2fcf5fa9c59fdb20a29a11d0215a469c6d25c4c264587de219c77418fa79dfee08bd8b5433b1ae8742cb61aca35485652fcc4972a4a3ee04b19708b5dbb551fe27a5b5159b64a41954116dc3902742eeb5511df6897f44dd184224e135fcb3d811521d07bbda928530e9a9f7a4edd3cf25aab47a0debe651e71f3f760b1a7d8255b2cd496bfbef635378cd5ba00472eae0e79ed239e852bdaaac705442401833aea796c6c12c3c599795f11d3060e045a02dd8b0a27bf65e2df21deb9acf63b65293061001daf585595c9d84bbf4eec8baf454e4f5c74201b0cb81e3428d65bc23ca1fa3c04cdd5127d51ec6d45053fa65f4d45b42376106dbfdb33ea7c46fe4c262ab1bc22ce1bfa4374db9cbc2554ed8e7fb77072f9708c7719aa275a411778c38b920182590700575d2b432c067b525b0bbbc79e25247ba92cca9b4f362455a3e0261eb161a91bfec474c110d997a3e4020dbbfd2b22701bf16411efe7286e32aefd1445151b471578e785267f61796d0d42446ce7998a8487166272a853684c48f5f2521923638a4b0f34290f216a3e634a1a619b13667c72e153733079079e79bb69bbeca8bef847e9dbcaf0004875c9e8d21d18eccec999c18732f192ff8dd6b8bf1774ae5b1efc2514b8ecb7a210147388460ae0394519ed489d2c81d704bace66d5fe47472ee9e4b3eca1eea57ea314a3ee69d90fa0bc9b84511d16a661d712fad17a930f6f6bac1fc5ff65e191485830f31f630dfab230b4d0917967e4c1529115a086b73546f080c934b25a8f824d5cb7dffe329890df81be77e3441fede1b9469c75775c750d23e34eeb3058d06d06ea7fa1f6b1b4b05ebddf369b7a6ad8c166f43181973ed51672240ca6be1a42274d75491de5331dda844a0bb66314dead5b8b1d188209da5b3fb7b84bc1f9125a8104d708b45fc7456b8b05056246f1e1e45bf4ad7af46f065cc5696df06df9ff2209f63379ce2d55f718d2191bb35eb9e206ebb283ff6720329b5a14d9e7a5d16f1bddbd9061833e488889d16090947111316a2bafbf5e6c3e9e43dcbd654226a12ced8c60c7361169dfc7bd9de11d55daf61972055bdaeb562a79d178c810cd1201d5e586d3a61969596173fafa175767b611cad1421c5c88c03d47a79597e30ab4ba7dbd42264f0bacde79916d1cb8e5c046f54bc530b95989a8c8216cf2cd09f9e4c092898e5008439646b013ee3fd2f8404108050bef7d1bfb2844a9124d880e33e16d79d8db42624e7fa42d6207cc842cae8714235cf4aa7dc48c796e2d23c438eafda0774b3384c1e0ecee8ce8f7fb1883c633895dc9e8505d4e71cd34ddef1292fa3f9a71221b561963f71e71e54ba67bfc971049c043c918c4ca0f350a078e396437be70d6dd2283a6f3d0498a585d4aba14e7fa35a46cf66a62fdfd78cc0e5b91de69fc59313fe10aac6fdce078456c2b53d4749599d9f08f9fbebb5fa0d79772a24bd70acad9ee4a04781686d21b10c28081ec82ee34838eda511902934bcbdf641021b0688637e4d2cb78ef4b37f64a4cae5ad3e2626367e68e8c1754e13e9b50a191a36abcab1d222020a43add2507dfc973d0d60f842bc89de2cdabf0f279ccd03ecccd9850346f5a1e65e9a894aaf5906d6cb66404146326c8bee1f78b8f91c2964c8a14cd36e46ba3ae7f0fd5feabcd1add3a238c395c0d2bed9ea43dd6a75b10fd995f7c716fdf75395cfc9732eafd879aea18d23ce1c2ef61a0bb0ab73e6ceaf12a77a7f8e58bc9b97a101a57b15f5789493289687af627e5818e07c910db866a9abcc3b86e4145b8c0c80a1bb72152807b33ea2479f35379b853c4b4b2eb470cd7526f085282901b8c25f3c359bda91ca7b72c3b7efa0c4960e2d0f2ce70a326c0f523e797b7a9428a903530eadafd2cbcc8648d4c919616553f9b133c12b138d9ee7ad3bac2823d0648c5c59a908036b3b74fece644c8fc2b7f3f8bf76a20bdd790b12ff428390672edaa5f5215afe6a691cb0ef2a66ad6e4d4a55d11e5954ea3f3bf122e8984883f8d2365eba97e448b5fa448675e104d2b79f1eafd657f6ab9a9a89b3763720ae11a16a51af84d693d05ce93d6c26a84014b10f9ca2bbf7aa491ca249c6e39e186049fd11977c34afc738436b7f3b920320d5e91bcbe6a0613d10c8dd70f3c94a918673771efbb2ef82ae6a57234c57e16e10000e5c700c1bea583c2200c27b423125c82694e2abf36fdfe84e5d629826da0ebdf3674195cd3e24c456094189370cd8a9a10955c5ba780375d383c77acea855174e82c6bac41770cfebc2804fa85e40c0ba33c8ef3462156efa19d295ddc13af2f40786eaf865dfaf58a76c845604e3f127ad1e1bb6b2731a1caf0e753aa77d5a2706d669dd13d5992f40a03acc03715506d2eaa5d55f20c18397cdf49a876ba1b8aaeac0813ddf01963371d431ab3178462d5571245e3c394913d7c170d57e7964c9fa08cb032ca7531deec156177e978dd53e64d7935f9517126cf4a7276d9b44d739a69f4bf4d98fa30d875cc58f7e3b71910c8979d73a971f5acddaca6bb762040c2223f3c46bb7c18d392d15995eb8c484f0b19a3545cbac67026e6a846ece77c51bfeb5cd47b13bb8d6fd140be5c38de45eeebeb517c55c84bdf819447096858717225240afafa5b758d14a414c6841ab49f82765690ff15a77abad06c55fa268ac3fb87b217fae1729aa426da50222a61ad0e591750bc689468faf74920a0162eb5cd0841a56bbfbc196d744aa02528b7319c583b8f0db66a7f166425dacf7bf5e12f1fdeca07991ec218407c89780f9e5ea14a2cdd3fc539fe89a3e6f25c6bcbd2c96f4dea2bc3ff87f4c125fdaf900ed092043a05df2f27eea2d60561711ff3ed31211ec9d708b4190b9735dd504e2ded953a642acc6682cb0625aa77905ebc507506284e178ef5f946c33a1a5894d8bc7c268f44734b3f36af0b1386de376081024c32cefa7e1fe6203066934426b65b679c88e3da57a6e4845dcfa3f6b89eaea3d80f17a60eebb60594c60cb351f723689f930a12044fd09c75f04ec6ec3beae9813943bd783835d10cae0752236be8f4ebe325b4bd0ebb663f3fb8761480e6515905976eb4aa6648af7163a9f195c84dd7cc46163552889ff46e8f65be076e90fa964a8de274f7d6b5d341c0f8ff61e0f4b363e0806c0f18b34001a598ddd3908d09e2c3cf51cfb9a6d0d2c69a5fd21817a2f5a38779b45ee84c860604f12fa7399f01664bd6aeba7f5af96c9861fa7c3f4b7a13759324cd1f9e6735489eccd61fa35ff6d26fc097bb7a5748eb954ab19178d345c6712a5c5fce3db6dc61a8b586ce88d5b193f488e6a4dc769feb8cf20cc372b4a517b8f631118b8cffa2ae21e2183eed95eaea685c1a35f0114b9b0263552e19cc5e9ed4cedc4677f1728eaa7a5bf70db330515e8c5e25ec4333b31b8a8d68e4112020883f8eab8626948e24395ac49d8b4212ec4b46b3670bb058813b97a79e822bed0cc0520c0ac8b8608eeeb7c02ee9c5c1d05454c3957ff0ba5b666c6d7f66da237c88df901a058874061a2a471723956bbd5893ca58cf06f998917d497859176d97d178d04d9bd6ab8ff4de7aaa009581e320929d84705f3c4f50a7c2e9a02d6802b6ac89ecb911529a7ffbbc33f1b1f6532ac4cec2ef5c3091f8584abf77b987484b01906002ed5661d4063a8df56663b7827587d688f244fe4e6b9ca344f1414706905e36d772bed1efed8bd14026c3d497402a61be87bc67e41e49b715a5bfbbde6a88ed356e5778c3f46f5af0c72dbf39f0df42c1a3aa96b7ca2b6fd8d35e4a21a37d32e6880939aad488b4d431b0bb1da44c3a2d6fbffbfff7022fecac3aecfe2b003bac4d6afe48d89c22fd364678b5d684d7a7114ed6489b3472ddece3308594acb2ec636aa834ada373f61476951f5fcbe7459421422c76062e6c365c02e03b82b3f336a0e85623b7236c4a7616780627cad5917b2afe6bc83fbfe2b28272421095d6a4a686667b4b9d7504345150d11f35fa9bd6c593b9b5a51dd20e7c9573ba1c449ca2b334242dd918195f4f9625521657017bb73a2361cd878caa35b55407462c2ac8839e5a92112daab9a78b04d1624eadef55d1f3d5f4bce8ea43938f4dc69902b2b2f90527ef24ab307492e9c2ce5a81b5d4610a4acdf9e93ba88bce1d7fb3d1819ec0af651a606776f43eaa649977aeac1ff3a7021dd6dd169b8fb7aaa790ad515dfb6029b9bcabfbe4d2fb9667a91d2ed8fc43dad39ece514784a8574c9167b4e689c75a99af9e241f43cb9ea81f8574509fa0c9e6b0b24a0ae965bb20857cf17d52b9e7d347b4363525a4804e335d0502fd8f39f868da313eac3b191f9df569a3df21ce3965e3f662ce7c090b3b44fce65ad470b637392454446397e24c0122a4b4a0a6171c7cd49921c9374daba914042633d0d2a310b6c129d006a29f27da6b55b648499eed6aa8fbf31adfcc7b91fae15516fea0dd7c18d3d71c94062e4546c1ccbf47cae5cae755ab1d18b513f0b344755761a0589b234eee2e69aa83f2b221551ae4a9d424ece839341eef68cab717ef95c26a44daccce864a23ad49ef5998a2e50a5f37cc66e1a97c4c52d419c0441e40c9af725cd96cb630c57649a27884a9dd3d01ba151a2e8595b0ff37176a351eae16c8f3838181c6ab959c412dccf4a08aa791ae163b71dd505de6af800fb649b543400b8d57b407c310b0812dacf7bfa253fd71a907b5e472c2081eb8a9dc93e6915d843823afb21ad1a9c974ec8bc1f45632fbe5feeb3236a7f36306b4d4e1799657b06c5c94a90dc1463d460454244e7a5072f47bd754405864757191a3054abc7f6dba91433ee5cbec8be1d695ed5b9f7a2d4e297385c3c682b56d838ec5b1e811f3edf7c338008c0437dbee301ecf541e460ec1f4b5d6fced40c49df60bda3fbf15a5d1b71bc5ff9025966f0afae5e22033d30b7c0cb6de056ed4a3074845278976f247a3f86a8fd6c132ee2b79c5028260ba3fb8f4241e3775564fe0362e211993aa0e2c2c9d7a31b3580806e33669119b333b431325a42c912d8bb81e30544344663ee4a8dcfc4e4f0cc4bb0423ef528b51a9f2fcef6d7e3cf4279805d7c58265222542a8ee061a2697f91ab7cb1919b3404c942b618b826b17bdb06625eb9a1d61ad94c615413058813a46435a94642ea807166e30bc2543b2cbc0076c412c63657187c022488a8de202ec921efcd8c6973df4dac47f7869b882c26460bf4e460b9cf72348c8afc882bdaff1920539ed1ba8b3c8627a92b9a5ee17889acbd68e327614a1df3003a93930ddeb32594a18ef97ad52f85e78c4b1d1e453ef29c8935db902de8bf401221fb2e1ebb8ba3a77b513a8107a30fb311473bd3c9f3e87e1ba2a7af183b6fbea8c566c06c6be45f9f7258e4eec91375c069e4692dc66bffc4942a59aad96029ad7c73e540e5c70c0603d3bc24d7096871b213b566267a57f20e81461b27363f3364e46f19cfbf389b60ab09d3ff1ae4af991843e82edb6ce54d533b3d63c369a77f9b65e3f42969d9e72ff37c905f1e5d597af282ac25da9306c14fee0d26bda37aa5403d51144e03b6a8037ada6b466b61d5714f8b504f646e8da839bdae440cf619911df4f45be0f9ba5cc9000127a4c12d6d46637564527f39ed295860cf5b940c4ddcb19822b63f75a2a8d67e0cf874b195b0269719b41abb0f5d2615c18b1523e59333bb668510562155076bb8c2b0480ce16109d412dbfc52e31857be2ba5d1ad880c5ba04d23b98d914aa04076102b3f7cc8081aa5ce50cd2548851a6627e2844d19db416bfc05d387016f343f79a744ab25abfac4102bc4220bec0422813b715716c935748cf04abdc74a438aadfde7cf5b94f0170c7ed5f56256be06c7585e672e8c56fc8e33748c41d58d9d751b383b872491f754b607e95c362307cc0c587c6155ff8134e7955ff67fce0442c69735095f739bc99077e4b179c13fd110e3235de5884d5c1a4dd866cbfadd67fca87d439a942b7ea4854e131ae147554f8f778b1957ced4945ee9114e47f1bc4522d3d04f2d21efbc4676248a1e1f06f5f64adb746726e78a3d4154a74d0e010ae8035620decf270f7e154abc400f6338734f64f4946b66e9a6d3ee08e8e4715a4571264f831eab22033050257e4b6bfec38e87ad42dfcadb1fa7812388b1840397dd21cd02bec03708582e3525515307e537864c61a351b9f412946d7c100e8aa1dd1cb250c45d6f0af82f4af96ee141cc319cf6f3db75389085c7b892296f1446fde1d5e5b763c30ad9d2ded6724947cba54eb911322fe129102ddef3d89cfe183c953aa7f2da5812ccbe1ab2c9d3e2fd1002fcb1e37995ee56e95928cfa5b9536402380467e6c276b16b45fed955baa2e84e9e14153a1cb5ba5cf290563004c94f5ef455e6b60b2941ad49afefccf99ebcf34611b3d11977fbdb8b7da6f1f329836a6ac3592867bb94972f907e911c72373020a91aa5bb4bf8720b5933706221b66fb191f8e231d8e82d408f0e7ce367bcc19b48b2fce532cf48ddb711cf275d13d7e47e4a42e5db9e2ca11d5ad91bf81404c35b4699faede447fc3bf54a71b877ea3fcf119cd85b04ede1c106c718a0f57094bac20ab60f5f258722bfe50b55ce48ecf0827b9acb3e405eb2b7a942758c945902954a522da92638cd45909f613639c6bab12b22e71acc2b363313b1ef3be3b27ffda05caf0e9640ce25a241fb6db2bc82f9755d7a5704aa7b65d62f7d20c68aaa296217f4b8026eead34316ae252abb6cdca153486ac88832a6d0b922c12358b3f87a966258f4672110d655afb20297581d013e2b701e7ccde35435f7b0270a5c3753a9a1db237d3a0100942ff6d291ca8bcdd72747a669d2033daa27f9906b0f96b6cd5147e089f057b2ebf65a3deb66dd3b333e4a1669ba1ed374a66e3b215dfb9c8f4e143836117f830f8162facc2187267b6cfaaf99661226220ad07a5b385c49afd608ad1f56ba289699e1602aae79b11359dc4c66c0e07340f2356aada9b88b7dfca86df166c3045f1319d93e8096dc14d9126a23188ab08754e2ed41d6a31d2dda64338d266b6e48a0def3ec312dd5770fe82a249d03c40836472251c9336fa5163e7fbc73b37c865fc338dc5b9ed57ef1bf71d8cc2d74448d91be7e71e605dccba24c5d7c12b34537ebf73a22a3d4b2b4c8b33847e572c29f9de2378d1ac62ebbfaed9b4230e41f0c2ed41eff5f4c130037f73a4812eac5bccef0a013ba333a2b301ca0a77f7f47a85fc2ad10c706943f7b8e7d9957be8a9595d057fabed3b722eabca65e235e02ecf204728944ab72e350e6d5479c1b2fdea08d841c76ed230b5e1039afe0d8da5b0e51b159304f7a84e10f7053be84015d6a1cd921ba5103a0db3e7e5cff5d51799612b374150a7c42a33723975e2487ca609bb2849948131904e0a9fbfc33add778982c266d1408034813858bade7ca6da8e61639e23c0abc03e21623425c584c5e6590f862e6d5696c3982c114e380cab1605dc766b8ff664e5148005af3c4b5a5b4f945a0f44ac1030090662eee97bb6eedaa18a0f341c6dabab57a69818f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
