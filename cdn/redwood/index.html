<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d84da870fbee928b51274f855c8c518f7fa3df09f90ea59a16cb3506c049afc0ad2d040ea9641e1672c6147dc84762779653a923dc43226a86e0f8f115f2f26db3b1be8163106eabd5097d4e4cdca8306071b30ad0d5580040333492c27cd7cfc628a350a9a27f1cd5df6218844faf55e7668b27d7c3c88da9fddfc2bf420f2a49c75709e7f176ee42519b0be7c410b8b80dd39ad8e537db9dfca123adbaeb802059d34c9e15c95e543bc12c578869d60b00a9906f0f9336eed3668d46232c93ae4a45b2476212502f562670f8bd83712e944a58e6fac709f23e6afc701745970ade515bdb0e884876db8bc9772bf67cd7353213055bdb3701a7b9e32793ab42aed12892f215fab62c06ed310d36d2fe4dbad027630bdb32479e99ed11fe429d5e73a26059f464433a05a2c71b00359eed170a9ba78a2b30eb238b717654aeed759ad08aafca37c171f5993d042443875498095e05d94204eb8a072c9007879dc411e721cdb4970cf949e049f8277521b991c126c2cc4be04b483c8518e55f42ccbb35f29adc3c50fca7992825db28c49e9fe3bc205138c423c3587d9e2e46187146b77c4cacf51a0cdd8b020bd0295e03fad78205ea393b3b950c42490964058a0194a3731afd4fd45c801004116bcc877e2c40fe880cd7b9a0c1fcdf590078bc14510eea7e850b785ad7421f542a46fec3a7a08a736b94c68a85806c8c5fb1a30f438c6fe788736493a52d7cb40c0407d19578fb35394a0b3b19a22cab596c55a35a02ecd950cde0eb733dfa295b10482adb932357432e1d4ab912702c478f152872be910fe5196fbd2b2aa088f0e3ae0fbf617940d6f139051d174eeca8226137bcf8a3de2a0955a2ba9c9f49211322c09d5a1fea73a588db47c903aeb51a64f4255e08784847b794cdc7badcb7ee7d953f25c1302e10659521518b59cabcd94cee4a45447366367c162e8ab98d1a803b67f6de2d6339d42cc063ac910230e3ee76d7a7b4e351783d005da407f8f0ca3cb4a6d7e0b97b7ace12fbbfa65c961b6360aadea1a7511b3bc55ba3af2535a8d08b0aca74cd24c07946b4109f41cf105d16ea9492f819195df574621a3fef0a7902ef39eefdcfb7ac0cc036c415f3479ed00b3bd47709ddfcd48f541653ebdf7bda3bca91432c62edc85e0510d72fa24e9c181bf8726fd70cd315bc7e3ebd61013e52149b761c6a3039d29314fb6a21d248e40e460d545e80be55e01b3b4da8be7cacb0f9680011bb3e5ddf84c721b9eb5690974e8c84ded727392f769abecbe43e475780ddfc1d02e32f6f769f926889f50a7f9954817dd06e5e858615b0b9da449674934e649f3d28d3b0427cb5afda55a3b145362c8e9dbc9bd4fb89466e1901d256f67d7852fc05ce0c2d954b8b079d888b2d0b0ab7fe2ef8f325d1c88ff3455cb9f3b82f87e3cfa611bc6f22e2c7da4bbbd4ccf3d5434ebb4e5d8fabec8716c4bfb1ec320028eab20699b589a89ebd7dfaa6c9611ec3a6efeac9809f67a15ba5b2a63d28f1c118703ae4b23947058a9c0e395bd06f4d2e007b882408f5cff68a4e2562221d33bb313d1287729b85a5d21b8f803beb3d85091988791faa89a4b1a0ef91d154d8355155e24153805d0ed13faa5835732185b11146526c576c9eeb6c327b9be651c4ed45df47ef494b83a2aff773470b72b3de628aba854274e6ea3e5a60eccfb6324f178878e6be48adb96154a8bc0a0bec7b0694ccaedfa01d4833bec91782bebc16702ab6be8b8d2db8fbf01e9a8353dacff54fdae4fc24e4de62886f9e15a3555f21150962f00587234bd4958be4a08fbe2fe3d8607a790d72dcf599f74bd025a75d192d927b31158bc5cd3649fa05dfe5c26bdfa112bd0f2830cee23a2d279e3ee0038fc1cfadb4ce037ff51fbe92c1416633a40d93883a5431a676d32538d290bbdc23a99eefb5d401511fe3232a900a1e593aa4c1a97174e361b952f2f8a17bda3c5abdf6bbd8b87a14b1b4c7a3216b2cbfec70921f9f5bb09a2b86e03e28187dfecd3edfb249189450976b233537fbe9be1f5f5308db5a2f27e970cfd502ec353be9bc60ec6d3cc42372b4eb9d3f2ad1bffcc320c7290ebe2964f65ac48343ac1d9cee613fbcfd05e3b6a665994839d10cd33b5455847a36e055c5fb137fdc00084bfcfff5d1f1cc9d6acde75805ce0f631e60660d017b74994aa6825e2b4b77dc0db86837a8e6d00175752f57cd48430e40ca6dbaec69cc5477a48ff78acbd60d69eceb26638f4955d18465c38bbc36107fb307a90ac2bdbfdb4f327b23bcaa772494ebfbe640fbe90ccad89fba7b0ae72e0a19d1471b8ecfb1b46eef2dd21546ecc830d385db9025a28046597c3fd0be55614760cce423d02d9a0b447ae445594390441cc07f592ec1bd12468f0640851e2b6b3b9af10befd88e0e8655e029321ca4d4f34ff869cbd97e135687f9d47a488cd386039f26142779a3c17a783f6f8a0ea077ccf72064d632c7fee9422f6e06005b6cbe65a6bf1f399e3c893a72acab242777e95f5a74fd29ad9c9b412bdbbc31d3801935ae04c9ab2f292221da73ef7603ecc8fe6c3d3f3fa587d742ee21d0238f1b27fcb1013ac31c22c809becb12bb0e9ea5a9342c15db0af9290180839b652a49fdc3d4b311e230732ca6380e4bb3ee03a31d75cad9807a09c119286a3942d0e751c069209a614c887b0d8c7b48cfe056007f3d63eb0d01ac3dc41d44cac83dccfd1a76cc19e0eb8758d99fed5e4dd4d0339a1bf54da73fcb4aab39c40c0c6b740e72047fb6fe092a525a7509c0614bf49ee85259b69a11a38ce242dbe799c4a6752f0b6b8697840148a06402bef70777daec7fce8d3f4c7eabe17a6327b615a0d1b962207d59b4d89bfcbe178440e5bc0c71ce4147c125f5355f1344b9b41906ba13b7ae0bf1618a1560cb598769b0b481e94c11eb14c7127aa73a3700feb8e7a24a7eeb5cd2ca228a4e7bd1d7c84f64e507071c7e7467b25dec09109bfc78bd2e8f02dacdd86f5928b7e4ec20bf127fc79fe411a811c13cd543ad6f497c1675e626e341afbff50891a5328d453de981357a7208d3e5035d9fb6cb63ba9cbf59c17a08dcbf66d9e5c8e11e4bd9d8d5c4dd284ed954785a084a25a96e11911b1ba56c51dce868c320098ddd15fed0eb1a49fbda809847ef6a0cbdba3fd3c1dd9fbeee803ac26bc595d606bc1697729f66071bcef18aee9f738eb82dd563b918d37f8e7543ec09f9272e4fff1f25580531a9f10b9c5ed41dbec6fc9fb5d7de7fac4670065b8889b1037227d49369c07c93ee3136fc3508278b1d58aeba1d51720e9475deef232c096a8887956750620d63c4be5a72e3a91fef0a7b6a5964de56e410c938567531682fa36b16a55c0056ffe64dbf0cc6c39223323a974aaa1dc8f82bea0f90911838a061a6ef204d7df8a197c757251d833e95c21fca98af694512607afdb0f1e85e8a014e862bd1ecbc5dc592ceae6494deaebe168b5c9e588ace2e13da988b64f02921cfafa3b6418c666394128afbd31e429dc2b2dfe7d9ff4a3d09ebd44264bbe4fd5d5682e30df507f0e46c5c28f6f6450f82f262420fca0f46a84eec011395a4c16cec6a55c658986425658c6139380f97b373a56c19e014d7ee9028ab54fdbca7d9244114856949941ee03a9874e42b9a4f5e1a7271133a4d658d9c4d150478244f99512034ae39ba96fb1736d284d2cf4f0ede63438c2c55eda9ff97ecb43c123992f199d6816724517914130e69163fb24c0644b51539114bb2b3e639b206882d7ba2550081f8c09f8d1aa984ce093ba513bd3e0e0ef2570ab4058ad3b250c3934193ff1f73b156efcac60bfa121e414bdb87c07572c495dc19a2d873895d0aa6bf17acfbcd6f2ef67a02244b0f8157b63b37cd8953d71e2380bc1e62d5850d6ea9ef3dadc61a21cdb105df9495562351b7f010fea29850f804ae52f0c353ee2ed0dd74422815ecbd20de56186c2b4a9c734a5d4f99c0687902bfc4af9749387ee08315fa6063dcacf0060e6f0e5327e1f22bd45d7cd86ec9e6b29ffe5e9f5e022739da32555a0504085f1326e93d3ea9e919fe2853b412bdec58968f241bf26c1e88d6bfb2ea105e9162cb6e1ecdedc4ce93785cd68ccdb77ef50212deb0099fda2358331dbc42a81005def728368e3b5e39059c355c76901b7f42a2ce868cefc7d9d6f4b516f76340ed7ea33805603b05953c556c8cdebee5479ba9d9eb2ffb22d404e3db77aacf3d552f99c2514bfb39b4589445f2f86e949d94864121d10a3b9308187af0178b3360f0b80c7381f49283fc1124daf1131e8f365754f86553d38ab69c4e7b4948c9b1847ceb3ab6ab6644d81e68b174f9b7b824e05a69736d61c2581b031c342d926e2dd16a0d34054db7cd599dc7ca71062790ee9fb5acf3e3a12ea9db9f543c9f8b9fd48717c87c8fd301361cc6e126104d98fe5fb19daf0a545663b3abcf21780b10c928e35e9ab8cd7263ffdb8bcf11fae616844acb2548c3547efef952282516e95030cae047a2478e2b0a822bdb00605e9d60b19b47599f45b97336e157b2a3dc286fd7494ef89c298c95b70abb478f08d98e733fc6ec59d71066b7449808391b0a00f99d4381c027c9ccf7794453c792135822dbec17e72bab00b5b0438f302c46047a7578e843e20ef26436c23dc4911de0f2c735f29d8fc2aea2af354db8611fb9eca244eed5f24238f4c80ec0c543874a14dfd52c1755bcc2ed2c29528f8f97f7a2822df5e092f28cabfc3fdb450a0026302cb5bdd5dd6874cd93959ed451b9d5c8b6dac65ab0537fee8a77fbf5f9f72021caf737846cb5723fa1a904c612dd9cd9b78fd4c1e2f2ba6829bddad2036b160471876632b945d10ae09b53a11efacf768b0ae7ddcaadb3eb05e9c345ba5b840c08cd9046cdf79e3d10775b4cc701e8ca95c33dada47ce827ad98afbdd6b3ca7e151293e6f2640b0eb6d8bc04030dae68922d8323c8dabc8cc90020549769cc09c86d62c19f70ca16b5557b2f994a0a7e3a2c22580a6cb67a20f50793afc24370b1d5c6583d57dfc63f3f7acb4a5a8e65353539679eeb77b1355db69b31a11d637de9671129edceb6e3ea2bb11d991f533cf4c9d4b97ba3e5c76d6e1e37c9433094388ec12e1737accd991c97159c960067f9ba72de6af103f87a51e5a903e6836bcefeceed5e19c6c619afbb4825dc6af9993efaa4cc54d2aeb694d2c056f25d6aea0fc12dfb95253bbab8e7a559620b91b5856a548e4636d5803236b4d3a1bce2fad5a029a9c8f284f0bdf77fbb8aa229c36b057597cab76fb3e421ad33d1c0a7cbcd3ece5c4d52c11cf8075d1faa40b2d3e89d7ac94381e9b758f47d8138167ff040a0fd74212e89c73203fb2ef9a3ffd5bed643c7cb660a477ea14229b7925a45335699a66c611f069ed03e04f16d5fd6fedf0d32ae97a6d6db161ef41a910613f9d219031358eb0461632d77e05df39e51a5d83c33b7be122eb25684521dff7e5467ebeb622294d653d7e1eae6e25b36aad388f21c9ceec2e427ee351c0b7e3c7d9868ef09c052e66ed4a56e659294c75fcf8a25440edd9047cbc4af8131c3b991f17403a9ae453c7a1f137f21fad66ffcc92222641d2ef96c35b4a915449748757fda13add5f33b34cd57cc0be0aaaf9108890b96f346938484ad55a0923450cc9a4f9df94cec2b7c09196f5fd802d47c478be4b8bc165128bd64b7bfb133f0ecb7087ba14f3db133e3ec544a90b1979128d82449ebd58bcf5c73eb2ddb8fe49211b889506002198bf27f4df501d6e271138ac3f859600e9b1ace98ff469342c2be891eaa6db38df985a7d82112f15d3fa4ff3ef26c38aacd2f8ef4ba709d7ed6b2267aabb4743895f32ac47f411905feb2b088f5fad14cf5b79227b5edc31de40922037c494abca5166f3b9515fcc8ce2a8f73508da757111c5edc03d177d7c5641f20e504551744b665bd70ba994af2faa236f28daa37f775bc97eec70d3dbcc0b392972abe16741a3ab146d55d4ea673b12c65e24cbd8447fe32a431703ae8e5716a258d6e41fce4097beb9cf0f6ac000f0f316a1ddd969eefcf7a028ebc3e04c3e378818309df89d34e014f3f432f822de9b3cc0ad7e65c580a40bb1061d4882050a5f59015fa57d7cfd54f9939d4ba35ddef4c719e6f3d0d077de8e5de0193f1d00a2c8dda38123ad3ccec534dac184407e2f3ece770f43a9444be996e94f196ad8700023eb97e09ad57ad05a3090ff9e7de99df0c3cb1debce5f9575936a530b0780ee149f50a7f54537cb9b40393ce8b83d9ddc5d2ddc05db9c0a46f44c17ad65eecf20d705c12c1beef6c019e3c6aa147287eea52283a8dbfdd78e61d617a344af1cbdd7157f9ab87f1e31b30a25fd1a30e3c0bedaa7876a577158d09c28835b218bf003d258258943a03128d79a85478cafcfd94f5e0bcce81936949cac4d24bb9e5f91ed5bd9a8966deb178be90c3bcecf506d33033dbc47ee1e40637a2fa0cfffbc36340567e5fe99a4e140dd2feee1f40edd4d63014b5c6d4ee888c2d5191ce038a7dfe106e626f90be7188cb9235a95e5ad501d361e9856852b295ec39bfbac47695e3fc07f0365cdc89a5c4b1e3f99caf1b5b3a5e1b25e3296336300e7abceabf9ecf4764d4e3e1317f44b43e17055bec3e0f77337d386cf9b19e9899dffd94f20cdc5ada299a132b71e201b2cc77dfb280313a047c81a7769281994346a78285c606d8893154a0b26cd7d9d70802d7157f31a6979aff4dd2c179cb050d3536040fde3e70f86dd03e0e2d707d767803d7a51945a98cb8556387884e84af1882943051020d9ef8ede4e609ca427b252fae766817e4d8c7d765063b23ea12e8924a912d586e170e3964bb73c3073e6a1c520b269ab253e0ec9ff92c57d237994d25750dcda31a2d8596577a1b1579dc552f75b38e61ccdb9df1aa3af550a5736a8c815ca52ebd3035f90bfbe18bb27f57fc059123cc003c058ac64bc8eaa026456354f13baab8d6ddeed883aee9f10cbab3007e252f955efce1d2350431da9e4110062f34fa8c2c2cee9e8b7da63822edf338aeaef36c96d11e3b86746a5340f8e3ede9baa62c58306cb0b561aa95a918fd9b29460cb435d14c68c8eb72f1b6200497b858b4275a90cc5701b4ed1f10d5b51bd1484e9d8f3c7cb2bb6147d05a1ad291b35dd24a183a88d028a53f3b0a414738798a7300e53143e9b8ea093a7e0e21c2ab5b76cb1d4e7fbc93f637b44d05c14ad9264c6e815ddfcab637e24b6c44301f4d98572d9cac89e58e3e050d6e217b521d05ae0247c91f3123832b8a7bc909de529693e43c21a969e74963058300375f1e3f2b3bd1836be27c95ffb64b7a304ea1295d229305f84d45707439605a904f4cac2e94c5990f23844c3437cb9eb06b7fc66552d56935261f3c7f2eb60ea909a679b3edefe14b74acc4a22646f052365eb68cf6b2482bcbc22afd7e564420d96f0dbec38bb0dc473f0298b750a72467cee2f6aab81e62ae4b0a398886b452a8b3b5f6aa3710cd14b7a6e54d77e8213813c66436b8742ca24392b6b50a8bb2226c5476369cd5c9eab5d65c4cec7ba1f1678248b310e7876ac2a138dbfa74ad6904c739509ce76ad79e9ffb43776833d78017ffcf56c554c7536acb51c0353baa5bbc99174027f35bc5156c598620183069d4813a84350b562d6cb05c342f56c10c72d265a974ac3996d24ab00eb71f4d71ea19fcf7c73975a96f3216a99efc7eb41114f0b2eff9a8ea6af016b29d1eeb8990ad9934509d48b4b78b8c4e4ed735ff68651437f3c3115937c266187bc394547a415a1f9e098ece0ab506bad96a08875c072d8185bdf7666502fa25796bcfb43c0093d9a87c4445f00cd717403cce102ae2722de057956f60f69d7e9e24f70da5752f7f271d8c35be5a9f6386ec901418ee494ebcc80f3ad83ac74b4c1c1d2c15415880fdb8ada5ba92fecd9fccb7fa5f1b5dbaeec835ff631aefb5247c99b9c069d9c80fbe4fbfdda38dab9e7d1e410e9f067112589505ee536e773521fcc04d92d9eaf68310e47a79ac4a522800b066d0410c4842813889676a0e5514e54663e4683979c1688deccb5b239b9a0c9fc33e15ea84fa5ebdf665e54f44443348cb96a61d20073ec7b89247d56ab862944ad3c5084fcee97790e18c633aa59e22af6abe12576f4ee1ccb363fb69061073a1c68e494111b935b23ff0c1171e401b6f2315caaa525ca77c772931cc694061da9c18997178a666864b862efe9cf97bad1f60e923b81ab19ac3f8fd1246cae100a8eacd3882f8dc2b159635c61d99f8925e0d9b1354a3cd550c7412955e132624d5f6176411f14f25001e1f9bd8e2bcb63b0ace7c4c155001e0a01160230dd08b1b88011f45061952c856a845e33d6f57f9c43a27f514bed188cab4fed715690f833126a0ba6ffa15f25df1347217dde5a0625e96c5da8b1fc14666ca6bf7e38ac2ec1d29c329d8406e52631bb09e8d594b87a146e76509afe3b9649554f00e984d71765c4cc6ba3d97dfec9100dff2e8c61bd83b4a385e7e7140b6fef65bf7fbf7c0b42e564ab3ac8634d51fa24ff75227e47c16029f8f425d88e93d17d9b833113dffec99920abd19d68f030e38f15893a86d728d8e216c2ea2f0d726b07466a942190f26c6169eb0e49d0b56dfb2efe48c45c005e927fad14bcd305736ee8bc48bb2230c75688c7a6c6d6a2328ea3a62550943596a632c9f2e85306aec6aba76745be1793c90065d8387d3a30b575df319a44f6deb5fb888fdfd925af3617c85a4e1f0f5e4c40cb6c34dd3a4e1a9e1c9de8ddba248a6d20b0a693e593904660596a73cc28eadb9d3f9f75f37e9f5ce715d73a17399ce640e0e4dc5d2e8b3bb08e1e5b847a9d5c7992511ba7e61ba28c3542139d325d77ca162452ff333f5b0e37c5b3f4656ca4c970c98ed6abb5130c7e4e97c465f4bc7c03657a04935fb2d33c7a585413d0e6c545a1318aa5f3c1ed81cf43707ba92a22020ca5dbd3b946e4df8d294d607416c83048f5b1d353f5c74c6815ca70809da1699a9219ac4337a6a788c39017f4938b2df1d2df18b25947fee447595324b4b9785a5d92eee5357ed6bb6a770560f74dbf2a98f273bf5339586ea27e9e04e9b3479772e29252de8e6eab633a0c37e42fced61ec871e02dae3666613a609e797b3865b152b0c0e45a80b3bade988964d04350749114b621fb2d814a4b926a0487184578930554eb9000abdaecf93c8fac5cd6a3139223065fbbfd81849e9ca982964cc452776aeaaede82ffcabfa585e24c338a1b7d0aea670c2ffb1fc9a7afe2c254dfd133971a9b3725d962b5ba9bba6f9763c47936bfabbd5bab7162a33fa2e31c92a0e1689edc5bdb6661179e6f9100df38504091e77f6e41a5809864d5b10d081cb6856a7c8e40406ca352341238028827a91f00e88548871ac730c247ece7ada0465d416f604403ce236c95ec53c3470b5c890cc768b1471a4a9c79f70d06375b59a746b7c7d8078cd67ea2f3cde9a76e580de508ed8aac7277f1c47303813ad5dd4594b0684cf3ce1d129c51afc460c23051bd9793d3e4995caf9574dbfe021579bda27d4a7ab29df2bcfe18bafa6dd02b1e58c3eddf9d27c5f6c353310505f285f8ecf0d96646df08704a34b60765b11285ddd7d8ae35430d9356bd30b477f42b4c39665ea1e18281d7dcd1823f4361dd184a2c2ea16798b50098f311b7a73c786e68d8b47d320bdf6b54e525fbd2cf207544550598e111588f2dac98c1d8c14f56cbd29cf17551b0fa8f6b34a3ad1144ecd1f1e66a96311854f677bcc7668a303b42946f96f3840ac325ea7af1ea9b4a3946dde8d7852183729c18c35c2b10874536bf7eada2dd4bbfb6124e64e20fe95514a7073759cfecbd004a8f3bde061d8c5482f9a5c85437e2bae0fc88db1ccffe63ab6f93b8ae130e8cc09d553577e785c992370b9b20d34fd5d0c7765bc703c1d0d8c478fe938be17fe920b6a1ad9a8fa3bcd53b449c93c081bdd6ff7dee0086022180ae865669af96e93f69ead69e568165c96fffa527dbfc9bf2443e0f4f09278a2f79e53e7469f0ebc1fdf76e5b896cb78ca679fd6c51ccdabae6cbcd9c17ce804ae767d655aeee03f3736e727edc9689820f0b6dd8338eccb9cf71e5311d318d7b7300b797ecef5809d9f0254af95ba1be3f288981b80bd1a8f77668072d9de2a69251ded833740cd034f1a78abd9aaa4054a0e83ab7f92b46d27c723b2aa23a5a8f65e2ed4ab5906ba9d4d765a6fa3baf62b445de452eceb317bd4978f0accafdf411dedcef6373124429fe9731e2de1ca4fcb568921453ebf375dd346c28b572c01bbd617afaa314a0614bec6e1aadf28d4bf0603fec6245a0c570e662ea5b671e8ee4374dd6f58ae099665fe43ca79a50dbe5bff0872e6cb1c0622cd4efcd6b39f6d89fbe05a1e6e60a9c1be22ebb2bded2b5820acf9eea8ef61df88da90f6ac768898be373805b1523f94ec486338e039d5e364ddfea9da01afe1d7b69e3d10725d7f5a784c0d44c8d276c26cdb54303ab7924354dddefdcbc39704209af523fb6723078ac93c0dd0be26a8a7f032d9079f629559989a66ce24cc79f886a7d6f813a4c4d9d8a1ddb172bc5cf336ce50a2a7ffb68fed8952d3b251a678a8ab76294c4b45fd32b8108640f57a7de15f065477d3e84d60667f7c8d39a0d341353549ff29cd2fb07901ff76ae33652992daa1a9166e73ba559b713d0d81b9f111f46fff9b213832bb379cade53ce07907449cae3a2909a24a7262f8f69af5de82737b97fa5740ce3ce07a7f2ece7bde475e3676ac92d1ad256657a97b27af48d6d5da81da629a32131b2c2eef84c215a33e375fcdeb30f8dfcc16695f9e7bd3dab8945243bd8292d5c098bf9aa34fcd6ba515be92e3e6cae08308842a6e877d8e2f54499999cc17824b9b14c72465693473e016c6372d9f8a4eeaac55f1e29b7eda7d94c36b49bda36cb8b82088db00a501ab32fff33e375cf396f36c145c50c4cc21aca31f0caa0f77ff7378ca78b81015329ee215eac5973ef2c2683350ae51056cb3f208f6b2071968fea91257a6346a5c17416817db4c6dd4c7b7481ae4da5cc12a00f9f5e452c1fcb8978057ac61333baf2c57ebdc8f0c27db41ab7fea77b35bfcf8b75a68257d889862302a82ba1c7720ec9794e4de3598dfc7f6b29b372b4eee382d11aa33ae00ba53813bdef1f0849e2b8ed937b7fc8f03b848ad61aadb823b11a846de68320c9825136e72ff91e30d2d38a1eee51220adef8d07d7f52a77d4ca56082d0518fae7b53394ccb6c6df55d7d36030a1fdff7237baf991e5cd79627e884773ed18e86e2062b8b15a937a0a023e951f92044dcba6783ac1a82f474b15c4f3ba37cdbd2ad3e80251036550fbf449acbd063a235b9136992fcffedfacd34e4477d630b46c51910cb060d1ee69bcf7d35cb4053f0cb027e787232922c0b15e5d9654dee4c57e12b39a91fca0877f0059c615a2575c4799b36eaa49ed593d8d5cc06392329f9d604641965550067cc51e51bc36fdd71a2416fade0d810fdcd1eabdcc218b654645c00281c88f92d3dc45d04027fe68c5a102b5f1559662f2b98b88a162125df4ec37cdfa7c52812d449df3ee35fcb4158ce32fe936ca8f4d78a047dfe314c80df1754db6c41fce425cb0dc41e63f22f09f6f6ba89db9be6d5df5f33132e6791789f961f20bfbb498a5cdbd3c2dfe0f9040de919155664ed8764cdc62864df34fa189dafceb60fcb28f964995c78dd079bde3d566fcfecc35013e8086a79ed34ed361c9c8aedc47469f8a901c77795c38c851c3c10cf382dfa6c118304145938726dbd3ca324c4ddbef2a03fba4d35256d9d99231614f5cb82abbe8738ce7007ee32694c388d6b95caca12ff39c7b401898b80332c1c85cd249931455db252a514098b49e7e9972718eb28bcfb8d53f06c5dd4880b8088d15ff0f285f35dbfe5391fe32ee6fe5560fd99be26b09d0e7cfb54ffa6ab35e43a596d80c4b9f9070702eb2e2ccdd962655d715b250982e14a6146ad62494a084ce6315b36209a5b14bb67788d35ee2f6bee7638fa27006690236ec08e7eb1f626eb8ec4038ec4aff5e0826b310faa0b8936a6b60a2fa7029f0c695dc6ff1e8fb89e8b8ef65d7da3bafd6b45820cb94dde4b4e77ab79f024fcdc2827065aa26eaa252c113110ef7db80740b4f60cfdbe8e8544146f5ed9dc49c039134a64d7040bb3bbce899a9575aa1b99de63eb3e803bdc365a5781676a8b6543ef4d9331161c8d2efc533988c032b743f9a6ed616dbbe58e7d79a3bcc1a38ce35c07f9e64e7cd6957cc523de7b1919e2e880d7264e5751e31ffbfdc7f07dc6820bd959451df30805325f400a39d3362cac1663baddf8cae0e6e4856efd47318edd4fb10296cc927c860796f5685dcfa587ac73c13f48da13b520b87759212fbaab3f4270a3be30e8c9bd96f006064f2b12a4c0e953709231985fe0ed44a41442b17627d7f8addcb3744ec3f0eaca48f26354a55c37730c7bfdebc4bd6a67fb20e56a9db238f8ce80390a8de9318e87c1f38e34fe921dd0c589b30862a181c4d3f8e52bc697b581b0ba5dd021a38313e1bd9c058edb1adf9f390d3e5d6a5c91b3ccdd1c80dd7777243ffb8c4861b9695260c38973ac7e9cdf5f178a66c736f380afbc9d84d892ccdfe0f1048e588f76429aa3146cc7172f881dc7fd0f9ccbab4b113d81fd84411d039db7f352bf8529a3c45aeac0366d70a33b65bdc6238a80b8a680afd2b828622b61ca4737b465e907fac21bfbb5469dc6e555b241e272c20166d6ce1a2cbd66eb62f2cefa23026a55e001cdab59ff373584e6d898d9ae0aa25c5dda51e7595a3a46f991713fe627f5e4ba4771447e8013e2ce66d03319d22e7ec674dc81fdd5e9da37c7caa1a3e7258b118ec15b860f551bcefe2944172d0ea8799860cab8363700dcb27d6a0d776a38df6c9909652653ba4e7bb6b1c6ffca770d6a334a32bd807f3bb1b956450ff91bd91d73c861c0fe00ad8ff9c9fc01139fafc397230126f246fb6a88a53fb55a4af6c4d62511b75e43f0a4f26d3af3e7360ba1221d11b6c1a882b5c37d817acc8cadad23cead377a59d388f37f36e92ecd42c0d2178c6683c58168554fae39a98bf85299165f105df2712a5a58abf7a14663607f119f3befc4338dd2ef25e9284c6e155cc37ca25963717141c1708a078a12e50a619beae55a4b43f4afab388c3a7c0f15724ffe7ba28ec4dba59cc5fa0676c42342d628dbe3a9273a4840bffdcd32d96e73aa430387afbf60ebd88d6fe241be1ee5fcb3323a65220731e44278bb40d28cf501497d2776aa7459f2056dd9144339dd3e9c95eeb9ff4e23ecc1cde1dcecaaece9ef8eeabf880cbfb68f8deb59933e142af281d600d783bdff22972a8aee8941d45df47083f4353daf598e5d5730c00b52f5a779ad6a8c9a70ee8916484c564435b12257b728aa2c782d4ee0ca72001a39c1ad3de31a98284db7db6ad74580c4c75ec4424393763209e67fc9f48c1a173230bf0aea0d3cd36f0ad2a75d863a307aec934ae8e9024a5cc66cc4471511737b446eb49007f4d12bcc5ce5084908cf34a6da99abc044c2567827f52b36b45b9912ff3be4bb7d0d72e0e17cebe5310b25ce8c67f98c6e40f80b4dc36e6499ed6329c0875facf5e9b6daf754b1d328826c57000ff16b33a8a0f47b45c2c5c055fcc15c87609dcaaeb5f7abd55dea49c44e6866815e83529fcbf81e2061a2228385e76c8c2bc6adb42cf9bfe363a0c0840c34c0f9b6fc87ba85b8c531edcd36d39d14c2f1ae2cb89c17c97a3baedcd5102dce2a46d7ff09e519452effac632dbf8e8c8aaff8d656a919eeffe368bbde44a3aef5aa64e115ba88e3771a9eef3c4cfd5f544c9ea07f3273c6bb6e2df605b649b7cd13cb48f3dc953ec35015009d0d3c09c7db288c59824b4212e9b46dc4f80df3faa0f85156ec6965300602153185840e90a96c9765cf2d1f6c64a22cc9d7d38b21c9101d8d6325ccf7910aac5cd74d69727536c8464e3f459bd4ed7bf5befce3c0ef740a69319e57e8a0afc6a3b726e32ebb557e327e31751dfdbbe1b6d4be5aeff4bc8194a4ac21e151de760d8241ec9e85bb41848fe4547e877964939ed297fc27398b4cdc753ae435dbd5815d1573b60ce98b8dbd258cfc4aabb2fc3122d676ed8d7336ee86fd036ff559562e9bc3dcbade5e47254dc9aa76ef6cbddfbd465f04cdc2e2c25bb4c1c03adfa6d35ecc4d8983dbf4aac596055491f9e13713a37ef558d052ef81cd55320226c38a41aeb5ef00fc7cd1480f877c9076fe68462706a4f3100ebcfab301721fb33e1f2aba7f5b7503ee6e45eca20f6f0b5650144f8b3be1e98aaa4ebf5ae0afb932c0c40448a5ab8a7ff239fea27c54a891993c1c38695b79d23b42a4aad91738dc8c9a183a9cfed24c026d06e5176ea927ae2a83539108ccde6b40b37d7f0163f349326d5e2543d555c65b3b4bcdbc5d95c3ab631c7698d9b454613e731e836bf177e32a74976c7d1ac04d1c3ff5f6336b7e3d6e7093663ab35d67e66b9031a66afedfeceab64cd343210c4d93f1ee1b63836619396d535910eeae4333d93956a7e2efa36530ad9acb557dd751ac20b4f08f19827f3fed2a9a112b51b583c2fe691fc33b692ef2502cedc7c1f7d78e3e53e4ab197c08bf2b1b2b03f46394757e89adf7a456b393e136184647389f3330686a7d463cb08e29a2f80043c804af4c43268e389fbeb1bc89b6c5efdfba7eb22ef04ad0ff3badddd08a5b3bc7e45a3f9daa05d8583d32f224cd5f9abba7c233aee31bef776ca3028961600cd066f92927291664a7873b1a41f37cec7f43a8da454fbfaa083688b667e0c8d64274f2e8da66106040cd53b1865970a5b0ff7a5bdb5bdc8e5c87d32418d95fe2b8df29d5d79c368f160016de4a8bc893122a3cdacf76c958993b74e5f58a009f2a7fe22c747262bb3ccda2777d81816c9fdb8d286c628d227e1b02b6d06b7a6b2dd0d541b03dc9271f81a5b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
