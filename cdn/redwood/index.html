<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"190259df54fe9bf0b995ded64b3770498b456ac536323420b39f017c166281303700c2422d8511deec6d6fcd6eb6bc3a966aef375e4b189cd00362946cc965bf10b6e223295cb0b54176f705d1b4ab5e395574b48537a47b961e0ff1d08a3a6b56108b0903bc34df0f2b476f7d1de669894a4b6f210c8c0ca65a5cf9c3c7fc9f093ebb824e6884c80a2c919235d8d5f7fd5f7d5bf4c008e8702a8fe0e6906ab9734a9c7c6a01587f8ac8f71ffbecb5ef714042432af1cd2d534d3a2824c1d351db09f7caf6bce173aec2ff9a6cce28b884c6e02e1f515b30e653aa117530ed31ca1396296191ba32b5eb42c970217176fb234d31c609a95a2a05f1bf8811d26d6fde78176dc1f4e5dd13fef25be851d661c4d151faa7100a783020ed02ce84c52cb4c55f12586c6741f8dcd034b621b4e2e9557beb403960cc0e31b8299980ff0b597e067ca3395e531cc1b0d5d04afaf1c09d79e896c2bef524f1c866597b90fedd3efc9074f57563c8fe9b67de4a18b2ca5c5da265341f873f226359dc2fea9764f0bf2dd8b423d1ae7897acaaa77fbf4b2635b0bd607777abb0bc41e142a23a16ff30435645773e2e243419bde9174868d1fc36baa2eb83a0bc0ea6543d05774ca7d76662ef9c457270af12d857c2ecc4113bb9f28b1e53be471ab3e48b9833493d3f47f3c56b35547c58911df2aecbd2ef64746206386a60cb76501267573747e9d110145c9f943fd27ebc6e4a22b8f66058523da20469e2fb272a47e0c04a93c6570a405b917aad50177a7e1ea1ad582c7580dded7342f709b3567fdadfe19b0f794ee1656872d0a7b4525da4b948ea1908abbadd849064ffd4deb415fb9fe2a253827435b92849283c2260aab3a39a856833758779f19e3f1b34196d555a45fc3ac35bc79e15a3d99268538622d4264aace16c7af72d63002788b934fc99f8dcc82b259f5658bc74e07063f799ca855dbb3df999e3c76cba41d3b74809d4b77d1736a58d6e07e91b96381520ed009fa020288ebb16de11d8872fcbec51e23f9c47d3ef9fb75d94958bb7dc956aaf282db93a20d0c2036ce66fb3e509acc79c5efe89bd0b1f42ebf4d5541182d11fca09370bd70ff4112a56f59ccb98e5ac0f0b22484921a5c3814abd2cdb35cb5377654584b4003b3a1f10b04deb1d60f2bcfa16c323f04ca2a9e4a639ee7feb5a46fcf59ef37cfd6716a0dd8d08829ba3e0296c94695ee909d5665f203411ebc8bfa131ee683f947fe38568dc45cbe92f019e9a72da0c12185f39d01ad3c1a0a8227564da8604df629e3a885c1ec1eab98df9f45187292bdcde82bdf65a789b34d8378ff56c5aa4de41ed6660a4710848983544a2d8198018c70441ad99f1a84a8cfbf099d9d361506b0aefa8ce81599c230068c3bd2fdc9d74efd1aa889e5376cdc7ce9ab836db96f3e8faefe187253cb9edc0dd649a56e280cbe84998998b6d898e66ec9f2736b1f3269b7473785d7b6b5bf4d9c0879ae3e84a4d18c8351cc1d8d83b2a0549f3805ca3314cd5ee3d586b6a25f85882036b140bb125c658e2a60076853969726d3d13ecfe43cc0c6e4dd1e9fef5bb0e56642118d1e7fe27e8f554a778e4b601bfac21848fe170eb7ec79c451989ccee1ed8c9a7c632c2e40e956c29c71a633d33d99488b651a79c3eedd9722d40a9f62268b4b1f68dd26f26e0de4d23c8e15c65bf96ca608e355d5af820839d990d4e380ea9b3115ef345de2e5ea5bb756ebbfc0f2f2b7c4eecef378a6d6d0f8716ce066fa77b42dbf11b6ef7ff83af542709f8c4ca29816915d7d9ae34993291a1f4d46a8eeba83befd3e53fd28e38ed86446219bebe3065b862427aafb4c04abd8efab7f923c6c6242ab656e61c6faf6a00021c34a3906261723e8e4d4d293e4dc79bdc3f57becb8696bd5c1c99731fb138b8caa278c63a345a24853206077873fa98dbf1b408926ffd1c83d9fa803ca89cfccd9cae224614eb815ae12c6d4b40fde06e50a562564b9e30e5ef13d8c161f4e271b1ded4b00448a6998fff2cca3c8fda01f4eac7ae3f4f517397df64fe72492e550a2426121f0704e2872c6b7e62bbdadae993969da9a70d2367bbc9896d54763863fe6bc44ae619b97ed0dfb89a411591d3d45c24177583d277105a463744b1532ec4467e0da4fd6c8980aca1ee0f358ba95d07b1fd40f9aaa890b5f850a23411abc0cab04eaa15893e713828e92e4b749f894c53de5e8cf72cf2d8d1097c6250104a87291cc07204b9620a3a197f56083cf0cfbf5518b2087e5e6a7c5c45c272cf5fd4c3fa0e85bdab32e1e131e16363c7b2fab52b1567bd42f5dc31ba0cb5ac5e7cf25d124244787b3aefd76dcfbc235877d01e8a6c1a0da5ca981ea90d9943559eb14bb5103b8622ea44f83f3f406e6cd0c5f789b4006e0250f9ec297bbee9d090efe8de951f1b994cfb656ea8bd109c1a3f8f7763b06b77cd0ad35d8105456b6f17b34634b985715378bcc1951dd18447d3714b342b295424e1046975bd6330ae396889488f070fa340478c13873e370997cc26184085bf50a343a2460ad6ec7fc9584cc08c9e9395f729f27c68bc83e1516157fb5b6becf7e1f463a97d4546509dc97f88a292997a95bfb693d2e5e2b97dda2ceb82f3b4f89d362dff77d86f82b3166cdb6bfa2d9cc6dde503ad477e0e4a6f4c0f889a4b5771b2be2c1eb68fdbf43e3f6f0fbdd5897f3412ee7587335679b97f1ccebde9f55c58d52186c765e84f522ec2d14edb1dc9bb8fed19a52f3faecf3feb6e423870c44d8c9702ea3e57cb3e44086663a2f9e0cd5dbe461faa0f1692316d56fd1013dd82bf5e42106f721e1907cc6b0d59707b3e7e11619885ea0a72661ee037ae329d095d2dc104dff523b67d52abbcca23b66cc2df20f02dc7d045d5a3bb14fe75a67f1e4662a2b71ac147d69e0de608545a762748b02271de0ff80d8fb94795c3ec792f1f737fbe1e5e8d1fa159c2d6ee9988a19fa42758ade0092ce2e4ba25117754afd23052fbbab7229580eb7f2ebe03063c78fdea72df8e56eb806338dfd925ad21633ac8d9a29e3d3a5d9d8836d05b493d8c786135249d35901d82a905ee2c5ef83410d87ebb85b655232c0d67b19eb9accaf8f90d495c1e147818c34e3045c08eb3bfbd6090010b8081ff7f0b54e274749f802352a8828b40510f4025fad8cd12f346ced782263ff86433f40cffbb5fa81d21aae5b45ba124a706459f340b2ac9dddd3e73047d6cf00873b7789db1c226dda167537fd287ee06db1d18300b45e42a2e45f49baf1fdcf93981ef926ad865dbd48de12b8121763be805cf3f25eb2e8c1ccfe5af1e029d2dae4016601bea4118fe605161aa71ced905b2fe8c07972b82dbcdaeacebae2025cdf95f92a2ce86d482f34319a65fe8838f3ec9b84079ec2b4e6c6cbe67df01c96fe386fd886db38b52b6a99172ff696f6abbf3a7a1afe6a9d46be8fa430800838ec23a9bcd9fa8b686c54e41a4fc3f1f8430f9fb065649dcda9fd0272abb6262916587a4468009de6427d210546ced74c177c26c620dd05cdcd48ee269c190d83756926cf179b37b8d2e06b928e6a739dc86b743d0b862dfe4272b12c7c8211f832329057a62b7cf9af5a01db4d1178b1ba709efa83019c9d16ed8fcacf24b8fe8fc926bb1734b9f4ba17772b43ec9aa79d122c7083b6409babef68a811fb58d069b6d330e746f910a19471f8826eb947aec7290a5ba751425572ab8d03879598c618379ba3239ba4decf5cf164d5b1dd71ac04928ac9b017bd48f0ee2ad8d7fdd573134d9873cf547368e44dad6390c4b1d0735a53232c003701ed6c73086cf81066f21c705502fc59ef1c76dbceb7e58e095f8edef39268f3f8a652f37cad4a213ed6d3f032da5ef3ea88c5ea4869b5101208573a49eab1928e5deeb9d7444a7b2926f6a3770543db5c955ee6c73f75a0aeb3821d40a86ca0eeeb260e285cc95cf92fd011a650f3f6e5bbefdc905ca47d82b97ddc359f2de198e83f5c9d8aa8f50330250d4159e8e4f44654727f739ad02fbe9f625e77218e88fbc0cecceda8668a0ea114d4cd5e58b50447d9fb6b8d2b5127309c727e8a3b9d8e62509ff1312896c9aee8ac6b6f06943d9e21d64492c57d1d6386d8cec7e0c445f663d902aa0a80b91164e21c53030672ca67db825ea399ae69896fdb8fc46534dde711a4e68225d0c8ef12db23cd17883a2e0e562270fafec4ee570385260194bc5c266a17484438d14780b758c7a2f3e3b566422fdcdd90d349428c7d5bdd1ad6bd507824cbe3bd3668c60c260871785a6f1d8feec3f2d91aab82b765e52aa87a64f466e817930f4068fd70a825a764d8c6885cd4dab174d03ef924910a9255eb7a654cf19e8b1d935950ed7fdf6b2fd59d8f9724845c1f7808b40548cec43743689bff104a90cbf93487953ece3cc45be4c3095a4b4796d9463222a736b0e271b292dfddaa5db9762e6544e32f3dcbd60fc06356c8c7e0d322871ab2d6592a7b1c32c414d5a651076099f1db45b5dcf6bd93d9b71b84d164db81f41aecbd9e5ae0acf2176d0bef16eceb3215a8f746d4365472e83e1fa6c97da354ec1c9f04e3fb5af0a2c285468f60a6fbf484b0acb74fa622be1eeac620576353590b4cb80c7afaab63d6b7caf686e6cd4b23f90be206cae2cd0cb73eabc508e0f63ff4d8a50b4aa3efa78e1c71c9dc768f6fa41f83e1d6b4be44f2a0a467004930ea64e7d51dfa51680b1dd2c713a8cec66315a6f6cdd0d155f2b72ffa5b2fb0da5e03e9a1844738afde40dd471514a320740045962df74bb19b1942bd9caeb7301d363cdd39b63fc7f710be4b73741f1aac31ce74d38bbf0995fbddb82f7b6a3691d8ad51cfa597fb5daabd1ea86b30b6a12690e4bbeeee1227fa25b4072f850069fe6180b6abc4532d15f4201424fc186eed5a3e840f7e27159dc870378af9695d1b906c8ff9b7386ddcce18ac2b15b0ba62bb24b3d4fe4c00888188abf0250e864cc7ca16cff49daa92936d2f04a39a2d476c2c5c6465b0f345bb6d9915004c82618df5c57381c9920f8f04719007cca7673bb6c6b983de9341d680bf6d93f2ffa024a05df716ef934d8ef7ca508d54aa744021e92aa92b320e05013cdcf113bcde5a147731a62f94ec2ce0d757d093923ca558998133ff7fc15cc0a5da9b58867802886be0336106cb83587aba0ee558c7896fea310376860a0a3854a5d5505e5ffa54939df9f0cf596f754606b052ae196e5a24fddca158d8430a6b1f501a090f4ce30cbf9de8f6d202dd12b7c19321ae4c0625c1a7dad54ed74328405810ce2e02acb9c46890d475d85d28a2d5dde1d87a722b899a636b88063b489859c708700142f664a387685cc3d50948ec62c94d4a283faa79da54e960954ee118ca6503228536cd899cf7bf746c35433b69d895db10d67fe0d6a4dabb52ea70ac7304ab0ca2308a60341b6f515d45064ebe48b866a0f107f77476497128535892cc27117352895084f2700b1f80d395fcaf21383f4160e7d832cc4789594287cdab6829eeb6c803b41d350fe5818aa59d09b57309a4c121e08bea76788a926a711ab1a83ccc83cc698a5c8b1158f987d54b59ab403f8f5e4ea570ff38ed2d65d27f45f089998ba64e8a33908936330209d06d075c42be3f7b31b508ec94fcc2bc97977fc4641525fa12a1088b813b25034079d1117407f8bed6554ab1e5cc314c8dca9c4f055df24eb98b73a3243fde7d4d177ce85a45d9c20cce9a8bfee144f108ece08fece8a1f054279172e95cbe81fa2aa05314a4116321ba1ac7e18676d8232b23644ff70e9d81fa4ee4bf1526a42ee6bd1357a480cda86b3d0714191f25245f6b589b47518e16f3b2e99dda7c07f7e309cbf38fa90084286c3d442026ae2d1dd957d4d8918972c61260b6114783d914f65db96bf0118afc135ac5d9e253993b511905c738d554237c154d43d33ff923140250f598ef7cdb4c2b4831f4c1603cf4859bf887b4e314a1cc9494e4f8bd0b6ded9e8ea53a828ef56fe60da58ffcb25b547d2710211348eb96506bd7dd0ec0177c1efc32515eeec7ff40143357a8af6d21a8a78049001fe0bfb66cdbc20011e7c15eca1c2a858e2c34cee5d2887b336887c1efd4597c69f4f4f67f79eca8c618455a2b2af2e46b5c2f55c430da8efbb8028aa02849a789417d537b5868881d9260eba71a2b711239228c489a74b2ef172c855a09001a8d09adc708c96f1e1d1c9a928d57fd9e66cdac30efbdd0870518d411b4a7d6ae86f397491fe498a82a3c8e8590938aeb5aa4eb0847becbc4e790dd5fbfbabf3f4c5e279f3103f60dfc584cbc377890153836b0ed44242e5754eb628871eec308e2863e183a64fe8b40223287639ece06c0af2ffa14eebf4ade8b5b36ee791f4928c62002bb099814d3e1a6f76ed51e33e40e6d63c3d85aa9ab42c0f6b7feff866e32f1f109f438289e5cc9641ea394eba5f0675b699ed84b88b3ff5c31df782e3a16d582f99df849f714e1382af3f2a1f5082d222a717e1cb752ddd6d349a324d053448abe7b40c8ac9ae93dbfe6a673733262a4f63ccde158eb036a0b2dd6e03f4549fdd1970d9e7f12fd01dece2614124bf13cce334ee9ccf47f4ca6bfeea5739e49e48c5e4ecc204b722670f52e452651461af26725569c0c88f72294060ade27d9dd1536cea8b8e6d004c27a67e958655f956614586529d28a201345db5fa5f14847f8d80b166c5c3d4ac88bebdcb5a9ac230c968bfb3e5281c79a9acabbe43b21695e03ade1a673c3820b22b51ef46c21e824a3a0d2baf921882189ee4513da078f6fe57f35232ddaeb1ac30b8a09643632e9a4a4ad31160cac2d0af535f8f7d4706d16499c94800629d4d6a967a7239944a13c00915aca9148a051140b810d0d9658cb1c41377165d08dc9f7a7e778212ad9e5a161ca650f116af88b9b889b66db5136fdd958c7e6d8c28547f2f7f5dbe9e7a77ca150d907b5a58445ef394ac67596d4ac70dfd1be0a01eba6d7a85ac17bec7b12bef28a91b524ab1770bcf62f4c558c7f22cbf689a23f103c66b573577fd527f87731d50ebf9b484cc3f9c6d40678a0ebb742bbd163bf67b692f99533231d3bbb5a4d9fac0beaf53e4ac9844a00f2f6f09281feb5e584da8ca599b05039e507182dcedc778c634fad4b844e4e7a3773f652d6fe6f5078b6a342e313c296f827ae376708a7464ae82a2d3225a0845bed3636bb499fa4994e7a156974cb2a48ec0bb966236c0150aaf52595eef9772dd8e1039e1168dc1a5fa4c3ec7eb08ccbf1124b00f5616f59d45403516b4caea92f5c488bd948a77c76e53f9e6c454635161f1d1dc10a2fddb06462db8d4a877cc2d6d6cabc876984a4881e1075d61935716fc1f208e79d75b16401dbb887c9e9a23181025db7ba633faf11f5e7101b181c497a753decdadbb6120c3e32dde1698e9944dcf5e3bbe8b6cf4ef218bd296c2177e65039d22c6a0678e7221d42aff31ea628043c3da85c888ac21d35f1423b87cbd2d517f6dc57a414550c934ad5049bf7e84f1671e3f072b46fb8dc57683536a69c8dee7d1a86c54227061b67975662a84eb32eb00eb8c1b8cc03b475743844714ba9683bf0053d00293a638f6acfe8965332d2983e79bef60d2fcf1e7a7a2c8eee0b6c5e497436cee5aa48a32fda0a46e90cdca1a0733cb985b25c14333e52cf62060d038fc35b78be168397798a8c816dae46446d46815e17db75fd5517ab3109414d36bc91524323ec824723542dcbf237e389c2f61660ca7d8ea23b845bf9b5e591c9c858982ba7ee0528a586ad44ede36849ea7fc671d4e98c362e541a6c7e1d76536ec921573e644a8bf4f7834fdd7dc6c3878cad3f4d6b20664df0b0c14c432f8fae5116868c2e9eea278e4b7b64c212b4702dc272f5401f0fa857011286da5c072eed7f83abc92e4d43112d9bd8a141422f08dc65b45efece9342e6c1375cb909a17b32858405b3de55f8550bfe7fe44148213a4304541c277b50ad8c50fc5af8915664743192652979a0996a4bdb71d58123f7e6d6f543f4ed9c7f1acc69ba0affc761493497a0cfa4eb2fddb35a457cb0c16dda8f57bcefb3de6e4b8207b518e3ae5d213ea15414e4654ac8fbf8f448ceb60aa14dfdf481cc0b7ac454e8143bdd38a50a7f391150c6b88d8b2af42620cacc0d2b54cdc2006404240cc73c6b6dc824cd457a8528f529d8f5648f2dae414009c99651de25d971922a8a63665981c742a0516589e4d37c788b82fb4983247e9d7f3f18b4da604b18eaab5ccce1d280a0cf8b2f4ed9f5273e0c1544a1f8b08b0fc0873e7e8f40e8cfed749ad5ab3a02123269678003d50273bca6051b3d794fd5996b0f1aa161cedbe1cda2c9d13030cdbf5958f16a4ff698fa3f470ae7e4342682316fb6a9f9362a6bcf2c31981f873caa5d90ed81eecb4bd78b0f08034154185cc2acdf9eea66124fcda2a8484655b80897b4b87a403dd0c3da663a5510444434c9c806e7412641856ed9e14bf5252e843a130047ce780173e606b3470a3d9cfe0bd9eec4215d433609cd3317a1b8b6ee263eac22e62c51449da8aea2675e1d8ebb624772c80c07e201bbc640525efde21ff3ef7d4ed864ca26187d241dace136c685446bcf4d33a9dd3cddfa436951b023edc12efa8cd82ac737cef926f436814ee078270b956d040d1320a322bf5ff952aa27f6f359d69556d4202b9c1c8aacaee9b764ec2e5b5f08141406c1e0906cd166a12d1190d66f0ad29723dcdcc610efb77611412bc3e2877410d69a8e1eb9016eb7490a9fd365ca01f4c195c85e95129f5d03950a4b041003b8a29fa531f2ca4b12d98c535163b651b99bad0f94669fd464d6f08c497c0c451dad5b5956d02824672366ee280f4e91b1d34fb466b1f99c8219705484a4fc96e64469f960805fd861b50c2b044deae722e44252b21826af56c235ae57b31da82abf4b7a62bd023231dfe3f8a1a201012ec3b6e62d4fa8d008b44d222ac9778268295abdaa36d43243edf6d5d3e5ef36d359e35a61599e9c14b10e3a5cd251e05fc15d8051182231b6b0f327920b7ae4b7a753985e35fdbb12ba426fa0c2646951313c3810fb05372aebbc13d42b4fe3bb97e72e3753e99047060a80ff810f9642a7d82408843ca907eeb62b19863e25c58bdcd5fa9234d2d031129fae88adad837ecab65db179674ff6baa4fd2abe928d2d730dbae9d6ee9c7abc03fcc8f621843866e67379fdb856adf48b6b8368fb4c729e26fad1acb3e4980ccd5cf2091f1d5cef06d925f5f78f7fab748af7cbfdc0ff987917e75ceb0e8e9973d6175300ab2bfe35a66d9164db138172d7021b74845613e1188aabfa6db1c3c549d9efed18996932a9d2802b50bdb8e5b409f8d40d6d2c0976d7f2ec66e32db067e85b10a9429838b571148f55d584d3f942d2c5be8c6fb0d8c2033f1da38f12d08ce8f88893dae34b17f7e2a6569fc17d2ad6a6ea46aa6c2aab8d01e34bbdfa06cf414686d530f41d72ff657999dd5addb10fe06dd398d29029a1b8ed2579008fb234f4905c2dd21df168dc811e29db730f97ce5f574d370312370ef063ccb720bc70d22324fe634ec9d7530b3a3b604ec3590f0aa38c62808b780e8f6e686de568af50ebb2d39336254fe150c21423c3176a69859d82a81eda971569384e185358569473bcd99f61f8070435de3455dfb6deca62e89fbe5a0021b37e9faa4817827b7469fad06fec8616b454be119c7e4a15db9687f4c087a261a967b0ee56b25e7be8773b471de9e39a9930defb3909968c2faf4f7664b0a848ed50c50b641ef958559240573608e0bde966d9e4b789392847fadb3942e1ea055b60cd6c530138f757e92d7a9d4b36fda22f4bc6dc32d8c60a1afd388722cec40e2700db2d74a37d14275f2573814a786f02ff8691fc4c949a24092522b13c516d084b336ee82911f9c3ba73bec380e6cdb837b9a054f4d84db1ed803c635d4b89fd55d03742d24269da6162d8775ccb6908f981cb3de541d140d3e2b305966d99c0e54aee7e20463ef5e35ad75356accce14308c3971a522c543ddf9cea8b34279886bec4fafdeafc11ff3ab327736fb572805ae764e15f48d4cbcf434d84f16ff7ed3089303ae029ccc38d3d862fae06d39072b1bc743722406072e2cc65754f06a0b12f94246e7c51090639290eb6e9531180532e790621a039a2df564bd6d1548b2240d84cd6cb115a02d03accb463c3cb9ac9e33a4066d2ab2ecb2d2bdcc3ea4f9acafb16f586843aed1d22ca3235384bc9c76a0648963748a3890ab1603c0a490d4a722410eefd312e6c0011bda4bba66f405fd04a4ed167fef7661b3e88212f91a56c5458d41a5ec384f87f2f32ec817dc25f70c03787147d7a693c3d9adf4db60e44584306b8200ebbc6d56588c4aac47a7b01c62cdbd9798950973300aba1e7229766751a77eccc393f28332988aeec36aa1ff2b31a465743920fce7fc4104111a622a3ec3f8ad56b6af1281b9762f8694915352923ce798b5176646bac42895d2d5522f0bd74507bedd03f52eb6ce192f84a5dd43e7a35dfebe233e89b9c17f268a016882ad706495b17a493f8b440ef46a4c3b0c37bc519c23f516eefd5675da80f8b4b24cebf87b15bd21eb695c71abedc24e4dd7835dcc4b8a152e96b0f72214f02ac07363a2a6aecd223000bbc006654f8cbdb1a45b7b3f679492e4792d00f67fdc137ffb5c4728a2c2426be81021e2a889d5cfcb90d039ee76ef834a88bea18599dfd6be23fa8aae9bd1094fe7550fd523f64e2f577f752704b6c0e122c7e00013c33a3f97a0dea67b54155eb38e84d7e5b957e375d3a9a9116c8a0df85fa837af6c7c0d4f4f42e91ba4106dcc0b48293a07d577cde0f5370c5c3d8ae1550b6bf815b61a7d8df458bf1a803418c46a6dd56b8b298f4e200b682de3ffe3ee6cb23a49e78a0ed3d4de816fdfca46268d62be5cca3caa19cef2c10a9ccb0cd240c6901a3a2b64c3a880ac51951c3380dbad07a53a4b8e03a78c38ee8259c9a1e4360b5da29831c64f2adb5343a0196f21a535d9c371421ed471e897d2399d6c59a4b50d45ba276b61a70723684ac5d764dc2da47ac197b8c4551664a09284f330ddf6e9dff5768db8ed9122547d8bbaf504d699b257019351f616ee3e264159e05a531c9fe5edfa507100dd98d7e7b4ee59906206e2cb443f2c74a0e236b2e004367650e4ec7ed454727403dba5c2672808afe437e5b986f6de0d521a0eb044d552ca8f2432e669263a8c0d2427f4a60c1afcb0bb8c5efe744e6e356d5ab69c8a0a56f08cbd2193d6445e73a6c9453a343d265cf53dfd5feb67ceda05dd0f11545e38747f914422def737755a4053c7c095faaf3836b2b8a49a222fbeb67b063ca481a082256de9e0a25918bae786d287d2774abf435f57f5cd5948d3d1a8a25f5b1a633a04136ec4f38e9399f82b28fb5f3f874c3ad282aadea89a56a142e220c2d26fad192d49507593bac3e6f76f2d0b3243c86d151a786065f30ca301ffa4f3df5ec63dd1e365f02b216350308c014ec4fd5066586e0b8420a2f9527bdcebeff44deec1c991703c87bade26d6224197a867cb34c6c12ecf7b4362ba592c8e3f2214c00669710e8fd8e8f68a038319c43e97e1d6939028487a1fbf5e8b847776d9f965a021c62a2bd8a6d6d53c2a5fac4ffd3b6bdee0f42e361d42936f831689cf3b4ce5f739b2eaabb65286ae3e228419f7848813a76637a4f3991741c7d60cb53017c35b8cbdf817f243fee62ecf2f45e65ab8728df7bbac5b7d68bcb188f283ffb1d3ca11cfded8b89682cca2986c1a60617f054e257492257e2d88aed2e81e55821e090dc91107681fc99c84f079ac7fe71eb8f36a5ece31e5202bc0fb3c59d40692b0f06d904bcc5354029f4e5c216c28e5aa858af6ff95103c92f1f7b0cd696c822fa223c3283eb8aba011118258ecbb595ac0d2d1d166f84f99aa45f141f2db69acd7d1c36daefa3fb66eac1a97e47eb2bc0305a6c018976e8489444cc7892fbf476da323a1a766487afbe95add47277255fdcc0f6c11a144c760c7ec0671293ff9d34a2abb0f4a9d12f4f27fcb947018d5cc1e4033c64012a3f8655d268cbf9de4f70e9da09403e9e6576f7b96924a626f51522d2e698f15499a517351690c0b37df9506ed753c606f4c2983385e967afc11fca239365fe48d15bb23cc3fbc7b544b26f251345a906fe4bd6e0a34fe1044d06157b1f5e342424dbbe188009e9285bbd6799cdf697b3e9a82e9c477b44ee5190180d991234a121a7d4a00ab782a9b102aabc1f4b88ff120c83a757bcdd8f4ebbb2ab7efedbd967b14cbac858bdd724bfc82e3ab8322ce3d4fed542cf0c685edf9861b705512890816a91ad131f7748a111ec7e632a0f2f103d16eec27c145153d4bfe5f96a4ed7cf66275f161e0a26c6689ffae5b2fe59c754448c2fecdd39e4f9ce37727f3543f47b820dc05e30885dd7cf4b6111e2432bc048172babcf1de6621e321a1f3a7f14bd8bc956c33f5afdd1947d7e962b83eed10b4d9997ab9d1aed2417cc7ecfb691fd7691190786e0b29dc4027531bf2559c6a0fff454ad882db811199592f892602188714d187406b958829126a29fc82dbcb70dc86df2c75e4eb99d2271b076e016a485d1362e352a6e5d6cb3f747eed26e5c29e5457b66c374b9a6cec7676828cce2d7ab01f74fe6d8ff3aa1f492cffad21ec5775b299f774e0c18dd24861c8d7def4a36e1c0995b64f5adccab81ed4084c50578cbc40f75337dbe067047e1adadd39a8cdb0b097e153290192b244ebe65ee032241fb0473756d6bdfc8a25b1f87073620529378c13b29c07db49ed3aa7ef385bc457e22e93ec4f534e96522eeb129862d8f6ed7f8682dbb41a0023dc1ca047253cae63bc96a04629393e3f85d56e8efcc24cf0d0172d0c385f0ea1cfc92ad2119e4bae82feab7184c618f7f2629470b23696382b0f36127fb44065865c3d5c82d710c3d330326d1cbcf54a2d5818cb69bef04cd892e2269968c86eb692dc78c88e41ec6810d5a4a53007572e8656913212d1602226bf9643be387d260ff15ae1b3ca39f18d25a460d3933644d41c6199815a51c15436c589711604b1d31afb681a12b6a668aca260fe751868253ccb44ac755d06e4bf9cfb03d5e3bdbfe1ba437a4ca0d3d56530c5f4583c5f82482247804dbc9bbb75110412f35b733df06641a50dfabedc80217af31520c6fee20db9aab2ae1f22088a3d5a8625c407ec8315cd3bdde82bed93d666f91c4418cc8c76a65ea47a90bacb67694d588e4fe17603aae5f67ef7cade1aae71bfd5c950b80b5d8821bd60c172486442867703c30de2030bc74f5552758515908c37c0395d278dea561db8efeeccc5496c72e7c698ce24235b121464c769640bfdf3de569045982e3a63b73bd30f2bbb530669cc8daba9e6da7362c0a8704cef4e7073fe0a5ea5c9523876b920638ccda90c31aceb8fe68692f03a8884c923b7a3a9d321589d6cfd7f0d31ed636dc30c1c24001e8b96e23f7c893bea6f50cbfcd3e43ff741929ac26bca214de5e780a3fe5a269fa867a481f6a47e6089d6811f25fc12ac2e390a131d5903902dcbcba9ac93230ac701c4fb5184523b17a172e703ef1f17dc039e686279c9c64b5fa36af4dfb1ed76596a4651979963740a4701f715453488f12a54b7b158f766fd3213a48ecea7c169eb62d5cf2510932a7d21b63a6b0ec9725fca5fb73e164a396fde8daafeec53e054e8a0d7ac00797f6d4572da7facbaced5bcddb4cf2aff89baf0354ea79766700540c54a0e3d370186e0cb919d61621a702c2d17e5ab4bd6357d4e06a69c9030f101816247c9eafdd621d32eadb700e03c91cb50ee8578c770b4397856b3122266b978aeecc77bb8c868130c0b4d94a68e3efbef4309ea7990c76e496b26d0f7c7951a94a73c3e8cbc861ad479e89b0e7a5048d6707d22bce99e79eded53d835596093053614a0586d8d3bf0132adf0cd114866a3738e688724321db1bedb0179a33b9f3f2e1f72c75929331e4b760055e7d8ba277b40fcadcb239944aff3824df55347e51af699e20736634365115608efd4ea6c0a322c9e7b5ae1e9e6070c381c0f6ea0ff0cb2c9d8aeae8b7688186675098e6654c8e914e9d6528cc7af243f6211842587d98e280e8764ed3bbe2bb697b3e459f6282aae06e4346f20f08bb44c8905108d01d2afbc03490146d17362a3dceb093f34e65ff96572f19f1ff5896f41df22c37ba7ab70cbdc5cf5efc6d4fbf3135828a0342566d13a9e1ba3146d8411e220125d98a6299237b8a7435b03a724f6abce0e9f7bac9053277d738aca2a99ec8518fe56c75b4e57280640ab8ec645039ed838918f7ab9920eaed77675dcd5ea0d85d361b7b6f2f5359e378099e0215d0aa612ecadc47ad5b82b5082d9562231ae62d4c8623a3bd0cab19821efbd198710776e13713d71d36a4cdb9bc07198c6e006e34987f505207fe5c994b637907e9c9ade8917934823df6d4ff02bbca3a4623624f0bae9125ef77da4f84c2eb997f4708a29603cd41df75d2af4dbbfa8aba0594324a10c589076f8beebd01e73f44eaca802452e844c3eba55c436ee4bd9315a167dba3fc5b859ba622cbbac2cb6261d1bcd7ee284a36c664c9bab57b74f4843e932adc8f774b95ec64052d582311cc7ed0de4506dd46bfd867bac922cd82f3d4095d567397945081bc5d5bf57325763025004db5f2bef5a51763c8a04f6ed034249139770922598383bdeec8a56e41c8043f0a7cee8ce0bea35c1a5b5dab30cee8b691037ec2904a13abfd3aa67ac88fbf663d38670a3c7af70e62a7cce19d357c33dfa9b8df83d907fbc4f8eaba3e9b37e39b435c3691667d6b778eeb63d5172b83dba2bf9ab9d4894248b4ed869407716b20d59dd3c41dd116584aafc5cbb9ca677776f3f99aa50fad41dab6ab1384df5195ea279e6b5748185f22171d1a9f2f828a6bd3dddb1e6d9f5397b503cef631fb110bb7a4f151dd354a9f1c129281d8c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
