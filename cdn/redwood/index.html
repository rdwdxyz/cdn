<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44f960ace75fdf78af36b8c234cad3ed122e3d2dc42aed7722a3e5a53d45b208ebba635193791514ad3d142421f7fd1d8077bfcd366457bf49a49d0e0378ca3b8e6f1d77f2575f9154d7c167d23ccd27a0e6b277901e5d8c1afb1369e91bd917ceb981ccc52fb16e7e9c511562372d447765d06232aa6cd7c49b3bcc0beebc33b1b75a89b804ce1cb0e82d9e0ab1fe01c192409afac57216f5973f273da7ca162e72047761da7bbd579bc26e58fe01f5560d7ca999467f0a7742513aa2802ba31231b741660a0221d5db4fbbd58c057b8320275ab157ad26d5bab915ed00f11d54284f9d45afd7bfda9b6312b92d192e4006504a5e50dd02a641727d2f64528db0795082c64384b6884f09614e50be09ea9c1a06b9d4f8c901ae916c577d0bde984d03cd1d5e791018d6b45302a33c5ce6dd7933ec048e0f4cdc9ba1a2ae09a61d8b5077ac2cb37ef800c6ff03881a60fff9166a2647da4e99651f40d5b051548b4b7b10c1e3788491f065c344dae2970b7d14b8bed3c782add3c130623a24114893973bcca48ac638dca1e4ec22e565b960c275230dc888cfc4d04b9c3ba92e46f732f5f56b343ade243edaa8a24010ce2ab4a9bd7ffaeababc0e66ed76557f33272f79e5e9ab9961ce7f6ec0b395839490f35ad2b15a1627eb97796f4321465f78041fd70fb05a657d7ac2d8a6eb1445f7ae921454f08d7f6cbf435ce5b3aed53df16d1927a3805f5bf43542c8646dd00d64af8602a853db671650af2669c89a2500e009c3ee40759919b1e0abe9f2377f1f4bd65be1ace1eedadbf0b5b2773751d2b4443dd1b1844e47bd300de5c409cbf822ba0fd45190b8dc24e33d6476b6104b462ca9f71a1534b0e26ccf2820401143e98ddefe2b4737068c5a51f13190777af7cd1eb2ae35322e23cf74af9aaa0e47f379ead371e6ee0092308ccaf58a7ae3133b93b1ec91096e20fd21516b81182689ab199f6508a1decc6ddb83da3d28d34a2accf3c2493425dd1729d8a2cf90695bd31991ac321ab89bfaa6a772708b67ab79675ded531c4e82138d92404f91f21e8e6299c1d7af7fdffaa6876f798d7ad81f36d5c9df9ee246de3743dbe0cf4bec1be76b8fec2015200e09f6a53f82ec5dfd46522a5b654c1415a6c2572ded9ee39969ca82fafc2f5cd0e523d03c58442af08b7517948d95e0cff6f0e9afefcb53e02c512e2afae0a0951db3ee29fa8a39351259882d29898d33a04247ce5f876de369307ee4259aa0bcd80fc562b43c49bb9d7cba474939e1a4c32aba3834a763947a2e28095a81a01f7944d1e94a0a05a7d014d1ce2cd51b75c3db34ebf49f68f4965cd77268a66f20c18e22d946c74df11842e311451f124f8f5e1703d6bac3873e4c33a79363841a81aaa4eda63ac754de42a11d70596283f56dd61d51ce5c3d562c2edd024adf6dda0a3c1029f06166c76f871dde7185da30e0d8563b335b5dac9507c15f0fe58d8e4bbccafd769e3f474a14834768be0c338f4a8d24f7dddc93d7b3569047885ec571c55ed7d2a109f23a193eafbcf8664a84252bf0dfcb2656e70df074d83a90c10a9a7dcc50cacbea538e8b903c171cc8f51cd7f250a2ee68ca7170fb43513a38bab50c54874164766437c3146e55bf5e3d44ec47423dcea490d0cc362072d80e19ad57c1b938d26d684880e97a13a4c44a38a641e54e273ef3331b484e1705ed8d77c3f182cb273944e515d65419d3607dedba50b36d7d87febf6ba8b8e8a6575ff4c0380097684c267a01507043f98ed8bdbd60ef05e3e2af5e8ec85274aaa3a4fa9545f69b864cb907e4dd503e669512dde7e6983df4bf187b1b358a1a58b30540301ee14d08222bca4e28298d29fc94b2b532229520f9e1aef387050d9c8475dbc33068ad700cbc30415318109f6acf29e0f940af6400f6849e2feb2ba91bea131b607427ab869b09730c2be6575d394b0533205431324d33e553d80adca4fa94fac5308609cdc208621b8c7133e354e45746998aff58d49f724fcbb879c2f3bb4a9315a5fa3281ce71de9e734d2a600e283421cbcf6935a518a332176c8d2ea59f340d20c661c6616ddd48c33546f6589b988c5a5ea577e91e5105d1d3e41b6e1c4b3fe0b2c415b2b53df20c3e3f85d759cf6e09c8558ce45ead041d62db1b7a985c4fcf4f64ef191b28ebdc34233bd8860a581e010dbd066539b7136d0e93d14b50f4fbbb87058967490479919949a0fab5243e9c14ec9c8762de346af1ca0b3ddfcd49f0a212af3d08441526733dc08e1e19aff8555d931143d3939483c0a3485e69708e90e50336637d38480df06ad50292476d8237f41d51f148d0036d8bd6eda17d7097b5c0080367683da521600bb58da1d3ccc88edfe6f33e2d86d1c5a51e3025d1ed435854f21378935d064daab1af36b668be0b10ecf71a34b5bf8e91cac4fb2876d123c9769880645c5aee81193d2eb51de7db0fad0783ae794b2127c34892408d6b0308fc3fc9546e69edecc8b9a967e4878afdad7ca63d07b20537259055b92049bd73f4ad5c6a3be325dd08e89cfa029efbbb3e8ed223616754d5bea135b24f35df919b7dae7ac6615efa19c84a8f3f45acc011c6f5a87169f979e2f17f417b9eec099f887488ea482f8340eaeb7d8709306d00f2a730741ddc1601f759efc8cf06b601d6f5de6fede42c07954338cbf05eb1483da886b234a47c9f90ac0e8d2c3d9fa7ac9572475e45bfa15925ba248a65ec5970ae7c5b5a3d8e38bae208c7f39104ad499943b1b4d41c789db72b49db22e473bf739f00479c6459de78816436ca5d5427fd02907aceb65875284fad50aa37abb970a382b099d0e5ab592a42359d834792c678f2ce242c141811447f314b372cad87f48ffb67126fbbde5ad722e5e4ab889608cf470a93b0e5557238b6a025a82459505b485ff66d3472fd02fa531e47ef1c4fbbb59c2aef29e3cf707799b9895713bb4393a6e149a53e8b48182f6a1b07116b3d7c8e38dcd7aa93a73bd1a91d50fc7f9e77cdf7315b46b6288555903971a2a507274193c0177442fac7704e92b89887f1328978cf675243d41ecaedb39dc18b683ebffa4d313137084784fa7a8337a6c838a750c11e3affca3592105080744fcd1abfaa4a2f8077b9f5027fd6f44bf4d0f4421e835b9981e38c25e0df2016b3707c17560af0d471aed9ffdc1659d4a7cfbc7db4dbf1500b0529589b680d287094d10018ce80219fe362b56f2be54ea268d8ed1dc6cd58f84db00713f660c50ca4f3b3a2c6c3e3d069c3bbdc4c44720c9848f5ae99fcc8495559c3265d1d3a1b39fb9b24cfa9acfb4a017a3571503dc4d4aa3be8141095145bd8d68a425f9d07b2ab1650c4f6c32921349f73a8ada3322662ca67a85ef6df2fbfc88a03b5d98043f8fcef0f18479e27f8c28b363db49ea43a634e71d24b5c6c71e47fdba1fa1f3f33ef85f792ace13deb3170ffa4af4a3f2ebdf6048c389346c6613033204c93821ae498cb11b5092c3134ec361bc36741827f7a057c0340857e408c527ad52abe8dda4bc091f1e6c192a52fcb45766fda6ff98587cda6b9d0e8b06e970ecd482329ed6b31dc6668240be9f4416dea8417dff27cb97e380de3b8809d36ee374336e81b05cb59e42d2d00a26a6962a91a6ff67c05a76c0f9cac54b53cdc1d7cb9c4cf0b3c9cfa87d03bc1b400d93aaad488b0c108a5b1866417aba5f003c616396170d5a132480c269524ef842cf8264b04a8ec560fd4446b3ffb0b6ed98e11491d5de2d139c0193976a8553ac8496db6c202bb0b70163add28e13215b511d4bd06688cad27377c4ab1ff540e69cc26b49c0382a2779d9cb82bc479882370ebf7db1b2558c92adf5edc4b578ce18340083ab8011e0a785046548958169ef7a0be16d6583b98022853e946b713607cf0be398cf587c1c3dcc35bd6363e4a318bf7a77190dfb49e7669ec920eb05061e1faeb70065adc8e45f32dc2da6bafdd3a14c61b0c7f1de527642060eb5f7104fd03fa64939c1e8ad4c448779cbc1c4231363735ba49b918bf3e6cb652baf02ccae0b605db35452a1d75ad7d394118f4bfc900432d2f116abb3c2b412058da41bcdc76af64abd9479a34fc744c0df9dffbde7ed7e57f39d823e6ab6fa4f4f339a088d67d45bb4ac28f12f428afd958bb47ceffbed7b5381299e4ca6b9163dd6e0f6204b78fe04a0b32b1f49b77107f6da40572e942b3f64f982c9e769dad68ded504ea708860ec13ce497261ec379209a7037ed14bc3180cdc1aeb44243de94ce34fdac675042d4d5658da79bc5d35d123b0aec2c122eff7cc11b69e4b935ef76d66dc9fa355d4623a1a84929e4d716c93a61909fed4a807d6e44215eb0d15f1b1c10a7578baf56699eb983d97c4a7e4df9843fa681957eb44bffdecbd04b6fd18fff8e8d781089bbafa7f220e60dd43b9f8dc9a24bcd7d0ff8531ee857d8f23e882e1b86842c5bac69ff2bc0d587bc34ac8b6453cb4882a576cb664a74a9ea30d651f6355cdbd5ed828fac53016a07564c660538b65176e1526414484c0c22a5a735a328557cabe152f3dfe2f5e03c0cb3d08619b46474ff967cfbc30a18694a419c0f015e0dbb7cadd905428791f700c6f8edd66c1fa5dcdaec1be836c8e681ca55b969f5fa10bf71fb3f25bc9b68ef05a8824e109187973381cbb88ad5407ad1d3208cf4619049fdce56643420ba79fe7b165855fc5ea443ba2c1d59857b94163fa74f306235d8b83d90e32c3b85177bbb9a1a69ba9350560b139f49a3786b92ef1b28dc304ea0fcc50c0d0844c82d9816b76ad78da165707c9ee0b7db8a8f76b249c4026ca63d0d343a502c64be57c45687dd9350f9f4273635248e10cdf1098cd365564e136bd61f4359d9ab1eeeeb02d653e02e2ea3fc0b0efb59ffc322d5d5f3a8b8815cd0346fe0126201f67b30f6087c23c54c02db6e6989aecada925cfc936988eb3b573f760d5bf0171feaaea2f6929ec6c3283c06ccdd9b6efa8f3c821f4b31c5c3df561ce7721165d23cc1ff766c79584fadf800ea53e5a7d18aff161655344988726770b5cf4706d49fdb15190edee575c25733b57d5b4672be51d7ae32f84c9d39bd5fb753bea76d326084c3beb0955a789289783e19b50492e341e8f31396e1d2d75e37f47009863d68e1cc32de8d5c43f983817de26b90e835c131f62943c90a52eaf347ade5a6a3736746a3cd415255b89d7a018ad99f43286442f9b273ce653047f55f7a410789781dd7813d8e446ade8c8137637909608999e6a2e4419cf8a09fb9c4533725cfeafaf49cbbffb2ea5ba3c8aa27e092de2dd08f07ab6a6b151847daced8e85b5f7b564095f4999a8e9b300891559057d062d4ebe4bd509196a85a17dc5b15e19487d1aab4b5c099209ba9371092d4f8d3e10f6ea23e5744e362b6c57902a1bdeda9383b64b8523363965095cea9b8ef4a18dc8d4b03d3fe094712bf8aa2d2e811e07cda8ae318e135e016bc0f8c7d0bc1c23b80b5cef012ca835aea6a41bf5e523a95988dd2fe96d33154646f7dcdd29bccf559ff5e2660d733087653aa61b577798080eef7111b877cb4730867579fca1d47b1881b882e073f02fc05051e6c49a627813badfe1857f3971666b2eb2301fc4ceffe9c9313ed66b99b46d6a6a62f39a4930c5f1b2626807cbf0f06f86f6d2164de5684486ef9db6f6cec8cc5cc44f571a68f80d752d87ddb65f7517bc645941bc348825acfa3e883b0d17950eec7c4650540ad2b2fd763f1087afd9ced9ca054fa02ae247a5ca40c08f511fe773be2a46398e67a73b05c745f3e30e078d951390a547603912552e0ce2449609e4f366eefcec0f87cd6280bf7fa8b67b4bfaa6ae79acb188b2c8ec5c89ee63dec0756c5bc772a9716b312eccd0c6a9c0ec2bebc75cc09ca2e27d7217c04053165ec7c20664aaa44a883569e5dce76b76f72e9902e18adbe7f538a1a83da47404a692eab51524992e5c4cf3ab6110a6eb3f5438203749dbffe602e6d1ef8dde47e04c44c3c48ce92a956d83fd72244d673e1db0976e88fef17260df38925e7e3b3357aa86b09deb0abed0e07dfc7cad78b354693f8a3a018109ea46839c6716a2ded15292f3427e487518ebdaa30db92079a0cb960b3154ad0fc8d41d471c61d5b651a3d0e67fb78928d0411d361e8e1111527d74a3793b8cb4b6b5a54f537179e9aa3dc656a75fe513bb9a0ff6f5a8e28a216c450f2e9672f98b08285342b1ea561a4a7f4f91305f2e20cfcc7aefc3df267816f5852ea2e1441507f3dcf7cdd8808b260867a0477f78ed2e6ce21de3c9f2b4c6d178e8db88a405518d487dcfbb57b15519480fe8b9784952bcf44ecfe56be883e5f6e794971813b3284fa796085220fac7a51b2b5eac37c07bbab8d22d3b6dfb7193de818f6b9e2ea3b27b2b49a7d3c199df10581bee00b950e8de833ddfa321ef3870e694a9c5c877b4759793192b1506377dc4990b37220cd99ab84cd048d28d5cbeadfee0ffe348b154b0ee0b30e049afb600d22382869ce21af88d84a5170035f5a17e307ae02feba3cb4cf7659d1576aa067ae727f71030a3da06f713d89eb549cbbd6517cf9257589e481849f1d116d62a5f4d25f55b104a1ab500ad53d1029f33c83e275ef68a61f0368ea8c91fa043351a3a17f9d151f28b9df1484218d8bcb856d3f76fa5b732cd76a93adc2b3601d9209816998315c05f6950e84cfe562a1eadba4dfb46db51d60b12f4ea790c6ad8c9198f9a66dab310fcd2d46768c1de657829b1b2b7fb7996199428d9f047c8be3232a28d4137fb3276712564fd9e1414990b6300360a6afb24203db56ced219b97d6b05dcbcb62d0d28f1d0d9e7de45a063a090d48d7662ae7d3e62fc9e3ed12edaf0ca2807fcf871c39db70975f4ad0da6b2214b9a420c072bc3bdfce11d9dc4f9c09cdd51a674d43b69061fb446c6d5b6e4769c8bf83d2b7150ccc5710c47b1b4a267ffe1f831c476cecab60996df479c85e1220cfcb20220d9562179baaf6087830d177beebedc0ead8a3cb1d68d284c1e00e4260ca3fbf498e246a69b504d46543e3efaf8cb366b28f1967ac96b7f599428f0613b539e3c8744705f342baf66525b464f7504c59f00f2e053a421a1f603726145a5cb8fd9da034ed78a7dd069a1283b76cf0db05fc4263fe14882e9d8cd0e4d35ffb4deb9e753826a2361a266980e567f0b527a7473c84640191c5165623c9aea5d6224e9e4412d12fb16dcace8f14184a75d6ff2488bd16f0a5a3ed3ce21664af4a60cfb69c154c3cb39a6f307a516c977a8ee70d6d85627768d07c2d67c5eddb2a90204b963b738712e9bbccfa37109947bae562d094b5db0d2e93c47928da5b1f60b1004d7906e216b624a01ec03f56720bfae1e56bf179b8ab2d09c3c647c0fb13875ab5303f7291e441154b2c235458899bb2d347767742f82ccc0b3a3c57a4213ad5dfeffb55c6d359290460e91288c4424b532bc52f59b9fc80da95b23cdc0d32c8d71f79b36385bfb678aeb2d8ce2e84be60e1a16821d66bdeb5163fcf605a51831be07e2f64cb4cb2b94cd31ad4ce3fbd9449ce95cc21e8cd0e8d91ada1aa08d6bd92a04ad8d5a34d227909c0a8a658d14459358e38775a8e567531467c3826618983cc47ebcaa13df05716343ed1a71f66a0719199b57f74338bc4e0f6cdb5a754f2ad82c7fc0f934ee59f3fbe93f1921ccf776c192bcdccec20863adbba106daacf2ff54419616384702dc0f40a58361848946aba388bb443d66fd07578e5ab592e8a710d7cfec475d7b167e49f3dcebfeb97b945bc080459a365e16cc014e2f9f7f7a29ebb53a3a6932eca95b57f031c59c043569dd607af38f46f33274deb3d6237c65ba0c285972e26a87d1f3f9b8d836f33e5db1cddd777bfe4637f83ce5907024a3fc395293008eb9940a252525c9dfd91e99e026016daa972c34ffd21de38e5df9450078ec2c893b2e8e1333c9584f98c2db438eb6121f64dd8ef013548f3f6e2890a94043d58bd4090ab665bac4aeec00ea8d27194ca33dd36bdf04f6f0a19144f772f3581cf4b709b52a9934414f49a17b8b5761c337feba10ab3ef2b5bdef3dae05462769ca0997520e00b81e1fa7e022f0456b87010ae60457d067ae8c6fa7abcca35326f15cbf0129d657ea8df5595c54cc939bb9cd03e930bc4ecdeb301def143cd5d68e3f84528a292b657e2391e5d26e6cfc405962004f9867edbc21855e266ddcf7e44c9300a79a274562e4769c96ccb8a916dd791f6df489d39a1c8a2f20b5c3f555f6b5bffd213ed930ab1aecaae2e7cddd4b6fc44e94766376bdd1c3b3589acfa312549d8d6e390ae8d8ee50529e9290be691ca8cb8207cd40f123344c2662966ea6dfa7207e1adc54208624031ae898737ce8d70327abfabe4a905fde66bac5dec142c807fd4179ea3416c1231d8bde3ecff68fc7804cccff772ce84137d2dd03b5f6d3062a6be9b73c322727b67753cb4fe191b3d77ac4a759fded9339c3fc0ce24f24d3f3ea9d2cb5cd1021dd21e1e84842ee82d8ed2a98330cd3cfa2c937ace389b929022b5c0974916b9d5493a800c9534bbe81961a3205190956bde53361da5e4ec9e1bb1b3369c281d590ed77c0c2afe56d8bf4cc70eeff529149e3d72912d847583de29d7fa18e9c5408dcc9dc03ebd1bc43c410ebc83aac1ae65b37b4dd9ab4dc8fcb1f11e10e41636252e42e158aad0180d9817bbdebc6023d2da16be6f41fcb4fdcb7a38e0be7594b33c8d851287450efb0cf81b8995c346f1bb87b188fe195c3d1308796fdb7c550d57d8e3f0e5bea42c058fe1308cef1ab373c873ea6115278450e3c6da1f203322e6157c23a8e0d1da0a36bcf8f4f6028c6321c688b115661e72b452543d0b0cd7615ba78fb82ce841c1a251f0a62d95be63ceff95c13a11072d057dcaec9f39acfe3bd4d80c3958c0e439c9efd91e291ef84030ef5308d624fc85e7e56f09669b750abe2b85b8f2aa9ad4ba3707176eb3454eac6605fb02afc42dec25e9512c2e5b824b925e79a93033464851b23c88f3df3e49a658124d05f2feef6732c35389becd4eb724f5943f3605d2fc274e2c8c64561d066c642e3c1abd699db7f163a597a7ead9d760dd61c80e678cdbae82cf59ab7745c438fe1ddcad08da9d112aafe560a0e37c9272105108ae299c146417697cdc528b1901ab3a04eb043fb7bef92586f147f7d943537856b35f5783494db0890af09e1e8234a4fa71bc503f5453b4f4774f8297053fe3aee9d323281c9069ad1e98d600eb5f0bcac3f8bad04e8ae1e18aaf8408c83dfd62b80802ace879675c94d1948aa99ffd30802f4dfde4aeb2a0b78b535ea67fac141cbf19358b17cdf6b493371ccad800731bdbfb89ef2f81c96725308aae4d830cab71c0986ad1e46abc2da7fd71a7c191f846d03d710e43a788c50a0db86121cb7968e978ead1c74aca4c2c8cb10cd6f115f7ddae0da2e94191d45eab37add03c610d46796623c3e8315070800a0351414fa2cf4ab5f6d29075204a6d9c4d626b7d94f9e077a9856aeea2d483f323c2fde9b26631ca67060ddf1c0305b1f54d26ff066ce424d1c08a9b56d2707d572b2f4f6c3750c04a46ebca801f2b7288bcf1fb53c7301fbb00e99114ecc4e016cc214ec438915e13e85c5a4911119bd94c4663bb8ab1ecc40bd18b9e7545e6e804c9da392948d47377587fa46dd58e478625f2477846d07942b401cb81d9bfac123f6b3490954311352a04ed4bdbae8365b9bc3269d1a7f7da85db24bb9e128006137ea8da9bc3368ac4d88cb7d195437f068866d2c5a32be8ed169d98c94cfe8643b4bb998ffb89b84a6e768fd7c9c3409ffa92b125f998d55c63017aba9e7827ec29e63a55884cf216f8fc3dc774e77e94b28c100f8231c480829508d523db068fa23a826a95c97de5ebb96d0e1495736aeeb6bdda99bd69b9e69bcab57b56a99732681f138ab57188edf0055570f7912e5221321f1071112fd0b6ee57c14fb2dbe0bb8d6d3e79e3366f4f4025e3c6f85cbc2bb3ff3ecadbec564d23d7a5896736fbec6a5acbe4e01f833eaedef86cea31ef7f03e5567f447c872b5f3443ee69d50e8ee71afbe8a5e16b6f0bc91cc224d09aeadec4ab7da7063e4fc91226480597f576ce57dc08106be3c8a6cfe3dc32ff1759a8c464af1226a144bcaf7d13eb42851e2929de83acfd6e7f7913cacba47e45b78f49db70f6a2db8cbaaae4c55f97815e7e17e58dbf0a612a352c8fca1815d171f02566f6d45235c5619555cebeeb25cac65e9ba246d1573dfa7dcf4c1e131cec2d565360e85e8005c0990db0c4fe28700cf6c9a5e06718c4ba896fb8d23f40ac3c638efe4c28ee0abc79e71a463326d445a0e861c3b0455c7aac355eed5bbc8271ed7af014f274feffda521b35afa151761423d6bb235b13ca644ed7834dcb34202583933f8b0e2f2775fe67d4ba4a5cc151a7dc02b0a865eb9844ca344222f2e54bec081934f580197c6fe767f200d357b3844a7c5bd1511a22c077ac2242f469a2b30fd15ce8a90890573786ef8ae680221d2f250e1fa1b4c5aa54f793f72fd53d2423bbaaf0fbadea502a19b889fac35f1b241b71476e5e69dc2324a11ba1426716ee80d6b432a02c8713a02f564f6c6fd258733e86cf5bd8da5d08934287f54e111ba90ca0f9c3607c46f6dbc1954513496cd62eb857a782e6c27ffa81628a1f6a3c7ccc0aa559fb09f2d92d3cd7b73bebbde0bc426b6b9d4395f3ec83625100418d7a96bd6a08c58d570e1b18a8f2af801e624c4beb4e6475445d963be6a628a65830f42bb491b4aa515bc0b305dd19927899923db92b94cfa8164810de9a0da63dd9cd720ca8ab552fec5470f1807a0b3cc33673d8e3308894a3cc75b96eb92e3678b513260d3e177478d2cd489907010364666b917c2262864bbc9917311b568dad238f0515f72df84c78f4f260cf3fc827a9ec63d524f3508cd6a6c9d80e0aea2733049dc432624df013c18c0d8b8554cc0cc1b937a03c1cf945067f76e2584bc5c3145637a4799b8f13a670bb36b496f1a8ee32acac91c89c50c8b13ae889d0cebe9d642625fd123d7423d53edf413f3ffca142e30386db5be9d9f1d631c45f75fbe7f62507c0e0f7781b9c1104297e364854f7fb9a7a9ca6250ce480550f5957ff801be2503dc0f47e96325bb33f4dd4bac57d8bbe0eebbde801c083699229ef01e08a2bafdc0ccbc7b54604d892a908d683a4d852c737c5a302998002fe66abf70ab164408e4a6985b90efccb4600f0661d4998516af1082b331d47f7374c6b97fa16235da55763102dbb6949255073e5a6df653a8b7282b6e0d9f869d222bbe8daa1b2a7f0a15b774d2cf02f60cdf9d2931ca190d111b13c621042dc4139dd857cd07f44b0d416451b16c71a13fb351a333a9d02701575752f652e07bb7c511f1e6940bc146aa2ddea7011793ba143579e4f845866e582679e4036553b9d66c0164c0e6442c09701309cbf1a8ee1cf5945b0427cfbaa0b76fc7ce0687c3d1d68c4863a311aaf92d8cd3a397cef657507334890b1e432e1a14a1ced2e8e9474bee4f43c4bca238c13eb0e7c452d947634773010ba1b792768a232088f72a3ac714a4b66de6e63990d1ec2f7beca83254e722fcd75d2c7f56b199571b2a08228c62c62e47848f059cb948247280d854261ae9b49fa83e9b4bb628f641d9b1a2bb3d303f4515f3223e8dff21b9e58005b13a96d41a58e969379a9980d547f953c25c52ef1baee5648260ed733be4fb2312b6520f18a2df0bfd55646ad34b1877132632921a08be5583e0358c1d99054c2f310e8254cb43875d470e4517f15e40b6aa7c1aeb7eb1b79eb450c834a6c870ae4459ea3ed518353b46dfa3be4c927d295f91a736c2587682e262419e550142c70eaf6dec46fd1f6a3e51500503113014edbdc0d6ea7b0877f65fbe3749ffa604f647698f4f8027cd962169cf7eb47de37d73a147b7493d25605cbf8a1e16e9f2b19f66761022e0932247b5a6f80e49a7b5e3831667740815808128827b1af07383eb81ad0bc39b8049ad3655187b64afa3da6aaa6de74c6b013fcf0da048a4cd8ccbc12aedf7f4da110324cfa4fd97946dada5962fa35e80920a816647270169682b7c2e1e82af7b15ad3e628eb8eda23c45743289e56b7b5c05de1fbf4df51263f12231e4921e1c1cc809fe5231b32a7e81c1bf4b5c72ee40e485a43524f7ea449721b097bd2268f7107a7f3feac7acb4c8f0f4ec7b64b3db4f8982f02ea41dea33baaf827c3589ca23fcda3ef74a48e210006ab93b9a862f0591df822a6d521b2ceb0d9298afe525b069e9dfd7cd7bc4d41e0433330102b3c811519c3ac98232a1aaab2085b26444c24aa301699d66bc06e702e404c5fd4bd8abdbf2f2a0060bbace32b3eccf751c63db25dd2d250fbda90e34c3a2d089b22c22a3122775e44035ec9f6c6528d798eab2937634ee802b9662eddcf67bbd49989ab95b0e95a8ede319b8951758bff743eea57e5c289062c91256281084a0c160517b7d6c6f53dcb4e38c90030cfde7968b18f6dee47f7acc11c6aa029db8f30c40927b3b2d2e68e1046bba00ed2071cc40033c224c3a91f853d65a0ec23936eae801705fcd9e0a5a8d387410f4d192e647f5f29f70c8abeff444062fbac7190f48733460d4e2df8da9f6d360d30a7db4c496ea8943841d852d58d36e34bf7a7d80548195cb2e3a793fedb0741076eba493fee3ca5ecf7541545518e1b780c5bb70d81f440bb1ba33d098987060640612abbc030340bafb1e959ffd8b254055ba1a8988bcfe346b04c62f4b36a654f25e176915a536938a5cd37828c7d6bd6933e0b3fba7248fd270f80a9b734cec211145cdfa788107524f2224e49699cd2e5f105d1bda7f591f9ce2791661933e96aefe1fffe1d6c8d6198bc85abd8ee6827a863ae4a41477ea5d0d556d4f14b10f3e873b28e64509e021bff67e3516fa9f5483feb40b780fc9c36e567b0b4ce80ab412ea4717a9ecdb6bbc1d0e39f62f9ffe0833657cd0e69791b0e909c3a3b4dc152443dbd4d9114a0d7929e5154096c9ffca4b230568a16aa54cc1ba9472f61988bf75427a772c0bb72ab453f2e44d425ce409737c8cad038f68316905c4a50eb4a4528a0679deab5998b0f77cba3bd05157121e45905d680001885bb9726b1e6ff17315fa7e8baf6a81a63b753888fa64305106b7b2fce16304a7bddfb4259b23f656178bfb6d71be90fbbc339147733855fcc2b513c5a7e0817868c13d7311f945690df027232531a2d7186ff448c0d24dc3900ff2472b41c0d35a8a3cbe715d27352f4fd4925fc7639b4f053192a9114162b55e226cce896e96fba3e3363efb7d7577d402d00cce759f2e3fc2c1b0c798de91a9fe5da7f0bc549a499325242369f2b3c83751f02197950bd2ef71b3db369d81cf455fe42c97bbcad80a39093f8f089642f10b0ee317bc41cc726e4a60a4f31b4111e440af8e430417f0ba322751241ff12a9919be3b655c3eb140309ac3859750dbc69dc733c83eb84f19566507f351ec3312316e5169a29148568eeca024af805edcd0350b279341902670e0d222cac158b7aa223635b17d737ec985c2b07cc11ffb30c9f4928aab1284cdcb0645e0a2ee1a6c7729b1da8d0dfd6eecad9ec3f097e63148c3c3f2c3a6adde21beb1a93e198dff77abd6ed38877f3f8417bdaf31bc6958c6b762002c9790667b44f7142542e1d807c67bfca668aa3ffd955e72f1630d07cb7774a00176d3ae2f466a7a3fe1e40c9220f4f176d7c2b1984804791de442686a43f1bcbe8727cc24c4e4105c297b569e05b71a1c151d31fa2b6e13e83b6e389ae48edc196d6a702c14ab1ff84136c3e1721e96d377015db41850383aeafb8db506d2f714d1726c20818a93b7713ec524429aed849e6055e011c92a3591fd02e1efe1abdd58a21b1227ad4aa3dcc00ce07622e7c278a3b9dc6dbac77d1da3edf4046def322321e6caed902b4740464968facdd37f1a851b40495e99a6b8400b61b125ecbfc2ee3cbd35237c1a9ff3fc869a68601d9cbfa82bf5973c37dd3e7f44e45a90e77be8f3dfb85ab213a5f324880e55954c0dce513a6c48c8c57786f8675e07803f05964ffc26a99956d0567f5ae3d4d2afba496e9d994cbec5852141bb8f384ebb72dcc3aa1b0422b9ccfd1c04adea816b07b2fbdaad9f9c17319ee41aa2afedc77a64301f34e39dc46f22be3145ebb6ff95d73d71c9cb7e45755332ef788b8d01e9d1b165db46231cb9689e2dd2a5f257312f2613f989d1fe769081129d6a485d5fb58d4ead54f3cd3a691aa52a794fc5a90ecbee8c4ea17923c5c2553ddf04ddc5f460b209319491570f5d44c085f84c3f57f8fd1d707ba6f05ff82bae7ae0a3f07181cd0f0467c6219e18ec7266b7947e4ab30db12052ff0b5854beb0bd824e38ab049be6c76a7557a983b34ab9e441ce78ba2bc1e391f40af8e3341e97fa45eee088bda7409a9032c3967d586b8c948c1c1ed5267ab40fbb4d443aee77751c9bb52a4a8f25d82f88415befea98c5062ca467af82db1cd903b7766f1bcc6a18c8a2046cd89c9491d2051d37e436ab03e10a6efb78414980641cfd2ea00e00cf8994e0787668248f1ceff3413aecb5f874847d90a9f79e0a86bb2bd93154b61c7f9a79f01dec7aac65a46b28c30cf81c084eaedae651c59806725cd70b1754431c71d149238ace035ac998c8bdca5e8da7ce86e87b1e5012b0a1a6f0859880f5055a93909e7a6ca4127ddcd97fbc352001117741aa56bdd4cba7db6fd1ce20747506ee61e66deb559a59f450ef99566737393a56d727233b2cf8504d717238040edd017855b2c37321e6c561e6ce6802ac79737f9c09d90334cde9f24df1097cabed33103ecbdaa7c569139fd82ab6e632d0e22bdde29de7ba4158c2b694b033eeccd2e4c25359eb64acf39726c9e0bf61b0560b821300d3edd2086b88418535b17991abee917668649b77a9ccfb3aa25ca74147177c0ba58470ed7b90b9a940fe6045ad09bd59de96b4dfcc63958461ecbc2bf8b2f5dd8270fbc1c7e47e1a96aa73c5442d49da32688e87cac62ac7b8a5416ee9555f1540a7b0748f5656997bc75a9e9fd409aa4b2a789a2cfba1967966b884a1ff5a6059baf908dbaeae7398d10df3bc2eb1107eddfe4f304225b30d1df47ea07f0c59335d2f8e782db842fd4632c985b75758e3975e2f946b4711ed03812b086e7db50efb9e6cacb6e7c55beaab85cc5aa759ec85f64e5f78aec76e3cc88b6eb4b9d0cb052d0e605b8f1f3f8b66bee918f4363354b639404986a8a538ad7adb9c390c06b75b1c290dcafddf4fb12fb6f2d9faa08d6ec4fc3f03436076dc06c78532afd2e9e8f838a772a800bd5b5fd26fb1131e8ca741d9514c069183cd1ea6f2f3da1467f9ed80d784da82e6c610dbafbf7ff18ce24227db8416e5c5388df534f3c4793f3c9791f04cb0a756fadfe579ef1734eb7802c49d142b406159a9ef04d63fd7a1652fe3e06ed6eae03c6103d15a24b642d20a9b75f9f52a3dd107e9604e1052cd6fa72b2bf262486bd3ea1ab2ee86ffcfac0851ec741ab2980776d3d039e9d970cd07098dc3d762d315fa67cbadc5392a6f3e5f0f149bc75b445ed40dd0da1ca167866e5c83890f210c7c5a17b48ffaeeb5b28234eb3c0056d137409f375eef848bdffbf3e6d41c6798797b0f538e04a02b8ce81c6e408a5ecda192f7dcb29a2fbab85ba307a1089a1dd08621cddeccdc9db8b9f13e2a5e6fe5a8a6524db830ac258d944c6e6cf233a1a578fc85d90d179f43dd69bb5fd665596c443ce7b98d5871c277597476014b9825ef4883f8a51a57b28001340b22215f96834e80743d28c50d851e993bfad4706707a565c7c66a07423b416c56d8aa75ab3751027562efabf941ef017893f5b900f1a025dbee8f8dc97e094d5099bfa2c3c030d39f4e0b6f434a54541fdcbd6c7491a88c61e877708ac27414d21da75fa985b7c6b76b86295c48908db5a9eb02b74f518d49218e6af7408234b405ce7e8c473279a96539a09489ad1f61fbb863e4ffcdfe451496eed270c79f504190378ec312b2dd9a0f770487a46ea0ec42c60786ac6db2504fe53b6a34076814ed7b2b7fbed80d0d8729ea0c9d663deb8658d575bb590deb4de42471a469ade254251d4962427943878b88034ca8e46cc3d3e8ac3682d1903e380a9c2f6632e7ceaab4988db1e59f525eb141f79e73f53a869bbc8185815b57036232098a89d5170a98c5dee113083c05205356fc3b229c14526f90855043f29d5cffdafa26f4f5912a4d8030d4f65f9f1be9f88c0b3c609a196e5c21c016b1d7b53093cdc1165be9b185a77b44879fe1d45c1b2d262dbaa652a3af7bc1bb1c316b19da58a279c49287132def9ef02690b8f9ef1622c8c2094e23510cbe77ceb816ceb13bfaec69776296e780eef3f52ad4b94332cba9ed304db92ee1225b5d4543c92a94084fc9d73430aa3ad0780b61b96f05678b198cc295f3fbd4e06bdb68c87185c74c81c44b3f1834b13926769a771bbd33c750feb0575ae347a56f12dd59544cef04ccb61167cc7c3e299454eeb358114b2e4ac9d40fa4cd590c3f1493d4952703e111c7410b22a182fda82a0748dacb8c63808872cd0d22b731a5847d1e2936d77f4d660d6749a32dd509fceaf27e438b7bae895daedd6f88f93d914bdbf642a0f2cbde0ff19a0b1ff0bf1591b69180087a1f768c2dd57416165ccc2838c110a3e3a0077b718bc13559241ba8d2e644bd5b07989ff0d080abff20238ad029c340038b2e8fc0a77c8a62b1cef7c55aeb7070b0c14725547a2ae84bffb0ded42fc2bd128f4b43e9fc3be5e6ca3972cb52a1074783baebde5a828d1743f65ca4b930f4fdc988f20cbac39ed3d7f3755041606706082086115b396a5477a6c13bd76b4798891f1284a96a0a75490c82bb22e27e528fc6f50037ad2d2f60c063e1b03384fc4c69fdc4426f5a95f9f210b6ede2a61d15226c9b55e6780b6a15360ee84481e40f7070f61c4fb958814382998c364d73d037d188b56550e8c809ab4d9ca6604aa7958c19c371ecedeec0720b0db866fce1dec54d9421c3cf4ba5831c17a3447a9c0d27a96966820f7afe2e1870087415aebe54204013d8ca9b3ef80d8cf923ebfdca191b5e40ece40aeabbb72810714a0b6d128d7e4973511496940798826db7d95c46be7e3fba06f86f9d12a613e28e8d77a22ec111a9a7855d7a6057d5764146dc73be220800aed9f5af5c0d1d6f34b2f78616dbd85b7eb23d8216f0037627aa545dfd5c50a90d416a44d57a97dc99f105fbe0bd9d8214f6b83523f195f5fc8fcb1aa249fd20952ad6a5e3343d42e1dc8398723844c7884048844dbb3dc7c4609a548cf2c9142bc011c199cff1e22c2deab4552d345d5c9691214cebb0697173aa080a7ba8521ba4117015db2a67ffd679d93a6f0116fa8acdc58b94e2d3b79419e7f2935d50c9f4d21196b24cda6c77f041ee43912f9863a3abcd176c598d65c20e6d85cd2af3cc503389c10c90cde82377efe716bb56e540e2c9d0b70678ddfc62501f00e8f10c135ab2a1ed01e8164870dc1be33a1f9c0609f729455d088c564974f4133ff4fad1fb52988f009cb455238dacd430179061087683336acfa3b84e2679505058c9e781e558ab7c6035340dc60b112e58fbba5c334df117b28f64e4e06415b7b05630e8858984bcc347a8bd924f228d0c1f7d1707e189427d15ae6673681c461f345017060c114a02e2961deb70855005f447ea61db3cf19a48aa76a55cdddeb4ed6e29d462e44c27dd205a5fb9e6096e1ebe0dca65ef2e92bc9558825f68bb4906251f0e0e43fc579ac0a270db0c2e5a85739a5709a344face58b0e002b06a15eb20faef0df7d67d886542d2b14fec458d39eb240c25bbcbfca2dc4658f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
