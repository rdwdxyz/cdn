<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3f9848c0ed2112adac1a3c82b3356933eaca660150007fbb3c8fe3c69a1f81094834ac3cd601faa36749f263f9ce46d6c6be330646e6a7d4d6abc1f6679874d51ef3fc2ae8a545820d2480fb14a182da2c4ccf069df387b7ce7e4df63600b13eb6466bb8a49deaafde0543912c841ca03fda05f493c303aff80a0ea2d3b2a35240af25efb145717fb9e8293bcbcb55b292cb53c180aeb6380f3d051ce713769b9fd4f3759cc82955e88defe6bcaebde7a4c692b37ee2c43c581b3080804d39d6e32bb3cd4c4775bc9293cb1b1bdfdb9aa7282c495702878be9a1f4f390154f3651f576525bfc06a683efceafc4bfd8b039b5598a9a9f27c8bd0a7fb411c9ac462f4be8530a4e3bbbd7313b129acf55721bbc524adeae4f32ab621a1d1923bbae4d5cad55a423ba3a817615eb63ffc853613948a46919c044274a88591e883fc8a6222b12a2786b63fb74057879ffcc0c30fd417a66d1223069352230854447d33da5b78f77cf4643044615554c61abe9c8c4cdfea8f92e610dd0cc99a8747af5985bad56a96b5f29ad8c12ea78f0cc9210d20b28adf9c86f588ceccd12fb84ed20b5f33510dc6eb907f7ab5114d234c8c39de798c305c907c6b5b2ddb77643090a3672d9c1f8e7f71b5c96ceaad0c14172d1582188c5ebffa1900b0aefdb8f0c94583d59fe43a9148bc30eca33986a99e1f7d185896d3f202d92675bb1518b849a5f1efa673c581f1d1c5e4c332ca03320daa8f215701ad0a2c6c861ccc6b7775c2c488505351a56402a5aed372faa6246351f345e9a0dab7d2e3b353cd8babd04c3be3398740a7457f5cc677747ffe2409631092b3b44b3141a01a0a016ea0fefbebad74c12868e67f3a434101e19cba729b36b8b986751a7ec2eda1d821969e165099655b337d3cc7ed3a76e02eb25c5bcc2777d7fa460dfab151e4bcc463cd028464abcf5217f4b3aa15f1935c255ea6458d4d686fe9f618fabed72961dcf743456db2eebb8628779fbb9f2b80bb5ed67faa63d0593cda16f68d6ee65feee006b2ef6bfcc6e3054e5457a826a7bf2618e797b06c3d2f3b35c88653e531f9cbbd4c1176a000259a1ee709c6315c08c9964eeca82ecbc2c14145555d8c49d99f2c9712d2fd882bec2ec860df9bad625b024357e954cb868b4c8578ff5cf49e8142566e9e9d5ac75fe357008c84abe9ca4441865e3582ba2e6ee6a3c9b47a3497306aa68f3a8230802fbb57cf89c0f2ae6a4ae994cf1f6c9377967f19bd741249a3670f6675a8e8883d3250dc29c186c880ce52c221a20f927fdba71c443547d80458aa152e5c928c8c9f3e11678cd40599876929f2a893af67946b501ce10e79f1b01903771fee664166b2c2cb8a92ae649d92a539909e767d46444a7ed86e3ea3fdfc35dee0c893d04a8624060b75a92fc1eff4b823a71deee27e451cb6dddc457ec9497f770fcae8f600da78c2a6250a5f8480730b833272a092f3ab32610a37822a57ab73b42d52b07a7ef24d3c09d8a572a688301184d7022b0437bb025eaa26fa8a6dde9bbd1b59a7370ef6976d8af6b887270d27a9adb8ca9e8a58dfec8a6455a1d50d2e1e9ecf9ab08bbd07d75842d097099aea059e31e1e4f39c26a2c33f80f9ec15b9f5671cfaf2abd2ea681872099808c0fab007cf634252af6a68ca04b666286c87623159e299f4750b3441f94517bb78ddd407c871e2c5670b16147001ee54fc66347fb405616a13d09129cc8e6a9c3335a8e07405e9f2699bdbd20ad6eb5438c7a2c42ed5b391e1dd7a0f5dbde421e616111d971b15df8a5ca02728dc8b36a780a13e2ef01bf92d7b27acd25a74c2624ada81573232c63fea48e71e9de34bc1e00f43ad9ade78071738f0e14c7c9c4487bf7949a1620f28218f67507854c3781dfa68f50c40c57113266e9a1da41af7bdb3f4641d6d315845c215924ea90e9757325c4e59be2f0480482835bc9f65dd02460757f510e4a4db18b1888b3050929fdf93e0f7d7bdf7202f2854d5dfbbf8fa9668127e6ed119819b6e942b791d7defd4d9bdea2cd1c6ef097996d0e2982029805c7f2af320f2d5db3d12525181514e2fff7ba406d53c61a576c1c81c5640874b3118c904c6cc817ce36f6caea752cf8868002596d032c54b19ae2f7f34a142a4a07dcc8ce13bd28e490baaf4ec6b7ff802d5ef13cb20764b8c38093c3a01e62cb1e5a9f0b64835672a00302bab2e58f18e1bf782f5204faa083ce0cfdba4b9f404fb19aa69156d325ca905a666cc3e9847287b434f0a5b5d0b7b0e3977cacad5d17b31ac58ead21e287b4a0a03def4034096c9b0f2cbb679de45f462e266474ab3c435a11427fe32384358d5fa667f8f797b148d99b4b2f06790b81b1988d876b3d7b1a8de691e2c3f0622fdaeaee15119a64ec743b8fd0137e207e59cbfcf47c7b7e64f225b08c799186bbcc827df07c555f2de48f9a16ed527f8a973301157db7b24dab2a95aa7b486127dd9cd3ab26076d3cfc28c3c244f11c088adf47329d65e6ed47b4030584474e515b8e4e716bfbd10ce602f29298d27cf21965f5ae38d1605d6354690229e460e6de784f6d035f29e5da63295ca8180c86e16c4ae8364ce1c5c724b04fbe4af80b1e7199b8479f25b0f83a40d8e80a86222f4a93969cd526b6a2c167fa6596f5f52bd9076093f4823439a36d32532285feef1d5153d271550a5812d95740eb77c5c9ac7b0951fd404ea134301dbb9147cd036a3bf3539a234e2fb826abfa4219957ec20045e680d8f167804a0b3b0728aff6a7822643343a93e0925e3a6a08a813ece6faf64323603ff9dab3b3183efacc1108be1c7ac4897215d8bfc756f0703688e94a1a8b0dc5ef5518f8b67059398c63b883959aacf9ae2ec48ea5bfb59c9cd4ee4229168a55ade4f999f45abb95b4fee1bdf7136fdc582dfd69bdf4ca7a470e9f9909d0d763a714e86742fc1e508796a3dd480a847e840a0dfdcfc6de127d0280c3d45a8f563c0a90cc5b064aae0f440efd78b704b5e2b6ff25c0ca431eb7bdac6463e38dca1c652e8e4ee3a89f8dd137b5c155fc0cf3adb4be41c9a5324e7a1143356046006990643cd255f81308cf690996922ffed44f9be225af23c5776812676aeeef4b187d12344a9b730b04147d5c10dfbe28fbd554754b84c4c14908e024c2c3e10931e0de3e9dde7f281a5f34d02130a6d16d299178b67f00c63ec305faf11fc8087b18352d091f29d4e86125fb33ab71d198cd3c329ad92d1ddab9ffe0f4069acaee8c4f73183eaac06443b37edbc11a188f82ff4a93d764713029b3048d7864a21cf6bd401b88afbfd01203661e1d4ab764884c10f3fa18fdd06ecba4b3d59d937bde1e0727599655efba045bb7f42c8c46d4f7bb7469525a3fb89d8db1cd8da3b449768b1181d182415e30fb40aed381be1ebdc50a29be9e5dc7452ddfa3b9d2d3e80c06a92acfe08f482d9de23a05a8dadbfa5f5e6b794e23da74d39da01e6792da35dcdbc9317632f78a047066b42e9b1041c2f390a3ac187781993cb500ad6491ca18ae45db66944049db0cba19ea294d2fd8972ae5562f523c469dd8e461c686ab66f3de5217195f97134d850a8da1541ae4700cfec1836dce411c98bdff1f92080c1c05fb1fbe41bbde8f3db931add766163f3b31b56cea6acc0050bab7474ab798aac8c6a1d518fda17922759d508f7c26e7ca41554fa1265ddc10eaaf2953ee3bc1799ef6c87b7e6d1ddc9499d86451e590064b86ce0faadf6505774bbcfef95bd7d9284dd842e05adc36c6cfc6ebdea2e16e0612be737ff0a4946388edc2f20ec27beb1745b7105f3992c62bfc660e0f590339e275af5df178cff174b1ca1deed5cbe5d8374af2787d1b46705cd1d640b2e4d2f9cc5942ebeb0d370b86e24dc3d8e28bfe4ec02706684fcf8bf50296a11163e5c30fe50a758a782a7d7d57f04450d4e686302bc1c41a58b9d812b5bd4e30f2e139855fcfe7860bd887e72b82e9f1abef06efc0815b96c49c032d56fd118fb386306c65b00d896390245241067c56e2fd7d5635d2483328aa4212d46336dfef8ae887815e2a45a50cf8f41775bea53d0870f097025c6b35f6e24b9d708f1e9854822291149413acbe593a0a780914ff8b8078b50f2fab4ddac02f5bc297c797e75e819f62a84afdd128ddf864e79521247a741f40384765d36512331aefcc25c0016f929d7d7ed8de4fffe16247866abbc90de3b177fe68780ba68e9853b52bab35e9a339e806224a3f39c18f5829d17b54fde16acd3b01ca3b6a424055716b78bb03298d5e647a070ea8e5ea81cd2700632d9521f489f243c58ef65352167acad908621a6de1a5bfec4eb1f1a444829df099d9b022613ad00c0e839fc45fe3118c64d6696f3959f5cce0706cc8d34ecdbe1b8109d96771212637a7b08b65036af98ed4617f3b9c963f27cb11ba9d727647b494104f41310cfa0640a5701b17eeee240300789e446c0fd46783c2404444181562faf7377e6875d1e9ee4e9b3aeefc65d3b28210039d0bb400b22dd2b7185ef9ddd53aedf407d3296159d4e8b26bd3be052b53f88ac8e8ccd756ee7e9b461a4f81c85d25c364a6497e836c89530be3d53d279d8256a26a044afe5245bd0bffb5811265b0fecd1589094b1d9e7b85a29668d82bf91c6b3b59abe7afe0828e925723ef91e5f4619788e130422831e9a8ddb5b55a9d114134d005f0726d0ae1e707e18b785771e483131264f28a18451d7897984fd53d1566d1e3e450dd504cbc6c40879f38bd223bd495d04044ef0c3e9562ba9885058647790645b0c49e481af1d23c39dd40d4f51475bf99edc01240329e8c02993a4c89b18c03a8434d8ec6aee4ae7011d3cc508edb9f26af0a72dd38a2b5ba07cbc10f2d809193c3a92c1faf5ba49dfdf8b42daf2af18d6ee6fe7ca4868f94598ab34c09e78f21d435173a42f08d66882314a7198002aecd0c1b276c82f715c4883c3828be9c4c01476b2e833c92e23bbde913371a9d1bb0dbf1f82f4d47c8a130357ae301e1f5c994e83fa79e47eba78f2c5ded22e88facd574515a201bdb28b1d925b3e0b75bf4dcab47710bf3b4f01231eae99cbbf7ffd2bf9470ba83bb9a168566f3f8541df97901d9140e9dba021c24cc38269ccc0dc2cb71b5c2f7f67648ce02794a39a7d37508d5c8adbcb3744de262d10b6b7c53354609b9166da4333bd30833eb9b8e4082bad2fd4fa30dd0ab383e9704073af9d0db53da27248320ab0549eca3bbf8f72e93e024c32106d9ccc27a91e88f3267e5ed6ed25c6348cba52bd2a48932f49a3ad57f61e5da06bc204edffae865ff922ab672f592929266c55330b59d745a11731e7a65477fcb42c79590ece2a7bf479cfbd8b0f8c50318e62beef00d138f9e50cd01e71ef3468e238b25da630bb224730f64c18216ebae6e81f12ff41b3dde569a1cccb219f2cd73e146f54c72aeb446f53ab89e240a8f2e0d8f45e1824c96c0c19227b7fc400e9a5557e4a8baba0123875b8781b1219f505eabe7624f34acb85b233ed9de0eb832ab4f608f4d50b21f04439c800148d290503fe000c74b3ffdda22565a962b0cbb5c24af5ab0933a141dde234248f6327f945a9ef62b69cdd9a85588aaba0e3e58739c9f29a93cc165432f9ed9a21ebddd3ac1c15b7e649f7608ad02a2ac3840c59e809cbc2f5768d630477cf7fc0f1063cbdb9b8237e538d2a508be9c4da676f8580bdd431b1dcd4f302032ebbf7b96ca07e9795db7ece3f96b3d5e3dc3714707fff982da938bd385ef896c4af0287c26d40c81b7b6c991400bf1454047df46a199857f5a1e7d4631b8fd319c5213cf5adf54b9937127da2d703fe3708cea176bcc51ca7ea428a183172a86d344a40c70f95f81240598d3f4b7022fa941ef42d46dec26a07ce1425ff4b814ba680b61c02d74cbc28655beca7477abbbbff53ac95ba606de2b9673507a886457e0f15e3495f0acedbb5da5bc8797c1de5ee129d85494ebbbd53582958b0738bf2e11c61d9a55f4dc75044c402e8dc6c3b4529c4e9181c97aa97258b466b42e160a9c8f12ef82d9dc7ef213376c1f08aeb8606db34b90b03b353fd856738863944abaa16f58adabbcf29430ff895070baa41cdec7171d540561bccadb1b11e1a58086ee29003acc964ed140cb7b27374bb6b49dad09c2641cfa319f623defc81542cd0c20278affa7d500c87fc12bf246b9f5014fadaf24a63da5931590a2d1e4e92ceb5b8fb3798329249dba164e2aa38bbdae1ac1489ec2235542a2094068bc898c5865321413561ef84cfb425fb94cddbf5cd90eda191cfa5797060abf42fb36e00ab4ede832a6e90ceccd0e3e12a797b8e50609e1dae46fc05afcbe7cc7335a0daaac91d55c38b11b3174cd2a3a10b4e48323bc4bdbd1e6120e57472cb48f97ec3b429fd98494a2413766f61082fcfafba8c654f1152550f72790fa7ac3acc9a86b31c990ed69d42f11b41ea596fde9cb7d1dc7ca409f6d09c34f67294250731abb061500b150a2e725dcb960859f0e2f736094f710332825369f89049f9e1e1461b8bb9a5f9eaae3571eb0c1fb3079b027d6e66f71392b7845d9271240c233351d6319f7cf66ff5c637bdf0cc286bf290a5cdfcb82b3593dc18263f95c894ba91dd40b1a3718fe6615ff24bd8f86cb4cd531d6b5d4f0019e00e1d09ec0c59131042d8214aec0edbf255f58bfd8fba63827e4fa37cd509ce263ffd317bc10d72c4b877faf7d6754705eb2e5b45f525039982038887c31a9cf43f49d990670b7ee760ae509f7f81026f5420302acffdaa9cd89f65d4024249ad55e0eed0b0a0d62c446a1aa492e8b890a372cba5ef7b3f0d99ce896fa9dd3da0329d4ebc4ff1ebe52641ad7418cb16b13cf469a1d8d2490695729cac621b60a7c17778613affe67242a85a1b9f2e2738df318cdc9e7355a5e717e8dd18524768c9b285e5a6585ce838c2ef068d20cf41d23a85531b3f070aefec8b1854794c4a0b649bd79d19a499689c208afb6bae2911b0b0afa525a75140438612db4a3d16b7e67a207ee50735091d64f9d6d06bb7c83128c3b49c7b23c6e31709a312ae1dde61a6d087e4e363de6229a6b7abd25c46ab3eaf5fc80cc05e78aaf19c5f3e51417000212540b3f18b633d451fc4d6bd94f8606f77bc17f51d9505702944cab22df9ff008958498196ef6fb7f43997f54221061ce1dc68a0c7d9c4b0e7fb2ca3cac8d8f493106f6005e87de7fc0805e2b71a5eaf83399473e06be42dc84fb2bf7dc7309e2599934ced54fb124d516980644438aa15101123d6f1a1d5bf2b69e20d68e8f630ffa5355ccbb7e3ecfb57edb7ddecb87e3462a3b3e5e19cc993ac180f52e1dd1c39e13714c8424dc704665e79dda79ce9e09cae65fcd0ebc242209fcac0aedbaa7e02f0bb2920cf09093192711c79eec3800b01f3d37835ec1fd0583855af979e247b821b9af501312e73e3f7f6aa371b048c83554aa3e944bdb5a88608a105b11c5fd358f5866b4cbb8ba29cf051c1dbc31ca4ddcecf25d33a933df5551ad76ce6e7d93443fff0cc55772c3050462bd31440254923137835e2b339607a527013b2cd46c08783bd2209797263a0fdaf96f2d37cece5f1fb4e8e9634bfd897c0ac5cf99cd65396a0f508f3ae8cbf329cf9a6c98dde8b446bdb890de718b1d2e479cf5df5fa8b1207e4b7d990e695a2b9e9f258876733efe6519d131909223d7ffc8ebeb3998cbcb2c52b483e721cf86e17aeb19c6367a76e704d36d73bf3e7124d630c3f46f94dc16f806bc0f253376c4c78504ad5ae7664c71acdab41f6fe2fe7a8cd6db7ae2220a03f87327e099a514f5c9e24cda26b1defc5e1c1b6010adf5ce898315427d7eaacf2d8b956dd595523f79c858f4f946f0db538ecb5afc7c5090678000c8ed7a3ab4c317699d7470ff4fe110b0bc935a4bddcba2d7bff201c1569080e1aeae0e85877f6c83f09dbd3ecb89aee04c084041b16353ae2598125ed35740a035eb2aae61fc917fa99fd648aae6b7a17f50956d140aa598f9654eee8d2f6f944a441dab67614540cf2a84f691054fca65d5640e379b7d43768f8f3f8423c4c71668292e62a5cdd5107e68f1125ae0bce290aea413d4498a503669e61826c27cd233d11f22359531e81197ca70276ce2ce17a8bca3071307566a9faf3e6791786d810a162cad8bf87734460c6d596f1db0c9a310626e5876d51d6b890f97f6b248312d53f659baa9f8d7109099935e5843146c714b07aa65fcf8b0519bcd66fe00fadcd6b2e38beb7387cb1178102b331a1dc095417d9f0015664f83d17ab4f4f76f865b2c49118f7a5de968b07c3075bfef2615b857fa344bba9402a1ff49110b82f7182e8bd0035d53d3f55d421fa083e878fca283b20ce000a8aaca4b101962d5c3852f3fa18c03f880c3df157f45d0cda395264553038a98926042963613c07bd8847280d613099d7eef5cf71e595da229e510fcbd35bf22c38bb9cc23523ad556d065465cc72b8a0bba0f36c2159a6b83764a6418b86f4bbda5ec5c0b8dd9dee18b52cdbd9c5c7b007ab8c21e9214875aeb600b97b3bc112bde31131b06a4d5d72013495ef997928c48abb2478f849e5ab32ac92d0a731f7ac94cb72adc64b4606cbce7bd32053cc7066fa43ecbab5f7bcff6f68773340b7f74d4ca278d0ef10866b7c3b42fefd3ade2098efd4cb04154b9a4b2a2e916a2f82f2a0bc053ffe368b7dfcd89e53a92ade851402f8df56b9201897de58e9a35d92c72242850f8c2d45f4b31500591fd2fe50e24c28a9541f0cb0e669f1a3c14516bb3ebb0284c5d0e29f82b44e48081839f8ae1f9a90a23cd0057611a5480ccf488d58d86f641875f2de9082a92bc1b67a69a3458e10a09262a727e257029f0da47307b18456917b01acd38cc42fd5386250d31d3216c32f4c88b4b398fbccd87fc9aadce9dd6c1b0a66eeb79daccc07c66f667b0549d597793b9418c1cef5d0e0a1358b43d4f34fcd901ddd3bca6cfe1d859496c798d8ef0f4cb04831b9810a1a82a3b1c7b0464910ff50e47d240b31956582f2a4d64761b20cd58e8d6a74a86997cd30bd3aa3ff5b0bdae7ac6b11e56f19e4903b73665128efb13759d68faf26e740f40d07ca986c12099ae4ab0924c85f5ab6ab35d113b4b2bdff537fb335aef0b712fe5ff27382b4fdc84169d3a99f7cf6b996b996a7b4ddc54c36d18b1d3e3e8ce4882c21eb0a8bd273db72446a69e876377ab2661c53d8303163ad14480c02f784e7bcb06afa0e8197cb910b70f772afdea456b4aeb3cc69fab4fc48210cdefcff54fe811b8604c939ad8d2857e137c04ee7aed295d8fa0e9944fe3f4d480e38bfb69e3f42553e2202078c8b5076a4cd91b66c6224a6ad5a36c13a7c97627eea83ab29acbd1c24ccfd6f2bab7fc3187e0224d38feb2e2f6662391de068fd3e8b290d415384006b0b362c2a307ba679b57f75e841598d46e4e69bfa2aa6bf9383bb96a53e51d7cd205aa7ccde070ec5e74a964293bd2233c6d561878664e7e3d2186b57725099a2a3dbb48cf767c065126ad59681e527277c5e66a5b8fe48ed69b3a54696cc845e01116632be8500da70a620e30fee5eab1b993a5ebfd74efc6f5e948dd999402166b5c10b9558136c82c977c49bda405c813a5defba048599174c91448cdc8eede45f58ecf0ccc89624a101ddeba7c723f35b4dfd6e830356a43c12401eb0455544dcbeef13b5e04e2ab40e922848fcaab239887828980d3d4c2ac82da906b6cc958b3824cfa1c73604f682c92076d058c4b7f452b9155cf9e52bea0c20f726b1a25e8a9175389be68fd7bc56cfebc30d56540755c01d542d9940ebbd502fc3b303d85f5227d718cea5da7fd154347a8ef80ea54da0be94d0d0e59b5408e76e9af7fd53cc707a9539db50959fb507ab3d35d014afaf4fed1946095e0524f1e38f06535c25ed9972cf9672e195ef03a934f0a2d62079ebbaeda4519d6d6ae41d340586e96633d6a1e6fb6c51294de977055a25f93bbbe6c2bf7f5204231dd0d60c9c0d783c9355e96b357bf575e8ee5787f02a255ddcab48dc0f38cf2d315bdc8b86d4a82e2e226a173df34720c2108cedba24a333d96e68ca0828e3ea7fa14d1f85c3d80bf9dc6fcfe0b12fbcca107e4aad6bffced24b2513516bc5e860d1f27f43317c3d2b3169b4d52a3fdcff21b30e41d507999584164acff873e5e67a30cbdb323da469c63722b9525d3dca857bae862ce36801f69ace3e0128f55a9e4330a03409ba7bcc63ef96f44bdc23d8913f4211086d447411a5dc0f7cdd62e34f9c7a215b08ce6d2018b647d21a59b7c20e0987a8dfac585b3d77bdb78a3e83ef3677c5594c0c801caf39e86dda2dba2035617e07e3f59ed786c02f037f588b012d566973fafdde6b78909e75888f54710d9c3e878bc95b37b8d4deb862a27e7b24fca3aba3ffd11f27d74b5e08d99bea4415796b46c2b71f45124e9d7227115968ea9b2a39a02142616e8d95c46d6d8aa41611fa320b0ad709dcc1cd6ab72df2d5761ab0d871ac6e47679a33a2b68201ed1305af3d328745ff28f6757bbfba1a5450e8ae25223490ab3b5d92448b869fcd59ebcc063bbd53446f2e40611c989981c1c78d559d148fa368d6cea92f1da91e249cfa007e49d625a6e32b75b8c4415b690da62adb9c10c5f6bc1b2b966bb07de82825e4ba8f9a52066b0eee89deff52562dd473bc8019b4aeefd2d41d5cb7cd34c2669391ebd23393265ce168a332aef8ed4afe22440e569c36ac30d96c2754f8208486bed3e5f42f9e5a567b90326bbd3a34aeb016eb05a2574a35861cc0d0076b6ddadec1df48756b0a1f189e6c77238b0c83b18cb870366de7441a39321b59acd539155467db27dc6fd74e2491e0e0f4c56c584495401a1c39aab93a8f38438a5b75300653bec5f7a3f0c7c80f0dec883025496ae76eb175d0d0fa489a043ef740e75a5a0cd34b83ea2397b750b092ce34adf265a6566d3bc6e3909b9f69a2975d69cea34abeda649615a2605fbe65c6d955dc67d89ac4967218802323ffc2c88a0ac3246aac4198d09da13c06b5985ea9001f32f88f104af90a8b540073d437b0a393b4e770ec60fc23ec5bb7c229ee24cef96d958c3e4eb54c931768539f9446ccba9452f25e07d0cd21264898dbe5fc0c2853c063252bd05eac39cdb6188691d0ba5c69cebca608de659d3a23d2f379705cc70b29aedbdf06fa1fd240874e89a55caaafbb5c2841878c9cefed87b13467f006f5ca4cd1502faac408ab31774fa44221b630198951731b0359b033672c17fc4154e6abccf983494154057467b5d2f8b43921b73e5939683a23656ea08dca306319f58bee739676b74d063a100a1eb2e18867c8b009647b2907102612285a3fe9a5946c360cd05ff894b9dd4dd4c0f897682e4ad0443ba33fda2bb3de7395486e67aa7125c9254042f9c5f2d21e290bfc6efd6e2e0a023d5fb07aae202b26ac1e8a11d05624456a69bb853d3f50c60a8646341996eef7775f7a274716b2d5690e19abfe6aea7187f44631fb049a10d984c2c9963afd31cf699d740db641083d204b1af1dca128ae8c661748f0c78f931e436c1770496600dfc5cdd30b36477ff1c232ae395e7c8061f6f07562af871e26b05fcbc0c09e29403366975d9a8ec0c1b35a9b7392ff75e8138c4ecb566f25df7b494554835fa8209bdc5ec335939e52a106ad7d069073a3a462b7f12602ce1433e5b359f6e051dcdfba1ce8ea98216533fe7556bb47e81bc0176440ffd5dda4580f5351466811cef5a22cf81866b4869e7a6a336a0af81ddf96f53609e06899e47f394574ccff8d72fe06ef202f66b9cd590e94c141c7f608fc6a6c709fe1d3d8c021f22752dd3ba9624cfac274a1d0d34c244396213526c84afdde25ba747d8a4e1dc8b1cb89d042d8321adf0331eb8f08f47260263954d8057ad815fb761f35185c4d101b7270c8d2093b8567953c152674a6703eaab26af3dade277f1d2f78a3181e41dceb5f7ce3891a121a597894ce5427f9c389830e001e95522b52e09c42c3b8943b6cddf956d5bb79dece622c39dd23de655bbb747ae7523618357fdc95dfa7589a76aa22013980859089dfc5b7d92c6fae5e641fd45008bc618b7b5230ac7946adfcff0f42f176aaa010a56b15617acafe7a7c8644b9d62cc51cf4da993101e23ed0c80faa7bb301373ba009b98955c6e23aad95800cbf490e1c99a4e6633f64c6c1618f2a1fb2fbf556d31adc06d8de80ab8066fe98d1ccd07d391eb0a54aaae9acf8dd2eceb8154593793f261c58f98bf17e452b40e6b229372c2b0483b6d950d7bef7ca81e375d34c701da5193be8b75822130578da4e904bb325b6de8a82e729a5315f839ae14a42f4d6c3d8ed2e90038f0d629de78e2187c447b4eefa297d1652d59ad241db443c6df5f23f52ee44c40ffad28f2685454415f015ebc05e9764199dae5c936f56baf77c018db7a2b23c467893f009b0e0a6c723d09ed1dcd135a6452d9d73841badf4a1f00dd9852dfd08c14bb041e09c5d04a3939b5c7bd77e03f3c96af0fafa422d5382e66345a5b0e9a321cfa8da77844957995a9842196caed41a7ebdbe2e800b3d1eb9d425fd711602fdbd3308e6236db4d04e688553d07cfbb683965500bc1ddb360e5c7d853f932a2895db65119a17df73b614bc624ff1be735d8ce31d7cb681c14077cedba0f3b0bbf4bdc72a614d6f26dcaf37707d35ba4b4cc40ce8095d03e6a8f55b4085a95fc14fbbc288fd945afea1ac3035b03fb00a237d40150f7c96af64e0764b9ee5a9e1425085111e6befde8312d58b7c2b9dd270c2c18cc7ce44b2d5bee1b29251008bcc7f467ca2ff035bc3980d4790ca7e012db78df1081875b89b770e39553006857a9b5e73709be8a2ddee04bafe510a7f3a977e4a3f03e9e050aa0ebc70bc49eee99607a6b3657e189d98f965cd8af13b2531dfd911a34458af2ab331f95f26ec5506a8fbf7d2789c8f4ac9e116107d6973aaea9dd4bac3f222f78738482170707042aeecd0a8a31f3f231561a8a08e54eda036db57eb1dd1407cf261193946591d724d4a2c88e93ee6d05ea854ef2b8a2ecff4f371b0c766598353b7c763a2e6a56890562c5dc6e2a8f2419c5dade3e0b181270fc7cdc15079faaacb22210ccf97dfca160b464112bcad5705943e14ed63c8b0feaf9f1875d84b7be176894e85fe4670af901ce8b3c48d1faa770821f0044e9a1f82f9b950c9ab749f48266ccdcb38aebf1dd3bc58f760e496dea481a5a47b095035bb1da4a89cfdb59515a7e750103fb46391b3ba1b1f80264ee5edff63d6eee1fd5b7ac9e410c8763802effe1f921677dd1ab40132501ac367c53c9475de7d8050dc7f2352b56246ceec81f0ad493332f8eb133604395728dd61acdfac4e003a6ae86856b5687f20f01eefe0618cfc6d887627925a028e1f69e3b2c4c0c16a4dca14be95cc6f320bbde402014016ce288cf44bc487994706fb4cef90a86313d39ba96a2d202926aee9fe1af280c235af3aac7501ece0b2d1c733cadc4b052ad93032d485713a17aaa5e3b75c3665a868644088d9ed52b14a827fae835829b193b41483891e46c495301a305cb96f850cc9b2b02b94f7c1792adbfcc014c0c189047954616e8f48fa67e6597ed8a0f4627d517340f6a7f6b82e7bd255baf6c27a6daa9bd08afe40cd98e732791f68e0467e43bfc95b073574baffccdb8fc5e7597d90d927866f3c7e1d9b4fd233f30f601cc195f2bac21dbb193fad99dc19f86d2c4e4dc91293056d0bbf391d40c44239a1dd1e7e665020a8a10073e950b16597fef24fff89864bcffd58d6d5503b894411e50e0ba04b2ffde02a146e8065f3337a984af7066048a756b0cfe08839c40c1c1bc059d67edd9eaa754d25ce357a481f0fb83a445b15b4e2b5ae9b2cc2e356bdef6e7771e4f773befc40edb96fbce68b3a459a30e389ddfc3c2874e245404eb67ea29a1e73a88130e4d407cabba9f63b5e901b7c08ed7cf6f28e866c6191648acdf403d94575d8b1d98eb1827d3ae223a44387b6436f13ae696b7d6140f111f05929278ddaee4386bc413208c24160aafdda4a540f75496eba8974b81101821ce98e96d8ddeba7f59c37cf8bc08bea45e4b936ae84d423443f8d3889a5bbcff1f94d72521f8174a8bc0fe9615ec459436903056ba311699ab7af39aaacd63ee368d80b804ccffd2c1d2e2e6fca45cbfd9cb18e8ac56de21e8fab875aee3dea92516ec0cc1e3b1aebb337d2df4c8a13a219f41ad7510c5089b05e7e023bfa085ed415d81761f5bd0d9a448af4a629654c521dc169a333340d0968f220448d9f981289a29b4b79e5b3a81bb4ebdde176b7b78b7764fe7c778062550e7b9b947c84ea4e23a6670ac014ba76854033bc64aba76cba559285a036a8cdaf6f274fcf34152f339cfb12a9e28054b20dacc66666790338292235aa64893d25cd1ac753d847317ce7e5d8f6afb0258aa9e27672b13c0b171b8fbaaf795c7b5fc17815741384e6a55f9b0926df7905909196ec7a192e48618d3fb67f1082363748240a243a01dfb89c917eea405dba4070f6665e9e8a10b8591adeef67da0f73d60d8cdb73143e5db79514475b1d9135128edd34f852e2e64e28d5cbca2b25ad9dc0477bd08045db774a33bb6728d6237cc11880a916877043d7d75c20bfa159a24ea45160109f1ad48763a7e60b3f649b3d19fdc2def794f6e9cacc12b2f4fcaa32856017e6636296bd7552c7928888040a582f2f97e0de870fdbccdac5fe000c1e52579e3a4630f69bad997c49bb0a78b68dcdac92155bc4fb8a481ea8948ec2edf85f6c3fd588c0499891d2e6d7aca995c7684f86ac41ef86d406a02d7f20aa3dc7a010a04287052aebf4c94943107325efd61f0de7069d5b4a1ab4ed24552d36af83b4b7c33e85147eb97851b1baeee3eba412cd094adb49567b3f51a8edffed1f741776bc7adc95d5a10f71e73840999519d9ee707582d79185a961ee8db4164224c4173639037b46e8c68ce48bf38951232ad2da39686db024e81cb8e742fa01731484043e63442c14d3473f4a4d6c59c72b817320a9c12a564d947bf054e5b6ebbd69167d0642814f071c5b87c8f5bd0171322a1524e18ce961e76a0d3be4f23c7514062cdb42f0cd1f8abf259af787863b7ff67d21a740c88b5e8808838fd1d9e8cc9338f3b03f62d0138da2a395ec32f83c7c909f94d617b76c8a588b36f060a8caf8bc19c1bd78590d23735d1097cee19419ca7b95559965c7821854247c803b50cc9b6a8242fedbd3f61137130b4c4592155582ae30e477762d582462da848cd4ec6c62465f64e22efc75446cc3a116ae96313e71d61d9b1ad70541b3b73755f990c6a72720fd9f791e95d6bd5ff4a3c87aa76fdcb3de719ec26b89e155e6dcb301d30be67a04ae6e48a6bd1e803e05290d48a85709c8ece3a10fe8a8d9cd534ef1c0a7be532b005bb246afccf7a94867bcb56aa8ecbbb464ba764bba180aaf56c5a7eefc49917471a22c1b940408fc143889ddf2f1dc363f7c37847accb656f3e1986c57a793b16c37b69efc7105b55bd54afbc30cceaff0274bb17d12a402979fb0955840739d43ce2a9c6fb95b3b44550d83d81b67b565e6a5e9e2f76470e4ca50751cd63ff9d95ecced22e457b119b9c6da44147307a1c794319c666a4379abedffc71e170fd9b8dbf527680114b64370998a98be5b2751db0413384037260792fdf0ba9171b555915840cfaada84f1d6bbf3c48d8dd13bb58d1c033802b1405002e2031f523b8fbe2dba1ce9642d3c02b95bceed6f03feacc0198381501e38651ee100784e2e1e1c38286f807e124965544fa19592c20d483426a78adc7b3fb2005bcd122f7a8e80dc81918e03c2e582a669f14405ed27fbcc6e739efc236946eb5959980eec6700c2e4b3b82b0a492700c4ce2d06b81700225f8755ff28b96c9bd79910045fa8aa0deca0a2b7c4eaff80c01388efdd60fdd567450111c95fa7eb182e654d3ee62d474ab4e790052874556159b4da14b4bb5bbefce7ed000e69c7df25259b6452172193666b440f31bd129ebdeff8e8e41eaef4fdbc912463b7946784afe2fe94e1506fa48f064279a2524171aba7babacfaa8b856307c35b064615b063e57e58fa9be0bcc1b6ab9d7785f5937b678397692b04658a7b7a6d43f33f73cb2d4e1cad0409f9331558f93aa0f0aebcf9818dbfed013114fb2300db973297a18c454232cea3521999efeb01acf370d76d9daedc7052ca0e218a52e87f8332d6794beb35bc61ea686f11864616b354b4c7868b9749837c4f72731a6aac685a55ca5a69c1fe8a5341a77d8c1726d8c13a2c64c74e22def980524a515ccf1e59a12e0134199a475e3d82d519569a09d4994708f85ac5e8736d985dd1a97f030dd7fffb07be5da9399f8766862573799263ffc9b95494d54ff99cc5128d77be68f19e61c99366ad2114e1aee477ce1ba3aa933167b087588b67ce47213c06aed29b26d2dcffe1b2e4ff72196c3d40a2be351e1c34ca5eea8ee11a593e486e698a9ec1c583a60e4c1dc64c4683c6bc5bd3ed48f822a42e54406116545c16578e83008deb75a5aa2fc27a912cb26031a31634c89f1723dff2a25c0f8d4a836659e77c4e1188014a7e04eb8dd2d9c2759d145660cd8d0036788b50c269f1922aa9afd5d3e05eb3fe0173ed3108bca7f8fca92e4d78985f876a868eed50ec25424ff8ae0099ba37db119593f37d34985037e529fc871d0e9fbc0d4ddd54911e7b08249edae04990f7fed6dc35666ac742a586a2fe4b4353ec444c39b5767fb75c19022dbf3a154117031c0d02fc76f98481bb131471c97c8aa5c68ec67720c60c9b171a00e9bab36e4258fe63b2b21ee0c9aa2e86a3a23491284d59f065de438b5d4ecd3357fa8471307548c131e6957cae19ca9fe03b1b46267a0d4adc18529100e89ddaf80767387290e60d1bae44657c635eb45021caa167f19b40585e0bc462ed756ebb920b46fa542cef24b6e038495921ec5b96184d4a1079c4ea0c7db479291bf32cad3a2ded30a953f4afcf34ae7c0c8881d5731fcdedd02c21c8494a9ac323c155286b603c884e4cf400a53c1a941f24f2ad36c17e07571190ea6660a65922ca8f0c471d1e132bb730f8b49ae8ae411029724a591facfc5571c334383d630c7b1551b0ee058da22302d952f1f79bc67156afe9f3ac14d84e12f8c4f68d57eb378c77d1372143c284248aa7ae0fdae018e729820909d9220f0de2a77705bc790a71162274c4838d195ed5af03d3b28571d6d405c2e7c9fd4651f1f953195055409d9a6d447a443d42c8e2234c2d16e87625c7b59b08e96671183b698658b37ddcb6c676343e7ea5124aed59ecc80a67ac8ee3d2421fe3c1195479433cdfa9d6adb50c5815a9c1161c82f933390f7a4573a46f1dc237b073a0797ef974b78b94de44b8fb0d1edaec77a53cba8f4855080c540b2e4ceea7f774bb65fdca8f3c299f7ba4e61bef0a69647e825e56c86b5a9a214219b8ed127beb1b7c3933c16b0d47c376eb6039e0efe715ec4eeb2a4088151f22326f33cc74f27884843ab6d21932a677954bb08a9027d68cbd15d4a1b0dec2931a548266aeef150a3979739b4507eed8de055be49482a750e5a7a7a0f5a96264c0e765c9ea3d30112157125a894dc36eeac5abaad43eea2d52b0988ba5fdf3e00d7e4d54b629ce5533fb96ed73dcfedfe30f23dc256ac7f9ca7b74799d3778a292f0252b233b8b39419fde1543453688b92377411982dc91357facd5ea5c70a240b7db729a34c592b96e5b479932442c9f0e89af15725fa26947e7b51d54cebef972577f1a54c038a09dc597c1567584a64abde84e1ca595255b1d4beba7e3ae584a7837b732bda6d74176e3076b1ca33ddfcd2a3a3386a6e16a63d050273e432254d2e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
