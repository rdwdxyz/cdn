<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bb22f3d87861d659e2a3c3dec84a13e6dfc6b3c1551549039e3f02175036852924371f004f370eb4fd546431f19ad5bd14af95e8a3ed62f5caf6b6316844076f1b9c2a0208c6a715639cd5427720111b93bd97898f6950188f3e8f96387aead2d710ca71684f3b32f7ad9e5d392ec53f32db2c7905fead050cad7b9e18a0d6b320b7fd5f9f3b895eb975698a56201525221b37629387535ca2caec4bd13ef42ec149605d751313a1cdcb53c7f9ce4b6c674017f75144570a23041dc2017c7f06f50dd420fec918d5d1cbf54c8846533f8a33ea45a54b19b39bc68052de8cebddaea8353adeffce13dec65d7bf4f1baf52d89857976ddf8e8cfffe414f86f2037f21d8bfc3b7ac70c0ea2e18847e2b2a6914f6fab52e938861da852ae37ef79e3325d5b6cce320e687161540988a65c07ce4ca7aea025faffad0f2e599a48a5cf2caa8b11ba3f11a6661d508aaeb56bc6e7aa323f3594cbec761619704eafa43d30093f7c7bb966bbfc57b05b25ba6b9906c5223db2247bcd326a6ae81fea1bd19fefea2cd324e5e0db044704eb0f5a17d68c061e1d5ef325a8694dba49c3c99268cb6206750677a02f4628b81c7d8b9bb5e1d0eb79ccdc52efc39f5528f85aa724fc08bd775c4ca8767fcddc1f93153a8cafb771f41f6d98a33ed32e718549e1d5ad68b96b81e0f9d4b68f2b54d4c1e615c400a6e04181aa07bb9f8d1af5b0cd8a75a2a2419a383c605e30a49a1eca33ed0d693163d04687bc7e030f4aced488931caece7ba6e8ce32decd4295face453427a689801906e528ecb1b2d48b70baee0380200984449e061bbaf16319d01de95e6e369a872eadb9e33b872b9dca814017017bf0ed4a4665b5f73ec6a5cb38001cf3bf2f7abe629eb5756cae73c430f4d019ba7a87fca874bd62ee7f4d8ba6f08dbfcd55bfd33a164a555e73ceceb6a87657c36558b29738bd9816f2eafe09cb34b8f7d7fc235e77a3f19b5577b7eec58cdeed1a189df4c1336c8b8ad39ab4766cfb5d98cec24d157aeb20efa6b2b0c48acfade3d66c638e24dfbc93e6cc738908d2e56643583662de79bd78a3b17e7703cd217dcd162dd4f0a3417e305d9137066bb782eb341f270ac90bdc801076d9d5e8280c17cec2300abe388660c9e2ed5ba55c313b6568de0c6755388026101dd713ceb59fcea10e3b09c7d0c62d1a258c78c1b5733649e516fcc28c4a761a9c7303ef5165146bf6b735f1185986ba948397e0340f7015e765bd286f499ac1ac868f7f9d4600a77ed5fa42599090e250eed8016c77796ca67acf1c8832ce40ad5808e33466d329495ae74cd50b30a0b2a5aa6f8810e7da3786b1f4edd1275501163ce4ea44fa9c5bb829a95fb80eea4c038d4fe13b3800b94a2ce537bd361d5bd50d40a75bff8878e3ac656be356e50883c8fef34e5b1f28494b52b908fab611c8be5380cb20855b992ac82909fd22b5fa6e813ed50580d5973c24871575d1a1ccbc49c2ee8e763856307785bdea42bf7dd3afb1f30c016094c3ada9199c87b65fcf03c89ad35d3125608ff432308bd160deb8a44cc1f97e0331d34153ded187b37e4ace997958abe618b7bcfe91423fa531de2b8627a0fdc68229efd1f111d6cd9e29cc50ec3b4e5ac97758e14e37898f372169445b86a33fe2151c67997afe5033aedcfa9891bf13dfd878e70764edd5abed337af6708c01b27498b72ea474ac073f722a31bffd5a35fd9aab0e23e2de84e59645affd94215975886cba4d8ef653b4b7f740aeefde21ad72a84889c3b9236158cb81b275154939a35a6b955ab8d5db500855018de3b219acb4b7610aa616f3b8d24f4dd9840d470dc0e1375f9f892be06c888d37fb1b04a9b1405b84ff1ff6bbc216837a3ef1929cee5967ad4255124c13eccc665bda2824073abf9d4c568dcb1108eaf4335efdb2c602544f95c33ab8295743d74046dabb0846286380f2dfea3b52bcc4cec7bc84b78eac49ee92bf1bd6babd1f35b7d1203778db878115943797fe55888acf756524bca61e7998c18c80604c436025d99ccb102159fa2c7afa6b09fd066c48ed7bce2e93cfca6d8b6d61dae80fa175e161e9da1b15c671b637c7c598e3eb554c93409a8fe0acd3497212bae1ac0df6a66afa987a107ad40f77ee17f17d9a95f6080b97e28253269f740dbae0a0112fb2441708e466c3b5a1c7c2420f14571ae8ef6e504de5c125108ca18c57edbcb929e336b2eaa415c7e5d332c9430a1e4c6bdfb6288724eaaebaf3c31269473b5df2da8f109e3dfdf3e8cc49d6066223b3f2673e24dc10e5023221e17a20da48a978ab83f4e1c97e95046943360382583c022ddb523ceed80cc9359cdc49e7ffa1fdaa350f46d7e03bbc0586a5c412c68d69103c4df1e275cf60535d25f1df5dd8ae878cb46a11591ef975daa728ffa61534c80874d3ee3abce30891935e753a7abb2903f75ae0bd1d27f2715b5d1390d0006f641fa962a05ad407db03b27c600488c6fa99f40de6bfa44e217f9b64056f94e356486f1cf0562f1eb4c454b11cdcb63d30221ba5112f4657e7b5887321ee0ffb7971997f7119c9d8a4a6e2ad203ba42bfded4ed492aec5f488ceacb3297310843b054fd41bbf3b5ec196d883ac7050fb32f6a57907ea35a3c46485c495a36f7ef8f446804eff3f995b807b1d2ba264de0fb68f6ec1cee3de4d307c19d18e888f874ba9569496b31adfa02992b9f9cd3b67ccc51096a1cb969949a571ee7ceb92c277d703c1eb30197c818d68319cb6d1148249b6d26a87c2481d62f07b28e8c9d787b654dba1f1eab66e4459f6e724491a0c49252b63b2d1c7d5420093b691824b7eeabe3ff80d4133b695fe85ccfd089cfd627acf362646ab412e8d832d5315a535d23b47d0734c7bfa0f4c9c139bc11c17852ab45f0467d29a4844f7f443190040f3fa29dccde41302fce042ffa0cb646c6b5734f68c9eea6ea54a3228f6f9df0c33628d458e8816fa9b89210535eea55ec32af44ea3d9c9f5672a353f28edfbf4b21d4ac10dab3b5e175a8932e4ea1522d99258aec3793feb2d85114deb9c7be9d74fe00a365ed41ae56668ac651b60574d8d5131e6ea270b6971fe316f3ebaee7c3014d4eca29ca7f55be20abc7464f38cea0581a9df2cbf538aa868243f04dc71e7dc60ad729e5574dd9a51da2cc0b6adcf057f017e4d25e243b69d5acb33d49018749805d805b5e56cfa058efd4137d57ec2020712818241e394f0ff13ad30f2f37b23def702b3f94ccf9bffcbf6bb3daa7bdb12ee8ada6ed29b9322f3bb902eb24291bbf05f7edb2f8ecb08a06b661a95b279e5faab8de6cb6e4fa88b6ffcc6c9288b6b8e93b9cbb9aeba0bf5366629aa50af9feb875d0af07a7bd3abf0f72209185721de249b9bd2ed3cf5764a139a09f0e595da1aa0383022c791b7ce0f5ba94511dc653ba79d0dbd1ba1fa7370e16a886c9a210de702a55c933f18b14bfb4dcfc1831433e5fa07a09807218e0130aa410a9085adea93af48d1060315bc719f51d15201d3341ad96595a6da10225a23397df4ad630fbed97873bb22f1edafa5f261d203de7f56951100067b096b13291cb08a7c1425fd39bfe312a39cd1914a5d69a0746c126445f0a124464017d36043463ca6cf4faebcd91698b8f8d7e463c786f0d3fbadd13c6df9f52412a7014266461a12c34c90a935e8260f8cd903712c8fba47783e86a92a39298fe8e2f1e0f2163c8f50064000cbd07ce0de1d30f96775fea689f81ff0a4891db18075be1204b93d4773382df1c40d633890e61db5c0ab890aece019c747d69b7c5d22a3dd5eb94d56ac1994e602d6cead50e6e622133a6f6473d2a7dfc9f6120b219bc73c211bb8cb5fa727c55dd280ec54a48fd05b87b41fe027d768f4f1a99625ea29f761b3abde424667e4e4d55deace33cb8041b89058afa32888c04282c5a6759aca25c73f17134e14afa52fa61b67b6ed3ebfe101bf1ad82edff0682542265ecd1736a2c1a40eb8e766a09a39b3981c063c774f475698ee04e91e3e797f495c52d7dda91976d98049f9066eab330b9a852af394d603da74a9d7035da9a36a9a207a5d0ac476f8a4aecc14ed214a85ce2273ccfe0241a73fcbba8d821edd081ff5940a5158fbe91ce9552d2bb69da14c6f5385a3fe95c67807764120be5fa8b124d1c08762e7aa493c88e143b54ac97298c13333e5c75b1156196a52db524b34c8ad60e6e92074ab67e8b11f7e26ee26592e7ef2fc10e0a86396ebe01ac4a45d9fd6bdbb358987647548b966a57e7fa69d5a6656e31d148e814c5ec9a3c5f62912418a8f5d5e91ce75320162ef70f9e3bdf53eed43f3e4fd3355101a921595da58daa3c925a22375042eeae319849bd5bdfaf4e6c3ebb45bb6ad8e637ec974974c9ca9c79c3dbb3781c47b18b888ab6f58ff06e0e88573e447d85294a161e02338a9770807f479c56bdd3bcc1800d717a58df1772c39d69d501e7602a89cd88a8076fe408384231a7483b24973536b7320367cc70b7623078e64666fab4f04c5dfdcf9caecea0602cd5ee77174bea6e06f6b869c3eb51c755335093f58a376e4aa34357de67ab33f2bf75b4f38870abaad48a90277b748487980979780039f1f910d752744e63672582f4ea7ad119e1c10575b8ccce99601991a85a61070a5d2573683c426178ec0907c63ee2a061597772170a32397b4e4b8862ee47e84369cf52291fc7511e56c4f501b60c2344be333f72f14d2986b19c2baeef735b1f0b3cf4eeace2b316d390e7007233242f0fc6a566197b43206e38b690e03d00e4c48e911671137da704a9855f998d3fb28ae36059213f9a10816110bc50e36b004ce33e04eef43a5f9697f67a2e688901a7bf357ccb7f9199365c6ce0534824048fb97b2ff680ef1be223e5dcf97732464e94099ae3a055f8c102d0946a33fdc615ff7559263e7e068ba788b4043588350662cb5ad3946a5337e560083f35d3db293e8a3aff26c6b42efe38534d0ccdcc9ee7a77172bd0d3d9301928c797d311f206233c37fb11bc5aed92b31b21b9a49cc025d7704e86c515c3dabce0b3c8a6577e935151647e352564d4cfd1cbc5518f0946a325133bb8ad575e855d9b65e5076602cdc2f292a6e1bb4280c9e32e7fbba32e2eeae7ac8df39a3dcaf88eb2a7ba4eb0951d78f5b08f9f89ed0df6301a9fb77cc068f37ba722483122eddeb8f4c5da78fbe4bf18d2138ebf2f04085a847ca4c522d62c1446812c149a9f1f6888d263449a32e93e7db6f3d2b5ce014c958eeeb9c05dd2724e7e8963d5213f497fec789951ffb23ea6955a6adc5598129230a6388b14d259fd2858f98853ba11b36be2d2840b2bd684cd173d7abc03abe4d89f19afc1e8f6530bbb5bd91675d3de07f31f691bca5c09da91574feadb5e4199348401429828f305483511ad9f77a23f52628370998124c652c1ada08bb6558f02bc9204c55186865f9f5d420a257c013bc9b9862e6d05b72ddb7e3788040ffe34af1d008129008136aec533b895f7fd238e88d1e8399816e824b863f1758a7f14e579137c7cbf42297b31f21c40977ac0df50cb51b48c18ee1d59ee923aa87b48082697d0d1764038a2fc1ddd3aab52ea3972787de61e9f02743d09218f6e1ed07be9b7d8f44e9c59919d061ffa7fbeeadcaa668df42577f18d2bc0ca1ad2ede41cd0943bdfcb33640f3a92553c3fae30bd48b96f0ea4616a70375acfd103bcbc4cc62b7fd6b63c740e1f19e8ee781fd01b2f0cfdff93a08df838fdf37a7eed5c2d1dc89e0c76155eeeeadf24e20d04b4a68503b7dc30a3af192329ae3f1ffaf3b349744539d0a8637461a7a5e8550837212d07f0a6b54d5d9a0faf030e06e12a0dc4b1d8436821cc9b334a1b30645a7c4193bf3faf6bc1f7ef0013d8bb9e49c034d49c9b859dd6064ff07dcf8d1761b75f6a4ba3f64dab1ffff02a80f59ec564c986f64e85527bd483d9fa06cd8cbdf6121562c713b166c60cb46925d41a0fef36be4d0bcd9b30d797f905e80ff8d4d7460e164599b8efd90124bd72acfcc5871be6db61ca8791a75ebd5053c24031cb60d3f7b3450fb9443855335372d17b9a6f15ac58ae89029c1b809ec2cc9d5a8676052b79994fc29ab3b69cebcd06acbc98ab7583e2c44a6b7bdc2bd8ac07bca372f8f6b1a4920dd29db957fa15201366666d0d11c82920acec7d612c4a635bac39e7b8a6932ba049dad15fec3027162a7dc34e69c0611fbb142b38f637a02f96cb76d7b9fbd4bbf88410ed35ac7f603b71f789c58ef789ad5343b16a245100a553411eb1fc192ebe151f0ec8deedaec4c3ce5bb61026238b775c89e2b94b61005fe5cb25e50e9ddd0f733f567585935441a2bffe07a9290524b0d36f3bb7558b2326fc85dafd9179057fc1eda44d5c2b6fc323e03687b94283ea6aa9b7b8a47e2848a2ad1c3c1fe9721f03f641dbcf4fd49979b3c49b72aac1b03df45b948cb4fcbb8313783b36180c7d6452656eec34865cd531c9da41460ae51c94d8711ab34efc0255c618b4b9855e93c463e0cc327c8778d4851df25d6464398500a405afaa8495326745e400157494ac808b5c1a5711c29b695e68fd3d02a4dcb19af3664076f35fac88e905987e952f91e77f36b8ed87c4ba573be35a802f8891853b41244b7b1f35bd4b93530854bbd81097d4a40f8549b9b730330e0fcdc27b887e1477ce21874dddd0506ee6e372461a864bec08a16f53f8632a79eee6a8e652dedfc1e8aa3ef93989301a21617d2bebaf8b44d2196dde8bab18328a0557b4bbf6b1e7f4c863346e9d8435167bba3350042995a8162f7c4d7869b4594ee1a55f14f8e6700e38bd707ff34dbb29b9b033356235051cf9d36ce7f2f1a0b2e1cca2874e4823b00b6e949b3a27d99b7f115db63bbd1c708cfb748876313ff6286496d38c83843d3d3ddf9fee18ccc338906d20633819ccb3c8c04c4781cfaf0952f4966246983b98112f970690122b3e7c5f37599fbc6556dfc37544a66d0887f74353305249078ed4ed9af0cb2e3fc44e532e575c4a149a2df3a422051a0d647df85400af7b40f6239c1ebfe5e07387750edd6ad0b04089d157eccf16f250387f54ec6b176c6b9ce73f97dad702db343b281564f8cee951aa0d6c3957bffac1d2fcbda6c477c0cedea1fed46b132a58a271d62b38d872888081cb77547773d32b261e1b2611ed80478ee3507602459be1a3674a389348d06b4337f4d50c2d7fdf8fb26c91208ea57de7cfb13a557b224432f1f0b3b299091459ae58759a9fa6185d645686ded754097ad1babe5ff9060d752ff92c1ba5e659ed049fb7f3b87fe96efb3d621793b0244cba0511776079cafc605f9e0f811c3038745105a8a15ed0cce9990838ce275ac9af7ab87e787d63420f4b9ed607267efcd887e141d9d335c8c7edac623a7fb724f319be6d50f04f4306793d7aeb59cfac12de5b02d29bd6cd78d53a52dc03493b62ef601b16661a059ed7fa70dfcc45b3020df2f9dcc405a7b1c9a4738a5503a155ecf0795ad1750f96be70cc1745f25c5ac902204f3a3ab098c5139e5c971172ab0482c3ac1636c883dfc0abb53ca2dedb9d13247786ce58242b69fa5adad67e19e25cd8715d85042d1cbde47a8a8f7f4b746401afa01f6ecf0d4097dc29e5e189b54c37db3815e3219d67c9f05791e8fd796a1f1259b61531f000e622b100df84ca66671b6ea1ef6babb6017eb6b63f319dd06125b3d9364cf212425d99aebd780f45f046584ba8cb5def2f20dc55d8f6cc400e661c8a87bc5b9028e750b42dd0b90dd262ca96456d83e43e0c9f4d8423bb7af5fc62c9ef6e6e635777c434bd2868adb3c6d84f47389232703e7afaf82b0e8e67ff3535fad0207c8a494731c11feed0d1d367d9e8bfae578a5977e2e63a7ac990fd3236d01fa94849ec74e7bcce93cab9d2cb34e5772f89b41a61bf4a598ebd2daeeff4bb918be835bb0a19d4958b27570bd25d526e130cb8f6546a96c26fed5eadac6e5fdc035c8346ca99d3d984657e8b9c0acf80397dfdf14c538bda4fe4908b6078ad7455df4d49aa579552ac4125531d34aa54d05139eeffe5da9b4ec7363c0a64cfea10abcb24f7ba3bc47e1948223e7321abf69e8cffb13071758ae57050781b838d1b9adb3f52c23111ed5b3e870664117382b8a6c909d8b310e623c9bcf597e3f76b80881e7bce52e7e3784ce750533f685253f28ef15e0de2e0d91d4313f7c6158b41852181ba351685613cf9da9da1d9bf77749aabeacd0bc584b512d025775cc45de1619394a0b38ea19528fd4c4406900ae8bbad55c89631d09fc198d50371650131ff2e2ba53ffb15915d9ef6015c2ab396932f5a0ce2bb325214616890f0e2e04fd489f9e84f8af1081b72112ae138d052b81959167830cf1d02823f2235776440067b9f8000eee8f158652be7db78c25203b53472efd3b7c736c11b162ace98de420d879bae14c1471a82b666cf77f7dca9dadb464c88065145d9b13dc424ab90440856f103850456743adaf2c0e2fdd543eaefce2e842918e89f48fb7149d5b32ecfe8ec5508388c4aea9dffd60ba6a6a38cbe46f1e9919a05fdc57727d1c7ad0cc5a901629de0f494c3535c890dbbf020e4332fec77054aae075a82a224299a441e8e39001919fd522cc88d09c1ac361392c34f1f821b53604887591781555d7bb6605c46342124fca391d720d7686ccde5ac522db3846caecd65b7d33449ebdfb3211026d85821716300ed93417628d085b04091339cc6e74f417adc14d0cd5786e539862cd6dfa0f06196df31afb99cf9e5af4d40b68a1b5059c5036064a64c059878fb3294c0bcd31e65bd26d75e06d192e335ab44c1b919af6d3a129400c5ea1a487056a741031e9532891b79edaa98ef7c28540a9cf90471a12302ef55b3390e58ec0d84dcb88e84799acbf5616d5ae0cb7d606aaaa4f93a04dfd57ccc0bb542f87dd87c90d78942b40961c6dcb158cfd8f1a11daa558ea7238fb963e30dc9964ba0e35b26e701525dba6f79581816513aab7eaeef2b5c071d705ead52b3745f333fa4dfbf1ef245d2ea1967ba1517e659257f6ddf646586ea09933d7eba5ff92592a786eb05f4a2b3d82b377b1934b931b2ce224382878e03414f6e7a2d133429ab6b10c0e764ec462d6a915fcd3731a5aa90936e2193535e66c7363298ce6a27da24da2c42ef0039171eeb160ecb6e950b127a2543df9e844196965c60a4bffb86903edea5645b87593faac3bc6bc0731a7108ee5dbbf9e5e6f1456a3e79b6cf87aac0663adfb9e36979ce7a44ce9452f54945f7317bcd6af38b9366661af5148fe690cbd133a179ed5f1782dbf5f80ed022c7f6e0518d09f8f1307f2e9301e5172611b4a999834bc4934845993db96679f287be736c5df16fdbb23ac67a04de3dbff12f762da55467ae6684679bd2a7bc3d74fd05d0ffa64f3e09bf8715026d22ed1edb7a986861dbae5710d382a67ff314875713936fcd6439d87b3a4e63bd8e31f9b4094d3fe70db752094e670cca055edbefff4556c0c74686ac6369229a67f032de2d801ad5c9500902eefe0cce0ba150b51c686741ea4861ab871b2a8858e06733cd642611d73d0982928ac1373e052a54d3b3d643775d57193ca49eeaa7013edc58ae5037c17d7483333b19168b54254372e43638a1536255690c49854a8bcea1f051c3faab819990679e21670a28efc1b2e8542fc44d71841f11f7df55e1880423f52e1d1f779a9402bd22e773fd30f8387c324b1092df9c2f05206e30eaece2d5bf6f6c145e40bb2d34fc1a030bf8922fb560a7fde3eb864bbad0954fd34ed4a3732d8750687064c61f7613667765099b9e32ebfb55e2a9603df3afb16d7475b0416876715fd7ad5497d6be7dbcfa41e86b15a664c69c29c16aea51a7951bdf7bb99d271dc5e4475b148f5ef3f960f42c4c228d83fdd90ac542d330620a2a918e9bc54e26523d89dc68eb70b2493949aedb9bc1602e4b099c4cd6beef91132dbbfe4f94adcd22c457e76a433467d3232429e2765d40c6bb413207ac9d61c540a9ce6156760cf8d1d2ec0186901867bfac3bac2ea90a319da2d97bba77aea853487dcd439f38c91f4e1655ea837049e16712412dd844e5c33f214114e91bb26aadc0352903bdab64fc6552e284db3c432c71dea3c167afa0c69966d61cee7ed435569ddc49ee29cbfe154f4f1be622e757a206b99f550bf44a9a9a438e0432ed14b633afcea0dd093ccd72a2785e973324df2fd5bfaab0ff4ba7b0d3655236f84f833aab7ff17d57e11033938b49d478954a23af64c246e3a7dbd48427c792ffed375ef4e3bfe30aa4f062a3e3f7a481005bce61b55b675747a2a6b55219d01ffb05c082de6ebd04ab25066dc0916fc5571c36792ceb35d5b59db06541810d57af5331c16e8741de4c1980e2340c51d8bd1b02c20c9dec1ee95ea808244bf4a5658ba6295cfbc0740cc69d7bad4be50378e081bcef5eb07e56aadb7224fa780d48821d9b4cc8a7278d71590b354c29fda3308d07d70f2d9bbe98a57d59e5fbb22258d9f9f3d043b2dcca9caccfc92f7c7c21cbaacd7d781018ab81463097540bb6e5365f34a307c5f04c8c749374b442755e7071df0cf50cca3622ce85b1aa4e8e225460a401b427dd0bccfed62549339ea69be35b80df4e0cd42402c3285c087c9e11812d3040baa040c2f55e18884f714b031aa932ab99f66706527222285dfad5ca26a22a56af414f878b2bb73047251e76a9b5cf0e2644d4e3f3c907c2e45dc7ba58719e297d7ead43d0e2ed6494f134e8a4fc0935e3feb2ae6ec5f86a4473a46d5e8227a394f3978b2c3875f6408bc63305ffded77614d778527bcdfbfba8277910ca5970832b4d9d5291ef65be06d0c0c7be3265a81fcaa3426b5e82b567bd69b1af152b8675a06f9d2951087a078f317524579d800dd67ee6b9029b270a3f78e67a764387879a7aab20b680cb7843dfa3d5a89b2fd4021ca7acf14f801428105cc32a51e2445ec7c867711b39d5c606b1cb1e2f3d970a7ffd604051b33065c0e42403778de259df3d6231cdd052a7f6d6506b978084853081786fc92aa630a91d6b63ac1848ecc0815ee80a8e0aec8e7ed364d453bb9757f8673dda836ac930925dd2cf8f43800d700609684da6ce3aff327a77d140048ec4f31d40152882c5ee9e37b58e5110449ee54e1653409afe81ff61b3a7fdf31bc8c86d38be938603704820096fbc799c4085eeda45e1319312374fef6bb24f59ebb3dcb37e26d082607cc0739ef994e6fd5125895bc05f051b8beb3ad8483439268d65fee8d925eed614e747822edb3621b6fd405d59ad49ec96cd7ce98b97253a67510b30cc21c7f3ca1fb753d201e1056cea48dc4f431c75b6b828d56bf7643cbb60efeaa661d3244fafb897869a4e3efe09e4a7bf6e326f169b6e90f013eba3e6aa7466604d4e8cffb856af504c56c86fabbba96ac71ba8806cacec26d43b9eb76f1c697a0b2bc349fbffce20d0fa13228f56faf3d1565ce844a5968f4d48414e87c4c4018df38d22b6e9eb6b8753295ce06ebf43b829c00752ac0189536aac9fefdd56eca34104b0d0687d302b8d804128eb28e9b0c8996143ef33228deb204a36e8a235fb33c566f674731a4ea54353468a661a4be4476703a196f844fa83032d8d2f8aed1bef41ed887409d9925ced3833dda1397c497b172e3c0118afbfb87cd366aeb8c22ccf22dedc2cb5e0c51bd64230b3b6164c7ba6997dc442bb2325fe991532c598ece73fd348efea7ce73755c124c96d0b242ace1b30c1f3d838897b27ab46954d68e742222a2340b86889760e94df2f49ae6147eee38cc74d72c977977743fd91da55a27c9d6f2d25b562990ffb0b60eb8041fbf7239aca807309d2b4c5a5d64488bb5a5fae7336d2902dd9a34bb22fc9693de7aa6aa14606b4ce82380938b2685aa88bc758cb4bc61275d58ff1b3f7217fcf017e4c27086aecddfb1da1d367b392a532445f3c3629dc1f010ee0dbf91ac755b8d8f07650dc51db34135fe21198a808a7ca632a60a4e5bff25c27637a1f098ffad54897ad5da5ae76f538fc5b01aa9a470b88f0b4bca678dd224ff6ec162d611c9756184b80ba5b28ae48b78c55cd308accaa154ce38edeb43d2130515a8460ff0ab6fbb6c1d7336ddcdd2e9cdb735fe3c20d2121e337514c557055fb0246d656d6aa67bb4d153ac7c01fcf64e406911071c09a9ddd7c72ba5ba8a7032ac6667bec7e734ac6cb41ece793b1ba3be94e4aa7a7224defe81f7bc6fdc58450441c72b0ee65aacdb7e98142d81cc1a4b83592359e77881f6f1b9c624a881384dcfbe8b0fbd773f8c4bdbbb3d4e63c76c0cbb7b4953ac33fafb6f451cf96c35d54837be60dff3e580c8c8efa09316c81af72586ab6875e54047c399ea0d3bae1c33201c6548023e056a6b33f75a710c69480a6321aa36dc05d5ea2c40569c7a6cc5a50884a8098947c077a578e325d637a2b17930368e7e9fbe75f54ea0b57760e07688218f755fbbc11f0d98b9d27c8d9c5aa9352a098a1837ceb84fe3c87f7112740fb3d029b52ef52b3de4f25bc18c420e7e3935ee9e07ab9d51e6c2b6614ffc0b9fee704daa72d8332e6635a27c05583874b02ce2da2bcaced437caa1d207a291ed9974a2e78ea0529760441552375f3670aa2a1f340c2a45a92431bb8db9714b5e58eb43ed646ab98b5816b0e6db7120e9747d3f4fa8dd6284f861f3dd0c5ac1f347e8bc491a971f9f6c7b7799a8e1bdc0b9e7172f3d86ae973cb31642c2f7d52111c63dfb45edae070db0c7802d2c7f399154eddbd6e354dcbef8b510bcf4526aa6204e51a51289303348a25dc13e2b76dddb18f9922d0f51cc97ecabb0baef8c62eab350eca9665a508e32d02291d2f92cce88cab33803035f1ce6694e7b60ce27e92258da61f31fc24960d9df3a55cdf8b832e91827840760d58304716f1e3e341e2c82e642c1bad60635dcd6b44365d458f2b11634a4ef4e331ff97e29b256d892c9b9290acf2809cb74256071d580b370f561c0d14c74df566ed376f1457477a4e625d5b1670ffc6881e2b7f71bbc4755f7564935dd8f594ec20a00ee419a21870d9c7f54e861a807302e14194b24df2037a6964fef9d67dfbd3101c7b30dd69632fef8a2030e59c92d0c7b0f0edd477d552125199743d719e78a6cc9d1e31cbd37992472339885e5175dd11a475597e37953534217122e47e15897dd38fb3fbd6c5a02247fd9306437f0e6b1bc75d3e96a764b4721b93a849e08fe81dc7410b03541728a401374258be4c8f11abb31592546657a91d61e8dc79aa7600953c2420ae328daf72a4cc801e2ba932e953baaf6fd89d4bb026f23229ea11ddc7f3b2bc675778a3c7c483ac42008796ac657365ba147783410f8fd057e3e6cd549c9715bc111ca20eb12fd0a6b298de243b95a3db3fb90ebacf8c01ff5405462622b482b9ae59bdab532cb9704e1291fb40f07ca2a5bab0d8d0c21938fc601d3c6a97a69bf132ead2699219b7ea82b5c39bf7a9ec07c2fe29db87449ad02ee67fcbe87e1dce9948b50f313543df926dd83f52d43663b2ec4233612ccfec8a0dbd78b6f7872796b651881f7a736529d71bec2da3ee85cab58557bb125b40ede7b208243b801f2a66a942c835acaab73ef8dfd479643b189fbae54b28385f1f7408bda44338b79b64d0524a56ad162a1c2ba1ef5d310541cb92bc49e01e03e6d605d4ec19cd3a0b06776ce76a65793376ea57468c293061206fb86c9c0ee7e7ebfca103c9372e6fb9109a8f2de0817a543e07a710d0fb2d28240c6dfb6a30accf02815696ecf3a00738404cef67f2fe31a336ea8ee019b3ea11581876887449ec9d29f5e2cc243ed4e76f17ddd23ecf4a45f8f55ac7d4b559f955fcbd666332aede5179d802f882d4979195e38cfdb148e39ac0137f4eb263d25cd464c6930954ca653bd1c8b464f4f6dc5182735fa2673b244d6dbd22f016116ee5cc542886cc3464fa7a39436862c08b1990a774805c01b13729e5da574a8cc5a864b22da73bf6e656f6df5f75d6158bf5e2edb3c24f205ee2ca9c88e63c2bef57b1771c58a9ef46c81d8bf123741e97d6b9ee1c8a6e784afe0952143e349fa6913735cf33287e23f41f1c04d409240ab3905df5a3948853638b8b8209303dd14817d36921a6cce1e9e386a397f87ecd8c5544488365eb2c5ec74ba1e845c9c7fdf4a21931b98768790f5f597d4b0fd1141b3b199e0c410d4c5633913a1e4d3d5bec77e400c3ba944f67d24ccbc98b0d2f4e624e1c577e3b8b00a13952343e32a3fd954a6d8f4012028e9df38934ac142f63a7729d94b30098201d3de7b00f581bf334d6bd25faf03dad428d000242f1fc801bb60eb3ce25e2f57f308d38f9a60861bba5bb21f4e516d8b3f1c7d417bde8c56a442c5c5fc0a878b87cf4f38435f2eec500a5db26aba115bc3bf12c6e8693301c0445e5eab32173f9065ef4a452a6038d0cf0c6aec99c920cc92757b725f945fa67f328a48e7ced3b4449024617a3efa5a517277ac4701000186b177ad42ae3295283eca10a0a9c1fafeff9f2aa79121051bc01f577aff6ad2dba44fdd6cbe8cdc7f5cfafa0a44e683e7d45fedbcf520d2a7442fcd95ff2a98d329bcf4f10e84bb31e304cfb10a49600cec2d12127d92167132fd7e3bd73a2182d333defdaaf37e14fbf818fcc6307f6911f124fad3cf5353e37ddb87b5526c7d474731934e44e093d36a470ded06c62313921370efce941f6ff3cdd61c557c096fdf81edabb20d24b02b949bd8a5ef9bd1ca3116768ee9eb34b49ca44b7e524faf79783b9b44ca5305b9cad66751c3737fec2fb8328920919fe109076f9d079d3152ee49604679e0f27fb2e4f20eb3dfbc06d655763ba182c5855d8c099040f522ff2d17489588716d319867259e513809d981a3776c50f57a0fefc83f6a9d37d2e679ad2eb44b73832f49d4f2a71ff66b510f5e14c6f4f5b12a66e3fb29b92ece0292f469e54f8f520fa7000c3f3624c6d015955171da8f3198f82fc5f45f9120ba422a04fbabff9b086d6b242998529503706590586a9f55b0a280856d2785c3f1cc96402aa63592959a9ae0b1a93d43e25c7c9de46f646d763d2fcb8d70b20f03a968c023b6bd5ff06f7c2d11083e369f84c1a28c6ef17a88a9005d62b19d50c28277729846997cd4a60ebd6931eb64d9ba5646771ce23a1e0de7f34770ea35f46bccec3421960d03da909b3ccfc607780acd3a64ca1b5be51ec180e24d5117585056f40211c6b9f75323730ba466e18929c7f5de4dc06a90b0cc94764697066869324f0ad18addd247b3f273e55085211c92513bc1ba154a48e51f001a116a78792de55acc264dc174b9d4ffb0cb85ed9c75089ff20026d1f898f9f7255d3576073ac6cf18c18cd1fce284f7ea62424acd114f28039052a32fbcffbf2e352019ae45fca09fcc751ba4dd3b067e16b841078d3091991c9a58b1722cbbb18b355a3c4075ff3324aea26fc7540cb0da15b6e5b776b125dd33240bdab29733c70e3c2118ef8ddfa3897b27b41fb5f76ad7e435939adcdc85c1407b91e3385ef7214f96f75a63dbb6d0be5298274ac66fef0443830e43c25788f0d398b512b80a553a89c4b1c7597b82a0b1247f23dcc1e5fd02f508089de2b1b6616decf88cab8b823bf021f5f6e26ccb0baa4f53bd9ba27cce93cef03c743b81cff1b361d50b1d45fce780888879fb269c420734dd57cdf06c08970edf86005798b3d653b696830b2911e67abf4f212f3eb83df86596c586b0bf9a84df4f58f4dd2e4f37dfe0ad59912a6d2f0e1957d239d1baf660ec32c382adac9cf743561f091bc6a16e858e7dc883b8ba523bbd67b66ee1813e5f0f820237511217ff17db301c53f174175ae6a2e37f7b5cbdafb4aca2e5ce97f55ad51255cf78e1ef5927ae7deda86582e9eda46c169d5f6a205f2735500320344e7d3c4cd8e85c0b2e1c3d19b13f598f5ad0d876213211743443d9c15d5a05c733e93cfa2536fb8499975dd1d924eb0c85e545dc87840cf445baaa048ca8a545dee9ad9b626b869a326f9307ea08e4feb7bbee7d4f4b9892924f67fcef1470e1a35dfe9e8a2296f2310456d68bd7d58fd690bbe10f9de04870c43c100e7a13d4659dba892a01fe3d499c9803eab6b0af251b1109eb0f0461717579c0964f02fbe76d0a6be890523e59e20c3dd865dec7eae9069a6ae3f2bdc25302de1d8371ffd19416a5d9c1895716ae5c98c0837230f5e1e52dc35463e4179a8220fb05bc2d34456a54ba478babdfa7b62e368d022ef967d990b01248c8aac651a625bb360fe7156da72917c0aa4c7bf6e59149e4028e3e07af293b6854a0b622c0beaabc63ecdd898b01e9fd030ba35e61874a3308b5be16b91566f7110c250b98ac1fd3722c2635ca0cb7e50d0827de7d4e88aa959e8e8c486b6eed9b98a4f7ddc04ab33895bd9cc7d8fe3de12dbd6173fa692cda9828bc24164e8c81b6efb7d6e89114b3e0c276494384229cd13b098c7bbd796402fb61c40d75d4a85b61e2859ad48fd6faebee1866d96f0b7a22bf226115bba7d261233bed7639fec51a4baeda8d9c42b7209bfad0a8991f6fd69dba8c2091e49cd5b16fe09fe17fb3296e81aed7e4b83097a9d6e694d8a79fb5447914c64af39c5fe5b4a2f7ce87763b1b54dd2869dc11f3027f48aadc019c9a66a42e1afb3225300e8c886c31a6116a410c499055946d1af5d07cc38e07e9313ce909ab34579d413b13bed7bc77ee69772c8d4bf03f269829070edda145ca98e75beb64ea27974a6a9f4099acc74e97cb30dfe8d901414c810f657d8578802e5ba6f73dc3b1ee46c5b138fe3bdce2000e8e3429e2ceae163bd238f49a6a2e10259ea0e45c285e985bd73d6df86c09321c50244d58cf2de038d7149e6d6534023d6043a322f144d019b3a1dc1fda71c8212ea908c51808656ad900bc701b4c016cec9e9e6a82752990d0a4e9bbb17e0e621760bd98c2cf46ad3a7e33e0995a1668d12fb587bcbf7fcf49475c53afab83fd2e5352d885cbe53719e133cef9c76dd871d0cf5a0d034767a4847228961c05a2da3b4000b7c226afea23bdc97ee35708253516095bf681fbd108391046938c1d314e28044a77e0171b26fabf97d046f73573352d0302195ed28669409c2475575795e37f6faddfcb26403044a6b0c60f561c62dcab46fcbdc37e86cff14f7114b8e57663789f93a7cdcf46b532a6b58a43a52c424e0812fbf55ad5f12de00042f8535e6e1fdf69aeb488059baa109cd1798687c12fded08bd217372f8af53ef75226136168a65afd333f7a92de7ed34b6803e55f6dcfd2550e92ff184d1d47e6f1da5e94f387cd10042da1fcbfc6ba6fe2a3d7ef479824b535c7c66b4f95fb59cd3b82601672c989823b27bca6c8d5f1851a7a426764e7d7e7d42c05723deaecd8bab482e3a67f52834faa7c0f4f3bb86bdb35ca47e5cd551a68aa2987d813b13edc038f6450557ccad3c91c830ec20547653f009e6bf3c8b6d638d1017aea43d398d0fce6e541230c28a0c10b83bed5dcc0fc053b0125da67e52b47f16ee8b9c0bf2a2eba3194c1c2305b5af82aa89e4e77070970d2698c85e5800beb217d6ddbce304fdfbca64961aa6f22d6c17b568bcc97251c00176be58d71d2b63412d664c655017599a63579607e5be5aafaa35c388089dd13e08413ee430c999afafcaad9690ff64440a6ce45da13dc846b684397ba92d25b825dbfd33abe5fb833763bf2839d55d6d03109602fa0a2abb33db6181fea7305060413090e5340971487fff518b71b2f0044a9505d903bd61ac7adea801f7e5a29c4756a1f853ddbe50c1daaa19e80e8bb13ebf57fcacbd089ac545c7513ee4c26bc2e97b9b9b5741fee9f35b5599b02ea627d42ae758fd09f83a2cba35358cd77b827efc220b33b0adf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
