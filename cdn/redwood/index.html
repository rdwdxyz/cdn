<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36033a54119358d066efe081a5c978eaeb46571172d6a103207e37a37b4f93d8271316e66cbfc27239f0dc275bacf0c36433c8e1e79e3905670b037582937fa65b04582b1154d6ae0382231fcb299fd623411a3af3cfbc7d3c79889abbefde336f2284364e554b34fdfe2afbf476fb3c5a7d849c892b069d4325882a0c030b77a66319296e05a526f9f0b1a145436c4fbe9fd72a264d15bdbc60273a15a63701b13ebf557c421dbf3a1771983fab56850c89b988993a6ab424df221d8decd10dc345aaeeb970e6576a4ad9208278cc38e4108f10a92808a61f9f9c1269a9a9bc15878f2ed4edd8bbd652ba7970f575b3e2819e257ec168099d62ac9f13c0ccecaa259b1e46e361c69def739800431ae36703eddf0a2b54f3309fe74e8fd30ee34957e3b4d32b50294844cb524d3aaa70aace143cdf8b7b73b87cc4c573893ee694893c01f3b8c153052f440cb4385d54eb6c99d01206c63bf35a56af7356f477e19c4fd535a69c0c8139b07c96e9c4e6619e038ae1f5f669daaeffa852c0cbe8c195e2c575b3437892d20e561ad07952a1ef92902aeb68b159dade0ca79e229c844f732fd6726829c5f1194e032714f2ceec2920646d08110a979bf9b17352060812a3b694a29e5778177f3ee3c9975b7e8a3b8bc5d6e214831c10a139bc10519617f92c206f2bd5e327eae9cafd25d3b62cab27b518c3dbf70c7757299b74484fa3aeaf242693d00c7280b8cc3a32c72e2e1a0ef34d3d24b844804c88f7a2b80c73156a438556220fe025f05941c2bf8c55cd50559a7733f4c5593f00256a97db0f6125d17127f8f29ec965b5cdcd5d51895c05f7602135f81cf06ade95b80e105f4bfde4bf7081d0abb15ea7effdd67f2e081a066ac4faf2c570f8ce3a8e14600dd97c36a265976f80ee84e85476e3936bdf01d676b8b76b70d928a59bc181ecae3a6bee194315494f572991054b2fdff1de15d8ff46bbfef793864ffeff0a2c0d3dbff3f8200aac5613fae5c0132d270f34fc5ea428d6455db72069343ad0842901a7196a1e5ecb4e302b1898bb0270904b0c3cde7f214c4372c1ca07686299babbeb97af497f60be5f16100749bf216a8a2fc12858963e3e154e0f842aae1dbb53ffbb14d716796189f1fb660ed6e09514aebdaf9b1f1ec59738c512ffd5252ecc16d6ba92f78044b61b586133fa1cbdfb40061097f63aacf3358657e08375e5d5aec6aefe0255dabf2c66bd965355fb68d63e687a060967fb1930246ae801bec1f66e3b308c39ff2f7c962b0fa861162142a5de57fb80496ec33db718d410740bbd63eedc49e318d1315ae1c90f3e901e2b0808f60ade36c56970b8dad9ed4d6f161969825a550f1b9b70ab9171de6e236a7bbc422dbd62d252f47e3a9138f621f17897460c90668254e6504071207c69c0d1287870f73376f66fdc4603e9fa2396063508d102bc6d92dc355dd7b04b09dc777e16d508cbfb1073dcc72cd68214f36a777c28859c050175c189feddb2a5720d43f146902f9ee7375460769c2bdd8a4cf930a3b1c292b176735f8bfacd5dcca6b17c308c1466e01435dfa81b1543edb2f4ea8695b5cfe27abf9b7a41502d5f7489144abd97e0f356beeae4a18249cce468c3326c66ed055eb43997d844cc7fd2f041d8849eb48f435167312192d4acb01eb67af726b5c526ac72f90cf9e94ff699496f6658d37900df9a1dd8ba351eccd3f4d9ad28446c09b2922e8b91153cc78649342dd164d398193ce30b7ab97c2060d39d4a981fd9ccefed4c37a2734c85cd9b51f1555985e5207926be8dede72f8b25a913c75627ec867322f0f75a8587657c7f397ee90c712f6e1bc52caca9070f66166a62763f6c0d5ceb7558023ce23c6e9802ebec0b2859be4fdfb3fad2da58582f04ebbcfb5044153306de44b0530682020a8d0d81ae80a4fb8293237a5ee41a6100414a62941a44b774f3a4ed3dc7e6f3fec8c55f823090bb285ff2c36b5f2963116278f985e2d1aa1c93ad82aad6daef41965e79fa0a61771e186e919e9cae62bc939cf5b60aa4c1d14b931b64c8b29a8d0bcfeb204a1b23e14e6657fab97c30d488f346182bf69ab07d4e13464c42cca517a8a9442f870cd247b57d169cd41f0f6f411cfcd0e07503389728eb539aafe6517d3e794d37f94c16534eeb76d2dc9afc846589430cf0137c8d69732ddbf6751b2f14061dccd9c12f31b46ddbd68374c5b55194e82e9295d12cd535dd14918a15a739ff24d13fbf79ce8d88cc829cec56820bd2119b8ac293453f943895426d1ffcf0c56462055354ce68f7c85493708e1fc6aa85c8a14f761d086fbbb89835b8e167a98f0b3252ef9530644dea22c89c19acf1207be884aaf02f87af682785a2c99307d109817ebf694d17d9e90b7c42aea778e2a2f4c6784100685ad5e0790340ad331d28730bed3fc8ec79a4a2984b1e1f0ee4323de849faa076479df27bbdbe2199fb27563ef8b82ac591decee78b1545ff319c865f3f537b1d1c522104e8d7b1ebbaec84db782bcda281a6d6b19003379cda3b8b646ed0d75521c34c68be320b7e29e861555427b242e6a37507401d91249c1369748aa0392789f320e316b1dc5c94b772b06d65786c048a5c9eafb7e5bb6ca406da8da2f992ad975c023706bd7f2aaa7a2951c8987f8c27237bcea4633de62ef219c2208c5c865455f24f8467ba48f849eabdd5fdb21872adac68a36e97f0dbe1b65a637321db1065c11f2592b58a840e90787e3a0076e64e2e99b3d1366753c8c2eaa50306249c4cc8da861316a2794e8fa100272907ce04bc17644b89047ccfd1b167a11018d5dde8701c169a367e691aad622761646b454ced3bce72dfcda06af17eec6baff91c39ced974a3acc73acff9bf29c6241ce8432d96bfb65696feb63003688c1fcccddbb0e46e0113b817cbe2ccaf718c40499f0e05d424b22adb53ffad04fb5ab31e1b0ef47db7679c8096009b3d49aeccbfafc8825c78f38d4f266bbfafa4de920d8a91246ea3ec040884b3598078c63e83a3b1f7aa8528923eb08f5207f6d05bb3a68294acce435a0055519446e24fc5096cefca3fdbadd29c51e20c18ad6ded281d91a47fa10cfee58d33483f87537a7053c2aeb900e9783407eed0586a373170c42f6479858058c2c316353ddb8b40f12a9d06526de3dc1904490a6c0621e19ab15be2c0aa542ae8d8f7b7040aa161f2ed7b1c70a2a322a98f2ece894fc9586f4b7a7b55d693589b5c01e1723c0e9561e9db275bc4dbc1cc06d55e3520e806f141729eb3850eeee1f786a1adc86f60e8e50f4374425143fedcfe605e7a76acf19835cbca6cc7fb129e223f91d538fe07965754aaf36828acf442c400144feb16f4fca46005d4ced97a62b1264e1ac5675251b0b2c7bd1d4edd04e7700411f8aea49ba98da7d266e940295591028298e0d87c52cd0505c05d44c045853d1bad485349f2a5850e15b4090841268866b0af337f2eca3e638f70adcd4d4bd8ccbf13b9565d6efd34bee0d6d8c860ac6455f13b68446f4222bce22ed79387ad2f509e0c47b7a77b8cab08e822f157ed7d0214e9df59d7e3e3e2e0a452e2c3cb4e803950d8a0323365fb104252c63440723a62b26754fe63c93f4aaf8f12a578fe6cf263bc2e15d2eeadf5736e3a8706e4b3060c8995c706583c54bb071998edcb5bdc9bb2d3c9628b2c86cb3d3df50378ad53a6c8b51dc0635d75f6e5a07701aadd8921dd1aeb8d50918b0ad04087fdb34b29bd0e17f60b48b0d16ab65464d75e8dd2f76f54ffc30dd4e43f5c42298b06646c3b08c35dddc7d25874511073c8ef9634018363cf700cfcacab66d56dae619bd6d759a366b9539591eac74d799ba914adbd31c880b780d1083674c5c5e3cc6505b560358732c1d15af322326262cb89ccee6d5a5ae94609c8f935b1fe212aeb35e6bd4fef36e8f2c8d5a371fea6292ec043f6ed6aaee312cb8c3c86cf6bf5a856d2182b8ee911c18db3cf53991cc31f6d7bcc1c1a2e3e4c28093280541fe0bac13baa9f3dd2b22decfb0dd6461fa45c43db6ce9b94542bca2d8ce1149b5a70b4416f96435ca930026db1201a97a1ba51698dd3530f64134e027bc63ab9017f268758b01b922388ff5600f012f5d13ba650229282fd95dd371014701111d09cb607bf7872006516776a67ea5485734b5cf7dab9f45cd9ec3e643f9e2520f94ad02d0a50c0c2f81eb03066884478820fbaa33049878f79d7e841dbb11cf21a996400436a864f2cc7b87d5ae7cca7fc757061c7e7598232c4807bc2e183df5cd8ccdd4fafd7fabf7d9190d998bb66d7928f1cb45749100cab761bad43896736bcbc052852bf779e7ef6f332fc1c60b46d4d51ae166e23a01e85e634426616ac1226fea48cd652afde3290d45023007e3ceefd250c81ecb5796a8e9cc8dd9d2fdc2caff2dc2ceda32736a5c9edece5f603f55cbca86e87e21074c736cd7306529ba42760740772a9d6db9b6e98ec5ece41f117dd6b3c8961d74541e48f40345fe2899ff8a3dfe8a1409f3318560c99af240da0bbe9eab691c53f479d7589da60c9a3e13ec4d43b02fc9e6dfb84773c3552e229775c967ce3ab1efc68a2ad603c5c5977e0f95dec7374c86c574254a90d0c730c6419ce2bc30a7fc7990703714d0887531edbfbde2fb7d4bb8db8d2206393ad8a32b0b3b44fff4aa94c4ad1fd1f2dcdb9fcc7519120eddd5155c2201e7cd94de29503a29754404aa7d978effa9e50a0f0acb42a2cb49667a6b1a5f00019be27ef0e9427b889e4f430c96ddf6f04ffdbaacfcc7767b7e3cde4cff9d8777e0d741a4f8a0004ea5818b10ef5df317c4aa819bc64b1b70d097b40fccbeb4f59ff7d7c03427a6c450909812c432dfd33333cbf86ba5f316673fc47ef62ecb20b93906e5a75f05b6eed6a6b798d092b96dffc4408b374c9bf8834065b5416dccfcc40c28eca85777d6c3f3719a6efd7f060a0cfdc4d3a272c1b3a07ca58a0689bdd3866ce7b72305350480cf943565c336c239cc5e2a9d32bf995fd8b6935601f7f00ea188d5a885f7d2d45cc26d0f2b27833481999efb41964abd868fab71758e21a5cadc53eed759bd8b720ffee3bf373abf43082f68aa94db10e70335ce3ee1eef76bd91dab63da9674c71fb27906dace87de62edf2c517b698e673ffeb243f72f2f19099eb44843eb547f692b3d4ccbfd0fd5692c664b6c88acf5cb94c88045147e69c1ca356254eb29b827272f97eabf8198c8ae04efe3d4b76ce2164b6bf42c0fbe73c6009cd0f1ff004410284d01f208617066dc3a2333c547fc8431436b6f14e157618bc39c2bd33c79973e500d6c46ee8b9b4f46820e94ba659f00e2d53c114ac59a0d1ecb6ceef953c522e405b312626490abe35b970864f8e362ae599d3e74aeccee296c69960225da37d0c21f07be0e54ea74640c46d03d82ea4f1a9f19ba517c2b2c174538e9a9ff759c30a9ff52bcdb642e707e9f90767a143ab12bdf6a8066648009b384847f16bc086768c5bf79fa3e2f48ea26a8e3b1829f0ad7f0f5418509c1d861a8937a44d1a997aa06ddd0ce5b2a4508cf5391a77b6a9f8dce275bbf5a016fa4279ee22485f08dab6176c17563d20e0f07b1f68b648c0294a29c5f3c72f16bd169df1960d0fc1481ec27009093e65ce7c62580ff999e8bcd5c9484034e359b187c42a207720dc0a8408a96e612783208053776c5bd6acec34c05df08af2a4483897ba866befe2cb7e7b51406fb229526a796ffe32cca9b666164b748d3658a38a48098d15d0456900d522274ebacec5d2662abdc46ca445e6cab27787ee44cd7bb8836b977d57e042bf582b8543d10f19a551dc51c71b055bc5ced6daf338372baeb12a9ff5a22858910503353d638fa96a34007f6d6caf9c8163cbebdda67380848a1602e077925196ea3604963d25bc5c2f0533392abdb623051529435e73aa4ea0b1e290edfb877556bd76c22925ae766f7e9f6bc3d649b2958f67749ee1ee4a42cb592b69fb43d4808a4719ef88f26cbd79291daf0d761fd3bed253138f50466f05040219c6b067033a2be814f44bae9111b5bdd0a53baedb71fc572b550111424829f3d5eea400d842765b5ef6d946c9754c72e283bdb52d7f5d5596cf8b4f84b6d602529de882d2e9d383d3065337e6b17998abeb7e7e82e4e1923ca9c34f2ef7db7f52803ddd94ccda05ece50c46eb8e943483a4f7a1c2c566eac558d7cdd016b550d20a68f76849d3853a463ecb9ae1edd23d3d3848168fac040dc0afdc55aa02ba7aeabeb3f0e56ddddc68b7c234bc5799a846f62e1f7ff60ebbf6e536d4d2b2fabfd8d8b6498ed52275efa977a10d857d8f7d8a3164d63a2bc5f82e9c73b7727eb35b0a9ff0fea5d3062999fd21f1c886935e6319e578551004aa5014148e076a1e36b11dca0aeb378a8615c6441f620b9f1d173c9cee55f60fb5c27220503f2b50e1d15346975a6ceba998d63535839a3be22e7c588203901a4168474929f6661556de732e346a47f9ae9986e23f8fe2d9a6fd1aaf25b26fb4e1844c138696e263544bb07cf2f1a03a14803e60e002ed07bbd86831d839ba694e5976c5ff8566f6850ea3ee8429077081f0f0bdefc3d14dd1012db3bf542bff17b8d14bbc4177a34503b479cb3d50dae44247e4a4b51102a2c106e53ec36d69fa9e087f88b3751de34f313d3fc6386b3171f2bb69e2e71767a75337b3c46a93bfcf704b8ac59d7072a97df6a92d84b3e9fbb8fb98f2f415c10493ef7f356157b61b8b69413763fa9083483b8efe81ae422ddfa3e64c9473caade420c8184ea339f52c48276336c629ff7365c431c692e2b0b23fdade0b209ce57b73da99ecab958fe6f8c17f4b34da1ebd2a570ff8c01c8fdfa575579bfc563fe15ed34a68658e5a9a6b63f42491d76ac04a70759171146085ecaf554f3c3097c31a810865ddaf6cfae431ffa080059f7caefd914a2ea638b31d26fb491277311ae2bf12f5fade3d2076497246b2e673c887919dbcf8d07d5278736b65c6b8f0bf2b7ea8ec67f9c34d5d4cebdfc45b5ae0a1a9a2ae8ca769e18f5dd179db078f598f171d718c37952789a9f647f2d86209272ce3495b3a2b10f58a9b64a7b6613948ac546def8e2d27c14f63bee28fb13ddda065bc400120495a18ce1df82b49f456671f7acb2fed7a63204036bd720b583c85d51c505ee1c9e24d6babc90d36688be7f8af21b0ab0e0f68d2806178f756ccb645e21c44e9c27646ecfed6401fa26fafcf6faa81ef079b9b9dd5322a7c34229fddff7ba815684977bc6d40e732e79e77fc2faa07d0021a38da5d942edb5ba8055208715b2744fb3cc243915c79bdf3d4524d8af3c67094752f43b27244deee08e5b7cac5f101625152194555659d3d39598e18cab87a65ca820150220b643d673a0af95a3f16a09a46fc6b614d1b5f501413764facc61078a54993bcfd8ceb4f80ee61f6bdae66eecca95785aecab7f86ec0a46ed6c24a359e5b3f08504def4fd3e11917188d789302678fe764ffe31a66ff572ef4e3d6a017ff9cb732cfcf2be657c7fb94906421677a829859b386ca0de8f60be08222b7ab39dcc7c0ddb5e1d6a50dab486127b51e085218d9f342e340fbad67f82f816410705aacc773d6b9d1df96f1ca83462e82f50091d2135953ab2500ff8ce032f203a78f4b12f5c1cad1d6e460d1c90bd4b898df3369ccb1c14e1faa3d58e90fae3ec239eb75c23ee4e451a43707423205d261cd6b340f807ad10ebb6509fa03ada22af61012ae7aca1987faa40419f68d46c1c364dfb5c05e9b6df473668de77f759b9d9b9a32c2fe488f2cd3fb3018aa0330d7e7121bb927d2ae1bff7a3384b57d32c86ae86c7e6b184c6b2c100f306026b20f3628bab14bbcbf5844eb8d04ccfb4c8a1a7d8484f895f2364729ad4e785189ab3702497de8328f580d28c54dfa5ea04c924a5d1be070597d528098d1b3ca9828ccb6a08134ef258ea08721fff54137d2f9b7d4f023d8bb744fc4e86c5ca1f5c8fdde14d5b46c770f8e4a4cbf7cb6265cd82722b2e8fb627fb490eb711267bc984a2d2e9560422b3bc60d0a9b0e971a333ef0b6a63b5136c8bf21e9d9dee00a41ae9cedb040c0342a9b67d3a2e13b13df9bc531241e1c2f24498078c66d8bf3bb3d833dda0181c2dfce12fd198409c875cd0f69809ea8ac6ad70d90f97777bb79f2481c28a545c28f1fbd06811d51456df624c6c5140fbd71dbefc2216a5496fa30b6724e6946b17b80a2f5cfdc5fc665e7c5f10dd9f7508d47453642ff5353a2ef76faefce98365a7d8c3147bc129f3545593a6e71252077eafcfb352126cb1fb93c25bc533c679c10d57ba80d43990d22e5b422ecee2149b22d9da2bd7675679fcd5b571d7a8529ec2ecc781d8318cb8c036788cccda53ca08492c680ad4ea81f1ba93a513b4cfcf09959041cc6ec996e70470d2a141426cde381bc4ee475a526fbf1db1df41122e7f15fa80a9bad816329ab3ed4849accc0566ebbb688c386d616e843e1b3eaf1562cec053675f8472a3a8fd205734f3058672a933039b9e33e41875ec91ce8fc1c66a44abe4bd376c747ed6fd9be131d06c7741748f2dcfca438001894da9102673f69a60a9394029025182b9ae3e6a472e04431daa86840b22966645672ae9389f8315ba28cf88ec54550737e01f37af565d16172fa044d730f5435fe67e6b0c14d5c47f3b3ff30b345a56394d26c30cb535e3e2d90eba40e34b07d6ed51ccdb4453efabc663f8d0484c371d3a219c8c8e1d5f6d99f54039cf2117a8c261ca915f31d3091c4b85e2d4ec3f4eddec8bf8abb616180e84acaf994e5412c7711f3d760e5d56d3bce8ced963a957ef7d82fd63c5f074745bba4a7be0ec59ed9b282baf4fbb04cbe4f2cd536fa235505ba3a4c7a5f38bbf4e48af8d8c5f6aac3b0a2461e88acaa994fa8ee6796c7c12bbb3226ae7f6bcfe917354e17c237f17def051436915245f116d8d22b5a4afcfbc3316f4a526a31b2ecec7b0f8728db08f3d98e7c90331e17106d4924e2f88ac0fa1c0a13064d11e3995bd7307342fd079c0bebe93cbcef7337ee8a39cc17d25dbb133fbaa7e9aaaf45a5fa6a0e2b6c97ea5f680b104d0e83dc04a91e2eb1be6b2ce7ab5b03261814391efd9c1b48b881a53747ec2946e0333f61af0ae8b88e674ce5807643acf5998ea19c0c6079c8e7366f624c3f9eab7692940e6d01cc4c5fa14421b569a376b70736a4d6a1703f312c381b420cedc8110ec026e93a924a586a6c0b706a95d0990867294d4e38ed1ecd1ee3405661dfea3049175a5c5cb456fe768c8f63290ffb4d2ba5b3a2fd2dfb386bcf7f4ee517a3da86040a19c09c8d8a1f5e7972011f156696fbc1ebd34dbbd69c0977dfc647036b4d7b8e655ed39fa79c8401ea359ac26cfe59e2c29018529f47d4e5f75d51183f27d357ef7b0b072dd82931ae771a3fc2700f3209fc09837766255f13746d1c50a48e53c543cdd148a0cf4ff2b861d8e43035b853614bbb9616b00644f363df37ef68f757a6445d52106560e57c4a162fe109e3f1e9c682361d2d1a65f33c7e9e85f15bf578a9c1828fff11b3f32fbf0a377d126ba446f1fad2f7ee8b8e081840d407a23eb4a3ce4f0b032c337385de1a7b4964658334a5aeea3048f5b61217f61b9b6758635736689666ec55cdcb33d2199b89ad5c4403adfade0d4a885b1e81c1e8c1363044c61ba4a194e23723325f87456ef2575fd88ceda69c87bc05476b761fcc5e6f4e872f80c031bbad95d1abbf730ecf5c528e2700b3f0bea6dc7965a6247e823cf69e0b768d430a98c27a851fddbffee432b182f261f11c3f94782c5e9d54d6ab4c9440551612589c33a56242b06436d47691d69e7ab7ff9aed46e71d798abed4e416dd0cc13137c2c7030eb7149f5d4e3f987aa161298c3611992d802de12b3311d1f0e3a749d7c45eb88f650949a56d135396420fb39ac2e3d8d0fa8edd5a85dce76cb053f7f25ad4cb3db1bdb149fbf075ce691f7b064d617710b563ce1c08beaf6e425a62589e159eafd0710514cce756666ca429159bf3d5084bc880bd4c09c30977055a5bc82f2d168acd4cedb4b7da8b8a0f79218da76709560d284473dd89f5c43b6f20f410a350e6ab9c0dccd83bc619ee60939c8b6290405a2eb2b204fa54d878832d8ef98ae4c7804a0150823aee395a1168a970cd6b4cf3d6f32edc12aa0e1b32719e7d7e40b3648dcb0dfc101f8434e5cca0bec24ca7d411e3e5faab534b5a8e3b5d2763e2879b707ac107bbc2755ef8b0d30daf0dfc77ad7f0d930b74146084fabaf67d4b7a66f5984638f0b5fea2fc90a1be92eb535c0791e643052682d4ba81cad05f82b17fdc218d2663c0d106b15c66b4e998ab7f069745d5b16dbb0eb66698ec65bb5c34b529ead7cab75631f8817712ff6fdc2c2cb3bf070c9033598b61e8820a4c9680dd06eabe84d2a6c2c283d7f365f2472cf1e0ed09b748c323bed2d3101d6e9027305de66cceda1efbce40d6dffd434bd09eadf0ab3317fcced296176954c475056b5398adfca31f72f9ccd88e2957a406a5a2e0447a00d52e213b20c7dddfc242ebbf2e1a3f0b8072977ef46da69bdd3b6c9bd7a66dccddb71146c23e532a1992688002b442b7ec34f48126de6dfd5fbab797b6cbc3e729641df903a86016857875187f343b19aac7ab0b16802aca492d9c6b9f53445a68d2f15c01421aa05b377fd7949a7acea0b860fbb5cc93ee2753521ee586055fe31576518435d104e07155d2b9ef911d210323c0e5189f9610b6d0a7b0b911cacc8f5187a972c3ff67837066aa0d5c857a37100a65fc52ad1d06392bb659bb782ada9ed229a2ed424ee4d2d988615b0e0d990f5fcafa66033aeb26ecfb5712ca47d0c97ca42aa77a839c7797ec4e18d314548e3e94e1909a077a49aef26855f7814874ea7d999f3a50f052703eac492397ab98ba13b3a901db1d74f6842e04ea25de900fb6f709661d26c82eafd437ff091bbc67c8c21c680d40fbcf55d37593a285b85a77639f6cebf3a621802697211d67849f3c4fee3271ca18b616e0cde6349b2700567a3da3d1d7146f189f6937c7a44f8b0cf8e10abad102946d0095032ac5bf1c8744ddfa374e48da79dffd6c8894aa68df19f1955c7131d62042662510cb114077b8195fe1aa6e38332b7f5733dbd670f5236ce5d5dbe0888de5fe57dcbfc194bc3750e55d85fe1a2b878b6e9f54f2a39afe98365b64eb17bb8fc4ff41f38cde4c2c349d17b6bb0d2eb877a67954056eab9c5470d3662171bc376c2bd864693ca599912ce21dd80bb4d4b378baaf7830161f7556231f7f1425b491b79a6d0a8b435dbe5ae0631cd1ac27a9802e4761334132967c3a9f17d243f2434938f814119a1b874f04689ef517c8b3cc31ed915f8d3a3101848aa8897273f546b92bb662aba18b048f4ab219e89d9f8dc981b0971ac58ac80c3ba768b6d9aa4fb2f7198699b4544d06966d5798cea4ac2192973f52dec14a4688468887b07275356d14c36322182e1d40ed21d702071b4a34716ec33c6516c1f5945a23132eefc91dc0008eed6b4a7bb1ee550b6e893b3a6294c3c6b8537897098553dea905261c12060d0b5b69261107548ac536395bb729b414c284e94e8e633b4632ac7fc27e79b8ff42f13b58c219049c75a755de75eb751ad6e3f43445962d104164d7a5df0e2aacaa0e2ddaf2ffa2f6a5bb3f4d1ecb7a0dcb9669384dfa22a4d25dab61aef1d2ca39e2389b660101922e00341a1ef18716f6f2422cb9166a17af1e00abbf9d324dd7be3cd23bb243e2ca48f40be97edc0688aee72bd251b2cd69ff9d45a9736cf1af4518cc9698e2417415efc5085e71da4025c6eeff18ca8c5015f7cf2dda374701768976f290535e762f0d86fcf035680181aa282f44a1ea3943e5dcb48ab82e7667e512b00fa0ba5e9ee899e3a66de589b83815b3ed29a70587e5e375c07b4e3a10de492968836ce778621bfcfca232ef2eafa36b90e2e74cf9f8f1215721f6ebf9f03d2325a7d0d9fa2fc0212362cb051a2cebe027ec0f9068c87f895a7f35bb48dcd6c2c4ab65454394691f5191a50dc740fd7ebc816319e234a162d18c6543398f5d03c0d7de3254113ff42756f29f8c3d9fceaedf94e555ddfd4427b098786091b37229971b2240f3e03e4b7c5b24eac4acc686654b7dfda6933b30a796f789769dcbfdce4f3ac3d2893805e8342eb83193aa4e9c947417e22d2a9bd90203bb8596ce2f99cf311160ba3d71c4bb189d714ca1917bc1e97f76477bcd9aafecd0e63970e953b15cbaa4a6c1f2e1cbf8e2342eb5caccb903d390c414d81c9e6742a65d48b8f7a9327c9a6f81da1afc493928635573e7755c828977853e41d58ca71c34b7dcce9eb05fc8e7612e8dd46fa121fe78106d6eab3e5fbcafb6fb83213a6710345d7da06d433d6c60834abfcff37109087a0aed2c964ae14c603e3dd506bbefcc96a2d5c3b6491c9918af4447f439ad974c0623bdd670115f15f9d52193fe5b754ecc2ad8ce8043a0c44b2cb2d0a522b0f9940dba3525570b53f90c9dabf42212c96258d1e86d100701c4426058a6bc79c49cd890203fa5bd8207cd0acc4a7439d08ae85b967925d02c2f16851219cda482598ba3938706fd36dc244024485805341044d4881d87898b4188d82d036db713a0c3bd5e24dcbc285dbf6d78fad7358a79a472b0ce6b7d4b2de8ceb8f0a4824b19d5af096e03a70dc50dc3f77450b1eafc7e33c6fabd83b51bdf8823873723669ef3bb89d6cdc4c2b59b20f8bd26f14120290867617cef5d4deb553e236b6bfea3016b1a1ddb43308c9f938105d30bf5cb23bffc6711e6500e51de97abd46ebe42fce095125376051f6b8f2e45f3899548c0312e59512c8efd3de44e54c21cb3f0fc5cfeefe6d643e84cb86e58bbaead064f967115eb7bd376b88ae99f98f6310de09069ee5e7bdef8c45ad61bfd7b254b499ee06d7a0d678f6505ae8e416a0167d88f7324e9d2e6c097bdc5f9e202e97f10d553df0b063327c382a623034560089ef78767bf3aeb5e891bc196d34f1907326f4428d0368c0f3f9c5b7342508552bc24020799f2c04496ec3416bdf27575ff106c750918478cde7625898908924057d656a7da8209392f361cf8b175f2ee3814a56d80d9ef96da812ebaff551a0e1b15312739136b45a2a6d0e55a3f3c709b9070c551688a76eba2714d6ed094c66eeb43fcef3b9d216e2856e7ee561f5a5f9374a5b7878700e5a1bd9e59a489b4119ab5ba7c8b842a7aace221447f8ce0b829c2b97a47980b088a0956e602d208d2b674af5e39cd47c1e3c6ced43a39321a027e4bc2f793f8abedf383611162fde215847815f55ad309769d5714355818de445ff74d29c9720ec73456700cc6da3f790cc78ae53f4ea0f0ed096f5eb8827cf56912276338ac342c647e737f887e2d97aef90082876f070c1e554aaeb5005440c9f2c526f46a8355c862fc3b12f8f74d2cd407a3238e234ea9a37f73779d5c3bad6f8567d95053ee23ca759d6f2f0f1cb6bc5747215de4be4d283af57caf8e4ae138c3c59f3fa05a8e1c15f837b63edf4536ab98a126b66c0ca5a8aa1c02377ce067af035748fdd8309534a07fc0a53326e8fdf89d52373779689ca296563dba7820b5166151dae47fbfe44e53fa309282f70838d70c90e1998bb53e327c5b64e057676e98c2f3b655ac167fb7b188fa114a0963222599b846dcc666010f02d47f6ddeaa907e2556cc3ae9a194ca47e10c03c77f1cf7a3239d5834235b84b6e150893de12ad88005a0ad36b56b65b2ef4555fd09f19ec254080d6da51854f55eb6d2458190803dbe8ba4c902e421c2b964184133649739c788962bc8328791988148bf900a648cee3c0ee873781511b2c43171542f67b8156553b10c0581704c652fac9a18913942d6ca7adcda3bb25e6c2d594b2a39be48875e9e771d37a9487f127fd4205519ac7c0e50dbe81dc2f91f541aca6211bfa641460f46f7a90c62bddd70d626b1227b9c9566579a19445430cb746961ce5ee85b613cea8d8d8d9de06c2e639dfc4c08e2ab6f6c6c39f66b3b26faa2e49caf022e4acfb20fdc6374664cb6368f208357ffa555853bad747185e517345003f66822438cf6dd3a5b865fc300a1c6392b6f60dbf988a5395c73fa0ff86f23efe5c46c61f9f212300d4dd4d439b4c3bd6f18dc3aaf0521dda3b8c24d0d5e22875c31dc8292cab5d5565fd47d354b0ea4d87067ea11b765453dd412256d0be0f7a37da71ab58627ee7854792ed84e374e828724670c08809e20843d7d12334c826309478fcaab0adf20ef5be9b86524d27ed78c482c82fdd82b57f3acaa82c48aa6d1c373d8d351eafc3d655af980c849f6ae1e0127688857cf425a6f69cce1b40972b280d4b4c72e00f261ed978ebcd3968c143735588e9a84df7b09c4ec0809bc6e33cc8110585a606004e43151b0074f8b8cbd7096a55c35e5ae43a90f701664f2fd2acbbd36f6356850423a481ffd7e720c8c551ce30da3a54d6282bb3502bdaa3497a7467b546c9d5e666b23cd50c3eaaefe479013d5b2437f0bd60e3d5105c554fbd841daeaf51acc865b559561378e5dd22c452444bb8d607d5b3b6f41654e63e9803515bf552dfdfd273228b6dc4d03b15e33e1e108e5241dd07ddb700d4b3670da816f3f4c3ee6e6d55df44ce3ea1ffaaf7c408842cd7e35575282aada69c0d6cce79c350038fb3829b2754120545d62ab82afdcb300ae3a120cc42c715eda49a04e56552147b329fa285d0f0ddde97aa74a3ff0e4cb725b754e866d82bcc21a3ad6ebe870016592235d3d164582d9e3f212c68360df47aeaa7f9faf2d624acc81d8ba0c06fd55069263e063fae50a56af3e26bf6bad530e9ae88701542ff434cb08cb92c88e9d1d97a07c4c7e66aa1100a7a197e9e7668e40af2c43a2bef848630ca378fd84d6c1a859b446ea5ef4ec9aa4db26e4d189f3ab7ed01e20bc93438fd1c4e6547bc783f5e09a4d1c9406ab4dcb3c9936e95b013cc3f1f2d06ef8eb8da6af4da686f84c0f37481fcb3175011e2d476a3295d4185ab85d45d56cb3689e8c15477b39d26e4a3ed98fd8509bc8e04758498c1e9d38926b08567a0025f6059a687188d71eaee9b0667f0e2ea8d88e11992fd4c02fc4a75c2fa1e419e8eaf82a045fffc60b20b413de10e6df1b66571382668399b24133b2c64a485872472a739d0b28f2ace19b2204fbd88b96f2375c8ef6f738267f45cdab545e9edf410bd487e572d765e051988f71ee29e39dd772f593995b9e4eca76660651a853ed85b36aa16491a6fcb7d7ce7946a9a0811e93e6769cb47555b068e75aa686ff1ea3fce33a54cf71f7d2eb908c6377922432825b2102173521e098b77ca66d54c5658081d668d48ba64b3d1483bc2f751a1d2a0f2a04cec1dc636d18cd576e57d1f4c6be55cb53324e177ac96cac8a66fa4014bf9ada2b8a1c8667210690ce38c360b6e74c1ec841b94f04f3b545da92eae6a17893ae8cb628062360844ac5ad37da5bcfcbf7aa2d41bee54691ec419f906db44e324fbefe4464e4304bd5f47f149daa1f798182b38dfffa680ff97c47eaf3159ee182f5df586538eb3f8a620a8daedfb9a1d2fbeb9b6d9b7174f3b5757aefe0cea8ba617d994ed94c04cfb9182688b3309e41ec0e107c22890f422aa114dc2d8ea7becd296202f25411558c69ef8f2e53159b0add240347666af16f21e5cc669339df82085b2c25d29cb22354f37011f3f99589618f93506c75c1dcb7efa2a2d410958556025b7f53da6b9279fdb8a6f85ee6d8590037c2ac71ee3804636570a89858814211fb64489f4e12e51b3d6a2f2e29c79eeb97f4e04445b6d0b2d8bec3ea06055f3047ebe6ba182964f26601626c2a51bd889d85369ae9a0f6f0e026cac8d37e9f065b26af4bc134bed98a7667d1a331d7d19733820a9a7c3a2d869cd036f90c157c24245a56b13b8eb67535b51c0ea3a0c13dc52a74f13af88b07e19940a120c989334a683e49f3113ca6a1a90b82130847cba206790e9ee1f438cd2d4af70c40c9cb6d93f359cf8ae88961e299e21c0c5ea9e437433116ccf165a2e0f94febd9fd502cdac9fa3c8ccfe1b035a61adbe7f16ad2ac1b4fc696bbdd120f110e1a92ce364cfe035f625571c1258ad9a612292cd3b53fe0943d0207e8f9184d48ec092f50e7e969b945e2b7606d80494d98032a183fd791fa109701a5d85172bcfc5b25badd47db4ded45dc5de6c07cbab7d916670b306ee880b96587627430e9e7173fcabbd5766b1c0f4175ddcb6783e796e33016ce18e33b7f52ea8c7c773e153c33eabbdbdb6e8152b3a1e4ac023bad92f12451cba351e66237c05d0eb22d4b16709585413742a88b65a6c25ed235803873aa1ac51f3f7e019ee5d0db98c3304af9352b0df553f5695b42f39c130d759b82a41e958bbfae23ea504175cff1e7216393ac6f22863b99461d88b07ebdef1f1c2664dd5f8394700280ed1dc21d8a30d17cd716d5ca0345a663700b9c06b97d16abd0c996fdc92229eca06b98a440ac736dcc9efc19f4fac7470438acf803ebc7836199b25f99a125adbc3478aba123894eb05559810a378c1a405019e708b31f2ffae50d5ad85c016d59341fd6481a1b00c6fc2aeaf3510ce94f9a5ad8687d0283bc2e723719e3b28bd4370efe5eef7c04039497e57c05a6acea312eb597ffe7a59448f43d5ac5d283ad51494435ee89df8d92ab6f73eb532c56692b406cc539f1818255259f0778c72820c9756e3fd439d46128406b9412a7ba507525e8920255ecd2c993d4bed6d03add54e93cc32188b3bb50650c70e5285bb393652174736c09f94f61d895e861c3b3f6768026a3441a3126fc8591f83e7d3da743322ccd46b50bf5a9b316189ee6b038f04f3d07d0be0a5f52f3ee861248c24210f67af54258ca137b8860a54a152c6100a3b7297dd758897efa4cd5a78dfd1e0f4600c37baca102764bc61afa44c574c03f37b52c87e4f066145a7e6ba218ad7f7e0763337a41cb00769ea2a5f528d12bb0376308377879c548c8408690df0f1c2724d8ae5b82d1b9b12a30904e11b0562309ea48498420eca12f28458365fd22ca0b32b3035cbf45e4564bcdda20bce5bcb3241f26260ee921028701c90cf637d466695b41c69c04b5e32d06932e46e8f36ebfcbd6996feb850ab454af91a66bb104e5f15be3e3844eb3a0b8b9eabb10239f4ed743ad2b264f2af4a36701b46de0d9fd2983f5fb79359e14b29220290c863d95e76eeb7ae1f3612f59f579b9aedf93bb032023d4bc184b961a9a1cc2cf5bc752c8b1ba6a94c8de9abe11a59e84fe77e6f3dabc6504a1069eddf175c8bb3b2bcd780c860b1ab622d60d5198d28b66a244e8ac657b802d0f61b661a7ca5d9b64f781e2478531f06d1c7d30debccece9618c497d8e6ca5be2527b40a7eb35b953b19e0be4c8ad3f6ca051681fcf2819db4730a4ca941e9f40d0ea204b1904b74d44cfaa03534cce17c9723f6d28a8396944fc2e67facc76449d64a65000007a24225713363d565721ba6be80e7c00db4f302e00d391eb3d9e6c737d7dbbb2ace254bdeeea4c601dab867ad771bb139d4fe00c1a22dce4e58a6dcb889d73f3172eba1b804781eb26a85037a0ad07d794dbe27a41d33466e3c21672ab3581bcce7e9ef4354e474cea0b1b11552ba01be7f67f4de9abf80e4ba7f69b79a1c43130ffce47b1907444c3d6772f89a49f06db1585c3de377bb717d5ff595526ef0268c1c9637a2fe0e77f84e7bff178ed9a4c3d0310614caf618bb7aed6eebc6cf8ccf2113a081235d4e9dc91b0439976c65c4c09c65a89288439e4cbbadc272ef23c64f9e834b48be9b45b7a850e0f64888e7f14d2ec56503e42539a7eff339ae6a83453d41944b013e951ca24a153aa280a9cc6d262823a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
