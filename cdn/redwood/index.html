<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc1e9f48b1e9fe13effaf21702c669c125fc66b6319ab3e173892831221adafac75b21a7d52a73219ddebcc37666e92d2e92c2e1c144fd2df79c4d8ec0c7acb83c5bc7be7aec284723de8c983b8b019a98a142ff9f9b80cd88341717ce8369c289a0c87ce198207baf59bc2204e2cb617edc999ed34d8dc124039e8739d6d41983860fb91fddeb5269560480454425eafa4ee47a74756ffe7bda7a46176d2b0bcebabd60fe1957167b25e3188ec6c2e70bb9216db363cede829e2ef66dd1acff5ba0a10cf2ac125605424f9eaefec406ea59d4bd8844db6a9566486f2eca4fa89b86f6b9af718fc6e276a701e03e34e3e8e4ff6f5eb9a1ba450406b864caadee9bf23da94b8d6b449c53bb64392a1df66fb5f747b5d1253fd47a4923465b09394776e6708062bb43c3f9c6c4edff3bd80ec76ec74bd8a861c9c184d4e052faaadfe8e132582088a5b8d1495c49346ac0cba368f29bd45eb1df5265030a85c07bd869ae090a141a870bf08b76adf651ae3baef3f4d71d4afcf1a9911d65afc4e996ce5de6912ed1a2bb15a9b6ecd1fecc82e419dbd741462b5c07aeb5ca6e5e6476dbc753bf848d263d72b4d475ba5ec06873cddb95af5a54bb2c8918d67349b943c728d2b2b5ab7dda558320f4d7620ad216f61a02948f75bf5ee81ce41ec100ffd389602550b7be49c70b2aa72aa625450e27c53dd5c7fbc030c81050744dc3ea0762cb00a778c4b3daa6690ebb841fc45a5dd174844f673332dea397e97125ef2ad33fc12a390e358dabf7fd3016e6d877c176961b39e2cfd58e1e657ad984759a1c3c43e8ddac4f6bba74295168a01fce37d1812c9765c81f58c7144a907fcad7bf829e7adff4b2099e15245a102c08c62879ccdb0672aa74f08826db67aa11497045463b7377cfd9aaeaa95c7aba2c384d395d21ead16d61941253ed1eb859aecd6a679e811306bcd285ed38bafc3606301357717ebe3b242355a4d74d779c0478a7b65da351c321e90bbad0eba2110589da091055e898ec7a986a3f47f2f8d0779c8783c70a20e309760cce7770611b32024b6c8d47abaa954c1db9340ca68f4687e306767157ac6551aa4abda4483457885c06dcd6cc88caae503e998cc6115b3737102edbfaa1db9c8ec228042d956afb18b508f104e53d47840f3007714b56e4026aa1131050aad60c8ffcd27ec781c111eaf1bd47d83abf0fe0ba73e4a0356fe0a75089f19b951f89d51a665a8993c3a881882d65094c6e034b6b60e031b216bcf3c5dc6aad93895de0d47ea46f3189bf41418a6f4efb0cafc1f718cb03880cb458c047c1ead2978b58fc5a6aed2cb2dc21a9c2057ae3e53c12ecc3b1bf0f74ae9464863004a7f872af85f31e3c23fd920053a76df9b99f50fb16952eb6e78930857168dee34c78f7df700d0ed6fd3ea42dbb8d1123fa7b6c4203cea9a831e31fb9cf4fb49f58f7b05a671db8999899f115cea8bcef0291f3bb3cd86e94a2d1d75e6ebe607d43b5178e773b98da50edbd16bcf71d3d7d74c12df38ea140d32e59cdb6337220676c8e30ff84530cebb70216ce955629cbf04cab7cca97be48ab9cf274eed9b21ca8b5506eddc4b1b6d365dd0db8f51ac2ed0c1d8884a2c2189829ac0ad4b37c0a4a6687f251af4f9a6947f8f81bac456edcf0c344df5e72c48b91bfcc17ae3ac85203180198aa69d7bf872c2beecc7090b42e3258237ff6e95026c9ca5d2762a73bc48aa9c591d6e72c80b3268ce7848d3729c18693385bcb148f7a8dc0334bfaae9a1769333df3d132a040a4b3c2ab38909b655a4ad3f1bb347a48fed2f2f0fd2cdb54b30a40fbbccea74bc45d1ec1f0e803b25de32f0b3f6ab16249480f4310a2ff59a7c752472d10610ee9539b364efebe3087ecbe3680414e6924e6d1f78f4f3feef68177cbbd5f837f7ee14ac22030010194d0c19c3fa29a7e85fb4592c0258983c420f76ab0e10818c253db474dcc74df27779b36a90c233884b85a435c8211bf7b9b667ceb3387d6611b16323a50cc7ba77bc52ccd1e3b894db49ea1011505769c9349129888eebda8ffb2c0362f5f047451db9a4ed964adfb12459d178b6ab5705e6312144ef8ad25a840c327db60edfc2450c317a057bca56ea1a81e616f2c755f10d44a1c6385cd678eb7ffc2d9b434c2dcd32f1e7289c3a6dd4f89e23e59af844b870a5615615da0c76f1e52076a6cb50e829c190cde07e20b5de55c6a20c426f546680e34168032ea4819dc34dcef11300be0a0235b055b4c44f28885e0d146cd7a6f352bb5f9c2a39a944047043da19af3ac50ae9d613110315ba69c4010a7b618156ac1b0310da3e7694ac4162a8a6afc3cb90f0fd54bf4d60b6a83ab9268a3d34f9ac584d4dd3ddc1df3fb895899f6c7715eb325112c992dd987142ab4719eb747235874aec707e8b7cddb0b2cc0966a02bbcd92ac1b275be94f7cad7a022745820fd9640f33497d05dffd76911ba95e3e9c6464102df78e4bdee3acc8ba050effb6ba5c096907fb0b4eda3dbde1853563e1acca01581a363082b3c20ebf10226d6fc55eca300b1938904d519012337de32838af8f2ffc4be84501ef0a84ec6d5204fdaa1d594a78ff122a88e80411a6c8d90071511fedc13b57b116b6fe3f8463f01dba0078a8fa157c7deb58495281518ee060d633b0239860a0527a72a81f82ec848ac90a9f85a796df82c6b116423e578fda91deb14a582a0e911d4b0e3d0880c579807482c34f7c2f8fa285eb1c5c4a88c8d1813d4578319a1db531f89e28ea1431931932c687b2b5fced06dacf0cf96b525d2d4fc458fb29fc603074609c38baae9019c93358985e1c336e551eb79861bbc0a61790be0fc522b334252178a6eb3bbe2aaf3b0cdad32211d70921cf817869e10ae14df199d75b50540a18f846dd5ea3a288633b6a0f595081e40d5b3e1e289d54da9c8e76ffc5c7e60c6ee88c3558747d48aba73e39ace117e8c76c073aa8c493d03483346cd54befb37c57ac0238d5a60a932b21a6ace66806c66028fa695692498c8f11dee822335ac715c316ae723cd61f5fbd669ef73b742f99af2d26c08e2100a4c9098ffd2cd32745eed7f38c7296cd4d8870c4216c0aa08f44a8dd869fb821b83c6ae486c76d65f711e9b491cae9e290114a36d5a438e95f75c8cb8d3da21656589f9f132cc3d67edfb32460bb600a147b4a9ab88c3398021b62953cebc0e507c37e0e4c0c5743c8387c7dbc141a64ea8b7c3dabfbd85f578bd6d5e7a3bdfe3e318ead6dd97eb1e0c9478728693a18d6ad43a3b43dd4ddadaa27c88e3e74545650ef45a7df3e322f1153976a04f9df0d69031af97ef7ee369335a8ef4ac388febc1653ac09035c18dc57c558da2bda0f1246db3cc91d44ba494e2832071d6e1664df1cd9da796332cb5acd17936f86f8b87cfdea1ceb10e043308cb5da0e4a73419069eddd19b6f3a1343304c19c5bf37cb6dabc9febfc8bbadc1d79fec73a587f105a3a0339b9aa2f9ee9113b9f1afd0bfcb3560b6705e674c8e758d6f609a4ce3222e0e0178ced26d5c28246f5959e045db3ad0d6fc92411adf93f6aa1938ff4b6710049e3c7799ea1aae8cd2bad015e3df8171f3475724eccbfe7130cc0576f6e105b897e9915a4d22e4e2a92fcf5042b2b51efd7bc877227b9329fac4f15d289c7b0310121f2c6eba9bcda73da80cf4d153d6cbe09eef34916cccd7c2a9d81b107df4f6638f56fe5053a92365cde556e6bcb2d58c9f3f3b65b79e4b1ce5e16e9130927b4b60487ee3c6e53d4a7fab2a25b098796a7bd2f54a407004d1b280db4fef90abc64b67bc61d67095c447fe69e667b113355fe1724434056e092ff78ad03a021f66ad6cf05181279381e9330cbc069c2746744890686679c6fd239d5367236a1ce8d19000a75f1c8c873f18553b11e5216dd3e34f4d2545e04e3b4313e93afd619709684b9be8d5dd4833a74669cc446f2ab3629ac0a1cbf61321be4f3be89eb39ae8b3f0dbe5d479277653170f8a01c25897d543757d39f09d1061d3f53f0ff1774df3e3b2017f6bbf955a4807689709f4f9b306ef9d6093639bc6e09cad6def7ae522d57c357f007be4afd0cfa85dcc4bac8e56ab6213b921d372ab991e6f1ffeedeeff697d7363b59f39c954be7cd3546b53b79feee6c2be0b13fe20c27eb8d794ae71c30acabbd877ae355cf09abe21d0855ecc53a181309708fbb5304af55d9dca2118610bc7da8de4e74df805b21c6a5404c5762c443c485212fcc930a15165d043cedebc76f38313828b307a718c6daa0ff07b5fb2889772208c74992a03b16a923ed9aaf8a50f6648eba6a45caae78513902183437494e2c4eb9e482b746f501b99b3167429693052c71bdcd1fc74dcf00b7b771a3866e687cec18afde42fc9e7ede2baf56e173832c2afe562790413c1ababb6b5d93c494ac3bd958e0e8af905b8bf5fb9e796c0260d15f3f53d170b3b63ba0ee81570d86307da436aab30f55dd29b555641eaaed113d2a0312802b9dd0fbba07ec60f31492105595262105e7dfdbce1886605c9d744f94ee71a2ff9794b7d22b0a3e1c82ea5f26c2afc16484024740df1129f49f92a3029c8086263d834cb3944d6570c1be11737fd43af408cd7ba334e50a281122459116d79b81ccdfafe577a310576d85fafa86f1836e5993d68b9190bb2e7dc11ccb0314ea1e16da986dc46eeee9f671318217efe89101c97ecbc3e7ad762f4fcfb261f910543b4c182c8de4f23ba5a3977e97769d83fb721bb182dfb55a7319717bef2a0cbe6e2568918cce2db8a3f4b46afea2eeb780e9e2154f2461490907fc179ce066b1efa04538d177b1da2959accd7e5723a6ca8ebe7d12e40a8b909962e9db31c964989c8bfcf343dfedfd7c9439e76ad44a5fc99fa0c937eb057de9e97331b7e5664bebe57a9a94275710b445041afb82467141db96a236503a767a4563a2eb7a72cc0330cd09ef43c1acde986e675c90bffa1de14a11635ab57c1b2b77ae997a7fc9ea357b9002d0b919df01114edefb51efab3d59015536e02f338be76d69882ae17236f4db273a19bd9a76751b6399a74eae66fd84043d2a6d652a10c36c5d6b1c1b40e4c43e8bc1b40253258525f5813cd7e37b2da92ed528a08484f7a9bf79b4ac2e009f65ac2fbaf96cebe29bbbc7c503aa9e3fd436e4ea1b0c69f573273cd0ab3ae964d5679db0a27b274bfaa0aef1c6ba38d79a5ce90a2bcbd24e4a22b9a882145e8bb68684cabc6dbd4312c0d59a952783bbedcb36b43d33950f5f1a33428a0c0c74ce24b672cba479a79b84da5c8ad48b0757e7bc09f047c619fbff4e53b4fae57f6c815d30a446ca0d408149ae15832a051aaea8411db3000b330c128a57975ec30a1a5fab2f974f36b8ceec48a5cbe0c18f1d38e29e4578ecbf007938b9a2c9986707295ac6d303f20598ebd37190eea7cb5c89fab00ab8c12ca3ce80e861bffc5cb872e4a164fda844897608b3ee772a09322cbd0286c37e282de336f3d46d6145167bc6678f799e1dab15c329243253da58d7630cf7f9b82583c5e77757646268dc311a90eea6a3869777cf00389dc06cd2f802a6ec084ec37478ff9d72cb8deb7b3fc03a531a4b41ce6cc4c519ae9082f5886c538f77670c6ac7b17c228cd1495baeedc71f0b4ac03c83d216ee94eea97b287b7077fef8d51ef9c8839ac6833f41425f6d8866c17ee8008f1e504f34114e1fd9150d9f6a2f762daf7d9ead705d523a2f09e54c76a8e81d989732578976667b8d0b0b8a8f525f3cf2f36b5a480794613b9222fabe35bf27a2d2dece415f9ccabd3762051e48513e6302fee93a9836f5f854cc4d5cd5bfea18e00cf59abce2e007a82ae4ac3ee7c429dd39a5185ea71d3ec3730755c29ad05095f8395c9cb91343f550c4a2d3e640f94ed7c7da9882037287b07c4e78a8c5671aeb8cdd744dcaa8510d5d54807eff853882306b0dd372ddd5e9fe344e47ed8ed84977ee144d8f5b61c46bff3377f32539e1937f8cbd81f2a6a0975129660239c5e831b5be7ff5662c1d5d0b2cb3c6051233927ca7256aae05a6cf7d02664a3d9f50c6afad1c752ae4ea7e2996dd38a0db4ee2fa274308aa650306a575e1bbc67d6d49dc9f8682efc5c54a749d782dff7bb5cd91ff89b29bbab051fae524d7f31f98620475562c33cca504b5243a503d50c77aea1507927ea3d4e81e5c78bfd78b5d6f50512f2ec8858a243720057bbf5053fc17e4345970b746289d52e81c99f8c04511b1140663de129adcdaefa22b4d29f6e4c8403906e10fc4049a7b8566c5b611b7b286e9d12557497597725b4d6ba073dc67f2623aac3649e1702b4714077eaac2ccea537c118c134ff3e7e56aae58c71d7df2179de8e5f6cec8396889ab6ced2b3dfdd37524f7735df9f8beb99094f7bdda8523cdedbcd155d46263deba116f867c06a87d217711a324ee00e2898f0549831a2d0bc3cb4dfd8dc08c1eccbd1999695644d1ac98443237bf15385d341dd7e5691bc880d0ba4d73347d07cebda2412cd670dca6b8ed0dc0e2016a4fe3971bda79c6bc7a5e92520bc99070700b5945947a1502b91f0f23c16c12d5f70932464e35cc790e3b3f0802526dbe785f8e4654efd89eec074a3a23eee27f8b36a50ff670c6339b81c10b98cedf07ac4166675c965517cc081014ea415f4eae698cd71ee5cdaab675c411a0d47349053a6a86b126aeab7c70493282748a100fbb2f13298a666e467d190896ae0f417decb1358a4db541be0672d475f485de79a8739a4e656456daa5fd87c69f9e2c408a700501a9bc0d59009f11d22780c516ddab9df315e50ff62cef82f95a9133ef2ce29b4bcc937187ac7a1894fb6024d3e0d70f762ced1ff224ea6f90887b2958da4e50ef9ea8a40e0b9edfe9324a025e36aac336af001001dd07e89ba68f54ff0b26e82601609e519a7500e192d431dc3d5ad5ff3c7dc0d41e7cc24bbcc87ebaa02fd0734bf1081369c29bdb4edc850ec9c4759522b254ce530b74e245ef16cfdc416acaf4cf07ee8eef22fdf907cf521ab1fe19d5ae1bd5e4e251abe31af55c522ddfa4a42b80d9f7c7397a29e083a50b370089e033dfa0b6584755034fbb50e1cd233cf3de49bb9f5f09a4bfe2a000fdc52d1e42ff20cee4ac7244a54c253901cc9612bf52491a15110b21687d849406e308b9a0f843724d5f672534a1ca1a070a5b04b6aecb598ac57a14a05d671811d2447aa4f158718a7bcf6c07f815f3f140bda860717740226e67a05041bf03cf831734fd17b0cc137eb0378aa8c6ba514217e1ce25207636f56b21c03f21cc718091fce2177e84396a135db0d39671787cba5fc2f04498756aa0da7246228eb5b96f2dcd50915e7796c9e445da03f226635d3406dd0b9cc3040ff2e963dd73dbfe8d628c7b898c27cbfd59f3676e1ca50249696adc7170595b064563c80beb192bda92bb982eb0fc6b59de600c6f848caf51468f954d2079087ff9be6ce019349647ba258007483fa1b72211555ffcfada43a47a5e4a1471a6352153f53ed0be0453d76470e38f85f08b5e7e74da8e0167d737d55063f0996e6c527b005e8c4795f3ddacf43b80a6154419440d25df5f44930ed01ee0994220fd5d901eb30f6a2953fcc17a1d4575b37d879e5e1d923d9282dd9ea64c23f9955a5ad2a289f54d52eb1690ef75fa4882d231a90dcf98836dd89b21a1bb3045572dc339c521fdbc5a0f379680525e3be8d0a2802df00c19152a6707a5bc3bf03f060bb9ef10a8a713b71cf4eb80d0904d6d826513821e68e5ff4d2c52af542a937d0b70230a1fec6e7a8330b3f3eb4ddb8ebd1361dcfd914e125ee0546f21c09ef4c4bc635d5d8ce68fe0f9956f874b397e22dbcda935bd1d794c9059deb964ae067014bfe7aec684023f691d0c225624742fa32a0da4ca159c59e6139c339e9ed7b3ec19dd4a9ffed60818860d81c4e76bb30502f78b05c12f8e894314117f36fb818e7a81b8746234d9c5a110376d8368d9561709ed92452f7f0eccd441b5cdb65b6987b4d2175eb70f37644642c6700a4d1a4ae5043124137aeac18c8fbbe7d9ed2460e5f2a48a86e281b1bef4f901ebce6bff79ebbd9c0079604d9999ce1343e7810efbbb30a7c75a5eb7475553aa4964997e3ec02504f24b2c622e8632af435832a79b5fdf6624dc139484f4d9888efe8b28c850d22b1f2f72fa766f3946f18fd125e13d2d220bdfe63b590088f22342c97752e558ed0205e03b69a3c6d37901557dd544ed2d624ba8896203b9f08982e59655569fafa5356771396d9438221d82d53a87cfa6c769f0f88354d7e86a0a7342836092feaf7cd122d48f6da8f2103841d01e3bed0ada1d7d2a1eb8c602f684740bfb3c8adb5f6ae16f8c857f483f8577fe0585335545c3e0a0ac92250d965477cd67240dd531865f524f47a3ae556924bb0fc40848eac4cf74753d7a08061e562c933c0c4c58a24d2a837c8a3346e714774bfb115da60f5e7f87a7eeeb3bcf8c044b82ac2940d390d99ffd3656eda340b204735088b1c7aaeeaac519ecbc67b99fbdfeea133b897c3e6b7e1c8264fa85c31a5b10a755729b429bd6f52b2ee98b2e526cc8cd9f3d88e639f7af050c7333933e8f24e3f6a47ee83b735219ba986f858b0f3a7a6849c65f3f1b29365ae2f48f04dde80a8bf60fcd06da49ef3195ded11c9d839c9b7f930ab3f72bbd9d55e94fd215a91b5b21be247f4317411ba2bc9e745e58b4ffb11e614a7f0ad2cc536d92dc1c9aa57cec7ee0ac69287ae7eb863de62443044ef12edc1fa7ac4acfc0990fab05f1cc9fd7efe581f13b4f3a6d904dfb71c1306b9fbd8bce8e95cfd862ae7727ce6ccf27ada7a8ba0fdd0ab24ce6abd226d04265f1f987d5f6358611baaaa3c8622a3fa83223987fca08c2fe863ad5530ca363c0100b5c55d2ca80bd65d1ec88611a989c2404489f821d39100aeaf022337ce48239176f02882082294b156f7a34d7c49a5952f6a7881d8af4e659eadfa52ed0662d655197cfdfb1d6f25e177bad9bfdc71006b90721b7a684cfa0d90cb44edf1ec5bc29aed1319a5ec26567fb30e71ee1f631ca83165e4fd27dee7005402394a34582b23c85b3623893a640bbe77f70ff4fa22b3daea21a2acd9c6792b64045cfdc4ced26368aef532c52aca43086c19720099e33d462055a1b307d3a2318f82bb462bbc88b7d283eaa5f976bf50a9f848a4a60e1e8cc0582939c36885a56890f72498509f714ce8c9f06517bec995bf07f02b70ed9340ee3b5656de21a28e93cd79b03fa2cb90f3de5bdab3ab95e42dfc1dd1f38fa51dfaa11f0126561887a90e0d5770c4a0b80960c96c6910115dd34a94664aaad451f08159d79d9f98021630aa9365df5a6c8d0d152857fd4268a35b5c679b901c26d488c79cadadbf45c9c2f9e876cc3e221c55ffc936083c37db6ea84609c528dd5b47d332023c4e567de0f37b20f53373201eb5879ee7c2ddec1094f3bd594ccf06a7ba6f5c943d5e9396c067b93b5c91cea86720d49d29babe8c794dfd0137c69b8628e2b199a8f0495392b5528e5201ff525da07d6139c954da93b7d6b2211e8f4eb6e01318bef8528d63c5c2ab452a081541316123cda5ba372c5d74f70fe77ec746fbc3cf0cd6f2ec755c842e9ce809bd7230218114c53984d6792a743f6ec42ff28efbefc3928cf0056bbca282d22a9657085696cf6c20a609dbf53a15e260179bfb39aec6eed55d8681e0afadbc8f34e8270fa17976eb2c90b784ae01fe1537b74f9bc2585a6e17fc7635a797b25041588b36f505299bb209a7a0dafa17f7c1d526aabf7c8b3b6762414b5395ed9dc312c0f32d7d61a60414f3ccb59a775f397e81e0e57a2717650cb7e53d79c96041ef6a16ba8133bd762b653ba8f5da7af7b8aa8a41bc375973c840cc3e8e8f569bc9f0f07e5eb0a984e7bf58f93ee7ae7eeb26fe1b6109014106e31e45e9715c77fa4a969472d2324bb8f52680ca88953184b57a5434a8f43cf83e61dfcfc922f22eea8213ae8c116f6619c5bf69d9827f7f10936f9c8f5694fe0047ba407121d35cb949a6c043ecb61ad9a9a2e3e78555aeff4e0d58f7b7d5439fbfcb707348365132bdaa8c2c9ebec5523808938235042dd3cea2676febbb4ab2363775cf6668e255eee8f7db79f0b8bddcbfdf3e143e65980145dab81f2dda96889a4cad5edb101cfd14e105bb414e7365331863b79294481a8755e94876cc1663306096f637c65e7e6497154336471a2abf53b5de266202df0da5a24edb7f6422921526df4815e81a536f57fb3b8302ca41c13223326013ceb866be7511bbe5e16ef3bb9bf6014b4419e196585d1a06fa42575baab3b81cad4c89f25e8f6f9e92ea3a5e17d36497d08a56218893d7ecd8351c0d88db5876665ef9e1cb33522136a92148c0e250bfd0ab909c218f4d8bbfd66494431a4a5498c3649f5696a8fb00b40f001ddb5c5b8d8f59ceb8a6ef8086f24eca23e43172115ff5a28b1c1750112957c65f34dacbd07c67ee1e832a8960a73ce6da690733f7b47eca6aa93c272fa3b3a1535589499db5afb70c510737e025c9e9a61271edc89fd7875993d221df551a6941d4d815a757805d0206fb0dad18549c893497dd5c6a60e4c45f0af9a5f6beab7246d348f75ee30ecdc065e5e146c00e91864f85efff19fe9c2d684f075c3177edbdcc07375f899b34d538920a0fa2d378e8dabe2dafdc994c2688ebbcc3efe04d698b9538c57438a3b27c01c4065345a69057fe3050576040ea3b769625f84a9eb66e1438856f53fb552621a5de5ca459b8d02e8d9e0bca52aa260bab3f51afc624221358931aa2c32169cee85a7fbf16e00e746c29dedb6221f91f3961dc2c680fe1e9a110ded81787c4fd8780596d7504da4218dad0082b536052087b6ba23f183099a1e65548efe960b6842175f221480fb76e567b7fd6a221a43db4ca7bb164f71167fd40b84e98ba2e436fe981674cd9b703e6898fa74d810ffd09f7d97316c5a94e01490f2df7eb28f527f439213933d8ac072ac8f90b7348633cb446ec75f308c23e95df4a4f181cdf00dc6379cb44356051d8b2829b4f1545814a3c3f272baac4c239ea9986302d814b886db381228f9640bb7d1abce07d0e5311141d8f8a893caeb25f24e91994ca781d4c3d79b8b4c8591ad4f8257d21c519ed3b555d753a8889dde2a93c32b67726d9cd85eab9051a59a8377c4de1d55434610204b222f6d06b89657d8f0cbc911e68535e22ae2272e4e33349ee5ac054366c427dd8f559489fe96373407f6c6502ab88927a3e80288c987896fe5da3149b470d83db219e4a95c07101a84e9998c8d439f50d8bc8bde737c1ed7e9dd69848ee87896073192a50cba13722131e4840022a007841f42464a4a3cec6d64ef848724443bd5af6cd0c141a7fc393e388e2e28733908169434da11fe330aad9b80a820713eee44418e365ddb4f6dcb748f63888a20e5149405e1288f5debe35298a09cbda6575d9bbad36a43c77003f93be196270b3e0ebacf5fed1c75670d82982232f4f0c8b6d8a435e30af8907937cee8927d1b8bdef6e4af55232f20e677998433441a9f0ded5186ef9079cf57fa409e0a4d4399892c9b294828aa94923efb60a956a9d848b1cb0457f135393b74bfd36f28ec89d11f91c6bfcf092f01d356734618552995b4c237ab3f96f006d1a31a6ccfd4d415a433a966ad3d8c4902d55c569f556fc437dfa43de6c34affe998e8ff959091e77db7e27183d9f44a9f4bb696287ec970eab68866a3a2c910c22620057d4d6db4870389a731b1a3d3692773d6ad4bd176adf90ac134f2baf03c2980ce3b28b5d8eae9cd0e587af6d21138a546588394c4023fee9e1d40955ffa4312b54d6d5240b1b01e6e706a66972c8f839e526e214659b7b7ae96e4bdd2319b2f1ba6d22f50460abbc535d056587ac422de04bf56c21adb4e6870340cc50ec5a459c8ad61203d6fd9b07f0df82da5de0d5aaaeb4af20411b5f3ae2645180733cf6d38d0a9dca7d052ec80127c1f0df1b333f507079ac0c33d8b10193f850caab75ba579c97cce28bc9aa8f9cd5d86d6246c5532d6958f4f23ac12d4837c86415e1127363e89e3538296108cc9079e3582b803743d917fb2b0542ef0071b6856332f4c2294ba9ee85e9ff6375451224a53b5ef68754294b9e1fc506801182505a6c2551da849696baf8ed3a8e70042bdcb69ce2fa161d73bad1d7eb6a450fdf89fe46e27aa9acaf8c268b7430789c45d600fdee266e2578e4f49d92c8a67300a3620e11b8f7d9135d92a44801ef535c8cb1447d26cb18fcb8e6468578c2d0a71e347eb1286e171559bec314409afb99f96b08e699737f62e1cf7b2411900b6541851ae9f6a207b4cd1a30fece6658c38de8909d2c936b15da7fb5d5b66de9c3aaaee5f68e7a5eef25217a06b7ba648cf658763c8978dbb30fb311a22150a0d382d936ac7c8b9db488e9ef3f687fd7adefa7ec4554eadc688790a274306ae38517e4bd571380df70efe4d9fed5cef5946e8965730d7561de53b90cd505d67a8b4f700e9d054ba7c9c98b81ee1b84686d6b80b1d986a1255f906c018112289bec2503b4e3b9d483391c857653baf621dc45b3a3e5e53fb1838fc6ba6b1500fafda48d9baa9418ecd90ff70479066cf19cced66e8ef6f4e9c521641d890d1b2d24973e76d73a2d30ac2b0c8bc9a98b0e5336a89a96358799f421739f46d749781f9d824b8ae2c19415b1a0c9c2b440cfcdb9eca36b4ace6c5fe289f27408fffcab251fd584860087afac2716ab2fbe9fe7ac22a0302aff6acad6a188a495ebac5e4e682509262570e1fe2c92725b52d3257f6bdd582750760e953b3bd8b83f36c2c2b256b625fac7df423ef4c64f2e7c47b84d7ee6bade7d90af2858883be73ce87c1eefe500c89a3af75dc9d43198b64b3715782c618feba7c5dec957831633054feece406f08caf7d75d38aecad95f5845e370191d436644228b82037c8eb26a572d30e01558b6d326a41fdd9b8ecf9232586c85fda005f65519fa3635e1d18ddb89d87f1e0ddc809f7af376ad2f84a171f37253d0af45f5c61388bc0456ff1bc70f141222a398d19ccbdca4d6ab10444e9b949537b8439d24b56e72bac3b5554ff62aae0a42c518204de42f4d75648f9e30923ca2489bbc70dc709cbafab4b47592fa47a6ed23ee34fbdeeeac76985e92f998ed73c0dc92acd906e0d4bde7d68bbe03a33a5ce9bd3730b3e638b42268de1ebad19692066a7e38480f9a5b3e5f29063689fce5c05c19f0abeaf6f05105af2523a005b3aa80d75169241d4c76ec1ab8b973d9b39552966800834310234dc69939063265a2b1f2c10feb04e9aa5ccc50848913cf7e9b973d0b854388e964175d69f53b7acbd802b5c226f1d844df85a4e68ba6ced31facb69f6287e3ebaa442b5aa326b93678b2b82ad7b089440d03e1d4cf004153b56af503292e87aeeece4428031ad613df49d9bcf612b4b26a3dcfe8b0ecc5d03c9c19ee554045c6aa22afd3b10b80282ffe5a12ac3f7d698c782516c18dfa6cd20190b54662c2deb5b8abc96b8222ae891ff86aa6f345bddeaba7d1090fa059d4f4165ed9dd8ef4b38ed7c54ef8bd13e916ba0573b8b9d066e4d2c2843261247199837b2f786a4872a830528393895ece3408a9f4dc86051fa97de670fc7a25e41e86a83422cccf7f99d593ed796024faf73c95cbabce55ac47c6998170d234c321fbda96df318bdcf4435addd48942ffd4d91c72c3582c057dd733782c5e53d0b7e12c7bf6350ded841cd070f7ea5dcae3fa3742164916113443f098d0d19d8d80cd283813277eef515bda67bed2a26203c95b8ee58c5220c60ee10ba1d86c917575cd544b6063f316baee099e14036e59508db2f360afd669d26221b931a31c8dd2077bfbe7280b514fb35580b5da5cdf8964f15e959e50af20f0791f198d951b2313f429e9d638ae77a5b1e1abe6f90107ebb33e010b6f25d1fc3c431b8da3088a80e19697d69ce170350bab977888e8b3de753a36d4869ed3012b560a5c83f853743e8709da8422989e0a67a5fc262aa7d61a5587dc50e12d52dd5abffc1df0ee65b3392b7fd2fb014aa7a4b429ebe6332f6464d49624a851ae3fe4d5b05601416b40a4433dfc97721c880c764d6e792c8d78b8d105a77fa64e7d84bea0104bca4490c9c3a77d6221040bf4a131a4f3c2ba81a821d78f000904ff4f99a175eb75a42c2a79545efdc8e2d6bbfd901419ea1c91471facbec30831af4bfcc8c2ed9dfdb5a23105020c971ebbccabba03f1ec223e7f8c69db501054e4a74e69e8633f6f233edbae0ac1894c0cb476907388978ce30568a82afc4aa8bee3cc3a49217a3bd9c02caa30c689289c5de561699635a49c0ee89995ae664f1f918096b81ffda051692a8be415964193d22c45acd44927e7ef4f056d4c28f3ca52dda33c8b6f2982d0218e0be25be95579bfc4ef3b0e414ba52d3516fc65f66b010a8a70934b56ffb6dc2f20a38faf41a2cb9647f1d3a6e3a6cc9855b1af095a9d1586d24fb743d479c840c7ba8b680cf67f73dd385f652e86fb1202274b684e71938343c862cbe00eb1ece7a3d384fd485ce3e7514330b2704ac6b706136e040a32175b89171c86e3de247bd9d714b98e54134653f9fb6fc5831faacca76f845c983f26967c9851ecac14cb68785b522b6c653224376c09da3ed1867a26c99dca2093d62d27bc3793189a090f4de9ba8f3f35cbf23b3144e5d10efa9d80b26d669a2153c4d9766bb182d0e42838d78c4900e55caa720aab2fa2a5d5eb5ed756a18611c41f886cd9b8c05f1095997850092bd99b5d66cd19e0f2ed21cfccd9a1bb6b94b7ddd1cac3bbd5bd344b8a3aae01d52c498d5a4ff6664b0867575e2764c5b79f0b5fe50314030d0f1298170a89aea987a2ae2bd148d79a4929bbad830593b926aaeb8fd5e24266302672fc7d9dcfa93ee1ed9c0ab00241baee9625b9dd5a19888a558bb16f73220670ae9b3dd69b77ce5490b85b4f2a6721c94b11bcd20f5740a1081b729c493a73ee8e9460bf0efc889b609985b45c36ac9d115c2f8e20ed594ff46e65316c22cb28b3b275ecf527801822a2d53cc97c9a89c706ec4457bc4ebf5c6f5130d8cd47321a9ef388c69194470f72f622922eb1e02fc85d690d446a3e41dbe76499c9152077701b0af2851af0e4e688686d1d142e219fd45a44f4cad24e83c7815cdddd57187b43043d31e4148f08bc1621aac6afe9f2fd4734ffb0dcdf875fcdc76a308f7417ddc610d636170a937e2a3b7386e7031f2f9146306234e45ac735dc876c0cb98b489219038964cbd3a91d19bab7b9bcbbf66e9323ff3f33280d9c4b74f24c57e6b438ef0ceee23cb4d55a0b5205b148d926b691ae45393a4ac7272e8584edace6c83d995212cfb39abc0d41165f45b55ddb6717f547434364a684a1dbf5e9f06a02dbda3df300b7ffa057764741952726d430502e5c19658191647c493def0887d24be5fd80f3ca4065560aa343da160176c613d0b2362b9e82fa1cb6d685d241455de1653711b5e30ba524b2a344a3c4d161a078fc4db202e1b7c5116bf7223e2092449da4332d3d1a673c362eeb1292c3550f65939cf5f58ad02d360bd52aaf458abfeaf87231b117a7a55c9501a297d4ea6eedc5b424f9ae00a9ae95c727bd81d834d9a8e600e0bc2f3ebef27e9fae16c61ecb884ce0ec7a9d27f93512e1fee03e94715f615272ca3fa5368a177b6d0b9ddefc5478c5cffd052da43c0f03873705782cd22ebaa975137af1b9add32ed7d028824c34e9a0cac956bb8fc3700cbde6414c2619c5ac12efe990b067dab7de3bb5748ad4dbfec72a106f5037e14dab7036a1052c2e8bfe74b5d0d7214e3f504c8481b69940edb1b4b60ccdd574f5322d5b7d96f2506aade4a0f69353dbc11dfee27a92c6a571b5189da03d3a412b670e5c722a9e879bd415a06784a7d595675acf929ee73a7b1cb1638fb2893c278088414581c56320714c7749267ea1ed73b21338347b8c51ebed9f61c03fea7d331bc18b924548dadf6a41f9d36edba1b00cbac6706d551dc69e9d4f346decf42d7e6d8914707878a514a245863d6733ce61b6d317a8fa9a5b2d140c0a156e0badf7eaa413e869f34e35bff71dcce8bb5a2be436a7a80543cdb794caff448a7fce49d0369d2aa25ae07a17ab0eac31b546d77f90e53b5935119a6224f8496b27a0080ce0b36bec9bf7be009352fccf4a64bec8b02ef5fdb8bb7c78208282ed459bfc91c583d1980d9508cb02fd4e320bd72201ce20b08d62f186dd5d82880716f9db4274ffe350e00ae626a843359df9ab5cf328ba39bb1ab0979d0daf073b3b86051c68346c7787ac02aa1a10f3492e6b2d4a367cbf11e27132bdaf75a7a2af4d01c56185fed0c1cee4e90304fd07194cfecc1c1c3275fa7c95807afc9b89605478a925d210ed33e186b1c3a9ef5fef9ec445baef7873e64af0af86d0d58fba59594a6c54d3b042b72c4fcfadfaceb36ff5014e86e0bff2df63a949ad9d0951d290bf6863e6ba20f3e997499966555623fdfc6bd9e85f049c1d03f59fdf183ffdcef41e851d49a98390bd917c6e2923efcaafa84fb9e773a797dd3f399c02c66079116ad4f43e6eb2ded4cf86791068fa650d608429651185053c1be5e3dee265dbbba5bc5601c338e198256028c2e49e138b9892c6ed62f2fa520bcc85c202aa1411b72d70be048394af71c4b349af4077f0888a6bc74ecf990cf232d9b15978a72f41f7ee078214858c64dec505e70da57267c10a615e5347005223f6598609ed90a3840acaeb69cb5bdbf4c782338acfbdc2482d07d86ebe3e24457c748ffa3a41cac5746231c0f95d2ae6e5596a28b72298d3004ead5e9ddc521ad1ed77552246e03893d5280417177c433cdca9ac1c210277ee8083748dc295c6c5a8205cdd12041108a7ef68d1b3b143923a5628921120470c7592e09ec56d69462c752b734d27876e2006a264af2c79c8e4d5810bad34786e4dbf491c1d0ba1a1af44f6c4b36c95e424193ca07887bdde6a490934bb3f3abe0a49805643f1a7231e8dc245774816e2da0728647c70adb328371f1a7da6f0d509f846a992f9329441babea26fbbcd182cd61ed0783870d6821af18c9f965f321f7a78ad6504aba31e69c0195e6d7dde3f7a5138111a7a8dee2e07cf95e79dd3cdd9df6d3543c93b321ff9f9b58ff52f733ebee1fbd957e0db33cd7ad5a7f123cc4d3410f6279fccb4994afc331837c331c48660bc940fc8ff77889379bc9806fbfa1eea8c1cf963226d18d0665b5391a7ade61f6894d9db90c0501ed3c4ab55bc9315b429dbfddbe25af01c75d9c33a715840f29f66a8c9905a3a1274676f6389d84ffa72daec8af5b6965afb10d1a6ef296fdd228f93809988ac340a7dcb05c48ff065f2d18aac39e06890ac9febc76828f259ff7cd810133c1215311e9f69bd920e414fcfd7bd59902ae16c52ff66f2cd4a0892b7fa5162fed3fe32255669877f567b5dec725676ad1b6c50637fca4175d8c147f94a40922491aca3394a12aea696cc4a40c83473b904651bb5b7daabbdf815c3cedd5328defe43d958c66442eb092fb41bb07af8a5c96ae6ff52ef8b9c77ba2cb7d174cd719534f3362e48e3e38c985c834e5f0179db71380290dd70e528c4f2372e5ec9447e6f52543087d9c9db4e4ea27d763edc72fb817106b10f6bc2dd0d06e8e5e6ba8ffff147ba44677f80fe083454b42d96b17550a4385625dffd673f7c9dae9baab6d75ae44c5778d7d913f9e37e3056259fb996bb8e07827bb3a40da71d1067db6e74c79499ecf12deed2cfc65fa2f30ee6fbb34a0934263e2850d572d988a5e0cf2c1ba893be08095640a10e6bdf0b83721872e5b168a5b2801f41ed54fc81cfd81e006056ee450f5bb40850e2c9f399563","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
