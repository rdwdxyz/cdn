<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0f6c47ecdb39fdc7c1b7e02d3c53cd90e13b7ed93fa7764827cc0b5411652315f36cbd9fd758bebb137b8f76936f01666bef69c20ba124e808c34f27916808dfe30d3592698607636b5c9f6dc92b481666a35b95d68361fe3f08a5b65bdfaf0419653243850c279cc17f8198b1ad1aea03a89fcd9a7d9538ddf41ffec35c2c252452cdc79d47345418116ad996c047ccc7076651c24b600cb04b636e7c24fd1cdc66284326df8bacce894b9ce807e0d459ed53d2321178bce5c7a9e4720e47794eef4f76d7ba50cfe0c5698bfdc18669e9819703db1a6995baa82771c7fc01057381a87305bb63d09254d91823292c916d2ddf1739795f5661134ea872eaa81bf65aacd65840c6dcf27719b0607b060c06e1d3d251c262322f306f26ee5b43fd741bec342b4edbfee8abc67398d789fcaf52e0116c548bb53b615bbc8cfb18d02799d848dc64dc9282cc808869bec65cf65723c859a51131e0c4defd1fce707da69ec74a8e51c1e758b2607ea3c9d3190b86e6179358c27b60f24cf3b155b91ea8ca43e0d8dd02c592c40ff70e05a8717a5ab6fd0bfddb657632c3c87bb640f490689871ec00076dd39d6d68c6e46f68628bd4608df5331b5146b826293a9cfa02d7bcb626ebc925657c0be8cd7b3b342a893c31c2a6c0768a5937633b9b760af532ddce0f39091641c25b6d8a3df0f9144ba44f0804a4737f5dc3d5dff202a3b718add1ee27f4b16716bde3d1f0d863d5a636be6c68c8fa486835f442c92026e1d82539f5c9bca14e7e46784bb56649ccf4cdcfc647704fd2ad5bec456355506b7bc62a3a79b71349967eec039bb1c635057cabf05f68e2609b9ec07cc3649dee7a6a6911b2f34e6ab9af01acb02c242bea2eed83b6e68011fbb89df7226682906d92bb8a91cc425727c527d8e0f51757607a0f6d22589d49c2ef1663b03e1cf9b12d735c1cf6058740ce9d97938b1c46592031976d8e50d7131b4a0e681a81115260aefe591b322902a05742990a2a49314d6a2bcb43fc84ebdbc590a81ea59758b4cbc9612158c685b1bcbae1fc18af2b2b58ff9da627d7696a40c503f45c88b7e33db6b125adb55667f519f4214006eb59d208028d5dec73b808792bf5ae82ac01612e524d37f725db6c6f8d056f6a1e13402b7187bd97e3611b7a0fe362706c881714429fa32be9bc19a96ce50b79b4162023c3a4ac64f7c8fafb16a5c6dea197068deb7d37507889a7dc7a3ef22f7d050b112d2cfa571fc8482d88533dce961cc0af627b6b588b899e817603528188c86092f36a2370c9c280b2041ccc52af0e3dc31d9b75821a588f1acf020acfdb394f93a4a52b76f5a7932bd6746068be9fb0b5b9775fac612797d74ac666c0e1fbb5d354fface2637ae63cbed379127cd937bf60545b74db166cd273895d857494c3b6db708dcceb159b2b7e1f400bbe5579be4d5b8f224406ac663f57414cede81765cf6e4ebeab34dc344102fb702ed652cce345cda9f8329c9dc3ea0f3d0d0dde75dfa39dcc8e2993900dbb20d283e7dfd53530d2df1241d8be704130d8e418112dc8b97a46857280b58d54b8870355498885a6326db38490a13045bcc404c74b6a957fe104dcd0ac12c97a7bde0282551e3afc91b365cd1bd70ad5a90318fe60e32b48b475b1d0c9f7866896c6578ae5d41fb69836139a6240fba3d0c85d8e6febf484813911630b37b8a680730853b86447cae9d364b44cda4d01d574f4fe925cff2a8a02f6a9a840f32fc5195b6705bb88e894d38b0d7090a4c40f4376eac0198ac34ddc0cfb1369acdd4d07db4a8120268c536fce60b79fd432be7333d616b1b49bffa97b235a4d7cae54dca4de2a1222358d74934cf0283772a753810dfeeb45e3a6bf98e814abb1e831fbdb0875e420bd966046720574c0800ac422b7a90c90d14599f28863ab017296c7993dc84b45971c7ff057fcfc046cd7c35667764377620edd453f193e0504884fec3ea2266491630e30cb7ea6b1a454f5ae94c62b5194eaecf23473bb5f6357befeec1d2af3ee3cba9dbfb86b7c1fca667c46f2f64c393891726806bc5308920d8fb744d4f9db3d510f0d39692b43e5350db0965ecc2d38eee34b45ca2cdf466e2bec34883342da73e99d0356d6fabea34012c65bca668d8e5b6e424654bd75eac6d4c30a7da2586877a27cd5e0b74aee1b29207e1aa2149c86dcc42bab44cf0ff422ebd60bd94e1c32b506fd14a70a3d6fc34ed191a74c94c8316eb3de180dfe40d329d2a848d2f8fe74e88a31a02c361a6c3bfe4c9a21b798f3e09af37c014e6ec2512d4b64a5a21a7941b0f8113d2b3e672afca0123e1a6957841252765660cfbb31c0499eea11eb01378821020a069da28e9b96dfd463ec59b1e1048f189a652cccc7e0f556ca7184c2a42e47849f5085418b8a43bc01b61fb587d397608fef11cdd81c0d56000efb1c765dade590c76e2a996b7d6679334fa0d429a30b6e92b3c90be6b24017b3f37861df98f6c88b91f8c81d66fb31b8f2c6ddf9b536e6bc2dabc446448b71a8df242d70770c6fd95c5347b1cca8550248828d88822dc6564d9c66b706076c859e950dceddce720a54d0228fb4117f11c2496d35f65bbd88e5353206de9aa32a7a919db02830419f5f21a810510493d0c92e8738353776a8cf1863e2dff73e9df1ac7c9b6cf90a478b2538ce5166f639c3169f989d118ff5bfdd47fc3c26355aa56a3138680bc97d03785ff480e8b152ecb006e8528741f81a7eba23eecf430db78c35184589678ba4958821aea08fe901094c7fa27d3b4715ef827eab07ee10841c3b30415a0c53810c2f72c49338d1dbe86d16f997843377a9f9e66552a96bb51b7fa68d00f4a95547a0565cf886af4ed0bca8eb2a1c3679aca9787c23fe197ffba3d94c677fe010649a7978ed8c7b1c9e3342130d08d2db7144939f2a32588c3413a9f65eb72840740ccfaae2945dbcd633a86675080a7ecbdc11340596a92fa1297bc08dbda904d590c73d1898be2bba0e72d08d3e461f2baea4a1540b7b9f6e2fc60afad6fa4cab5298b2200c6ffb8eb99afa307edb15df771603b803866528384d66cf7315e1dfb92ad8c4264e6c493632494a4302408259c2d6f69ca4d0440f05ccf1c4215058265f11f7d745a144e4a6f2d191792efc1ff56015a2d50b76d50323ab40ac6e652069dc480ec682c036600e3910c3005e9e65847e6cc1f0f4edca9b155c9282f4938b9dc46524c07a685c047ea643f1bb00a701e66442f58b8846cef25d294a8fe6c761a0587cdf48df0a5c21d5c7a9d58577562736c0c06ebc9fd416e42e8d69f9cec7908724f35db0246a3f9aeb3cf9d22b5fb3ee062540b295dba312bc00eb6d9e2e1f91d371ecb5ec362848a88d059638f3d4835dbedea9d74a7d829fa27d62265e194f4243ee5a7aaadb9f14cfba47541ee5f382ddb036a1b5cc587261e5d0ff8b4da4975277e9770344c68fc25d6a3c2231518a2988ce52aaf430a904f60e5f66ddd1626e334f19b0c84d572ed2267a64fe36bd3936cb71422f6c75e9d3e177dba971e87f75ea61d3174652efda5496ef96a46fe6c2ff0050a5e95bacb1862bb34eea1ca63b5dd87129d28d454428a6dce6230858c25990fc05776ba5a6c6dc9ddd2ae3b150c07ba4abe7f61bd2bfe8d42513919cb048d3573fcfb8e83cfa009b8746150178f8c472f3f63a3ff430a5adc458c2b81f154bf6e593b4be3745721150e8a9e331e6e386b01bb2478000e175daea1800389109e2b553d78cb8618f2e1091dd5acfe4bc60797f81bbd184367615f57dd079c4f548482ced929200533cc8a752cd3565c7b6cbf3a65508f11244bd22f796e650f12f0ac888896f210dc956131e59e910ebf7fe8e3649e8d73cdf025efb7bb5c4abb4dab54e1c30125278ba7fd5cbfa65af31177c17dfa0b64a4e437cde2bec0a072fa4294bfed83b61f485b8103c591026cb9583c503441dbc462e2c95cbede508363bce874132aff42af7b179c631efae31a913a4c5774c8f31ae36500f5b8a883d4af6b002f2c6ff2a127134498ba1e7f41f538d619c8a27ad50988e78f5300a0dddd8040885458abd0f4a418bed8fa1c177aeaf3f0be44a3f873d1c6e8427242d4b88afff1e89e440bf0256da0eb52af12695ae49582ee6b00bcf00f1e1fea82700ab95a4eb43375fac59995e78fb407c6bc99d7e6fde0eb7553e31bd968b90a2865f35a5f7b57d807fdf84e1671bf44bc5218307a6c19d57b875bb2e0e27ed81c16fed199cf3e808b6dbfa3a9bf3d7c77c047d15c0a64cadaa8277c86fdc870cc676fef453c7d1ef3d0b4cc28fea40eb39debd0e2e7cac63e7e780a6afcb433dcef322947b8731b9bfe01fdd3808b726602b72a0302fbc13eeb1cc816e0c3257dc39478f6ed10c5f5e99abc4ceda2b92c3bb4b1fdb347526356d663454bfe22c89d9418f45c3d94a8feb2bd1f5ca55dbbb60043df4c079c66edd87ab85dae9fcdc5d75c036845d4109d2db1b2a4d544df9a0cc73567b0ff3d392339418a2bd42be5b6c73ab5effceafd497728abfce41416248a4b15b77e15aa963db5af76939510f463b029ea7fb1997f7beb719a3969efe99b0348191e57cf6a368606b6b06f6f44de3f29c43b62189a5de90c4d0b1b7aff4a51e3a3e81f1a0912ee388170f20bd539ca056757ab18610dcebd6762935e2fefb06066342802ed720ae47b5e578eefe90324c7ac40ef922be49663b844d6c27234ad7c273b13e88de7455e37ca6f5953c46cb34991052fd068dc1767b195164b9042ac0a6a5e6981fbd320790ee348c21d0126a85c30ee46db672317cd92e39f282dd9b61a8df8406ab7dc2e77b860743f077ab61a8940d79f319977f09eee90cca9a4f4223bbd4e4a1eab08491d1eff01b738ec5993b691730408d315a4081a685575852b688e2d72be7520428524da8317aa91c9586243d06c34b9a2b0f5e73187d524f1df5fc49f5e625373077c6868d7abeabd41b2fa88776ff68725c9d9ab87e63fd558d04264db138a6f997326576939d24c5cd0b1cab91307097bcd5db8ef71bb452575d5c048b7077a5f1901e0599f1090774aacd941e7caea5b05f4fe6009dc59f58f416524923f1e3e82cee11fd8c1698ada1439e12179e491e955e1e20bf188800e9ae02e08dc678e7810dede0ce967bb6c745eba3e3913c5f927669b697b64d66aca2f6b268e70641f697c1569b46b36bcda9948dbd53616b412c690baabcad72547472a93d5b53fa0f388449193b1a6b95ce9390b8ce2da1a6e2f30aab9220c1d0797fdbf74d360d277b72d62fabcae1e8919845de296aef55cdb02ce5489f21d56b1535db5906fa31b76fe5329ef25657ae31b227f5a49d30f29894ca5046938b1888a23ee84578bdd81c76e9ed491114f31c960c5f7f04958c5654eba099fbec4e85a2d2882b3e0a5d000fb6070fcbce7c6e61beeda1cce10368ed237f730fdf09d83f43248d20f5c528d17baefd3ab1a5acdccf98e749abdbe0d32f904fb9f41a2b50833ccfaa33b0f8e2743b2db8f55716a6a5ee1e4c2e0e56673b5ef0eab078f1b90c7cc23ea5ed1d89300ae731cc6817ac3ad8822a65af4eac019aa2b0d565f3737a08de4447e3c9e55a30fdd76564205e8ca8d9454a437b7ffad101f9bb5a7e16d17594d335a6138b03f5bac5042c27c297e66682c634c0a3aad9767806d552f5dabe24072b6897cd893249db99a3ee3629f9b1890f563407e408de1bc694b930241145d1a64261ffdb294af16cf13784f798bff29a2680ef4784fe572174cda8e16086f51d45bb31ca9a980496a71e25ebbc828d29a48059430c1a3a7faf06bdc39ea1be8e7bae5f76ceb8c85770b3ae9125da66967be3d2ef08e6e0a586f8229bc2b9b6371cf6e6b5fbe04376507e50197affbfa15fa769177a25520460b8f95c4aa96b9e3bdf5f694b07a60c177e134392bc53e033435021002d28141cb97b588425b9efd9f02708da5235d8c49d002c9cc941f5008f5a6eb32ca12bb75527fea3fd6ae5c596f9d9ec4d0a73446111178a9ba3621a600218bf28a62300f8f87d4cd9bc77d3e361b0a7a5ab74da9cb1e70b97bd70c3c8a9e9de4efdad480591b2956fe86fb0570b898639931b17d0f6d4e69788233cb13b0008858ac3e9d8208c64808f95bd5fa38cba23018251bf04126a5469a42a52a48427bfe3c56b95cd8e703f622c51a5d1a51e075568764c6f0ea68e21a4e9efee7c933d889d8aa05d19cbc03a8890f1ce33a1d406ac616c9bc6a83e5328d27f6732e55a51d14338f22556ef12d033bcb9064fd876e1e1f519590e851af7d3debf5e9581dfed96a45cf05ead879260b6f35c6b312d6a0e41171019917f6f393b595ae217f5a389366cd394bcb2c4b7eab229390343c173b372091657e2be1012c6d66e32b156ed5ae3f3bf41213420a7d27ff167f27a610162dbca6ee32d83badeb13f50617a381e39e02ad7f97119b0bc984fb67891b325800eeb1b9a03197d081fceea03449eb27bb2b62e820ec28be0c7e199bdb1558a134f827c0dfc5d98bdc56a131a95a2c5711b55b50455a1d85e46858fb791a36369c3e5e519f15290b46fdb7c51593c1b9ca68e3b7a73c14becc00ba3fa4b77d9a805108d7cd01e0ca5cf33e314cc906a25033fe4e9ebe6539bc0f66c72b3e969808906d89bb41b16158f00bae1d4edceb4c8d14a2a4fc7c459451e0aac94c977abc2acc817c5736b30ecd2b2e7361c5123d1c4dbfa8351299a5246b5e8e086418233f21b3effa05359ce933492040a7380ab3dbf48d5be88c3fb49304a67e100f22ac13b693fef987255702b1404b6513ef1f62ccae15f2f7402cf7152064e4daae6e53568b9240f5b49bf83762c74ee946456d3e1df761d21d57cddb531ec73fe6859f343cdb2f17b99dcb6244af7377a075bc9002ac775df6e521066f459a0d907962926e5efc83b0269017b0f47ea9554b7be396dca782b9e6580ab4d069c3eb5f751f962ca56727336f2bc8f5f5f6de05dad2db11a22f7c3d8654ed32a17423d0ff3ab019889b688a7d1b09d304ebdedfb741aa977b0289a90a17a0f8ac8fa64a0937933bc16548d26d8e1b2e16df0065f3ff9cb6ff6434aaa9b236dae6db834dec028c843554d01e05010bf43a538ca035c150e7fec23a76e669efae8be3876c7bf7c4fcb5aa969df2a2a7e95f3bece603af36b4ce31bd67483af975ceb4801ff21d39f9a1d9aa7bb1d4fc9761cfe3b52f57ce464ab883305b64c1d2b47d32597ef08a9cc85072e5ed8ee8b3e2d8048d19469e6f96c927b69e0d5d64d22ffab961083faaf9edd9d579f64c0f2278ff7c4d84363f81f85af4539228f05e11d0e8b418fc74a650c9e5a2cea98b40e1886c360498a87b9ef59665a3ffcebfa14853577c4e30dcdbb4481fb3c8123fbe69ab0e345f118b44b748ffd4a390b702b33b1595a78e8bf72d94c6286de29af75cd8f5c91fd0e161510449beb579c4d719b48dae795fcb74d3bfb40ba3750a09748c0fefb2732c4bd67cec0b75661e2803aea1db26e7257234240914cdeb4fda206bc9071bd461c9ce880acdb694c08c659f07bf67d02de52a1b7b11d2af9fe761e71af1d9556ef0ee3a442603e307ca03a5b981ca5a049af4a180e2d16b14a90439ac09b62053cf993098c3206b119949645edcaf3e08d6866b963145bddc55c713f7aafab0f19df35f18b84b36d3ff892841127f21e11c87d2c36e46dbd04c31bb1591f7a02e53e39d414f9568e3cc209ae3f27f7f1e649552ed01dd40cb55c6700c44170d8ce734cb83533299a8876b504a3a5d10eaa401d1e83f7a1b092d478d51d7722a614738b57cddc516d618e3844e7cadf813e0661ae35ab317fe8aa882f6c3c3c26561db77a060f3510400503ec0939ea2ac6621da3ecfe22a67e4406a29b2aa88c2a0dca72ecf405db55cbf875ccbbafed01d3ade3b306d04927bd5b24e0eab2d7d4f4acd428694087b70ffd1618588cd2a73048e8f1a7b8dcb959a84aa133438df6bcd5f3e34f84dabdb6316d78f049c69a1556d1258713529e325693ff8cd1e767b692f45d9c5944f1f51d21026e992e11f34e7eb757653419af864b16a236f7284aea75ff0bd688d6d302da899e44483c8cd7ccd0c57e8202fa2d973f353a2f1a50fc988631fa832995087be7be8376f3f940b64248f9dadb05dc1b6ff93adb5a8716f078bb728f2d54f156a5fa4c52ff05544519a7875642be0fd71898a73e6f2357cd1c6505c2c9b7bac828988f74f39c5ff487e8cd3c51b0293a65ffb72c69c0f73a776cdbe1b0545d9fea0baccf98823a77ed878d4910d7d41c3c589c2b8e32dac2472e82ca4cf73fefc383f2eeae3d064b0724e93f7625343af1b22d7825037bf5a3d1918fa3d669aebfd8824352c4ea4166bdee2ec8b189ed013e2afd34f5eeb4643dd335fd016da215d922784d3a4cdb5e5d3d475c88b37d956caf5815f008e7f67a7c7bc1386d838945e4543103572c87cc29e173bae56a2fbd33d945365531a34ed8b44d8fc342214eb9537a66aabcd92b920dca6437e18562f24b8774c522ffbfd365178c49a29fe5691cb565a15e17cfd2955b7eee176c31f9f6123adb28546b6e65e87e8d2af1a8cad299a07a2c8d214031f9dfbc09ecf3e426b2928c785298203118eea7dfa568fb3bbf641773b0ff14034ed602ebc4be293ff561b46e41f17cb760eca6bfb79d8ec7ca4d692acf6cb57dd1b21a6a881e1473bd1ff75ab693c90cbb25411b0729d47b6471ea87de99f89629178495574e0e089465686ff3a257da038dc0dae00ae6d9b8ab1c3170535426f087ee70bfc5a6e2da799ccf37325d160040ae1146895d5444da42ff4753038512d13fc46f4eb2b73e8325313b25ef22daa3cd5bf24d0793153110c148e04813c96b4151d841e15751d6ef82e81db4a79c2d0f68aa17429766322af70e8b59a4201c63498f1c7a652fdd91ed15935da16a487492e0c1a9d4137daa63dc3f02fdd0cb433447f43258b4c36c9930fa4d60d71be4613e2bb224358bd514fa40898ddf4324533f94b4fec3f7a8bb5706e33a3c71d105a348339a65fcda059f271a414ce45f5196d9512f4a61db6de838aa52447ab855bf147196c6fc884ee7bf096765046bb5ce3f5f7efa52c99a035a099188d9799a11257db6f1fad945888fddb9474823406d1577024dfed0ccfd113317bdf93eee4ff1ce618447167a1c694ea43a7a2dc908e5f482bd64f7e8f4e0e1248ff71008cb16b23be6242720bb1cf8b2151f22f8762d514e7c270b650d8675a3179d99a9866ba0ab85c0854321a58ac5353b90cf43fdba15680386b5f4b77f8bf73d49b518657af1247de933ac3e38d00902f2db3102b66be20d5ad2c2ef2134f2c4624233511865fca5e49e8d35cdc1f954a8b6992f46e935014e730ae1a21fddb0710d64d257941d90a29fdf388ec6e533ff223b4787927175fc64210672bb3e8de3f61f47613c27cce42fe5fe1f1fc79c53b66b4199d619b77f4d78972b19a8c1499ab37917065aa1d3be6dfddbcd783338ed856efd5449576b7692e7407258c9f40a45a8e7a7fc93541a1bb8820657c51a90f619c3c8afacbb4dfefb65d132b62e1c56ea62e107d0f34760d6ff71c5a7bca53081adcc4060ae202e571796b8955ccb400ab764829e63247c6069712cdd27ca7ef632e82bc9ecf4ff496029b2aa658f65370e1167cae85cc9274b8056d2b6a8af51dc8f7f782bef1108e3873aceebdadc18815dbc9cfee8c844031c6d94ee3839cf1d0bed3023d35cc9b392899bf50c7139089702c783207f6ba739ad6c4c763b3b124741bffd753e799c55be9ee976c13e3d551f61c11634b3ae991fb5c752e19cd80901035fccfc68f07770da760e7a9f10c9ee417ac0071d8037f7ed092f87c85aeca834463ae1aeb10a4206f8cecf6d6ad913846d5ebdca122734cb3d76c8b533b5bc09321615dbd1c208eb8dfba4eb2489b496debd8e7ee3092c21f546ac228d24249ecddfdb41ddbcbde8550d03a15ad75e0869ff721b69f986ab945476b465a21397e4aeb7be059a39696d4324e471b045fcfe35c6ef92e5db9321d762f482ee1d606855e1079258f43137397d097abb80a7b98096cef232362a5abb4443e9686f514a1f3dbc45f6dfce66382dd9de5999b4a1cd3250c28cf0e172d9496fa2b19344eea398b6d503e62538129f00095ed1661f1578a6677899272a9672c5c1fa61f08d4bc2bea210c496b9dc6df7418b9fad5858d2045eacbb8af54f1ca394f145d92b77a003dd10135d9fd80b650351a047dcd2626999c386ea0935a92b01ce32203198ed8332c814ea5f4ed8b202c5ffceba2a61cdd384844d9081c3e3c14c38abd8c5da1fa230cf8d9270b2355234cce4c1bd22a35819b48f7898c933c985ade055438c670000aeab58094a23b1459809088df541936a4c5ce4cd0caa32e4776333cf3fabe902afa9c4c116914661367800ca4c8e169f10f4acd380b10bd252a115fde1fb8780efe595298d19af22e0a11446a7d4083929a6f7e9d3cd15ed0b02d3e4b2e0fc3c887e249f5f17b5a59259140a98dbfeb9dfbeaa8a4c810c8fce51873dea6bf64459c1f65256707cafa07b283abb56d802f9487981f00ab4c0b00ee253111b42f34eb2cbc2dfe7b32344a19888619d628248b5de3bd4d5dda652f2c8263e08cf44bdc03f4a4802b4f250bf65c358068e0e13eea84b02dcac36c619e9216e91df71acd8c213e91de3c708e727760d2e4b5640a53434d2d1e46ed6784531a9fadf63baf23aae70e76d7433f8de5f55940acaff8b02adaab71ef0530785c94a2274408fb78913ae1070852f8edeaf62ec935fc929a94ca3662776cbda3b5dc76938a6550b478927b8333c4c778c9b7bfd9a06a94082857d2d90fbda04d5f17b41cbe7cb1b551ee06dce9a77f318f92c66e6d3dd032c3cf4985771be37c1ef2750536e91651d230c5a53b853ba28dafe700ffc2abcfc95d5c352fd192101fa58e1c50f83afcdcff886ff54a767de6295df3ab68eda973fb0f9ee9bd5f47fa59eda1e4385d31261f1126cdd440e5fa9651ba58a3d35f3d9d4e3cd0602d0c193e45f1a1082e4e9cd1d82f76725de2eb22c16e051fbaede43dee2c609b07eee32e84927c9e4add404e82674c2a32ad983c0d0b4cfb60797b17d4cc8eea7b026667841ddb1ab8fc024a86f0ca1087a03e5f74aa9ac205da61019f590b060282b3aabb78d50171f13b6a346964f8cfda76a3c24401bdaadfb6bdaad191e1a7c8a9c77cc0e7fe7cc99948f9982c978bab6dc5e445612e37f8e9d64d56d5697b36fdf9730a6ba7ea92bea0fc59ff6527fdf7aaa20e829227b95343d54d7df98ce3c33a01bc4dc2de8a4211260ee443273241b17d8f05eda1e7be78d1b9adb76f63852b2a2189520b29a12cc7d60273257ce3923c79b6195c55f404e15ec936e1ab5cb663b6591b32046cb52067e4474a8c1bb97491cbd7646099d0ccbe068e46c9c4dd484bc3a8f1a0503d17369cd648269f992cfaed3d4b6283444a4d1fddd9a519ddba04517a99a7f1f6005e69310b0f6bc4f025c81076b4bbdfcde3da0afa329d7ed2388a37928c7b9c6e0d90c82eb99b6d1bbc39afa6c87b83db249d5c1656d0fe537aec03e330a32bf062fce2f996c17173c62b2e5149d51a850da69e8f1b3d8d466bef76bf2c0ad0b37fe2f323f60dda4e8ccf30cd532ba19f85e8594080f34dad10951f3715e8d6afb056357cec648ead730e787451310d68b6a147655473539af21346a01e4de4b8fb55362b6f98cb74abff0c523d5424880d51f3dca03f711874ae55e81786537c626bd07b34508ff0a26b98fbb3dbd3e5b717c4baf37332f55a97e6561f2621e62605afd00aea52d0da873d8ce12eca04f35fd38e8778b5df74091bbf766d7221bf5a6f548f17f517d8b27d5da5c158882f5ca96358749e1c6ce8ea012071aafa4f4aac804a5523c237aad30af75ed7b735ba3114cf82ad319f8e919267af77602b4a790508e006bce871698671b81f244c6ce777a7eca9e6125327358e811fe64a27345d6ee4a49beed3b8d979e634aaa8dc751a5ea0136327df4015ba0141aa78c80602f5848ef6c64d97d15e322002f01543423e56fde94c4ea160afab1debb3a8e7eec96e56fd75f2b6a19e1d169ba28af307f545b960df0403d7049856203f66ec4a9bc6f964340f6f885c9f4bedff3c6ad1d3e42d7db349e92f6b6df161775c3871de33c3f0fa45ee1d7c4b7a76cd96e4f3240725348b2defc46555df99151b0993f15d35d88ae45c125e35854e3f51f972f1e6e39215e48ca92cea7828de6fa596ce337dc4b14cd01381c7b56dbd85fae531a5e695e3382a29e7795e17844447e1a87936240df0c134c23ff80327ee38447f28bb801fdb73f2de2c6aa3ac9aa77d683a8c8060999fe08c4602da263f0adea1e55873470a198c9a187fab48c42612bcaea4ea7fda46b16138982bd2faf939a5f67c8e9ebccc181c1ebb3049f695722a2c2f3ea7eebc5cdcbf781859cd7c21d2ad1fabfff057e4cc31dae272fe113213a61294400da8ea4a500a29241cadde4be749a8f7b4a7204ff3f4647aef06a3d33d31f6c27cd608bece9406a718b9bc1d4bda41843cbe21085c886336e353f7c4add3041728fa4d9368a0147d76a1c635b4dd8387a9eb177080270a150a98fae5932960c840c6e59d8cae2e078a8c4534252ba1cd13d2f03051bd5591aa268ba12dcda2469a5cb1867c4df8f7c1fbcf5c9e2590f4d3a3916310a0d683ea496340b4cf4965ef6864d427d3a46deef2c04d7b39bb6a28a4c0d64d8ce27d1df6fdfc9c8aadb09f6de81d3d7eb636be1513f52969c7f115a5f28fbd30aeaf91407c31424a5f3579a7340e6fcde1e31c7db0e1c915c15c4909bf7a933b43bd02fa3489626565c1da9891a6cbb9820fca9594d3747594c257f7e4f2757c7b108befc12c3e577eb956e8e9fcc04851e0e3d8a4ca1c384a9fa618276ea7bc4809d58f84136fe0ce33d783f6064041157a36570c670619be269193eb02efc940de8fe38c8c86972575a04ae16597d038bc602fb01af463ed1c62cdfd239c2aa42909fc7756cb3af760b3543ab431e4681964179e8cc98608b1c61902f9968b6e69dc3dab5c16041fe45ff2f23e7f7353ffa7be4458871f31d260f88780b24579190d6178e92db8c37a6f7cefc7a8bac4ccc8f368d87da1e3bc7fcb2da78dcb163baccdc3e643117f5e75e51b1a31b6fa8a0f78663e373ef76c9f48ee9eb92221b5fa3bf6c3967f67d6da446702b9b4064ed84b60809895c6be3e4ffa9ce422a0a144e61b1eaf9839441743065156859e2bdcf66c1ec5e1e05d8cf27b005ffc8bd9127cb7701bf193fcec857015855dadb1b64843905e895bad53b25d030b126c727b4d82d8d3951d3e2f4df391f5386bd8556f41461d9b019065a2e6e1d9cfd940cb96da2078c21ab77fa82ccdeaac80df783b67663c23148fa7b72d0de24e1a2825f71a387f8c57de7afa45783700f366987056c1cb63b364784075da1414c3b8f026c8de2660421366fcec34ecd8777ac62920ff5e66fc9e5c287603a524f6e68d43d4dc072e6cd3a993e9ed962bdf293ec2a1352b87d774cd7878056049ced2c1509629d12d9c1d2fbd6007a042668cb2f10f9deca483197579863c222240e31b43aa1b0b0d5db081c230c5706d2b781b24496b0d22145b699ed3bee9cdfbff8677e61a9a7423acb95c664db4d3df6f1bc06689ed42768ef79c2b1a6de75e1981a3bb53346eca942dc6237aae5b1ed44135df7d207efb07538f39bdb3739bad21dd1ead7c08e278eb42040dc719336a1996398511bf4c75738499aa3f8fb9190b24a0260df1e16bbd4da3de3401dde62b869e127402fb36f7b216496f03a3c76b1484d6da5641c995ec699866ade25beb6295d48b6f675297ba925b5e00cb684e5a7632be5f7522c5c7b08a7a33fee95e01a57dceda675295e19b59abf0af74fac04d785fe928edeb5b8218a7fe104253dfcc95202c55a1b89bbb6ad7271853b21573ba56dba5d12fc00ea4520cfbb4979a3831dceb676b90c0e25c5a2ae173100817b49600288f209829da683748093554b7fd0c7e27be575fdc43831252f9a26f230e2a6afb02b0b1b553e9e6227060002505e7c1872b0a7dd4fa3a94ad486e372bf327ad2b4a0795e1167c4771070341b55392b50bc3098ffe015f89e147505f2b164068aa2398f31031e881d667a999a98375b481c9254dc7248df87cd1a890108ac9b11b1408e32500fcd350d665a6fb2000fe3665f6c46d5ece671cb4453e064ab166dba795d41383193ab50abdcc0bb8c99d5bcacd693334e06fd05f2a96ffe9289955afd6243e9d06d426a69da4c41799604f814dbf1d6b9500f26b57b939f73c1fa575c5e7172d95c99308c562defd3bb56158dfa5f39ce6f290a7fa82bb31f586eba65682d9d9d24e67cbf908298c000fde0363bf33656bb3e7c3378d3f66abefb829bed6ad2aa628b35f63c41d686fc8d58cc5363157bac126f81795ef320539798a643cc2e96709099169a03fc35b93268b4632886e65d961aaf53b24bd1ba72f3693a0947d2bdb497b0b92f9914b4d4b16901623cedb46a8cb8470f7cb216e28dc1b8b8f3c87ccdaa0906ccce3185fa3896f510d29d0f62790cf15be0d9a88e397eaaee91d4f8b051ba16b8bb095e8f2229d17f554a9e6f174289e824a5836dcc76d7ce350fbb33f75544eb77cd42d0dcb637f029bd72566a33280d443067907f4d14ae5cdaf202be7303280e2470ad56fabe4a696c429ea8e47c2df632842ec8197315a04761839a6069444080d3a19e47ee88539b1b875bd87d63d13725c1c44bcf456c51e4e808417dbef3d818cc569a0bfb2198808d495ed488c0a04bebc160e14b7130fe489f7c708e8a7d4f09c61d58dd174804d7a2750bf0ba0a0ba07bcc2733380fe9656178104af63827095659c010dc875b3d1a0fed1f65607007fc3a74f71b5b8713bfce6894c90c969d6e9c0ba2461c6863fe4549a4cf812e8c3af4350c7caf201c36788a9853b5274164e70f85799d0a8d21491f5947cf6d22382fc1a3950de5fec9e41e2060db4f7e67e86936463df020c30a6cdd4158b6231a6a3da19ba3ecf8552b6726748acd53b1007cf5b23e7ab7fc675b173c8788e1263a15fcae05941f68dfc2f867eea853e459a1f9acf53d7ba99728f871260e3319e5e2c16cdbb25380aad37261a923626786246b16c7d9a7a97d8a71d5b09f5a960527d5e66a033030c52d08285216e306991b5043e2cc5cec67efd4148686e3faeaa812a5376bc5f61c6a0de7d5064392151f09b2757f16bb029704a627ec743f19386dc13940c8de98192efedd6fd520f819bef4a28cad99fbe6272bc32a3022c688fe070f3591ee5d9f92f0d5db963ef7ad2f514c9928918372dba865e838e87a6991aa39c2431f5f6aeba2f6b8ada1bf12d8cad8e1f25a38f9cd372fd4dbc14ce664da7da81c08a7ff981a8fca5181b40813a5449cf84860f02987a99bddc20b70d94a089ceb4aa4eb9634ec305a4c691d6f9c39efdb345aff72e4f6cc5872c38c7ecc22ceebceac4d294e8ed82f442a4aa88a15296ad0b01d2090c7507a6c30a9af14c9b238a7afe60f3dd105c37b6f3708bf52e800085b8a80f85feb0056d1ba4c09cd5bc6b25a9100ca1c57dd6c90f1cef3279261845869ed13e62a07b9812e7f8241c9f43be1d398bb0b0c23b4753e171aa6bf87b60cf8ddc3271ed8454327f90c84a71477cda9fdc408827cb39f13ce0b28e560b9834ec43a2e403509c0a54773b223b702e1738a5bb7c198b66675cc9843fee7174f7898b0cf3bdc7c3dff5517c2bc8fb92725558a59e3d3fa19c7400dcbc2cea03f618c4dc5d88b7b5c14f54af21eb0c5e4d689bd922af94761a306a6a3bcbb2e15024c825ecde36681f10c6ee0b78a3885f72d8c2f6aa49717b25c3ad5bf439963ae80a0e78cb7279c59e83137f69cd674c3cfd42bf782474fbe09f0d960bc6f9211c703fc605614f44a99650703d97f4a2d4c1c10bade6d44efe1e47cbac2675993dc855b256a58cfa5acd19a2fab0099cb5448e4e61c5710905b18210e311c7f76e1db13b79c5a3c7e5df6c7b389315075e669569b3bbe7bd2d2ffabd331e1d2ea7f1d6a8c69e5ec1b855d8d0ad1ae6e4ac03ea039cf347d6a090cb2f0abe4b9ad89d7198730ddf9279bc789d7febf8ed2378562efb90138f12ade4716e92bc38bc316ae2ed951581f37c154cb7382878726b44f79edf3291de1f3ee1bdb9f181b1ed51705d253f8bf4d3bf9ded34dc04ff4e589db92b2039264ddf1f1f0c9b628402d165e4c4af9e9b1588c31a0a2302781a133019c92c6e930115bc4e2fb4ab2aa7107551904c0f79e395f88a3ae3d4032b70a7335a4fcc0bbd2b565a4a3d611e0eff2769e83a56b36a87b48bbff3e5be938a1afcf0172af790cf37a005b8b0444021dd86115737c2b8a7b7ba2ba470b35492830f5fe4d549d6677b72c5670df021de0caa2f3e48b0559d622565da9a712f1ae5b5ecaa6e205d141f5178367a9930d5529343923637c278c0deacdfe43f942741eda4c68eda5c0b0a813ce9b43fc3889d3e50f7066a946a34590b979a978d82084dfc43c2e51bbfa8d627ae13643b4e706602974ee37b0b5721e98a9492a79bfbaa0066ef2afdc406a0e188742d3eb64b077e983362ead1241d77ae282c174381fc2ad77b13468a19de5cd2ed9f41cef523985b9df0847e487f71c23dc8860eb64ed68ac15f767d223fdaca78bdf63e70bd032e5a9c24570495e64699c649fd451d9c1526fbd2ffb011307147e8e9bf85c02c6dfe0b5a2ef2cdc806a24e3afbbdd8d08f2e63b90adf59fd6759eaeb71a6f2afcc7fd6fab5f03987072f792e02bc304b7504f3680226c519e249c9c30c48cf81233cd38f7c06ce21b183543a592d0f5881e952df289865c6cb1d84e8dfea0cf4ca62d65c06cae99c79186f4e3d28dd1186dbea958aa4f64fa2d7c8d0914cc6c6d0a0b43cab6d8ae067b2e83c778fe603bd3d0de67e858a4e4b9bc19138579b5941b6d68d446bcd25a8aba81d1606ba95cd54c9f46a1af28fa3dc57c07350e9e12f0d867d2508188def8aa0558082b2ba92a150b713327531f83911720fe433c5e934777a6c1aba5fd1138e1644ef2a404210320a76f8e7afe1780bd8cb5f05226448e76d18790393e75b6e7f10583559fa7e7a412d11cc3d5d2baf2b04e71ebf7291c16a41064b853e9b5551f01f1e6a9b9e8f1ddf9b8ceac7dc115511c4b02345c9290509c7cdc9ee35fe9ebe6ec1a9be560bc31967901432ceb495eac431781060b97a9a3fa3960350a861889efd1b3928331edef7459dc915e1c60605ff79a0f25add9102e21ed3497ba14ebbd15807d8557011edfc6b6b6e2096ad909a7f178b78aa12f2f87a7a14fbfbd8bfa4fd2cd0b336c4b723aa027ea37c87bc0a759c74321f8ea4cbe38b35b54f68925cad874ed9f3dc6f85a9a3db8097011643ebe0d8529d60b98981ef68541c971c72ea3a13e7d8db3f2f17daa2fe0843d156bfc07ec31e40005df7496bd7281a17dfec92fec7b274dd98e6e744ded36332982c7c6a31e64e7ca61ad672ace645e7ff3376a8785ecd31d48390fc5644dfdc0bc5c061efe7dbefbdc94e2728ef68bcd4a8a9694b593bf9dee8b24fd32bee2b64afbf8d546d9d9efa0a48c58af546c9c937f4008f47fca7f6c3e59017e26dc9936690ccd9dd089d432b78e017f31b644ad1544dba253cf0fc5ed4b9661d3a8f627542f577982919d92c17c1b439f22541042643f3747bc68605ba8aa9b6041937842b3e215b7b99da8a3636195ac3afe541c1420c125decfb43bbdc92fbe94480ae55036cb38c7b97e69ca9913176fbfaf3458d6be9fc242db2ee98b0e999fbae58cd1512ceca95946e1fb43c4eab6bbb6f2ffccd3b2ebfc6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
