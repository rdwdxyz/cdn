<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88a2e7a564caf78bb988a9702b2b63d58457e3eecf9cd16efa96b07d34733d9544c7c5e6faf084bc2e5d94c250716de262a983bba2e90f5b742ddf39b4f61c772cd1a5798d6177e5aa1b536a0edddbe02c62a3fe01a227e5ccbbdd045764e7bcb820372393ba056b96d73d188fa9b22df79d43af19b563a38c7ec6aa91b95c8709c293a422a197d8359bf260ac2f4a7103423ef0baade6e4d13e0fcfc948e2efcea429e6e7df9bf03d104a4bcac334274febd7a8d35e9047ddf75f5923ec995bdeeac3dfdb90a2f10fa9fdef0a2f9b40844b47b7db7319669ab1822d2c930d0aa3f9419735419551581ee2709c24cc80222d8d5d13e8f281d47c993273277101fba564cf4ea053c5c485c6d8fe5e8c4b80d293da10b3f8567d1699c30162ad2db36dfc1d4ec54d0762860ab88c965d95375302899cf86eceec75af501c8dff0c9b42d9f198df3792d8afa25dc094e20f422a597a10adba81493e908ba9d24529241322f6119908b67946238e9efb87f777e9ea0993bcba07247fb1d9acdacff15888f576ebd02f846b6cb4eb090c2999b1b3c8bdccb0f6b798c63c69d317b73bc31d1edae59d672c9dd13931f196f4631053e9d5ef496fd7a50af635d632028504ed3ea37e6c359e1884c43fcf83c52363fa7fcc1f0189b4ced024b2d37ef029949c966cd0d399e7ae14f88f77a2c4c5597034fd3c5faea56a24daae0c0af38fa401695827cdee7b0880e4d417ca4a55ce18fdca65a6c5c8139befc9652367c72f09b91f61b484d5d9aac1466cfc2af6eef5a64b74894fa6e4bd9d437ac893db8fdcaafbb3f0e449121921786a316aa4651fa7ce22256d44f8a1b3af6534b38d6250dff5cd46122c01c48bed870e48732b83b6ad20b57ce3f7aa131b8c865bf8a9277ac6f135095fbcb822a86beb3ca62fd2533f71ebd32aa0e89edcccb0bb6f6b6b6665e5d2ecc946a9c5277b9c2565cb0fb71f577f51d7817c7e35c1c582346e0814d0ae47761d6fc62e8341849260bc011c7ea8ac76a011b6d11808967a3287c60b232c5c39312e8b9cd6b7ee9e9b0baba234538d24509b44d862293e7d5e3552167ac56da24d2fbf56fc290c1d7bdc29463a0b51af94d2d0bb4257438b5c2698eceab74dd71b74483b8a269c809b81cf649f428e3fd9c0ab8da7f027c689a1f987bd5a0bd41297ff26b162e9889c2a0a0e3c1d0d38c1f960c0469a0240fd9f83985d1261d23fdcb20a4ea5fa7bab8a764ace28786a52db07bd2eab646bd8255dfd23c738226b41142eabad267eaea912b566830ff165d7a7e37def2801953bae30382bfb107e4eabd91c95323623e942ff1a895fc9a3e52fe4b31c762207bf4396971590584a2d2971ebace55bdc5bfde37ed3169c5436799fec9bc53c38a09889d09d7d888522cbc1c4be7b7089c08715b924d94e9971ad781642b53ebbe32f9fc66112b7d62f133d13776a11bccf217d27d66e491a22a36a0fc59c07baabe5720bab95590ea1c49c69bdd621ea11e53587135f24685e87aa92fcd349d378a31e1bd7a6fa2244258bb97413ff92f2c3c3c90a0f84b765b7c59c5d552a81dc2441289f9546bfc5c69953c87c58fcd4fa9d1f6fe2b4fdb1573cb93eb07ea7dd701d5571e881eb662f11c595debfe90760ef51daa76207bbd52afd454ca7ee7de4daa4eeb0152045f21cd383035dc7a02b2434b9d92f7e91c817cb90f963e1aa4bc4375823bad3fba046b2f6738ed199b5dea7866f4d154a5478d446daafbfe554a48e8376334746fa55ddac37a50f69fe13d0ba688e087ab6bc297a96055f5047da0273309f3eac207610dc1e9279ca4a73984432d0d5af64df487f26a27bcece2128d7d4141d1bd0aa6c42b978b351a8f9a2e792c6cd03572d2b10d6271f34836733995f37d1fb91211815c06caf4718afd9ca7d07dc183cc64e22981071089ea1ed66c1652db8748f7ca176e455008c39e10ca65e6cf7c19ed73545ab5405c4c5bf39bae4f0bb6d3c20b1888972e734824ef78dff32f794c6af08867d60e422f21d3999fe80b2dd2a6bdc678cf93f10ed69b24cf747954dc67360a22d13d6b6c5596b4b12518526c61527410cdf9ba3d82178c06d41871b2b32bb5d4a9032e06c6ce7f82ccd7a8f117d08e1dcf14cfd96cdaa2910756ced0e0423537bc55d03ca8a6bf5a96599a31ab1efb7a75d7e03d26a5bca65dfbf0e60faa391a7ca51edd46ee615dd36d4352a4d1dde5204fb12a2ca2829b44db7f79662d28a35d05052eee5cb155bff34f84c177867398799670c2db3c3220f7d1c6b4beaaac190742ef08d14097de43f53d238c6fed15f1297cffaae4d4456cdc2b84a35ff825066f223a46a4caf82575b2329d01563f1e3d21b874cefbed708d7f5f740deab79607e740465c750d318c4ddb59296be2292b032d94f09277612242e6d510ffe0c765fbfbb267fca258fe51ebe2ad1d7d91750f51833f8392c39ca051e9a4daa3830d70ce23bb3af88ae0f1dc08a5bb0db8d01648bf60b2386279575d11d5da77cde8747ff958b96a4ffbc9b24923d58c2db741c52332685e3dfa72eedbfa79d5bfe15f2f57c63f26ab38c183847e898016a24ac20f10ada900f32af23eb4ea8f0e642c2ad1ace4b4dfd9c2da6adba8689c1ee0b8d6200cfb5ef40c373b6dfe1cd749603120ced86f7ae68ad2cb57a34e066fb633b2bbf0d6ca5236b3387c2787d0ce381086341b0e9144b1285424616ff123e4ceb8ab75787e334d8aa2443567221b76fcd4aa767c99809d058ccafaa2b46701216b6556e57b5e8e0f8151b66e70cdd955729a8b380ae17e826724a0783f49e52cb1c2ef0a83d3f636baef3fe522855d8d89d9e1644151f911132fbf0a7f8a90247c6739a6c555d42db9671ce7ea867ce885e0ca6e9f31d86dfb34c4a8d6595a3a27674696fd9b7b689fd1387b4d7b90a87f83420880418a4141e8189a0b92231cf5ebfa0f160d09497b94141ad5fbadf5ef80f19312e1d009a12f02fe4b697c607cb12a354240e15e66d878c5ca359af585d7fb09e7eddca664205b8ad3cadbbe01b10c40652426f78af8834fcb774694b0481b2aa62468a89ca6ab2fa61462e622c7c7aeb821f5616d10eddb264b944dc023f8a895bd77ddf165f4cd86355f2cfd10f959dfeff5ba6f3542d873d8763e929789b3cbbe34e5a88c6cefb7cea3cb9cdf780395aca21a33391a517a4b1a59cf503ad6e965a7c14ee2aa69e3fa476bd904d92aa1df06778c9043713d11d6a497c0a211eefddbd78aeb4abfa3bfc20bdcf0013fc97742a77ca2b1d4115be998e233fab1ac435049ec10f8d3d54d2ebbaa38377ac255369d9701e8ddca9e9a45fb4331133de57121218e1252d5dd630edab25585dbccf70161c9cc49e7b2a7ef90d1641108b94f5bafdde5bc5c9dfb67749ffdb93d45b5a9ea0e01d502886303faf4bb9ec9d544adcf732bc76a487ce6136c081001d92975cbc729c52e95bc3882e58b7a534b15922e652e5890ec4255a72f2ff35bf2bd495432b6fa2825d7b7b4e7fde064ce6ce777c259e86bce5d177890522ff9cf911f342bdbaf12ab7d8443d3948c29e3d8021894e50200efdf419d047204fce4a4e2879e43b8246551a6d377da5f25e6a8fc7bc2ea8af59f543f1bc691b11452b231abf01a33f1e57272f5f8ec967c37838bb238010dfcf9543e65eb311d3bb48eec2ea084ecc360939965e4653e790afbd3fd09220a347c6b8db78ccbde56b51cb34554f31e140ee35d9e1cfa96376ce95592cf4cc99f7021542b574c7f3335326a689cc69438720fe0cc6f38b97e5d415ab3e958b235ca8846d6573820d6c63d18d188c218c0e71bb6f31ab21a5f56d85b191b1f9a937439a35cce7aad304828daff1db24fa1f21d3382d98fde6fedbe1c0acec79bdbdf7db757844b7a20736ad0e94093997c802877fda10ae73071ba33787ec7e197daa7eb1dfde7394c44f4f8c6e18ba94dd970c7cabe0e28af7c90eca1f928d2024c3726b6a4699502fa6ec10b74e646f54bf0d0971ec4ca525a40957b1731cf6b04807e0fffe79e1eae6b9fbe2675bfc6f50be3c7b5024b1066129f5e8886d672eb7340fdbfebd8d4bf3ca954627eadf5c2ee9c9632911aadddd3f3e75c86d59fba6c8827d971a10b266aa9c16fc0ef610edf8213cec0fb950f9f52fa405cc65672eb885955985cbcc97b85e90b349826f9c62af6f5861864d2e3df9c7d64dc1fd3976eaf805f8757dccc08c98fd6eae55b503efba2b17209800f40ce4d3bf5beed1c1aba6204acd4b18037b7932fa80ab1df863d7cc4f9ee6b8610341480d8a30fa7486b0689a5c09595c9decf31a67a98c6f728985c223f03305a9d61cf7e47aca78384135246beb5c8962cf1ce0db4fa664adb3c35f6d69b92508d0872a8e45646e1055834fca5259a5f484c017bed839d4f6624e3f5c1ff569ac7b3a8e8306e918e7735564e35a533e221400ad704c865a28cceb38f04b65801e9ce58280e81c384d5fe0c2fceca467f4be5d5143d8373cac62beec5fcb2537e28549eb539bf42361d3329bcd9432908dcd468f45893c0dc446a8fcf6bd8ddaaa2c0bc13a74b0659ce5333d437f38be07d857d5bb4f412f70e23961d93989195c8c79b61c651de273f0e154b40a285bc9e70460d88511a685c8b5f9839300afe3e050314f9e0d77b469ad9de6620ec3a085b91cc2272e9c4b624f1cff4922d1bb03296539a98b16d0465b9c16d06aba8921d48faea414a1d7715fbbf1ffc88946358121d92f1a3517ca350af3b26dc1a3fa9890dfef840879453fac442b442129a197e9173efc15e82f7a2c7d71ea8f992a386c72ba28d5fa861b2cd03c54bad3507bfbca574fbf7e9e3264c0b75223746b1cd7d44c6693ad8fec4e66da2674c18546a90343bf3eaf969d689f598a3640a528e1c23e64652e40517594e5fabd99000b0f95d23dc8553708e668a76fcc693a86680a77ee954058e922b5eb3368ecc0077b3fe3073fb9808a4c1348a815960dad099ec776f8d144f4bc6b221745d5aa3002aaf384417710b22d3aeb9b3818aada654c06a0ac3e353f7ac6d3b6a2f340b56c74c5abb4b2a904b6e31b6a82935928e784659c022f5b4aeab1e32a9b885890c711031b83868dcf910d34028bdabd4de78538c68e599dc47429593e9c7f9b7e7e3a0bc249feca622ae4f85edd3fd93046a8f3f314f299c997461e0d59a2b31185588072398282b33e1d1a36e51cbb499202dbdd22fd7bdbf9531353a3dbbfa5adce07f873333b24505691445dabea6004b021184d5650def1f061f6eebc10dc91496513548124fbf258a75c3c164731a2da60b68aae0c78ec0033b5d35a9ba22dcad4cfd64f3efdafad4e04cd70250a449f4265eb3b39abc206238abd41b9f3ad492af65d66612372e5db233a1c9e2637996b253c2f2fb4effb3edc7f0d4e67368ccd79cff8dd34385191b5bb83fe3aa7170e1eb852146bcfae7014e05319abf3298a269cac602d63ab7595913a51f0e55e1495d312c08fbf989f3d28b48e42dbfe510fdb0e778c8009c3983b48ecf91c0403336982ae9da4e2c43f0448213f86edf69617a27c7a53e2cec6a7f35e7f56e0567e80585baf87adb2d8c6d53af61db686b7056e7f16ce768838b1e0973c703fa0819dd10d0defa0d47b5fe16500c1343fe21fbfe5751599d1ef448c8c3ff5e39104c3444dd4e458b4af702999970e9acf444f7615e133b130c811f8d927999bee68ceb058d748a33be15278b7ad90d05dca0527639b203c5b33927794ee349f7b9e0ffd61404a67c280824c3e3995b7c19313df13f199bbbbe2afe267001cd8b3380f10ea3b3580090fc08d45cb6c32b503d55e9680c41cff3b7d3aafba553bc63bdb5070ddf49734564d22882bdbf0d911f64a551c0c0a41550c861c6763f72d7d439d108d66a3785c2cfbcadab57961a1450c3a352c76cbbd2eb27e95fe8f33e342b5d96e2814f7901a76d9511608951ffe18ba07d9ae8ebdda4a10e7608e95ca053d618a012da6750026a724f12bec59e4fb25615435e8ab13270302f20245e5ecf011755afe6d59cb9a950d1042d41c41005f6aca956133af38d0a2452ab503ba9df0685e223ea49d3ce1e0f4eb4ecedd575d0442f721e95d40839b4f3946fcac2e11cfd6cad86a1509d4fd0d06e1d3c443478ca564658b040c5d67790a19da875e307131d3db975d418f39ef222b28fb74f2c74a75b20ab9d426f981caff0bbc57ca0ab3203c7bb66a2a720b0d32d1e72dd38dce814dd9dfc381f5ad57c9b47fa21ecd71a93ff583f45ed224b0b68df94b4261d3228e2383e6c99b5498d9fd3924115c8cbbd5c40df918bc480351c38018ea34c56cfeb7879fab29c2a75885239e1442a0eeab079a2dc8b8967962bb157dcf9147aefdc42026a29e090f5fe66fd4954c71c209c1f57bf4dfaa1162dd7e953e88507c3d3e9ab6f157de61c7844d66999f912dd81e173ecad2a30796641cb2f4fd56f29a6bef3040700400c1d7d80c55800de266e85a2037585fe319451aec1fcccd8b89099ee859b6083250926f7fa053b25015aa2953e773e3905be728d14ba1d970a1fae36499add0c3a585f3fdef8f2ab97054595553f956959f7ef139c7aefa6764ae0d8ab753577c6f5924d4661202bfc0f17c48e5d12f17bc48fd5895108a50d13804a1f502be73884a34c5948407c16d14051e7fed81818443cd858e09b07a0f991261532f7d15b2da3fd3ab05f91ed9ddc5ae6fcf5c0bee48836c0b79678c40de46d50de9bce2011690282561d9b62e3ce04b9fb16366923e5a3e60d9549af31144bafc2ae58c7f6b7dadca7e173166f8e04ab38712021c05175296e088c32ff83176e9bb833ace05dc44155c27f59e0a5c6b5215a56594dd4195b08751cee84539a4ed9eafdc7a13ba59ac325789ddbee9648601addd42652a1c5e58780ef1efdd76f3cf636f19c24e736541bac9d63eece600d914f647eb68782f7a9b66cf6a96501ad93dc87ed2ba38625c761d63ac2ebf14a7f8c4862e8458e82676a629af3e927fe45a9ee691024a2b76692b87d6849f038b1c916729fa39888b319ab95bdb35fc09ca9811f8a7c26981c5d00ef49a6adf070303964f4e057082025b1c3c6a3909c1aa597b15a12a77ef2e675db90103625297dca74e3f35ae74bdde1ee9bafa19252d318dd60842f3c4bc959a2e4a1891867c1253a267b384afd2f73c18c0c50a81064af2dcc27fa241034fe559f9f4acf7c28e5cf1d36594748d78a9c3138341f4f66099d12daf14c9ff695cd5b2acc7ec3a78f3f9eeb858cc47a67b6122e6a36895c434fc1cf55168d1f3bfb0bdb2d9b40a29a05e3351ed685c6be9abf5b18fdbfd95ac0fe61917810f2d0c03f84e487f0498c206826b27061a6614549ad0852b852562f2841e61796c5cd2af115d2f552bec57be264121eae3654273e4dc477938278363b7a6ee2bfdd1c685a7c0747dc2b84ba9943b0785639ba7051c4c56c393f0792d51d52155217946e1d2f2a576f35257d6dc72dd5d984a8bf41167a8d23de87633b1dd9ab13e382680b9ee928bb269bb5c2de22f8353257aa940deddfc4e886378e7f39b87c0418479f5ebe1875e6d5c770851bba352b2001d6dd2b00b5d39399705544a14818d17a9fc4012bd3fd258bdaaf86c313919229df65ccc2badcd8e9eab0c3a2b37efae346e0eb53eca73111b42aa9b06539fae4ba02fbf0d50029bd6f7372e4bb79ce620fafd8da2225b083316216d2f36c92eb1bc5662ca2d92e3df77782ed3600fba97b0e52222145721f88831d8452a57e59a14fcce426fd28f5ef6843024fab9994f7de1119ef0cc18399342b401d506e1f1e30bd83b813386134d1fb0fc263aeaf15ebf117219241997f60fde5962cc109033c558d3f88d71279d1d5d6ae63ff639be80b7e5afb24e40448a61827af58948458659330066255ed7f51a7662d7eba48892aa8eb684a44133d2ba752b15c06d19a1f781b26c55602e54cd16f19063b45190e76a624aa3490ccfd79f7a1ba57f9649fa463af90922a11c8829885550f97239f2292e664322ed258aa9a5552279f4be781698726739cf5f67ff872834ac0878dee4aefedd761c46572c50baad5ca9afcaf8b3d2b5a002560b10d3fb0b3d44bebc2c340e4777889ab11ab0e3cfb89cb82bf56e834b8604892cfdd098cdc13f824dfa85a76a8bcc7434179f6adc2a572c41eed245cf289b07f7b9478b6ffc0f721470d78118c35076647a664b66b24454b743488036df96e3d81c2b3795f123356490d77477a4b03a6a35df5d8c21411cc66e7b75790e9b377e559cf644fde756ae987b4bda576090f57ef116570fe8e1915ec66e04d72956c6fdf6a28a02a22ef3d324446c6b4291ad880a94574a04127ed537a0438c2a4acb6c56e2ce3a64139ca2f10057a394bc33ffa5e732b585b277da0ab3b75cfd9f6b3c08e57f14676341a46b13ca95153b3aede8bc46b9e9c81691c759a69a413239b64ed5ab890be399e3b0b1bc8e1ee69b355620642d0e4cf1f6abe4aff524a302046ebfb34bc4ca757ccbe32f846f1664831613fadff2288b4a11fb46d6a8814c0c7d2caad46bd742d88413f1abe340a99929f667210c517fb0285be5991af62f81e1b462d1b56c9ada44d733fd481b561185687c0f8e1f24d847b22ddd413b25df7c5d6714436dd8e381255529a87bdaaa3e623a05401825b44decc69f3020bcb29f1b0c9eca39922db3f8f42d477a7fe27314263ae31ab76c9c4e8fa58bce81eb234638ac6901898076a8860fdb184a74fb80d1f49784224755bf9e517fabfd0a2498be1130e77081e7bff0426beb830abefd5e863f28c701a8bc7e38fd2c1647affcd4d8f21ea26bd670c4b3cb55b933de8d79389a3644630661da2d14f256f2de6414c1ab97e090748201ba297ff584d20758f06403cd873dd3d66074e16422c4a1b86e59186f577f0770a24536ebd9e101656f8fff7bc8cfad0afa9bb1b2f19fac41344c17fc15a9d9e459dc75ed1ac0d313fb47e3207908863be313cebd1446074f8c4a6ed13f4a583df8682a3c126cf352aa46dd52f9a81585e9b91aa0220a5b1995958f0041dfe5ec1e17389f0249033e0d4c072a644a45c6110e2a9be1a8561414b095b3381a05c34e99178c41e9de88a3505142bfe5f0249dd44efbc12be2facc893b1a6fde73fd4bd4961476694e2690d28082547dbb1c18e9f0b57b6fb64b8794dcf18fc3434c5a6a65e8922dcff400da3b005ae75595ba229357506785c3718504a90816e2dc9bb484c9e7b8e98818246cdc71440c55b3ad280ae6d16c891f0431bdba520feb5ce4d0b2f6829af847f5805ac524b944f7cb474708932e74a07a91b0a4af80e641a2915ce1bac83795413ba0d6b4973795aa9fba69814b3f0ba6f2fab7780b00dd021d3bab918eb66a6a751db1f65e22606a6f027c97284127cc05d806249177eaa40e504586cdc94ff8de9872986ac3dd165e3fba5e46d9cfe79af2246a5aebcb493cfdc0c1d6ad48282bf144e8e505bc106c620ae81174fe30c988ef975f6cba2d941e893e7b2af8bef71f0162f638c83dac55ad4a818100fde9d55a3728036d584201477b4ada4ab71e3268186b9da43f8e7a24eb40ceffa8d5abc8f4c4b3870ea9b117eb777081a58551abeb7aff4ad57cbb160dd5d1c890c21ae1cc31ab4bbe4c32d97f9b2b7a09b19c1f23bb087d02f00e97d6e25648406a46e46ea7261b224940d1512a3d4296cf1ccd68e02bc791b6dc36b96d67afed065b12574fc83fa6d0211596bb841d39acb947962d7fe3e230e9674b403839e444d0d91c3ea46f665912ec911b16854a315a952268bd2470d2c80e1f09cf4fde0864a808ee93748715b08ae53bfd403ad1204951036d1da55fffdc0d8557ff86dcb898c35fa464bc815118ececfc23c1cadb9574e4669f818f226ade49dbbc938ad074ee2d86ef62c382a0989bd06191fcc2b10134a0ef298e1cc421b077e40b492586fe6b799f0df1f759d6da649c5a7bd17efd0e7fcc4c252d20705a1575092c7bf46d1aa75f1f5413991c072c5adb06b8c7aafbfccf0b60477bda7bdde36b8d8037d0c20f64b19126692ad77ea843e343a099d4958426c4f0fadc6a679062800e32435f5a029feca377fa7a25ac7ac0c46e1bc7d8edde39535e486079acb6ae10435f91989696d9fbfbbe15082475303d63b1604186ce86a0ea3e85064449af298d050942853f9bd3ad68c8080f343d25ebdae13ae55465c011f4c6edff884b6d548e3a4c08cdd2d95944eb877b8e590329db8cf310adee2e079b2c1de550fd58e82aff168fd78ce5939f1c3c9004577fe1c53f6aaeaaaba85cd5cce8c5e4ff4673ae24c17a637fe234b908dec649efef51a296fe5106132e3febc72afd1e12bae7a2daab2e5309b918317990ce6fc51d8c503f80f22214ed56933598c4a8717f39b35d66b2c840cd70f38695a1682ef394d5b0b12356a98771275fd5b15419916cd125ffa1f946e2e04ec1bbb93b36e9cd126777c16273ba04923ce3f7f04eede80c09123cf1d1249b0ac11b58d4ce722873be4a9b2c8458facd6b98f907c5ef0b459eaf11dbcaf0d270e62ad4f68ae841b4b715df74af3bc9ce8789f1476984ad593a6214ab2ba390ef514b1b021961f0e234e6afb5e2cc9e3681c7d22682abe2b458d5b3704df9e3c0cc794c7bd943f6637df7a8d3f5957507c58e4a1700c3a3103f5c5697f5db2021f58f14f2dab1686b6205a59c722834e384772b3012b8be39e4229d0b5a0137c0c83171f881bf8ae3d7417cb07bbbaf82bc9688273fb31683257c94354a2bc4ea7c3331b3239ca94a8119b5efecfd9d8210e96503cf7d293d7df28ae6360b58024acb67978d8fde17fddfcd6bf503fa5e47dc12e330c7e2fcec71e96963c710446f5401c0204aeb17748d2ed93ffb1ae0b2ba231d07b8c3c623b42e0fc1816cef43a41ae8675cfae1fd14e72ad5d261b212e7c4a1dea216afc624fbaae975ea47976a0b699a89ec12c3951872363f072ac65a425401074396f04e95cddb81ec80252a33aa8255e2760684d2c438949fa3a6ecfcd3d3ccce82470c670040ea53a9bf50b5661b97497952f2831c8868db68b026f6ebce607930bcb400389c5f4504217e068125dcbf83c0806517d2324ef1f79fcd4b134b6d7fc627646b4ac88a1fd0d719943f52af7107dd687d92ea45391ef2d49d6a25e6b4638568cdb10ca53ed90ead450f80f14c8a772abf56749cb1fcf59e1fbca67a4111eece9ca11234eee0fbc1ae9b0859a685cd45674bc2f7e9cdcc51637f130a9b96ccbd6646e5d50ab5d24a6b07cf6ad5d5018724eb271d546477609dacab9cc95663376eefa5de3cbcfe079b4f7ce90ec835ffd91f8d8d8be99253ea3eed9436b52ab0d227079440b5371ad2b91893fad17e4d440b960bc8c10358dda3b5066de413bdecb38b996c15dfae2ae6d249841e3fd2a8e59e18ef6791501511f7d88945da3b2b1407274d89be9087d94e61a2269506dfc491a62d6ecda90d0e2fef5814da7f5ee7d91c9d2150323ceef214caaf25ea28f2641899654c45f1937902409586873a7c7d4fde58f40ba361db243ad452c2852bcb9a478eb83b420ffbf7e3c32e5fbf0205cca83fca21608bda8cf502806a7a27851422ae0ba009086fcf75cdd0fe0019a1709880bdd5957864b4473efe6eb24b31236f32a1855d1c445d71e68efd376910e83d63dc66a0bc3941ab8b0630b53a43b514ee1533be7388e24c8b4e723763d254efb3307bdfda83b689b12c4682aa1deb9019a39841401bc3ec8cd62308cae2fab8b04671771cdb4d914aa9ede78438e4c2fbfa5f28698faa8eaffa0656b1cd9049ffbcbb40577d39b65552e5e60fa6b07fe985091d5fbd453675fa7a6ee7b6312d82ca81041a96346380dc032f542b2bbe916f50fb77734e42c6c58cbe2ef68299bc6ed22bf9c9a224a4b2763e35994d45cbba4f657d90d8cd6299dd6f3a6cdde75eac7018c186005315051538b520f3393d4ed152036df71469a0571c1a99aad27aa1b08b60a14967997ce6b88602927fdc8a4ebebb7a76b12a8553718925951f2334748a0439120d6e0a904a86fcf867861dbbfa92d344e6d926deadc08895049c240aae24a5c29c3fd416b51680bd7f3de25b4a19304add3ad93666757d1c8dfa697d8f3f42ea359b970fa78c570c3126a9380eb891712e95b61cbf43ee60bccc9febc6c58aaba425529135184b6511c9092008af2fcda41d72a9fae91e391240b91f88c9d88256fbecf1732f9be0b463bcd6e2440311d118f13155c2b37740a550c5c6de4a28028743853705f01ec9876daf694e8965e512b1047594f565b19568b31351714539e338bbcaab371d41e9af16c45f750efb7ef0825893625845169f7878c78b56bc5eef79cddb64b5b389b00b438e25fccfafa54b39155e3af743a87f9100b42508478539e99c382bc08d9a21689818bba8e3596203a35106750c4285dae6eb972507f8c4ab33d0aceded3284b95f71162b3ee8088c0b1ac439251316625624b3141306b927271aaac4de642770a6864937479d2016879eb7da365a8ac4145952276022d1746d6d05522783fcfe9777b16d9604f387667c41f1b92cc7f33213757c614f4cc65cfba5b0ed4952541cec05970604fb71caad6bed0f3e503544da0b4e40050fa7517deb81672a7ad8ed55cc17aa36f653d80c1aae88bda42656f167e81d3611df02e75504061bda327b1333901ef9048d8563df87f337f12da68b0a2419e77d1358ac8d3d902587c73a3fa0fe7c3e717cf16067a95629042acada2a7097939921acf730be9dd6cdcc5912ebebd0ed995bafebc04738ff615efb49f36750c5276c45a083f29462938a3775aa6255bb21ee8aae88ea8f1317335eda5b631b8cf43e8e5357cb28cd7828b30bf9332a55792fdbc7e953e2af6cf1691ac937383b2fb5fb29205f6d332f21e0e3cb5726937b9d4a7f4f0a7bc154ba2f44a6d7254bb765bbd7cada3748c8d73767b2a197c078e2bb8755e31ac08d63ba7a40e85f745b426e69f1d091f8015aad84b5d0dfcadbe4f7b7dff07b59dd732bbb1e0cc4913aa5c272f54bad4cc2c619e798a95013cbfef36cda1b2d9c61dbbbb3b5b1dd30864f5dce892c338cec83074a50c340a4d4a5293b3ed61243b3027988638f29a66d082a90b9364e21270df030a83e6c31fa73e08e6f5e3beb50a504071673d5ae8e7b08785145816335d9a4c892446b7c8bbd72571218e0b4b5c4ec2b34bdbbba29a0476de988094f6d020c36278ca3d8080ac2e2fb21b525d4cb00d091528c7304657484daa731ea09b0c9fdbdd481f6c4361582077a5ee3bb481505c921b3b47aff5f8d3df04c1b9f45beef537581bad35bca13f7d93b91de65667ea2a06f3583f69cb3a34f651887cc2462e0bc7bb82df0f092e127ceac7e85fe4617770620b16b6ee91a1ef64f68b28f4e9143d6a61cbbde11ac9ee1b7b9a92cf12d32c6699f1061d11ce169bd3a1626b2ea85a6aafc93d5203f6626bc7db65c8756cdf501fb9d6ad9a41f210a10903b91209d7c25fd68c7ebd13a69ad1c05a11aa58aca924749bc271a51409063b44c7ade36d7c33c24f1a1b3cb4b4be1c971369fc6e304405add38e4ffa0a06b732acec0d3b35d40bbaa8e51015c6b7ee4e1115a624a44360ca64d3184b451c58da2c77da5cb8d753aba117a4ab72a1fbd60d11df4541d60ff85205f651e318e4efdd22b3e8e5484669e86134eb9fca947c28b8f92babd45482edfd5492b1fbc29efdb5ab43c8415066aa4716af34a82ca13c12f835649be9dee0e8f7def2199bb7667fe989d803d6e4e88941442d1520dde5518bd9cdcb452d1a8c863f761c5dccc566e20a50b9a31850983894c6d0d636a448588928e1b08a0ba38ae0e1de045838254cfdc7242534d5ba2e696994ec75b55bab027fff449118a6ff2d1a15984b783cf56b2e778b9702e4d5dd591b7db3814d5e83f30089798b0a6dbbbf281ea991e1b66dc62781334cfe16f89f56801292e7088015d4dbb5cca08a193d30774c04e05a0c7202affcdec8dbd07a16174b29b470712bd72f021701cfef16f9313dc0f2f18498e1b0338f1b9ec63ea4473f0e548b023d96873569070757dc7f79afc5cf0da6da174c47adcf3b14c7d2b6495d20bdb64a584ad3d64a2d07153ab7602439a81fa9dd2a328d664d1ab85dd0b650ff379858c429e7279872cf98dec9624cd1e07a3dedac6146f90d004b498a8b2198f53e507adbcb88db7a2e05c3807d7587f6a8159ffaffcc27ff4f45d9db8de057b06656e27824ef83f5100d4deae3fd9b97b0db8361aac552d124044c1fe0196bd586af7325dc4bff5c726c0f6e4440db89872bab84695ec0a4e5be5b2c1753fc5038204b73697746789804cd0bcec47b722b102efb68b9c694c623e40fdbae572f9b6448809d64250f761b9fd9043ca80cea613329ea030160a303837ec03d3a5126d1925e40f8a1d9953d6a92919280638670337518ba4e974a53d711a29cbbed814fbbb82c30fbec87aa2ab9ac837bf1434365e591422f0c3377814060d188881e51f20ab6c3380e21a6e0234e33ef2ad75a67c61b59f86d9fc170783a123bd0b75c10b7b10aab1affe886f71c906add90387f64d51f9c16dac578afa5bed5fa022f1e092fab91362150e5045604f4bdc616949d9d1952265defb5c8980bb0e8cca3ecb6a42ed2304de16856666ff73d482ec4cebafa27439e22db6ba5c29c78e0bdf8ac15bd5c5e305bbe483fae31c6ee61a7e0be67591f062de837a54684e6e3cf6db58fedf69967189290a0d158482a4e3823db3bd76631ba1372a1f6a83286073e130a5f3bacb3c751afdc7426426e2ac81d1dd57a5f7d3e32384a96c7808b9afb9902e132bdc48bc874af8e123b46e78f4b11fc3d8a3a05204a33e4e75389f2f4c599350d1ebbbaeca6931468531732b688e46ae05493e386e4dda9fbdac3dd8b3ad23ab075884a7e0e1049c02e37674d05671674ec01f0457602af870eaa75c672e309b365d0523f601a81dd2947668629a365ca63236a3eee6c7fc1f63423a1b86de71804d814542ed3b15e727ce457d06ae7e91316e4506111e5ef1179b91cc15a0de7ab6741f2a759c8784a75e22be49cf3bf97a0235fbfab0c41eaa0fd5368a44d220505fabd1f37943671d142babff451392ab71b848819f54dd79b3265edd31a0c92d4df6cbdee16b8fa44ece67dec1da29ebfbc74c1c50d11aa12cb9b74eb665c190c56fee12e4c9894fef50443bbb3877485f1fc671ebb1731f877de332b5d03f8044c4fe89448a36aca198754ba63a351931754bdf27207120fe8a167e4739913cf10fdaa0053b03db96195ec358ab866a5743efae670f727ea7f0fbdc513e02797b6fe45242386bad275f33fcf6350e6d9d76c7f7020d270878585e43994c8eabbb7d26638131ee2bd1a587a5dbf7913a3392ae7cb51b51078bcc148e4025f222544da671534c83bc3e71e6184c8c1aac0da131807e20b83500692c8fdd0e13d03f6ce3b47bcf8a9d3f0a06dd96ea8584052fd84c1e15a5890cc8b17948ef56dcb41abcf6ef1b158bebae5f130e4b203d3cc9f0a916f7cd2e197c10c801255de85bdba3eda70c96208d7e7803b2bf98a918379851a1160ee8fd8678b0718422e77c45f76d0fb7d23455324d6d2a04adf29196aa62f340ecd2c6ce2ed8d782b0a0f89d498cdb3cf9b310878854c24e9d21ccf1d0fdbcea56ade1d073b04ea7cef7c9916c4a88c5764da5a903da0da9a98fa73f92dcf466ddfdccf97364c862688c31902a7f25bd8111233c9090c26f942899ca154d66f8ee3add5dbf7b8513e2d259bd0e53bc604dff9083815ac85bae2ecd27bf01bf280f550889a58c487df00e93c6643f7415580c2879e6699eb8529179222785777bb2bc063dff4a9c7f7b695c5ac6521c418e3971ea3e5a8ce4e830f07b362b94aa175c35e922fa8a23583d19119fb7a0abe681362f0f39eb7ed13f1ec6c66bc1cf7bdcf0d97c89b22edd66ffbb0137c279fd1d396047112cc6b238d8174df6b353473db869c40d1831440fa6edcc09277a53949a85576f960611a7573b717c14c6975a77d25da28abaa196119d9997c604ea12d16e85da835ec342814105558dc1b6e03abf97808a50799dea6f98f1d0296df97f0cb91027df747cb5e915de2243d476c47601cc439ac800e1df6fa32c5d286d4db3109e3068288f911092457b26e70b863b150a16157075d4216d2293385dfe215c996320506ebf99c6435de0bcfbd66c07ddfa62f4f21b09f68c6aea1e7191dcdf523847391ed5928126fe8e0a3993d59b7dc7e831f8d0fe81f7dd01dda30e99e3b2a68a97fd77c4fba7a1b7d4d4b145b9b141a795d9aedccd8694258108887b9de9f7844d4e0f9cee624e07737a28418ede19444f2d7eaab71f36b3910ddde067c608151bfd6b1d6c384502c7f766259b7852aaa7a90fd662cdbacbd52e8b48975ac0df617521750526e3101d5102306dfc815a9335f7b1335427604b034728742e4a6b2605866014eb61476a71157e20628d3cb3c1cfca69151d6a520d03e10c505c898257adcf571e6126003a91b9cef29a18818b5488009b036d0040cf4139ba7915121a7f66fa9909406049184909a3910872162ffcbaa39cb79763a2673dd4280879578018e2d02c2cd2beb6d8c0ee0d948a8a1d6ba3fa7907a49fd52a3f37dc242b8895a2b9bfb426b6aaa37108e4e230f29def58ee2164a4ad3ba8642d9e8dbdb0349bd86c3c50fbe45a34dc65238599f936efb1e1b6bd21aa147cd4f81e76f28e0961da0dedaa8b73d972b8b116cdd0ac5795c75a2ed274c345f7458b6fed41dafa4dd0eb150fa71be28d057466887ad8d78d96ebc684f6b9967e1a47848a176c57ef27ee2a72a7e1a7add43e3deab65048176d4df5c58f4a67bffd7069b17a90a84ad459a323d75b0679c3c56ae060cb5ead37ff227cf2cb0fe75a4f7e73f1188f91df1acda5c1b3c4dd2c5530348062426008d73def5210752d166ccd773ed3e0268f3e77cd38928969bf45b986dd15ef6a8459f38da47853da564b74e663b9966bdc93d38dd98ef6825a6367c7a8c576b06177f10d16674af3915f7f48fb83b67e8e67a00ecbd6218a4822952c46c016636ddb5a62e895d61f82944d705ebf3a47a692cbb1c90e61db542ef4bd1ff039480c013f4632836241712eb7f5264ae16035c7194e8916b9bd3ee825366c05dcd5f1a9d5a85f10c88011facb91c45de9d36c82a2c7e2ab1475f0232ecb56e092b0a7330394ec835bd5be5627abed1e830cf066fae455036283fa30aa6cc7a0e785314e593b4499dc07c53e5e68f884f163e3c2da5bcfdc6dc45687c8b44a04a659e060bf1bfcbca6ec911d36356c2ca58ede5ce8e60f1b5c56956fbaa4948b1720a3493f4c6e598550be0b11fa374d2c28216b6487a3a458018fa4a1d207c04a1cc0be8a4bcb887661709487c0d16ec3d1383b678f521d6865064c28fff3e245d3639e3e6bf0002fed02e02e5b9ed628bea4ff01591b348a62469eb345c1f97ecdd5533032c81b3a238347d7fc9eb9fceec87541f7316bf6cfd5d363b9370aec111a1b318c05c157eda04ae6378265c564fd8e4259d46266fc81dd671b72032261ed37ab87b0008fa301c1a492a901d234cb6c578d15b045ad66778e5793630beee33d3a6ab6ea7fc4cea374d961bb20be12d56d81877ee99769f0466161abfb6ad64b973375be0df44f89f9398f04cf60f92a174d58832b86bbd4f8bc6e7f879fff1676eb49a7fda932eefba15ddffadae39dcfd9957e2ffd1a4abb0f804ff088b20390723b1bdb2a93a10c65a3887d78a1abcf663ce4c49626e69c6e2909af39eefbe3bc4faf45ce54314e9bedcd990df3fd644515d12d36c6d1bbf26ef492136742b9f8cf5428c2759ca4a8118ec619fbf414ef6abe1a7c64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
