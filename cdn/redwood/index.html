<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cef2c1f88366e9e3c0f939be42d2bbc66f0924be5e0ce9b1155da52410df09360bb577328b32483312aa16247e31a250ae246beb099b3703baaaa4370d6cf1d48836a78c92a4071aec2c5651570df292945d37a3ec3f8c28f5ed454ebd9c0d28033545696ae82684cc2f8526c7c1d83393f4116782ef1085b00c49d2679f40a0014372699770bb619de8a03365299fd88f3e312c40952198676ac9a6978b5fa1ac1c91aec6e648787d3617235ca2af63185f11e05af3e542278974b807e6bf3e371563502cb497e71dde33913317b1355c0b2a852bd5c058e3313cac7cf51d4ba863ca940aa685be66f1b9da85ca49c5fb559c76fd18d1e28b545aa74dfe04d58250b8aca69b41cb3c1e7f839c306f96d81b47316fe23ab43360b1d24092442c851cfe2a91038d1a955f24269b281adfdb42ce19966ef5bbe283a7a14c48efb108930f6bee07b647554bfce7743d0b1e7ed98fde047768f981c38537a2c1b2f4589262b3378addc113d8b39a6bdcd4ce6f4637a247f6a0057a2ae52f5aa02800821ad9c7ec575b34514791629d30d42d48446e848da5efd6ac8e607642d74720b5f83ebaec79b74cbfdf8054cec849a9190c7828ab72b1f26644c3e981715a2e387b91ce19329662311635448d02e020d65df139be5d1e487ca59cfc9cde29cc96bb42f8923f3061a72f9450c7e3afec369c8111731a3357066e9c4a597c82cabe8257571a0ef35453624cc2174dd0e5d6e04f69af8bfd5e30c5d07c3982eb5fd1512576dbeb5a3b0610e9a2a38183f627069df5e9b0013805b0cf1eba8ffda921ef40eb99deaae203e71d2d16b3c60a63cb18b93a0e3600d95402034f75d70d4d2c818cfac0a314b978a909a2cf9dc51c8388cfc9137141d0edf0696e91e70172353000a3f721338f1dc2770121d189fcafa4dcd674556dce12eb977b7db25cced44e1b054e062b102bc0538be1ed128576af7916b2dd7aa5baa621b7a3b0c48ae8bbfcf96d5d2d5e870d21454b22a884a03ab994cda95a39d145086b665e3727dbb039744b40c57e2b76d56cdfa25dae95f679c5255f0d2f63a5fdeb38af44e4adfd493f39060aec06a5b92275d2b6db630cd159cec2866fc1953c060563f8fda3a1f56a4571a791d75c51982142235a9a741593c4fa1d3c01183fab461fe4288fceae86ae2beb1d5ecc3feabb634c84beaeb193a4dc795ca831f8469787358181c131c9e9496184477daa314c49867261bc70f0cc32f62ebcd59fed79ab7aa2b985db0298dcad4f9c3a9393f05fb9ec7846d6fbd86a3529a6a3ef7b557deda2a2ed64fb3a0b2d249797db76f1691c1758549c1978c2e16fb621105314f61861cb0f5f793c86ddfe23e5e6392064bba76a466162d2acf7cf789e2fece23685093ac84258c3ebd16bf467536931d74f09a62dbc9d9232922e2cd2f9841785732886a86b22eac813b0f34c95290f0fe8572b163e48d6010335b1890709d3540b617b086c030e03194ca3fa2dcf487268f3accb3f7a1cffead45f95f66ba33f5c200f48901d3d70017f828d20992cb88c204f8144fa94d42eb05fabeab26600de59c648fe65e31f4b2b61201702c5b09adbeb1d8f7ad01415d542563c46f9567e578168d68b62d6035554c28d978d37707338d1a2bb824969d90f064a8f0afc28b3d8892277671e270af3c3585ae86f63d5c207b26d9744b8c5edecab245c11f2759237112e89e3c96ffd94bc536d954ba9ac55b7923c9c3c80ae7ba7b5b82e8188c79de3107db41e46b4083d364d923f3b8fd410788cf352ad0112093a471374d731e62a78ebb1bafc97154ab3b99c2c40379e5b21cc9a996a5a4668a24359e331989f73831a8273f49033e3ec9cd3417d26d3d262dae859d3dbfdb844c5a5e156351c10651c24f73b6fc898e79a8659c12d9a32b53f6d93d8006b42ac0922fa47837ed205ff79ce7508171f5c3a39e04768f8af6d3cfeb4e1cd22c3ddd0e60006232f66a7727e5a8a50616ed94d1f4c5bb1ddf6704f970c4ca6eeaebebced7ecaa67bc1ab5676f3530f22fa75f54890fa22c260b0251a5418dd1955a47b5490c04f7b542203735eaa6a9f42aa5ed544006a8ba2926ac221b63adb63006f95ebff2957b810361573393e6c2baabe45cecc518aeaff857afebd9cec12375c81b2a489a6e1c335d94e75ad0a519b779569d086e3548d32075a8b8351e84e50898f0967857e861fead07ab8fcfead3f8d0fd27ccb2543e1d3fcc6762eefbbfae892daf61b65d259746e3eb7a7c41ff7fe815e181372160d5b6955772b1b3dbf8b96754f17431d7cb6886f60d5451f5e938663f42237a1d055e0646c7a9b837bb81b2aaa1b052859883d523480c8b84a7df588b6c76739d2779436d96c9c65e7f2abf24cec4832ad77049681beb6f4e7de16d6ac042b7edb05f6ba8a2cf235a2c91dd6303cab9301d70926f9871fd7fd8ba919a566af54f02d7294aef35cd36083ae7cf98d0d73fb929dd4c8feaa18c756504531a06d6d9ae81ded91b009a70eeebe7425f5a7712076981b186aeda5f13af6f2b2b179b49cecc5e22ec30c9ba00b343d972b7b9a4209d6541ad47223c35f8b961b29f6d3e6cf95b2c199066563a7283226153055eb1b540ed4910c052ff56b114e4fb58599a08d2421360acfe031733a3b11cefb7f91fcf80f34c63f2152ce6a2ac2e04713bda7b0694058213536f5d348f75a91003ee68db3675eda15cb5436c843f6015807b3a4cbfb05cd3cbab21297860790be5285eacef60fc107043e7dc3580672fcf677fa2b2b94839479eff0fc50d93dec4ec728cfd7fe500460e4a64ce17c0b3c26ef2f19a5c97010abadf733eb8b93f3a1a51eb679d38f67312e7baf595077b00437e33994313c9a19f6a61aadfd55b65bf694a92ad18931630653d460b3f03ca056dec49d5095ae42d6ddcdf5b4a30cd77b45ac415778225f1bf01fa119048bda03cfc4ef08b99cf5bb9a93f776480eba014791cc70507055e6b2d0dd391eeee2e0aa68263051ee20d478e8bfc8c6bf7d085b3d66d281c68caa4fd6be2b78ef567c15759be99a874760ef135cc4a5272fbdaf03c58c30bae57c0f6602429ffacbf5c8a1083483e14a75ea752e7c92096249bd45bff57d05941c913e7b175515ac23491f80ab056b4bcd20a80b04235bb5327f2e8ab1b6d33415ca28be26e63a7745d796694aab817460947142f7ada9f17ec13e91e4487431e6c51177cf00ab897f61cae6e4ab0bc02a6dc1273855e7177e962ebebe97bebbf6ded7e886ff8b1928245e4c81d68ef79aa239051c0d1ff9101a25b64640e5af0fcd0c4e62bc1a995d85434e95d87db6973ae51c8aff3681f478d2563535ef9d7599e683ab88e5bc17c20642206107c74b8b76cef3c6be13cd5e3b43da163120759bb99011e2779739843ac0ac79794abafc303df8270401bedf86d0ff767d963a689a4ded7fb7dde057af5cfa3f812e6f7a409c3a5660df36d206e8e4f3e523356fc4e674ddf1691e6ee535d8f6d7984255d8cb3d04edb324915120ea4ee4aad3a1b64fc926e387d37a2d7a342126204f24d76cabc5a1aa2fe6f53204b0a6104365964e5da7e184f001b624bf62bf9712e12282b9f101bb098229a7607ffcff4c3af60c5c816a874a6d7530d3471bfadda3f654a3faab9c0c56f4c5ea739c578ffe96b4dddb14d7e68531fe639601d50eb6e2a08b0f0fe225c8a83e1da2e3427242604cbf69df589422759be4b584ae5dc68cca41e2f3b01f86752ce85448cc4f88db051cbb7835e4cd9f09c1b3f72dd7c7d4e9a20b84583d9bf761d15bc65ddb9f208c546e9cac8ec1e930e7333abe1b364ad86c2fb52da9c6f00be0234ecf5384df7e47b4ef005d908d9ba4cecf320ed74bdd996ff9c27122098cc3894979558ea9f999ff02d33d3d9a6b8d597f157f2540310829dcaffb96805c32e5839e4d74aa440bcfd974e622aac170b379d70503fcdcc8104441101f2c2d8f36bd304f193cf97663353c24cd88a9c24c71023f21b3dae0511d385df63e7e09d979066ea70775eaad55b0b88c740c46774a44f636e715a26186621ff452e499fdd732b09d671a3c9bf9e12399d5d7bffa45f5b4fcba17c7a9679a4ca7676ad0fe8487542d2d6b975e8400ebc432ef964454ce8b295493ac14b0e6247969ada47ed0932ac08f4867f7dede7c0a500492fb8d27e757e229941ecca36f657f1c993a2f72bcdb79d84fcd5d4517efdd53e6a39df8715bdce81befc359430aa3eb3fb7fe343677cd45fdda7411df4e36e1e214b5076c6d6e419c34aa0c251e3f31afd1fd10332c77efbb4add660a853f7dc9bb8370113dd0a6dcbd198c5b78be76fb9cc54dd7cfb702d536f01bbf7425038a74a356c45e1b10a4edf37b4dee3045b5b775a095afd10b6f851396eb142e717e6d38050d15279e70de6807a3b62236599aa9e45dbc251327af4e830ff5e09c74af76f6724216bbcbe30705f196bfe5ee662ab4ed94248da9551951244c717e21ad72023d44740ad2691b1f0a9e9ef72b764740c65ea781257a198f1011df3429dff4857ae60bcc13a18c3f592d185c1edd4ad1db73c037641a97e86da54eae8f69f9b0a603fbe09a7c05823bfa2fe865bb0f352ee132a84b0f8cf4d38c36b79f326d5dd4ec3640103fda14e161620b0fb74b5229fa015f730adec52b17ef19590ef89fd33408248cf30e090b005945813322137ff818b8acaf8e6a9e2bc097d7f055ed268abe6daaf5bf795b12e9d8b1f62ba5c16baa36beb8e7fca54a77f552aceaff2e1c60ba7796e7e9e5db078b5593e4279f6be35b7ee00a8a9dd6598b99ac722bd7ac5ff908f75618ad0c61fd87affc27ad0001da1a1d55f4179dc521d365576660e1576aba268736f26997bb111f925bfbbc5fa1402e89e8721a2ed9fbd0778ab944279fea4924ba91e05e0a34a49ffa1ee6e0d81b7c838ba0fa2349057f89ace41e543076e3842cb68fcb5d9a8785bdd6a08c83f4bb8dd4c821ae5530f52f541b9c0e9cdfccf95f7935f9ab094f97315853ddd384773b9f0b5a1151408525286f8dbe66990adfef63d31666a192557fcbcc1cae4f6630fd1fa74e685018db44871c9ca19c175ce3db9ba70f708c989053c774ddb312dc5d9ef8cab376a0fb5350506a198f9287d9c81b1e22664f7da05de5314bb2a48226ebf21af61ad0fcd33cc02b66773bbad91cfda5a6cc4ba0596d4dbaf73674198000aecb6953c86ce75159ee9fca58ef5a018472001ea67569153296c54b97dddd5999719e3e37593ffee6974036aa4fb70c9a507d29c3e33a4fc9bfff594fa0cab0dbc2ab671451142d5ef57aebcf537e2d9390d344fc394a4bff75c238ac68227486ab85eec61be39f359aae0879d7c38f976c45805e159aee397226fbeaf11d2f58bad5627b042dab7a0063e02255d7c8e06c01598d601bae3023b609879b0f492fed624ce964191e62dd90e67f42cc3c32925f6b977667b779c2a69f7c5ff038cf9a9966541995e516356b5d682a7272fa1e470043c942c584384ab57369819152c5013529e020db0455ef58ccdd134d082f9df9e3bae7f7a93f8c9f649b3dfc1290ab53b4f982af68452cdae3864d82c93c42c81ad766a7571553acf34fafb6e7cd66b2dea8201059488c4cab4f2ae46b774b1616d2ec09986995bcf9da43f55807e2e7087b7d50e09d95fdc59bd5091d7765ddbfe599b5f2ce3df6eac31e71be5843b4acc7cde15074d7aac1039cca1d45e1a784f758d65bed59f81e019cb41abf89f880281388eca3adbb6cfa9f7d4ae76a23e3deef747b4ca2ed602df7540e3f07e8900e305c7c9aad313eba7b1fc50729fb52f443710de99945e550fdddab58f1549c232d0f64f20c1e685e6111758d76029dfae069d80b4c3c3e52c738c7dc96fdd4179fbbde6989561649a87e13a97d3e72b31f87fd16daf2d4ca73b986e7ffc8e6796d78f6f56529ce7ab21ddd68845b4c6b6d5594136f7161042d4a349e444c1dc45bd1d73dc4d67f695c1466c870452f7671488e96f20069d56bd98c4674a7e12564867a4c888e2613528d7f6e89a266d892aae81dfc0dd3e36aaa89f72994e037bff9a86bd7054571a129fdbc1be8c7bc4a3ca6b4497c27dc77f443b1e9c0b14def3142a79f72578dae3893a2933f4cdcb8cd1535088b55e1685bb7734da2beb973203bb3c00ff95fe5f0915f3b21c8a6df770bd2a9e518559edfbb7fa03ca65588ec02b1d1b05faec9eead17ebc624c7fa26b2fb2a602508dd19d7fad6fa2d623a9178687266eadb1b1993cdea338b79e1b3218e3e832a6cc0a0a2310ae88f31f9c4d2ccc2465d18e2be0432bbe16ff7e547d3fa9295dc3afe5c645684a1284783b426c8ff33b9072d8511504db4dae5b85383583d247776b4e5fc597529a5bdb1cc9a29dbcab7345e849494009686dfd1fcf43521ab6f848e784343beb98a38b02efe04c804232a41a41a1c84c8a8bc220fc9eb225da4c90ffde154efe56c7c7664c6dd30ded987ddecad7d5abb8a8d38d94b4be68252dfd65429d868938faa7b44694ca3453d501098dadce4967607f9b6795716b2ee981ea46a466eca57db688b1356452a7a0926f406272801734e0b657fe75498c097b3a8416eb41c11ed68123f7cbe7c8f426743812ffd4633421e0e5d48e631ddbacac9bf9ac030416770c3a2d460d8de3848556c66a3dfeddce44d5ba01aeb832a5229a6756fdf1c4ec6cb9a8381226b3ce71d4873c60ac2bde2354f06d535e4864419fc5e01f346c2b4626cdbaa4b45d825d9369a6d80b8e9aa3c8d89e8292fb17859ad493ac32e0787943a7d38283bd0fcb4725222d8cbcfa804c18fb32985ebb8b8529ee0cd8cecaa0a328b6c7a76f5fba33bd12fcc8101c6a0a89869fd5cc78c8801943163fc77863e111f2c5b53975cd1efc95e4f37665160c2b03151ba4847d1fd9a54edf27c72737da390272f322c5bff7532c07cff46d646ca9540e110681c7e53270e3054d9ff37f9df1a4fceb3443561143d849da03790f5e51819a76e0249c0393268b6c0df1635183554a10627061aef80d6f47a69457a14c53688788b84b774f8acb0a954d20f062d4c01a1ffa5c5fc7827b6aaaa2aeacd57dc51818840d846e8843d94ce4d9560fc92d58b1fc3f96f4510eeccf5ecf28fa5af1d1330d321511e1ad9656fc7ef5df7df7cf182c3633accd2e2468256a9121c25107d9cb6a79dae2e849f6a7e3ae3163a1a0f21b9a171f622e75ee06f8d990e1c3347cbf127792461be9f811aae9b84e6a64553bcef69597b2c035504fa8d3dba925e07735e77bf180749c321ca425ba7c367824102f9517a97cfb11327d2083e5e1158a1a6a5e25b23a7fe592c0b4e15f7a3676cd5d9c2e1ce1736fd19ea8b1fcd6f0ec2302668b0a630a92c385244a6e9ccaf8d6d1d023443b26a98dc314949bfd9e60bad48b185bc9a9e571b5b7af54813698d03d15da817008ad8d9992ac2551a38e7eb7e1e7e3ee2d2ac6ae6f7d30ba88547581314b48c90abecd8c944a3729931472ba2363eb5193bea1539787cd143c667d0f1f5eec27653ed7989f18f1ede119fdfd17c1e05564d770329d9dbca6baf742a9a37e995999149ecd95d39007b3d8561d815da9e8456a54ccd74eed73b447cd13257a361a7646bf8431452cb1cb0eba4e5983faf08fc1ade3f58a8694cfbcf1558a6fb6f0c0ec73f887214ede822bc6c335ca0fc7c8a5bc484374b09ff3023443d1db6a0e8251cf0b358c521322e0211dcf54e5f41b1f975a5f54aa0660c7953fc687d84e9373e109c4464f28d9b0d6b45a53d680afab2ae87fa5423d21e682097b24947f68c5180d88d07c06d77e1caf157d44692d84b60a445ce5e7d44ab026b6890582993ccfcdcf03101fbbd8745b91fb236d14bd1eec5c33ac0cec4b619eac0cab958f33e82f30a77d7569c70702debf395dbe4a0e909aa2eb4b24fa00422089128c1b74fb79eaf9d6344090555ef974d057f532fff264e8d575fed8899b3a6719f2766bb55970a20afe2de83c3ddf43ed454e87ba4c26a855365b789963ba12d5f1feff1bda31d6b78aeb63eb6aef7ea4a592b0af338f5c2617a2c0e449ad824fe91a44c47cdfb692c763be95cee0bd6c5f6588e87cfb38685f808f73d72cf0ce374c56c8e20308f228f7e6c79cbc6b1868e6db37f286f5334dc97939953834b76b38602a789a6d9d5f0d1187dd89659e21acccc1e230730269178fcd9bfda99f79f4d47ed37af6c8f4f99265bd50742a5b76e69eb1233bb81d5d6884fde2fea2dbd2c5100fc031d7f41d7bb2fed20bd93b73ed504cb5d4e5b221947c3b91e5e0900b2022c7b71caa28ab6ca1e2ca7c8a7c314826e31e16db6926a7acbfd5c90eefc922707a21f68b1047ce673da17c7ff412c44831fecdcc311902a74c371af3ecf9e4608092a7b1969957e277345a25e876a0b59eb5ada8c6c539133f4860990db1f30d6305f9322c39d9a0d129109c445ed042d341ec7ea51f7ba1c359b48ea5f71833f4c35edcc108e59d201ed34f1e003d5e4f9751a9b3f425d1b72fc789eba0b4785099bd3d3372b9e66d0793112cb7dad37b386daf1431f63174614e6296e70d4ab28824e90239d587dca60cabcafca139ea42df8189a5cadbc40d6bfa0fbccf8970dd7304975a8226ebcb0c3f157707b82e8fd786068706af0651ae3a392c8f73a46d871ae3ebd0b8afbe8b666552fd8c7e5fb2725fca403b0d7ea2352a2b90a4c701fbabbb127b383991b08b7a53b5860b63ac01b74b3f372756b35f292e352b92a60fe6dd7420a382cc75e766decf7dd316bedd7f6065bea7a30485b10390a4bca2fef615a232a4260af6b05872a2c8945ba6460185e64e446885e08e6edbcbee097da5e5a63f3c5a60f164671a34e1f3868bd4c465427772998d2e93bd5da3ccab3dda969b4bf60452538e7b59b57580dcf1a4e0d94332f61875c4d33820872c823dcbcebcc463c1c54218b55c7a4957ed4d5eea21497ff995c3c735c3c1b3140bff82de3ec42dfda273e9e9e0eef22c284c6e3a60be370d1b290b0e71b8b2100cacb8af623c89a036f41d292461912528b81d9e81eab5bcc21a22d4019a7ca9f640cf7509f533a5aa7c5d9bc1c717aa59cec13b28e8554e5ffe3ad86c273dbb4ef707a3cd7f0df7021108b513e0329e2e3a3d9f6eaf86fb42286b556abbdbe02486a55ac495ac0fe50c419f50ea9e5ae623839af29cf99dcdbaf0be3c07d23e99d85d17a0041daca190e1ffdcd7e96da603c62ca87e7a9fb1e5040d419fd42b38499db3fe9b53f436d45188523e197a1f15c111cbbccfca09e53fd2b5dd764fae30a714a33e9bcebd9cfb71122d779b613083fbb98ac7dd8d9a0306bf854f8dd624cdebf82b166af6cf8b71a7c65d8a5a75511cee7769eebcd070939ebaa80ce695a23e3ae0a9338e04389297869ca19e50b11a451c6f2cdbbb1b297ffdb1088ebf899438fd617640c3a7c9d9bc0b4aca03bb1808602f91957fecaea2f61d22f73d3bdc0b3b53e1ebfd32b2fb9c52a1afb619450493b4fadfe6814633e74aed32c995539b8c7b8b06be74ceae2500a3b410a6d0d631c66ec861b746926f0faf99b39d30f130505e7b0f4d3119f29e5db8254d98e8cb03da505362c052afdcfcb0515c5a61f10d7b4845a254c08d85031e8760a95dbf4e1433a4b027d42c556a5ed1835d4c3262443a4b541e2fb3e87f108d8ba54d04e70c446eebb613007673a2b64d7af3705283b61d120d85f0a0eab88503f379697039567da26ddb11edd17ecbc751f1c8f6b0a73c722b1632b27f4ac88fd95a92ff95304aa4b94642f5eea2397ad70c2752b17aa2b2c8fc7e04b871b90972cdb93e76689d52dcd71e7c3143e44dce847ae628ea127170a600c6fd03b5e7ec26f64c2594884160b8ee953513ebef1fd788b17a44988b5ed1dee64d5f0f314d0043c560a2f6497066d913ea37cd9d2a1005b3fb11624f452497db6a55e824660416c892cdabd92a416b1d062865eb3e47191016e511030c0b7b443785acf02544909a9a6be0f16a8d06ca4024ccc805a62825a0daad487957ffcb1ba6645ec100dc3f78bdb205289ca297e0d9f392979ea2ff7e7a9e96c2b59206d8dbd2eeefb3d1b5c97b7de57460eeb609abc5d4b24da50a24e298936d25337a099d2736edc363c3c66ba8739c35cf51bb2e39de4d0447c7b2546b050cddbe4e9adf1784fdf6e283ec06d47d9dd0a172f46078b4913ca771b02f309630083b4d51097210cc5b8d24c9a22aad62b023914e4cad8f97bf2ba78ca8a168a3427e0580de6fb54539ab41a278a1ebf60c96772678e1c80460999a8ccd53c7cbfb22dafb0ae304d056df14f1ead7ef8db095698db610920d264bf463d870ce21cbe4405139795118d1059185c0523e735d4aaecce06b1c5dfe692a51bc5555b5ada5c883d02d9ec0c1132ae92cd40172c303587692a2078669705b224f51a4386a24a6fac5a6ecdd7b1d56e4117fd4a13065fe8a44d91f7b3a3cc2c90f049df9e66bbb045999fa72e3e7b6d5af4109cfb8bd91a71884a60e52782361e188ecb73dec8b6a92420c033e995e7324ce4b7006a049494036adf593e2fddfdea661f66a4a31c746e57da07681b3d3fc5545fa3d3c695c46500ebffdec87e717c4fe6a1057a0679a5a3daffed47e41d8a3555d8b9356dc91e5327569ee75b510378e809a696700f550a7aab7ae65b54ad0fe8e9ca9a85278e4f2fda275a76a034751f2000fefe42b666655f85a651f2b18903fa8b0842ec4ae8d2df382f59dd332897e271f4b2a95f3100c8c0d175a78ba82869875cd695f47fb14277c03be55feeb1ad808cba1092b01c8cd7b452b6fd8630c2e13a438c62c3353c365b18bebc1a333ac029d4a3b8cfd6c6bc36d1cee943fa24780e17ee5a77dbfa78601396c5592f686518244bce06718144e8583de4b30846aa2c29d5b8d24140a4ad2e5cb66a9d545bdc9f8fc9179bb6ef983b70f6713cd13d982777b5c6dc18b55e808a228af0cc2c01624216841fb0e92cfed88af38b7f93b651b8a661fa1627429f0a90ad029be26e33b28d92357fbf0257ec53cf577880b7f8910827617215b9de2bf571901cd6c872428246db71a352f11a8b81b2663461c25472bc8773408822f7833996d757f9807078de446d04085d4915c0005c7cca079b3d4bcd713b4641f010b565e362472d870f01ab5062888ab64a0490aee3e7cb4af4ec76b9b847ddf229c7907dea66f744805379e112d0881efad721bfee43e92e4ff334c4ca27e69ef117a5061de0b3750a0e2b1722c50c131cdd31deeee642c195e2cd3c726f3a4708dcea4b6c1e21db9c14b8d140efeceb0e10c1513f90b8cdaaf91913a3df2c9680ddae7101257b33b9d6b5dbc3643023c597fb485e3c89aa37b53a8b6942944d288feb8dfb0981a8a151ab9b194dd7e1d3397518758d7bd1243eacf49508c7f397aa5cc46a10b44e728a5ec4514b3d1d3115e62b8036880b6629818c256bc8e73aa71ef919ac655b56d09ab9459981613f722da7081a1ab27190cb3293e3b747557f9d48f138aaa0982b9921cba60f8369fb5c34a3db0bc985651e11316a966ceb41857da79d318be80c60649f026178317178ef64a7fe060ec696f54b852427628b8a76671c4aca689f93656cd76d291a7f402b188d97dc27b90ad0b0c247e0c6056daa9676f2a833cede1c688e224f600736f8f56df92d509d7bc449efa3ae510fb0f6277975e9b2dc796db5be767ea029329dafa219009759f4342ac22d1892a53b511539ad832e2ce112201a47befd322a486777726ff8c5cecbf122676a22e584fb323d544837d63f79b925bb72a3ca674e9656943e6cf10ea798f7c32ed8d45a34114024bdadeab3798171270f33eec5da7b7b8a173776b9cfaa337757004d153554ce731cecceea4e12f83bd3ca72a4d5c699055a40e8c18f3fbb785d8a702d677d384686fd2305862d5ef072531a31e6acbb118114bb3501802853ad654a09169ee3d133704c6480a3ed204dbb6711c3baef898f2d8021036cb88fc691d9eb5b8e7eeb3dc767783090027019c17557d070fcf7dfda6fcd6e5d1447d380af9b48aa16fb94c919c9b36f883af450560adae6c26e165fbc07b821043fc1a9756549c96b0fc05e9e9424be2b3e174d5901b531dd4a71b16daf7ba54e45742720fb087e721526e8691f7236a1176656969be156153fc83a3bedffe193f8c33237d16d0296141d75eb93f8f166a43c2d27c4ad2d8e5919abc78e9903444f4b4665aadc896478d3dc87d3f356cce1c5049031935add5ca490109dd910e793f29b64d7a9f4dc63ba92f7f79574018cab011ae0b4da8c7ba1a18a852796ea41d6475a237427fcf28dcf84a23233015e24c733392e03363799e26604795dcf6e73f67ac134ca5ba6d52cd882330a12bbe74583183a193e41c5f63f25c99e1e42abac3a182548711736df1ded1fdf4652d48238c3866e7a3d4dd55aac027fd2c3d6963c4d3c7d78ab12c88992a9bed4e53573991c29a72140c91697e1ad296e15fbca166b3fe6a1a9937988eb5c696bdeaf79b85cc28583277a34e7fdfca32589ec7055aba47ac074a1b8c89de1d99b024b7fd8f9315d8b9b276eb6d8b391d31aba05555b4daad42a9fcfb5905d1829738269abc02f1f54bf777244a6e2bd33c9c2e9d880080f5125ad899248541610cd6046a1bc447313b1c50db2eba1d5d50918ed302f44a83cc66843f020d6e33ab5a98ce7157bc97537593386ba168db5deccce61d27f1eb93a9991670a3cc7c35116c6e1789e810c5bb9fd0b3ceb413bcf5ec38b6bffc0f9664325da68af4e9242fcea65f9c1f9caed7d496722c709d3a085f442487192f898da7f7ac42cdf1c22a32eb8372dc64a55bde905051c92be11da36209563b410076b2808eac1effd18bfedc5a2e1469e2179ce46dee5242a7af6e49d03f859c5d527f7ce3c202a360834e525aab3f518c914aeddeff00d831315104e4135a4b450204b508a8e69a8250cb1e7f4c0666507b8e11682fa4ec1c0c0254bf10cb4a4fdae4c40a524b0b78d155973319c94d78e18857742d0405d65dda9dcf675afeebbe34401383de32f9fa9eabbc7d5fb7476ccc966dbcbc22cd8e90af6340d502dab4a0fe7bcb6c766e8ed2605186e6e604c3bce94187d488222664c81e7d2806717d3f0297e5fea1029e951e37f617fff1b996dfe7df3930d5b734a7ad48f7f24037863ee2f6c7f6726cf776a60446310d1c22c72468e4790c83b824ff377e596f3d7ab6b1130650d6fd4ef767c37e76fceed477af3b0a6dd03c8e97a03afb222edbc8fad678b791e0ef9fa3ae58a130d9cd3404548eaad3e8b1a8a2620faf9e01a07ceed5c01df12f730d8176f3220d502fb12bef0a77379f6793aed5d4ea26811186207e88a42015dfbac80acba525fc19d049bf9a8bca0e8730a05595889b326ed753fcc20e4a418597f2b5dcb86b3754a37198f2fb3e8a2381560e17488d8edd6b43836fe1a8ab0892c6d9f10915763f97dbf40ec0394b40174250f1e08236dcd6bc7a0716c5858c4a6e4bbc56da3e9051f90abd478296266113b06e74fbb0914e4694df5b4315f249279d8244fc5a311062b59d203a9fb27f306178ad4b1a43064b8e6d85804ba1fc2528e1f1123df265bb382ee7b8aa3f51015208bbde7922664b6749d5e79b6beea14548601071690403741805a64723542e12a56e15594bfb24f0b01fd8cf912aa33bf8620603626ea0a3b6a00bfb9bde942c39970c42cc8fff19173bd3947add20d7f353f627c2b40afba9dafffbe344846d1405801fd01a6b6c849b9131f272944788b553b24a0a039069b6db840182204e49779cc7d743da32b7908eb00c7ebe396ee09f4be9673cd5a604ec7e9be80da75d6125e7e2b1a1e2079e6dae8b29283563de025fbd4eb90af5e0a79a77580371f847128bcd327b79dd757c4c400faeccbd395a82be64ffa01704810f8d8d34d9ce570fc8eff227b94a821fe34307ddfa6eaf5cd60c6627ade01420f008be315433d9b388049cb4d759457a059e01ac6013b1635d3be45afeb5d692a789f93f47775a99c7dbdffa128133d5e0f23f535683d9de52ff3885acc7ab0cbb0e18dd9fa6b487bc93b429d530510df33f270cff75d2b7186b74bda9bfe7e123bd9e876cb1fe3f541d8bbabb9dd999152c7a5949ab9f532617ec2c5b62c9ac32cfe80e096f6de7d89f2f01b8937fdc4e8f555e9b0efcbb60568a172f34e3fe9e6c21b1b8036731b1b8383e8619ac67f027fb4bc67840d38736b5593e53e62b30156541d350a93236c5182791b8a8c40621ade6c001f10c61441b9d4576f23ec05c319dabf201f7423435f67d6f5b8d0568687bcfa7cf902f3aa80665f1b9f2f8f4da455c6d3b8a66cbe7a616f14e4aca78fa50cc26fb5dc1725b0de37da26e50bec4ebbf675cda2d663971453576a1cd6f5c4c43501d581ca6ee1fa4d52de5519ff9383f3cdbd7ba6ce663ab40ebbfd0f279ffac8e3728975ad5ccf0eb4beaf4eadbcccf1a1e9b9ca67b8c862b60cd6814a8d96bd062d46891c23b0c44fc1cc4e96aff96336a5649774a408973479e17d043f7e56e97d6337960a4e61c7efd3bc9182c8b3478a755f8b4b687ec055d7c532b80349fbe80017c0c6594c46f4b2230c65095c523bdcf0ed668d15e29473e1fec75cb7eaa3dc35167785db04e37511414847b6523b98cfd30cdee7eb2429d16ae5ca0a91274d2aa0e57c9e32d52253b6438d501f090dec62f16d388ad3049a009864cc9caf3465aafad2bb7bcd8a2056bb3cc8f5836c64c913b74d2ff430443df29f515a7e743e3a81fadb2c0e8f5cd9f3e1ca7e73ea47bad1be50f7c57b82258ec27cb5309103e8751edb8dbb123c1788071cfe0c0637f74109f572a0841da431680506d38306805ce38132a8cb3a37d25280e58a51e751995cb883e6c81e3574dfcd083561ef5c4d80eb244858debb37c7e43d2728092266c1e6bf12c9119a56b699baa8f78255154f3b39b2972daaec9296351e989aee1ffc7778b8877a6bab2c675460bbc391a9b78e931594220f975736100cdff0db8fceeec3191b2871fc50924f72a4b2208b2742d3b0757eb87a1a90d335fd88351b91b030a81726550deca65e902bdb9205cfac00092615b5e027e48d0a4bbe1f25ffeb5efc75dccbdf16bb464d9e6fcddcb6d46955c790b9dc413ae2b56165aa8dd2ec97146a9859e298c07c5e03ea493137a3abd0aaa843694d06926cbf0fad820e51269bd5bdaed989493c30ef2fd2500fc9356bfa75992ed303d12d39c9b72e925802ca6162011d15237198fb5f6234d35d27824245a110362f38cf549d10b33aca5c452e4953b10ea9db83ba9ea83a3eb48cdb2e7b83d2ee5f8c7d6fac43abd79549fed08981c49dafeac650976dd769acd48f1a5bc178fe57d0437be62eab56d4ccb1305203a5cf1e41406691fff4d0cd1ce34a381c873a22e392840e57924dc16d95d17ae18e17037528178bf8d2495273d50bb24dbdb3ae3cd7073114c021a8ff200cee092e585d07e8a2d3f22f97281ab10a23759bf78a14ff5860a46875667a864a1cf4a10281c024e9eedb2044be8fba25269b42229506d33dc10a9309825cf4139bfe831f63b3445c6da741ca58bc3668fdd519df4e33efb9fc7de7614c4706207a26941fe9a813ade71ed724eb9ff0e12f643842071245e4bd78a1a32b8da23aed678180a4696318d646d2c205322cf6fbb93f1e6f07f332de6c5491029556fb7a76eb780c2d30e18d10cbb1166e904dc3e5d750bdc7f073d1cb85c4a2a76ec1108a878293f36850e84fa7754be76986011bcc20d9c8feb962aa57ba6d23fad3f0aa84fe30bd3fc43206a303fccdc3cf19b52091c441094b21155eec4b7ccb6be48d9c19b807c4fb2ea7103d010e7753af7b5636b0eb230735b2e4a9579eed85aa8a64ff03760ba8aa64bfc6d1fb41265b7487c8fe76d5a591a8e62fa1fde9a3bc152ec4b335e2d233b5cf1e6ab54fd6c98e32967303ded02788c733c6fc6e1ce06f317e380218ba814ab08edf6efc9e182b286c6b07dcc75f47047b825b2a75c72d066dd17d37ba7cd276220f7c18b6244b91565e4ead7b12fa7c2fbce3d80acba05b865e463349a6c88831bff632928e7cdedbf566539c462459fca8a097e2ff649345ada71b9c1a1afe6bbdce549ff84bdc700bf0d098e72960477a7669f117812cc05046de247bb24a08756ef3c3130fdf2c47125b65b32282c7d31dd40ea36cb4a7c917df8d777319cbbe8102e21c208bc6c528ddb6f9e36d970e0d159e3a99bab9d2844691eec10aa1c4ba89788974e57df9073936a3aef8617e524c7cc8dce174226a7a35cc2946cc5d586fa4bfd1adb2c0ca1d07dd63aac18caaf0e4481d1783af4de0823d966e6d6623bc9167913f8bf1b80fdce110657c66e3c4447d7f86740a9d2743ebd6a37023698707d51194762072880bf0f36f84856417b124207fce74f9f602637c22ae569e6ef2960f6aad8cfc801469e7f56d38a1dbdd51a2021a9b179303cf7d04e2754daaa3eae1e5104343e93b0da6d189477fbcefc86428a35f40cf0a9df154bce28b84ea077b959c88c4d44af795b6c760bcd0321551021ea59143e1cc232f08a9d21c0895917a4899671d5342139f3aa839ebad31c9ad6a0457459ec8eddfd7560c50f220958775de8a75822644326af2c345b6035e0df3d91bf81abd4edbed19bd9a5b38e05951f211617d2e0c8fd6eaf85cf730cb4e4e02ab0680c844623dd2ce84aa9d49aa6683c2213a03831219ccf89426a78145021ba9dd8cff332b89a2b3632ad92eef963faf9521a3205d1fc26e274c2dcb6bb0ac787eb2271d4fa3f3994792596139d20ff955211c711c2e24a876eeadfaf06471149b6fa1555f1437c52a10706211d2489cd048531389d65dcb8b8f66d723fd8121ae8e150342fcc873380471397a17dbeda9fe651cd608756525418166b56779e6b7abe3237e488dbd0b71a2207dd771177589c255f607385c8807f55d5f15566ca026b419a131a9056b70d802416b2973be65268bfb0715dd5dad71382edbd42793bd0769705ef17a65f6cceb7a75d57a3ad465fbdc8db65b9de7d77c623768a1b6befc4579c932c3324157dfeabb5aa6239d3b7f08b39c10b732e2033916a5c16a0832fe2f98b53c10b7aa4b5983352ff7fc89d0fec6cd83b89bd59c0c9279489b71838913907dc5a2509f01c95cddfb5239070b25bdeec31aee48a5ef2c812a557021d644bfd29e0acca2ee8280c1828ce5d1ed6c0df812b5c8f14c46f962bece086534617079c0088baff26537babaefe5295244d7fc38b60e65c73b0bc7e99fe298340ae250d1c9c3658d4cd88524c16d2b77887497db0a26b3cb1a796d9c729396bb07f135c55d71cfdfad28cb14bc37a0f821fedb090e62b302f9d53c1db639f4a9c83885398d60ab6d8edf5cf1ebd00c15e67c33cef060b4fc63c7837874352044ff0e6660840b563509ca16b8cca99ab4fc116b292c8e63dcf0370923f65dd6f228c6e297a994147e854026dbe54c21fbd880ff9fc607a8134cf2223b61089ae390db7e79646e683a6a7ccb97129a64bafe3c2c68093b4cd5316117f3a2b40a043dc6204d1f029c91930c2cbc2f5d432304e0f632d2223437da7311e225631c5e100d3448d63dd50aa80fa1faa0c2e59be6fbef0782b6d40503a355402415e84028560e4bf93738242eb53ea047d1be8915bd335734e42a39ef0ab85a3c80b487c40185b4e10c551d2ca4a15537e7e86997f6cdf091a3504e188ab39eb4c744bc5bc77e2523bd28bf1a1f13ff07c25e1c890fa131ac6baa50ef74a78ce7756e57f72ece2dac2ef347232ece3f416bb7d62ae8166caf0de0c9421041bdc3c760ba4ab7b4544d38f14464db515aeac168ad3694fc7345ba6350a16815b6eb60e7e71834e6414d97352610dd78c882","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
