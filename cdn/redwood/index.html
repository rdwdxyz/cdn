<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46a55163042effca37bbbdae4cfdd1020c778fb1dc029d5b99e8c29b7e704504338c80385d3d00d56c4a30e820ceddcd75113b842323bcfb73fbd7fbf7ce7981777170e708be27875492d5f7cc7c1bfaa58a3938d3f96201839e797c00a994d191da089e13c2b87bc4f5e2794fe224628a8cc6bb460a882951e10d1388a8eae53015be0e36f0e89638c1c9a9c357ad9f614855b96c03c46a1e9804527c42653c9db06b82c51d63fb55e5ed1a876c49504debf7674714755bb8195815efe217ebe51fb77b856c13b2bbc8381a2ff4b4c30a79aa2cf50f3439d9d0c6cbbffedfae50956db91c60b0d2f60fdd80efa497a842135c34cb798ee6ee87b719059526a55bbc03d27d7e3b3401569786ee10b78bf667c0b1e1ae6e8f2c1edd8b7cb51c6786bc1af1938e9690bebf7adb5a924a2f0fc244351b2e8b3069c7f1df0aa47b0abba3d396ba1d0d519dcb44794708c44b3ba884bcbf50d6e2e7bc7ca76663c8902de73a9d40f2ff0202c40537fb9ab5d7b714bed0733c6a77fd542c7eacb80387784321df2157e92c5b6e51b1f6c98674043f05f0f88abd5cc02857bc382a2e975ffd79141a5e18ed2ec0038b42559fb63f5c0a0b06628d95be45aacba74dffc9fbd9d4d9d1a1c7f0eeb5988d9181fa90a383e38a4d836b2ff2f0a9644cf642ea215a0be9aa48fcffb8db6ed26a279c0d3303eb4c0d9055ddf535c7fa4f797e872a13ceec6c083a3002aa8fe5495d741b0a0ddd997c7e35d1b3d9f4963f3e0cbb9a54633eac47b62bb2ffa1791f061c4012258287a41e24e1554869e13680f871dc7f737e0fefb14d13aee22d651c01338df194805386f5ed3bf7897dd04e6920f3a665b8bf052b7d76a98aba7d7255ce6386d20e234d9ed88093a806a085d2f43649b799c951b0c569f62b76c78b8ea5da337785b05be0df1565f6a75ccbc6f7dbbe497a55019038aa95251ee8aa9e47c45fcba079ef5324d76f3568d10dbfe4e77a8ae7e097401567d9114799416ced883287a62e6cbef1a56cb69ff4670ab9dba15d9752a9be52e13f3f3803d53eea1285aaf343b7106ad425edbc3176026eb1d9edc515c3463a978c72d0a341e85c34993ed948e34822ea644714665ba49f15697799479be62e25b2b05f7a87c7c01e0aca851c571db83521bdd82ca0ad88e4049f1367f8457a9ce9142d1e910c8279e6d1bb4d73182a7e7fa52be6a93458aeb2b104c65d9408df7907603053328de4e7d1d18887a798ef89032e6493cde68634345c3c57489ed1a5a458351530848f64dae3aeb9adaf63e0f1fb7961bfdcf3a5759248d9dde3f37b26802dd3e757e65b1d672bd47a6d443bca14bb2dd3c96b9b16fa3668bfec4f2f0e23f838055caa8416314524ee5366fcfc60d630bb99e6fe06b0c6e8985f2eedc77bc717e9bd4ec2fd42a6a5e72fb9a643acab50f5620464ad48efda51964e391ebf72eb3df147a56f1b5b44420b54300886fed50be7482de1477e00bc5058e7059b5a76bb4392542297b1030f3076f8d05d68800f0b4b3dd1d6600d91f7a8ca7b9de11094ae774dd124cd75ff70191cc26e03e3a1c264b78556d9677c686686dbbb18198ba2e5913c6a79e947f3db72c8e735ea9720991fd1016634ec596a174818178bf5c21e447479bdcd645c177ffe122f96da9a23f4caa743e598c9a52f46acd063c5487f5dfcf20b12d3936348c609882cc4e9801ee91ed5da3a6332e1fb46371fb6b3689f45e9e8a2c271ab8630e4e77ed7411c0eb52b8cce63ac4f601813e59a6caf723ecc79f0f6af6e145091ed4c6a58b73f319946a7ac9f071ef40c89abefaed5efece322e6fb1641a3bb89f78f97105cd05265bd34f59ae392ec15f30d72afe1a792d2e241ec7b8e43207c0552528b5a8494cdb51dcdbaadb9b14aa342a2bb9a2ffd4d5a70380eb2d2a79858f1ac71ba27d2685c30b6a69137dbcbbe62ba478a18972d60e2d4e3ce5e7e4ca8454512551130e1b521373db911d8a8e1c8b9defc5d6d5be4e98b623887a4ad5bb2bef9b131ec311c7b0af7e7fb11d0e2604f8592e45f67bf131d36c40abc1f9b171217ced70bb25e968a51f6b8513a7bb261a237f30e1fe0ca58e4c2454584d1a5fbc83943e7a121b0bec75fb7d2a24b0037c6715e7f25b22163679b91567e2019dcd2fa741bd0160cae9c4f37079203ec93255209540bfeb10cbd7068c1eac0af064cfaa3b7255b49627543ade750cd22c452eaa9cbd87d30d5851aa986c89e8b0b6a5551f2c43708c47b71b3bb11fae2815b127ef8e0415363b977ff3b52a526ee5bd45bc09fd1b480c9aedc84be3343f97fc46ec920c9c7120b395749f4396aae0e862bc179958b4bd41019b73d13f0902c6742389e8075fc257bb8ea69097416e5b13b69dfc079e97434d0be1a510703b05089d62358c3009b6a6ac1b5accaad693af6b323565b2b27bbb284e4db3b12b37560f7d71045f0fd072d3b02e6a047c60d4a04cd37dd388856a07e5bb8940422ce42fb417d6c696c129e38eede173c4e3edcfd932a58268421e2d4d76c64166b6c49d4a6717ad27ac74812e520bfadc487895fb355d1b1fb24c2949837c00a3f21da162d1f81ac5b3c953faed5ebef3e51d850602b2400f3a6ef13baf8a9f6481d89ab404e54c76bc4cfe0b2648e09de2310a7ffd943646a03918112269c457175c84bc308de255760caec28beb5e918ddb500dbec6055a918b83451b50cb9f84a23c1e26490a619c9712f4b48f78de5aa9504f5aa383c25cf0a1e3f56ca4b50acc7720b2f20b8e5ea84c0a56287d09769fde705a47fb6f9bcbe86f02e5b95776f965eaf453fb1d46cb46cbc065278dd94738704ea062b7922b5ed32b41c853e28f7fcd7ddfc0a138eee65ee4b7f57ad763a945bf27787f6aac40e414e83fe9d3906f13fd6236811a466ae30872f44ec0eb6d520d66f2d4b609accb2b6acc5b4ba4a92f105b54b1cd4534431711f4dc791fdf78ecdf936d4b9bf09236816e21eb81a7cdf1cc52d1dc98acba59f910caeef01954ab077b992bef6b8660b343d3003bff821f01a30bd1ea73a779eea2e539a7a7ed2f9eab6f471deab34e9e2774973829f3d0636a44e88b397f117bfa3b1806d8ae65e0f8a80acbaf55370c473157142cdadb8630928be2a12fcfb80b1feb4b1ec6568bbc035ee70019b80cdce0c379ab745502984bfb8f42757d7270e52e0bccbcce216dac46921d62a3837d33d3d36eae9cae346d450e3e55e0058cf5d7475ce68ecc7eadc49616ebf93918dd5e9e4f2c8ea3782947fbda6eac472b9f8cff9fb168a8e10d240753ba74e957d600778c7a4b75683a0419e17daa45e4d24dc4d038265715cbcee18eb84f8cfc9ae1dd9fa18d7357f7beed4c8ac5d6de5544c23ad77df78ed851ae613cf9be8566a193ac6c2c7f1be2bde70c33bb1fd2d209de2da3c6215b921740a2ea0fe35aaa841346a2a9e8c514a11c5f59eb000ac09923bf625c444936e941a759c29e5ce13acdf1b4d704d06b997cd44c107ba8823b9facdb07aef15d327f431ec092fe30696c1893ab6996ddf3dfd424ff08225289089c2c01402602894b0fc6da286093aef19cd61f97d99322c058ad9bb1a591b3c9659d3bc573a3f174d4b221e647d38f462e64cf0e4cd5be9d9f39012b5128bbed14e96a0c175a4b600ad679b369bb4af8131038ef6283c448923ef0f1a0cfd778de51e8528bf7ebf565ffd66d0aaa793edaf9772bcc5cce02b175148cfee188e4c7572ced18306482642e22cf8c6547a562e23c8cff34da40fa36c8a2f0883fbadc3d24eb6a41ee509229072db1b4f6d7ac03c8d77825a358be2ae6ce86f5cebd3085423a5c8654119b9a50332648b833e20728e15936e4be4e6625414929af4b5c4e4518c60d75da192a12b507008495153dd0df7ba526f4895722bfe62ba91011b032553ab779b6c22c101cd200282bcb93c53a9c36626d7d75f247b80f16997410fab4c793f3e0aaf03f53b58c535d20fa7cd90853d65414b6d56a50a3f610dd72ee9023bb2161e71a3537504d486c329a5388e81e389be9d0b2df95008f1aa9fa75f30840bd1f8b53a75124e834fc1dd8d2749281446588a8d81da4d2315f3bceea4bf347c9ab7fb76654ef63adc9600e9fa8b582deca71a552d1bf44530fe3e4d4067b129e15f85cefd5b29d943d752743f8fc3e3db6c774590ca5d6e23e8bfc87548c6744caafb1c4eb7f48383d66428130157c734515454c3d8cc08955f4fa7f451ff5d955d0b1137cd0073cba95f6ae48bb1a04e51526917af8e82df9e4621989fd01c8ea9e261b36ace0fc62f82e49ca4647004462d5c7b0dcd69222555c6c65bfa4a34bd1eb4a6d90f303db430d325fc27768815d618028287c52ad54268948758b49d5e772e98ce0aaf88201017d43d160b940cb2783350f1205d3508c3d32239a3a5d05ec009f1e0df625620bca4c0002fe630680089ec73a8a1c5609a64c9b454f24ee7d3876c1ae78adb0ad6b1f1e893a497c7351ca501aadbb98ed91500ea0ac8fcf35b3c18f9279b2ca0306a7c7bbf81c668d4982bec7b7195bc39e384834fc4d09270b54f38be172a2beb4f1967982ab2da485d845a8563c383639dd5b79d2eb1d3b08112d197aac8ba18cdb9518c944f04c24ff1734d9581ec22013bec4fcfbe5edf14eb82b8f9c9dea6ebee4fc4c1625ff7520a69b88bbe26265a7ab1a8ed2cbb21a9e023c4d2c55303a255699affbcc623a987b1ba795dc5957ea37bb853bc33a9977a93e467774c4bf3f0112889f94879a17e7931c01853ec4f9545bcc0ef354ab42631776f59e6ca7b23c553a6e035d3d46b86c54b2e17a2dbd338d1993851cfcc6332cc4e1ea1ccfca1d6d9566c8e9a301965ca4489e3b862f7f72f305d2b15045bcf1ca0fecea85e917c6befb0e47693c7164ca7c2c5f6920bd303fe94bc5ca1faa078ca947f4eb90e6bcfeefc9cce95526934f0a758ee996ead096dd052eca575b3e3c9bee30671c98c3ebcee34b4d604740d0a840c13ddf8f4669b7982fbf76b8cdd95d1ddcd2a30a89883b358ccceee2e8363900edf37a91ed2bc0224127f04661ad6bb115bcd15ca791e8ddf87a201e3dafea1d6a890c778a09fbbef84173d324157fb7832bdac96589d56b101e6afa5db2d430af086f0a4709efd3a9a5ebcb89fe88f2a63749f359e797cfd0d95b4c6875b8cd0c1381d808de2dc0e2e8e87d8e612fdb7178751bde76776d69097d22283073e39a253bb127a7f85a711b573850d084f25d7bd56123c7ed6122147918a06585626b6f31a471fb945ff811dcd79008627809b1a09b34a8bd049c7f6699485a19613573823a018b1bad0dba7600300c044d20b033274dc25096e0dc84f096f5642182ee383ffa2d4f7921a0d5be5ab32cdbff64b5dc7b5098f9eeb0f9c0dba1a7ee21cf61d9b1d1cb5297b28c90c538c92d0409af8901775e45636381900a6a044f10fe80dc9e1c33c1f3a358c8e26e0e1a8ac993b2dfba318882cd7bfe654f00bf14871815caba5c6440294309ebd38193216798b206fd76121df839ff0bdd0e0e851d88981801836e877e73ea44f9aa87f53dee2ea9b9b2588ea2a0ee05308ca14d9c41fe8718db283e16287b18dd6acec117d89e838ced980402fe7a6bbb6b3d51942df9de1af856b468a28087274af7780a350e0049eb9a7e76d6f8a2af1ebc2a633eea7f3f8a3ca93e9736800c97e636c9a8cd09488e17152b9ad2d86588134062fa11c39ae464fe4aa26afc38268d69da4217773a12939cbc6b78108a3cf15ea6de7968bfb7ec02a530cc6d52c6983e4b3ed680548f5ff8d96e20726d7477e3adb8a4253d1084be8262c0c9ad0056482e3d6610c19d1a1b4ee623b33369727584a9f2d1f7d274fad1eb5fe34d4464a8ccc861eab615dc790f6e21667798452e5000466c830f59dfbc5db2fdd0cb202392791077f6d4904c2976fd2ceb592554628e8c5c2040cde361ba579d7a42b4a25aee98bf2895cdd32015640ffb8ae322af66936986ba4ce85d86109d07f66ced66ffebd5893324a4de4a3cc2449b848d6911b8a82f4a315efa750c4124597528df1f5830a4c3103667f579ab00a1be39ccb2f5aa09d21ea1e4c0b8ef9175a451b4f919d41f736b9c6bfeb55da209954776e1a241ae04b2e6efecb77aa6574026518af6cc120f16d23718d93a0db26acb5ac829d735e2454ed8d1ae760f25957f03366bc5ee840b24d6de954e11801eeb17c3fdaad25a4eeebe9722a7052f9b48daafe6d0fd0500fe9dbe42ae5f55d4ed43cc7ea3eabc4528abbcb8f2f42d2c020bdc7ce40fa1ae782053b05bb1679c56c1484ae2f0aa5483c98afab2f6e65d22ed9297f7253eb0dc7536372ba4fc433c89e5c4a825832bff52a737f81a690858ebc174e20e265674bfceab5627ee39a7246cda51fdfa0cdfafa1062564738675796abc3cba5a60878e10f4812bbab2e8b033a8a79a09ebc53ca898d0176dcb67777972ceddf084e0d4330c1f62e9beca0ea9d7e6ac0e3834a0059a9f30160e2094a7291bafd5a17540575a059646ce33d185dca024fba29d06dc0cfa2ec5b4befe6f984331f1b54d309b5d2f91c99bbd13bc0cd2e23e8ef261553a791c50d420ab9e750ef0273c13beb55ccae4adec077f8276074db7845e40e307c97355081a1e476e0d42d4e311275290b40e8d226cb73332c04e1db09e6bb01d34e18bb5711669217fa8f2286a8b4fe4b048808a8ee224120cb8c6b4a83fa37908543db79b2e34148ba3928d8455312b69046f960de07d1dd30e7fb0f37fd26163355d48f39b2dba5341f304adf22c01e87f7b6402dfcf1d880f38b0ba05672bd12eed46264b1f21c200a92eb49ac0760c69a9e612b19af336e5847c84648454e7bb2578469b95301925b7c70bce5cf1445571bf6078cda334ba9ec290aacdc03ba14ec79b185b4fc10375bbfc48337b516869f8e85e2176de0e57264e1a462e0330609a1c80a62ec9a8031ca9d0a1f27c442bde6f57d047f132062d2391415bd6bbff6ee7e541c7fe980f47ec4ab0102d3b295a414e725a9ad41e992f465d7b9a4a93b0b43570e94ddc90efae7c54175efbd86827646a8593a01b2e975b6c59dc518809f6cd3f3aef8917c26bb762609986e8447251bc25cdbf6af17220085594725f81741ad85433e9a241217f339ec550433e6fa2102fc8776be36313eb07950da2508487f01b87bc18e68d9489712f11ea2c94ddb24354a8410f309634994ef932660b8aa9f3ab978bb86a9aeff4ec80b76dbeef6bdf05fb6fed69dda852e2658f373c8f7fabcb76837d50239006a6233e595c88ef566131121e4d3dbc3d240f70003624642f9a2bd8060199020a14557137dc2d0f39a1e920b959f98459e9f0bba395cfe570af8af8002b5a2baa0114507c5e4229bf5677be299cf951ebe2086eeb53a5b46daf9e578a348ae83029d970744039937257b8051c05474a8688888f6372d2af4065967b430e9dff65b5ad92bd3915c2d86714735897d9e97f33999742f2a6170b6d8d0ae4864eea7dd65baf6e99ad14b42892b84fbdbad240589a662f3a14e98442e6d5c65fe9ee9f7efbdf32be86a5ac0b509f1185d0c963ba5ee4087b30add487287936149ba5ce35e6dd8ec742d830abfec4c223c8853c3377fa39a7add3b537e363f3a426ba2f20629f58440eddd825cf05aba4d134d85ca5dab7c8a6f83a2d2f8f4613e52d7e913dd2a29250e4ceb76db13010747d572b6589b3fc3eec6e19cded6a0f29c2971fd96338bd410aa14bb0c7844b654a09d69d9e82484abc6399985eadb7ea2fd8405acd21908d4bda9a1d4c837b2f323c118d7bb3bf9ea3ebe6acdee0b31320182c7babeea0ade18c16b937039021bd493e02d93b304fdecb9d4b19f9f84ee4d0adeafc7614803ff6b2d6c777b9925359a31928d643ba3ed4114358a736a1fb5af709cb2d4b28cace3b0da9cac373f9a5dd1f7c5856c9406ebf4df99ed7a6380e497a0c6da67312065d4d29ca7e8d7476c652ae5a61995c7b07f3b7c3d7f657428a8137c9f6e59743fa445e79e593f2ef3a800557b70a935ad62b51fb1840d5911c268ef58eea9613aa6e480bc092e4b51baae9c452b410f100f696d8676994180b005bfab7caa01b558ab368789513975db26a82a2f2679fa8d2c8161504974ad661c9624656940f8d1e0dcbc7c7889b23f8cc02035c1a3563022fae827f13ad955867c85c18f3cd4942b827ced48e6f30d45cea6d9cefce8ed78c22a3f85c651d9fffaff3a42eed6606e7e1258ef5edcec1c71fa5395f3ea98aad346d06ca74e77a1a9668fab6c28f27709ba69778136dc2567bbe8530636aa9ea2c6cea1d400a749bf45df2f52efb790e1549e6a80a501b83bf87f03eedbcffbc9eb8739ee484b5e746c41e35d176443ed3ee3bfdf19bcc32309f7b2280244eae344eb860cfdfba4d34071c55834fb720421ab2c13e8e9c6be45b4cc69d9624047871747f4123c7340fe07ad4f98111245d58742180c2e1d82dd4f516874499c91ecd17009a38db6cbd1995d23214176fe77bd9b601e18493518476e1bfc4fb1a7f6236f018bb7ab646d6146a322ceea504a3b5fa67980f64be88570c1f7f7e44ec4e631edbcddba6c3ef97a49fb84dbfafc1f9ba533ac95b1e44214f897f2f3da439e79604de1abf19f1e43466091988df9e85a839a890f7d38ea4c4142cdc83a48bd6ba37ec5881da43c77956df5f337e50e63dad7816a1e7583b71a470aec5f8581d7a101c4deff504f94a5c4ebece7ae0adec154b0c25b5d997805517a760155036d6aef5d1bd04c1c3bd24311b58fa0e546ee322209bcbb7ed030e55598a86f675156e466bc77fc8fbc0143fb20a9f2d75df75d59379dae3f4de23d79346387609579e3eba865aa55065259a1571dd422a3c153cb57c6972a360b2f5f490c2e2d301f0383fa3b724dd7e00a170711dd745617f95f51714d8e328ed712291601c0af3301ac001b1aea718a5286ce82c1d46ff99a032d5a50f9ee44e8ef337a04cd7f1ccf290fdace5759fade1a331179864241fea6d65e4d66cc951aaada888d06c6cdf6f91823785111d4b72380b56b0b63d226302e8a9d187ddb676a7fea3c36c962296848ef9d80d8145263b234789baffb47df18ec3f6e547becb50b5381b7fefcfa532bab66f3c5c67d35e0ff14f90bb9d307b4dfe071144b1a53e77071b1fd06475139af84f9b0b56ee13d9c1fd00b6ae182d4dd604a17485391802e08c8d04bbd64859555dd934bb057bea11e0f25582ba0e1d3fca4b55b7275deedf6d5455238d8fd446205724ba46ebb9522efbee8b2f9d0068c41bb12ae345e1274a3a9f1b5403003800b347ab491333cec5734b19606b82dce549c0f5a20d551b0d55f15c232c584053eb4257fc302a5c9c6ba179b494f3a471f0b1b0e6165a738bc13893983fbce729b6f4c49032ccb2f9e4d2f4a2d83334582cf9c5bd829bda7c09b78e7023b0b322ce7be443a8e06caf442947786ae8d3aa3e7ca1ce1301edeafdd053d4117beb8ccc11e61d7b88524351784b4cfcdb6ae5852c6f2039e3215b1691ba7e3b36bd761146d995e72623d04c5bcef0c343f2ed58243832988a13590615fc53bf28a2195896eae077a7c12e0bb6e5eb1eea7247cdd472b8aca6b9e76ada60d4d5e4db0d477074b44b8943fee94fe2c287599baca4c36fe3a05de2566ea66302853a27e4b4ded13b4cb56a98c1b4d6d4c8c0a2148b2ed2ab8febda61c2b9917a6ab02b562c143bef7d6cd0828702ea3ee8106f0524785bee8308e6f0cb9e70e71f385808067058501e1009d9b396842fa3b867f969712ca33becf729c7b976081195d180de731acd348d06db7847c892c45f9cc124bf206cdb10d6fe4cf54b2efd46b9c4c7e4276fd7c0d76a2406464e0edfe69b039bd6687947d5d47269ec59bd1486d522de62997882002ab1e2925f1cc7d3792b370394cb15ed601bcd35500addd9104feb0d1d133bd169389ee2c0bd8cd2ecdd19cf61b98140e0274cfed8c3c8f6f42adf85469b9a900f549d98d876a3ffb080f859fa384ac2ffd4564319dae19ca2745645a503b8f6228eddf4dd9e4b3f4c82c6be464d983beef027cf6c17e23b59ceb21445b2cdb9d8a774249e819bfe5bac0887843ab7f2dfe9b0c4741edf6343e087e6797079220a2bcc91f28739e16e30c6c0879fb960e4e7901bd3d828bce9222a01892325673220c23dcd7f4fef709f67d6d28c00c82d1e6e03faeb1d61d38808c44411f1935f385003ec41e1e1f872e579cfa61052a55cc78bc86cfe3a879795d6dc9b96f4e92fd9ea70459327c4fb2a415560c0521913835b034a1b9aad8c000b038d7d1ab2b28a3b45d6238209ff584f0776d281c5efbb458c42d6b8823edb3b2be4fa22b31a0917b626e3b00634990a836e88aae1d7971bccfe64829b758a59d0452321b7859da953cc43f47e6922c2dd0d3fe865d52b11cbdd80e19172ed66de1e3a05d0928949ec483f428dff7074f8799c76f05277d6e87ac07bcc7fffb0972f02e4cbdcb2a60ddf45a3e8bbc93fa79ac7f5474372fbbb96d2fbde3e77d31b7dea623818f1d356d2b0f8cf3236fe3faf0f1412729d87d84843e0b71cd66e4cfee3cb28ed69ede8d9359ed68392f15597ef416e7c4293eed710b8e3625e6121351829755d78b0235aa41c7a1e6def43fb9f8758813bd45f380ba1845cd812a02f969e8e647288bc619097afdefff47c3dd43669475bee54b7bd7163fbae15398f451d543c0892daf824cab32ed95d248cdfd8a7d164663b7c119b3f4b6a130697b5bfd156f27d6e0dd60580c806733b29cc38c166ffa8c25fae298c5da64bd2f9e40e167ee570aa2a23300f6c9d33bff0804851698cacef43f48d55840668db1d18e118d5b3670ada10848354e598416604196aeba7e81ad009c1613a46ef26358585339f4ffba9a54840201ff90f8a3369c9381157f4da38b36985e1304cbb9116aef3e348ff1aa70d8bf75ce802f92cb2035c529d8d4ca041fe6abab46888fecb8f03503efae684d925278d92c85e3180fe565b2567c35db8adaa19499640db5f743cd2a82f5990e8d0f06bdea76dbb4fa2f6397e45e51be12db5cac12ad4d98dc28b0b061095c89bd59bc9baa640aafab962d0b7e6fbddf175c2335a34163ead82a84da6453c3fd4cdacd8791831c8027fd9b834131bc19bcbeb670bb4108e3acc4842d6c580c1f28ae4d447a2404be8ffcf3bd34fcd25b6a87b3bc217a814e64742d6805e288b118b150bd0ce6a11f062bacef30880be49d86af420808342eb11e0490d8b5c8404e463d9a10c186eaa9b49cdff5229b468472009cc3c83f8b88109a442c4309ee92524afb5c6ef36dfb0b35840d07d5d3af5c790b6cc84d47dadeca74299c38689876b72c55f59ee6f8ba03372b548fd2532032b05d6c8cd4e27d553f3d23a2b6143418ae38d1c2cba500cfe9321a0c5de235f1dde2c93ed2d93bf42bbae174954327ca08fc40de6a716757376e1f1ae4f3cea4410aba41d07e68a2eba32756ee4eba2e240ef3259f4fa92095fa5e0d5ed47bc4546c3103588a20a78e7f20ab8f8bd2c997bea4f32ff6eab26e0c63a4fa2acdcf89acfa1ead0e79542b915efecc172816755fa9317044150d65f4e6cf2bae860a8e562802cc3dda5667c495e39f0edd9f61593a4dc6e8d028efa96f8ed9b3d38cb6cbf21de85e3980855fa151288966bac901f07a3490a398753b72722f41edd056406d6414559e5ee60f310e673869b95e434aebb721c3579dffc3a3fa280c5d232ea99c2fdfa105f2b7f3892c28cdd9b15739a3fe367cc28989ff63b7bed2b7d087a746fe96b55f1c9bdc9af6200e817b5f7faced9e70bd8cd0a9867351d6f263a72153021c31969faedf2ae2eae2123cfdef56f718e7033890783535c46822759eee825c841952596e55f0c0dcc59e957389ab76bda5a22e1f5189f8abb65255f3dd6907cef4408613c0a36d2d295827a7356988753189a327ef2d0045a557b9dcb379e552b0adae86e92638b9f25bf786206cc75269561d3a4f5601ba6f3d4bd0d861561ae694e0e76d0b43606c369aba144b9d9ccab689f7a27f1cbe94594e1ed0782a4718d8af2ff2c72561e77e4ab8d3e8d7bf202fdb80aa56d531816060e8f644963989661c5963a6564bad32ffb26b5a10378708884485f18ff41e8a60a55a1bd6c630bff1d77fb39e36cea33267b26eb3226acab55fcf2039648439ecd986ad2d833a78bb2ffcbd99982d8a4868bba16eb3724cf6a1b076b2943c225b58b8cb65704b963b7bb01ac139b938bb9dd5a30dc6d6ac3770f69178c4a0cd0d8ad0cd4a795d996c1418f2fe3e9385812091e7e9b7bf72ea1cc8cabf77b19483adc506f27496fe2bb6040367b3503555fdc7f054c33f546d5978ab9c11c5990b095964d2084f43a9e4fd81fa4c660ef6df879b6c8ed19e9387270bfaea2a4efe02594dc7e26722792d4dd54a9dc70860fb6a38a4834b1c80b5dbc03ecff9613dfe631c8fbac25b5f23da180d569142f81a0c30e6e09ee72b5dba7ff6bb0ce0fa82cbda879b632ca5a88c3d3858cff4571bce725555ee6baa30e2f8b772b24d3b85d4edc908b1435bab376162ad48cb079e988f2c58b9ab511281176b6d3b5c63a89616d4e1b514e97142d53f4cb5701101139ac95639dbf1af5a4b02b467f123a2872ddb1a4959dfebe8df22d11b016d0695c102708df7f40a0837cae3da3e7dba81f2e1929295fd070bedf4d10be91a2c810d55b80385b848c4600081620c29c20b01098714dce98dec717127adc757a6f48f2f4477b3c204862b31feb09df550a0af117954ea5edc85bef7598f7de15fee27b94453ae4dee2db4b6e7c72d6ac18d4b89ee7e7d4287a40d800379549430a1fc529dbace4dd6adc6caef719a2a81aa71ce369c0bd684f4f1216c6092d5544a4c4bfa829aafe73d85f5fdf625f322c5452b990e819c7eb61a2e0f59dad5964a6b00b8a4be53a80b23da4f8ea31c7b6eaf4f0025790d4413c8c73c225c523d98b2a0651a729d040004d69eee97f791c19a5e4201ef4ead1be559e9c4711ba7984792288f49a66f11b37f32cc3c7a49e356631b24f0dbb5ad7520f0d97c8f339a96621337ba01fd7d9f6b00f28daf23b65d789dfdee2b87316c4ee789aa65aa93c53f69e96a97532481c8a314a2328d85c47e415542d125b40dc1c15b45b9d0a60dbf449b5c892deb1f2b2bc9f9bd51e8375a944d2a889462277f280d2dba9a849b4240d091972a386a644d186f2af772d36288403e455b99b18ad153a469094ecee56ae178d100b87e52d8e1976aa3070a2ede1f77f54590f5564d05eb3eb5d11725df90558aa08047a7a8c754501d24a952b212f99f2e31e7dc7e74548066d130d55a384e2c407468a933ddf6fe9c77891a5ccca02c27c740ecca4361cbcdfe47e89bf7bd9cf9185decb536bde7bc2a89aee175e38ec65f6a5898b1d4e03c76d14b3fd222360272b5860d396f14a03315363ef14592f7c66ba1ce3a5780e34f1ccd1fd1f2b72136f4bc14943ba5188113d604001036f4655f969f7171a5255bcff987cddef7afcd2a7358287993fd00300123972941cf7586a0e952cc1bc637626c4530357110e3a68b00bf38e5f9c80bd74f28b8f875d78112f3e5830733b35cbc57fc31bddc0547b43089e15fe316691c0a33b28a0a7f46d2d515be57042da860f289683e784a1a73e131e178151d32b8f00682c1d14479b3fe534c3c4abf79ab6f4fad48210a3f39833a2a232a54434e2259468cdade3094ec3e056b07ac24ca3c577e3a8a68e9a715efd9d35693e1ffcd4c07c67d5f134dc93b98e07f529c65cbd272d49fb1f10425632b8e5629008222704ff1b13e74de5a720ab2aece57fb905298d998075040c4a6d05bf4c24403d61811a042e1d88f3aa199103ddccf5c923c918b9b14efe7b1295c63bc449d6bab53b66f886acf184f6d566ab182a3eef1a7c226136de13449e2501042597182240925483b98fd2ddc7b15bc189b48ec75791cea0857d5eb92e90f87b7c17bfef684f4b86d1f6d98bb91916dc2497b1769d4c3ac68b1adf5d3b103eb4c6c553f06ba4ba683cc27ec526ed3ad9da3f4ac709094141614bca2bb676a79ad7fd2fe58b8ed1f5991fe37a33193374b6e5c613a8d70ebd15c57cc072baf26584d5cbcc254954433caf921e0c97ec169756685488d19987690d727b6b1336de24788d506bd03d7023832153ae1243e2d863e9fd11b9da2026133e9257ba059be6238f02731e4c473475f835b99d6d5abbdbf0a4faa09bfb69b2c932e40b4ba67afad5392ce09af2b9937ccce8d97479722b0576f8e27a97b6f9d75daf3c4339272131680ebfb9efacad22198a889bfa858bdf2976e1c207f4df418bcbd43c0918eb9f5d434e83f6583db5d62a09ab472c8fcb03ee1d4a06674c6d94750e809b1376868dbbb0a8c52424504df58f8e5fd2872bcb1111827e84d3a2b355b3b72c32c2d4e0c91faf77f48ed005e3510fef8815b1623498135380b8a3a397e1a7635f6c765abd2a98ebe5f68505029435dba8a8e6fcbd5c9182438eab90554c48e076faa131bc6edc9093b2e0b7ae60364dce430b742e20c8c5bdccf4b90253d40b8354a24d17b7f62bb406787b0d3851f71442d2bfcf49b7a51141208cad0033f7f000277aabe409d4975c411150c28e2186ebb6ce14a065269f23bf6d4b18576c0cb18178caba8261ac4d03582fd789e78e14343adee6001652fe9e27f6597f9fe9595ad13d3a94880aed22a7308cef988a14c6bc98b7359903fadce601204e76129bf0396a982087100d5e165cc8d4b957263d212982f6b30c2cb46bf7bb9c80e05a85d807f9ae48e5095adc37f0977d533cfa3723367a8da315ac594d6ec55be43e6bfe453198a21b783e6dd11049589be67b1e3cdead6966011e1b03b7d390a0d2eec40b6928bdf9da31c8020a30a8eec50ce0fd289b21290e5b922b782cb8ef3e890d4b736f39ceda978541e4905821b4a39bec0c736161d6fd719c86cde9ad8e9d714e084f67bfc9097b72adb51e2bec880e5e98c67d6e701ce9aee06499d09dfa2c1c91fb3e07755f159f45ec8530bc3b73fd9983360b4400bc2c1ce3b42ca8b64cb4e5e08fcbab91272ade4daff297df32ad6288137e6f5802da223c0c24d3a4ce82905ce2fe77b2c903a70b9c4b4f7662028a5d3ecc95f156b8420dadabce8b1fad92ed904da0f16e6daac6203ab6bb72df96a89dbf5ce959bd575d3651085ccd3f0b578fdc116193ad24b297fe780053b993ec0fe19470b6c1ff9f5dbd97733239e33d8db8231bfde42b47677783412a7fbe773ef71753f92c5f16f6384507370e7cd3c11fca99f1b82790d0d0ed1e7119f88b0a770fcb45e96e063e002f9e8b83b2816fcefa0b68e1dec6403cf3958fdc2f13b5b013c9b6b31674ee5e5b02fbbcf976a7c72a16cc3eb3465673b1545e6d372fc4eb7435956c3b4b62809ac62aac961346284f0f529914b58459fef4a6b7140dcd1ba540c2dda53525ee1cea8ffbcb35d1e88b36a72fa99c955f16450d7fb812d8c8b696164a2d017311967c4ea21f70e4c92161ef25a7463a667b25abf2bd14493a964f1af68956c7aa4fef2991e9411be836e214eef20747ea85f07806f5942bbf7b3f3fdd239ba18354048b46f237617971b4e3ca44f6adfe22886d775c977aebb4fa56eaf20e7ecc9789e5845e087c9cfee3f73a069fd3620da93eb6001e9653482d0cba902637e7f4de6cf53cf0baf55e5f0703ff535c8ceaf79f84c6405848bc513b8af68ab1130b31a95772beeb2007578cbcc0ea93a495523c1110af89e63079f15d082de36f42cff4ad6b4724554672780c345d48c265b5f770e032ec9b4915c19abeb9c9a1ab793aae9d1fdd1cc83cb782b9f0ac4f4d4b772ebb4a40cb30f0af209d1cb7650d12f25c0247a881f1e1a7ecbe8aa985b69292797696875a7ed182ea85a487404a4cf7b819065ddab5378df5cc47800bc2d6af863fa7ce43cf9eea557c2a9e98867491471bcadc2ce1af1072d25c3966f72a84c4337279b42ce74b1ef601910ab8fd20364b72b49a83c93ffe1627d46a071756021da54a1411e011b00870145e5a098e54d6c9850454400aaacd0d66412fc202cbaf8fce277cc7fc217d589cf15b3206a5574b27521fdc3e3c0e7d529cdff9196ac9b117d2098805d31079a5c7953143dce0a18d49759ed745610105ac02f43b1b6671f2d84272d16204c842fe1dd2fc9009120e4130b5fa6cc49ba983aa07852e66213eb0e3f447548160f72b1d5e8cd9fe1051d9c55da1f91c8641f481250a2fca545d76623c96a3606fcc9af18395970406aef15744d2b74989fb5f92a9fb61f0a1b5d7397444abfa496e544b17ef258222a4cfcd64270bd2fb1af05c78178cd3204b173dba75b92ff3bb97bb95a74b19eb40fd3292cc84307895e1468b35ae42d7b20949384e1ae86e3f98f45cf6def04115e8f462a8bc429be13600e468c60035fdeaaa044c28c1a64481ab2a24fd6c3d75a03475242d59cdfc8901eec42178b4be6da408578dd685c35c5b484753b71e250f152d0c0762350ebd7bf7e711e8de124111bb230bc3cabe4fba4a7242764f145520a6d45c7ebae948223c99ea225cf02cd6d90c0a1434aaf5ee294c577ee2c1ccf126d7cadc5db5a3fd19171b192d4f0b634131cb78fb257febbda46e4a98e107c9859aa60f6252a82367dcdc0cdf01c3894abef99ec26a526c39f9ceed8702b55a516eb7fab57809be3824d3ea35c6ca0cfaf445902dd4ef40d27e8400baf000f497bae94dd0960eae32b51727ec03bd4794366248a02d1fb00885621e989574e490df3491882ff8b335d0aa39d5be86114edab416fae68ed4b010a01010e0b06327f54ced27fbffd22abe3811164b007f7d7f198230427e769b620d835f3acfcf1463e3fa868a22536ac44ba71b4e7e4de381718a63ae505d35ee795789f5b15bebaaa18f26ca1e398cf5832fff86212c19f513c4bf3fa146fa67713eb836a2b7a775c9b51a7369919c9d649d4b33323bde4a81f886efa2e0f22830b4c97c93eac6796fac1dbc3de0a8847b410668bd78b714bceb681bf46d522cbb3c325a6af597b7198fbc4ee1c793f5f331d22c6231b7be211435536fc07751e39a1631e147cd95d79006d9652a5cacbb3e487cc57e23a5967004ad86d2e796582650afa4af09333e957471ecd13bb6edf138a8a9ecb27c12b32165249f58efc32ad5f04e1abe2ef66e8320f2a63c19be97a8a2ad0a7323cad53e3b0bc621c68f7e604c2d583f664baf997203fa21f3d7f436439a31202a9631d97b7296364c44da5bb1db05bb7c0aa6a4c2a4b3ae3757f8d51a91fe2c2f498a60c723ccd5ede8b41a8f3c3c9ad47fde9fd870750174a7119703e065de834506df46dfab7fbacdd03e6d4d9e1c82235d1a5febfe1d86b02727f640ff57e07dd8914633ddaa4a29aa39e7828af97a7da29b68e86dd40beeca253273a22e8a7f4bbdb2493cc5c5ec2cbc3048f524bdfe3267fea3b1fd236caf745068b631559fb87778eb95c1ad23b38c876f9d1e578f83ec8de30473425eda2709ed9058c06a41263eb84b7e1e4bf748241b4d263cbe358b13d97ca8e0e6e9fc652773ad0c0d4c6b82c2343447a4d16daa1a3ca4278dfc57545978a1b595432105b053802546ebbc693a26d0c5d8b29a11f2d3bf3caa22452756e91e0c22b5d9fd87589568688003c746f1e7bb269f97b875a20a89aadec1057b197ab02f2b2cbec8024e7bbdce033dcbce3d1f3159357f454aba570deeabae6f327bc2bdf2bbd10161fb7436f57fb3ac8c1d59aa3bffae9d14c68ac9facea55c8027584e6bfee7a8bf8fb3f7df02717d17db3654cf917b49a317a60f76268c60774047e06f91cdac4466c08232ea65418a31adca36f93148775dbe735b1627ebb53f4e90435ff04440521","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
