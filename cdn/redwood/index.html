<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bdd4b3d7c6069358b2c9569d90048a2fcfb664f87ed2734a790db55a7b776474e94f13c10ca574e4c386d7d0044c18895341139885232fd73c2d18c87d39e6fb61e9ebd9bfc8a7cf75bc34f14ca40dd7425be3507209240f9b02a80b0ddc994b18fce411020dd38dcfb03a8ad28ac17f6b2866cd274b3be2a9c03d33bea9650e86c157f33555cdb11ae82da653451c96aaffb97abf649bc4ca90fec1f4fd3ca372995f65a7198199433ec29fe3932cf03ad2c61e3c38e1f8ee507769332adbf664df16a2ee80d17ebe77c69ee7af9279860c029329734bdd6eec6620f2785fd7ed253f842dbc1f8790266cc135c001dd4928f5196a87aaa052ce69004374035a7f2d4621efb5b5a1b609e1a784b28f56f36980f61b56fbf935c957c118fe66aaa1ec5aebae64655380dde8cb231fdc2f953c721a7ff86ac3141959a7ae4843839e116ddacdaa5122d35062c77b47aea9b159c11f723dc9c0c4c3eea5e92a0da0cb9ecb8b245aabc0a575528b6e0a1ad4d64d063a3240ffd7efbd1287d711324db6acb608c4e023106add369855951ac6aeef1c57c9452fb740cdc6e6d6e58970657170a30ebdb23d2e962dcf8bd05e6812db64d6b85a794ac74030bbdc5a86acd18513657c95108a7dcf356add4e5d80f77e90b9f35215451fdc1e68977da9f7500b96b18d5868382a0df16f8bc9f41123950250f1e43ffa20349bfbaf6a6c6730d053799a563d916b1f9165da87bfbc9e25cbcc8a30a4b300b625e9995006340c1f4dad0f8092c10a7013d36b03715f390324f250e29ba32fbe79484530514e0910ae77dd93780aaf956fec185e1c1c74419e36c5a4619c7d74182593f303783e858b612792985bb501ea730c906f2c760f338b3dc844c7dd58514216cc9d0e0177c640f1ea1dd968333ce2c7ae1f2d5f811ee24ba1de73a9bffac424f033a2567f8dcfa9e2727fc2e8b33fc48ec2507cbb64d7434c31b37391cd340d1dc27601294fd8a026b5d3d458cb7e3d15f738384efb74fb0bc84e22255fd67fc3a04177f706f638c551ac27de2061cd019c662b0bdbd77058aec16c067f02a493f88059ec36aef3b30ebec1ab7711f47ebc051a5369e0f6a35232beff1f1ac626d3243c656606b5b4b318acad5033d01f032464f0f0ebfce935057d4d6a6e1c881e02fc6ee0c415299a37b2f58f622f8b071799e178d5aba58b8adc6da57c1f0e1412eb1caa22e0f2f2a0855d0f54f9b2a0d125f343f834f531aa8ef1b3a9329b59baf567e61d2dba2453b1ca40532cacf7d7dd8476e0a93208bf15d0dcce0c044ab8a1443c0e61d8ff16eea0ffd72a9e6c73fbd4d13d211349cc05d52a6a592d891e978386189c78fd3f258df5ba666e611b720462b6c26505d0770a7ef2722707c432cbff33643274a52ffbf6fa49e1d5dbdafb203649ce99f64d9825bbd8e2f4a1b66c6ac285f89fb4df06f63053c84cc73f5a20e9060c917fe3754a90dad2c6f55730de2c4e815b8164494bd05fc24007c2eece7f7a976c1aff7828a65f4ff2f994d2ce5c5cac46b2de0506103170f6c2e351bf752ad4da4d594470ec30b99f9d7983477ad882203ccbead0e84bd408037b72528e865ba5fa52752e5809e0d24e2ebc6953a806ac20e0cd012fb957c84c12b9f0293b7679a3ef6b6007212ac36e397dcae92d2931e0814d6e67c3892d7f4089d50f9ce751d4fcff6b56edd1134a582134ed17fb80a86714093433d4c829904b009c8112d68e30b1be8964892eb3f7c75a8df278a5da5d5f162e00ae5d28bac9aa8b2fe7c4ad97bdfba2d81b9b69229c40e2f986031c6bf167525f44feb40ab4e59dd4fcaff498f2226f67b1095dba7d09a67951b21ef0518d25f1006e3bf15df189d1b5a584d63416101f9b47952f271fad5eca6ec4617d49fa48e97a610ca309a03a9fb1cb39772621cfe8cccc98fd2971994c1709fe0f2a0a7fc656d545e1dcc8d5b5d6fe5c491539b57c1f6af17d6c67340e1eacd45015bf40933daf19efea72ba4856176a2898160027a2d670a40f7349fa362c8cc7ad33ff31d5d847921500db4080fc9eae5d595d1224afd22a8d919a8f97a27d6bec5170ce5dc20b3636b5f6203341f8ea2ab92115b5a19a672ae5ab39938899747cdb636121fd7a12f0608b6baa6851a2db2d68c3985178247fcc59cca9967d595a665d5fd52fcdca21d78f1654cf267a359f8d540919a55305e3271f4ed2233b474e8be635b992c742c47844eb4f530294e8541a85fae894aea556e727aa360b6e83c19f47efe18b8859458b63d6d4c39f9e818b534c759cc00c763e5cf48ff61dfee6a56b1f5247cef83de8eeaa084e769344ce96d6588a3229c6cf1651de7c53b237430f34d395b1f3b9fa7c300a129955329249574fbcce4d8fff14b9ff345bf3b6718b5675df0f5bacc6b6b29f3e8bfbd839f12fa69a0710409ec250f3263f48ab8862eaebd8f896e956e04b1c31e42bc6df671a31fc57b2dc03ac277c2e2ccc8796ede9f7cd8dadbaebe1cbc15795e4b1d08e9e4f5da155af84257a1e3a3671771add9bbbbd20fba817b49c7e3925de94ac3f38a3b83441719751367c53aaff9452dea69829ef53823ff51acb7b1c70bf40f84b78bc6f6ae4fd1c85604253dc03230d7d47048000d4c333713bc448abef8c64bc65b0be3c41a67c43294ead79d701bf886da8d44a02bfda7242f6c574be0096403c6fc47cba5b53790145b6b8a3de6ec5bc550468a3378c00483f347a3883a7df7ff532c55f6a86c24f6749b4c530a0f4a96237788aa03e3d0bbcaaa75d0893598e96289c5493be53bd4033631fed327d1ae135d49d0ce8375ebdd79f5fdbf8c31e9d3cf8191a675e25f4e47fc3947ba35bed2d956b829d8296c28438efde0a0ac3d744266782b0bb67b253dbc63d5e0b4f201cc84a9ee6795eb52c9e12e89280cc43aee2099a5548b5d8640b05c7ccfa443c93c295000d34c50060fbac3cdf9cd1d0c6bc6dc561f05c1f3ec4c89a29db4f169397284d74ddcd6bb82719d06294f481322ac6a8e947d103355ae5a1b2c4f58636fd4356a06ee31d5f289bef98762d72b312ac946d0ccd13c5afec1863328fb6cac1b19c4fa4dd3fc0b4459ef8c288303321503614ff29b751c319e5c7e586230e97d007f1361e53773d688d7eff1321b8a515b0a398ff96798f15ad5773462c69133d22be81a79126cff5866ca5c7448f676b84633622463ae05634e7ba7cf11836234de19bd280c7be71124cf7fe5f4f41d4ff36c0c859fc5eb007f235c6a1ba67195b536afde38c1f4441cd016c19dff432ac1e05c069e84a2f995db4960d8768691b4b4f5064dccb5263555d4988a177e4f6bb2adf9501952d009ff93a676d0fd07ca48c8d615d33c81899d6a1528bccba557c460c3501e7d335a3c86e209428bc5675fa6aec4a5d91adfb49662f69448dd9bd4cf7e24481a99d8cf1f06b593edbe4a0d5b6beb47e529afe1a2a4f570807b8744ace4e615e9306f4dcd74d18b82ab3d4944f6280a0d2cc3713102a2aee8c6ff6363c13646028d4c94c105d88485642bda31043d4e7df4c6e3fd84e14a125819eadd6e2645947c3878a0cfcb890482fd59486e85f7017736d80371cae4996abc5ef3867c1b7c461a3763bfc226ab6bec544dad0eaf959fc85dc8afb18a5460209d457c3c6c480c9b3011d574050f9f37bc99fbce1a2fefe583dc1e8bff8a5b4e74b1337c8bc0e6a95cd04e7e85b7a1960c077aab745f6ba19878d4bbe1ea824472c2b5b86b3e08ef7fba6d590bbc393c836f28476354d5b90e23b0061a09f7c6a9542c8dc8c1949c564b91cfbf4985448635f4169ba17ef8df830942794b06b5cb62631227aced58483c35e0dadb494bf5c595e99b4b7d5f7b0f225bb4a08cd1926b8a467f7d74a31ce60c2db93794308c023a2330f714bddd074de294d43a9675165c9bc2d8b90c8d0cc1710d1b9654a16c75fb8f37a583150f9bc47c87a0d9603242d4abff77fda9e16345d2a05a3657eb9eea6b3770f805f3ac05d8379238e6a02f376473cd85ecd0197cd4507333a2bb51fd1d73a5faf1e053228bcd6bcf97395dbed0c122a8ff683025a33107dab66e3c4180c3e12e43083ebb30acdb5c481cb9a691a543ee05bf0dc0552b0c0533b671c9f4cb4ac4ed975c6e181ad0281e85ad38bc563292a844645d7310d2affe9fd860839a635e6a68fd8b360c9160fc031959bce2e7f0269ec3261894e46e34c870aab30d636f233cf0e93b2e81a6a0bb81ac93efe5cd6a9c52fae24bf8b808853e9f5ae390bee5827164fefebd5a25b0c30c2a50a811bab6007018dd16cfe00a5e040310b092f1a950e0ac5c9d43194d4416e2bf44e2957b50fbc475faeeadf0a5781b54ff7981058aefd960342525ab10c22d3a7a6e783d904f333b06ac5bd271f5eeb3389d4159eedbcda275e64907aefde6c122d9d33075b2c9401e8958ceac050174c6bea4864ad595988972d8543226ea0fdcd6f435afb63e348947c7c9f067d82b0dbeea92a7f164b6f3581f58e4749f85689034a2307569c12001b172c6e9c3301c9ed239dd31387059283bb0191eb5b805d0d37f72ae0fff8e439ea9479f1de8082f7a78683704fe8a2793a3af0ec90b598acfaa4d2d8da0dd05884ff153b2246ef2bad7bdd131ab85e26a6955aa5eaf546cb0a4aec69d3035e781d58ffc3c8e11fcfa5aed07662953c6a2824c9ddd0cb2ab2112de27becdd292b91b16e1df32e7253008352e5c55ccea6f409fb85ae19e8c60181a7f4d46ab293d94aa408adad45a741d65e333185d41dd8bf974e649177993764ab0d7e9ef8b9fcff5641bf64577af4b0b1d05f1f2bc06959b4a297347f4610efc2b447155bf840e9dccc635507216ddc16d892f6bbb987029ab37786e938e35ad8c03125fbaffa5a4836a65232d0270818c2038712ad9512f5929a791447b0cd5c4086ac8228b927506b82f889f424536ef80d499218c30cbc9c2650988abb18247a67dd2dfd4ec0a8c2f5a5c0937e6a31c7a23b4f5ad2d734fcb258625a6a85b8f74ed4685f571f91c879cfeea94cd2a24d0de36efeee777b90203a7d2d3995611aa06d97f987117ed3de80db73efcd6673f20f92d4f5baaccac68e3f04d2a937d8e35c3f5b0f1a9b957e1ed71f5aabd54709181078bfc8fbdbd30039c6d440d15261d84f5f5a7676447da620b4aa0c654bcaf37e30dc7af433e41a58fed6fc244af2294bdb4412213af8c4ab1c93d8e06045534ec84471cec7a1353b7ca40af3bac9d561adb5d569ab76e73238f937ac64c2bd3e4c24040f6e432de14db1bd415b09c721e16912eb1a5eea2b38d6fc5c65e7459e39dacadfbf452b61bd141da5d0825900649c27a2e0342129dc922b9b27e3ad738adeeb5b2b5599186660135c5570eeed32e5d07be969bbfe429bcec542cba4ff521b80980e63940ea76296929c88e1ad1fae61e8386a868baee79e05fa8de288bb1c98a77e38b706393d762254b800c665c4b0691fa4e665795a823014cc04781badee3abe790d5b4d5c06c3e66de1fc2b6114af87e1429344aa69883b0bcc14d5f36cb0e4d6b53d4cd716ee4b6b1026db351abd8f91f089461dbfbb952aee0be68bc7bc07a420061a35a4989f6a543181697cc2767dd2d8533c15183b2eea7ea30645195a4e465b75f2ee9ec76d0e059b1cef210d46b4b0bae12f81791a0bcc00467e0924bc8e3c080ca75d401ae5feeebcb700945ac476a899d183a32caa14ffaccd51cfc680691f043cf07068f331005ab52e9ce2eee4e962cf0bed89b5843e280159863378186d5b35dfef6b09f1b2c5ab5d5845d85d99fa425aa0546b8dd5f74e5a133abdc5c77ab64e9ff3da3f12442541884ec505a6f43406011fc7f3e8179650f3b08a15db55984c1c9b629a20a4a0badd5c9281b843a5480482c9f10a0be64bf690379b77b46f0cfd2120b3a543f0d95ee2b3a8e41a43a44a445ea21b97fc32db419af4035c1e09751404ca09d50f98d24f800c1bccc57d9d59e3810747530fdb473853fc19e9102d8c650cae073613a9d9822a33b8129ac88d6df45cb20bb19ac87e9e5389afbd6d38e74155a711083fcf3c4abce6cd2cf5d31b4980787bc89986bb3d73f957ed0253449006966d32992512bef2b87a3f65da86a3db3f15033c003d8ba929aef645e65936e223f8866cab16c196328466d5175454c0e5f3fa186f7b71183484cb97f251e0baad6655230293fe374b47ac256566679ab03508f41027cfa1c75901c912244717276c63deaedb14c4bfbf1ca21929513647b7c344d7a3f865338d9e6051123b472e223c4aa6d0c730dada4ded9fd91dec22e259ffb4ebea026e6c1ffc7076c079ef68e662abd2d7d4c48432aa53bcf2df92d986549957c23ab6fa8f6263b2f3b7a9b19320b1008d368c8741d985ecea69f9b827744f7aa0cfcac79eef156719177c7f2a9d7aa2edc9c1f00f64a19fef75eb12a30d0f18946074d2f573339a8f7f469c90b7a6ca072546aaf65353a607b38181db5f33171d6d3f73db37e03f2b2084de67104e586ac806fe4c7e90fb958a08318b1d06a24f7e32c76e9e41ff1117e772f9077766c263a33a23c1e70311a6f832e567abbd2e4eed12025021d8f6ad401253bfeaab06de3d596e2037feca4730a26e85cee412691d773afe60729c83da0bc6bcfc6322534178d297a046be34190eb8cd4894149307da898d4d0eaff1c7e22d808e07d8979e61f5f4a77be25bcee5cf1b959b8fff6350891153cfd7879f1c99b44938acd0f6cf86315c4cd0656ef2ea7d57b6179cf8ef7eadf79b2d3fdeb6356e2a19dfd5fc67762bfd027e4e977eeb9364337e165da9a32ec53ad90ec723aebdb486a0294bd74bb35fc6ea71f7b8562f324c0d1071485cc3ad59eb37506398af086c51ac1d96c1c6ba8712521667cbe569e3a6f1e6e5bbc65639597dadbda5276386c5c6f67c555e187e0e1582e41f03d5d8a15b25c419a92c250343e8aacaded4414de29cdd21659aff854a9fb3f76e67c8a155a78d1d0e6b56936b82faf89b306a6c385b1d1d7101bb35f7eba7e3373de0005bace798ef29d9b477e787c70133be645ce064c52b1db2bfa085f2e3d66f2f83ba0ef638d63a2a718f069717ac15c3deafb225cf034617e05f836d670ca5829ef59bb7de7c47716c7932e67963b59d238d70f983a21975bcd89025a27204a9730d5b4b4405807ee732bd9757f73ba4f38d271d3331eb7e353d67b2d6e21165472d0107254096e3fa175bcdb6b365d4b861ed4a11f11a1084c34c0989d621e0bebd02a2cf90f0a71ea1860366c7ff4a813a584179fbbe5243253f86f25ee1c9ed186e2f9d8c8b835b1f212c34f7b628944b95df3542cbe678b773594c77c462144fe6bf1b405b88479f2a8ff7de493e97402ad3dd86e2d124abd81438f93205dd184779e7cd24669bc7b6e53901fa07bf1c658cfea80ba5a49bd56a576040c843bc702fd8357a1cdbe4512ebcca2083d936168c9e98ca88d877371d87e73d8736ba169e14d11703089c7d239c5a3ef9ee6877f15b8da84458fd087a035049ad3292080a17c310d849f12215c5e555b474f6a2ecd8809a9fd61d4f061c9a0a6a1c2930babe2152a558f98e0f20a064fed421cdd84986e5f0af976d00cfc1dabaaca9b73c6f049c9b97b3c88e0d1b88c2791e90f6fcb49df51edf2175509a30dae94dea1115552582912e71e57a6abc5eee281844f56262c35627c69996c58cb00a68b619b395d8ea4c08eba759723c6cc6a04aff2cb9c3b9a582aa707da66e8e2c3c2fd5438daeb90fa4b0a89445666ea1bf7a186ad00432ac3ca325cda245c7a8ada94b805784ecb5127bae9dbe8161e29290a464da359a9c38c92bd1f7e7444ee994a73ffbb3ca56b83170346fa5f54ac7d015f8bbffd775e9e12420524e03fea8d85e3e69a20cfbb0205d43f0ff8d3c5dbb19a2e695ca9880558495424c5dea162e0869755e6e600350f3e66814543c3ecca61f1e2bd3c4e7495eaa857c432ce18845d0e9a015e9688cee4cc546108bb2809fe7471da73aa5fb552bdf151f9021600c82379429b0174ca5beb10906dd243999924843bf07315dbb7d993716e5ab6d32fb37c0d8ba28c0d8795826a03f2f9fac193c7e323e58d05a4785b4874f9ff85281e7f5a259072ec5285501073b47383a69bc0ae2c0e24c3fbe9d1a73d3fe4f5866d9c60e28a7fcbae6f58a8d19e6b49594bd835da37ea8fcf1b4492fcfa27df32dc25824ea08f7d20bb7431c62354698ab48c89f1b6905d72b47ff5664b1b86c4662a3d33e0e3a53e1c83a0fbda39dc7c773a7408156b8e7b715b7261e9685a8e545af20530995f9872354f00a852da07f7b06f539cbb2b99ff362422b22bbddfbab9ee1c8f480107f2d826adf8949f207704b1084598ae2b0d278061cbd99677cbd613e801d14c24b3c1337d85e94db2bb49df4ae8bbb5d0b24093c8da3e3b2d26e52389aa03e13fe1422da99c591f5af555eccdab7b5ee7bef2aca23fd71b68f18de637839834f1a8967c2fe675f88411b2491182f7a1289366cd532f0ca3a624fe542ff558e1d61c5fe0a6921e6b3dd37ee3114dcdfbf3bc1b3c578a84d2248a5cbfc0231d03450530a397d2968e1df3200e92ff8c26104a2b41fbad0b756896c52f1af0ff2a1a0790c4a9a240d5d9556c5e55e89c1f37258b088423e238a3fced58fac7ae7655cb614e61cbbca3601f031485930f331a1d5cfaa2468e5c5e2987c16e3ce0a134fe77ab8ecd622d3ca0b414b484cc6ec438e56854cb54452c5e956a74b33423a5c0be3db7e33d5b69a6993bbde96a3946b8da817b522b5d358c5e4e6e0d3664fbabb495fef0ae22bf2b053f2790b9bb29d1dac16b1d39b31a391a16301091fc185a69cb574e4e26de6c2e2101b9f97374cef22e96d95553b874645059cc2db1f23e7f9847f10abd33a4f226106ae92ea95e586aef1390089d84b1be16849f941a7af03e1256a4cf310b3e3739981696c06fbe9a40d76a8656217b6e24362c5be6659a700b7f681b8cdf287bda61aa404dcd5c4f30baca5e839ec5a91fd18b19afe4f385f1ba049ef20a401236117b5654e5410491adc89c809e5a5e7f43f80c4a02909c39ac0c9791b02511fec5611e998027f75715f46d1873bd2bc0c1df11ba6445bcd03cff3385d33a80592537437a7dff3008b39796fa6d85eef212244c7411b149dfa59616ea01a0dcb5b997c114d1a9d87f8f731fce3d9ad3993ffeb59e378f4a7fdf56f761a8d4e47c965e07f425377e004d3538697ce9a954fec82194a8b7282ffc97ba5b478aec0dde1df2ad187718d8c481dc8a6a79138c7d0cea2908140dbaa79e823d23551179d8776c44aba8174bcf196ee81fa5b12cd92dcf673eda018a43df2c37fca5be5e19f377aa539b114b6ecde593fc7c75c0aef24a5105ea4c024708433b19c0d0117c5e3b4e6434da23ac23db6cc4c7aa17c85e9b70f7e648a8445c4abfb91f67f4a9460ebf8ec12af2368836c4cdda8d71b47823f6119d4f490f0f20ee5090ad0e15455d44423772c69604a8577e9bf64e605da95f29b2e9db4eb01323563178f161e0af7eea6d2c1a005ab0d966c6c487394230c78153a64b0fa85b97f3d34b40b48a0015d92428894a3bcec2280572927cc9cd29c4e687a57c485153b861dde3cfdb30260f3e7fe3ec314eb253cd0d8e7344ec21609e19ea4e311bc228f45fcf9084f8474c1f5f78ab58d63e774f644483d25149f790bb9a7388841c8677875f58b25c064c2b882747c69d6be4689c69e9ab6319455985cce3b24faea47701bc91d706c0481db72a621b987290424f280fb1f4bcf531f56791f70a6c22febf84502c35152ea5954205129c4dceac09198cb05e5df5daf927c2843a53c1e74b642a2dc2d8de3d1de9a59a95139f8278cfce4d2e00534534aebce8ecbf3cfdd51d1213ab211112abc99e037f79ddad1e8b4907ad9c068fe129ab3350306d333826a9f942e80d26d859920e4d2907692c7e18ed393a97edc1714307a8bbbad77fd03825607e8420179e6f33b0bb999a68570316782880157746c4b38a1ca016efd3a7b8ddb593bc33dff2b7cb70f58f16ddf40d7e8c1058ef7f0a0a5d4902ca5bc26417a4e622e264ff6031873a836bc434f7713a1b41f3ad26f045989711823e96a938af28ac75db953184c843e8c5fda80dec591ec47dd21de2bf0a57dbbb7e0a7dae99b41c4a5191302cb03843a6dabe1367a5d1eb86ab0fce74683759008729223b21f991a7474c3e32ed773c167e240d29e3c8e4c46bb9a4dfe77176a6d84c198ef62af887e9faeed8e6593082380f7b9ebe1eed68aabfaa2a894fb108181efcd89f034ffad31a774a046b476e6f5fabbd39d54eadb102ba581889cc4935f1ed639f1d6c3a1a8406fa8711886b06e1f7886dab839bed6eeb25d799834ed6263ae8d212283d0e5ab48c6902526c153f527b0e912610311a0853ee4a37d60c9f972320ae0418959b0b289e7fe3a481385f8ce9e46e9712ee4d2b35a2826f250a1a2391b665334f62a99d0eb29b719b0b1351b81e049cb246cd8ce4982b441f58036cdbcda5d37db9d4511e8ec7115824de44f52512c2394d5460d394b925f95fad7d7991a2547ed173ac2948a4cdb602dbff1d3e4551cd6e341bcde8664c423094c9f19ec61a4b93fbafb3de553daffa29410235f1cf61be76295ac8ec4c1f80da3b192bcdfb75bb4d0181d21f8a7f59bb78aa277e5be77363c174a419797e9c662db781901d25c6d5fefeeddc03c8de56fb5363c4453d958feb5fecf118f81f03847de1f721fff3c38986e5af316498817a59bd9127b4678708b65ec5f675cbffa8f1a5433ec46bfaca039f66773e5076917c12a41c423ca63d56ba9285a7491b6c7cc9c44b52e7932ee3c2efaea95f28dc92ad2607240547bfcd61622e364615b146767c8b4c3a918b3fc5758b1b1148d9772aeabbab7b53f05f46ef258bcef63e6ecc6c50098fa52781d74cbb16bc641c4293cdf31599b3ac6435c564d49da613a8b6d494f126b2504e67ac64d4a3f7ea3b879db5e7a52638d3c23d1eb606a8fd6f7f289fb68c689f565ad6e457164972ce58ad60bcae98f4cea4733f4ce0f1258a23a5c412c39e88617448fdf54799b99b25ca1421918416997a5e529de7851fb1df301e9a4ef291d549710d7978e40d2236fd6be755bcc0c224eebc0f86d960a0b18105a1d620a351fed6834bcc3e2639270e92a598049e89542516457359bc3eee5205867025241319454beab7b01ebdd227ff2dae28bd216fb363e9db08a6ad073552095c5d8aa8877f3f2bb9c45d944cfbf5474d25e58f684586494da6656f893525e902d7d17c26a28547c155cf0f6c9c502a17e59ac99db0b6b0d43bb0f6c13e1f9098f3b97e8b65463289e4e8310de40e112b9d17f72806f4bcc2e9df05377eddfcf8e70682d1fdff57637a9fd8431d7ec24fe0d410f26770a68fd4d16aecbd3d36d06ecbc174d4abd8c7e9232844d842a1b4828f530bc081d43efda4ec43013ad3be743ccdc655a630b53723fd69fa679b507b866ef839cbfbef2203d48c76a69b49aa6a5255b7ce55dfd77c332e0e23356d201fbcac244fce8a12ad5307e2266aff8063964c849b375e533493e441cb4d3d5c8953f6abd4ab6900ce295332bd18475fea99e702610089ec72b65118c473793dc094f6efd6e233ba0f7e7b22cbeaef782179742341c9ad2c7007359bc5be4be4577ce51dafa9e84e3accfae58495b5dee82292acd298d253156fdfab19f656a2a1722f4884cdd89a90e19a3908268da86baa4acefae16ebad816104083c1f5dbbad13f47e09fb64a8ae3efa50d6baf22a06c6d4d99b451d7a3be84ed9fef8c202ab8e57c3f3f06f75e4b3e304add4c118133842df17f4975b9676f9942df7893ad3452cfe805f80b5e1c011d02e63f1af2eb0d84c5ede3eb918d317fe3940d62c0f67c6a7c80006e30af41e626c522c19a24c569a747d7531c547d3d09a2b3abbd9659a879ff0c4d93c1f26f65d5fabfc53601959e7d1100138e7bb31795f661ba382de468aff47751d8b0ac58b1fc57e1d6aaa866201b910af63cb8c0665b7e88fdbe68fc4215ccee4ccaa95446fc9e2c60836e6d35fe7e7293872c51e0ad6cf8a5941665f5708fce2459f4e6b40485f28cae5f2253a8157600cb1dd415bc371fe771f18e24efbcb5a39585f07d04957f0383ea66c74cbe6ad3afef94e8d3a9f3cd193b979406d019d1b809badae206698e2a630c6f74caa8992b7eed7428865bfdd82850d4267140a9fda074f6a100c07a17e7a64cdba31ba8a5e84a176f91c9a7b32fc3559948169ba634e71133aa8d7318301f1b08a4750f5c7efa994f2f7533c3aadf21b560f184c8e4251d705a2a76f817fec3b9be37c5aa581c10ba5a68cd22aeebedff4ddd8fb1f1fed29c296efc72c3e8c7af943cc503b511eaf9822f2892062d5c5898b81a582c8a6064405bc09b19f4060b8864cff317a7e6299c3da5020a7772787519e99ea840d9319a1b15f1aee9b737f8f2b7a4c0cfc1362bb292608b0f5ceeedb8ce236b330f19efbcbd74fc71281fe5ddd510caf689e4842c42ec20fcd12a221fee919a623ab71f29bc15c287691b8dd95baf3d1ee6dc8bea1ef065726bc6db5405d9a17b8e08186f7f776e158d66c0794dda35bce4adac3f883922f4553015831c1ef4968da474df9f66d223b72cf906d73e73b8cc688acee10849abe1fc54ebd614a873351db198542e9dfab8c3fc76daef2ddc44232d9e408152d457ed4df9a1200244f3a2448da1f2ea082c62483fd33f47f484f0bfa2974bb8ff4507a93703e8bfe023f3b0ee1a1f60f39c6b824b9ba8e28e0ebb273c58ade2a505c32cf1eb24a5505cbb195ff9f26df58d17249ffe65d21ba3d7b2a7ab3bfb43a431c588b4d2eb2c070e26b3f6af5b26ff899cd90afcb95ca2db49210b879caf86ad3ed7289996a123c8fd0941a7c80525a0c30adebf179f55c8398b2995cf0d974ede7f5fb6b3e34b22be470cab185abcc8f6527a3c7075b7d20c8f416ce16ce98c07c66aa07e6a71370cc6c2ca839afbbcf826df3aebea88b662abf85e7d56f33258512734f12d9ba74bb46ae623ab8bbb88dcedb66a90d5c2de7fad652664a82c08bb8b47747d19f28886ac178cfc014f9cc5eac8eee62b803fa779e14d8b4f9a2c5ed73f233642b72f0f2fb47e0b496aebf9d8cca7e6242aac0ede46cbef0f30f9230528922f89b7034599794663088a5b6515db42903b7f78388437f375955b831cadc1336fa52829f224aba74f3789023f0c83bdbdb7801c18b868202ba130f1f7a19a128019a1882bf886bc7a72b9d81797216c83e10873a9b21cfc82eef9559308cc66b4a6a85830c2e3c9494a03f9b6f221f5789d226097e057783dcfa5ee02cd9dd48718afd9e547fe465134c42d44ec574a2af9c94e8cb206f2166de62bb12dcdfc094d25477fccacbd8b532965efb1667fc1e9278915574bb0e7df49054ce0f8e4862168cf35afa148f1adbab71b0d649fce023df18c9a47192e824295824570ddce232b923ba8e0deb943a362fdbef42d881888bf15835c1f5191d9ae56ba0dcb14258d13834570f8ef6c0104a4a4d7f49d8f1eb23a51ef1bdca29bb274dcb5744bf7013cbb44a4179ff8f39b666ab796652157eb145d995aa7ee3c5349dcc987f64107b782db646bf7bb0a5887e06582a01174e2d44a894afd71cbb1e3fa4a42223b5feb5b1fcebc8379934ec137f0240757f783c282f3330ac88841a32eb8156241af2ae45d0b60cca19f28faec901d14ecd0a4cc86804ba6b3cb02c41a67978da2786d2092bd242a7a89c91bb1197e05a7ea1031a098bccacb1c3eb87fcaedf339ecc95cd3fe7d85f75ada9a11dca1fedc8ed0da9f3d47da7db20a82241fc7b421a67598e9845d6dd8c4a89bcc519785da467b76c2b033b50f5c8f9964ca5e02a2a89aa69b438888dad7855e25cc490f1303396ea13e1ab0973b7f570457d078411a4fb13dc83f62915c2dacda32a08776f4539d80fb3556225b4262ba1258bb26afb90cab13edb2709ac21ecb670e4a514b123cd057c5458406b52aff803737ca1b87e2752383476e63c275f3906f8530b37e937e7b9d1442d9fd0d8c316baa6c53fff1897b2a82e5e13dba8427c41c68c8f46a9e54086f58c87cea27a69cfb35f046ffd524e44e6fbb9be917a877a926c69d1c63980dcb195af46f3d3cee99b0a45870995b4973f8000a157a77e158ecde709cde43f7df047de8af3161b8f7a8c2e241be98a8dd957ac31f1aa1c3ce34d584ea6955074bc8b662a60a9abd9e05b2de6a2bb5a9c4c6333d54fab614ef6205b3e880678d9dc317b35a2e6e4988c3550f4ecc14bf53d9f0af239b119150136c747e7e9bed6981f0b216d4b6835e2e6798c2492a1c7e99e56252486f4210b178c8943b8d4aafc2aabf3ff283e905d733d70d19a1b967ab8a530f8657eabecf4912480be1a6447126806db41130b5a3ebd7e04ae8cce013876a3f0318ee37dd0834e55bddd12440d0d91ba7302658e05fbe471e36060ce88539e24ccf9429292c7cbf6e87a245e0461235a0cac17c3bceea12b443dd3ee0cd244b09dfa59048331806bb87ab0a8349b86657162da5a01f33a67c27a4bb3dddb074f086b3958f842ebf9e8664d345801ec9feb3367579abbe48cdf313aa5819cf1306d0809c51fe5c1a9b8a804cbbfa161af14b56ffaf5ee4f0a8c19bb61c7fdc7097bd951e6dc5f78a36f3f95845f5fbf1987c68159947abaafebaedf965331e2edadf31209046c02a30eedde8b1283d67411198eec5a25f9b730ed8f147491f2843032112c841765e96f4d96a8cb8367d768419297486e759768d46c338434603b7097844a5ebec410071ce6a8d293483ddbcfb1ccfbc5c60d28f4b74e9d239637fbc1474051e3a164f4f4c519f7a468985681c4cd59b4bac161e9de65f7e842e637a9c16384b3f87226df9417e7e78a667c61e2391b1ee1863a40cabfd5df776f51ebad545914c4cccd754c73e6ee27a5a86a066469c4f1e56a7800f2350f136193c9974bb907104cadddf24ce23c4b9db5da7c6ad031164cb04238e2f2e5ffb0d81937d6c1801f4dee76d186219db4cb6d7e30ac485875eb2d5a1c1e4ec7a51a1bca557ba12e1ea670b0d245490d95952cfa146334334451bb1bdae6ec973cdda9763253143a7d08a8b0cc04bbc527528c83dfc526bd3b76bfd51e480db860a08e348eaa27af88c7ccfdfb41ddfc66153e70c65db880909eb71c432e682cf61aaeaf680f0e6c80c8af37b1dc643c890c182aac49f53cbd84ac7b70495db386de27209189d0e97cf4bd96745e27e9a107f376585e437f4b7179bab859d3a7d90a2e58eacdb58fa1a6d7ed6bec77bb31cc53be581b35b82a49a53c1dc6faeb1bf082a4599aca1023dd4485845d0e98dc8183fb61aa823eecb488f9317ed2368635e2a50fdb0bc1828ae2094238ef0027a4a8321399ab1b06df7e238aad9da6d05544b73b8811f11ccf53fc8d4ba7e674a09778a48d834a81719b191cdaeaab8e3d32a7630e4a52a3c6fbfbd87dc845dbbb846c8a4efc1cddff787951096e97f969149336590d4c23f1fd2ed2df299d73bfb97b872fc787dc0d5c639bbbfe922d0ac3783316b59d5a5f5f367c5469880841aa09cc64bf565d086a502e99afa48f17b572c7f016bbd6ef8f94e08cae3908ff4be6627d3c332d937cfa38c8f39f37840ba3ccb5ddf752a5cbc6554319e1e6bcf269398e0d069b5d2fc397daf41452a82a9c2776b1842fd318cf9d134d818b6500a41a95829bffbec2bcf712c9d7e2b5044175cdbc6589c70b16ec70c960779329289792b420b08e739f959d4c34279c4738c42f6bd4095460b64dc095d83878e034188b7e4507153d818746b7214494907264d991cc30b886351b9c3245ed963f4ea3f58556c6ae3dfc79fda6262a92af8ac9547dd85077406d0bdc0442baf85f595c2a53d25d3682ccd855b0db605cb99c941fe3cbf3e1f58208b1b8cf7500e728235c4d371e421886a8805f109e8877e1877fffc6c59d2ed0b298916f03b19e7b4c8d682e6c514b10027e68cbbbbc429ab5281cf9a29f2e3feef85540eb27546f4395a6f34d0e567060829569f5ca7e4fa57023aa5f116fae4ba92ebc8b28cb3875e0197692ab9e613a5d313855558c72e74969999ebaad0741b1f21460cc28467a203a9f8dbb6a97503d2bd3c090d4da4d3ee42b418dffa50ca5f92bfd165db2489fbf8dbf34e9bc43cc6fb41690daecec1026c006c1e1e1c0ef29ae0bf121893cb2de20356bc21cca8f6f89a520d0ed8bf2e6f7f59f57b632b9c49e08a03d5f981e5d9e3b0192b0333760ff14f7483e9185591f24acbb5faaf2c3eb15aab15096b54e0163cd54d98eecb4d557739dd099b6298c345a62a6e47e7ad0d0ab48245a8087197429e09a342d44c011dd9e1bb5ce6a362cdd0e05e983c14fe3f4573a57d6f1ee401d3801b8a8ae6c019f7c2ed7c20c9594db1ed245bd225cb542e55707362a9da6aa34a8274c0c8ddb35d74be4e7c9ee0ad743b883d13c3e652eb391a23fdfd76fc6deca038616ae2eb6915d5b94852c6b73b9e7412e3125537c1908dd358231752e28c985d60a96a213772c2072d51ed7eae4c06b7659d9f72c478df45ec6c65583582467452462f6cf4f7a35c4a7ff2432579e8ae7608f44073f0b16a8861fb3c975840c80ee3977dc93f6f63aff17883514ca4659b8033106aea3b7bea0a4bc32df09fd6cf08c87f2230fc1cb6283ea787622c26cde2fb2a97fe8a50420d9f53ea62b1855406af56836133848ecf454ce118dc9719d3a6901e0dd9edd755a7b034bad933297f090e4452d021f10221d6bc2a02df74040a61067b989f446159dcb8b616f2a3311ba8fdb82eb69b8dd0d655e48e054a876a9744102d0aa4f0314de00145faf045ba8b57c982b74808492e7c7c708d2670544dc653c88de1bbd7a4ef7af92965432c533970645de72ce8c5e66f7335a16cc9bcd78fece8b8ae62cf4345e91ca0caac825a09ee60641d27e02f76664f8830c1aeb37322372f4c6035b79c1a8544b89e05b39eb09423ef1a197e2505e6261536c847c231f7a0e967e28bd2855c3a39f74de6403cbef3db794581ebcf173c74a5aee75cc2509e813e1464103281135efa76e7794addf75c2a2c0303c2c7ad3aade84017aa0e2d355e9596227db352a8c217bfdd66f0d222025c456ac3e0a68d84d5ef57dd10475ff3bd95971ffd52b5032864448a1bceb3b93383f7091602169bcd9803e53f5530f1fb1f3927116461a3271753802eaed3b1dcf611fb3f7b90c82addd076ef089cff9156aeb7004fe3a3a42213530b2b5812e436546acfab9764bbbdbca31d8d433c711d2b4d9f3641b468101cebf7bc5a3f6fdbbc293a323d2589ebbb51321fe88bba39eba8721d24ee44198c157777e1a93bb7ff6b612f3932e77f1433153678d6c4c63adf18bfdf28711d6b01e87dc8305a19638834c35f2eff410f765c4fcd97c2818bd042a2150313ff6547c9a6f6dee25886a281e166755df5a21a91ae29840b50113046cf671ffe9a5589725bfe5d99450aaa94e96a82002e63a4d712aa9a7a5de20d2e1fc51d360d2ff3faddcb68722c3f7a9b0eb9a2e409dd7da9cc2a67989c248bd3245d8823880cd8fb7c7c2b60b1ea252bcd8cc429f039cfebb84050ac4c1e9cb5bcaf5cf003436d12ed84871d2fc54279a93b13d456c881eaeec83db7b31b1c8da1d5abd6eec16d8076a68c9ac9c06b98d300ee996d4fc7f825018ad3ccbabefa6735fa094286a694ea72228d2c21d4805ef19420b9298d5fe6fb37070d66a35327b41796ef0e831691b97825d95c41e9ca428c0c2f19a7fe30aeb572e3167f7e8510dce73d612dac282aba4096d7033f956165793fd4838218cb26c674fea8a9c8523ebd8d9cba51a433ea4b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
