<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a5a3e5c569343a72943cbe918a4d8627c1d8c7018ee24e6977aada81d3215939e8c83fce48c26c4d252f2f550af93e7033092bc13785433f86ab0eef872d4e14c43fafb0c766b35f91b46a76ee556aa1db76b2c51812a2e2a9d187808a44886aec802558fa408fd7d3c04c33f2a705e6b5e83881ee927ef73f76d724618e0712836ea343fe5a6461a8d20209ea2ae69288bcc3a451c30161147a816ab6de2831d70339dc5f4f7c948754020e22f437e47a90e23ffde1c8d3bd71a65d70c05cf705ca38c34c85257929f4c917ec56dbff3ced97002be0d1992cfae43b4e6f14c22ae8ae5d19c37674c29314d839bc46fe1ffe9e760f5c70ffd8edc9f659861505b161f469be2954ac75206929e8d359a4dbb73d5c3263c22e5a4b82751f622407ede0355970091074b266579a79fd80c521faf36268e06fe48704d3a913fcf4a1dad5941105f18273ae648430faa0d4030e715403aebe1dc05a0ab82d62219eec596e8723c73855b3855e6ade74f43e93cfab732951e7514b1ec687055d4fc3e22e118688a1cffb369786f43476c11d036db7b8215ad470dfc63b78e1ed401d1821b856a6cd1281884f5d146ff1b964c78dffb9491b7e89c4e3427484ab6c6407a0b3e7884b1413ac39c5f93205c9ed28655fb3852d80765d742d2ea562c374a2c805ad925608be2c6138b38627f27cbca03feac4069d6a1f635802ffee076fac463a1d023f184a6da1deb7a4ff5ab16223cec478aafaab6f65ac6b9a63a4c9bbb0c7e94aa2a6cb8d58d1cf276785b1b7a6a2c6ad4c00bed00a6e6666e09438848f27a3bbb9b53a8ed7ea98e8ca8a45cfcafad42ea61687613c18c30a054e293332d3babe45e4e4ea63cb3a538574ffefc8fd0758469e814555b4bdac8e27e9ea2b0be3875566d1e438b7bad709fc0ce7559bdd8dada5e408019eb59d0825f02f16cdb8c58206146bc100994412e4cab60361a331d9e556157fd2344401393975dd9bd2499570d5b40f9b6dc4304ea1bdf28ff8096294cb0d214bff84adf7f98141ed494d01f53f1ab1f252f25fa9f5a7a908c614ef682abcc4976ad8db711a6aa5273b35c6a647eb52bc3e3b9f1d681122b0f0dad4c81d34cecdffc5c3ef05993416f238804485180316dd8787f2c6fb24fa93bd78839ab9e6ca26a1eaee10aa8bb12965cdff6a002c3a33e15d581a1c2ab60fdeac2d09bcf788d742062d607542e669e1a1c2bd01bf44cb5c14335b40bbbaa81cc8f35d4d7f8c94f6515e780f34053b91f096c7d44f48d15a5014180a98806553a04026d48b14d3d882c30add06e500104b52d447b39a9b43ac6b7617d33b250c1eafb6b6e898624f73d110591271b92a64b06c2644758b24007b672afac88dbe535cda0aa475d6058221dcd7164069c74460073c4e601c99804c81489cab12110ab82dbe9cc01014db4dbfddead8730ac84c3559c6aa75908726c3688aae372ee8f9bbfb4f6ab5f7585e8f3a5e5f0f5a21d32c478685e7e172f7edf888f543d3c81c4d01d94926512951577c51d64cabf7d360edf98713ab4f7feb1620020d74c76db14fedf6678b940af369ce9ccbb256ddb8801cd683b1e57470aec5e0cb9345b5c28dffdab55f6cd86a464f01a2e964a1ce45c94c040e48ea28b179ba79e68150d4cc5af29fb64232cb3ef1e54e7ce731c2033263fff18f1ebeb0aa332399979f62c31bbe3050e4eb57bb6face8d27d8836de995fb11532845d3565d64f227783cd8539943a34534bba11878676e58197754894c48b1818d830136a6af43ca707a5e9ffb0240d6b30f4cdaf4caf3500c212f13ad73921eeea8416d31b18a2cdae872a4dde35aca3f93ce2b69c1cc75d80c2779929b6b2ae158c7d490127277fe74ac36bba0590269bc06a1887da45c0940d9530e2fa78b8c682cb5e63a4be0326ae5d3612d115a082ccd5eb54caa4dedef618dafce02b1562b8ce4d7f5fcf270158ac0193b95a282bcb0923dc5527334cdba946e1cf3e58c4d01ad151a6111059c2c31289a59e429ab3dbc5c79c7447616d5985d3f6495f2d252b96175d7ba94debdb6d4ab40fcf98fd743547e9ae2a95448f60a6ee2507407978aefee1e31ede64b5c21f99ea89d71d6df4f18b2a38a181fd9bb2563f27d6207a345332e97b4ac35f77fbd91199d40ec39220a6a6d8f58b8c47bdadc5ba4c05a0fd5b648930c11f0b77a7cd59370df50b52a04f53b866a2f8d9265a3f55116e250fa65065a7929ae0a40eddcdb0ea4feb56200f6204694f60787d9b6349e3a60eff4622a69a6458e4e251698fed2d68b165a73f078bd47ec6109e47dbe67b2b745e6999feb5209221f733881d31230ca794deaa9520f179b38bb9150b80e9decf3daee13af39b24bad362257306eb591ea0dc8564270ded41378d7a824d9fed1988c5c1db1c079482a946f52c40d904a53982cd5a6c94695b2bbf74ea34261709fbb2ea833b2cd2bbe88d6c746a46b94aaf4f530a2d46d75a13b07866a45755f0e9080c4fdffb2d770489f86fe28b8b61a8430dd05e871f0c6d30fa42384f76627929721e3554536e9aa15fd1bddb0f626063ed9060f2527eba298668e7a3f30338a48fba4c04ce6a608e88cb6ddb116bda08329315a2f0a6c12c0b00169fd0d8df02b0f689b29f1c8daca92ff5590561ebf6e14742f0ba39206e15cfac353ef06e09771039d07fe66571a92e7fa3ebe104e2e72d3ee12d9970c1c1c81fe36aa525de23a7330fcd10ea955b0ea37525ef257b3ed5fd25067b21f1aea9dd3de48caf2d34efcd39b08240cd6a41a429ff2d7fe0f8a4f1ee7af4b6a95545ac362895f0a7bdfd3d89f4eb519529d8fbd0fa59f456d5785f698698dfb2a61deb14aad09c552891b4cbf17aeee021320976e9efc64f63ec5e0af8c0dfb193e7abef2c6dc6f15574604ea8c1fde66f3553c4108b4dd6186a4be41be31c68f82c2447249722a16e84cc0e5974c9021f389e37d72ed916ca50299c5a62babd312df762cefc96dea0e6f8795c5a1e1fa0ff0b6e29c79e004aec071d28c91edb4fde29a1e6a5f4835bbc4ebb30f73461fbdd6c1bb1a04b3ddc40ba6c72ff27c6bcf0c77effbe637970005368d58c85aee8b1a5540fb8fba7dca9b8119cf246cb6fe48ea605c69476340ac400e7ae6d0542714d8f502dac7a4a97e5dbc7f609a1e142c87a3aae35392b615a8051210dcdfca483890a84a100a7639d51c9a372b5bb6e5239c3745eb0471252b2d7757a683190b18ed04bd08849e315266c111f14ee551c2f65e4517e5f3e1bf41c655c1cbada8d781a2355f571e7b7a575e98eaf9e282f0d6181e13dcc928ce8433f6ecaf93aac97e7f7cf1ff8ee3adcfc75cf7ebea2e2bfbe3d5a1ea24c888cfcde2735954e9f7be406bcf899bd9744a721fce41733524db3002d02ab18ac78a9f9d140bded4b303ee7c17dc0200dcbbedaa8609aad369ffba55c13df27e8262e37a6194a0a2a8818520759e65940c6d9926b42a0574fcf2279e3ea1724bdea72af3fa888cb536adaed53364fd051f8544ce52a60190a0871efab6a977d74cbd4146e13157bd5e335bbefde07eae32313e80482853fabc70364a51d853bd1c015708f1620557a551054301a6541225bc20c8cf0ed1f54cac5b08878659993261af5dbad03ab2b5e83743e4ae848aeda0b602805e00fc4f6b7f3ecfa281b7a922e1992278efe994a4e7bb19e0b024fcae8ad9619e98ed20ecd565730a802cf7616c38fb2b26911a66df60a152886156f32dac7ee381f75e8db2461320d9d033eb5e23e10fcbf11366ee7627754de4084bdc0df459c67925b6bcd23eaa2d517bed96bf538c547257e02448b7940f7a0949417a7f7b3531d1d0e82692da98cf7d02414a6f60c24bc46f97c5372e81805b342d726b4e335bb90a9d4d07e8f9831cd1ee99cfb8f0687079869db8372e59af4f49ffe0100fa5890de50cfbaf5c402bdb7bb38923b0c48ff8babdfa89140a1b0d68a9aec535f7a70c2709b01a809f4cdefa2bcfc9ba69511797c673b407f82075b49c209b6bb568d0f14aae197d5bc312b7dd78f4a9e81b9a5f3ba88baceb60a6fcdd9758a08adeaf7a52f78f01f671807d419541795415942c92cb962c8c28e0db35f316ed163382ca28142eb610db523f0cb20899a3f94768b7c545241d95a73a12b0533e8b08ef06a721395a7a950251ca471ffcfa7dd96b32f22c8b332e2bd6ca2aadb738c7cac3486ed697d9e77008f61c66a8b71b6819b418cb90bb5ded3018dae37f7c74f42ff65f6b10e5c723982a355864d27391f2e7228359a2c5c16e9a1e7854ca66863c0ed2e67d1c69f6c94711f641d44b491b13be603baef730e021eb2dcb795e8c7a397c716985f60f474579b11e977fc2a61c034d41554968957c6ba51ea30d4c62002d2e999ca1b18838fe3e46e4407b4164c2cdbbb60f1075ee0eb34a64ed4da1c113263b1a36401b5bfb25ac03c9ed3a638992a6a20edf6856104e407bda558f6ee3e43d6627db8cc2207d00f2fee5c45c9dcec37ddc5fc0b6425615a504923916ca9766b090ef2dd38e0d0b2421d25fa0d43d2e9d9635d83691b6d6de428a8c98a7dfbf04eb80461ae43b1bc85b2e5b0aa3e7c01a21ddcb196b7d45e986dcf9d804ac0c79a1b47ea3e96c97ba068c8e9d83426538c593b420cf1b5b0e425d55c90f0752921a0d5deb7fe1b4a1aa0b31330071baf1d98253adfd30c871ad96e88ff14ebb93caa71e362f63e2d12f74d9f54fc857c2eb4b7cd15f54a81a347a38fc482038b2233bb608cc2e552d10c43dfa13aed78b9f596435ee6d5e814bc0915b0d75e40e29e0438dc2e415685ccafe0c9325cd773eec55c2396cffa50b72dcefacd80d94f4dfb982aa7b1256bdb151f0b20f22820ba2d424dd0a41b7aeda7ddb139c76c82e36e0ac67acc233168d5b85f366177b6a78558f809fae55d655905e1485be03e68c5defd495a096e40e8518374a018e55a95934dfb605731e05c0d058fb7e943522e22ba543619b4a4b5af24cc0040315e4689c71ceeee875db5cd4db4d99ffe2129dc1e190fb41160659bff7cf3511d37a3da293cac4044eeeec77bb4811b4bd759da48c50fc2ceb672d50d66d309d90f1358d4a1c6ff32834b0fdea1c8630c59f397879004e5eb927f14564b508aae80403c5eeab6d85389aaad7770ccc68181af621d39ab035cac17967bef1766a05ac0edaba4ca134e754967561a29a5124ccf71ffbde2ff12a28b88d16bef9034145c90b1069ea689772fcd2dd6537a8ab120f2b991d47e234d019e69fe38e4321e4949833a61fa5be040aa57668cdbf19091d362abe867ca8c730d24fafe7b97f8628af64834f953cca9e190d3c4ea8e98d7db0eef754144676ccacad24431087027336df3eb601232451d6230798ed201fff627818cb229ecbfc9c61639958ea8559a1a219d5324a882457e629ee9912d82ee4d9148018670838e3662f47ea610cc10a7ccf695087734fef98850d92a3d5250f2e3dbe17412b1e919381b53f43cf9c065273e59558c479cd47d31da9e2fc6435c41a4321bc67682255de327bffe696663326e7df4acb4ddd5121e377aac64a95c6a2697dcb544680b510c746be7faf0063a2322a738c02f2873c9a76772e55d7849ac911290c20a3eec8725a06772032f79d1128fbcd0d03c54bef49538c541e0920e12fa2fdc83e685149422e716fdb853a514bec1575d5fc047b3d88e5f4043883b0a14673b79deb4644ae3a73ff3fb877219694d2efda174c5ad9270accfeb5c5f7d176b7bf7dfaba58cec1c520dcb83496b31aa3a161cdc00d088e9d804e4baba3ddf567edd6efd1e5909c089438d7b96ef53e543a4ba81afb8a9b764a534d14ab559d0bdf40ddc837c343fd4bed91613ccc67cadf4548dbe674d15d3cd1e73a89fe4e726bc7a2915257b0ddc3e4eb085217ca420b908a6f387b1f69cd4d35ada44e6c8486faff6ac79c7b9e723fc8d327d7a04b4343667f76d7602a06c641917bc15005ab7a7a7a8683ec1bd7325dbee830d419e7839e10b3aedcb4fe35cb6011116e088f9b7152f9288396ac395c1566dc92b44e2c068ab63d29aba4a4d4f59cf37ee71a2a315ae2ada875149194671a754d2f07757132b089667cf6a482a5bee2e1276573309162bf85c9b1e9d657e04b8467ee1f3911073ab8a63a36336163b390bafe159c1610e8ed2e861cfd15d55cc9ee467a3eec6c1882fe2b7a57870234c75879c49ddececc226a4257b149ec18d161c65273e0acd5fba86d9e8c47c655b4244bfe843e3b8ba8c68105eca68fe5ddf929b686af1fdb93657bcdd3525c3378c33a18a5eb1f79a9e322dec11447103bf065fb9a205bd5603d9e991235ed326f2b3915c27f9319bbdb18fc0741d4c4a69d0989d5a1b893a2734d6a0ba177fc8745863951f28900139960e8db2d6c64da77e8c74e0611db66d64dbc7216c642240752ae6c543db27eb9f65cdf2959dc61ac1e3446c6d7e0269c5c2a87c64512d6fa3a68f75bdf56bf6ace267aa53df8e342fb14f1c519b8788f2358eda1adafcb4aac18baa745606a82a427570c4eb83c2b4f927bc6eb2059152bfcf7cf16359c2e1f77d0835911a7b87e7037320107d2f0aa61772458443f3e4a27926307ae4790f92da3ffc7a9d0554e6d2964eefcd9eb8e0d3248983e4dde333ba14cdf83ffe5e7b450369cf760a8d21e7f8a6cf18f01e4372d121b98f927f9603e42d074a28471a2105445210e60c68dd5c3540e87d4d9bed73d374de8cfd3979f1769275fa32af15e8fd43007a26e68132794e0ec18bfa7b3ef4e96dace25f2e0af3de61edf650f3e27a9a6145c5a43403b161d2ae5885bbfb61fdbfaf89ec943cf5082a0a4146929b5f7de949e2f2a195148a2c6c4d852f8b165520d9b34df8669cb6ea9ddf9e00b69993959dab66bad509001cca1c0aaff8960f3d2395d37f55f770525e8e07f04e17e2665b64b660f0474a23ced4df2122aa06333ac9441375b186569bbab17fdb3691869b2061a67321cf8e965ede10dcd7b47238722a51dca285c26f76c5702474119cc477d55274ebc3c3de9bde541b9ad060b3d84261434b4c8031c24833eeb0d39d7962164b9d3afc4f0f57520f41c3a1a79440bf6287200e26dae3d403452ed83490594d5f328a99421b4732d605fb13784197d9ec6530f1d9fd51b551b6a49f2495098e0b20a8d55d63362001db5fbca87cf9023d13ea76394345b56be1cbc87aca2221969e202ab9f74dabe707ac7431ab278faca5cf1ddc77feed3c8283d8d037f3953cb06d03212109fa8d0af5ed2e45ac1277f39288fbdc6a59b16aebfb8ca6cf3a6f8ca5048b69baa8326d94278382a280a048271f8e2e0ee349cbe9291077100972a0f7e59184e38cc6cd3fe97988cbc51887baf24f4ca74b95bc6a6ce4cb5f289d4a52981cbcd1d1f23110689ae49fd05a31a26cbda5f0571a999357672134ce11c2f02d58ea34c8468f0cd06b356f32516c7b9616ff0cdfa8a5e07f7d6b23a50fb332ed0b8266e11a6fa0ed0ecb98089bae5ef526f83e56647de6e004cf03fcde3a1ef53b70aebd5102d34a75966d37a8a2f6e74a96a85117c5dcb941d62ce6e6ce8545e273f01774d5c54864ed79fd1fa568543beeba8b632e93de7a9d1f323fde2429c4540062111fa66c04afb8d1e8d81ac418681b3e81debe33227f845a7d8e12e16298ff48295c4f5d9d9e2a850b3864a03663acd6de8b493f7b0db94e092e1e4e7e552d71d8f68ed13767feac63c8cfea4c3379fa06f78215cb3953579d378c7b82a34de1a27e4ab107b0df5d82074f72985212ef874f5d973efb7f1b47bba29d19214d24d5f3988b637bfcc4d29f12fcafba628d7f27120f77dccf918ba74d111654ae5611522c9435aa4dd1e162ca1d1859acb0dcfe5e159100ead1b24f29ed320802b001ed080ff461136e66c0c93e0f3d2999509b507d9f83aa1ded5af2eb67da0e3821670b38424be44bcbcc4adb250de243fe86ff4826d0f6f5fa01ed9f5ef856b441ed37a84b73c0955f7b3a9f7c4a6ab29f59ddb5925245fd779b6850e937b21ad4ad8b4121ec5773554f72588b7e17513042791adbd2e7a857a066cad85657d7d2ae30191300aa02a8423eecc0b120cf64c2f1c6a14ad047e1fcab6c32c6a3ef991af23560bdb7fc5613f1a71f05ff02dc89816da9e19745f9ee9a2cf1b346e3eaab5f55dad13ff6859efe80af2e7465462418774e2f93f933c3be759189934e415010e40dd71dba2f7c6c9a5a901c679dc0e97ede3e06e321f496817132400b57eaacdf3914e78e626046e19d05bc70afbc38de6619fc9ccb0a3d0f08601b088ad992e6662e95151e5ca4729fdcfe9d2eebf15202229d69d29d1d5c430e5251436fc0d938222ea9b680648867965ab3dd24ad8109e6a9b5f09b222dd9b8a39c5d68d2b8a8b35c52c4867a01dcc2e1c516e6bf85129678191b2de0e7f0acd38769115af83a3aa15e802af9fa25abfc4cc3172c710b65540aa7db1e22addad7a86468a05ec2e6dfb32ff44b315b1cc1fd5871fd6eca154340a6ce171637fba8df88f31095010158e4530a48ca00e4d7db14be1600275397639dd237b5a994a1a174c86edf37c8adbf89c091ea75a6f9fb5485ab6872a1be6fd30cdfe9cf45e06ac4bfd9c15af335c0fa596f0acd062e85a1257ca613bb8fc12543f9c2704740bca63ff7c3c381ff3726729fc84eaafed46a99646c99575bf311fc66926e5df320e4465f767fe97a22faa0b229a06bfbaeb3d326444ed973eee16aeb1bb84b1c20873d09321a16146fbd9eb7ed4f17c941cf9fe0bc31a0ec0a7c7822cfd1760fc639c92d0209ff4f8bcd68a03c4fa9f60c4d28614cbaec566b86f72138487a933367f81edad4056d5f7bcf7870020c42b253e53e2b1075b8b8fbd5d2ff8433c78b8d9b09298a0d3c0d2cd2f219f0a892b5f6c69a4b269d14593f9468bb690d56b3254fe2b5a8beb4ebfdee559667d13baae284df86dd20745c40a7c52d3fb6ce29d7bbce68ace6c8115e444d214524f04f9913dbe0c750c4ddc09a0a965ab5a6c71571a02c2221a23f32cc9c6d7ced3b7dd010defd8486d53b80f1a16e029581def436eba88c59f77fa89891703621a6a5b93e4fca6e15cd0c2ca388d002f30ff27db495f5d5869255299f56f89375296a9f9d83d9ea8d87bf991812f7db6426b716f60f49afdd1844d044c1d26da42a9d9883fecf82e5c026835606ec1bda37b0b15e0dd398e30144f020a7d8e72b6410741879b2e713495f2af2953bb1e316ed0d17e51abaf6ff0c7c41c29638c29ed622fbb4df84934b4d54db6899da1e99e9d763075ba33eef2f828920eb82763e36470475886a763ed96b2aefcbc03e29b0931a20f0d148c97c411d1b550c521009aa063d1743b68d8e6766272dfbc74dba1e95b8c64ce4c7154724999d20f851213b1626d433f7fbb12ad54ee10183c33f5034d2de098da7faf4977561c59bb1dc3431f668522e6abe15c5993240007c1d05ef383ee63089e14b1bc20703b33501c88db507dc1ad0e7dc57dd7b61af476863f86e86d91e23a2acb394b976de6169cfded52689f70bf490d73d96928d3e9dda65cb75ba43b56214d340425a88301b4bf5d1d2984bc21dbe86042f993dd313d0642923c888891fe46d05715184063f6aa42e8e2b28387483239b823a8501af18a9549ca2fec9f8980efad9f5b4fe48c272f19e2f5db3e8256a9bd154cb6eb247aa5ac2e38d4802c9f2712ec65d824abefb788234bb317134704888c77723ddcbc5163568f2d2e4ae1e621ebc50f7677c76ba8df6d5c0e59689d4e8c474ddad8a44104109ed422e55ca99251841c88a91bb96f72c1da7669e93aacd0e0a933f8115df50e321ea5a9df2af0384bb379f89a976498cd4240fce8650dceed3dc42c237db97b83881b056c7f530f74bb16142f65a576e3e5ccbbc8f387017cdbe29e66cd9c4facb4478820b8971f2397b74ce54c148f7af79cef7037a9440cbcc0d227d35a8a21112ad2044385a750da068d5784bccd72584d34fe7f5cb74a5abd788e2a50c786d85544d038863d4b21fc05884b5a3a7dfbe408deabf39d5c5157b5b66b9f1d3d3a847a0c1a8af1087a1c474771bbe3acae9303229fed5bbf0655ec7a6d3056173d63c47ee357436d44f8ff46d9de1c6fe602cc1a921ba5af9a919c1da6f951cef2f914bff9ac8d962881f70cdec7bce9672e513a89eaecf6f5dbb422fc1e546d674f84e599bd137ff97796769eba25c220a3241ba44cee35a557bfaf36f194b1abc49089c1de5c71cb8ff3e9379c74e50d7b6108d3f9ab68bb22acac4ef405ac358f9504d35f05c73c64afa2f2d69b3a025b87f64f4c11ddff590365cfc0eb6dad10fb08e117df31d94aeab420301a96761182aa2b729812d0fea5282a4ce4c6e59fcb18dd75e5f4bd64ec9463a90bcb9d03245d0d51ca3ef5a980047dd7ede82a19a21700cc1547a9ca0dd026ca2d359b7f290829ca728abee42175bafdb9d93b746f730078586db3a3046a51d39e213f5c8796cf9375f846ead8955ec93e4cfe3d445541b00c4c27f0051447b55d022b722437c193c81562ff4e007b06cbec300c67530e7b889afc55f7cfa631040783d7864cebd0281d660d13bb4c61dc99bcb99b44f5e12b65859e510a40c6138be2a228534afa649738fb3d2d00f8185da3793b8bf64ecc65e4f81effec80c5233b8c889cf04eea2efbe495913779be04711ab96a1ff3fc908e9f3f7f16436a12c4becc529b6d96dcedcc53b2b7b2284b67d9e0f0c0df7ca1fb192041262bf7158a47ae464e541b80490711e1d7987cd7808b0705aff74c1d415f2efd9046a54dd469fe9caea3406419dce1b9a7ce48e2bf05ba43d03f68e9a64123751efa1818bb60f5ec78dd59ff08ed50744b293b63f173774a79d0a8f79748d851c22774c48e964b8c8895b657e4bcbe8ef0f8998666a34cff7e6f38c6390e26df6ba5a8c53aface226d77addadebfbaa84ba6fcc5b8c287dcfd9575404f437f57c32c228ba3c7c436112326054ada0c714366862f77e1345b591e979dcb75bc90cfd11853599271cb82f3a9656fb52dac106b4eb4e18ae5f6b057bbf57f01d9ab71532fa8b8cb9ff9a5d68237715eed9560ee073af6199d254c941ae11561f729d339435aecfdc79ed5857b804578a5f408864e7393913c289dbcc5bb1ca1e409ce9931da67e69cc6c96100ca9ae0c8af8a8289b0b499ba2ccd4580cebd06af11454c72b703ef4e8310f94d5dbb84fbd66e43f0ea398a1a6f5fce0834534bafef34d946d4fba71d31f5f7261d7af669cc40ed71623c8e49aee0b78c69c6e2ea6967c9e564b3758776f3c5ea47f9142bbbed500b3b5ed00d0d29544ca64ef3c4932b42be0c61b207e9a575508ed14925f4b39301b67a7748ed31c4b17ad7c02c3a83ebff4b9b374cc10994bcb70642abb91a834db01b803229a4e7d14822efded79bf7889c3b62a497363a2ef4c99bad2dc0306c8456b98fac25f626be24f2addcb387ae234fb2d4bd4fa367705a0f21c05e891f3ff1b11156c5b459aa8735d4ce17bd378aa8f03e2cc6cd86c40017fa1caaca8c95f8921edffb9c9937b0acc7be3f337f52761f87540d2819887b2b313223a8cee3d2ff95ee53a788051db138f5575ebadbe05a51356bbefc5f6b62383cf5d41d31546158b991119127b16484e58e410f15d9bee06da853a88c54eee5726c83b7839e5edec3dd4bd20f4c49f988d8b49bab823493fb783cdbbbc70f9227773ece36e6eee7c287113b0355f28be72c290d818708abc862f772b45feac819592789b16a70f627c749941ed5a691e44e9f6b3ca7cb96e6e93d768bb3a3a30b82d42eb2aa5b5cb615959ef4f3b4012da4cb38d6ef50f36abd2e7bc0337881b414723205a133b2917ac112a2c42382f02876a9e5c587b1a90e13aa961dcf714a3de25287fb1bdad1a1689bd9161a4166294820cdc596c32ed998db5a510322136898d72f4fb7a0b7f5a88fa03470c272a04ab949a5279fada6ab5a8793950c008ece67c746a6d733159d3b7e3a934509e7e4c4e7a107fc1f650a45ebc20b69e05d36a67f09a27726c2806171f6d2bbe3301e08d886a084c227d069bce8b1663421d64470b5ca0ab774a530dc35d9f9c603cd3f9d0d908b298835b8d70ec513940d03801663a4d4fa245a9505f453ac86c70376d90f28ea8b73bf221bee0781f7672440f28c15efa596bcdbf42df817e28b1c8927ab758c0b001feb167698a1e91d5ed7c28e0e18ae7f732b1ad863df8cae90b75e15e1717c3fa36cef7c0af8947c8a9d404d7b477cd0d070f943fea85ea8b8d94c812d67e8c30c022672d51998a5b1733e1d66d02bdbdae8c32d356bc8855bd659785502b58e5014a78cf73c898540b96af27fef91d779308185ce5056b6a14403e6490a48325a008c1d5acbc5db93392cbc3bd628668b0c4ac1398cc6e380fea4df3045abbe2826bc3ba30820cf5681279559b7623bf315cb452c08799a5a21d5f6b888d8bcdf947aa5055e0325493152da5da41860f2678d3c1ff50c0c02a5a12bc8da010d4da0aff79ca4904c71f297ca8ce459148ccfcb361cef1c8028fc3e70ca8a337890b0c6cfb3e58eb0e9c40189ee1b7959dc66965c0ff6253d90c53ae5d3ffe511820967ef29b289506fce1b67b3eab1760acbd615fafde2cf667f2159a6dcf69b46ed836865a69c8a24ef669a55e47a7b8c1ef50d14a4f015bf57d28fee210227d2c8ff1cbfe9a493603fc39b7f23daff69376de74c603180a418251f74f7071073d2cebb8f3cbe1d6d25c604257468971739e460d16d50743540d0a32bf307536b5841938f6e6f4eea5b41e1b20b62091a150e49435c02d1f783a200181c30baea6343937fdeeb6aaa519833c38edba60bc97a928f7022846a9c9321c7ad251804971abd65f0783adfd4cf593e2b51a6468510be6947110c69d834aeaa852664ef56eeea8e54dc6a7ad0968a02f1c2e4feb4a2c8e7d2a996521de447fe79bcd113c86058a685758c14ff6fb795a6c69af7aeef4cac0c22e314de0ba65e1387fb0f38ba039c5091c595dffe98d56b56bd62cb92fe1a221b6a37935980261d60cd48e74e4f5b9cea662ca6e72dbee814c7f93370d7dffd49a865c9c417f729090be1a047e45b2cea9b494b4877039158d14f28cfce143cff351c8102ed17fe3459e3d8ae312487f7d056e4a523714b06cda7daa1882adbeb969bab6a5a24697664998486354daeefcda521e1dc45ba10c743d74b41c409cdbb47017380590a65058e5421efd0b0c9ffc690886fdc24c0d9c9ec7ec1cb19574e96fc300ba54ba029ce9432a04a93e2f64d536f5b9f747873366b9bc76f99472abba71c764a8a6240e477154311814257b5f7b1840bc3474d0fe3c7e0fa608925d1524f23d27694224df7ef5986898be6421fcf5447c68810d58f185758c41794ca2700c97ea14e7dbd07a65d1eb8479562edf5d57c502f4aa5ac55a22549527d523d039feb67b0bdeede55891a3a01722c34dcb2da86e473b360b5fd8453ae444ec91751097fcd40ace1a00852c2587565598d0f2adff5af301eb4afa2ca5d71bfac5d95ac537c3a787d6ed3f99bb15d66ada5fc6f062d6af6631d28cb78248c4ddd591ca85fd7b8067411c0b538b9ba1589f6e3d4166a9194887b8dc2f004cd56a57e21186dfa0ec2ad74e245b56cb74c2a314c9cb2d0fb8d98c30c1e451c1d4ffdf70c8ecf2544ff5d894c2b06c7637637c03f3bb74989868f1c8e90f57464b2492e66ed9c83cdb5f99afb9b516bfd31f923bdc1bf79782689eb987fc3e6dd9858854b955e1913cb5cadb676b35562c5681cf99bb78aaeaf3c8f184b68c326b85f257d444faababc572ab0cb2d903346768cc4c55366c7c31833a53bc9d8fd6612d05267104d66648d83ee1ecdbc3a25c78744ebf460b959ea87d64a1afadf62c4874d9694db77b22ee9ea59c32aa3e50051f879a89ba94a09708e59f6c52de1a7b54e235635ddd101a607f1e8dba21b9d810f38038cff6b5595b015b1201d3ce30a653dc2329469f5e24bd8150d375447b449f5ee15052cf5b9beadff548f5f2e71e8c43b877906d67504718486242824417c0a69a556d8acfabae0e57d3d21c1dd35985aa4c4c34ae4678dc5d5ec2b092caa32d75c874b7a572f27c7e6e0845493d827df9f3427ca9c970437ed831f5fe6648cf535e62dcefe44c12423ac03f62004ded297d4f73695bc8f913c647c258dce2e7a73fe4179b22d4c30f72abe57dc1a6911811d0f2d8a5c6652ece65ee5dcadedf111de00db19277da9acf85286370d59322048cf433ba9a45c84833cd4e62d634cdbd5e35c9360705aec046216fb3d87ad010785eec068cbaeb49da689a9e206e81bf9ee4dc9ea9bbe6455618059eaa0a7c513a60f9497db4f2c700849ffe8ef7b8039d63f08a0fd6c5965a0b376f381051cb0d87bb80a880bb8da302e8bb53c2a5f76bc6c3a2c5be9132a61ab63b5d5383f6b34f5c1cb372d03e0664123401a3bfb69a8f3810b8fba708b55cadc7756bab185fda137722e8b21c44d9eeac7e2d3c21ae35f57327a1421e7d8750106a68356699db091db715510517c06996ea2421a946aa34e98a048268219bd667074dddc295ca22a8a077e7bf5d68d6d844cb8e286e3a8353b6537b5559e468eeb03aa892641e8f057197d129a4f3127a83089997877e30ef432d4deaa79a7293f8088161103aeed0647079af32351d7b7c00d966d700514c561475b4a21a139540e743ead7eb392d56775a5d06396a640d685bfb43cc275c9b8c6213572ccc94d647f41fd12aeb75c1de7b9cd2724379adb33af5d53760a86033643bfe4dee3fb7c5c8893f4093fbfb840a0366fce84f7ab2109ec29dd47c7efadde26da615110b8f3a232d4a53a159513af294e03925299abad895db6b82affb2043155279e6944dfee9d4de1d6835355aa9ff20549c33eb24a1185a56419d63a63816ee223b7a050d9a8550d5497b95448d101d0feb413f640aede310ec8188558c3b3eb1f40cd47161742e23ef628d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
