<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c8e9f2adecce3f6db77ddf90acff91a2a19fd76602c3b89dd6fbcbf9e958a71dd1ba066cb6297ac5b7b6dc66528e2d1bab10dfffff1ecd8e5d68db02f4cf818dfaef3424ec32279749355ea72b9668c4c4c702cd3021b10823775f2bd7145733f82f31270f04327528bd99b60966a2dbdb1950a2008964db28ef5b17eef93098794a55ce991a1d6a896f3ca97b1b3d630de57b2b80f10292a7e02df9aa94c0a100571b5d52c4d228c46c434e5bc6f5a92cd5bf56045e9091d1e15e41cf52942ccacf4c67b4338c1779efc393944914f5588f96d7607625c3c473808a20e71f3721b0b8f3880abf78b13ec8895bca608f72af374b8084fcf542a6707954b006ab7d500d0f671eb15590b69a2752253f35fb6882e5cf745c772e688a8da8ec2631887531691d0ffc00b49673e8f781ef02bd291999c6b3d6b0d4e53d9b8c67534c7403d9f2d594c12633acc6425608aa2d57ad8fe9364c383db1b697870813664d51429ae589f09fa5aa6ee938df6dd6b193c7da75694fa7afcbed316950c265f9c6c8d16a1ebe90cd2b134b91f0ce73d41fe92bb917197f7af92be60cf767b01a4df1d1222272718a36811766031a21af04dc11a7ad3041fa44baa61e97a9ec8912516aeb507d11c424968e9a879f032366f2562e40aa8c6c86fbfb951bbd14e3a42b32c08907210a9293e21c04068b3f7550be56c4a03f5c9c91b6bcb65c52ecd9f7c8dec1c506b860d9f2fb5a2a9ec78fb24b1f875812370f52b4f6ba78632afe28376f48b722fd9e6d46760e978ab9777d253c911ac09e1390363210017d1e28f4662153ab2646c63d0e84c6f8b4388d530df2b30ce32ba2756455b4f95f59cc64248e5a3fc07ab7cd8d779b3d2ed1a5e8a0084952dcfd23dafcf3faee733046545688bdebf1fc9f0109e12b3c8c89c57e9ec914bb9d057d1c35fff9ad719d222bfc8b0ac66047ad6532d0de00cfd3769a316d214ffeae90e9519225cc85fc4cf1270ce7ffcbe7cf349f20fe9e28e03df894b09b9e2b87d5d7828eef7d4123a232de37a899cd389dc97e0638d24448e9b2bf7ed2778587f1e65440b9ce748622694ee44819b4cf813331ebd64e29b7cd3e5f8be0a9882b8d29dd6eeb438fdd9e999b4b5bed5012f8343da553b7198c7818c9940f3c00de7aa33239ad79dd658d93e7ae6957865859abdb3d76883085dbb1315600168e6db078420c42ed3b8a2210c0a542e0bbb2dc5ad665b01e2f4c0c30df854a7c7e893836a0fa604351839cebb1bac52b1d8c5c900f03ebcab7c712adc40148c3bc3abdbfb58b160871997733d1985410d84ba283bbc65a0b7bdc2a08bf6bd4a6440f98edd86dca25472548a3fcd6f1d1af862fbeba34a6a37b1e5171e4bf110083021f3f431aebcccafb4fee707e992a5aa9263a654069e3f9cbd38f2dcd7184c96ff76900ccb25f15c7f7bcd63c0d487a107e9ac989ffbc954382a6dc3c9973aa2ef8f281e4cd96fe71c577915e895e7cd5467e18a8b0332624e26a5ff0fd64f7542c1af6071b8c77de62b6f3e38949e67811243af99e5c4730f6c964b20f0445920aee05e67b01aee6942fade81bcf236cbf76167f9986edf0b44dcc105d8c7168c1c9f048f0c57005be09552223b9ed12819484222d41c99b0372db93405e21f017b345cfc4fbe3bc2bf3fdd5d64df89cca899119a9c790dc4832f8e4fd35c78575c5329aa29cb52481809dcd49da48c3ac78b8e331da0f024e85b9f055f25e6437f2175847d422b7a38a921eea7ab240d09ac90084608bb3ce6200b646b46cf3946c24ab8e9367a033e675eb232703e7467c68aa2ff70e7cb96d2e226252a06d397cff84c1ad0e5ff3873f42e02bf5955d47326029a092ba2587fa6088c0aaebf7da26b6d4ef3ef07d7d840261ae2ddcc7748975519378dbd568f219a691270c61ed8c83625a7788dedbfccbe0b42498379144dd0857011de277657053e7e5a2388400011bb40188af9b93fc944126d9fda6445bc4e5b26041a8c1eaca44ca27a282c9ab8a009486385530e7bf90ea46f0db267b745f004264502f7e0bc360632df067f0095f23669417c4935ced471e1b638272c2a7f672c0bd9edfaa496afe644e46ddd89d34a38caf597f7ea30d41379396c4a9e3d4f7b969f31c94559a4f91c5aa3782810a37c46b733fd870d31a0c8fe8d90f93c9206dea1c909e703e92ccff7d15fbe466d98f216aac5b3a5ce36b1c0d2d065655bbea3a4e60189e0d32dda5c98926ec8108c972c93b1d5273d150dd0e756a9eda728b405a162757693b084caaa018278178465f866ea9e25a65f3ee08e31a3997d1ba39cce31dfc1cde22ca9c2f6a66eeaa158fce253abc76c9a7149ca4abe11e3a7973305b52f718936c43b28785520a6c3352a39e3012bae9a6224c3d370e8f352332e1a02ee5cc94771d41142da1af11141ade15208d3d70a4f557a3c8b7d633de2f25e126d13c04e323b1d52b8761e4b678b2267b235e6022f89b89392bad81d462a020d48f614f52574595c9c45f1c24fe3b696f473bce6743e8898353c90378420e5f87ca232448660457474a9e885c448c9c83bc6a52c0d87567a0de08b5b9a2b5b27cebdd166f3ac9d0429b8cdaf696c23903dd777c53c6b1c075e2f0ed7fb4dec9fcdef8ef283a3ab24d97a2c8d25c3b4d0fbabfc8def0c2c9ca13c4fdb2ccca01ae00316c356f7472b67ba88ed2b1b608ae0d368aacd737af9a56d64112084beb2efea7659c5aac3ee2aec9c328458daea72b1ffcf06b9aa75a8df7fa9032089977cacba2435edac0957dd11edd49c9d867950190bd19f31c4348824ee0bbc9a708573a0c6a36e2daea69904979d32b4f20c8394d01cf8fcfd994829c8b3cd48f51bd0b8a9a6e9606fe9199a3b506f73db38541cc4070bc6a244d9b17ada32e1e4c720d6d8c4ece607e6228782927aa46cb284eea5dd369292ac20db90e42ed2d479b6c1992e658c86903179ed39bd87e5bc999cd489ec5685d219e359ff09c6586b1210b654a748e300632956f03ab3144b963c8be0136d17209dfe3f56c23b1c26779140ed7bc6507afe43b2533f57e9125e578d187a7cdcbcaec2b0b0f0528484189b04fbf7abe3c888dc9c987f726663c1b18b8080c716e544eb588b8fdaf34ba0e16f4fcaf25ad43bfd31a7a35cff5a47e4c86b050c37330b3ef23847734d63f8c6e09a24196daff1df2048d11bed65a53a361789024728a1411c1e0d4bca78e7c1c344432d311b69520303b33990f5c2e35b753c872b25f97f9923e5c10fbff0271f20b8525f89f68516aeac6b0ce2cd8c8ef8faacf31231a5acd92c84a323fe953dc418cdb0c7faa46c03bc94522697fb870ccd7f1bb418731f9e9fdcdb1fad5359368a949c66bffc22ff166c52847df0dfa53e2ba9d7d91d24535ba5628ae5e5d2f059db249c5b8aa44f5a2d0789b08107c249e7d39aeb1e7fad49b2be14982f0af81e6d24b52d950d6601258473fb7a75518246e442ab65b540ed8f32d4e2bef4d5c1e64c65cdc3e1392955f9d75dce47a26409a204a03f864b473795fe9bd4b5c1f5bfabce0758eebb80a78bb9428c3b8b7caf8dc3b6e4d76abd0f5860781d63bb49ba9007ed650ce39cd1620e88711bc9e76637bfd9bbe5ee57fa7c06ad5aaaaa093e249069951f413ea26c9811123f8a8569318f864552fe712d300e866a35785c755880ccf54d71266f114690dd31af1587902daad1910d2c95111523df42fa1b981d23fec18e4a1d1512ff644acbf095743c8784cb257d3953e405249da337cf9bceedaf554beeb6cbbdca7e50f8f7542b6f17f3b52b60a806d688ed9afff1bbdf0ef4b2f5732473f87ddd07e6ce969ad7dfd75c71ff3cd3526ab3fef8bd7a480c6094d34a8f0f1f1c3235245bcf1b4a83a2dbc8cdd39858b704cbf6628aee87c3f748cdd61774f4a30e6ebe02426bb82775c1f5eb17fa9a686316f8c049ed7fc95a7cee14a26545940d0bbc969662a537240b64ecf9762686c30ce3d47851addf66bb16bb287d79ecd4fe9b3bb951c06e63e8cdd5996c75e4995022eb90f703a7c91b647984738e605f7926a4adf00c98a3baf57efa7bc47cdfa79e548b6a9a0f3f3b994bf2fe0165b18561bd5e24a1a9a626bdc365ede2a0b3f65262bd7f6d8d8dbd11ffbbf2279652027137e1460097ed95254afde12b4304d903d8cbf60bd749983de8d3bf95f67734e68520716581b3739c060f98a9376f04212462333fe44d6d5b13cff87ce6547618911033cf32297a86dd22636a9b8adbbe647546f25d4f5d2db01fee2ae8c82e1be59b72f7afc8d4e8cac705d80ccbb51a6922092ed5629285c76e2380b0d577bd9cb0c4f26b6191e0a856f80d77f3b624285c088e275324dfb05c404d7e8559e01234087eebe1b7bb8f95cc86a659337ed37e7a3f7a1e70018be8d2788c9c826afb7778a479bf504b62374de2e9f037b57a8571dbd790624930a8357944a10cc7e2b6bc2bcb2c31af08979f9311d6382055a0734d3e2e56506606ec29cc55b3dbeb6803f5ee4998e9af6cd5900606d4f40ec9192be39a256aa33521ef021bec0c18190a9470f163421a422e9b747f86fc95d9be64106535a3f947ac79674332d3a496942298bb59c8a3069a1f9009ca0cf4421f040af695ba24506ea47c781726e669ece1e477a734b9fd79d4a6eea4966a6afcb2da756c237fe61a33983aab4879a955824be4cf3028d1c9ad8292e40f18dc64efdb8a4d52564d26df354faa929703e6930f1cdf084c36bb5b958dfab085bf9b8ea21966ba1ba8abf28bd5a59c1e83515aef76a69f6011d3985fb7a856937656120fe2872e50db2baa660d8eb49575355081291ddfed0a7f5cee9d99c8ba92e41d3ab05248777ca252a2c68de2dc4d020ba7b06a15865183b06c76697059aec55952280c68bf39aa9ef2a8561862ef4ec0eb69e369d2b2cec25782287714491d7700292c63a4cf75e44a18195563932118a7c687eebbddcf61e36c717fc801cfc716a0c84833ca36a5818178ca74f1045c046b6dfeefad5fa7caadcd9ab713a51bf6155365f42b8fc19981261be0e6e450165cf9c1c6fc02ab98e930c67faedadec86b7d69aa5c0e295a36f955afbddb6a1813a38b22cbb60d7b98ea57d48de150bb17b6e1b79172e09c5c9dd54a1c8dc676ceee0468a87f93f3b726303dd0a9a1586af373fc6c4f290cc0b2d252b29763a7f9f607c9ea3af6252a9432d719b022fd1f502d74f9b6eda194a8fc56a2b859efa6b7464791b11d9a40e5850daf906239bdf47e2c35b1eaa0639277b860fd2f028e5aee97861e7987ad27ebed308b77a2c750029ce58af550e496ffaee503cabc9dc6484acbbee378f1b3f44de7a2562938b17481b8bf90422ad08d2c5f33c2bfe5f1fdb8214a7609a3a72faad80474a1eea6b6ca39522d595297ebd3085790bb6316b58956cbdf24481db2aa75a40a7cd128d9b811c1fc0898d5cd12050025128dbbd51c771237d6e6faf508a5d9249c3c81d30882f65dc920d1489e63e84e74745382277d27c2b54a6cc237342bbee0fe683643350223d9d203bd1ef56fcd220db2a876ffbc43a45f2e1175f474e118c131590aaa582d6758e5e8e8aea77eaec29060fee0a33c8914454c7c5d7e7aeec22bc2e2df69907a8c103a04a2737a885eea44f5ad331128bc6397804ef3f63ccb811edd2933fdb03f92f2e280e1333d9fb44b5e4fbea6fcf6a7b55e1b2f1e254d64fd54f00ec11007a65c570ceaccd7292a7cc9734d46e34f027a7636b6e3fd97cc742184f33557eacb5ac25e36915ca4cbc799b358946aa53e9314459bc6bb8d12ad4eda4e35a9c73abc9a5b955f66897c1ee9871d9fd59838bb3e8086641f26a43b8bd7aa5d5c8f4395369d58a002b9e0086a0286b27d42be35be9f48fc66f3ca6cc886f0c99b55b0c019105b82315dea42c6feb8b442b9bb683eb1bcfd6981cf6d25950e0c3784a217926b0693e2794de0c1ad4ff460a19740490321fa8ed852d4e9c263818472b050098bc6af6bcc202b8c152b6ae349d540fda70afc9276ce7b8ebff98e8e7fffbcb735386b5f684f88757b8d58371477af23b5611d4713f32e0d56cc1b36a4cd6a60c7204dc1d313e05c05df2fd45e70476e586d25bbe888546c3492e32043f0bbad5847a9a00cc1e168daa0893ab9e9d48dad763d7bc64749caea167f04a1572a3c08e07521ba235f09c9519ec30300479b20f418b4546c1ecff54a597a156af9b3b3b981f52f0fca7bb84f1f74d0b7018f4a8463ecd6f33104807f1bc0b24ea661ea0615dc6bfc20593f2e8a88c5734309bc906104c5673a932646f1e1bb6e9782b871369bd5e224b5684328c0d6604138b8d22ce0990a4ace864918cf7e6b5f879dca4e61b50938ed61bb98e0f5976f048efc8a671a2c5651b2f97641a2847482ee5e47a942ea31c679686942e667e259ea7a1d3cb5b4449d8a383a58c1aae11fc01231a60b051c34d9ea70eed22ca4b601bee55ff1e98d46e602ac9e5edbd6d4370d8f08666bc28b96eaceedbdcdc15a822e5efe0be2875a33c9f1861e3c566038f0e3c5a3a321f776b7cafce32712a8388a50454a48b4946bca6f71d019e990f4477ce78df93ec6be0862c29991f3f9fe869481d3d8ea6c31df1a5713dfac3e3112d69cd64c77261ed141cfef6e81a0bb1c4bb9ca31396296ba86552cda7d1e0df8451a6aded38653eed13c71a51c43b49a910e12a7d3ccbc1b6dbd5619dc6daf1cdebd2317148b7abee1e038a4e7d770f74a0190afb1d3e48ad569ef059db4483c84d97ba3881da6f15280a5139fdbfede873e148ef8a4de86d1bc4a922f7d9e626a7a80113f2f937187d8154978c53147a3b79fa6e152d676d39e18b68d20953db3ce3d9eaafddb8a8cad49c19dcf4e634d38a355a8d4757cbc0f12e64ac2bc9e594914c2d2f5a5d5fe20b413172a0422f5a1f37a6c612ee784c3269eaf470cc6c93dd8973c5191cdc1e5a43b359b6c64a9afe0b81291593fea243a1c76e958b1e9fb49f38339e99b8604cc9c9c23bed1dffccb4242fc4ebd4566eae9acfadff6927e33c2562fbe1900b211f739ab151b6eb87e563bff49263bc9efe91426db97b10d5c4687d304be721089ecb2e4a71f9a59dc66e147f68e697b3b3b9ed3162397eff3fa7c1ba401dd0b933996563ef0741c170038e5e1aeaf13754eca2eac4cccf79c8f36a5a28c7c22ba5c02965d7efe0c0758557abd2c1862e9000a38b1bba34b1864569d7112323366352ddd5f3cf3d23d4b2ac630a1646d91e624f6ac049f69a2b9fd7f76454b8059be21aee3c0b916221b48848a08c65114ec8345018da3432ddae41f5fa3b8f9d5478a2b554738be90ac5529d6c1898c80b96a44173a2e5a25a670275dd177ef10cdccd6a7dfc3565cad17808f43e45ea94f7468d856d62ee1960b6332a5e3e3ec85fb240246fb77b5cbb5c844ad5524dade7502396ddd0719f55ec5ed789beaeacd5c4ced29fa611400a60df63bee1dbf9673f465cca34f9db959c2e7064b63f4282524abcc5dc6cce0dc2b90536cb5f3fd75cc14de433308ab06b8a5368c92788c3a7ed44f88248a76ab41f60cac3a5968bd69b1a276703c676b27e066b1716c1d50bc26529695314d437c88bee2ef5cf66dcc59c18d37f19f3542971d28add781a4ef6de42d48287b2cbf025ee0f78a04dc43336d89dc8223ea8c8a6d393a26fb1102204e1e5e4613db75967a07a0d669cdf51cc9e7ebe478e27643e1b9627fe0314d19e7bfced2628e8620c107810b3384646645f14efcc3e115c40eb1c1a4fb7758aadc8d6bbec23fefae66a50449b791d5a5ec4cb8a5c568cc29c8d562f14da739a3533d6de30893f29d82cb0733b431bb848e815dc5d89f61921d2a7a08aaa85d920ee27754441350fdf79c1195837bf633cfc84c4739ed372f86fe2984dbbaf0e784c8e4955cb8ce0cac45fa19df235350c171a9b027bb9bbe94b70a48645ff7d8042ebfcc152effc7df21cd490a6cb6c2f48803208beda50441c10fd0818bbe593cf81b4dca9a72076ead0566912fa700a3ea51c00d6807e0f839271f76af4b8a950976b2955f35077e2b2d67ed8f9c702dbd639b6cf20d20cabe76c4e64f70a4f1320a210a918a7718d4638475eea7080b4e761fdec5ff22be558b31c4aa1601752c3288f1a0128a29a8f7e0db972d5ab4f678af831658989d487001e253eac2d5d965b8ed0be697cf63f8779e541af511ab69c509868ec139159d440d38ae227592fa0bef871b4c3de38e97a8edaf8e232c7e3aa59dc1bf18dd01a6d91de784ec0a1e4858c227f16da6151879fc44444f77feee035b932d88a2b3c6c02780c39c9025547c415834eb1d0400b0244ab3557a2286aebf3c169ffdc9fc5407bc4cb61d7f19f39f6eec82a2516019018c5e6c282512aa493358e7f69efe80c7641639232f73fcdd6280ecd0551c654c62169dffc73458d225fe09265cd8605bf84dcbb26f4a2b40bb9c277c071ca504b2e4a5ed016237d8ed37c6708b2f75617b305247d52934a31d12f084cc0c07d40c647e5dc72ccb663d0558c438dfb4ac7320950c2c89f4af2b20c89ac5c5eaaf0a081421196c5b791a2cbd39dd65f668b1d562bda2e7c121dd50a2e1eb9bcdae2dee1ded5390267cc239bf5a8a2c6f31424d1f6374b088e7b2c0f602d14f865830beb7a0154401641ad09a64172647440938626c7daee4521c5eadc4f7fd69ab88145c32352f035531c00f38a31488715fcfb3c26a41634e5530c24d10a830d99240607e5a8886f46efc8aa9044e4c85484696d8134d1ef0cc45075daf37370088ab281395ea0c7c3a6643b3c101241766ecc5693830ddffcd50172451843b1b63c2bf323b8d196d15a6f0b8b99619fcf8e8426ed866616ebbbd6572c6da088da8e006a6aeff93a06ce2e704a19d1065ca316db19f386c1e6b35eaedacb58611ab0bf70deb7a6ced8e811b9ea934ecb01a810f34631d8d63da010a131886fa9b9f2db718928b5c801842e1e065bd7333746b2f5303d2d4ec5a1c488a483669b1254f4b347732d43f17031b9c2982f6e2b8592a710b7fcb3cde167173606a0304a9ff78817b54f42fd475fe0be548c7d3c1762d6460f451ca247d396d4f07494799fae46cb1ae43f0b0469c3ee0f35812a8e5e0dee1dec51dad94b9b5c36e0b932d4ab35cabc2e96572ed41e92944cbf16bd73c802286e38007aae22e80b73991ab18b56be261de037c48fdce59412b256ebd3fb47d41f7aa6c9e52cff3bfe730b231ab347e9e97621a495e4f8ee0a626f24098a75f036b09787b8a1483cc5f44dc0db4a85c5074429cda9ef61ef86e83e93d2c29b28003d6e00274058761b75e0d3c653d0c87563f82e8405cac785e9e856ef4c6a3b7442dcdb4c76db1b26bdc55671c21afe447099827d85fe41644d7763803436c75dbfbc5ed0575975c6890041cf212bf3057774004513055dd9857935e4ccdcfd17822152de6ca3839f5a51a1379597250e02c2a33d65c78bde4fc0546ece3ee953b817fa61fe891c44ee45a666d9f38fa242539e7c184bf2ef37205b924212a3616efa9b47bed75f13071771c2866ef7d7030efe6500e613755148a90db15a071de73b02684c0d273231930ad35971c62483ebd1997f825bda19a2f14b44755d63b671500b7ac78bc1f9ca9af8d706b847e7793500ef715c91c162911e6fd377a8fe9632f0710454c8d3b0238758925ef137568b4f6446d83e525289460f5439ecba1aaa4268aeb3cc0d8984296838163b4e6b17a26ff1661a16d451236dfa8d01e31f2ff3b2fa68808354de422d9136fc1392263fb3f6fdffbdff1e2d058bfb82e4a9b09cf40a441f020a8482b6806d1036b455f1d8f560a0ec36210fa237baf4563f3164dfc0fe6fe86770034864a715c06ce4a81a34d847aa3428e21cc0ed60b74341636269887cf44530b61c405c401d76f469d8d4c31178ac7758299542d61f2f59f9f0658b7a1d91844adec96f4d0aa72bbba4c0b56d478d4269a3fead94afefc9fd7b4c51d0d03c0bbc25dabed8184e19ab18c49d86289ecd0e904e862e8833f071f3a819bf57d5f29e42f7a2d554ce358b86c385f272fa4d79b776c1b242c61e86f3ef4f1b7b6b766d003eae6548b10752dda576992963bf4a40b36e43fd77ba6ca9040b254159017c6bac1e17769b077c0704abe1b74dd35d28944e7447dd20009fa266ccfc428674a5802601b4e12500e12555ba457f85ee4e60e204d6c84623eabc61fc6d3995fa77fe3f26de2bd8154c093a7eafd65e3ad11cf6d1f9724af5216c9379c73b1cafa254f1773799e58f081144d685e5e8df4f3aa40dc0d1fed1ae3637b98b73bc8e8bdb6b97ea9e233959077da329e90ad4452d1c8c47cda822a34a60109fb67ff5a50b81ec1204a31efbb31a45b397d6c266800353627b45d6eafd9fc701f98c005fdc20b1a56117373a1cfeae4cb69309bb92c189c1b9b841ee5d5bc31245ee014d7dde7dd9c831822ba03045060c0a76f6f684cf6c995ffa6d4cbbb1f878e07c37c49cc1a90f80118251ce5abe366777b11a4b016cfd90f31b3d29611d906628415a69aab6aec1db1ec5d9e3ebc8f8bcda10fc822a37de1733a5f43376f1af09f8da0307f2f8f1c335942de7dac138f24c7b9c7e055417aa61f923766a13e1501733e05f6ecb53e40868e2d50d549436b2d7e7ff29c8d9df248623a3e0e9db76a199fa520b835dd727e6d90b8a3aaca23e78d73d3d92800c9df415b5958cc9dd2170de37e480269c5b2115c938804bc459d7bd953d7869d188a07165ea56e0ec0045719a2646371f5448bd4ab2c844a0745a25355d97117360d581cd492c7336c09efda9e66778ae812c8cb0a89f0c3e26d9219beba0518a2148467337c770b8efeefcdeb1a9ab240e174e70a3d48efbe49aa23007458bad27dfbd0dc33f17fe514b873d445f22d888dacc651fa7af748c32aa75dc6164980cc097be68ead9083d02a537017e00601de357127e734601bc608d94c0d8fa1b6ac10685a0e5ebb1b39b88a23b786525e30cedb09f6cb26cebf2e64fa6aabdb1edfa0600924da2934d693f7333fe3e9b2e623238b6e336a021874b9faa7b420aa7d54c5f1b683f49c49020bd92305e9c0f4ffd68159e20a011a214bf9142ea1b3e8cccb41f90ad3fc776ca081cad8833f1901330f8313da2acc6cdf8be9ff1d7884aa1e4b3af63e338f01ccb36e096e60be6e2def94c09148bd649471f1deb9d47a7f6d819fc987af1e2b323de7cf1f18303d95ccbf136ffb5e59659e21f4a1c154bd00357e887556e1e7130b9bd992033927a5c35929a86431cab4fbf80c486e46c1511c9abd6dd6754b6f8f8cf0e591c8e1fe386e5d5df781ffdd1320ac897409ba3d2224af5436f3d439abd8a5958beb7d69a497514331fc0448c4239026604d2b89ed27a25c3f8a1ab0d5d6df0d1a466d21f606641683bf1f56553565811d66bbf445848a40f9647992f3e43e19e8f8ae202858e2ac52574d000617b88803e6f92d6668c9a3dd4b898d3799c16923bd657e13fc6410092c8454b51a6df2c3c0cda907b1aa5e5455dc92dcf2191f1d79663270b66a6a501b21a226e245787b99099818cb6c3de1e5d563d69317c4c1550d00626a17356f34fb52123b6f069bac4308e3bfaae7bf538196fc28fc9d7188c37cc3f652b95ee796115c55008100d5460fb92a55e93574cc930d0fd1e970b0c07dcf21f78a32382d9d8abfd2458f898ce660fbc10af0ea05e2d2961e367d55b483c5ea33eff7206b616c63b50821178afcf4ed612e9cc9a38681d26db200569c936c1b633e432c9c4f7f414fe5cf54db8de6f1f5462382bc2cf6666e6fdff1b84230ef389412c3492294f85cbc2f579b7132ddc3d2f82feb9894cf781ccbcdeff689504a59543613c6fdd22fba24c37dd1da80e59d9c8e62e166d1d13a156d2f3d6fc390432f492e44f37ecd2fdae1e268bd4e2f63da5c73f6d1476485251c090f9f197ba7189cf94743763d9a5c3d470caa286a2e5efe470d17ac95e7e625e80442ede7c43877950f413627863330d611479b50df42ed903fd5d9d1db32c94876a0a2eb6721ecbb48d64f2abe9149eb3dc51bcc2d2987da27019801bbd011fe24e9ef9e320fafd14f32204b369668a79ff07cb7639de7295b58fe62c2f249267e92936db7d54d7ec96efa2d984df0e752a2e793c8389b2b3549b752a70ca38e2c527b80694de865a203e99d8329481c2f6e0f01348c585d2a5200ba0abc9df5026cd614d407c561d2a3eb9dd949c8950cd3cc899ece5886edbb43b8092b835c9dbb7e0280aff5710da44dfb7faa43f9f8d3fb127338f26a981e5204b267fd97cfda79d5fd49ddf58667e748a32255ef931beb1603b6fa913c44ce4737fdcf666cc8581e2c54552052ab2ff89b5c0ac24558feb3f16a57e0e78003728b7543f1cf8e282e2ef36c4375047890815e5467d69bac36f5ab02aa86a86708933ce189752196cd9cad3f20c4ac0bf7adfcbd1f074ce2d866b6df0cba5a867bf88f93664b8cd1ba0fa6f92437154fd68623fd17ef40ef8fc83ff38ecd325fd1990b89a92064aba48cef3e1ea7828a746aa95764bfe1674677d8474a6c5d9e008ec72cc47b93fab5f5403f9c759b1a36cffa6c7a6bd57ccc04907a1765f4949d1f72d89d062a8a4c56c491506fcc95236c82549b2da1fc99729849af4c01036990085957d62df33eb06f25173bbdab11581e148a9c4abcad9ca7e3ee954cea0f69b94b8c144b9119ce70978c3ffcec0d849f4dc5aae7188c690de168814563721c3cfdeecc6a377fdd7cea1fc2e173a7352b3f495ed088115586b7597d6f6f8941f573ddbe106b60d0f811c8f576309f8158aa4e6ef8908381cbef0ec1e9801b13941f8282bb1067529b67b069cc41bff1260d77453df1a294980961667bc088983fb25c91cd6490bc29b05f65b6c1aa9439d04f33ed03dca3fb4ad3f325a08b37fe85376d1337f30fea62b71d8d447fe0401877d2cb52bb1f3a667f7f76f72568d68c28b9a69d0e4f9ca02a5b8175e969e29f68dccff5b125e7ee0224d3fffb00cdad5ec82d44cd2dcccdf869d1d932846bc51bad996a2aa88084aaa1ad9c2c06359a5770dd520b68c7dd2b8a318520187168762064d76e613a6fd238dcc0257f00ae67cf60f052b97557f86ef4036454548452e7ff4476b7e3ea75685521cdde0a6c989091b59e926c89255f448c2c6a7970bbcc686436c0d01b1f8e2f6b6adc0fb77ad0e033fea3648234d671632d0af75c9da7cfa6cae92fc9012c7e1202eef501d3404f1e319eca4b51ece283e0b05911a18ecf2b8105cf169937ea1d3ae1607eed34c82104fc10a1ac87496931a701490e8bc69c4d10f5463a2472a97eefa44a9b496849bc4c2c1de6087a4e0dc58a8a129d907b8e5bdb73ad5642f5481e327355bb81b733836146d66f2d478fc67fb0dd5e6878329cbc129fd554037c8409e30000a497f35749bb195ca6dd449bc21476048a13b32b5f0fbc3293368d6d4656e7915447e0220c94c5569cd4a2c3a60dbbf67a9c03e01a7b0bbdaa3dc9a2d4def507320dcc54be760986f3ae1ab470735010596be5b24462ab85b062984e16184e8f6999b94dfd78de7a1369d22da95899d9bd63b3610370db467aadba004b91f7e41b0dc660559b3c230ae365f0038a233cbeec741b319f9160ddd1c8d52d9fc2177764efa392f0f843a4f73e15b3a7257179936039ab867b1cf9facac41025c6223b733805491cc2fa9f2f0cf725109d67b38b13fd5dc729f4ed8789a44b80d387753e6b2bfedf127e20c1334968c1b13491791859c74f212b4784eafb5697a7b53eb8a34cb5a8f39c8cf1ce5183ca945b39d398cabf7bcaeb30dcd6ba8f095fe97cc774d766b675df2650cf4e83ef41522c336c539ae5e9bc593f43505cf79b185fcb011dfcf4594240e0398db7c12affecf0e223ff4e80f1724272ec1fc91270657947216b56498fba03b90a43b0188e803e0da45deed0a3ddb2db05bd9b29f193e3caeee646270982ebb295c5f3124d5cc4d9bb21fe4fd561572f3ed374919c57018bbbc201c684f2480e477f7a976436f1c2b05702dfb59b26234e9b5880127625b3e1d3120ccbe8c1063583ab390272c3c8a1fc7ec055e3e99bac4d86803bdfad3989a31b6b19976b61f153c0712e21b70db3332f7591b514e85e1a49477c72b20e4b76c2ba601c749b6ee75badb84abfd2203b22b3c1b90ccde90e990c327825457c9ae3f1200dc10702ca2d67718bc24bbe581311b2c544ca320d80b6b0f2399e5f56940bcff99bffa9ce7e30c3fe11724e7582544d3fb056f978b16f7242bda2c129a16625e16e01f2727ed2f2e31d35e3e325ca1600e2c64e6c12de85acce279bca29add133eee6ac32298a9d14e6f58f87a00ccf9368cadfd74d16c14cac589722cfa507e7d82cb927763e077e3f409af9aa267c85cab2ed785736a31522b5f51a085fc198e3c7a8161ce328ed533ca3beb361d168756e8ca562fcf2b70fa75ef4044efb057b4757e8f6c6792a353323aeea46d441005f75bbc3e78defb7fe102d7f7c17bef5b7b490d19e07dc6abccd85769b67fdb9ebc28be74b4c61c722d52d9dfa747e39b5ddf2ceea14724198340ab9ec2c31e2c8893c1192b6a8e1bb8d6c0b741b9d1fefa0e6164e798c7ce2da654972893d41307383a34662c7e08a3ab9f6b66f70c9fdf1c3b7013c918b11836544fc541e1a34e44c654e1d4f0032b783c1812044eeb69e8d7cf8396c6b423486a1b98f2eee4ae008239a0d4fedead59eff8cd8332ce2bb30c27ff33e54077d39b699874706eece02ccb4ff59955ae38364aec3e11fdd85750de17f7e8a96ccceb1f2145b45a9d9816d7233f8b5355bb4a804209ab9df03caaad79c2c9f35f45c0aa05595bbf04cc1b3d2c1f1f8678a7cd097e7155fc538ab887ea7f5d5da70ee1e1c29d3a261af1c3cdc992f15178567d2117ced78fef8d9a8a85ba8cd24c4bed1deab4be6d18e511b6ba95299ccc4df3542bff92a7bc67a0abb4880f24a8cd0f2df59ab5388de98dbd332bbf261e4ad2a4c156cbeaa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
