<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"790214948c261c3dcdf533b6313965a01a174d03a2225dc7b030f91c9cd6cb77c0e23231de8919dee415b0a2c2cda9527c6adf7b8c92dc5c5a3189923490de1111b269716af6cc418efc3b311cfb82e42bf7548c423cef34732dc9658a4ab4ff2307e56c31d9b5d419c219d45903cef7f8c5a2cd80fa2359fe86809d02f7d712f4e22e5dd9fbac269630cb1d3f69f976551c32d2d7e5c2f9a74e5fc2260387be431d0480e14f16c875337e4204c0d9dd1361c215907b03747f50d2d031de25054ff7076ee947bd6db3cc7fd8933011aadec2f9bb5d8770996548cf6998bc8e61b7f5a4bd7d4060404d004d58e1fa9c7e43de2b45771df7f06b9a600c4fcd3390c8598e5c94fa3f7f8b4d5ea3ec974e33213d70ddd6e9819520979ef8cf7c78cc37237b8b0d6472b291cb9271db45ff2ffccc5c8d026190fab8388cd90bfae7d2567e591daa6b8934d1e00dea684fa255be876a86feee736b2cd65c7d6c6786beab399cbd01b22c2eec926011d5b10cdfc2cb54447f988c3d2957460ce528db5b34a6b23ed6a32df1436e70d484120a9d226b9076aa6b093e7ebf355f2788bc322e284f3be414ab45a4de72a8f0d662c9411f325626c1c5b904f58bdf0ded5e54df36dce8c968bcd66b6760162680e7e9389bb6b01d40df2d00276179ee453c5dd4488624ae33144ab43c2d0d5b54d9fb73e6f902316688aa9d7a5d082a7cc4f7ab6303980da8e0a8d9141cb521b2b2e674ee340c812e56e7028407c2b9b6f54033a53a722e504c0602379b2992412f7972cfb5b5869b3e6014a2cf36689fb0315663c928b8a972045bcbec45d80bb24c1b8f3db12bf94d73816360357b649026e4194ea70ea6836104c61ff97c1553142d8ac6d4d2ceedf3c60d9b38eb2a405542ba2abe86397f45061bd7ad8292f1e2339d90da995b26e0000212a977c2e2f10ff501f73ddf893e50e970b82d5c3febf1bffe97d6851194f2de63079ea8dc276b780b819ec81ce4b1377ecc2be70d33b693a6fb76c64e774c83933d5c4b05f9314c2fb24a692acf96a12109c344ad32877ba338d229d8e1293c9e08da4bc68d331f46023512935f9320e3018205667a1565c8dd810eda64cfa4a4576efe470bcac4b7e499cbd88925810916523d63018975a214dcf5f6d3a0e7fd8c45980c17658c205c831b49bbe2b3ada66598f083c43f8bf63ff5d191e9ed4ba7ff622bff0482fe3015af149d975d6100401e52dc84f437c00cc5725cee2c1129b98381997ce68dc9fc4aa0721ea72d79c26e4314a2701824bc1a6313a257c2cb6a99934274a7abdd9a4a3fe1640800a5810dd20c7b61bb84006a2999b6bc171faa714858bc17241b3c007a5bd44d997b4188a824a81f1f971664ae954e5c8514634beab7402fbe058539b2f7d608b2d47470fffc7f37e6a634d2561536f894a5e407b5d0623ced23c2f2db7f37ff626176b6fdf1b8d7115c43b9a0a99a1aa9cf2648bebedb8b881478fcbb07d80ecd191f5a57210dba87068443334c5c2268d354511a2439165c7815b27b90022f51af33437f2c7ff6a15256622aa83c0a04fcb933cd787c3a69fe9efee76aee5143516ae97d6d62611ec2a8c1eb286db81f3ac382272141a2bb0183f910d7e3ffb7b2358fd5dd320a0026f33fd42206ec7cce59fd56bd9f46e9d44e600ae52079f7b47905b2c1f6469f353c3e8deffbabada88f3d36d07874efff575389aee6c9afc07e9351c78a36188c3c3fd16418628223cf1a10bacb3a1cdec8fde557adf5d07a955190b7314e8ec518d8ec7bd7723d48eb2503a9fe2ea18b0c89cdd8b1475d90a71d27cc70433a3795d6653dc942f68472084ce385b6debd97059c37f500e8ef0fce80a7ddeb3415da3b8318f3e62f38a61c6040b7924ed75c6576b257b2423e6000ef7b1d1639d22a555eb6e6a33c0f1c7d76ba70ef8bdddb3027c6d0ba7a229bdf17fc448e626bb90a64eee85973b48193aabcab4c578fb7d7fffbf103e885840a35023558bc0ca852b84b4815a184f77322ff35d7ab60cc8eadc0ab7f61af59b0c6c2b1b55151113f3b0997128a670eef14e64f5096999263eeb811199c83dbdae96d707b0b16b5e2e05215d33546f357d05a58b7d5ccac4734228930c6144efaffcc1b9c35f7050b57aaba608a0a7c08d07d8102aead6a9bcba9562d01b15f77137477409d559bf0b98e777ff601715b9ef4eb5ba62c6540533fb36b4b54395aa5a9b5d89f74efff2f48eff418ed5a52767aaf857b386717dec510b1a2e9acbcf1812f570cc309fbb6771706e322b72cede81df534885982052bb608fa5631ff5661e113889081fcd90ca7376bdd548ab80f06026ba6a1b6bbb16b710dc9fd5484db497700715eb88db56901974a523238d820aa2dd99dda257c38ebb06875d21f576cfbb7fa6d1ad76f88c8c831fa5a6faa33e7104e8d9ffcfc69fd356200675508e7f392164b5e7368971c118f22649351d91f75536bc5213e80c223508f8ea4954241e6792d27f6e4280936c28dd481c368377fdf3e116bf285c6fdf8fc67afa6e04b15b2d2b050a72bb4d1477af7fb4c816a9f5b6fce2d7d192a24d75197830aff189ef337ebf1bce7664d210001990e8b7c50b801dcb48f5ffcc14385c86922258956657fe1098399faa0fb0d4d4d2e64ce8857c220443b95fc0d5a58b3455584a22f38bfbcc915754ec406242858c7e1c3e2fff8dd2d4cccef1e871ea5c6ff5ea2fd1a858dbdd65061d4b79fa631c37a27cdad51188717d3c752f6981ffb77ab06695d8e81edb2fd878fc019db999ef59195378ae3749d403b824684887d88521528b28b59882bda78f628800e878134d83111af25e2c3e19dcc487462ecdae3872a3f14daaa2ddbbc81953e965afe57f7a62fce96d662bb2705b93bac2f553aa3d75d0c77bfdb2588a14fb2b792fb99abf2342c56492b6e54d4376186825cd26a9aa908aa249688b02a63fffb6d8d164d199120495355b0bdfe4a7a14b85679ef6b08f3a031f09ae7c80a9caa03e92a876fc6425377a54bbb9f67824534014e4cd804bdce114d6f90007cd9f010c9737adc330a5be0ab5054bb34119584308fd2a9a44343e2a8eabe88252edc895d9bf2e426f1c55f66e7897cd505cdebaa052bc243723ceaf8279d544856560d900d1e27d3392ee4e44daadef691c0d1dbbe6e490d89c9d0e8c0a543322f4c739fcca94fc1a50d079d42bbf2c03edcba1b88edcf76b8c95948f5713bbc7738d867e0ce7cf8b3fd0ad86717e4c6a014edb4b54fd71d867d0a7b966673a0adc4043821908c8195272d7a782a820bedb2283373e31d4d2bf6dbd2edec8ae3c54339bc6cda2a2635cd433f846a6a5056e994316f19dda3d9c92bb9215c3455c003e930630685bced6b3b6cee33248d5fdd3b033f03bc62ecc9f4f46bb446a31d957dcb815b046b5bc7c50a9aa4a4bae5abc4cdab5b7eca9399e2d44285d0d623d458c520093c738ebda96cf2a091f0eafeecf9a72f5a64821c5671abc60b105899552bc98f403f25aed43038e4df7f93c737e0fcf62b337f5f029f99dcad09fcad9011e8344a4106cf1b0bf11617d6287ab4e12afe91eb4d4d4e81b4584165abddfe297fff7fd7b25f1b2c2f4a2b597baaff205ba7df608214eba63056b22756e30ed8e153f3bdf9b2aaf76c9e4ec5126b8cec7b6f1470e51ab644ff6f148ac8bba787463e57d4b856ddf865377fbb16eb7348f641afde60198d1ae26a39564b261cf64aae6f8f5a86065d0bc8c3f0205a4b31d5d9e62e97a50da8ffdbac906e7b69ffaf540c216bde2bfb35f3e4e63af74b6d2f9ebdbbd17856fb057fc8f1f18ca999da81ea14b3dd4b846a436a4762f8df50b302ded733a3d572e9c6d2c56332be5d3463d81f1a1e3de7bf2083ddb32319496b69e26bc10ed61b3213f95c5a51ecb5ba7f1b414c98896a6093115cbfdd2745eb5c5493b2db07060338020405d4780251090fef09a5bf6a052c272d9e33f2e3e50a26d1ee426309ad06a43b4f38bac35854a29905d77c7a89d713a758db7964b316073cc1102f52208bbeb6abd49ee601eca9c25c00fee4403f697c82ab9be8cbaa1aa4cf9be8f5b0e538582424906949eed037c72439499d295a398da55b961b55be63d817bf87fda5289a71da1f7ef15c108896b128de4f059536865d46abebab788e958464858f709ba55d3c7ab0ba95ad9ee5626f3246955220f703268a1af1d2ea233eaf46ad5fbd4a19750fbb999b6d6c4ea913badbb4578004545423dd84f79a9a7e18bd945dc4bd49f95cd4c150b75f13c7bb0e2fbc4e8770173db6665f28c35bc846a40da42bd4d79e784f61f9859c987dc9fc5cc72877c365fee1e76419e036d818d641d2230c3a8050b301084a36f0601ec81cc4cb6e88c839f612e9037278a8c96929221524eed2cb133ae8364d37ff6a8ae1b17e1ea5e8f64028019f59fc44ae2c12ab39ab46a06430bfcabd07cca154d3f089270446d197d75bc8d8892957cb096ac4fdd926269877ca6bbea27202f7ec8ac0112b0e85110416c69939eecccfbd03af54d10cc8fb28e264d2316628388cdb026602cb704ad6c68d203a08d2a9339f694c09ebdaed8086310455fef9829964f36692e1cf747c7edb47cc6518a817cd1cf2a485625f45b7d72c38b35a465e43ea4dffb5bea138642ee2784b3348664a7811be111f0a94a86cb3731a10fc195000c4604abcfd90c83df95f57d01042aaddbebb1c2b96d3124cc4d9fe79aedb59b5f6464ae3921a22ff6607581626c328203d738450650143e46730529e189663a1183778ffc16117f3c9e1225737c30adc64d8bae912c881547aed38fca5edae6ad9d38d6f76282b5c53e0be47e4fb18a2dab1c8a8a3ef4a60bd466fb2fa05504b081d23dc8e97c30d4f27af7b005236b1e6ff38e9c1277731620eba582d50063e81d9e6398adff9fa630c791f0b0a916097f32cd5b9755ce8bf67541301a6a75733688b518f68577c0c00f6fd3f28826cf45c4f4d1d6f9572a9542e8cd1110ee44791f96ef3a633138b0c98afb679edbb7b68de40142820e41cb95d5d21d6558acc2e892e489bb249f15a6041b15013a9331b1e028224a4c47d633cecd27842947ada1b470362cb06b7f1fe2741ade1907ba1dc04931e46c6c00132f20d10fc43dccd9c6562c64a34eac212efaa41e76bb4bb9578ad448dec775db2de5fc80cf8a7ae31997fdb87dd125e0e7fb9f4090bc7c273792d97566409be326c73377d51b1d6ddda41a41bf08355a7c05791b603fe2ee7bdc5fa6b85b03679ac6a370fd2138cd8dce3689110d8bfadce6c0512c78a610a1a04f77759960f5668c6f5b9b1eed66634d2157c91c998580f880c30fd1bdec2f782bfab5c4ee1823d0424ce85616cf5cd6286ae8353ef3d9f22921fb12520212a16033b0ec36c169961a65669cd512fbb7578c3dc30dcb5f1926d9316b180a9684275d37e4b9b419e2877d18eb578942b7069bab86a18c305318f4cc7b57d2902d08f4b9b1de6e49cfad226f57fe4b7089493394ef2de720b272c72914bcda95f02f46f321afafdcc32b4a238bfde5296273d8b27711e27486f25b91654b69f8c9f031b1cda049901b3df4af293bf860e6ca266ef94a27775024895da8177a6a3061a65925bb7e1b2ad3e9390ec3894c6eac253e9565b1802f83def1d55ac5835416db9e10ca7165d31e8c45d7c458060d163e89c62f9b661a05c20d903bd3f6b61e578cecacfe9763b3b38f98205cd35eb8e1aeea9e482c4db3277b91203479a551b7c1efe462af64c85634179febc19981ee9f7a8a78a043ec39f85e1e58f5458098006438c5831a85f1cbb8577638cbe13db1c575b8ea8fef61d059126153547c2eedffea1bb34e21ea6af34e19508a07643ce88ff58be873e6cf7cd3960dd4dc17b149e7c57692294365849b0b1717db39d416217edb31a22c324b783ceaae3a2b05279a95ceceeb1a7738e5ebf4004193dc3f608868ed46db275e3570a5d5945f9b8049a0f94ea849e86d3b02833baaaa55cd8bef85b0f135241ae05abcb60d74d2903639575bbb486b3d69716b50846aaba7bbb390630063e26f65e0085960b11385f54959f59f3d4d26aa0193de0d2937320f3590f775ac3beacd8b690b0d676796dd08cd0f46ec11ec42eabbb7535cb743cb90a5fda2b4b0c2670e634353a476740c67a449232b3d1042c2710411032f5038aefaa6b4dc5c0ad3392e211647dbbf8063a69c1dfb1e01e097a6e3ed67cd6cff988aae4ed79ff832c9803c236b9fbb6ff8bf1b81b731bfe64eda26ed87bf00cb59e95cd1703def714ebcc82fe864e259668a7dbdf0ee4440ca7abd4abcb25f00a6e225df65a67b18c259fcd281c77247e373ad1b75be754d9a1d1dc1773751ee19dbca11d8f50a988d626f41e32e65ca3dde627e7dbfcbe89e49c544591220ff81f0dabd60f8a531e474c592b58bc42b04d8daf9b3b395e00154f7ae86b68b4e2d9ab9e594d0d08ab3116a0b7a0c768ae59081531b25702ea6a51e7e3d3990e8462c5c07918b1cccb92d6854ba56ef4b37884a74a6f66269b5be6f87194e9eb63747db5d33d18deac7b0f8bfdefe6c1e68b8ce022ed7de593699e280fb164ee13f7371fc44d48c8391e40c642e8ad4da05290ed9e5dc393e928a9d77b8ec1f753b1ae46f8687a385b15083f0f0b50681e651bc80c3836cdcffe62bc62ca683fe064cbf81ab619296cda89b33b04b5d4059c032bef0b09c568478fdcf013ed457570370a1aac5727ad0a58266b519a623198d6ccfdc50a9d4ae2cb20d15fb15f2d3efac79dce9e84a0f11ca9e20f49ebb6bf35ea373aa62d20bb006ad6824b7fdceccb1627a446a49bbc5045de9ea7f1a48939b9cec96124af59eb361edd28262d4243b7c81db35f6e465616c50af91c5652762bc6a16da1d27d77807ced95bc2ff5c748d2e2372c6f97d642cd0a6326088041fc7705e83660d137c20d812f65aa50084df8d4cb1fe629de2b9353b8ed8d4d5fe2c422e602cfd7e9b0bd5d134b1a5b32080af968f69d2cf385306d00d1601fd676ea6a40f55dd452f3d4533ae6105dcb3efc1b5d6667cc696e0001e464ba0a38d67640da34287cad01007c80841ea4c05d4e5c24cc1d74e93be5386f4eb435221c02c4badec8b57dfa30b9d54fef067d690b8e45c7c540f0fed8cdc14b7b0bcffbc87deb00f1c6ed113372f2443c29587ba8f0e7b948f8cda3aee58d45ac254239025688c5bc6dbda713c7bb0dcd4d00c2fede01553417f00a0a8d89c1f48d9b8ef338bda156c1fcb2ce9c93b0f49a7e74d731950646d1d03a881e85b7bbaed6dcfab0d284f15434c47efc36358c93cc1383b0e649d720cc0021c64b52213a642d0dd0ac8d610e72dac45dcabcb5dedd0cdf666508c54c60c8bd3e7d3cff218d6e2022aef179df5ca8a5aad8b293f55149d92338f3b98628783b58915a142967673540f2944d0418055c299d7b5b4682320e0835a5e0401a073de1484a8109e013d66659cc51487b51bd4da5776452f06bf66ea0064e5fdab963f4238976ee22b07dcd5d99fdb51ae25f236214ee5264850a30feb9a569e4369e24d36eb5b8792518ae35798b0c58ebc8e1daaaeabb49811d40467392b485a04a1456b6f3ffec4941462e2f80b08124c414b2c6105d50c5290bfb309f6c836fd87ab20d779ddf10ec774bb1da7389811263ce9df333c9bc4fd399366404433ffe6b088b49724b86253dcf711ce550df2abe8dadff99607030fbad69f64574908c593e288ea666195f8483282a5897a98c1c25e606c9ef8797475164e8342079915366922dd80165bbf9e379670c9c3f9802fc7236528acb13de7fdd935bbe3d20370d7da99df1cf284cdab92f082a1f27635f6b1288d1ddbfe01db2ee8f45a22a408fa20886330429cc89098ca132037f5355fb1edfb4c05622fd8ffbe8bc48cc579eb8f575ca2d1af832f97689001a02901cf1822cb4f22f9fbd91ed0ac2bb6c66fd1766ddf26a7a6fbcc0d4dba73ee875fb27228dbb972675c678ec22f1ec1bce3b92edc6f868431ac696c42e12274c332cfa61e17349c7e51222ebf7b4681d4121ea966cba2cfeb1e45a8a66a3ba7d7bc9da030a96dc337b7a17427f2ec8fc4e0db0147abe0d6f5f6d19c09304b17af66f339418ac3bd4dd9a2adfa7a71d4567f3654fe4507d9c5f1017550ea2758c17277b434ea6f33fa624313f34356203fd0dfb5ff022af452e4dfcb6291f4655f01d603d5f4dba3150864850ab87944dc53d36cbc6d72928ac20d419f6215efbddf399d470cf0bc8ccbcb598d2f9ae727653bbc178c66e72fb8acb80ad8eef3d46e4ae5f0c6f8984e32179512eddcd9f70e932bfc02c2c11204bb1980db19a5f413ee3e7849724bb3eb7898ac7210a7599b6bb2403c65c7666412da0a5a60d95de17e2b42eb9b8c12dc9ed0d52d8a00064f0e9964dbe3f09248fa3e4bd97181102224d00a74a7cd5dbf92a185b1b1cb38d15f14b5a8a549f1a28040ce306b2a30cb14ddfad7994d57cb92d4b7fa9cb49a2856920a71bfccf87f16cf25d65c17d694f662776db4b15dfb10df719d28a4b736ce22a6307fbec1f641cc61e8b60c66faaeccf6e52cb33f6639b4aff12cc72d644317f987b2a9905515541c4a5383bbfc63802ceb229db0768d91d1bac921120090635548299eae2ac639032d15b69012b9112129239574c79815e9379140575b54253debab61b08563457e8a9a4791c8e612d6cfce19da373f78cc00b9991a9c8600a647b44ca27201640f4e53dfbc2ff2a3601c9182bfa50c0edf502c872b0850705789eeff3d18eef8f77f7210c339d9d1fd30379d84ec70d68f063c2aa43954788c64087545666264b2e95c90efaabf5963e85632ba26af7c57e2e7ed4b82cde4783162b402141226878a2ffa560cdcfd15b4f8a250ab816b03de67bf3af7a8bb70fa60a5ce11b793cabfe140f94aab207e6dafe054399ac15aa2a97be764e9e985bd55bd1ad42785b9d96ace3548f9a06e58e533587f5917c27ff860d54932580c84b14438ef2adada38f3fc6f7dd7917f60e3c425062fc16b642e3968173e3a07612457c43b5928f26c1252f90628272099d8a2f078fa8fc5c6292bd04c530005e6da2da10bad1cfb9ebe45b5bd9ea14ab2c89637d717436e259b55b9573d926c45b16a47740eebd0d0364dcaeb0214c75440818636ca04febbfec4547df8412455c7b13d14d1a3c835db3a0ae0c7597d5b2eef201a7416e783887cdeaf16ce3bb5129ed26f9f07692ff5f7370b7fe80111488d12f24c85e4f12a9d62de83da2d8e7124cdad7d75c21c73701646049710f792409593370a631c9d3943ad60737885aedbd16e1745b2af1dfae2b390b3507ff2be971b712383ed85362d59715a46fdad7a8f06297f6b9169a1619ac8e0e8a6a26a66075d633de774e3cf15c393d67b662754551b8ad275d8f271bc4308005c5a66a07ee473547bf0151966bef19c7e77ceba33d450ff2e3c6bc32787a09899da4c19362270382b68361f4791f839fd4b15575c2f61953f371d3a6bc0b07ecaf19704c8ea78b93161773d8714e17d59a85c555601630e7a5e80a492d1d4766b8da76c5c7cf6e94f9c668ced8be9fd29565b83f825102cd9ef86179f9c6a89c89a4dba98b65dc8727a218ca39bdd5d22ea884e785f39e8dce9e2d836bd57b8e9ce2899629bb1d8ca21881fae79d4f4ddd060e91bbe295b76589029a60bb3fa2539da7d4e7e36bb5a504c9ad7a64ffe4b7980b83c348c4c7a71299be536e34a41de1627498f7749850996a02ae902ae3ac41fe7b61bdea6ed13b9f12d563c2c8712adada288e50233fe01be147f92b546228e98c1f17d1b0471e5e1ae42f2d038eab0adc63b2496b9f573621c04dfeebc3a3d7bf6e26ce09482edf49cb358951a74207b24faeb36be06349f58e86c311980c4aeb5523d7fc9d8ddba53fbb85667a0e90e65567b8cab41ffdfa37019aea0880b3c3077ac458663b3f1bb44a864dea2bd7f36ccdb5ddc4b72dcb565e4fb6eb6e15c150af5ddc12b34835307b5d45ab311164e1f6782b4ed81e6ee5d4256cacc68d0d7a1cb1ec6642b6db89e89fd21440329c5219be6f35127a3c06c2fa439437e674aa1009c94c4df6f332186167cd851a22dd72c0555c3c40956f3ea998747b18d063e326d7d4da2cbe582cbeefd9b3322cdbbe409288f0e3b80ad65ffd83f2362daf6391296db5cd3996d7d90f540b2362053a0f9d6e2bbc11cce942dc58fca370efead3123ebc983853bd7ce03f5cb4280e24a32ed25d6a1643ef17dccea04766df63931343f675e747a11484b256db53674cabd339eb424f0d9331e65c0ca93ac28dcb941c3c2c915a908bca43196c595c562a5b501fee132aa246f7bd82a6fe500b1a1c2dd3224b9bd5d548ba9c2f588c820fc69597fcbbe583e007d3147ac34a7f74c2a30f757f3ad1b14a6804f5d8a30aceadc6655ace96d6dceabd71080f3e8404eab9048ebe9688568936129d92ed462ef7e8131e27154c4162af44032dc363b82f60070a108533abf3e8fc98e89f7f62410dfe755a3d384ebc6e2017ed55fd986a2b2f740b15d449fc41e8e9729cb91bdb08cc546cbbecfa75b17d0ff4ba99d097c4c8d636bedfdb25d9ffa2b4cdecdac9eea06f6f48ddc73b72d6c1180982560b7b0769f1a723c8e6abd2093eee877069a10bafc3102276351344d677f136743ff7fe9c3d7e972976da2eb6702b2f57af2b976a50dfb51f85267a90e0e7d2c411ccd02a663b6d3ed9d9ae817813f353a0f060ff7423b6e0c2b72f42554da26d7a2d2881372f516027e787ec0a331324ff97c6a225795672943f01742c0695fa8f651c0132bad5ab842785033b0236c0344fc74b29449d46f47ff4d9077946ba0a809acad379c06380163f92f1366f7d87ab57ef9f9d85f0bcb5260dc47fa2e00eacfc879eec592269578691c2e171f9b081b57ebe9bcfcbda193f1f4d2ccced8cfce3cb1fd63d939b1a3b6ffb82693c18e187bf3cca74d310490729ff56623ccd1a13a54ab70c1e40c5632c5cbcfb3ba5b93ae83ec620cf207ada215c4f502092694e6d984479914b6b7f19625c35d285c4cce9fc5e9aa7f8758a474be1060578066e0ff28f17e693c1c996d11386cbe04aba7e9401b204fd8f05a81ae4906d26d6cf3f40a32dab538c9887f85b85b6d79cade06e871cf45a976fd969a10fde2ab6529ca2d978d965f0d89c6c33d18bed80309354f9a8b618aab1ce8e67eeb8a1c6a047171178d5ac67a157af3c253c68b49effcbe5c355a73b4097475be1e6c980c709715853adaca692b2f8d81bbfeaca8437459345dd9343afbc6f5d35dbcebcc3e864ca818bcdf37134247415e8b4690e50823798909bccc62a2983318f7d0200bb9567ab71fcf4af2c7ac55a838a89005da6c5b32c52d203ecf192a8dc19de882b583d09cbe25bcf2260a9f86b765751dcadd1360a4c0d07c9204a7b286e4c6e6036a1ecffec34b5b0cf743e322648acd7a39f626725f2ea75dd7d7ca9a3b29da8c750ede6d6afb375ee5e90af36795af03ed30c917d0e58624dba72d35aa89349f2fe72a2706bf1e4b8fc80f656f1785e5a2c554db2878db58a100f62fe5e2858e98eb10ac1c4c99f268b8f1a1a9cd4eda42fd313d624649e03ecf58ea7791ce004f6f83572e155c8c03b93fb83f4242b365f4ae58d1ffef3c1c2e459928a3a9489f369a997cc88cffb1ba57973629d75c283e8c59a0f0df5e7d90a31dd95c520ede10f958e5b8dad16b8e4a0032d65fa04c2fe13931fd4aa7969cc82f045d2e5e3259b381ffb99557458f3e4914413b8961601cfe6889661ff28e1d6a67255625a6a1e13116b3eb9c1fa50d1f751966d9610cf62ac2d409850c5cbe739e3444f56b8ce1d0cf96d1a8ef2e494e6a2c5905039b32f5fe198a9dc724759971c29ffcca9ffa965661010293ef03866546f86e7b54e5a1d148e1ac0e78fe71b2f68fa1d99d514b049e309b92692f00f48c83623cdf085e6084448a0b28bbf507f963865f9f13d1b6d91b40460f18a926875d50041d743ba51f1d4becc58e476e1c17f6ff4bf880ce87c6d9a100a4bc57f88f7ed250e88076fa350b997d504b3f0ed7e2625404936a08a0b001e67969bfb3f72a55372f95ffffa23ff08344f49d42edfcc086a54bdecb436db2501fca3a388f0d9775c030b2470c3f97da3b1f10357fd6c11b7bd573d18b1ade4745a767077003e5cb71fdf624f5fe204b5ee7188017ebd628f703ad30c037e46ecf86f6af2a1f933ab691acb0227f7ecd04e5ac598f410990d0258fb88cb2482e6d4a798cf37f76e2f7659491a98dd080f7b3ea90cdee2993812bdfed9dbf56511b58620b5aef1561e216ec02596b101612154728a802ad0aa573de7ec77b74ac2c6cf9bdaaf537501acbb8c0cc6fa8e25cbbad8588a7b3bbaacd1a9c172186bb432dabeb9752aa4a249520210f149e54fdd25ab852560b442e4e227ab68302f2d81ba61a331ae62cb9e5d973cc2bca88d08825306d63f23aa6c0d13733f7856395e140d65d43a9c521564da3fe250fc84f535d0edba5d2742df886b41e9200e93c2acdb9bce36fd66d3429fe70df6c0966b83632f5dfabf43089c9f4b9c19a3bd155133fd8ec0fbb6422fc6bfcc7d32807d4e09f7c5d04f8acfeb93c2885d10cc4e83ed01dd127f8c74b4dd82d1c9588e75baeb611513477c30d5aeb1c6020be78f67756f85244f625ebdda0a840dafd460a15177e1f4198fd60938b6e173026c2e4e10d953ca3e894c4baf7c013f0c3e295b254c14261e2fb6b6891355587f919e84c160ed8218708deddea76cb560314013e7392b5fd2689323198598f5dbad047002f694de62f83b7500aeb1b9e140f03594a4dcd14af7add0416ac788bae0a3741842c1e1696a477227d39a3394988c00331784dfdf7d85a367edd284ddc619c627201d4d64035f93fd50307b33230c8651e00b99ec620198409eb90572d55e33910c123fdad191660ede0383fdd1baf1df6333758f8328f7b51ca69361f37ae5c9244473a50a28c7b4053b54fce18be5c712121c5b2a835d332ae8c96d8a2fdb20d32b06e076149a1d91dd671084404f2a0b6c1ef4835efa62b6d141cead0b33af8d76f2879da6db1ed29b2857da377adfd39a49f6a72f7c2ad7a1880afa3e6f3a5cd3610010c6ab2c83b056561d93f9f0f403265bc857be837f361b0996990918aa39667fe26fd09daa184cd2475175bd2b8bd2d5fef048f3ac9f0b9c84c647fffb513628369db31fe8efda50ea97ce5ad8e49fd6da27151504fdf8c049c62d8cc7f800630275d18906c78cb411f74f39ec5022d106cef612c0f450951e3d8d27b31a7ce465f697d47eda805411ec0d729957a63763ac7bec1f2da9e09f26abd1552813eeba99d458212166cc5635968493a32c0c6598ae161bd75449c4b408ceeba34cb13c4f8b81200ce2bc06decdd613d9dd9b904cf7fd92833928e509c67c9283fa17576a9a577dd0d3abf0a8c307b1d2d05a2bfa2130b0711375a7b8df0fc9e78a2173858962aa6147fb42ee5d95bdeabc0721561b5915301dab473553995206f19045bd4f8da3d147356d82cb2ec34441885444c6710eaa5a02a7d5a43e9ecc3bc448ce5d55c7536c3d03da0181e9a0dc9cb8faf39fe8095be00a0ab9d12e2db1f264c938d8c4d0061d7c058f7ac280c4f0fc92b9f70871bb6df0aec7620b92999e8e6427cae4f9073fb685ad4351f91819ed3def8ec8010630922764925df9ed3ad27d85ed66cb0a6408f66564f27cc6130a0bdb45fab55a5b333624604d52eb77a28819ff94778abb0df49ec10dddd1a04288faa663075217f3ec0badaa5cddf4eb40ce1f841d1b28d2acc17b69a5b42d165719f65be049b4fd83a25318c88ebce03a8e5138f738dc6d3ed003e2d25aaea05506131bc54bf449b37c5f15ee0e44647f75a85416307a401d5ee130a0c21ff900928aedb1a284559e3027c9d2de1da3da8ed7493a7298ba57d996a224212e80a1be61e6d0854ca911b7b6d5f48e48c66ef411f60261dabd3c2d3ecd15be67b0146384c6d623146e22e4d8607c7ecaf87459c04b7c19f0f0d36356f52b1c70a26d44aa4aadc45010f581cc7ca815de516dbf99fc1ab2d3f419cc10e010ee0fe413c852bafb813a5305b03b51cfc4ad2dd0881b2301035f7e434ebcfd130cc0a3d73166b32aca4c1dd16f4d54a85dc484e8d6252445ed2b491c2484e88f2c792f7e872648d901ee256e7b51de129a493ffbd2f3067cbb6aa81871e72f9df1bede3cedccf5fe59e362070e5120a909d77aef4d1e78fd5b992640fe4a4c2ead53d42b29ca779a76b5317b429295b59b1cb77a550950eacdad5ede957b42c51ee9776ee86244191be89d3b3f57d6b9ce85461b0f7d18e3a1ad04c2a40e39baf9a2c5b596e6eb66d2aac3b0bb38cc8fd814e25ad98d56b91af2d302fb58d3a1c6b0b94c0045819ad18cf9bf3f6abac21fd47c7c301480fc009e9c307bee85ec7a5060c9c6af7e612ec4609dfeb6805e9c8b55167b228a5750e1224b7235d0f4d38ee52c014999663de3597503d118266de2f6ea1b9cfec00d46f9711aac6b06a03d6d8b2abf78d1957d9576ab04317d1664a946e67e9193fabaa5773c21aa4241ee59ea6158ef83db4d5ae201ab9218e9478f7e6948349a8f8aa865c35bdd88b234102cad90516fc1b1bcc07aff6fbd6bf1589ba4815d90437ca247575a66c6f715c9a716bc320e5e9bd22efc18f8cb6b2870a589a89d7d245b417f9887b0dad6c4683159510e3aebe422e7fe3650d2cf3ec670c1b6c3ced0952f191b5c2b45931169a0107ee8625d8100e28cde7132e3a1e5c442266bb0def9004d9dac1e672b220d718b290ed61458691c78fcbb974dbb4a6c1583438822a1cb032653b30d848f733fdbca426823a82e91ef37d4db6225ac50ca434b6296b1822f2ec3cfbf6b84e48943957e7804b8bad155bcbb848d5862fd7ce5310fda2c9849c627bb8f9bd3a79d4202a2da2d2b546deb99b7cec389086443dc344847397797d5dc083c428f963be2f5274bc9319df91fefced3afea4dcbe919bc834c8ca58d5e4c3f6ceae08aebc6202b70219c33fc8079d3c7420a2856c5133bfa85f4e28f3988391316a3b7f2d1c60d2432d275542873ccbd668f31ee57606eadcf3242bda209972652b82f43f91c678c80e297657c6b4abac350e0aa0986f600cdf591236237e0b97c70f022948494d5f96463d702f7fe74dc129d3e8fb438c3a04e3a82f9972565dc8139764d57a5eefee668c46790f015e9ec9e704ad02ade817292d3dfa38c823068fc2a754e9668912cc437f68a00a28fb9416cdb2875fcaf9f23c44ca3a022d5be86a2a9f3d49b609e2e24d5b4365eed0f746abc70b2b3014e58acacfaee644c30bfda702c9c91482874314cb57e22234f91abd62a4c25309aceb8fd22a78e1e7bbf24fbf17b3eebe6055c9ea6483f6e89dad12587e7a730a3f7f792e01ea53934ebcae9de178546747b73fcbbb9380ae9ae4ef285109cfb000fb24cf9cd9fb797e8381a28dbba68335c0bcd2581a044cf1350cc316f0482fb30081a9002fc207fba10a46a87054d6e8771c9a1b2e0c5ea687cb02688bfbb6e7a1375eade0a46bdcbb10eb429f8ba5a34071e23950af6f9d7ef815a3689fc0ba1c670476c2cc6b30d230931619b7a31e3488b65e7194bcd7d29ede49ff8775b4b7c275d6b48bab5b3ab22667aa88c4b0771450787e0ca2699dc613ae29348033e914ba3773fb97122a92a5a386941b9c0ae1175f114689c23fa5cc531c8434a77a733c1cb5bd2976df76df6a975426000835c53f08203dc5ab58dd85fd130b5eb0669ffe73af6ddfa6e154268b803dd80d9968a3d47cd6599167d82fb5c73e6f7b241248cd0ff10327e6639652cf6fba6088e2d6bf59609b19a5d4da2c7d973cf4ed702095ca71a3ffa187e3cc5e01026e6cd2a318fa67597826fcbd3a203ad72acb90baaf4ef139d393c9a98846d850cb149c0fca4ccab4a2898767358fc3a321f32253377748bd71c6115d869081ed822a01b7a8bbb0a842e3e0cc224c8ccbefb3faea6d43084f50298fe231093026fa70c7e83c110f25093641bb530544fb0314d7decfb0d2491d30b9c677384d2d42aa4825fc1517b92a49c194c6578212cb5ff50dec914d4ffa4f8b5409d36e5019a97639f36c4aa51b3fa48e57684c9c75c5cc3efed31b6e221e1480e54c75e7159fd15e3efde7a8727dafffc78a6afb8f63e138f94c6d695b13d227aaf104566d005538d1d6673cedb94c29b84900e6738019fbafeb61a03ff8078ad926a1aacafcd3cef3dc512b73342cab37dac61760f7e9a5ecc081ec467467a44f085421c252e0e6d3f716300fec69dc3e43c9bfb783cfd83429e7d693b561662ba0bc21d4d732a01f8da9fda269b7682ffdf71efc4c6c5bb17b172685b5d2d7d97739bf92ff0d68b2b0219dd8fffd5f52e341ec83ebea0b0a6912dc3a6fb2ec095ca390ecced0f81bf80ee6d1cdc0115defc26b66ed2f7a89e9269fd70ef08857aec69d7ac4a183c5fbff3eacb2e1f98dd9a92cb3749299a8edb525278b1ba059150f88f644fc14afcfae5b237cc0d2d56f2afbf4ec758cf3032b4bec7e4820da8d7dc0e1c116775adec4d8913471f84829c5e735c308ecd434bcbf806c2904cd65f67fa5c431ea82cd616ef443c17d6d58bbbf3e566b1ef10e4e3060d2ec1cfe8ed5e1fd49742dee4b2b98a57d93efcc7d0e8bc751f02f559d3b4589691e1a3bf67228a1f2810f1fe674ee2918d1059d2e463c16e6cec66062e0545f89e1ef6fc52c309f117241b0c3923a82e322455b0d636dabe7b537fe8e5bcf90c713d2802a40414547afb4bdc969d698680c22d90f5e3dc64e6a0625caf8e28c74f8471d4c53234c7f15677a38cbb22c6deace88ea66c94c202d6e3c7c862b10cfc5dd5546165f7c2e807df56754229471c030b5f5ec77e90ab86206ef8bc5ab3ee0fc66a40d7322804ea79ec16a7ec8cf42859cd4541e2fef6f368aaa5f0c4e5ced246f295d2b55eccc8a66425f2c75c5a274c41a5b9d7350bdc8b4f74496f44972428faa51eb156d370ee2d145a8e3a59d1a9cd668a256b87d5af8c2e9c7cfbdf1a0042fbaa3aa59b99171f4ffd0e7302eaabfe1dd28fbb1eb50a19aa2ef7bd618661b12b61e2615a72d4ce18cc9d32e5721c66786a5dac2aa68a7ea3399060af4bcbadac0af16bf102bceb0ea55b6850788628e28d2d4eea3cdaa57685678ebdc83781d0197db3b6c09b52a12e04d999af149a39fabaecf997cfbc7dfdba436fc9f7eb4da39732c862305a039d036324886bde817371e59b6d934e9ec4031a6a16241ef958c682cdec6c3d71b74bbe3a7d6fa7842de1c580a2d1db6989e690d11bdbb9c560bc7661d910c5a6c05a3ea8ca51037bf435fa8eacabf184e59ca3d72de8bb9bb64e132a46de751a1a19922257a6746494a6b9300a7a8076f5cc739d8aa287e88bec9a3df7748979f200432a0054aec05e3d22b352cbfc3e964fb97009206923babc72c7a82a64607ffc870620fd282e4164e93c3f298c95d9cd702db63195b4f5f409d5cb90d8956a4b75f0fbc78deb8954bd857dbdfd33ad785b55fad494b7f600129722441d2189db270dd0f3ea65962119ce01525fa26b3a53d6b2e7ca5a0d13bb9fa74e1fab341f8c28a3c4deef22809646fb9964fd5d6ec3574868700cf6fa1ad098e61f0ad4cffe5af3afd046781fc5077cf21a17d974ab95dd45cc74c2ba8920023d2224b77f33d5d40ca7bd78c4b81c6998d9424ac4f74c29dc4c04f322c560b0acd89fc4571232930196e796d14f95d86d29084a50d466350e66d328d54a053367092bae117d724b0f4d82730887d651ae9c379d41079614732eaf1bc38b4b0eaa678e4cdd581eb37a7dbd64f7cda9ec6c627cfd60698c7739ed1604b06a2aad5739","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
