<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f73fed14f3b1c3f44b591fe123af42cb1287974f2caf1c9ca30f9c85050bd134acc6d1cc3b98d0b00929886c9b1722f4cfc3c4b74d5dc8a77992543477388eaf7a57b9058edbe90bc602c87e9a4105dcd0093743e4c247c22673965842801221988db507b0504410ed239e3b26d3c1ef3a3fbd147586358dbb33807d16df034094a6251d6ee8774daa436366dc447458112ba8a40b8d052e7536d1fa5542ca567926409b9c4c05ffb8cb9351feed69af7639a47ea98fb26ca373d712e5bfbe3c6d6b33050c4c669ca2840840a5d249dff2abdb8583e33b8f6128b7b95956173e8b9337fadafeff6025f9433bbd2bf292984a016b3f595e59e25b206b1fcc0686dd471305be0a8106567d22db05e3d9c5aeef72c62cc74b6e2ce8c295e4c6c7f2c4e4584a81a8a3e65ec3cc3ece01d439003eb353b7a6665883142939b7e62f72ef49c863e11f9baf42e261716021a7bedf7e0ae75ba230e65e857b0c749f976f5097aefcddc76e946084946cd77ac5762b8f7d77b878dfb6da8788bf6eac203d5ab761b80176a6cdc95648889ed1801e59967ca01baaaa76ffff7d98030a6cc8461c570c55303064a2de21915160f33ccf98e700caffc5a741a895ae0fec065593c06e8249e310d71cec4372880770d4850a814e50db2dfee93ca135bcb987ef2d5e0088dc3dddebd718cc895f6a7b34bce91e3df358cb6da6209e252e79a20875a9f1392f68dd6c9b8bf9733904a829ffb1a42ccdf1bb18ab6ef8b91917cc4b32118d21b4646ab71ce5217ce15002900d18d4f0dd3261da926adb91cc8d144a9e264efb84c6d5e999595c737b77752fb383aff7b3aac0254ef70b53ad99340dbd02bfa829baa50a2900ba116e165eb6948735c6680cbec3788e110a713bd80dd08af907974e27ca35fa7f2d695ca09b3857570d36922e92e13c88b8e4f62beb47054c89c4242c9e5cf3f596d0b71a1c561b6cf5c7e5119fd33bc6ac8af97659ddfc4072fe20f999d179e7e16ed012e52752ceb549738d67c25ebe1d79581d2facaf1d09efa6352fdc1e8a0992cf94b4b130cf3cee87aca05abe14438e6824346ea641f8b0fa4a48a8845dac5a71bc795b07011f5306a30f8428165f9bd9a9fd8f999ce84b936a030aeef2df43510535b658d2142266d74827e3d250101ad36ad4fedb9888060f7e2bcae9301fefefdd3b1634588a38f4f4acbf2453f92eee98b4ded8c78b83f29e288f6e316f8f02374f28ab959db188245735bce3dba1c8f08947a5125f70f76576f7230d2b70326d5e6c619a00647b274bc3145161202e3971de7b2a73b36b6f5f6e71686235a701465cf9ea598e6e25baf82518c1335662fa4ba411c504021ae0aefdf367c950565bf81371057b92072551c0e7fe535d04de08720332229ab602fa8ed689ec65ef7945d64ac20271d1a60499dccd4ca74c0fb5c4d109b74026ecd32d4f557afc70d1e5435b81b1cf1dcf1d5d0e8b265fb70b21e4f5a33d86900c032c7cadcf40aed299095472cff630fe928c32792970e96f5d4bf3df35d35c567d5da4d28d5d04c76361cfcf3ff05b9fbec5d7fee801b78bba1b2902b63e2dd3a1880d099670b3df240bcfc355ade518d3d2616bf9e39c478dfadcd3230cf6bd233e51980a3635590c7e851cf737b2edaf59da7969616d189089a2cbed021d75ed0dd547db037714d6e6fee7e6b1d32679d334a554a421733b0bd722e1c33e3bf48737f8ef57b387f40dcb45c3ebd8a99245b6242328739b0a9148f1b165a087a8ce788e569cb66e5517261c40493374acf9f38d88aa3431499852a149660bf71fe3b506a5e68e712d9038456f577cd6bb62fe17e570486811e159e213dba0e7f9f490604f5c3d56b37f7e0532eced9968cf17e9261334422b8d9add8611107942add83df1de345720ad03c3613c4cb15c79d9e4361b785af04e72b263a42409c2b46591e65dfe63c9d993eaebb7aa4349d37a27003bada0030c587746656106538dc6db4e7e23a93c7963325c82fbc49b0d0d15e3f72241e7b422193f4d7f90576e816f746b809ffc28f6b1eb0da276273de8e576c9029db2b70b5ae99136bb55b200f46a6fa6dd205553c2bc6a6b3af34e322f746c24fc3a2a6e1dc3c7db6b12817a748a5822cc3a401363f24c86e8f107dde31c102ef1d0f2a8150235889ac075ec5ee70fe7c85aa37294423a624786bfaf878ff90618a8c13757ea2f3c69eaa2e696949d179cc3d57651184d6e3b5bc261d805cce2182044db6bd20e857bf6aafaf2463d73c73f0291765444a372ec70b2bd8bb739cb5606d518d3cedb9ccf73c58c0686b32c9101268ea882e14d036d9f3e0f70558b0a16c3945f526c38f45090b2765216e3d95540904a6de36f38010e0d53b0f1873301df9f6539d33ba9df7180119ad07cae254daf3bdf0151a2c97475cd96df5301bc54e5464ea4f1fbe088a345cf3c78386273f31371488386fb125a02b2221c8cef01f2661f3f34ee88d1f88a161582cbfe45b5d35cb9f70cd2c78643d00fe292b28f62d2a9247b20d150518c7d558e18fbaec08813683638ce533242ca43fad9bac102f5a19b9540bf87761048b99193b766b20c660308ebf8d4503e26f2c4b7804552bb69c8ea40fc9107c49c5e7032a53fc6dc6b0d26636fbe9719a5b64c0316cae2f8bb8e1425038155140f18d52b672cc62b6793d5b3279b13174b37c36fb8f1191321243c63b1b858a334a65db3d19d3d9a207eb1be66160ea08ba7aadae60ef53eb5732b49610cff14a888985fd850a2e6d578edaedd1f94f084808114bbe8209f9f5f92e845bb1594e0bab4cc6fb70c2fc47b7996f713cf0e17f122bace86ffc015abfd18c4995a41a43b41ef25d5dae5959470da314bf083e2ae0ff1fe056c6164eeb51d8953498e3ad5b23bf9dfd9f67b23a39c69888424a72ed203e131a8f838a8bfc860ad46d09cba05ecf741d2d26772f78d459532d6e3eb315a6e45a157e8d18bf9ff6d69422afe31e92d55283cbb08f496bb205ead177651da7989e658966881f3b5953a53db6d191a57b747ca13d254f427bd89b86d5e7fbdd2583b9e0b7a39da55819697ad3e7fcf70ad46d0167472a600b54d80e28f11892cc211197448616e983e7c2ced645325300e472691e04932f28370f177d2a14ec098e040c753284d78f71696a95da8d2327def1d0a1ac98b6272f6757a41f5a8bab98a06f201aeb70d5facf6750f2a973702b4ee9c247b975a16ad9d8da425255c21dddacbbcfcc9d2113e27729676ecdbc9a3b88f69d5cacea1b35672f9467c3160a380fe6cbb3e5ef8093257d18cf8e3445b1cccde2228384c4a44beb9c2e436b6d65335edd31fa38231cf5f10e83c4174a23296942f8069e20609fa6499f24bf04f3f0198a40582675a0982356017a9a1b51d267cca7665fcebbefea9308a6b3afcc5fe7d64389eb3b4f781c754570110f4eee17139442c66d7e44ed64c24b804c51cbcd23b57e2fb300e0c58af943e99e7dbc1587c0c174233b6c9f178982186c2b215c303d5f59b1f1ce2cb6d5a7cc9977cdf8150b6c30c2ae36a276a51075a2aa022f538947c42db2b09264938ebb2e43cab56a46609a4a240a29e5ed5a1d917d6626d82d2393ba7ca3d506dc4f31f857409350e27111f4e53b4a7d5a006e0532a9ab6c48adae96b495df3a49d6420ddc22c70e13039b1254f2f454188b8d4495885ff88b77c83c3d9082539afecddfd5d3207d0aafa564a9e34e1e81d314a6c84503e2f7b69f67865d8a309d3e5c17767b41e107f8e31be18682197628c18197ab87e039dfa427a11f05da8823ffa0e529b169ef7359af96ea5c12677d82051021bff08ce6383d9093c0c47b4a110bbb26390d4be888baa504021744b321756bd54731728f330d6a6b052d7c119a75a08607927464a8ef9da9cac29a89179ebb7921bb0e23defd1e6d44a81bc9ba32bab549beac49d1f3f6a5b8823cd02b6e2c3ce866983f521ca6e12413748c764188fa707552e9be6e616f9de6fece00a4c151ebbbb402dd411f0d7b97575ecedfb727d35331ede1e8d994f145fad6409c0a482243ea156e094052f394f5ffe9d91e20c1a7dba31314c114ccb2c145c31a5cb6b1a4e6c9d01cd1b6d92e18fe3b34554d23870a1f7627ebd26c03ccf2fac350cfe3e1004779698799bb1494bcd3d38fb36ab6edfc7437d5db5eb44bddda0afc24d5e6c8b063c9b857ec735355f9b8706af1ded0263f902399ed6ceb1e0df1b1558880922e99814ff70647f511b4dab457f1a0469af695a0ab9eafe97424311c2eca5dd40faf32077fb8c831aaf254630971fc7fbda32c57f2fb81a6ef03ef677513b4b5e95de6e1b65cc5bb3b4f78e5ee7fc049ce74a5f13b5650eeb98e9cda1425fb4afb8c47936f1b2f1ceeca3fea525c4021793fe820a39d7cfe5a7021d14d3df14f74691d8a38234c8ceb46686b5ba27ec206898ed5b75e113c6a9813175976c8ca9d996cfc0f9f95408fd0991cfa111833f0490112fbf6879ff376a079900b1e26f6fc5a5810681557e87578664acf1d7fe2fd89396fcc4b7a0f28e16ea9d119cc0c826717d159755a30abbdd6e78da243abfa4313206e36d51db31d45f022ffa9fe3331f7eaf99bb22a4d536f4ba90ed738bac679b9c50f368291e11cff7510162555ce791f471544cce75d9b91ff263240d9c2a778721e4a0a3e89bc5442d56bf962f313bfb4c4fb4c5e8558111483841a23c6e16045eef1a1efac991b41afae454c376b809364d78fa5d7704fdc4b4f37ce666ff9bc34112fb3485978a00fcef105d1a6067835f9d3f124d97c17732bca99d4a98626e71f20149f0dc6950d44961c982bad892e781e608d96d681a41130362c291756408c75dd2752a7d8ffbf5726d4b4243ec62947f8ff7616068053a4bc1f306a65f9299a3523fbd37719c3eeef98c9e87e121168a9a1f8675a84fb5377125f84bd1c604328366acf744467e2ffa349411ec7f83ca0acf868e9130719bd9825302e617559ee12ebde302b9b2d8e64c3b775a480c4ae456f60151893663a2d1f154cb527ffe4e8f268bfa35380c99f21008f4858c644eee61ec05a9fb1a4246d28b35644bf95ee20c400e96970dcadbf4b158cd88865b3ca5c86f2713f7191ea152d3f56b728a0e9d9a37c2c73330d13f21ed72d347d8b515bead1266a6a6c9609630e7c011edabdb62b2340f7cd1c9a052edfcc540be70ff3da0f61bca156e82790a145d6835bfda5b32540f0d9310e6c9805acda55207043574336f3cb2de2d8ca7e9a54d16e99063708d0de25c5b4d5c80937fcf27ee49a70605ceef9ccb787796dc5b4103c2e251b0cfc0638e624c1587d29a439a6b5133e1d33224d51eadf84374a74834c8b05285780896da9619aa44a664c56a1f6b469e6173f1acdb4b67bc0016f7fa47471e882573a96ade6361a40a919d3b27a79019704f4064eedffa12f90f70145d08086e0dcb9645f9bf2d883f82f9328ea4cfaffb126eb9775a3d417a5fee7a249a5f19415c80d5284b9318207821fde40657a5f7c6ee6ba6ea14481bff7ebc21638b19d95dc94f6ecc174cb9d4beeed715442f9334c810c42b600b6531eeef57420c0b2f9d94308c7a35cb04cbdac90b36574d0e324eac4283ec52ce7a2acd450b12ae6f8c7e58da81fbb6c7ff2d0cb483feca094c40a7fa84a8c309a2538d15550efc7210521e16af5c1a8512e4e599eaa3b5a7397491a549d7c7dc5bf71b9e738452af2fc3836c30cf13f52abaf62ace43e4028c6134dfe24ef0566dd20f99d7c70d2f5e5bc938be3b0a511e9fa47b33bd7de102731adbe68fe808d9f88e3647c2bdda349cd3f700bbcd7bd1658476f0bd6adc36e9cfa4d19fc80dc2012279a62a1628bb941c44c77aec579e3e7c78498eaf8064aa30c367978ab6d35aa38b94cf82baf5c9e0f01309ea92f404ad13d7486dcc519fcffd974b50a038742e6655d18738e1046196b1b659530098c86d3c14fbf145ba5645829b07058872baa2e6965353be6a033963df3fdaffd496fffb50a9a083206584e5fdfb2159364517a6b923d3ea89cfb5b11751281e1b7c92467b0b3d8ef406fde9f543222f7a2744b93b7e9d107984768662e578ff6bbb9efb6586b3a976fd186d03d9c375800d79d7e5c37a55e40ce92429352818d28fe206a323d90073223163847eb32aa02eefc1ea272802b29ee30a077c85f9c2a0fc43e6544628933a8f32a65f98ebb0a8479f416880c051ca339de2d3a2999ac99092d454f6d7e893d0415deea0520f052cf2cb3376c4ab8f469a7be7ea13309230a309cb05641d41444ac0716fda43ca3e4f23789b382be8793928fa3986b2b05c01d22ccdf018af8d7e6c97ed69c3cd586ee4929f2e1f6f72014043ab7e9b57aeba8eba0a179aa00ec8e9dd5835038a40f815103afb9caf84a51aa88c0a583dc9d3586978ed760585a887a8c021eb9dae3d666b8706a38ccbae133dd46c2777d67b49fd0c678214ac488dd15d04f149341e525fd9479136a9f88de5ff34c9599a9b81cc768d4646d66875703f1c9e0ce0ec94e5684e9b6e1481b1c4d9335352798c29e7c71b5aa73b68e3f285eb6ba39f6d4567b517beebe7555e7f9a71a874dd8e444f270649f1c098033cf16ffe038adfa77dce30e0f4c81c8d5f37a3ab1cc5ff0e5fce392f21c856513480dc950953b4a02ac93f35d62b1a5ef49d56299c4d70c3bc9e1e2963e9ed3d15e6c28c507f11f45dd90a549ad0b1ca9d176d53dafeafa859e648476fcf7099e82a1b18c9be222650ccb6fcef4c48c6ff84ad1f42e9189da5bb6491ca940aa1f274d33ddc1ff991d61a302ed64fe4381214b9eaa4e14f353d9af1604f809df12666d52c96024cd11dbdaf7eb3fdfd6ea8e757d76e339aedcf12862e91102287ceb83c92b366433487604e945b43e9f50306bc8bb94d0656ee116afc6db9b96c319b759cac20329d7ff7b2050fb9c890ba3e2df3754cdbd90c9d92cb20e0649fb91c8fb578e9bee90684b2f4ac642dad48f3cf6eef2b5d6c9ec9f0bec1a59ca8be8d246745542983f6c3c82ac606982054c39911acc8e77efafa685c1a6b220198dcfe21836616a2e834b6faaf31f5994933ef553f293c14785514d071354b655a37b5d40606bd2d4338f6b6b339d84cfe2a17be6cf34c35d57ad37eb8a88b3a134cc61bbcef96cd61b5d79678fd8bbaacf8ff807ed65ffc1c4cb3ad249398fb2a56c339969ef56a9471ac00ebb69ac5c18dc1305f5a04af013ea7ab03c751a1687c366c47a96eed66229acbbdd23c5d967a1e40df5d768dd4532a017ea2ea5f57829741624a45aaabf917febf9635788dc0b133b90f3bd4fae5c249c59f48c098852a37bf5017c2b246f47730ba3cfb7aa195e4cfd2d163ea400cda9dc6dcba1c99104328c79bf4399a96db66752b85d1a6f1bb9f67e2252e5ee5b14fc80918b61a29c498bd9ca5424e657feff31b2348812dbae163c765412a8b6c2a11f2435df51cdeee521b6bff33e25aa36b58b3da28572de8b05cfaa633d0f6d9714093d39c0760fe29585325337776e274ba4d97c0acbaa0f05e7d5fb776a0b0223c3f1f21bbeff276f32ea5e45e3934462217ad185b209f33d9ad1bafe616d88dd94ebe7f27763b035e8b78eb8653b2240493f88c1ab112a938e79b4ef1908e0ee1d516f720801ad4e45da75988e1a6e645c9d8f880f48f48a3bb2d7d3b56462d583d5eb0c225904c6c86c3a6ce1148e061577e016b1275c36b33d900102b7d13044064722bf2bde05af1e3891027958656e2083f1ad3af30015593641a08463376d757b3c0e7c869de7420ce1286f3cfb1361d83b24a7e202c90d4292e3f7c7c3a0b16f8d398abbb1c9a78a7a15cd160a318850544cdf6947955ed833bf22b043525bdd34793aa72716fbfca21069ed152f9d0c0ceefdbce3620b63724eb208462912898f509778a79e1e16d6d10343cc9600a04c7bdb6ea1d05b6a400f6dc2cd19436c0382d62a58030e02e744da96109d2ee19b9eabf6a54fc691bcf3e651938e38fb3bc39d7ef7e9f43e1ce9c5f81c1d58672b2706c0178e7c1cebdadb49e594dfe5dd5e87570c3e1d03a1fa6ffa628ae9d1453fce93ceb251f404ffb3936662e999908b5a93b7e89a2ea13cbc808d694becc697ad017164105c1dcd813ca197a3264db80939e5e0bc024404ac2164bd7f85d4a60abf87e199f4a95fa00f28218554361b6d512f695d95a45788022a520636f0da7e4df5e663dd1d2f1d7eb05518c6c702c8941eca676bdaf04a57d584b46c3fd54cb0b96d7e76dcc6f7bbeec5d914c276904a7de7709ad2f37782c69e45f3b1256aeeae15470604b6ba5217ecc540b4ba6cbe9f7eaf3df245cb6fc9cd3814d453415e48eac9c9b11348c663ca2adcb02cd6e55d125c70e8f510bf1cc39dc4eefee4f18011e236eb37d3fe2e907740d1633deb84e260592dbf9437a5810dc4eacef5fe00452155c455fc87d49956fc6f3f952bc7b4752b594f19b47e3996fec04c3b004cb1dc64aef7e3f64e60d7b705459b5a51def23fbf6c888dd6ddc4455bb715c92dce07bc47a32886ce8b82edb296536ca46154e2c767cfcecdc99181b7ca0ec023b54f4d7f6ad6ff95f14d76e44fe6d5ef7f1e596085319fcbbf418d2e483d6aef557b02e5524274634688c7f49c5b821a2106603fa66f19172f307eed7ac527e2c8b68664f2ad54988536941e4c3b139bc3a14c885230f3141f1cf64579131d8169237e5f1dd2961419587e815d7c6d9da2971b8c1a01328ab9f5e7249623cdc8f29cad7a84403850b5689f40f3c0876458d0860d7aafe787c5a79c543a2c3f93fc4d3c795ae90587805db44b074f9e921e6528bcc6968a89d056dd1de6b85cf92520d08d080f73ae964da2934982c1e2eff8cdceca376b33cdf09226ce663d7e5b741cad66fc25e3c824fda0fca9c2ba92c32ff2ae8762f3e5a6aa9719d97fbfa65464b426144da5c8f0a0ee35808c5690d111b7fc22f158bf94cfb1ebd48dbfccaae9e2a777bc330e1349b2cf64a335e1a52f6165c6703915f8b8cd2ee133a9457a916fea4a62f66671f1f97f818c0d962e3b9de070b82726e87b2e7ea7ee3adb00587df73e02e854e2f427eabe3f0dae220d0044fbc77218140b66c4fd863a5efec9113a29576c02b20fc1e39d4819a016f3e37f4a84d4058448d928203dc28d014c44e8073ef7866aa8089f5f62a754e8286e6179eaf721dd6ccc160debdfded78bff0ed2a3f846b01dc7014320b14b00002e0927ed5a00dbd2f39d29501c33df2028eda3a45e21456baf13e3b2cd82f309eebee4f95493aedab22799069b084e875ef5a5cc6ae4dd85558acc7e90ce231f5f49eda5419204ec76d9336429bf68b9b4e02312b112202c436b393820f0c43522731d36722c9a87b2a4639a4bd275f2709021a5f3445da9e3dc548ba1129e84512e976f3d5eae389adc07703839ab6ed23d810de55d235e24479d0f5483c892e300ade3ea5e361749999c00c54107ac989feff0a29d8556eccf2b9bb07a7a57aa818b636cdd5f6f47e0fea8712518a1bc32b7e19f6440cd71420da06308e01c64bca2054ac2d2085e5a3db63511a6ef3a7886d79683ee4e4b9d37c590570678e405432f12b3744856d5b87dc84f0f3b76e46c0902fb3ee03882aeb354a2f28f7368072346ef996c105b4cd678962d78793cba81e1e12b6fb62e1ec06c7177f635519b37eae034b88ca564d309aa004ebd17ad6c1c31c6dc7911ed4fa169a03b449fb518a83b54fb1da95bac0fe37e8f7ae5b25aa0534151c705f7e7cbbc39a744862af27f2a5cdc18207c7b65edd4b67e80ba7fd6c7540fdf9b911757e39cc74f512ed6a4c6a616a9872bfc91ad36b72277cb6d10c2a19fc43ba144b1ec67d90c4b1fb0f798c892043fe998db9b373e6e6d7111d2796913a6a7930214dc78ff4d65d38158c5d5641c352ce437ff1f5296017ed45a4d30d6873f525dcefd2a1eac33fb1ce97b65da88e6c5c3e898318fd83a1a5b4c45bb0ba94c33d32ac5f752fd2f361f16720b679ac3f36df6f6079ba73a53a7f762c07c8dfed9e33888d0cf0b681ccc69046184877a7a8c1dc1878a5fcc8962cd0ae208c5216fc0f40a2b49819091a0dbabd865f73266dfdfb4605d92a9a3b98019ad992400e9cbd68fa441c1ab4dc9c3fc9c3e1bfe8bbbe1d1bda95ae86a58476200f40ff370f068586d972860c0d5360577ac2e8448e84fecad46afdcd3269ac5c281f98294ceee568bf2e4fa422646ee11e17e71a3b419ae280cc79356a2b681afdeeebddea6dea203e148949b2db6a6ecc9c21be2943cc69310512c7df97340042e25c954821cd69f689052aea98baed838e57f39a371422cf391d540cbdf80a502a181873865912be7efd7c3dae5983fa4d465bd1fa2b41daa81e717d3ea1485c94cfe4ab2d9cc663decce0e9f40c60f4c1cff8230fdd3579bc568238247890d6cac4082d2b6e9e2c2dd437a977251b543e42f8f04042ba51f894eb8d221c8463d707ff22f0b79aa85c3b1d5ff2927b042a6d339c4b921dcd46063746ec46b9fd867bc4937e2fa39704342d265c9cf7b81f6a4a2ef9e9bab64cc02f7afc0c226168c235afc16145c23026c3c76d83b1a51bd4a92a29b419395d2c5e2965f3dd80d16e9b5bb361094b79b9eb2e86a3a0c41e5a03c0f26288a244fc897119f7cc6b54051ba780142a6ea3009e9315614496799148385623f90aea7d93e87295b560854151b2dafc7d72f12582c5468b18b436fd0294cd14d2042dc3ea6761461b6036128fff2e8a327ddce47aa9d0ec76da55c7277039be01eec69bb9dc8e90d7fa01f0ab733af55028877e21b81afb9d0db55934d35e733f653036eeb829f99670da30dac2443e3013094ba048bbd71477953ea5560eeeaaccade8d687421c35e40f52db027077e420e083d4326657839d17c794f8683094ac09f0c0dc48aac771c288682524f1734571c1e5f53ec1fc87432e5a82aabb81d277c76158cf2c7ce2b40b78b4ed9a6e6c4c536fa8ef32bc3facdc4ef38830a3e05091da52147199632bbd2c051c7ec6682f3593e8db1c46524ab6f3b2e3ecf4369bd656e8fa1e5767efd6557d20e8885d869d5f38d12b855c64d2de00c26af34edba11c9873ea2f55564cf04c038e4808422a74b6637343d2fa13f8aef24bddf2b027fdf2b318d0bac3c840f65dd78001f5d351438a7d12c83c47be44968a673473449281b6a9476d095ff46e27e196605ff6b9780f79a4e8a33d9e6d8e6d2319168a5f552fbd0cf95a4fe93e7542793b803676639fad8802b0c8c91252c9df6a92163b91753ef6cc29d3d20d7b05bd397f508be79fe6ea979c79b18c2a3ac3c775c484c65714d152b5c0a00a69b346a0899a5412fffdf2896b3c526076ec8de4923314e0d3bc0d32d9f6293009bff4eae079606ad6ab9ead14d01bd97d8a99a38cae8aec56895f58b59c2a2022a1062fe4ac1cec27ffaf4ab05f8db53ec119333796fd073c5eb9b5274ee2ed6f202ae6e623a6abda2f9c31e96ae77ca546aab7a73293f7ded3ae0abbe62dbd43d0f0db3c97097f306b15d19e3e7099ee5db1de1c8b97595c02d353a8743989bde439487d3f7fea00d4f05c45064eb5dc16c47ed2254b7051c6d8bf347448ce99902a823f02840167198b77d5105249d39595bf6442edf3ecba7d9202604f92dc533fe446b6b8e7f5e6886bf31af5ab98c83dbc8918551b8c8c781f871b4882365384ae96482f910abba55ce3e7fafd0aed9d2d85e381de9d790c0b3c85b538fbd4b6bd7112d524b23dab8b94f5cdf0e12ceb72b1a0d2774d4216ac0a4d7e798d8c705f00550458ff5efb2516056baa9bb0e9cd70d075d1f15e93ef5ce3690f9e48e202706e226089974ddd9616c425263ecf91433ee0df83762013f1ec63a253392157a6ef856b3500acfe7cdb5232e89cd569195b8f1a2ddfb8a65685fce9540bc95cfcf11e8386a54113bddfb38de8e8c350aafcc93f9c5a91996e0802d12bf1012ae12aea446e31507e73a1450adc741eead336bbb738332ebf098e153d05d9b374976d0a057a5d8351b23aa81cd83245c4c5c9bcdfaedb1f89c6f67dd34f9c6129974239e8db047816fd38048831a5e695bdfbe6e01c11ed77dece03cabae28a088ba0179bfd2c926923a20cb24a87cad1fb7319abf5e1323d2ca22e32ef4df6a64b665e123d246addf347b1b5b3479217ca855909ea04b6a84242c4bb7a2015d2344bb16a65bc9a58ad19c58afded94b5c186f17b1c04af8e8d4b4e86b9bb78c72347e04d5574762f070d4075cddb38855e05806649ef183077834089872d99a12b7012ec53cae9699a0cd453a61c2d0e7c9dcb197bc2821d8756d62a2516c1df8aae292205c827f273f0b4b8451778df79a3e9e3a4c263bdf16256a8a485cf55847244ad710ae43ba4fbf5b5966891d504746c7b4686bd9b27fd11d83a5d2ad2f390e6aed4ab2556d859da1ff8a4d45811986264c3f2522aa7a824b94983a06c5e55c2537226b14a8ba79900c24795c58a2f4256d852b73c74958c27f6b4b0ecfb06b00f7862e7ca5818c55dbe3dc7643fabdc146ca96bfa3a02325da755b6ed1cc630e29282156945b738c9787f7589822c0a87081a68a3a8da662b8d6e484fd7e521800d0dbea9719ff28f4ad05ca3e6fdbb4d5d39b9dc34cfd38da5a914d1ecef190afada550cdf8e5884cfc2985225dc47506dec82e8cc9b83c0dcfb33f131a150ffceb64660675353964b44db0a5eba463ebc6c901dae80dc672bec491798d2e6888e6d1ce52f08b00a12dde5eaaad16fe9050700e86b5bfa29ac5d1714fa266d0df4e366470894863d4977d751d79ee0ed6229d6f36511f54f9d833cc16efdb810d2f1595f0dc0c42c55b10c1a186e8e260a255587a1e86ec4604214853f716be0e412910379988144b3b34edfdf45526c0298ef8c6aa1968a7f2946c581819e4cabb0a582be2fcb36ec24ddb1f0d8c709c6b35ef19ec5d34bc525a025c0e6a89eda060950bcab7aa295d70e7f6b38696ed3d026213bc7baa0f7cd30a8e66e75843543cb6d414533b087ab6d77aaa3a98410ae7f7b1c04353095147e9eb0fe2cf7f132958da1ed3805c51f97dfe3705971a72484f7565d943fda205f001d5cfd2fbb1f231fa30baef7c39d459d3f95f1f3a22f02e3561c57e315d0df19bf5372bc0b2bd1fcd898cd3d1efcc44ce7b968aeb29a86e3782d9355111933db029ea726afdb624f31462530b90017e0bab1f496d82cb3660c44b04cb8b65e88d699ef71c3cb3cc5186ef6b69a305d8e418e926cbd047c831bb01617389e0b7b22b6b784ebb8f0a622a8f1d70d8a71351a977c2e8ee2337fdb7a94092641b9a1552084ec83b83f43253ae09a36e1487798e7cb404efe710fbd972f925ad498e383fa4bfc567858de6c6f64527b20e53c7009221b60191a58c454c24e1c143db40c71e4e02f3c7a092436fd058a3f6a2cb3a29aacc7b65acb5d2fac19f6a0b9ae014bac2c755a75548a83f926e34052993d40cad22d9259a315bbd024fe345156955de243356186cd90bc237634646dbfc2451a9cfa298b91a6a39b4e85f9be3575a845f71611b9be60dd2a72337150ca9086819260e197b84246bb8c72f8b213b71909e58b51a11f6c457ecaa05ecb4c9a94add902990d9b006c643718b07c77957381273b09f09a7c6601dbc96fee20bbd61bd3ffe6aafc75ad0df493b87f7157bd9c655fe35ceb127c649f73b373281d4d6b6566ae2873322b714ce8d3e267ca23daa644dbfe583b0cf69b2942143cfeb2e62f54564f44d31a3f7e7f13cca06942d302c430d0e088e0f7edf8d3357f91e0e11e33868f143242c8b9fe4f7a483ae29752aab29aaa151743d708361e581343c2fcdc691d7044ea6e33b4f6447a5a6d12996820ee2f977a7929488175d8e07015caa2a0ad93290e35e0cfa10f0b64a164a8ebbda82644a7998f52aeffaf7f94d8f688b834f04d2b7d7c10d7ab237f42056f8837681af57356bbd38be7afddcd1b16c772aedc3e066feb6ca2df8946e1ba668eb7b14302f99889632df4ebbf15df9dc02c714a9dbf876b6a92fcf258e2dbbf8979a199a04bb39190a453c62517e4071c00e8ae9122ebdf705d368a72198cda6199f0ae5d6814f7c4825317d767f523d134c9906c578018774aad4784541de9f48a33f2cb728c477cd6c54f67b0c74315e952cfdb40421ae951c5737feb8ce1511cf7a61ccc070cc42a0b68900b7403660806ad2dee8f8bafb7ccc8489367ad9bb562e11ddeb4d927fc2292591319b478a5f8aa63b85fe37c3618fde3b83ecf67cd790ad33c8f4bd2044c6d556eeae35bb0a82954bfa20769c73a2557ca8939a25c0851adaff8a70966b0eda081427edc567a624b8cba53fddfcb72be8515682a1ac2561222924520bd9a96b5350023abd88b49ab4aa083264d444377bc32dee60151fe522d238e26136d76c82ccd7f6a84441ac989be6c702068b56d7f1ed3fb83cbcbd00a371caef06b8eda8d4d01c5ce7e0ee43383c49173c27904014f56a170911a36eb2a08e731391a1d01ff911decdaf48471c54039ab6dbccf8a9122b0939cd66357f4b5c908aa8c0f5ed42180662a5c72216aa31cfbc999d406da90e83fb9adc7ac8e9a6d1f016da905fc23efa689c2349f79b36f5cef73dc45e2efd50ecb50aaea63059a09701662c6ec06472f85312ca50643039fdbe5b0e0114dbda30de911ef4adb0a8f39e41d3687cdac89d524eff99da398cfd6e7f3e4e81ba829f6a4e4f2b98a38d94f0ab53c00f54f2a8760f555024a1fb7f7ca188b9b1c497f4590e7eeee633f020e405fd2e0fc79bf9eec956f023a925c4a4eec25f562a49bef0bfde6e9f32ce49a981f5f3a331bc1a90d27a986bebd1c8f748d6fcc0b5efd2bc1d618ca163c11baad613cd9cafdd903350dea6b9d7988d61374ea91a86535627b31839f3a521e4dc576a85e69ad2c2d20898c297d597a8ba984997aaf073097ca936ab9520a740500af9a700603ad656d5a2b9cb41d502ecb10904d23c16d395c814f7f030dcb8111cf30b4162c30a9f1e017e023994e28dee7a7d20b7cef3d9ae81d128b16bf48cd4f88979cad27dfdf7f211bdc1605b53b6c471152cba07fc845a259c4f499ddb96c7b6ab84ba10a8a841e9e28bf71ed17013b4bf39b099a847353e6802fd020d3c115c21d99d8cae9f679bf6a2aac1e34df0177d1b4f59814a09c243a740ee62eff667c6a1bc371cbb8c557cffd602bd36a5272978f6ed8d7ecd5264641b18fd9bdb0049142fde4acfe7e6e706ca8c5d22eb7e16043cb0a7999dc5a6c0bd377a2acd73873817dcaeae21eae377516ec498b01c409d28bca170470c70cc3f143c3bd3212abf0edfee798610be2ff96904c90271132cccbca0d25ac6b089a4fb29858c13f687292ad5fad97e628e5e577fb82fef3af2acba3c749a244c4de44b5cb07ca882da603cc05b7c1d30c591d1ade7bc2b099cc835513f31cc667b094062ad39d7e4a2c4f1a392d3496a6b84be53970e87be0ea04bc07847d4eef5d4ed5a7cc6b154d463989cad842e397a9bbf6bf05e8092ba6a056905695a15d2fe0453e5ed4858aac27e20113fee599cf0645befb816832f27c8f867759eaaa391f320677eeb430a678d90bbf7bf5f2f604a0bd33b5fd0a5c08e193d3fddd2a9675fe1e6061897e30d1219923e38eafba5cf5046fc10dd801d3bc0694e847aa32aa4f3f0f349b09c6e68c7b9f367e9aa2b1b14e96bf35edc405428a8cd83f6d1c1eac53ecbed911720bbc3388f6ca73233794e5296e9c8b3c2e90f6275514d71ff0b938da2ce7ef7eba54aba59968bfd945c37ae05288c8f2a71c8d9ad98ffc614efd9aa33f6d3e80c921c5062392f87f62b726328b0ea19d9637ba69411c65c8bcd934ef07e33b27af1b3ca42c37ab1652b83098858f97ff1c06278665b8bb6ae343aea9325dafd7c4d1cc7470dc9dcb777d5636dd7674b5fac816a42879412890128f1a17c31e575327b30c9e7b26676616a3dc426ff26ee540639a27f69a51df5b0b8022b46fc71a83c53e89bb327b3f4f06e5961f12f2eca64ad021056a22da382ca013e34888478e03954820675bd3b304282abbea5e575066400a4c0203571c1b29114e9d12fbb65df0b70cf5abdea62187fa88bab8af7ed87f0e7a6e8a6379ebca3a5b99d82e60199048584b08233149d962e16769ae0efee839b86182c414abef413451221a9d5d06cad725e7e2509b1d22965d0c313fbfe4afbe0ba1861d66ec53c6474ba143eb749fcafa6f67336c5a15fada1860caaeb1574032dd1c6a9fc3c0bdc74c21f3fdfefef3d5add8f1e81403a4e50bcf8d2e46fba4ab76b9e51ccca9183b40d75772e7e299bb42cc5489fa4565d015fbd7e0f1107746bf1accaf15e031e3b5f3be1051c2c65a900527978339e77193c9f0be72d09700f982aea54f25e5bf3bef04aa85116558568f0d685eef9d8f08371f127fe083acc13717c4eb2c9b41a49ac2d387481a3ad91b6e8fb6622837e955eab519e0e1095b15dd536c1fd703f716d36f4b6a1860290065ea1fcce4dc95cd9d9ceb57042df89977368a2bc33c17d8434d1fe74ca6071f78a798285c3b4d032830b3b95e137182bddb5984a028676ac4866c5cb7fee7f1be733311d35d441d3d31b3272739c6b3c0197ddd12c6e7dd7eeef33d64b62c433e4325f1e82ba5d099ca65489c02b05c36cbbd8965f42e430e2ad7619372aeef45a0690049cb53791a72c7465386e12b96cdf53c57b45ec9569dce898382651c9a77acd07b74f0885ffbe9363ae2f931048e916ec0ae1f188a2b34e763a9c5245519a8458e74b0471ece1af1bf00fa9c88d3fab1a28b19b6a5264c19783d19fe0ac446afcd01f451ee62a1dd78a2849dd250f62c6f28131ffcf9d0823a698a41dbf947b165aef676383b6709a7a7b423475a7a07dc3ae0ed90ac56e939040c26579c608f4cc851714616150117ea72a8ebc15a51664d28d4637401669cbdd595dbcb3271dadbb4f1f01a04aa39c24a3a9c2e92ca0e0b85a418fbc34efe6dcaabf2510c44f4d40e64ed7ccceef43097c202b69a0b4a061485c0875d4ac18571a0a449a901990c05bbd5b6b34c3668f3ff08a8512ae6a8f7ccc85df470e38c0f98c26a33a69b9a8b3d8c25904eb9dc1ba1280c865b2e2329381e3f223db1dc52f64aea158cbb4d588c12d761e50ed6498f54d58c8799085c5d6cadce13e49675a5fa6da577ffb6288f89eb948c72371fbbc2a15e268b72f283605591862f782cdccc1f1ea8c324cee2d503e3d6e70f4491bc51470eafa95f3acf4266910ce790e6e935f02b62e0a7d758516862a8990a6eb7a17a320a3a373b822b092e5e42f8ab5410151f37a6ff833a5a1ec041d6f827c25c55f5d8dca510a5daa82341b5beaeaa3ddaa45cc75c2ecd9601b7fcc433f08022b906d6a37b3a9b93c20111f56c385ee50ed017a6a023edf44dbda39a3e825300043685f1cc003018ef7c37411667348429967fa41da9f9fc300279622282395794bcf7116dc4f7a70b45070538848de7cb59df78084de762cdc559bbfd20228795d2307c746f065ca171beb9aa8515672b59c3c17779fd8a6c30b0307b9e81f69190f4cd0fd92c8fe2bf80c8a5659069cdc7b6599cfd7c656ad349f3f6cd3cfff3a0ee3a8419baea1c4936d79adf23ad18060d3a95d6f522bb3496b22696dc06d9e4d3a5e3e21fd20512b0b818b54a27fa98503f86d1798578577b06e46cb0a0e6fe5f3e7e9686608579cb7f84d245156e0d014048325fba9fd8a42ae420c271dac782b14efd5727bd887dc9c6abc36624a08a8abc158ae33afe8cd3b556c95c2c8ddeec056fbafbc3d4d3110006ee9893bcfbbd4057c8725bcaa4bc41c281a2391a999be4c4a9fcae4fbdf097c4642c38ce18395936b987b4aa707ed9077c44a4782307f7177a21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
