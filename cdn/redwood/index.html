<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f19c35cd8e521e8d2a22e6af8daeb0dc02800d2c84bdcb944f12383177956ee6184b90e9f5dd3477985c12b6373c50a831fd528bcd51aeb234b1a122a81aed7db4a8f4f1a5aa653fbcd213db2187e90e3aa8cdf3f103047f306b8b76d1c4274e4e96a243422f06fdc7cd504f412d0cbf1b41245ada3724fafedf7e33f93f018a6362431f971d7ca5ea76e06393cb29cb95b4c2dc403ea092fdb361e8e6db228a5bb0a4746d41ecf8e4b693e29aa1ce03176f844f4951c377f2c04206cb30a07c310cdad798c641a9f8e43cc63c08e8f907c4a52c727d3f992be3195487ede577b7c5099624227bb5a38c11dceeaa275da6d6b84c4ae4f9cb578c9ef314e1c3e9b6b2e0e405940ddeedb19dbc39e80cb464d76397a988e651817bd845c5fa8076eabb3dd4a40e1adbbf1e801e8011a27928d10b748860eb390b8aba04dbada64ed37f8d20859b82dfdae4829084683ee96917a80cc36c7f533eb1a58929c350d27a968890eb3861ae94d9f625532b9a71f9803dfbcb134c6fdee958d075cbc6eeb1633757e91a7b17dc7f353a24d80bc5a9c33694481032fccd1482a423f1fecd1db70d95bc32e8919e521cb4235f639a24c16572feb7995f351ae1f657c46d1270506634194950f7f47cf0db5c8df4953791ae13a045bfb53bb0e1cca8f6fbcf27278c2f7aabffb944907144988efa528835a90ad4d18f771138a4cdefd4ca64abdbadfd82533a0d1b51ff179453037840eaab2efc48c9d15cbeec6cd8e22ff33b307acffae03f00252078d77553d11a7ea1c2f510b1f32eebf6dee097546a05dcc535d6f2832dff00ccd16de17e9bed2a381e12f41f5e6b52ca40599be508ff7c6b6fcb51715e6e7a05f3236bbff1dd2df8cf32193f179e77521f5592a182fb0eef929e2a1f38959cf0d9012765c549b0bf112791a80319a7cbf09cd3a81b312153bb8b47d5ac173717bcddb37b51def40a704eab51f25a0ac6a74f852276e6fd11f45bb53fb0b77694f809644298c9dc15374c50e38cbca706eacf8a87cdfe2027c963fe2c142ca169950a01f6f2f5583eb50d61ec08d12aa9cf56e902c499e17461d4b24fd3070e5a081e906ab19a5e83c98c88988a3d73d6567fcae9279b66110c8db887cc7628332459d2452167f7a1d548a14d48b9675036dbd8cb3abb353ff0ab8f10f38bc82512d364b231900f1b8d83811543391a9e61904703db2f9eeb131dffd9f8e9c80a3b29b5990d0a3f8ecb959fdde443e9ca0a961bb8027368e9608276adaaaabeed0d3a406a69915f6c5381d047b2c7c5a384548b8970b4b9d2cd497062d24bb37827317cd8cd4bbca4af5c7f1664bb060ff50d90df6bffe3ab70db275582b5f58b6e3a653c89737affa79adf12c3d2777d3b154aa94f35f650e2778926c985b56339137d0d9255ba5c6b778262712834617a9d38bf4615f0308f372faa9c6eddb87dca255c0b2337845baf70efed28f13ff831ac51efc08cf15e8222ce9914dee4b591a9786c5b5cd686a891feb2990e74c045226ac4e4d22acf30c71a344078ec17b9657fefd8df0bdc4fc2931364cb41c755ab9ae02aadb912ebd3fba7c2f4b35ad214e993867776958909c628f0316b336456456cbd263561fc5cc3105e37b31a78a6a5f6fb53e081c37333b6d7c6119892d2503196c1c698d8b2f8302ee03027bf7e1de9074a8e2327b7a98df95d31f85ff851b004cc8beeb874cf15dac1eebe249c05eb7bc5f344219b69b30d15ccba84587ad5e3b8a1c54fe77e6f2917714905f7703dd433caf9c782fa62ac0b47d575683476932db108a6cb99d7ad672d6959688b5514f6e9b0a18b46e0145ddba381209b08b5cac1c0d3788716ae12044314fa333d8e5f7b0d5ec5bb19b2733604c5f0921b1a3c0878d9aae334298f7d9900070fb0d3554e9d0a94794d698498633822c740e3bd2627415aeb5f1a54407737b5e180a3fdf10665f4296e26aa1aa151d0c5fd9ef19bf18d12b21c4b9f775963a43c8ef09fa11e4dd6e60034483365931cdc4b1d3feda30332e5b1572dccec3c20b1e3d75976146e6a5c92b2e33b4e8622277f99af85cd80ccdf67a81f2b8ea133a306300a39d9fc3306bc5595d619e06b706a62bf3fe80674b5d79dfbab6da61f077d329587b0c277a83f11d3e192773b106957fb447505a9ae1328ec0a732e3c00f972e880889a1cc335e566d32f1cd092d5011c5f2e30e0a457c5432b92262ec9cc858ce7e46506b190755c686ecf92c18bef760ec38aac1a4d47eba945c75929d8b9a333754a7bb3f2a6e3b6b0ca4698abe381aa58682276ec0532e504ca98e60917076e3d2c2d39887c7eebf283cf7c1fd5e3fb096c884fb26a7dd50bbba2bd69a9774234cf073b064fd5652768a620620ced4e754ae19a221b46a578b89b7536cba2e3c57d58e67d869b6888c106de13d9f73a5618000c2ef7ce4304c2da87a162a01d04db44c93078e2ca3cb2b53b449a59258e993e5f6df071624fd309123b93c06d2544e12f39f234bcecf3755e4637a9efc35887e9897c010f79a6f3cd1206df2c58ed77854bc58f02fb49f8ec1fd8046f985b0e7aa750fac0c1d8541313c9724de2a65af2e043b4389ca82f2841f4e100026ee0e0ee0fd9996d530541a75f542900f1bbfdb0c78ce5ef6eac7f6b581a54f9cef0226f4ddf897e9762a4e2fcaa962dcd8acc9cb96e28fb2863edd5183b59076a7649e131c4ff3a03fb7fd798ed2b837bd7cf701a2dfbf596bf2df1e4c1845524d1e59a24fab6119de2ac18dd911862d2c3a2f9e7175bd37159536d854990caf35aef72ddc68e52807131c9ab92b6ee58887be2c32d26ab3636bb626e6ad9ef5630811a13fde5e5d535b5a324587d4967a022e6518c94a2f098c797d5ca7550be9e06624a3042d72f104238d1078ebe7798dcd5680e0fb8e2d5a024c04005c786e1421ef3b1f1ebe520978a7cd803d1ee78e490b773dfe900ad09792ecf598fcfc9c6a7ffbcdf46a83af1831dea29f3ff919cf5b0ccbccb34a8753d86ee00f7897f58b3580882a89f742ca8fe84d0f62d3a7de1a613456fd21fe014c2cea98be39bf81626898ec597fcf5c44e6b4e859a9dcc0b6cb4d3533e8b07b87dac8eff47889e6655938d3fb455d0ce51fad7ebf71ef83829c6a8555e10f3d58fcbeec18efa7571ffef8eafb14f9051bbdb052ee05f1300a8274168e27cde002a5ad1e0ecb70834914988f23177c6dbcc4bddfef42cd4015bb14beec918eb6557d6e448e31eeba43067ec67e1ea908e226fec55e7f162713099e271b3876cf8314aed9ebe9f7633c4ad181e2fe663e69c90f01b7a54b6f40cceae437fb0a38d43c54fdd88aa2f5dfbb3d841c834edf6ccc4fbc3bbc19805c1e7da1f05f8b055bd1d2c0fe120540637d41c36062532c6d0202f67af6e1c4c4f58116fe237828beada09519e1059d42569337a0bd888d211ccfcb3acf3185fcc72219d2f92a24d37f75d26a3ac6c1386015f17b19343df6d732f86ada51729fad2d5faa333e67fc73254ca6f32d034a9ef9e2a1d20111ca890831498edf0a5332d825b14abaf943720893078c7b468f076eabe163d23d00f7ed15f269485ceb85b113036d03cb69fce8f37d5fa7a465e5aa42990b478971c9509c3cc971e356c5102bbd2e66c063ed3272ece80996784b477856e9efbf5ffc04788434c71c3e44c6e29237d5e07e67a1b50bf5a4c66dc28bbf0e69a066e0ca58ed8d6d6727c5671675034d78aec4022e343a443070688954d77a666933a89961f7e62cd737e41fdd0b434240cff64545303f75985a15c2c77d58608b0d0dde7820b7be26c88252ae2319207c07bba46b0832a777407c11f069a8f48a3f0a365aaf4a127bab0bce7213803178c51e9b4cd6527d32fa16c14b4092863136c12b3593cb35f7f09d044f2092a7100921c364a0dccd4d8845e27c4a0ad8fea17d0c1d90d6638ec04df2855ecd8ff0498be07704e17358cab701134bb74c7abf56671809a16bbf7b5d2f8cd47066742d6004818889f0c3349ada862e48fa6735f8bf4509d66554fa5c696098164522902062f465516131e5a8cfb30b9fdf845c77f192a501130f95dc87174ab7dd3c50f27fb55e0985f3cc802707ef4bc5dadf1ed3fbbbe48b535764cd704ebab8dbcd90c2c6d3c384f985dd042332288b969a9126c90f0fb9e1b55909cced48787399148362bc65600b0b987e6cd7aaa02d05a2683a9356f9914d982aece5b57d8890f101aaac20a5af1c1032a9a5a4a6804d7a6df16d773ae82bbdf1fbfe4bc68617fb939b87c540512318690b285aeae63fe69975d3b065d3f5f945c799911f548fada6787ae065a13839fe3f5336d46d2f53fd2ebc28ce57e7d2fb1e2d693eb6d35d2f5c06d58cc546b62f5dba9bccba47ab9db0b279f72199c670cc6c4acdfe14e82f42275618071cac8537f76d1a2109ce30d9150dda293d72427c2893f5a261e4aa147a21a3aedfa7126d940f17eebef5976e013df876e686d0cf8e343aae75fbd0b89b45d1afc45e2746477b78067e5c9ebc9eef615f79b2fb302478312029e711d301780ddd413f1c4af37af811e1a0c3faef79787f3b2e9f484306bba7c0fe7c7b97481233d2112ef601f3246836c683303b817a6ac3bf092948266ad5d52aa5562971aa89346761c0fc428fa91609cf71bc556a17bfcc1126dd08140607ea4b4d0af54186403baf81465dfc8bda444e19156bfb9f40a71b3bc47ccf14be730c40142dc96a929585fab0d6ced0abac1f4dd45b6281538db3d474ddf8fa4e279d90b2d1e9ed6b0efe7b7dac3d8e2f768af4482f3cf00039ddfffedcf010ab61f7d37d8a6d7159ca4a39c1f1a7c925b0db727ea1462f2a4b9a088a8d7d9351d5bfb4788d6ef9c8c48207b239d01dde8bbed332940977deecd4350bb5550dffb59654123f431ca27f0ca6f92fce256c766e3c6f12bbc45ac7dfc8e3a42cbe93feba55a59e5b2283c5d1f0e76f6b9072f92fad46027d8b2d6b79e78d2fbda5fe159441ec2cf8f48cb381120e1d761869a4b053e35b029fabbb58a38fa4f5b8a6c6b22a343c0bde0211768ccad1fac7b7c14d159c14677dc2ce556c1a313e11314fa5c9b217ea158b922fdd7e8af9951f0c2c4384308872f0600e283fe03e0253879643fa58636f3ddc9f304a000ab693fb61c726155a8315355e9fd8444483b383a73c22324386985253d10991025ee0728e0bbe293f84ad3f622b33ad31646d836afaf5b8ec831e9c6d10e96a3c94c2044a1454979e328f3597752ff7ebc5ce4efcce7cc29a6e74eb4487f151d9b5021baa50c916d961ed43517f3f59c769af8325ee007c8f4b636c9b348b3bc0ad15c82687ef27443947370dec12ed06646f9b9cff98ce4987c6c021fdb334d85767fdf67c8424b90fd7a62150bffd998af71fda791f5deca50e89e60773d2ff0c5b6977d3569f2ffdc975fe9c60fb919ce486ec240a6bf9d4d9dd3b9fe486a2c62a19279048ebc11009dc95fe6389f30c8edb6ffb548a85dba1e63802894439fc9e3453836056f0fddf3d0d9b3a781f72eef03790b7f87cc301c1742bc11161be0b6a127765dd2daf7c5a17cc1a1da13878bd44e1d5fd71226582b236a5d64ca49246c69087c25e20b0ca19aa3149888d0b8602e62a36242cb3a2159dd4951e5dc0d52fd2ccd729ae5ae2720e127be43596921665d68f5debb35b1f9fd2ba456b9e75ac8327aa7e53473d6fa53253095242e0964bb37460a4c5aa3d4af6f0978d1223ba70bccd21f20063c16853c751e09b5563228c874bca5cf774a2ed3e9437f241533acfbfff7ed7482830b29afb3a637382639717ac5d08e61cc5ad16f58fe32d25ac9c27277ec32e35c89778e960e7ea272a1d77c1f99355a220bdcb777c2ecf215db9a066e05d71d93b74d1e10f816d9aa6c7c1210db4ea2559ee7b873bce4efd002119d3ef0b4c3aa38ab6fbb9affa388a663acc5110ca402ff76a2aaeb1ff666571d68be839c5cdeb28fd3b6cfcbd0b70c1946c0c8edb92a48bafc910c7df69d98ee3b3bb564ef539b508a93d032311e815117f57f55a824af6c03d69d25b6a52dbee4708b830e498d4da41348852a203971d54ee93162cec7ee6a10d980d1da34b58abf76701150e581ee2e1d8002e747eb6691e76819d7046a07803b8f6023e6b746191418c654d96b7b9a8dc7fcd8c02dc22c5cd73e0109c402e6670b74bec603c620ac524794fed28ee66f01a9e7814214cf67907ea96bcd7b08f9e121ba8fb76f005fe9e04fdb15f31f9f309119fa874b86354bd35bff0dd2d513480d2c6ac89dedc3e53634b3a6adbb625fdb0c52f0872cca031d5081f6ac392e419e22656fe9db0b37d68c21dbae4dfb6f2ca3c52663804e734f4fab09389cf2acc0b21a2900ca5e717da23651dc7291f49d2948e20eb13a4ce1a5b1ecbcaed772d3d30523aa7f30e6ecb7363426846e612a98c2c686bf871d9900050df02a9680aa445d518187200389ac3e3fc5ea280787c47bbf18bb2f3365264e33def93177c325073cae1eab0621707d7ef36b64638942dafa548ee4dc51a971ca7a4529321b0b8f423ad57c8a57e1fb66c3a773000923929461207cdfd56dc20896103bfcda82febc3fb7f4264f4868173bff719a857e2e557283430895298a775cad4ae45d9ab0aa258bb1587d637e044f2474feaa8bde09de3b42dfbfe652277ab6ae9be92c82e2a7bdabc553f60e4461f924731a550aab7bde909de914953eb393fc64a58ad44e8b644e025ce9f215ec59b7862b7c374e3b2ae2bdb58d1e28cc5b340bc3eb637f5339c915055a03c42fb282765c388346a531525045b0e991644c59d2993cc15375431a1d77fd5eeab5860ad2f500d828fa8a8f64d750baaab1fcbf1df3529366e7c5ec142c17ee0e1588a921b4c8a220b5e3e265777b49388a1a7ebaacef25dadf43d96de105cf24ba72ac3b9dc27160cc9c28f6b5fa32783525a4b6eb1ffb9f5e6d2588c09a375472039ea4c6f64ec6604d0809a50144eff2217bbdfbda1f344d09ac5d87e1ce700d5bb12cf644640a7a2d2043430b53a7a199d79fab0da08ea8d88ebf467b3a0589b992bf28fa45d7c4c1e552e6cbc8e7675ab3fa170d28a31fc053f4dc435ca1ccb25b8bf65bbebb1c8322fa4e8adf22ed203e76445d8a13d816c6bf921a05b3d3e9c7d5b27fd84057ae8ac20c6f62d29eac7484a5f1a651e86ec18d6637553e9e0893fd80971f3cc2b42e9eb6806327f0079922e39b87f18fc7ace8d5b0300862e47bdd444b89373d2770dc01478fe7b22d93370f1eed4b0fb22ed2d8340db50e11b8002cf0d584cdb522b268631750f9eca8dd6d4a3aefaede04563eec76561e7a369e9f993113566e2e84a309c068ee9a57310ef8a47200b1804d6c75763fed093a36a566bc2937445fe0760e7cd98316484e2a4aee5a4f3f44370e396a1be6b499d845b9ca84968b36121c7fd570b037456c29560210bf6534295652e56388d73e3f52d2ae5db7381999408eab8330ee6638cccf3b34bf22aa216d25f096de1932273ea2512a8e9a246b37ff913ffebf06f19b8aa640ebdaaa9aad12b7eb2b4a4eced8ece54fb7ceb7f1b89f080f3cbef0b8c27b7c9575c7e1865a671a6d87b1daf6c03fa01e579782e14d4f3c1fd4054eeabcd64f0ae22ccd759b942755fdebf660edb94d05a579abe303cacfae8af49f482d5c56d7294d55158c32d58d3ebde12b4afda11a119b83c309616f43162073e801b01bc3cb268080d391028750651921d68f5e5478195d3a8acdcd1ca3edda65dd8046470f68d2af3b455dd57ad7651131c81b1f1e780c0ea288ca25c8aa04da164d08969f0c7c6ce105e0a1620fa3cacda0db0022981a7f5fc8a1d1e7b68c5675581d721baa6e145a8b82e87869d3adf77380bc9375a9b0918e5b601324bbdadb5321b8eb3a177bbce5b26a787cb387cb36be6822e6da9112ac6f95bfccbb6057a8305f0e51782c63264827eccf14081f4b6fb119f3c1837afddc5ccb08f6898c3a4b972cd8df380aca7394d0c3d7676738905955131ec366e6b4ee6a4de73fec7e11365f4879f65f0a96b0667f44d34fdfa68b1191f6c910d4cd933fc4dac86d4e8fa1f9a565b8739648c5875eebfddf95280fc16080871b82c1874031c5190b71709ea137f166f900cc14d91d6d0bf6b79cd243bce3e18ecc49f48e91ba25f248d9dcdca26933a3ae9c34bec9e9dae86543b7cab201247482f1b9acc9c450894b1c75803ead9cc7f668b4f42e0d064f2385ae108f80946b5d451fd05ea2f041c61d6f00f03397a5457b512011d7eb6e67c36163580850f9e6b72ce3b4334a32f9147289cd6a79a02a1d79bbaae57897e31d25821be72865b2cd24d3d43e3ce4dc7dda8f33689b086f82a412911178802a7bae0d01fafd1ec2cbd7343d0c97f1fc2f549e16ca0042a29c2a9003846d87a0511f950a8231bb91e276e0410d85c52c800336fea25bf208b4f27b415e976b3c935ec89e5a5776f2bbbed721a351b1938b2c496a12cbb6fad31d72a35c7e26eb4cebe4b9956afdc37742a0f458fb9f970fcdaa4b38c07595b967f4c696c5b00b308c4b36207412577be1cf919843cd09474fa6f345c0e04445e107f6fdb0a3f8d4d71145c352241b4e685051d55fe937e34afc832a4040f37e886c3f4959b3bed0758c833d99dc55bc82c9e2782386ea3bdafe8a043f57da46ce441f839cc0650f9ccc5b2468155d07059952327fb81eb684908f37b3f52250fb2337fb7d73cd19e8f88f5573d6aeb3ca1a4c1a2d12541e95e4ddd401c813a754b953b560b3d9b34939c609e006e37b0210274a2d22de320165d8cf8bd9184a20f0c60843da67e2933370eee10b5114b83cd157e4f5d2e3f6f6ba171bd1dca97bef4745f8991273d16c6fb3632d0558d2ab7c52e113b1eb9ff3bfa6ef2a63bab7f4b0e5b2992ff9aea6d0801021ce7c149a92b9ec6401ad2e3b17f8578bee7226b3a3b2bfb029f77590758562a162d161d2917e23375aac17cc588f0de6257ee3121094a09c2e9db7b5f583541ea10326d8084427a3675865ef14e49895e8793a72b2e85e33254d8f17e2276e041c05f15b6fe78752facb5040460faaa9b6cfb0f59d5d683c2353750d1b85e8f316f970c1021be5f74fb9fc41f9294a74849110ce729717b9996ea90c456e9967dad4077a44a03a3e84df16001ebfe02d84b53ab0924abfda161ae993329330413092be1d96344c42aa691c3c92ab52dfc7f05ff839249f3bbf9e2225091660cc7688429c4154e932ee3505a4481fc6230d5c6d3b93bea13edb785dea730ab9d99408127d6eec284aec04627cfbd7f2462d492b7d5c054b5db06a1c363c27d4b6a771c0c84811476e187efe2c450dfb2d201e157133e853635d39959bb8da7ba077325b43dae4f79a10813250aa21be65612bd8247a70688443ce9a4d5211478ab675d3907255a2b3e69258c1a844f2264846697da4e6447e123bd4bfd614883bc6a0f868d53662eb5dab211a4ba231113553229fd17a89787aa90d2cd54635dad1f66b0e9aea9aa3c0131f4cbf2f77018a99fb2ceb74cf588da195b38e9c0ca5fec7dffe4821c50e88b05f8728231e21fecc0829619faf9c4b7ec39831b9ab3fae77a3c0ed2556c888a110d220a5c72113296c199be5ef27d96cb30204b305829e3561940e4d15d2798f0c2a2caa575539f63db734c548b0833a5579bd7f16ec12814ae1d45e543e54cf5b326fb8ec29ba49f098b3cd10e63724ef05007d5be5ab49fcfbc995ab6d4203aa17b388ecb02713a73b967a09aa71b3efd46fa051ca8c461c2eea704f0afc4648659feeed956d733cead3683cd5d329a741a3d9679b1402a7d3b2296a6bee11094ea1efa9277a215205c9e14700e7294fd41a9bcc50d9fab55f2bf8cbdba56f3f588d017f29251f1a3e6a31dac99b8d296d20aebc570e4569f30d62c6ed78b88dde5bad84fe42109053c9667ba28bb05414c5dd8ceb784d9d65d1d74a00bb4ae5aa270ec9a17f909f5ce2a0500667c754b073072a0c6ec06b9e950e29824bd34d82b7c94ecfb408247b54d3f9a8779ad77f358286627c814dcc2c2832e62209b374d279ee84fa16bfa04832994a1f027bdf0cd560ea4a1e772ea0adf3548c59a5193324ee2f0535cb282aea88aefa28ff339c6521aa6f318e3fff0f9cd9d942f6e95882da2e401db6544e7321a42f478535c83ed777a0938f7bc36049059c4be8de17473a909af9b4e773b1af1783b3632c58a74a3df9f720613ee78bfa70b47553441579ed2ebe8185c7b50fe824632a3ae6b380011ecd594fb1283d713ecc5d212911129ceecbfa9b3a8bf3df102a79b842a9967696595ac288a3fecf95470d684be6929dc40b49e28a76fa1073dbba6e118fcc7cfc0807de3813acf7e2e180a6328fbb4abf4ed472eaeb4d4a4f64eeb8c9dcc68faa42ee4f5bad28a937061bf258565a661f18cbe5c8f3f99e259f836681d57af64eb1407ed70ca4fb82e130bd5e92e6eb217b577183c6e3b087268013788a2a55a7b8bd9cdae12a2272d7d10395a16c2afe9d6603c36ea977aa59745399c2c2442bf36b4f3b0270bfd12d00c3f48d07b9fdc536a25c682223387d768bf381b972f2b6d6a166012c48a219576c5ffca532ae99e5fde626c9043a8807ff4c620b1b161347da4bf3828b0ab287bc863c8bcfa3cd2385ff83d593683a28077e05a268a605a451d2e858faa6e539f1ad9389e0411d798801eb443fa14b158f375877db64b60681869f939ce204e17c684cf61d6d435bb2eec39e5ed17b4dbfce67317645797ed4a2db2e3fe818306b0ca60f7467658ad9e57bbc1eecbb4391a4181b72c6ce5755543ebfa21a51d78581e53d64dea0674d2e09cc26a6c16e44ab2bb3b4ae552bf2bef664c9b640876f21c21ec75a380f6ba213364151229812355ff1246ce4d5b437707a5cc4f840ceb48991948d8187d965bd6de945284321ddcca138c0e30a6e08752747ac4bd74502b07b3208b2c8f9f1d460b1175322c8bd7f3da01d8f8f0d887ca966ab69a5c506fb4474d67fd1009f452d98b700163f19f7c8e680b30a5518bbec55bf21cc51648035371e27855031d5fe2ce8046cb0380cfa6deafceb5c01217ac1d144edf2484db4363680c4b5753f807ae5cdfb6f97179662c51c631ece405b4f71a7541af6bd076604cb53085470517d4850ea5d1fdb5f6a2a730f05c5b3aa99326b8b7f1daf6ea2fbf620b8590baa6422b5a82d9f3c9de0de0e29c06f33b107729d8cbc3a6f13f94f4ca3aafa08eaa4e0efa946187ab4b03dbbafaf5a7a1c4a797f57ba812921b544111d26cafe5d94dba341398712e7e4eddd0af2abb29e9d320b342c85d681a332d2fcd74bb77dfaa6cbb321852c3184cce9656a4d74441c8be6508850feffde22ed43027a5a521baf80a2e3fa3f64cb0582c3af1fd81389b9d6dcd35dbb362f5682b673ded2cc2cf3a27763bba23229e5e46bc530c30ddba878d3e25da17262deff5285a70ebabe2c26f21c2aae2da6e1368e5bfaf484950e411098e6f2567bcd1be4cd37b842b839b617bf0df3c621f7d67ce5e35acc9888549311775cbcd6e708127bfe0d9a15e0d9b76d32fc9720776923f0d6726a03e1051014bdd35009ad9beb665c5e3e9f0ce047cce11ec3b7ff261d2ed31b80e6fac0978c4475f142fe35d60c6c208e96ef637487187356a12790ee9760ea244cb6163d0e7632ec8a439b0f102f423173fa57094069a31abc381be65f6c48028d9566f2c9e9fba7d4bf0fb80e987bb181005dcb8e2e5e7e01de959b2347e92e87469ed4d33022c878ae6ed9d1a8b7347fd953037ab0e286650e83baf3997f963d9d8c905e8c6f3adf36eda607913afa46e12a0ad4bf87dab6c8533a3910e54b85a3196a5f8822e31fad3fbf1e906bdc96df31987688d25ccc07cd74ce1d8979467a7d2b7948db12a7ac310571a29e14aed6b63d98805901c268b39b4a70cb6d21588739ad0944e811f95b6a67a5bfe3ac8b2f974bdc78279e39425ebca1c670b5804ca810421ccae064f4629452338e0586f1be75629aa0166cb73e0fb7ad023643239edcb245b4fb76d7052b8460ef3a22416b1a6207f8bbfde5c52a8602c565b436b798cc468af3bea28246c4395dc7272ac02ede9e256661cfc76fd2c30a6d1a61696aa41d4697d7469d1f478ccf0f81832a89839dfdbbf4f1ee3e6ce738afffd6401e63956caa1bf6280dc83cd92d7134c61c8765b7a1c431adcec677349aebc7973809f53db3bbfe04a245a6495fe02a46fe82f62a93a7562a0cfc11d545c8cbdbc6bdbaebc6ec09a8deda05161c08acab74aaffffd444ebfd63441efa99cb5623e44e1e5fb9c7673f28bf8f3a0833e5cf78e1acfb819ade0f18b87f26c05960d4682739f620d955a89d78dc350ef856a7f156e2a5134dec93be4f10ff64572b407962fc3f370821ebc4edad66ccf05c8db1fcfde615bfb8c71cd825b5c3afb6511eb4406e43537bbbb4357412f6188642ac8ae36c8e53c8c41674d2f4d5a2a73b1b456bb699d08c18258fd2f3beb94a3b6e704731b52d75cf3f3c647bcee703b7d41fa12818acb40ec9f0650e7e7c2a1992a2b59f0df42bf37c7a0c16522ab0f82f7fb09dbaad4dbbfa7a539d778480aeada5cb7114fe2ba5f4b71cea4155ef6583dedfb75820680f17473cb33db98cbc406249f88f933ba39e84a7e751856b5ad69c8a9b7af2aae1b4cc7ebc0770f51cb9feeb76a665acfc5002f3f24eb97ecc7d7a8ac6b5f7bbf9308aa9080d21cdcd28b0989e0c2f3e0dde43ff9135d0a9e2171cdf0abc0d0bdb0b9daefe1d5eb4f4248bbe9ea315e24af0db119ba49e5eda9dc7d5da35e28bfed89bb4c06adbddfaa6023e1da8deb606f8924ff4b281f97f0f01c405340a6010621b91f770a6aea273acc51c787896d810663792107e5059e00f4bd056c6e1fbb130ccd9f189b29be92eb798e53b097b52bfaf09d5406e8e672e190b208feb7007fd4f5193ff2198a0aeb68a4c00c9ed165400a86f335cac64c6552183d8b20e2670ece81bab4cbd956ced4ec8b87bfc668d4fe9527ed1b99654c57d39deae6627f25426ccfa11b9f3c215f95e375acd52abab7fcb836adf9b927133f1e2600f8bfd049559920f7dad778fdec025948c75613bcc9d4abb4707ac5f6a600a6ca2ce8aaeecaf8770fcdc9b2fab9f1f2f012f4b0cd5f21b8cc92966188b826eb1a992a48c5843079e1fd185cfbb36e1543cff0ac4d98dbaea872d92fbf6abd32db3b63216db4c6b9261aa3eab4166abf9f33c650f98a8a06ad4168e5b193dddc867d59246ffc0fdda823c81073a2c2805c23d2454b80474243389777f47131e4ef3111514fd7183ce24512cc7f40901298ed076dc416ee31613ff6d1edd5b85d349b43fc6736d0de4c81547b638a60836b9ddd2941d63e035496e01a4ffe8d4b7277ca799391e6eca7acde43cbe7228285146b77dc56f0078fab065f2fb9348bcb8b9b7ec53c4e5971c8f5437b27f4c0541874a52d5bce7104a2c9818dad5d61ccf12a420fc9781eea319d0ef1c0a591771af7083bd6a03e7677cf9f582807aff4584584ed0c4d6765d6fa20d0b34780c7775823400aef3ade1b880019f5197b2a9d5946e22614d8ee49f24b15467d9e8be7b11c2617e83fe6999012d0a1ab8e3c339ab67ca566b27a202b88cbae11e62ef311095b73cecf2d52e3d86fed2266cbe7f31a2b087d947deb7fbad36b83042eff035d79a8b406fc355f120f3677db7c187a1afb3ed8423bdadc1493902c44ac2322fc68f452a47cd9b4dab6a4db481f1e866217a1c54247c396823947904c6c40fc23a8c82e24701900af8d2c5405ad745b9a5cf778a5b27df7189dc58c099fc342b7af47ab91b3f892f870f008cb8a138c71f9f686d14f0e5a43a7a4c82f9448756c59d41d591676ede84c248075122a48f0503a3426d4f5fcd0b5a9e40199722ff852055ffed0203407b6374b7a99df12b3f3cd2400b2a31133d1e8ad0ee0759fcca555b8dbd4b85677f25a56fe9587ad470792d5a72db81f16b2e372445aed6cea1000509cb7ec10e89c97e9c969ab3da00f2bed0f4e15f2e2ff5031f72072e857045f65fdcebc5ba515d40f6eab24a2584188247224d7494e83ebd0fa91cab634a3c9a614a60eea91e61ed89b74d0d9140a5872d1fd747669ac4f38dce7f9a6b78dadad8b6118aa1c305365cb27f6edf1cf61cbaef36a3b2c28fbee9f4aa4fe5ffa1fb12b579e93555c1e90cc29ebfbf9d78540c5b08f55b5e2bb3be8251ba7cdd2e558ebe6b1de5fc734f31790699e8169ddcd5da9d9cbf484137601571c4c9cb4143fec5dfabfa85a98dfd580c3a7de8d4bfc5fd6a281d5e971629a99cd7efc9ce74929d25560f890b3fd36bca88f132535156547aa5b84774d5cef5ea757267ddb4f30db823edff69d91356809d809ecd0679c7bd3aff8d48014e91b65408af471d7573d8d54d3b586a29fdcf5ee03591cceedca4e6ce66ef9df435dec389105a6e65d8c533a720c3b9a1df9bfa8e670a189e923e1cd72be315858e1b84ade46f3623fe0b7b38a086bfc96c40afd207f11460141582c47f886263e62c5194258a59536d303a95d27888c449aee07d4404d92ccf69442b9441bc0cc89138a5ea29d17748e4fa9b159928e66389a799ad0302ed52f8730afb947c67095c9a2ff3624ae34b7190befd03911fbad17424f646cb03ab603a3a0594f244d1c6fece5eb18550df43827152f0cc4938997472287efd31165bda522f62ecd16d0ce2cbfd46034141ff42b32763fac964b822249b5d1861d9cdcb013d12cb038046f8adb35d6d36be1a52ed31d5ac46764d6f2434223ab67a12b27c11d9649577cf99cd440225d7f6eb74ee6f5c7a991ce0fdfb7a19c3d3ee07a0fc5b30eb5946147d493058c95a80a0ca60bafcaf0c0695b034a5f70c66e158903cdae24c1bf01040c3800983252edb48b8d030c164b17a813949f064a3aaa9ed0a618c8b447b0de5fd3d28b8411d34004c6cb9860975366f150c0e72b99f6eca7549ab58d2335c29371b188f2fdc84dcdb1f9b9fb3807bac2b706cb09f69769b0d549ddcc8dc6091779388526ec0b00b8fcdce2138bd1c063147746eccb7f8b71a576e8c7e919d546216e655a2d01296a11d889266c21c520b24695bbd1aab50d198df3ad501014b60d1f01ac9366491b5d82afe7b1c74e20f47181563b81ad720ff87489e3386fc933f3df04b06824b8ebaec13c9ff02ef504bc7c12d1c046e5fc41b5aeca9c834bfd5000df32ad567a4e0fb4ad1a895b1a6603f151a0105fb233f7deda80f74b2ef6e551f2ead148b1e49ec5f09ab81c20dfaafec01098803ffee72d66c8c780fb1c1bcbf57f679c226580e92c4dfd9d19432469172353b53d32e9421e601c9d4a6a65255fe8b678673139da17da1c8702d587653fd0965b90b7bb8b062bf57bfd0377912ec6ff421e85f452d1f0ec582d7e1aef709916f9de31dbbac9be4059e50524a36b37bce0b73c7e100176477cbbe74163a666df0e6309e71690ca03ba7cdd44b3b03fff00c6a83a83a7499a76944f1d4fd09eb0561a188303b5461c7318ecc4b2f902e05905a8bbccc97847461d6c13d04978418c64ada6df6304ff003868ff25e331affd1d368d395619b894f0a087c72fed4b6e9fdf71f6b23691d5104783666d9ae031049ff6bde4f268c01ddf057c4f4a6c23e75f17eb2574e572951a57ec9ed874f4a58067a863178bc6edc5737aaa9ca62dc8d55e30ac8d20a20180fb46f66e2c13a344284cc2b48db95af985bc5a36229918ea614a6a0892f31a628f4b8a62a4ee5b1dca7a20dabf7fc6442c23a77cd896b1b71a90f6ac89d677be80d5e2e92cb029a1ac87ae81ff3e848c0b8407e7d51c4aca763461a95449a1e56e804ba5d1962e3a1e26552f18fbb644de24736b88afd67a5ba84430b7c5000808537e0c46a5585aab80060976bdd9dea2ca307f9a8b8ed864ac052541f36b822cf77323d2367ebb0d3ae06d710a015dbca978d5ea425582c4a49964b7c2c559fb9ee181a46f0556462797bb2c53a2a942c8a2b02aa3530c0ef6bd366dc669b88036936231fdafd10479bda7b0e79b46f7b0da83134f302e07310eed06e8810a9a84825ee5e9b95c806aed447ec8b334583854ef2be828cab9ca81dafda9bddaded3bd80bc6355af701eda421f098316ada40f8583c34377e3a4287503106d1a69bdd185428f4312c7d82b0fe82e6300728a0693f32242b56e1b18295dcae6cef31afe51bc6cef3768a4d60e19a8a356dedcc74e8cab26015465acb7eaba15d2b447d7d1ff1334625d5e8af0348a56bede5fb7fe8132ace7268bec075a9439d0c2b66381e35f85e15c8cd2e85234307cc6e9932666d6edef2482bb4a7ac5aafe1d7ee1d09caa9b9a50b7bda0100d6bcd1adfe006139d870e1c25d71404a65d8540a701caa4a8709fbf859e311d1d1766c43342f6def39e579697dda0dbdbe8c273b9ac9a0cef87eccae063a53bbd7389b81dfbcad942857f5d23b6b423682431c3c4f63334b0cae8a65fa00f898975e9679815ec8721a4b842becb42ec21363413f43fc3e9131cc68596bb8752839f2b18373859cd619110e19ada11487c038996fd0784e16f07b4b0d25d7d25afa313b1f54f29bdb598df44f72168852de5dc25775879d813c8e5f5dd1694633c8caad3ba5d6d0e223f25a0324db4d365820df34447c66c6f0faa81439e385c86cc3ea2462eea50c5c4f7d923acea49b1df760212a5047aaf8ee24b80c9ac3dfce22a67e58ba5d29b7a7ffb6a2663869eb9641318a90dac8dd18849659ea03da4cb263085c32efa96ac472e8185d6d8efc9db5e4ec03dfa48ed74953fd23e48382ce922219e01cbb52f4c7aab6a924ca689e9fb826b2a8d7a4b550ec7a1efc48a53a76460cabc02014713fc315fcce7751ed3ce0865b2a3aaa390f75a9dc3d03a7f84638005cb563ebeb68df699763fcac5d3aaf65a4ab05342da16d63f64e4da7eb9af827690da1ab386ef9f5cc2cfe4060be8b5904f6ee29d26282f2558071c84336aa4964eb9b99bdca2039f49e22ff4f2abef46569359438fa8b2c7e4bbe9c2ac6c8b3da4c3523297a9058a04ca433fb9fbcc14cc84d9203187c689485d9156672dbe4fb258c54f0c1763f964ee94692434929ca97d594c13e48eab6fa0a98ef0dad68d821453d632634c2721cf678e1891e1b8e191e3398cdc36cc60c5706667dbcb7126fcdd61760f02e745ed463113aa86ab5bff59f1b604ef93f42c1763bed854bf186d5f3fcdaf4c9157e305353333b0873bd1b4cb917114b62a64c02bb27e930c1566d78611debe7ccbb17fdbfbcc51c4fa627d030941011483881fb7c09db35dcba4f58e1afb133d0b132ec86c1acd1d5fcaa4f2048066bbb9ee3f36341d95db7c7e14b57c814feddcddd0a970335be4ff5bd633c07502b3f369a8cfdedbb651f39071ce1ebe8dbb07cd50aa8875c35f8528fdf479116cb44ebfce098eac0d15a7bbcaed8b5d6580c80cdb41716e28674c5ef47e90782a6820500f1b455d929f3317b7ea19924af4f60c2cb52e48002a485aa1618b6482d7578a29f727bcc02b47360c35e4488091d238a834719ff79c5eadb7fbbbdecc2dd0c27f3d123b07ff9a3ea0b607680ab7898897cadc910277e1bb93e3be462650c31d4736cc81bdd1bb7e333855ffeb4975827b492c061dc141461537a0764791292d831866411a80eec5ff18f527e275c0ea8c6d48913783e2313f6c06663156e6c5174a7bf85c423a1168d7bb9c396a583e71906a1f66873c61cf043f91781607cd1b38b1761ee4b275e1cb05798ba528ff7ef0a0d7454cf5c671518938b9add1632bc01acfd7d9e4c21ddc87d89038e980d1f3eb299481dd82e01fb21e8b68f08e3fbb7d61453996bc63dc46e44f073e0c2f8b4f51090f21f29030dd43afc7cd215ff1ecac611","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
