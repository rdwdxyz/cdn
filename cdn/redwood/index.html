<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eacc93385a96df8288f9008f6280391a04e3ed06ff94ed3565435b356fb9e97b2518c3ef96fd49eb75559f7f1896c084ba97ed008b5bee9f73184c4e94a190eba1462911680b238c2ae2e4b1a7f8b2b55bcd7f03ee00234b50e4fef37a06b4b1b73962a18f5f91bfafec97e92ec2778e64b86f3841ff1588e53f02c4b1f6618fafc4944a151e1a04fb57dea460814a6b539ef50a17aef29fcea38980b2c7016e763d9b06fbb0b27211622efa84aa33b2f5d3750abefaef65f3caeb443dfcee704f62fcfe51b93c2a8e74e0e8666c8193c3e584f1421a990c7dfc8c88983c7ecf4392cf94d7ab692af413dd2c282c803598ce8f74971004c34c4ab1894654d53f418aff9f8bb49104ce6b564cdc38d9f61d9795cec21bb6eb21cb4fd32db5762b8352b8e8c0da004768c5da3e47a566b85f5e580364ff8a0979d18840e1eaaa69331367c1dcb6da7acbcdc05a9f0a51f1ec457113f2bbee60f99f37a6c7e4b2edf4c73be78cb222fea56464aa626a07da1a01ddeb4f31676e714d1fa5cc50b9c601036878b77d58866ff87d07e324cb402c6ae882701aaa73d395246a8cea7a675c9bba1dad924dc93c7f2fd49a5a5648949d2429f5f06174c6dce8157114c99378c338488ed219632005eb0f034f73895e4962d103689448c75f349355c083342769150346fea3ac700b1e0cd611b08a397741932bd2fecd2f96db95e8c925301e3207d421a2733aae00b614aa367fbac7a35463c6b82319e7e88489981ff107f4715f09197c93a066d466457e01039b2f25c01bb9f2fb0fc63f4d005e3225825a90ee2d2509f357466eec18742479e0a1b56671c54c53f0272ae61ba90de147c48b98dccd3ed796ffd3ec1ec7fb5c927fabc400434ae0848a25f75b24f4745124b2f7f23a88d42c9f1b291478c82642091e2c670a280c98e0b0d18bd4148c711b42c6c49a00e5d4d93e0d43f699204add936551a40ba2ab366cb4125cfdbf5e32d24c305796ae6cf77303e33cff3b3292fd285e7b5f749d25df24b33b6867f971bf96b2ebd0c5e7ab4a0a6ea029b787d9e627863a6817baa09b1e079e63ec02f1caa39c05883ddaae10186db3a691ee146d822aefe564259194dd3695c3ce178c751d121fa4e284dcf90f46322a145afe06557798f9f1946bc381dca3a8a12c88ba54e63a904f6e31f1f3273ec27af8acbe5e4936729f8d8c7c2d8108ce548bf516f1d3564e6d651ff14911572f002b19d4f19d7b230ac5f51d6bba8dce318f825c5d83592954e9d69398544889712ca6ecbc1b81c3e813be5e640987f13f12409313727c3b7b2c2e81e9caa7c56fec97172e6b217ef6c0f28d14e3c778636bf28b03f29649db28f9d2437aba9c1d24809fdea2acec3b5688353cb07079e67922e61a39c49af0507d03ec8bcb148ba0be2185034a45826d2fae81868f2a9272aac402a513b6db6894348fecf2f7ec59d3b700f0a8841db8d79f0068ba3ae84736d43327707438696f7d205ade2fe3d1e7e2e6fd9dae0e410ed1a629a66f23d6c78066c08f6071648c8d5057adba7380f6cacdfa5b865207983c24985f03a062952147a3058097caec143c2a199624b188695e261d8d8477ef212adfb348057d63e1c75fee64b64d117ae598f19cdeae46d6d5e56de470ddd90b9bc417e0f718e1f2ded858b7443a6387f406889e31d91ca163272b401b326ece8e3b372528d5ae9d29cd7058998e4a8817985e377004813e123a38787ea89b7e359cb5ba37b8e25e4bf032524568d262a084ff66a3ea34e7636a576767d08b1626bc2a8ed997d4d07371c645bc7eec267dfbe23d413782f4a6aaa43aa62d3aea1447a2f35a2e6ee2e714c8ca18412921cb4fdcd2f60f62b27893d2a6ba2919414b1d18d209d0d23ffeb5c67196db851fc5cc129df903d639600f5d43bbdc9b7800ccfd3022ca56797e61876dec0f3ea8251220d0f9fa13666547502ea31376faf2543f8f06a4b69a4240f9bd677bb9f2ecba18fc2a0242ae4b23007b59c2d6eeb40d266116b2d778b26ec0837aa8bb54a0e0a2fa561b35ec901752ee7405b8898337a6f514e162e3f9f7f4cef8847da636d7c344617400f6ebb2088c7e04073633e7b50eb97923feaa375a30e3e0da919f0e40bbe5899925c9fe2a21f64bd31f834647ee155d3afd7ea64728fced0dc1898538269786a269d6a2ed78076c60576ac9044b7f895718fcac5230a2f0d621eb478ba93af367ea9ca4140c99e6f140873b35edc442fbd129ef623f80d25a331d387838a3e2e94d2cb16dad0cd0e6d16c920888b83831122bc14071f9d2bb4643574f2806276c665704bb32fc7f2bb9b266af2448234eba291d58ceef91799c80f5799fdb571292df06357e74571870f8ddb4083d2512dcc137e3e5ecb36eb24fa7cc3f1805dfff7be874422419c53428dc646c7aea18d50d564a50dfa287004f70a177d463c634f0ac765ccc876fac05504fac12d589097b0d4c31304e0516ff6e83cf8e01d2656c17e852c9f3b6a7380efcbe8242025b66f7efceb21760cad7e587434a6ede66fe716a7b69523af51bf19f73c979711e66589518c6ffe6b738e69d73651713f5bca14298d937d708781610c7fe207f6d307af1fa4ff078d5642e36ecaa45b1ab6232ab5cde5b0cfc941baf2507da5558f8b7d3a59547967ae76992fd3f8097225056b99fad4b7d57a4231f65679b98eb9c78e3cbc89726904bcf6cd4cb7db9df5d2e60bdae428e89ea99f5d893362ef338a02c946fee9bd6fae4dee4660f69fea6263bb56c91971d1e200813f14b8f8483a6c25a823236200fef81eb2b2d556582d43b174037043808700363d5703f4b87409415e202168c0f49b0ef287e955df745d6dc1c79a104276653ff0b3d23ec991a39728c534518874003333d6cc0fad18f2c677b3dca08251d26a22ee3f7986d57a9225b1509ea8fb6342aec477682ce54585b56f3954574a440e8b7e79f4caa3764154f9dddc814c0311cccf674efc207f92c0b8639fb6778b8fda12afa9970e4cdc55732178e77aae4479d1dea5de9ecc574ada3ed25036dd7116c030c32d9cb3d28245a8ce472f8ac62c2fae3209cf66a030f87837be744481ee1daa7a49b44e5dcbeb9e8f09fa59ccf17a8455bae214e20ba9129eae23a8e47be093edc96be8672206a816286e677616ea5ebb7203d18c19e59a6cf75da6f0b25cdf5b586ae7ecd5e479ffc3a1aea4b020faabcd7646e74cc0a42a531785ada6481e2bd65ed11fd478aadc922ee7588e89d9d89e67e96cd439863ba6f38ba9d54d4565f4783eb397f168fc06b2a4a61de4d41345c72af4c2efaffd9aa51aad5ee52875c2ead0b1c75925c2ff24dd30d9bee82ab22c25eac308a83434960efe6b2dca729dab7caae79d631f8d1d6b6110dce5fee91a441b2acc9a5a23f720125fbe63babde0bf31922373fa2a6a891e0560a45657dbac0b752b19ea2436d0a55a15bab3946433d5714548cded33d3efdf6e0c57537ad5fbbcefc1192c982684365b2a814a01a7abef4238fdfa98914a2cadf2690d6edca7fd83693915d1fe6f752195ef6e3b4296db6cf52f2d17a6724bf9cc61e53d783e36a97989d02edba65ed72fb9f3bc43e5fbd797b9e94e389befaff53a13ca86559ee5c8c1ee821283db7ea02d3deee74a35bf71ead9626d90e6589f3b0300f9403ce269642cbad3001ffb1906cf13010377ea1133f15672f75964a4819628e8d5d473ea76a3697e936c1055bc154ee72c612ac976734e615e0fc8d71b1494bfc776bcbb4b95235ced6184b84a49bdd2afa840173fb3c978638d2979cb7f4746980426d6412a91f08054628792eac0527e0980f740176fe14690929e768bf87c1c2468314c8bede7f35e46789d5d74f02cf6c16262aa4129216ad16799401ccf7f3b46be8e74cb23299dda973bcb7f499af20b58302f8eb578f547ccff26b6eb3300fb8ae21c65f3c294e7a9fa089bb50e2a5efec55d005d4f7696161900dcf121674095bffada62b5bbe02063bcd958dec6a78ef0a1a8e8444fc6a09120997ce8f846921404609f34b104c854d79e663f4e9bd7042da45fa6fe9b92f9fa06d263b21fe5ff4728f8b889718c1286a8bc3a80f23967ddc49dd7d6a68e8f3b91800971a4be2dfd8974fa7297f9c95a72f0b4f457dbdc5b16de99a116246aede7176d623368d0c9f9e329f5f0dbb63426f61eac81cfd1f4b81b818074f88c5e465264b926a9c0f27203b74308cf431674f93f8c2e6c043450d3d3bafb77dbf94a51dc68a567a3151b7b7813c7db5b1c4ccbd26cfe81937b067dc6e76a5ef8af92d0543540855d846990fc4675d2c057a55b672c155aa805d6ca1d99d4a03879689109c20d299bbab0de2d7f54cad4d1b2f9e0fc048b0ccaee6ab8f1d8c3f7034a8f29ede020802d8de678aa2c7728d171db9d425c4cffba5cadc88e04e26861b30301aa226f836768c5cbe735f1b83357c1401577935ab7dae6d964ae7a8bca38a58edd6413de80bbe4e9f622fff730d365dd3e439287153fe3f9403be79f34a7e6d9cf97326f281c8b08a3f668fcdc838d1d8004238c65fb1bb6992c0570aff95f8d322ac3df327de99c3556dcb34b62c994ed9bd334e26f44ecef597e564f45effe05a472e414b4f981f1b825deebb94de81093402076bafb14cdbd97381c7b20af045fb2182dc0850f0f5517be1c56a8ff89fa001dbc10a0a4c9167940e381200a822baeb955fd7e26e138beacfd62f97918251869ab6bcc4be1f6b4d555fd2471ddc3e3910a510915481ece16cfea88c639829bdcc22ca68c7fc4d3239b9399783ec2026dfb5efb02151c029dffcd844f0fde04d37b156574dc711a575cdf737a463b49ccb111d4c5051e4c3506aece76e912ffec0e1f1bf1611533a481f77ce394609c884858834e6398c20a276dca8d47031f17f630a3c6893cf6ba88cbf739cba3b72d4ceec9ee31dab2b360db216753a4a4f6bc1b8941a6835c7d3049d8eaf3328e7860a6bc73575283d4a23f7490972d25d225c7c8dc20eab9c643655f8515436c1d65c73ac693e99b184119b2599dc73b35a7c00979b84856219b7ea5e98d53a8ba432caf2fde3bde0bd5cb5f6bee1daec815c04a46a9094d74a03d392a00c63443dca9a7211dbab1e099554bdc594b885659b05a7f8d5a6d1d99afee604c373651af0a8711b868c8de482c731fac4911acf3b49b8eab291ffa265f16506d0f4a12a527eb27faed720d8792aa506bf8789727d7f66a77556352527cf5cac320ce5eeed08a92189b696ab7f905a55a606c1dce648b35167f8208ef29b01c8753257c113cfd0971a7d81d9bbc1e16f1ba5bcd3d296499f9d64913e69205f3134840c9e56621c17d63e7e3d6eab7d6a81dab9c68f87c4f56eebef3bf12bbf24def49e3b5a4ccee4f4c1f1d4a0f69e5a5398b5e1647ddab2abb845921d782d3b8ee1fac7c2047be89b30dd085dbd9f1bd3e865306f70c6bd05ad478e5a4934bb8fbc22e696f04a856592bfcf7102c991094b98d5f7b62ac7ac2d5674335883fbc9a4c0b69a6615b53621e7c0b68e41fc84db9eb5b052c0596a83ffbfd70ee5f9787a134ff325a1c90388d05350ba88481fe1ede96f20143f0e40fe457a7c4b655d8d2673607635f7167895e10c118fb744540299d6e46e31110ba020906fed5877815970d68ed8017f20f75c95313d0e3a2cdb36168fcf961b37fe45414d2422f7eae2ac29983cb35e0c4e2ef8a27147d266b22f6f6a45a88904a61b09f93b811607f21d680fecb347eae8cb9d4b822236bf9e13be331c65ca97e929eca16b27b7fbc45409f3d8b051bce3caebb59f52b526c0225e64ac54d1beef7fe7127c289b210fdf978f9bc83cea1f1a89872d3b1be54eab1a57e3a1f98e9779bd3f5d78d9054aabe367eabf703f33bb457725324ac39cf0f933c0e94080b1eb0d29387eaae4b4520c3f0341a51328f73aaa09b31cd5755d061e84f9647b847e1836c6545f21c37807fc9887d1022ecf27f8585cf9baee479eb3a130ddfd75dd8555030ab41a8d43d0425b43f2dc80b31d359c3e3c1c9fd5f98bf4feede9dcfb6f8e63d753e270fc97a2bd42eee994dfb9b46d5e8e6e7ab32821b93152c965cbf15399e1ba1925d725af198b42f94dae0943aa2b16b81ee85ce8f5e0ef0ea20f1d90010e73a03b9afafb2c28dcd037d922cb060f315e181b3ba3db48678be7745ceb92d231a71213448f33185aadb57d7fd661ad7d724ee3bdb83968aafaf2e47c2ce046cd21f53c21bfe58702d99e0695a740a7a14d79c72b6271d322baa135837deeeff54538b5673aa3285e122ce9640e61f927f0bb92cbdd77a8318532ba99ad9b32b98f899f41e0406b533af39b9d65120ff672935b222b2574d85661ab5f7916e96b7d97268b8c3066f2d81fc5f18fb16ded9b09e6a0513b794662e01ede701e98014a80f534f77fe8cca49b6ff3a3091bf22532a725ab0a1ffd37f5cb7b8187d91930fc4214043ba9fe895a70e7dfd5a421ca2938a3d7ecc05f28382965b175ebf0789539ad914b9167397a49cbff841ec65c53a5d61ca0fd5f2c93c379593f44dcb2a52dd71c3f0fd64dac2726d2bc2240b7e1c91216c613b973aa7eae808031889b0bf5e35e1867c3427e27c574af389d2edbaeff569c243bc09c933644cc22734eebbb397df8fe59a2d3753ea5be89454ce95765b0996373c42df396abd3d4d1243186a0b477aca87398fed693cf344d2f474ad73137df48f774c949ac7595f017fe698ba2e1b1b50d1a1ab8b4f4cfc6af74839d1861e78a6ba805d8a19bf4294b3cbf67e522814e876e7630b7a1f16127f94c454095ff5f586cc1a47f227f9006f4e154487b3cc910025c223c9999f59afa6d53baec8d70a117692152389567fcadf59a7cf41eac474f9732c540d4ddcb5320a2f61e1959b412ed7d3fb9390bc9400b9e47fde7cd38f9f7dc787cf9ccc2e92ea8d00b416175cee70ecb7e756ecf1bbe327940bb9cd3893798932ddd81a0bf093c6725035a4acf5d015a9f452491460d81769e59b37b3bf6ec99b44e9d2eae18b0b5cbd3e7fa38be875b30656688158cf4c41a2783a50a2891791f450acfe757aff5d63e7a426a47e58b0438825573111e138b49d7279dfa19de50bfd4fbce2210873202a68117c1d76cc9c2f23935d3b05ec18cd9bd8b5b98cc597ae91100d9e2b3ce9683b855b8d035257b7b678151144fd32bea3fa94fe4348c62b3665f0c9dfa6956f886b3b70337aae6e42f28507c606bd211df5157a13514a93ee3d62b6ad5f9e264ccc309deb653b0f4432b9096dbf57fc82fbe5cc8a7b821c67c5d35c57fd22009f92ae618940d2e66412b739684b6a492609fdedc055b6c81234fe4549f8a2c2c7b5d7d8113891e86ad8d456bf7cf5dd59c639f7ee9a940fd2003dcb6e8e3c70478e4df2560af65bde414206674cbce8d5d613462f5f2aebc957986d3aced46f62fbf9063b6c8b5116a3b23b7cf43e6358a6523b782f893afe76ee5a8f30666ba342da607ec2af9e5f467907079f3bdc81c1047fb83959344a875de765cb9961a5f9cdb85b5e296856d48fe6303f817bc6cee7401e66dd2009ad0f915dd2d276f5081dd2f3cabc3618b84a30f69946f1a7d6f38e8e97b51021e39d57b0e31e17717b0c3358f8434d80a5fdd3d22feac59a3c551cd896d700657e148e88d6490423f78bb124c63c69194731f55bde55b7e8487e709177e87ee46d54b57badbd91ec83e68e832a072a78daad24b1017306374524c505857ecaef019a68c32d5f7bc376ba461019d12e7422dff633fd7b3490c36c7f0ccbc2cc449a21be34cc0107b2057ffdaa3bcb4f560da88df69cc6b7bcb26c1468352e1dad086087b2a3e57688484933958338a40aade780de79971c1d6fccd29d82eaa5c94b385bf1e667d18b639b35ef865386d921e82173bdb328d618f477ee688740cf95018be3c239af21bb1655806c15a90abd5641243d90d80c4e6c8fbd1f871dc66da2dc6e85535c71f434c52ccf09d525cf8fe7e8d7a61c2dffb262a53b6f5f4fe83537c51c34e8d869c8627bd26ca65c7ecfed1dd43dad4b885e1b8299a1a7f082825bf003a9aab2e85a210ad27c967bc9714af49aa155922f2e43f2b17ae3969eade5417522fe73c06af3e008dda777aa63ba6b07634eecf4a7160305fc3ca491384bac0656b1a9edd96098c3a44540a19d4b26e1ddf3c96ca29a5611c6a0f2cf8fc1bfc04a2615f14cdceb0fbce4d36bc3905f04f3f1920ed28000b90f3ef914bf327eb06a87df5bd0f9d4611849dd1d107852d9cdb0eb19e57255ad73af1ab51134df5dc953744bd5eb19c13fb7594b175156b26e1db69c8b822def2bc09574d0ecae4b2186d3c275e7b7e0e18a106f22ddf9ee035eb8d20ef9ff4d4832426b745d34a575e81b488c2be48ed6113f6995d17c7a4d6d2c5fddec20e0879f77e575ba0d36e6d25bf564f839c9bae1500b793a338d6745484a0d47eb94674b7525b351bb08e176ce8cf336a90635c8450f36d29948468fa525a94a1a9e00a35669a4952d0d3a8633c2c681c5f1384c73e87753cf6f3177d426f3e2811fa82ede8af0cb8d19d9edb2d1cd4de8966f41636e7e29103f5e57bd559f68e2bf29025bfcf70cafe09fd03cdfe854ffa3f20980650db770eb9c32f3feaf6d371618e14b2386fb8da7f1ae677322ad50e330bd643007ea1e2a49a2be8c2cc0f53d603f5d898369b5bada59126d44dd2415bdf11db3aca5e012948f929f2339b56ba486365ea023570df713c1f50e9704e297e5308c34a0103f34ae73956d91c898738075d4fc423088833e26be47ba3607629b9ce168d63252dfb52c2f2f23dac8bb5793407d2b9538f69a4164101776d23476869385c214828a6bcd967ac649b7349b135742af21a7ad61448d6a560e79d35d606d472db2ca37e68e016b06f972afcdb110fd6cba2341eb30e9d46e8d45b457e06a36887315ad50d439d0a52839d07af4d7cc3ae5d33c2c3e55cdb1673cc7c3c4e05d31814817bcb80e64fec4724259844e797d562371cd9a82cdf50468a58e4e54b45a1243ef31aac10c5dad17a6c04cd8e0bc63d37bc4231cce22b79e4a6992cd8f7b3289700381124ebedd272e33349d9606ed56cad3cb5e612eb8277b28bd1e7bdeb4c24bbcbf4d034e954cc15bdf7d87b5a798b0393e7b4f952dcbc9919de6dd470375469331d1bff8e353267cc7d9f39808606a0e90b95ccb3ff1fb3f2111485b714eb0963497367734b1d404e4349827efcc3ee47cce1850df209eae678391da9d84108e1f181a70863e99b1f25332935d31aab08a86e4aa1e2135a35f068a50daa7c2480e6fdb53febf4350fd551679255ec2bfa55bfdd5e1f0edd685d6326b46af6a4cdc3794d0cf35e2829907540c13cf0a0bcfc03b158fdb46f1e2d7662ff9d05cb741e3a241a4d281ed002507c196c0028e234432daaa461993e3f3b93962d60029ac78d7724c82eab0031c2a00589baee610564d5753555ee55cbe780f72034469e4c1b47f70e562889604fd56480c47e86e1cf1f69a8e7b4e3da8e67591875435e932b09da629f67050d914d3d24d4b3e9bbe28d2d96f926b20895d99df95068867f2145e7f484808f41420b7957a29a155896a47fc52e68d14479408357c7928fdd0fab2ff64efa616c99ecfd5d2641db6de36c5e112dad9494ab139869424738d83cdc12fb8dfca803b924aef49b195b0ab05455bb70cbe353a5b9dea7bcce87a1cd1ff766bb36e338e0fb24a9bce837607566a2c9182f9bb1f51cabf174b101cd2f26e72f7861a35854e2324f46ed7cdba97c2e9d832ecbc4c47f2f7e2495d5b5cb22f8f1c68915fbfe8a1f702e173f6e9d2324006e4c58d14b1259ed0f117c6b9fda83a18c586837f4620dde508636d9ede0639d87553710d5eb09827b588e5a8d4a118db13a67839268d4743587e3a655fde13eaedabf11d00d6218763f058a993d9122390249d4eae137e5b06dccc927162845af2852e60f9ffa5460e0b0c049b0ea220d41c3dd6b89e8174b0396b8438548ee64f2909966f6381c4b44b8cf6dcb4837f5ea8c4577072c0a8f358d9c02156abeaeece43f4f2296a7d285771be237e8ecb1c80d6672c124626f283e06074cc6e6646f69da2fddc2269084abbcd57c0f91f915ca79e7cf357586fa3ec45d785f6917e9f614f2daa072b80c2ec93145ce6b9dbaf15dd788cf04baaaaa537031cd8b3078a52f40d930f6eec0813f548d5d5e35d6074d3449ffc628909fa219e6372ae965389404162035a416bb469eefc8ade735b8d9658e5c8a684afafeca0ac28e9ebdab8c80aea19cac5d1b18ef3a03fe97cf61c099c69ce8133a2b1f2f67ae1ec348a85b3c9f9847d043d1247e1c16e7f18170d4dd1e90c40d7241cfba9252582e0b2dc09ab97f28abf348a4034731c7fd19b63582b15d87856db6c56e43567e9cf72856805860c1a8c9a18ffddfe070c275e6b997d4934fbad3515245d25101389122ef53d7d5832b9da1daf03550391c3d0a860a4638f93887ae6710be6b9baca4341c238674bdb110b45684fe89912a8611d3d7ad2c4c15b35a46f859e102e778962bcae57a6cb1730d67a2e2598df20d9cfd6af55b7d76b77cfa8c169266ee1461564bc792bc9a43991a115a85670bb7497b66941c81457225c3ca11c0c096c833516bfcdb5c21d8d92db4d064cc8a1220961ceecd7ff441bbd52970c1e27177170ca2c735ef68da0c875ab9e1748c8d6ad7cc2ce5c6f8db454ff05da679f2b057b5ee5743591ba43f11598eeaca6623508adb10ddf2d89722a1e09dada1575a5b18451966057e43c03d3994599cff80366be28d50bff986d4edc3403545fc531e202f59e72d0608c7f7dcd52599f5a036eb5c485312d74741ee24752114392852b14c44689ff0874128687c5378a51bd98c2afd58c88411d571c63d5d49dc63861ee8f0004e17223ac2095f793691549e0e91543cc83b1d3f449fd5c085b8888b8b1d64a338283af419f246d0a91b5694d77ac896981cfc110a3d5c8d734dcc922f6fd9d399756623404df21153d94e96457c1eb0d9fe7632fc67f0a02866130b41d66ca751b1f15aa1835e18635855d8242efe6d8385aa44ef282ceed1ce38ec5230aab2d2bb51bfd00ff752212b67c2f35d44bf5ebb90200d2af6d3ef7eca6967a19a6958844d14f11d2a731b423cf3f9864fe41e5bc3a39ce1a3adf97edc519358fd3d75f115686731ac240b05b8f8057a691ff3c77a181b13a02dff78f1409ea4b942c7bad5a8ff5e6278713dbddc495cc1c9728a39d2e536f3744e8bf927bb881ed63a2a26f3b20378a2ee76fa260d4e00331c06be0d8e057916978b615c067630e896a36569a9c3749145031d75a22cf9c6678175a63fdf5d13207dfaa1c1b86d4bf8c4dbc159d940e450f4854f01bb781c3d8091578938445a57d4c19ea9bb96edc08c215255930fbe0b4c7f778e4efd9591847a80f0fc481edac8062af7be86ceef3739a2ac3dea639e53a8705cd1c00f0e43eed67b3479623362fab99735b66724f4e37e50a81701d9bb41723da76245c73689f87cac9d73cea80edbce6a6c02224a6c1ee518cfeee4bc2f74c2e6dd5bc96ee5323c50a61e61d1876c0c91b9efd94a9897440e31e30e3dbb815b392689a642df3aa44d4a65b4e6fdf43694238b08535fd0a3907425823d0a0830aa9acc94a7b250ec8180a9e76b5a4e22c2edf3bf53d5a1e257bfd708843fae7c97b8f1234b858bb089fe9302bba9fc5abb87d6270562e682e27844ec4f3523b958bf491d2f3454a8c092f5da0f45421e581d420b60793da6e83dc44670c883317004753a3883b51fed834d795ceca0d555b5fddb06570725a646ddcaf0f7dad3ec3d600140197c910fc78327715ffbea269b232715207f0d915da8f21526cc5f09bf6be554794fdf7431e32ebe4d9343e444f49af2937bdd3a27e3b2229d4746d7d61911fead80c14508548676a33f350e8338aca7591b3aed9e6118a4259844e24de2946226e8c71b6524d4c4e7037866c180def676f7e73c404a59c71f9dcab3de8146877b2753bc57e734959861677b5c72ccb7149ba787bcf0f8af37b1a769f6f8c89f3b9b6c09e18f543a58d0b8814feafb769feb9b1ef513d77688d16d98ab92a2a9bb30eb9d0be1700baef0b7b968f790e386c6abba39413d4d10437d22c04b01c4fdc5dd15f36149fb0dccf6cc3f4fe6a47fa4a1a22f38504d3e68f64f0e172e1b04a9873c92af9300677cd2b47c75575783e5a3c76cb73eb6b1ba17bb547e8d4d44b185a60e77f5d1130ab3429858f534df5c4788a7f5c3f8e475acfbc200791e5dc36b6ca00377dcaa207ffd7ec2ae0fbb3690cf0194fb253cf69253ca48f4dc747b6827e991d900f80d08b9e343b489b2eefca493b9224fb7a41675b6b811caed4a891b7cf740c7badfb33a0cf233ecd4dd3bfa881de3cc94d61390747cee7311095975e952f001a07d3b560711a00162ab68c8eac4524c6baaca9347a0b94375238cbf2130dd7241ac397f8596dd5bfbf59371034742085f3a48a2a50986a3c9cd441bb2e1772e45ce16cec33b4c786b52a5d59597bbaec3082eb1076564ff004059ab11f7d9bdfd88480ee49b92428649dce3a82827258185fb22e3321e78e94b35b9d0479098166225487ea5c609ca3198bf2b171f9d67ee60592ef61aca0276c338d5a42c56423341f26319e08514d4a6d62d6c8bf98009595c7b1dc89daa20210f037a245535e441fc81af828df3bee4c4affc92ad5ddb4087100e6b0489ed8dcb43719014d3c9bb8f8b9d4751129e6536125ba5139315f97bb09e5e1a191cbd6ace13772614b3e84421eee3c4aa1ca970c5964891f37bd7ac504b213e771b9616b0c1d843c3ac1b925c134cbfe496f9e5b02f4f3cbaf0dd27b8db182dae05b5a31a0d4aa0fac4bac1fd41a1e8965b00aad9c0a59760a29ed1ced566d052a81944b4bbb599e1c64c6f286bb619521bc4bc134200bf7979f1928e11004e7a90e4a88d3b986977c2e6a442ff7c3c39079d4cadd78a37346dd11b84395fcce01b98b6693fb4852bd3dea01994cb248c6af97a29078b9ac1d8b959fa20f26dd6b009a9364857608faadc9e5a86e1dce07d73e17daac2054627ad8b6683e441d1f8adf79a46feb1dd95304238bc9c82c59a073341b8cdd53f0a77cb504d45ef10a7a3dbc9fe079681d3a34be8fa0f1258b5d2236d6cb113a16816aca1eecb131f9e99c938235b24425629550cbc7217fe0a999442b2675d62cde0fe594ca56227c9d36027fa91c1b4b41a2d813202908034faf2b5b59d4ad5e3d22cba15ca553e7bfa0e6514be8ca0930b50e6e50f345368e0b0553ded6ad05fcf9e16983a5779c27f38bb2aea3cd18d000a1520d3b8b9f922b8a4db6e9ff30e80b7f308d5fb08482fe41d1fe86658b1b9871d6e15e8478e0c05006f6a037c781d79090bc64fecc1126660ec322721de4d4c6eee264223e82579c244cd3f5177a6e845794a041ba2a310a1b97c2f076bbee51fed2634ab75e830da30be59e6bad44dbdeb237f7fac297351b655429358a107e18d08b5b3992c53cd1b95f18ff7cb8fa58978cd64c0f5b3994ca0e77eca640638452218daf9012a187ca8e227ba0d5bd27f5eeac03f6c5c36f17a7a1cdaa5630187714ab0d0df24e37835083bd0588683da57242b486187543bd84c50af96c47434a4994096743604e04598d424bc4dbfdec011ebf7c1531e47c1a402969a14368a3cca26f77b7376e687aa90de239b7cffa5f75d64f2fe6faa7402598788232c9aaefbace9da682daf8bf9a8b6bf16193cc280d8e2f4109b5d25b2e605e59feffecf3fcd32b4065cdce85d6fac0ecfafe710fe26df0d6a29f207b124ac25b8e447c88fbc5bed728a47ffd1d3681ae5eb37120e5c48429c6d0cac122469c71cc55133f4d799f36a774c0698b04ca5a9a57055033f5ecb9afe52f4f83d9945a51316cbf40f8ecaad656e64c2496074fa93b931451c317e8d65210153424cb4eca3b9442fd20cb51c88d703ea410a2eef25e87b5829b0d7bf7d9bb4e15cf7e4c1db085104ba362668b773d80e76cebf57a15150dd952ea1ada706033f71a6e4f60e499bf80af2b1ebcd0ebfc6ff542fe9fff8fee8e458866d2b6b1dc7c76db6dbc7d235aa1764167977d540adc276129cc721e1a3f06424f3c6c14da7a0e65a20930da5167833c55406074073cf7e0d4fe79f45dd708e69f4d231621356d60938f41f3b16574c07270a167ce7e0159f2d383b4cec49aa0668ee5ed11d8028825e49b2c2c323e82eb4eb01ffc00f3dad4aef7831cef6ca38f0148b12031b773881144520e105d11c650ad56d95d78c3638af39be841b2f6556c25d15ca01a91a0703b0392bf29b6a16af7bdbe1a41b193d0f77ce408438864aaaade43efeb2f58cd48f3a08581680eec42c7af7aeba130502214ae376b80a5e61f8b9346a6f735536ba94e72836a7ad1e34719dff134e67be7a2617f4f0e5bf2ad1e4feeb5b0862bead398a71a7f856d0de8785958263f79ea0eb5a79c100c177a7aef6ccd254d831732f4ea96c8dd752b7fe04a336212c8663372daf52caa6de6eb8f9aceedc356c76f38fe3a16387f30e4fe781ab521ec289aa3a7aa6253af698d70280dade1bf51088bbac94236756b571812ae52a3dfd9f907b67dbc49675a13e36449e5db775a17110588140f288f3f520efc543b4f66faaafb633010c8fd9221980fb12f9283e22580ec47d2df0ea5ada306f71e332700018c4361f6303f89afe5c631f337856b484ed063198334961a79520482a51f66a81ae8075bae04c8686b58c733604b7ee2a42dffeda6bc4d4f142f57141f03da3dca7e2a2b5594ab26cfed0850d63ad69b7e398f028c99d46158de50bfe8dadfaee74a2bef3f29054afb5b756209f14dc267a63ae9de9076af1d4de8656f61427728b35b6f5a132d79ada567d2dd35774982d3caee6f9e480bd8a37f20f9c7ef3e81af9f834d51b720d1d85a98ea4cc831389d5904a6d4efe7282c49e08d5f12549b7c016ced433eacff2b13c35f1f9e66741cdf1af6a11fdda715dcab5d2df209380eb2b756dc83f1bf9a63c6b66ac8e6bd9153cfbb5eb6ff3976a1e033eb56c8db370bf60827fcd2f6b7646604b2975b581a49d15d16e7f244e0d7951ea2579b0421cf4185ae4518cec211036a72eb20ee1ece20b74d6c4fb18ebe9fd72e03f4d18765495e8d5957283e08b4301fa84a40cf3c4adde88e63d4e78d847ef89bb86a4053bc9223976bdaa95cc0d6f9f5b5cd34832a4d76c5e686c595e906b310346791e23b947c9a20f76cc6db40b681c332642161b64a633e95d4a3a4861c51972e44b20e3933f7d5c8661ab6d22d71ae6b00c820d18dcf72d424af3b171ed7a9f21b2c774745543ef64b67d59c6dbee6a0cc87e235eaa00b84237da358f83f99114bc5b153439799ed6b907596b543d337acad2cff3dbea470790eee1614c05abc0218cd020fdc78c1b31f412fc8d4a29e71a7a976e53c50598c1adfd7a632cfd96dde0a605a6f4f769c56e0875dc376e9895e3e5ac2859a12391ae0894011dc791be8ff4e1d54ecbbaf1392914752437479d7f18f0fc43314a88edbed5871ce51ad864abec7d27224db4b53beafb0dca92415aad08b7e67fc4b8a0b03ba672d11553e621dde8d19c30932e947a7f61aa82154d812081fcb70b928325bb1ad33fd8c988aba15165128c759124a70ae8d4e603898463b54877eaed0612487186afd2ffd7e7bb4dd38fef90b1742a7ba4c8e08b3462af91aa45818c1391b1193535f959e50c8c6f8b611a30c4756b481903c12cce89908561d87c02f4f329704f14f742285153c7752d9dc2f0757af848c4fab69b8b8cb6f6ea90f0d235b928e5da3676f36953c11d7dfb58ca9408afab5c4887055d877a84078b716af6c2eb9974ed373263adfd818eaaa557729c59676e66db5d05d002cd218e43fa733c2a97506cac4c5bd1f8d12eeafa2334c9e983ea9f5c28dac735bd87906085acba2498fcdc0bf31ee417502295634fd4404bd5bed2160db0fa850d2e06956da4c6e22cb180060af6805ad8417b7a3e76777a8e82aa28f7396619a12a20035b544f23e5710c7d7b8900907165a46a61f076dbdbc9cace9106d01158d21ba78bda5db3effe3b67fa234ab8ead4b3f9231c4085709fd26bb86ea03d8271e289e5c03a2b97a2aef91e7f96aad1d5576d50d278c37df1696a9ac94e43388a76e75f631409656c74622576c49535ddd17fa23b9c327740ecd91d9eaa67f7f4e621f7c7a137b07db661f4e758ddde37230881ff8fff6686eca7b27a22efc16344f8ce917515d1c862816370e882e00b4205a6eef7599f6f0c333b4fa512657b366b871fc3cefb47d4d2c77d984d5c62f487a6904e1a7d8f27378b576c6a09ea33affc0d7abb7c5fe65cb5b27af03c98684d5523cd66d80f72aa21ef6c9d4e01764973ca2e7d72f8440dec67c8122072cdd15dff9b59c039ec5e5fdcfccc0f8aca71c71b24f56f648c0d4fcc1e73ee6ef4ccec6236552a445253cbe3c02956aa3f58c41c3f5d816cd7b1a27a45059c20fbc1148d2abc3f245508d8af43bd326475ae908240dd29a18343f4c684bdabff54f995888efb0fc7be283db50ef382b62887a0a799b47618579d659ed36eafa2c96525a7fa3a5bc0ce3f44bcc0823b54c290424a49a0c3f6e3cf4a78db8a1fb83a6acb26f0d64a4232280c5054c3fe09cc43563f0d6167f790cc1d210d4233f4d7ad40a49cfd07ebb29217fb8cc5a15b3795a295ebb52fbe09f714318d9ddc9ed4c1b8cf30d19ead39ce192bc96ee87b75fc864ca06ca20e2051b9ed6b2876dfa914d49ce779a7ed034df46637a1a2353f504d0c4a840adf0839117fd7f23bd0db30976dd706d7bdb23f3931fa3926dd9aecc9e3deafff10cb18b15fd40bba5513f458031c9d2a310be03acb691d9608acea2a8433286f791f87e8913bd9577d9fa5be911d005fd024d1da30753fa799a06b7fa58a04a720375a0fdfe594d0062683a6b4aa014b209ff4b0d9823739cf929726c9e4caae871670fa6a74d32471137d018bbc95ddde9e8f7d51b2ac13f592336ed336826377ab34d3bd5ff53ff4780483bb17bb01435fb225b3451187730c5f1a4ef7830acc5379fee6ae68ead8798e26e1a2ef0df0c890fb7b46cfb31c6bc9c3c8867d947e0f4143d6a90b342ed988f126535433ce18eca8ed1a36987ed0c4e5763279d270260327be2f6a243fabf21ded8b76f373bb4c34d6814c7d03ee525f119a1b636a49135d96e5bb5414ef8388c7d0c64f79343cc00c4f66368bffa52a3db634e15e10d2a5ab529a8d11dd263806f8e10425abc80427b031284d66a80dcf71687c4ec27345aea5fe2975772d07e03216e33e7c8cfd429c3891e0e4422c62783e5a5832ee6c3df99ca8f7d8616fee0990f2d97e1ad9d023aa968db998274ed2345c9a2d1b8da75365e32c9e1e35dcd2757ea8117555216a2035623ca63b8c9933d709db9ab4f084bab4db803512eded1367057695baa3dedae0c3d920d5d0391ede6241a37303188b24b366cb0978d7395982a854d7ac0816a4d376309a8c05fa932ec2ec2bf27f58b654ca3aaec9f78354205ad3be70557834d42b20a63338447d3cf32ef81a6d064c67678c44f083273f12af7a2dd8bea0a8f0cda9e13d436d2fd46986e69959b8b90d2c3e8ebd67d7571778e08138bc2d13970035de8b615c804404a386d066454a73196ad77348efecf64e5c40535401a6469c593013cfbc6a412bbe800b6da71c708689dab538f741bc6fb88c8640749efad9f2eaa6c06c631ee3a6ff4c7d63e51d67426859165f70fa6951d2ad58ce5a64bb2701531db753645a0af47f9b51441dc38448469fe0a8fc07c3518d3c1222c72cc65ea097ccf01616272479bda3d1005d6ee46e969452a03282ac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
