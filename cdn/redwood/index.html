<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec276fc6fad111c06354a910ab3fad7b0bf38314a785807a7cf9db86717075f6b79902586f8ca7e96fe6d40b7e0f7de15b84cdd2197d35613f6e646af7f970523abfedbb3a1f3d8700c97f197edbce6256a7bf7debc188a3395e6987f7df68454182b506ab2c1845dec0faa36e30168c210281ca518c0082328df0d49b54b3e33db375f8027e79a96c78f1290aa8c9f9a8030ffce1842246b339ef306798e08cc93aed79a9af8b3caa815c23c11abbf0156eeef37046c47124f22e02b798004e987f28a2b4044d0bb3a27e87d68b755c4fcc766f05f5d7d9d0f8b3ce16013a80de4f14791280aa495a9f478af72211348cf857bb5afe992024d50b8942e936f1492c4ff54aec7de838361188079d0bae08999caee4d91145a43f94990e01a04bada3abf3a64f6a88f42f9a298275327e2e84881f4500ec025c58e8b5ae91f3970f26b883c9c3ebffe3de7834fbb5bbfca47991096e191fd04624556940ef07a99f81e62fdf06dfb2129876b0a7b4a53947d3fab28f9e751d0515532a2546d8d6570285b95a46193e5cd27781c8277c9ec4d8487732f41d6e4ecaa5bceb8596208c5d80e5e5799b9655e8d2537d7d1efea4a86acfad7518f406ebcc0b85a6330e9a3f5ed815d7ef54e435683b1bac1ff2ff9c6cf5096d0bb6a8b0b08c1b58968674f7da810d08281eb37f934b993ceebba06e4174499c6c664ae309d0c3fdb9c5480a96738505281b0b30189e68a11df473a95af290297c012c08c95093ac788f9716d38b243f8ecc72a921cdf3668a538680245f5b9cef08e958e364b4e5d62af6ddd83798815556c6d04a278ee07b279b7cf0309501c595c4da07e9e0efcd1e5f9751672be6399f571568658d1ae16bb8a179bee263aaa12faf7ffc47b3b32b05890014d018bd502ad70810f1ee7b0ac528e88386a35059c2b49503ab00d992ba8d2d5c59c3159ae92fb31881d9c4589a5ff202838b3933bf350d4cabfce1097971a414b0469394289bc388d4518530b17b9ed4ba73c389369fc28a974c82850f5c7afd5dedbb4e1ad10615610b93b2c2252b542f0ec5424d38a7ea859d973587247bef2ec8f634455e500af9cf5caa918434482d0e6f4a87f5744476320b740af97b91b427e3447cca1b76fb2c5696725e04371ba1633f55477dd8e30134eab89b8df509325da6afc3745ff64f463db40e451d139c1d1ad1dc54edb0fb2671f88aecdf2abb53ebd144e57166baf0a4f2d43ae78867783d7e734b8895423000c40c22aa7f090322bb4d41c10da93bde55f3785e1d4866c0e20783126d24a7c6d2defe32079681c4c18d7041289f3e4e2bfea10485a6163ff3ada9d458da319e7e61600af55cd6bf523247065bd7c32242d888662a6052b43e5f99d3dfecb64b287bd67d1fe9091183952d79d4f9ca7e83dc4ae59db4907659bb4f22233f60625b16d01e9aea1470bc69892083278ffaef9ea9a032ed7f67db712f7623803d0c3e4cb9c4c18d058055972a54758b789ac1b3f1af3346688774bad8ab83ea24daba53e02564de7b9b69bb732edd826cbae4b0271c8db29b7f19b7ae6ed32867df4950ac2480dd819cf92236eecec04691aab6c8eb64b9468d89240cd4e8a26e165535baed23d7f7ca4cf50025b2a7adcf89cc5ff7d50b88f551a0eed53c6f0ce2ab53fe739d247de57cca3ae0f8f0974f4ad44c90837dbc135991904cafbb05a6ec7c490f44b47ed5c401f5cc4823acadbd386944b553bc2b01eeb416872fc11843d2190f967330f85561d635e45d6a2af758d9403ca9547ee7ad86a6cd64d09c1a923be9bbb95f4a961b7b6d7308d3feacb7073c1a8d6c681c8f8cfd51bf5338907283364a781dbf9e6fa0be46354cc4579b4dbd44b3d6c120dce4164f0ae4007ad40a2e99bf87449ee9578f6c8810724325668d2d2da75a7412954885a53d55c8a2db5fede0cf346a25b922ac37648cb1a26a7fbf2214aeaf860bde100d4cab56a9197accdadfaf72633751dc4d0b90a1f1f675d4e148019e887a2232a4e46f0735dc56fc10bbace75f469025a05759efde96672c1f10de80789310c19bae0a0959593eb839d26cf0a6ce40150cb1920a9f0997b294e8ec0949577b9c3bd103661d67b504f7c24e9058c79c0fbd1f354655b96f12c50b07149963f3143c6dad1d2b5a8c446ac689bc990b6c91a6dedeab7341ae681d8a66acfa6d29db1d470d4bf9f1369564e10b96f803291c743437b9ddb414f79dfc8b71ecacb0486d3548a1611273db349a8186b6a7e3fb09c7868399123f973a875a066b7aa48b3f8c61f2d2a91b25111a14a7af7cf32c18ec009ca4e656ac11f03196ae5aeed536b8be532409e6bcf6a164a353707ee0de94321bb4f20728700d3258234c612f3c2d3a4927483ac1ff6bffaa4d3065b98914e0cacf04ce6cadd4c6f75662a2b1a2a663d2eeb334811e22e53595683d6b3d14e4afb6b455110fb788fc8a1fcbaec5bce79f50813a98cfaf8aee7c8203bf869f63150744f5a37e76c476b090db5dee3adfb66cc91878b24e4719d93e56e6c74300d42eab360b4225cc57f4888be5192cc8ff328d6a164eb274df514b3db8164802f49a592102a803b557c2a83b836bd6aba6b2940e9bad81c340b0acc0cae261d7153d6b160dfdc4bb61f149b4a6f32481b0011ea5d230acdfb023f36b946d123f5a5de313a03230de03f84414fb5a044a27b03ef07df5c37629bc3f98859fc032cb0372d47bd79a8d5d29f461d8fdc6747c0978b035396986376ca69b3a98061a630a2e50735e51239b8e7e260e947c9838752cd5e8338268383380677274cbaf8d0a06d5effea406054ba0775cd814377426587793399b3b87d59b5fd3bec0f1949c55d82f57262657c1f02915c2c8c7074dde14fe3027c20e90cb2432cf2dc26ae3172ab629ffa09da50bb22a1b0bd376559a7fc86830f97d4cad0de0a52bd2cef9a8325e02a481af094e03a0c05ff263f5b7494a843d6fabe0c67f30c1f42082e553bc9a46becfdc7a790c751c46517d60c04459d907a5ca043f5b1cff3eac01ebea0f4bff17e450ad7e0467b5cdcaf9fa257232f0697505c76475fe76f1a78788cc00572ba2f08c97105ef908c0867e1d5bf94e8d0c444d196a308659c44a6fd0439387e5d623aabd15a482ca4ef32f9cac7ad92ebab61e5e0382ee3564e738a4703d40d121c68558c6b730a77132a36552c1c864a14ca7e41ae70396f587805d93a655f5cb3bd2ad39a144f9b83290e31bf4a468fcb198caa2803de63a9ba8e2dfca9df6eadce0957bac1ed47de7c77b9e53d2b30f19e38c3095a3007e0f1210948e62de896065cf9c381f79830529fce793ac4af0c84a5578e5492a54e183cbd90d03257b892c4170b145423d6f17df8e45ad4e5eef4aeeeda3f3b4b5d2c5e0b50e579c990c663bdf16e8e9dbfda177dae65fd315dabe0eeaf634c43d4cd99b1120bfce73b2e823a1c9dad18fa232c2b9f03347a1f0389da3d366e8b9c44d23642093eb6a71766bfe6d6004deb900d8a67e9a8cc5f20270cb4c14e53774319517937a21ecd70bc6c2f1e2f309778bc2e35517383be7ae3edc59f0965202d1e69600decc7d06f22e006abe51d87a485fcc363f30c6f43181f9cc8ab3edf4c799324a03a6866985254340270d4f759910e9b45756cb9faed8f7e60ed974fe980e3744cf741d07f415af84252d23d22c0f8748cdbcfb8edf29ff641ef6201c8b3305e3ba6b734c189a411e42c964125809e4ec38f9f5669152a9564a04e9a9e4489e28a6e79cdfc563b8dadcaf702059943a1a7588de5e964dd06addbbd91744e56ae1f5db1609b171f9f3ae66b812eae6d882c7f18d200a979a88d85d0e679ddaf8b020154ea1061266cde18d7df2ff34830953511fd5465724c635a78dcc387977f56dfb1eaaf2bc69ba554a5eb6faaa1ed825424282f6714c8e69521838af1ed47ea4c18c66c2148c1e97f2e71c9b1425afc5da0da37a5bbbe106badbac054f3300c6bd2e7520e3c9dff2c6c928b6a77b9e668855706a5f904dcea0f8f198c227c94006c84c5a93ab54d78bd16cbd56e32b563f6aa5fc167c0ceee5e2d3a48d74598e9e1bea8c1169574c7e6faaa53cc0369047d767ef554271d4ad641175ca635e32d4da534d3ce9b56be615f290207bac36d2b4f4c3dc9fa92a81292c43e0749c614c3ef8e00820e0fd414bcd0d69c57cff0c5c13fe1850c7ef87df4e7ae03bbebb60bb47a4ae3ea3a03a4a09fb9637068b43b3ea17a63ce2978210ebe3457e12effd3f558bb5de5b51cb62e4ccb3f9e2f7198deb2f80cd4cceca2f416a25de9d70940b5a9ff6d79d49991ba2e71f4342063ef3b625938329c399e9004900d6a6c02d4111d31418b5e6de8b7f83e900af68bccf88e5c40cc7e96f5376e0c58a1200071c2bc0526eb3f822b6b70f7907e5b9fc5099ca52a6f585e99455835e76404b12a76c2e68ed298729ac57fb4d4f9b50e2f7188340a209842fa924f1ec3fec506003b1b9ef8cb22832e523a954408635ae1d345f0a4f96f484638dc8c2bdad26316529b0c5452621bdfac5f83d5a91af981d654ae0b5bac32eed58ff739c075af3ac265e9584115a904e76a402755dd33a238a37f95946545e58b70de081238f591e750be91fb88b04ca89ab5e5694203c022391f9edfd3f2e9329d6ea621a7217724f71c8456bb40bb77c8faca3a03b2be252d2315576b61aa3043ce7d5da190a8028994db8a10fb77c9bd7e1b31106057985e88831f4e90e49fbb545a29de63826f62c0e33375e6eb29e31f84f6a5b3b125a315086b9f473dcbca7d577e89261f3dd7b6112d4fe1540177cf6e5beec1c1c99b69513ffc786ed7806f1dfc30aeab3801f5890159914d53576c894f53d682e81f34dd1c20960043aa699662c2c2eb741917ba086281e87dcb5eb9e204c4fb683482bbc9cea5ffa6ee7b619f2947bd4c294302d26420b26f07a59da801d54118714c6b466f50ae0bbb78fa69a42ab98bcff7bfce20b01d54d65e3106eb6e068f8c61680635c98ecfda0b426cbf0af907431cf5ac9b5e8a3270b55d0bf736a45b00de2b89c3382174ee571e55e85e11c1dc6d371a65ee51bb0bde2dbaa504a8f0ee3af6fdf81271a8fd0f9d19e710f1bd37e36d17a2c231f8470b862727bbe6764bb21965b6808b39c2932dc9780a6f96f386474203e56f56629d5bc54756d335a15a4bdf2f60d18f02cc59c4591f2c34def752a17e312897647745e0a62abafba9509c67fd6719ab990e5cf8238d7c68075fde4f4147003bcf20ffacacff1511649c6556396acb56323fa3a1bf3f4c0efd4f93865d73f666fb50e588195ddbfd2360eeb32231e9951b9ad2969265a3e57bb8543607f3d169298d494c7e6c0b1ed1734811d82f8363b25575507488d149df68c5dfe82d0cdccc6a4d81f23e848502101699f864130cc9b204b963e8dc2bdc13d05684d2d3f721b658a9e54502d9d3e943d6ba4e238de5407d5a6f7c7846b3d89309cd76dfdda804abb059cf65f54fb04b272670157b896233da35ef80b47f5bf4ad3a09f162e89f45087ff4da6b51a103ea9a976b9bd189eca0a30b83dd8503f0bec120c7a4eb145815fc8025a3024f269c15b264ede1e5b80a2e390e142e4d8e95d4b6ce1534c23ea532ecf65b928d170d04d3be7df21b60aada83c18f1a0baba7e1567cb3499ddbe6c15e082261b19df296ab21f037d86a5fb57ce08a4a94b78490be73d3688b4e4102afc69ca1828b7e8640cea42a1750fc5ce1b7abc2a0860dc094dc508164e11a51ff9d3f284110535642da934680cd808d6edb8aa104791b71155f6398cf1a2962aba115d946e3e57520adc35190896e61c510b7b2c2507c53b42ea1c2e440a8362b00eb98b3f18ffa99f42abf3e545cd8927d01b96d5ab28781c613453edf306a8d6e371234eb2660f636b9d1301262eb6e190144815cf4d7aeaccf79aec64bfb0c3cca21119cfb8ebb84fb6282ec7307444d1b1c149408d1c6c14f19da0a98911f9e6b52f6c1d00dc2847c6d18f1673647422cabc91fa58d002ddb2e61280ec4503cd8a98e583c28f5326e1cad4950295fc49c57adcc4a4cbf1471e12e4a1a59853267f01141a67c42eb4f7dfb0b9da15c86d385451bbeb6a6ff81302083bcfdf8abaffec79df00e1140f8c4bbd8e4c8beafc17d8aa1be4958cb7fd5cade55248866e43b6404f597237b9d8cfc38dcd159cfeab48c7d5e98b1a52f1d4486c12c3b969b54f129dce85e49f4b8905ec8b02a882087fdf392b05753695051bca90f5e6c798f5d742699cccd44fbea814c3a1720ce163b12992a4a4bbe12b95a0e694d51823f7c345997f40d732b2e3c02bb2c001146746497185de32af356ad67ce06041b3ca8de82353a8be0a3ae25827267a555a846cfe53df718e733d2277d960617bc9de014ec0b334de9962fb2281508af1666e8ab02476bf76b08aae0ffcbdf7041a11fe502c5c4d4fb5666279feb2b385f53b738e6d85af6f453d29638ddd054cbffdb709b7f38b29b6e94af7381b6729172d6d70fc87fff84d382e704e907f40afe997dc1f653ec11a93222237b9bd3776a85e531baa39bd9659d575e35c2d7f65f9f068f678d055afa8e148f24e5d5a3c9d1e32eb6b9150cfdb2588fa9a2e18cba512d7b724d9c142639410e0b7c740ff5c8147eb1db7194b8d2fad632a0897d9d264f921f94876625ac84111305677bfa02a98f9687623a39b52accd7cbfb30dac6af11ffac519270cd68599184ca7e3ac77bd3b8593ce3ea93bd46620b3f151100c7011270bf473e676bc7651ea5c0d197bf992f90d333695d3df22bd9e88ec57f367de58fa98d3734b280da6b0a70ec0e47de4acec38088c6d489a6e42bafd59d35b906887275abb907b1a4fca4312f79f177fce4407388218d8c1da3031711f7c5fdea3d035b235a7bf792d7532b25ec2d355757dca7ebfdb92de3cb418b7c0433ff6a8ed5c81c818225a955ae18362e7493f8f566ab341438787445a190ffe636a7455335cc690d2b217a3a6d579219bc0115a23f2d67c2b9921c8b7eb90b762094db9735684c061ab7999c19c4cfef79cf64fcc5955e74390713a73d271b5e67a276f9036e1db2b6c2356028ef55b433a5de96343e6d617684442c65c466acd0d504c0e12908c627811519f327d8862878c2f285c0de4a866a2ad0236a65fa25705b0d8b47f309a590acfdff66dd208026c9c41227a5493a1ef7ff2ab440af8a5b36fae22839fe3d6c5531403c1f07f2ccfa365974ee4b5b9b23daa02589684f97a1bdaadda0361d11f8b2e66841b0f2a9179eae4487a93fd7809f1b0dedf81496b65ce5e78e3038e47ca7e39e757eebce28c7de760531c7f02a1ea2c3c784be194268fdc66cdf39dbb5bad4c76bb8257657bc693ead7d87db11fd4c874b15423a4f8a45f939dd7521c0613d95f4725d69d5c5c8e39ebd7e37615a5fd3c61ae5712f1ef4b8ef4fc978372569400b2bce1ce819c42a4d36fea8ed2944d6eb1bda57dc9fc2828785ea77c1399f3112071af37b896cba60a37484d67392ac8faf52de5bc41b0dacfee35eaec666d92c69376834f79a8d50071c64804550094a5ab773aab404b4a40311960e5e68f3fc29190e3b736d4526f1234af6524ac9845c60848ca5e48ebf049c29f814d0a7ecf357e9aee8a8d750e688716a906773d90113ee89addbe75a81659c86aa613423522e197958e23870fa50f2d8fe4348b2f75b5b7fa5a09a61c0e5db1454a525db90a523e505e87a138932420f62a809dce9aa9327f5a7369d2107990c61b13e2009fe1e5ddf84887cf2740b1f91ff5ad0d0af35db7e5b11a570c12dcdf9230c7354dc45f9287bd094774b0fdf91ff9411935a3fb7d91d035f7b78ea8c7f53c1bbddc3619b750b32e67f2ad0cfad3832366722ed9bf21fa93ac0b6203b59977c48288b3d808abd0cf3ac92c66444cd39ede49082a0a747bc9005b77e68059c509048ad7b08a355d2ef008a13e31118bd4544d4dda1f88bb388e9e0b1d57299580e1eaf7ed346b9d81a1256660e7b22d2df7410bf14985f6b3c4490d20da9b4cae346b71206177dd11c521e3da131f38b8f6f943945e31ddd15b090c8d07d48391388c989817b33e54d3b6cb852c8fb2deadfc54f6741bf963683b6dda8f78daa0d82adf029c77402b45491f3ea36551d1c095592e26e2f6b1dbacab7323463bb1259a148e4a21c04a71af9ca7f3640f40d57b7a691807f8c90519b43553092120eca4f79933a0926139326a5e0bce09fce2ea403b347f839aecef4f5380b7507b8ecf7bfbd9a247fd0a73c7d8761a9fe264982fef3d848f5fb7a9375648bde332009603ecf31eaea98e84c8783104f76e363547b1e559cb4ccf6ac73862cc44fedfd8d009fa5fca5afc3c4ed63175d3dcd29e614f7d5bf6f0749ff3d4377d14602b1648e072aa83ae2fa05ef4f3534065e4ee1480b921a9ef806607aa5669599d5444663ddfcdfd3e945b6fab33b344e84842378e9fe98fe816e75bf7c70bd5817d69439cbc044448348f86682db7c867e86099612fa5df8ec4e94a46f982863bdff0ab53b88353d72151a5b558c0e676310ab15433c6917c89c8c438e67558d5877a81781552dc7d05c58bd72cc0dba2975761820c2cc0112d8ae78a828a65ffa6dcc390ba03c0318d986e652928adc7189279bdfb71ef5f76054b042578625bc69ab3fe9e250bc9240bd9f12d3a5e58403efaefe0703249322c2748396f9f46caf9328baa607783f27828ed211af3a786b86c22572b5d88429e725feaa14f94036c89f43cddd2d50eecf818238f309234c14e2787c24b48a99d15f1303f97f7cbd54ef9e303c7b2d15acecd249bc01788d8e99dccdca94ade67a2a9dee31d3703faaf1c9e12bd3cff58ec8fbe7ea5a47c92098f0f7b022ec7160afcc4b474efb34ee4e5b45e8a81fa634a957d2fa8e0ea4518eb3c16cf39522301fb1426269ac6781af489e88ee36f8c733dac7becc625e767bb80994d98a2c4eeb8be30b2d8de7d9246b72314bfdf98b3f048f42f926ae202793d7039eeb995b54b7a1b8f2491059cbf3198eba0cd1b1f2e06b1dd96111842bbb3a4a16c4a60e3a363af0a959809ce6a8f3933e1cc6fef4661f821d4e8db07d05bd77f2483b866d6a122892d9da52f67b3bee17ab35916af34668b4ee38863f8a1d09e5e55f680cd2cbf50165c972b147c619f5ee1d97e420361f353e6d386f8ef9f5625c5505b35d8a2b22edebf2f815bbcd9707fe3cc39b0ce10e0bfcc34a01ce05d4558f8848690c49385bf024b835ae09807f1f5329fdb2375fc2eb05e2de27d79977faf1e90fa84c42eacc14826684a39cc194ae175183ed603b34b9ebd19c263741a07d20aa7625e8d9c46ea7a320df6b78e08ebebd41af2ad5b14886341c4c4389742af424381fdd2b1b82514050467e80cb198b85e65eee9c25303ab5ef1d21c942f3c4daabf70a832d604183d2c298e1b22043e61a0c94afc089efcdb77941ca39651cf23abe7e96c0eefdb6fb80185149256ef0e62b20a7a7a8e5f486ac55f0bc1e5f8eb98e0cfcb343970fddf6105ed0ef74717310ade78c4250bf2f3bb9e71fc89e12b1aff6161a6583bf1abf757da4c4eaf9fcf667201741e798a94e336f99d73ac0bfd3a6e66476fcd827120b738991cf9b0f901215b3bea251a15aa5dd965e6c95df9c371eebae81f4ad7859b3253f2b66f0230871653543015d531a277524e5329f80e333ab4d92c2d50113d642166bae02dcba1d6a789bee5029145d43d94d71c5365fd88ea75385557d072dd0936d6003bb446b17bc311060d3a3f2a85e677d230389c7930edeb2aeaf2db97636852c20982d7daf69813d9258e560cc80b2123421e9d5fcbf2ad1da5e350dc1e1d39154d930b99d6a64400640edb1ddb9cad6f9d7e3ed5399de9af7b76a9213edaf8f764f31fe6ff0bbde44224eff1ba760286ec1c849a26f40ed4fce717cdc234b5f0c20dc58c817efbf7c48184e10bb0d6d608a0f6a7b0e82e5aeff9ca810db43ad0b5a10ce99745a76baf42f98a8dfdddc2deeaada867d910dd4f7112e3221812f83cfd64cee14c2aa7614d7be33cc6e185029891aa0afbf6af71e417eb130fc8e867a84decf39260566c04bab3b9cc47d994d783c0f5310019c589e21ecabe02970df790eb7bbaca5beeec238c9ea0b2b7cb31717d434eb043060eccbdbc3307fdef733313001def888b8e5fb46922484a351d6d05d554c43b657be42d26e2479514c031533b322287aad31f46eb40380942ffdf958b2eecd5b1c845474a1570f1704aba8625068ce041f579723df6f8d5cc6a3e08b42f0dfce58be4047cd008e04067204788bce5495adaeb86c3a127c15df972bc5faa71cdb44480ab8192baf7273f354887b5703c5bb7578b3a0e43bdc7dc62c5f1458506b2b7bd4614f12b1de2f70dccc4e294d7668115d7ad456717c0667db257d0904afce7a308820a9fe0f245c0b674ed774ef5979e11e3e4668185945efa90273239d8fffcc23b22a2ac1da6fa2c656e30439d278671bb945513b8a41588390f9cf8acaf82ae4e205a79019da0f95b65755e2cdc402f0c1b7c95a3535fee8d7f19f1b844ea8334f5440967ee3af1069916b6f80e05572bbea3ed5a28fc32e970dd9608f4d67c14671383a9c2960200f31947ab15e9f985e89a999df88549decf807cd06f472fb8f3df41239fdce68b1ca2cf3486c8a7541a4b52cb8bc7a8a44f7b0428456a4bcf8662959f01c2e7ae4271b5bda8d55965c9d02e9416eebea5b9e2ac78d479783e8df4b3abf92742bfeaa793fba2f9e97aa267716b8144d486e46e06e659f3dce32fff98297ec2a911e8393d562b084a1dc2a466c394e8515d64c30b7fc2e129138b663a7218fbbb6b03366554bda8f61e8faca0ed487488cd605ade29f00ef0cb55fe6adc9ebadaf32fdf4da4a754c9c4af07630e9de46b7b44c8c07871085579c0742f411ccb3eaaed8ec71dccdf9e5dffdb3b7034ffeafa22a57f31127848f38b82f7fe6217a0fd6a9f6c3bd3322f79d5183ce75114086e13fc37a481ba5def8c0d5964b684e7dc1308650079eee81284ccc5d92af7870fef2072d243083ff0b9cb2d1707e826890544f86ac9fc090af0ba3f272ebca91a3facc382c53dedb22f381682fef8db4e6ab89957d95bb2feaac03ffad01fc1c7e8bcfe2d9ac32acff0d1247184ba361411a8c6f87ffca5c5a2d9bbb05f2de972c9cf3f0e8bbfddba8609fd49bf3c130954b58ac7f3afc8e06875dd2f44833742b8e5899ff0852bc56404275406abe460ebb5814e007b9b972c7c9bd39d308a02e721cee82c6d573bf5e7beb8242b6a5802e927fc6975849348f624dde0a15a3ef7c546e8695b6894d36f381036e705039770f00be83be218f4df02cc130a29985b8a870231541c197036f1d1b4bdd330fe51d4746bc3976af2f25c069afe9ab6659e91809683073bfddf7de52856b2c7eebbb869c289f80c6a4dd8c037529cddc2436ec7ec8abcf80bdf88252015c2502131840735a672c832d0243782c8c8f58cb18ba058558e402739930c75ddf50cabdda5110d11cf0f2b3b3a57983eff2ac4384e4e6dc2ce530dae1a0aaaccc1878408c76c2332884b6a0b90ae40dd6938e0a9001576a8316f9f9c6550bcc99b99b739d86c1c2a68ae13715a2db8d6916df79d43ece7c298918b4fbd4cd326854a7172579ab62535df0067ccb6d5cb9e97bb29ef7c6a567459795c2accc2cc789899a5b5916e1d477d7a8c61b57a32e3dd3c9f0994c342bee9e40d7d1a0275f44c6e5ec2d17642ce965ad1bd381f0184ff790cf67273c3073b8a02bae0713b1ff82e20f55feac1cc3977b6868fb4ab247d28daff9724202051cd461e0a395b9ec15e5dd7404d42c36c8ac8c02d32c877d76c605fd93660cff6e062fc4037394e28d807d4026c36b1954eccd5db18ba0a6eef3d41246a0e41c57ba36e91f2451983320a793a87306c5c5b296743a2e0ca51b19fb6963cc75134c47d109526f21a254fef9059ce102085182856f0776ece35ced33845ba889bcfef0b29407ad88a0968fae1875d2f85ac78107af9a34b4bb44ccf22e5328fbf31a0de6fecf73d0294f887439ef4cdfab8cbd1774dd676b18765c131dc2974b0e117ea34b1a8f45669072fb470b937397cc15aa8f165efb22b33bf03d702e4f67f24637adecadd362406cb40ce0d43362b35ca8af9163c239b7caa2c0d75d037e05fe2ba3135c3ee0b487b41671476393d964fe33dc8a94ec5164db470371c2c1788a5be1cfe52d97e0bf7448799097fea34ff6d38c6095ed68d85f8a9d0fd99404eeaa77f978f63db566f2885c349925c4301a16a383412740dd1406bfd77eed4809ba8ad277dbab9c87f3472c782060a1a13dc6f5511e6b2239595dd22b49137ea789ec4c55cda05ef58e826b789f89518a07bab234ac925dae6e508ca45a8573679e0b976ec28c57121bdc0aca7426046f937ff5f5e5c257d22f0ddf81ffe9df8971483649d52924e03835acbfb63da414bff54e37d684a8c503b51bf1830cda78b0821c31aef42aad1f7cdafdcb4fd901bc9bf384350ff066f20c4c93a7280298dad2d4df897190c4fb73025418a1cbee863bbf2ed83cfbac90da189f97d8ebe89fdac549dafc010c3d0395ff98700776cef736f5c58fb518fad0b2cb50cdb08ef4e24fbb6346b2ad522ed26eab07c7646a92eced45c58cf1f86961b7eb96e0f25ae742df798d025bbba06b0610e8079a5f4e01a8995c79f1b2cff0f00b35503a3d3a96e7775df0a3fcc49ff3a5674f8c50196f0f6381e273799aab5edda6e3c810f4a1d19c4ca7d14dea1cdac5574b96ad4a68dfe88e0a586c898f2902031e0753f2a818b860fed88c92e60537a0b7db380c931f6fa3d3a909799bf1697600d12e06d9dcad3ac39785208a552b82b03f20c583617776d41059d265cb1af696f566127ca54ae9d40a71244605e0c68bd787ed96e34a298ad6191764445993350f93f53f4633350b688b203efe865935e0f607c94f65c97a10644bebb7347fbc6e3251a845a6865d81b67d159509f20aa3619e9690238c2a240d7e66ba177c4cabb4af83a4776493280f83531471c7d95695317a0d3d52c0ff44ae4c3c741916815e5dd02a727d4ec5e87a4b747496147718669cb459e9aa0bfe8e30f67c42350dc0bf715f688bb15e61c143a678edc4fe9a5e7e8b9e98ef93e13714d53abed801ddbf38140258d700792c03decb503045c5f549612240d4f0b42deb42533c298d989ea01f0a80c901f5c5ea78f70a3a48ab4f188367e55cb307b390f06467eec699f1a7048d17fddbd20022c7325e3b6f37f373f80a7f31e5c02ef9901d19649bc33876b001beab4a2ab0e412bcd2191dfb4f1b75e50e002caa8eea8e5dbf46a4d212be8a1036e2528d86771955e2170ac1b5fbd07ed7eb43eaec0ced4963d32c4e98623b0431c1f6ed99b74c0ef9a20ba827c866299b68f4d5308fc41950e1906e68132205e442ffe2ffa643d50ccd804f2beb1e91146282d67d7c91979be275359a05a83628d8ea453e228ef7c83825b2c6a29696c6bd1b8a8ccb026552d15d66013a00e4069dd93c10653c1cbc1509fb52b93c3b571e13a66b32c0e57417f256f8a7397c5c080c256ea409297702a5fbea110401683c8604f192732bbd2905af43a4166e292b5f63812ad446a1f2998ed12e39df08acb1a8efb941d1d256ae675013c2d05c8ae79107b0487d711ec2782bb93f7e4a07782232fc4a72593f75bcd8bd1aadf5feb700a53ccc20a88216142f39002db828cc5ddeba0970eff6530280dff832e09daaf92588bdf9c2a6f3293ced6afb1559ce70a2a5098c7034df13cabe7d5ec2c7ee0c2e122dad11739f8bbd59f8d0afb323cf8e91c0437f0a58222192adcc9e5d8c8d5ee9972088e1f3d40d8750b9508ebe09faa8ddbf3dc7c650309ace328382bd5808e2e991d242700a1ca9f3d0e51d535f3cea3c6b12abb1aa9cdbbb5dcfb9a3829c68cd059b405fe23c348074b9877107b534152014fd9d09259ef361122876fe10549115d914b2252f8940e92d28d9a343354c86f37abc2c217d066cf2199f4319c528b4ddc4707bf131a26457bf6cd8297918417dbb057ad41dd1be5e22f3b720c6a0202306a3595140b1ad2f03240f581323eef57b721731691c0e1492a7a5099a40a68ca7e4261406fd4626cc34e1998b59517b713fa687e486ab1bc0e48a2706474f3e89453b93bc7e9ea8c0fe372d1d74c995d83175e0a7472bd924387948c52e309a9a3121affc94af92de76ba21acc1d09e5330ed90bfb5442c881b6b4327b281405e8c79d6b63fb913709d151cf8c94f4c651ab3d0fce26cadefe690ea3540dec8b8d76b07329f1b31d98b620dd90e22bcd18ad612c4415331513ed5ddbe6d9553186f7c04e5011b9ff8408477d1e3c4530edebc2e187adf8f678b89de1780312154228b916746eb932f766904238cd91214923cc602afc9027e42c1dd24e75987635cf1adef13a7be79ed27fb17af157f77b47cccb89f90e716eadd8d7aa79da16ce883fb3870fa8890fa2303433db66a9741e4a9d2d63532ed436869f61e7a211ededd884f3e32eab29661696865407b88bf20c42059b277c71134fd2b4dda05b953e7dee77195c7239918241c37cd7c4f43a865d8b9804d02fe7c59b632786960e3d4e7037d004eda612025cf67feab2830e8704e41612e1fdb09b386cd83c5446afaad1f6ad531bda33b5a1c478978eb772df73879d88311d863fbd050461489f4c22796f090d0c22701d055fd0f01f0c04e43426991eefb80fc763fdeda3ffa47c1f84ecc6b0722333cdaf6bdc0263187d41e4a466a45c23d147d5421bc195d4a40934d82a716c3d03ea063d1e483a684d84a7f60ca5a85ac22663c74d2ceaeb723be3c048bbc1abedaed3eef646c13aefca576c4d81282d874338e1b850bb212b9b567f1bfa1096246f2291ac9cf617555f39c6eb50cf3993df388b63681d2293735fb798bc6b7319d933a8b22fea343bc228fb92cb51d773ee0e3959a3f4c028141caab683b1516ada3155e6bdb0c4f9adda5133768f815bf1acf2c6211de110de910ae43c10c1ab6358024f9b327b5ed5c6ef64c5fc0520de44cfccb39cdde6b4f536c7d178cf0ba99fe684b6986025ab84eec5a9e3b3e3bd85e68aeeb6a19ecf8135f5c6db84f4b3794e5e88cfad3c95d6fdf725caa2e8e3120a6d402b77358c02bc54c0abbfd9946e668df62a59b54c0daf1fba7df874de4d22b8f801036e2875957c20312a64e19fa0815f6e9f9079c99837ea5974de0da96db552c991f77b096456041dd77f5e72104ea805f84f9ca3c887af1fb5054608a6fe0ccdf3c741a1c7b6aa9d1a07c8cee1215d711039808b76afc35bfb773cb5550eee09822c0977a01e464aa36358f31c7a3aed43abcd1a7664ed6cf3baf9a935f0ca5e05ed6d1c405dd37c7c9a7721c3fc6a476c6388df1a442f4dad1f51e04bccdb300e76528b866eb75e410c3d934c820dc18b34cac0f9d484969fe0416c2047bb1fb8057db5f5e4cd30aa793590cc0630ab0c243e3ddcda5c707e0dd608d1620b40600babf986889e00d02dc8c41ccf9f36bdf4fe30f10e49bc4905b9cc5c14adedbeccf32f71d508feaea291d422052edf338d901e7c34c785ac343dffb321d72bce109d8cb24fcf6ba3ecdc07957ed79d42b9b8b649e1d8dc2bac07d0eeabf2245e4bb44a69d471489dc660e0a48c9b774f957680864c190089e27675eb0b95dc76e5f6f42a72f8f3869cfbfcc778c01e600278c0f7e67d7c8b9b8a22055fe0ef2338950b249655882e6aac8c2cee6c04c9281ba614fdabb13abd66e7a7a1aab48e3a532595a8355669a91c7a1e5f3f9cda6c6d605b7b4ddfb0b3f6efcd08c0ecd42596fae41dc27081a352d893acef947ed2758b10add5545a04fefe05b82fa9dfb4f4ee34bdf015c20c5cdbad12c6f15f1ad5b24603845e396596f3ba2ad62084ecb63195710d80e74c02f1fd62e85dee4b85112a10a69d64574c15e87ea27ee2a2f20561708661404959f1e64c56580f6b3b9e62219ad1a3565210b0453c8960060d30ee8b0224a9b274f389eab527ca44d9bc9e70e50f59ec56fba0093e28e9e9da048187d5f12fdadefc2ab91a7d7d82a2c63aad93f8797659ad02f5a7031bb44dff4683b0edadb677d57277dbf63ccd60d634c110f3516cd5b51f346a2a95f16186c2fef3a40f87c33bd92d719b20b2887a9b7021f795948d299eac1b36eff55e4f2b17c57b08ccf92c8275c02e7b6f8113fa5d791dfcf82f76629e13da6b1073b5e06b77879de9f75b240975af728e0683f441646a2c33ecbd650792eac804a6f51c468ef9fbbb0c38da77c69801e29c45d161666dc5ec6ca07be4e9efe3cdf3aff86db982edf6e170dd21dfd2807eb7b648fd9fcd9de887320095bac24d6f7f94794a1fcb03af99e5a7ec9f41b50e52d8e8ef2a790a17f1886546ae113b8053f4c183ac9066c2d34ae1555b0eef6e1f838f589af42f85c699064c3503c50ca6908357df55b22d0a9d9a57e0a7eec91186808fac159900aa2cb54aadbc36fa5f4dc25f896c4672774c5997218c150f2a8cc1caca4b5e8d28a9b94e5e183b421567fc31ff20f2839154817a1c395c32c05f3b69911fa2722d78e3d9457888a4cc97393376f75ea9f5916759f3c7fa9afaed9ed17b03875116f42c412d50cb4aab2a55edbc98fb796de3234af9973cba7557a34a97320c4408ce721254f81af7c86d8da89bc3cff71cc34f108c6083c657723e8e708dc8aec9460aa72fe90a1e53ce89204fcebacfe226314b922e3f866bc58ceea4dbe9ea6b74a572cefc13f69e48fdfdfdc975c4e4525d7d6a234f83c0b7393ea0c061040082b80c3c5f9573b01a33ea66da314d5416179cbd6f6f65b11059df606a528fdc0f0d61d1e49fe17e831eb2028a544d7bf7241d222c63ff4d2ad2266f3e7eeb663a1dca393e0e607bd9e1d8eb39893c19d2f157fe6ce7bb4fe35b76e782e2f8d8c06b52d31e5d99063f1ecb6514648657759177685693d441be4a8431b57b95804061dec9d6179738263c04b839e6dedcd1d18f2cee55ef265f4dd2fe98ddf375350010c0f6d43668ea4896c82a0c0cb817b5888e593846d1a184e81bd921b7adb0056bfa6ee009816d5e87df5f04600b14e6d54c62c27e578667995b90c86e2b57d0abd58f307d1077f71b1068448aa1c57b39dc7f9bc7499f95272174709e01030708961c8166c0431b41d806eae84aa552d82a2f672e26306ac3bbbc3507ea6d439cc3836bfe1564b2e0fbb080aa6872b9d0ce1ea180b5515fd038691ea3c366fc294e1f2121317675822da4b7de367c0a17844eabd577d4ae9db6cffad39a19c048fafa73b26ebdcfcf39c1a2e3ebc247ff5b6c493d991a9a2328795e62366fcd7b62332e54b6f13af6eae8f516b44fe41f56490ff464374f9e1e1451ac6dd1cc015a52f0cf91d7c370f89d391a11a6530955ece2b674e63b676ac1944e7ef09658ae3483fd0fdf60521654876805565b8e26a02fa3d7c37069ae01db07a3ae1715ae90c0c0455005fa6c56350e0de7600dc716196e16876d0916d5eaaa0451801e8ea91e2b81a9555f45187e06dfea5123d068fb5275c3c93a39515cf3ec432cc8cc3e3fb974ca384863d728051735505901cc4e3f3570c554e24e512fcd95797c3ed373d5457eb50e70215db25c29e3653bd999734e60dea507027d2c03cd734f23214cc457e31ebdf8d64a158c24092eefa879db157e5abb02e67dc578030e833c644022e2a7d017482629d4f19564f18912675910d4ebe3b8e62bff8c79a7b1cb903b41a5ae4278835487b97f1754202900f22eeabb5ad968feff20806d3e26bd1473f21cbd7673af867d9c78422e1031ba88972b26cf4a317ebaac8d754008428b6d0af45d1f4cf131aae47f0d348d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
