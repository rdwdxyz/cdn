<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bf7d19aa036114f281af09a13dd01824a18a28c4539bc90d2f5599a2f6b516ed078be3c8ce77e844885eae9693489ebdb609d63154d87950b1d9c08bfa812032037cbf83eb756cb6bea1690b9503cd87db818057a7c6b30062102c3b495272e0577f66ef54d2b051fee208f52267353b0d61f0e7e3b4e22c32535187652a859181ed1cf57e6c37f8d09ce999c6092653cc87d4c990b07a6d8b18e9464f601a19a03ef589b7b8b7b34bd1e975e1ab5f2a076f47d2ab15684662d023dc9cf7a9f5c05216f4de0531a7143564923f2a85a4ce8e2e6bb9a97a55068df271c9b51bfeb333a4b313830201462a7a3f01644478dc817be195f6a1a8ddda8c0a7c6a13261b65d8d12658d0ba5d2dbc631bd12a050a9a4144f16f1f4e118fc3bf4db08c9c7515ad4459969b935740ec460e3ff7ad80ae12bffae15064df0b833df88cbaf7eb1552c0c76938a132c689a5e1e63e017e3e3dce697631b76223d71c5621c44ee09f3bc21a8e57b555d2808b6f7ff74f92e02010070eab4b2e19e8686727ee14f810e6a5dab9090652c07766346bb7fb1090c447b312113ef34ca7bf09c67ec57949ea7a409f5df72b5b327c207ab33f83bd07cf1f4f4824818fd08badc22dab3ae53d8771c2ecdc6e5e4402a647c7ead8acc20b570f60aa73702cc239ac25087a6d6c3a9c633d80b013ff8cdeeb8b2b2a567891aadea1f1c61e09285184ddd2fb50e97819cf5dd73ebfdebb688b54c112d1ef4c3da6cba54b08f834e886002287e4eba014253e5946c950342632fc2747dedf77fc1eaef08f3021f4a81d61326771ae6c4d5ba20ba732bda0bcab5283b268f827e1620cc9db5fbffce727b97cedd47e56931a8db5b9643d4f3bb72f1aa1edb5c9540654cbcd2661bafc2cd0a8be877418e907369ea2d47f7a844df2f864c996ea0e54004ad2425518d3f6769945740841f8c4e00320cbe7af01fd84cc88b71e3f6209299bc98d9b191bcbf36ecbb79b0ba25a117cd753ad0bedbace7b037ac064c432b6bcfebb7d7f31b2a0112068e9932da9df7a06153bc4e55169a6f68a30cb197f70b1a7fdbfa9a24cc66065c497826b6a0596d5ea834d9d372dab238bbce37ccbe7d7902aa2545d3e1f0f060eaff7bfd554f8dc95f0ef7665a0ee1e76c5daa3b81968ec8dfc3787b9e417a8b764ec929a35ebf84b722d855b73f82b74bc47b7e312aa94ca2fb9557af41d6b41097ef4cc0e8b8c5eed3b40a8a5e872653b938e5f401475b9d7c9d1bb11ac388bb9071027993a3661426225c0ef58315ac2f2dc8cbcf20fc3a7ea068dfff9817a59d8c6e95fe3ef4dbf3f234bff33d626dbe498513b7065d0356f2b1ded9406222ce9515df4ecdf23632ff3983eae4af19b7eb746ba405321070667263774be1aff223b6194d5bbe2598d48601a1eae8b65e84512274cf41307c8eeda75892453055ad71c67bf97418c889f9c446505d8d6fbeb84d6f340a06bb3fc3924d02cb68094367efbedcd6b424ce076187a6e0d9fc400ec3a61f82025182712942edb3f36cb3cf54566eb015005ab5a77e0483f6794e9600a7fc13162fe4a547ec95ec9e707b1700d6d6eb7a05f3fdfba4f15dd34961e812179f75905f7db2212ea10c2a51e68d5744b42791dd443997c2b84224aa5e89cef69cca6e527d779e41922682bc563492f77a5441ba15146e08767641a51ca23531cffaaadc0c6008e8a28e7eb1d4f397da11d5b568c563895c065740321156ee21a9e83371fe53d52b257196e603ca0273f8132f8729e45cc2e0b33f6a1b631bd4207ec3535f893d45ae609048db3d3cd6ab4bfd1be764c12f963041c36d857dc1ebbe93eb0d91bfa2df37381301af49ddab8c2ddf96ee3f9508d1b4c2f293c6fed29e3b326ec25bdb520ce7a1945df5fc98b8cdcdd74af39fb9d5e502aa9cd99067727001736f653bbb2f32930926c929e50319ab501a7c27fd6c215e3e8fe38887f3c5cd84149d7cca385279941aeca95a83414c8e17aed6fd4fed7faebb177ce85ee9cb1d713284e1848781ad634e7f464940b90b8c357c8a0721107c750cdc68aa2203fcb04d6782e3fc1ea7ac9d1d9dd53ba573935822dd6a26c4929a3cb967b7ab54087808ec4c498777b191093649f5edbfc53e84e6a3e4d09ab68b0a587af115361e6779e2033bfc67a66772eae22994fbc0471fb2e6a06a04c83cc4c729c9227b7ef491288a4a9e4d747502fdc972a63bd22a343df00c064b16f199e09970f2d3a893b6adacb0db1bb06863f043dbf9f3f880d13ae8321753d037169bffa69f1340313bb3decb11783e097624590d9e67aae24b4329ea9586672a6d0b8fd27b6a6230696baeb29b4a0b43cf8702c84d91b67cc4c9ff6309b0e0d7a76591de53b6005250dceece2992f7d56e57c054a3ea6674609402d4a6c3d1e5ceb0495de8f21da02380d30eae55f1974cb4160dbca9197b6d76e89e914bdb3ec12a48e4db217569b7cb694731a11b158b423cc207f63ba046837a73a76c41702191049f6301b7ce7972105e93989907b720b4bd1a3d60f37f46b34795160a36bb81a92d18edf4287a8aae5f9a95567cff816699a1331d122555ee138864a6ad3a857341eb8103fc66946daa27801a0752f6dc386d91196b27cd9dd88ddf1a10308b975d418b414bfc7549eb0c55e45ea2ace60acf5521dd39aa6a747e5e0fda9574b9d0d6263aaa306ff290a410f869fa81cc86073f37f5c536523d35c1273a5fe45583edcd879e7af213c110463098b3141ac75d3fab0dd31ebfead9e2560f92e63100e74bb5c29dbe5e89a5b7be5eaaecfc03fbf414bc483f65bf9aa49b5f8cfe8f829a4e0807e9b5f37bae9bcd8f44ca895ee8b68659ccf61003128f8763dd8e724bce653277e65215f2e0994947de9e2052404ca4b1c1c7371f2dfec08c3092f6edb6414ac261866dca3246617e271bf00413ecd9174c15ea17bebd527287a66a848d6d471665a6e913da7c52f6cb1e56523da831c933542187a7de8b69211545863d8bc1314f32772feb2d38d2517aec155d9ddb537a5811a140d5298a8eb7181fbe677d58d1d59f5dbf3dd4f3d00d310433672125aadbceb2499a6febc62a2fbe2bedb2fa7aa4b42ec83b8f4bf1539dd41b1280945f4320486279d08bff8d53311198b1279e0480ef4e60173fe6ace612f24b67f0784ae4e994a465e76a5f2f94e59d154c38305713ff305fdc32dc39b9fd347987c85279c78bb918df2483db4c8dd5ee68d9a359932d3ce496bbc9219b6f5983938361ae183dfcfe4090d1a21b7da69bb7e23ae0fd7b596276fc346647d89382fd1af60ba563d9661e2aa11d724f9df64723e02499f2e82b6fd95483fdbb9b985aeee55a8a07017744c5292fe7dedca9d562086be765a7c24b83e9ca56458497dc52dc55129cee01661f11092e9eb44299b96a82dcb75a2b0e4946454f6e4543fe067faa39d31660dc75177e2759b6f184a1e8261456e032560041fabf6f771ee91917599088e5d2cce76f5bafc99a11eea541cc91c443b5377d66f0bd8b9d6ae439293df7768d2290a33820c4e1b91b05c5aa32bff834d7f39fd6716ddc7d5cd6397e72b1b858900c8cd0b475f1b1f5a38fe01f8751818e183e5b3ce2ec350306cc884bf48bca7a8b81c3ee526a914ecaf0879006d0764a38898526c3b01cfe28bb54001f3aeb698111367b7c06c0875d85b0d7184eb04491dda5b3380f55a77ed5514eefda379ac774657a225d55aef4d194640876cb75f8853ec4b1710508c98883e42db533df9d477175ba1c94a55b294bdb139208b30cf0d0bdaea261731ea8e1a15657c24f9cbd9c4eaf6fcbb0d796c8ccd98b6c5f09eee22657b6f32686508881e1c054706759528626eb1edcff26f97ecf619d13a8a73db5a2bf1cc10293cff0afcaa242e59fd0134b66a6b169dd6bdf349031cd695e545497426330b4e0886059fe35f45439660ed56de41536b393d8eafd2ec2ee5c1d579fc8541acfcc9500b95ec8c774b34eb3e5df504f862b7882242ea55c314c6dc2f91d3a7758f7937bef21d38db3b4981f5f4ce93e7a3bb9497491ece9671222c1590065a8f68fe87f72b69594f6368f447f01ad6feb47f8c7105098c80052dc114dafb60bf3fba19999a860f97ba297e3b6541cf5b5777feb782609e67c6fa5d76c7dc4ec4e3eb2a6f1aa63db4ea9c204ee0869c8a3a12dde121464eb1ab80492e9872b91002db6b6ccf81b2b5e555c1e15cb71245116118feccbb2f896f05e5c81e46d5073e4930322f83431770b815d932db72fb47b3e5c15a72067ec96439f3c915259b26752c79b7c92bae3dbd8a54e4de8456441f9ca599df88e20351dced77cc357c228975df98adb74771d6b917bd5de95430759def49d064dfa02c72e6b892322beebfc885fb5b1ff48f38485669d7cf990f3aa8a9c7cc024ceadcb9c162ac16ec26d58f53c31082d15c37803fe7b4efda1d71fdc5f9b6d6bbf0c946c80f803b36fb7419628c3c1dd9ff991cae8635c70a11519947b366f272c733b193410c479ad91ddd33da96ac44f5473edc77271bc055b17b28a77b911d31c2b1f4d63608ba022cf15f20eacc7145e252a5d9bd8226c6208dfdd9f10448825ef3616145fcfea3ca08b6e92e75c07e4c6bea963ce7792b3cd72207b7bba4447f33e26c5989021801a8d4f7d16f361c3ad7922083cf8aa9bca8adf026ca42a0535017b1774204f7e82dbc94b9d08898b635ee1528cf65478fd49c8b9542a4e2c46eaa975c9f93353072f45acfdd68b4133674494be514080e3c26aa2830a871ec9edf2bd6a2b84bc8ee796d12ab8f55de070302597211b2545d236d9f7738be72fb3e9c68a8cb22232e86ce2a51a9a0b9a0f9e54a45db2f0c9e3ba52e939a786027c46fbc620de700040b869e9364352e0d336d2a1c5a747accb10b31fc8fc3b688a8908662fd75c4ac29208c9af8f1a2697fdede4caad2be80f67b22882ed245aeaea2ba58fae6382858fa6545445a8347e86c4b401385cb0e537417dbb4813e3c727032970ea29b38010d3d9067c58cc48d87db3aaaa9b7eabd45ebbcd666528abfb5f5848707405a5db72fea7eb281388be95c60b7b9d238320ee3fb75ed5e3ad33b0f4bfd7438b5b240be8ca7ce3ef333562dbf5b5a6e1a6487a09997352b93df62bd8c2f817291a692d93320308d26549c7293b9062d60bd56724e75e0edca3b83a6934dd10030fc5c5a41438a68707740d0635b8f1c4f83a9ce6892c2242d887369b288fa15974f8e12b4e88776bbe6c0635068b82b76958537868671518d88c0d5009b495cd77791322de05fcddf6885956a4ee0b5fc0e6a120304035a6ea7e96bc8e5abd6db1bd22a7206a094dcc7a86aed373642bba16683b09c118f2a32cee0f5e6af6d382af3ae99153644c5b27963e9480514c91c910a606ee2405f9e8f8dca1fbfc3396d55cfffdfd56d114733aaf7420eed7f67178644dfd00779efde1b777526476f13825602d22038aee2e869ddd3715205fc27c5b9a48676642a6d34f11f970869e33423178814584a0be9f80178db97c8033f06ffd3d8179aefdfc29e0e3b318347f4d92702b3bea33ed7da1006a7e7681d7026511a8d353fa9e5b516e00b4db32dbdd7472e1aa25c94555838a555300e86ea08a77c1579fa1761b6601246c54800cb8c157866d0021dce70c0309caf247b076f3dcd8442e72aa0556e5873cf2553193d18e15aa4d9e40c1c58e698c200a31364b4d6efc473bbd5390267b9f0689d5de1c1e058018f7edb8f796dea450bd2d33b5a09412a9d46251b7fc10e294642b2f10b521ce6cccd0cdbb35398f9a3c9439a5c6b9df572d2db0e679dede6f423706b94c37cd9632895204a0812b29bf2c17645dbaf0b2460452c69521b4c33794da8b971a12b77d53a8ee86e41f3df9c39bee7aebe8ee71390c98470618d66c6b855bafdeebcaa4a1662b94240ed3188591a87df6c229f11eee7d7f8428687529809753362089f14ccf33b2e4e2c7d81a959f315417b8433e9cc202f271c83e6a01c9b55dff76b7da5108b57303f5451d43e5a9081abc45cc50ac3e5d768889cf89caa4c9a0f5e1866f3a4d6df0a453f598be106b6d9d31fd24ea8df448212eabdd1a874ae87efbac8aec83d751f86ec979c60dfe2bf55da8b997bfc763860d22488fe671947b7ff1c12782f11df70db6b3331c10da21f82ab45bd0118b4d9298aec5cc732f49fdc8dc8d8bf42829a8a8b996ba67ecb4fb59587231e8c5ec0a160ba40e0679ba1a06bafa9a2cef9008d1ee0921a27134f8f3e0bc51a0085649852c556e121938116148e6c47d5caf5cb05470c67d166e680633404908c9358618e191351909d3c8204badca910cb43aa9eb8758d55fb51d4ee6dbdeef3cf423bbae41b70972dc85ebe41cac9b79493414675eb69254f9ba66d0dea4bd27389dcf7ca99351ef284942f9edf0c6cc7d649661272876be181de9dd09249ed4ae59e39fe006c9cb555db85f61e9cb32694e5c44318e7ac48297a198c55d6e752904bb79fcef66d05ea7bb58d15f0166c56a5e194f91c8261a53c6b279397f29f6da8e553dfef88a8aad11234e870c87a253d4d28e1f0006ee66c26bf38ece28f6d66bbc2ff783ce2d5dee5103ee9ae6e3c5ad72a0501b6a5146a8f256f4b3a7e969bc4982baf9f5706868f6fc5801f2ee981337fab90fc4b2a8d5f9dbbb7fec42f9f272901b3db4bb4e71089802a97a7434db38945cbd07cabd93a7b4220ecbddc2cfc62346e2e29bcc736a3d1e94a18c38d823a81461efd3499e9c05ba3deb569ba756dc12bf2c90edcd7b0d7a1ef60e11970e7b86bedc0ba46a77ebe59feaea3e39ee5f4faec807173e51433d94b8d078f4a16dbe0d799d2a39c1f71139953c85923a328e3a7a76c1ebf1d76fbaacfb89613b9225448cb5a8c5a2606c992beb9240f747ed11abcb245a4833c686afbf80b316caac0cb256bb65794bd7e76dd3c1dbbb3932998abeb235ac12505f13d299cad7a99777c654a4e29ae1a199c17f7e259c83fdc9da54cbbdcf7bc9c1841fd5637d243d34e530bd8af897253474fbc4001ea0556228e36e1feb22d60fd19b383485f953a8e75f4306667876399a4a3c2d9221f5529aab5ac44e0514369ed6561a750313339afacd64ca2215e9a3fa22147f3dd8074ef2e0ec37e0892afa6f62403938a1a6bd610813b1391c4ce83e7b238bfe1dafb8dc902e1e50f11037fc3d83213b8b072f813fc4e85bf1f3313151253aa26e4adaf6b01bc950aed027190cb3c13e37fb5a6662570c588bfb5b283bd22a18350ce2dd1722539e639b3e925e7222b482cea1e9ddb80e418761d86c42fe6c1fabdddada5db379a8bbae3b92211a307800779c9c5bb5c97948444ce8437713a912af0b2b4b2acb412072a3c37a5345f5ad42bb4a03789b330a3d3e38ee78c2a3611e246a30fef5539ab740e16bfb77bb4eac2d6cdd33f1b56a6b1e2a273d9159346f5ab66b7650245d5692b8b8a9ac2aa181a5186b2b3a0dff0c037336eba848ab62d83bfa0a08e527c615b751b34d58be1fccaddfee3ea6d26e4c0be7962bc4ade0bc5f8d4e170f82619a9f9e9a49ecaf8d3fd4afd8a5e66578438aa00815d82ebeedf9b1211a119e3c50188926ab3d1251c963bbba2d1e33c994659cef1dbd962c571a6427ada8068b2a6e50c50b4cfe83604b554bf0a18dd63e1c764b48ff443aee474e7b8257f11053b53f602755839ca6764186bf8905a1338e2a04aeafa101262568ac02970df13c4b815cd56694132653d08d58b92e6ba4eef5343791f170f8b8dd10d5c9566b7a717f3ea55e41e593c02c6a08935c229778b8a7518ecc715dabab3d6de52d012e20e6a7aefa3b5fcdac455606e0358109af4818416a657053408dd006d6a5cab3cad58e87b0f3e1281e43766584bdeebb255b8c2f0693d68262fd8d6241634da94d71dfd2968212f031a34d16db20ea60c7e789354fd2c716762a66586ac1bd91d5b0ca13c90a8984141f3bec5625e306580e5ca3a66c737cb4edad106eb053bdc4a595744c468543f79f4b1281b3dfa97d327f6f9d30f941bef26dcc0cbee30d2fecabd38c9f72fd8289ba01cf09a2ad37a170d15a1b1e0d242985a14ad37f6bc679dfe7a2f87458750f8bac48352b384151852e7ee8919a164db440ecbe977235e837e1a13db8505e6747cbf1eb7dde4077b4177287c878f294513e047cacbfd9f35bbef6e2d62d792cdeb11905e4c0351e6d59715c6c947edd0171a7f631098272995899dfbdc3c84089ae123cb1cd197212fe834a319b5220bbf9326f31a350ae696e0d5070bd068be6cc9a1caec1e8bce0302c318813b0368b19e7bfada352b87d843cfb7e4445e2cb9bf83fa6d543911c3da706c24d638be638d6f309e1727af1994c61c006d7099517d84aded8dcdbbeccef0a68fbcb9fd08ead7b0b20c141b9a1db46e5d262e319c674942bce40925d7bb1d988e7e1cc31131eba8db142efafe24940a81a01afe9336eeaffd358fc3beb7ab8c5ae7384e554e3ede43c54cdf54b633d0e075b4b5cb7528cae27b568d3b93d5d033ea144d4a8ace9217510625bc5f1fe54046868512e0cede9a84eec9305d4f63e6d8854e47a49574bbd679bc51f1cce37b54dee447b979fa4326d69829eee01051ea6a38566c0662390b5b38036b3ca474495b273b5a4df61a1a8f573aa574398a33cc4bff20fae89bbd9a87484bb468c8b5be85d5649fc39897a08bfe57589fda878cbf3fb9194a3ddcbd51eede0e514053a65aa47c177f9d67cc022f419b68b0d0e61245fb1c56224153694a317638f63600c325f42efb7cb4a1bd31df3226fbefccf96ad393afe1a04b696e8ba84ecb1803214c112291bc4a2cda11702d20987431b98513e49eb992dc168b38fc1ac524990e415c77374de17f5f058798a20a9a77979143e624ef42f51cbd28e103da053b964bc6497a2de381de74c28ba9a845269c9f110af096a88c1e22924ccb9c3d7027e62a7d8a24a6b0adae5c3ac9f72f55916c10c731228278d3a23795183fc3dee1235b6f79bcdd8ee4cceabb46561fb4e79212565400a5cafc42c41779508d0e35a2b762bc5c5a7e9c983b95c1a0d07fa7a7477d9ed7b40110744b0a584c37ca2e2eedeef444874f20a44317ef37a61c27781eacb850df882f089c44e2ee8e907d452aefc635d13ff3c3ed5e62ecd846e888b2b69ef58d9bb0752d4a37b0e8424c2062782b8c0575c64c990544eadb30aa3506de4d2567fef684ebd617c9607e04630f35a8d0250959ec0c53578e277a186ca7e9384c69ad6fc2072d24c29dd44d5bb1a98c354e70678df2fa4d02e9cedf43050ede787fb6e751a2327fe5b4a5e7f487495aacbf4579d4877fb6100e0af730ca0948151174bcd9e5860d2aa39a0f84983a39aed1b8a4fa66fabb24e4ea083fb824797861ae2b051e248bd6ad6caee520e23289fdd2e60e4a98bf3eabe14d7bcfdef018a2c979b571e7228cea4aedf635466e6f0d62b326e477ab0f75a8ea2c35ff4dd005237428acef13d81056ed2b58c0bcab2a554f2725d735bdd82b34951a6e93ae645acbef67331e642b6a481183e4602e4d807119b039224b1e64864741b26a28319261869de63f83fc643c883711766ffde6793e8ac22b9abd4abd2cc1f8986d10f534486341581f5287882385b9fc5f48e3d8cbe1075a807a17dd2c34e0f5bbfc6c959ff59632e62d9cbd9d1adab60b107acc67c29b3a5c0d7367a1054b526e507fb1fad12a56afd7a2499d5118bce91111d4215880c703a140eb49802cd4de74641326b8dad65f3253b46f51b1c90b7b2dca3c8b8d262b2f37bc2172fd7461aaf32b9dff0270577f244209c0f328375d18aed878491b5001aaad5b397463bea65275c675e84651e468bdeeb7580d5d12dcfe43c480807d1db765f0a58927fa811faddf96b483a4da571f7033fa11dbe6c4b40d04a6d6ada044bdbe78272913110204fc3b233bb7345a62b0ec3fc7f2f856b94ebfc0b57fe385e24bc9c112852c5919d9ef66381145123b5a5d7f8d33df7f55979bc04ce1e902f18c0158e28410da47a921794cdb6cd5be8834df8dc0297bc462ed02626b3978032524b598b5f7c319a70cf7effe4f4ea8b456de73ea30930ec05f3d15f6da281501509576980a2723cd2aae92188211fab8a5119a51e82204678b80d53a32a8138dcfbc178e673a4fcddc12b8ad68f4f30fd114048ee88eb0418d7ec949c1887844cc98b65e4a97823314041fca43741aec2b89e1245a2c8d9580cbebd451fce54e7e297d71ec450fd3f3af2f9f3f73045053ce25bf1777a729472a1a51300e1f1473cb1d78fe329d73776a0fcfe6731c6f5f6d21c8c46e2481a45a4a863cb67b67048a01a4e54748e91333bac67e4d5c02ea5916fb40a85af27a89f8e732ff2e95109f416027f168bfe9d2d79f22a44ca4626dcbad92362732710dd7f48764abbe9f6e3d9d86889e34c1874ace862969e5c6b3095bf79429ecea78083299174a7d07d5dc8837da477f8fbc818ade5ee1be166a2e013f41846f019b7de3f1167c9c95a3b7600e194e1036417b1710c2c201dd06a9ddbf2e2b107f64df2d6863cac04d194ca5073c669737a1c0821b21f3fe5d420c1136c74b60eb4ea2f90acef1adeb01fb99ef46f87bae1dbaff618e180bdedefb58850036ba969e3925ec07df9fdf30dbb1a2054e0ce290bef15c9906b8ededb77baf587e0015244c0e2db65295e6522f68fef59d8244aa43c0510e01d66a512ae99fc3f99423db20c46338f081aba2205d78660308c11116e8b807a6ca2348acad257967c0c93840b8f53698ac1708c9829f7eadac34fbb4c23efa93d882286113aea13ae63bc045f25e9b79a21e415e7a5c1133a4db04f1b92dd3f931b24c7e9242bbb473d5508271cfdcb92f517a5712617408779ba9be38862e73bc7891209a4d2373ddca6b06f544d223c029d6748019a2e381962831ac9c9675dc9b0284e33f9516d57f407c28df9189700bf434c2368d93b0d8b651f0d5a73137d73cdde1dc90e2da3f1ecc6c045bf7cafa1ea9fb6902950ced2999b8305d99c48c21af362f4bb74c6857f7401430b7d6c92987464afcfde92f673c390043fc5cebbd3a9021e14bbacc529506c7e2a7d6a8b2ef6398abaf06b8e4b5c40f96454dee7693bfe1f737b60c2dcee084c9698968e511826f623ed1127254364ca9e719b02eecc718fc9cde6aaa691700ba0acd54767e88ed78c166ef2311a02f62ccd7b3c89b5dd7faf488fa063d5c3224ca665ce8d1bc9626afc0404a233677d9943c9f7da48e7bed41b6827ca2f43b5303210079fb4c0faf6e52ffea19f65f62fdb0884c39e6eed494761bcc3402e6700e94b351190f4c205112ed5eab7ccb240e17fca745d4f25a410f4ed00ed3cbe3f721d4bcd0d08a645b63110f0474c74eeb3b85edf04bd9e53f497ef90e5eb6775c705c3269d4eaed08a4608f84f8db77e4b12ae9ceacaaa43b1bed3a7763ed1e1eadeac5c984daea78d947c052ebb2ad644ea00ff876eba579f5b8721fe20f53c75ee54998f40a3ecab0adc8d18add7dfe37f0705591a8fea5a990ecd32eae7eb7cd421190a7057eb321e21644662d36ddbd023864e31d438550bebbdceb64c39b33c159107a6104e02a5c6c814e989221b4b8f4c5867ce72c2f0b17dc0011856cdce7d4d78de895dbf6f10d7a9a1968b3e37f41f322c30691d82af41b0733376bfb898cf3050ac18efd1287fd3f61f06b98185d9709e439ca7a291663f87cb63aa89d5a26fde2bb0d63abe66b9651c5157bb026f61ef374a47ec946fd96b973794dcc32c6ee5019ea9a85424164e22d9a398f3dda9c076183990c54bbd3543058ad6ad6db75b9304068b9c2a10ff7df40921812c07065ea12deee7500c6e7324f3eeb28e81fb08deff1034a95bf3e01df04e922576ff0656e77f34aa4f38525d738e6b41063722cafac1a08b09dc79c3a30a68b302c3dbd59b7c7ef5c44243f8aafbb984ebe3a3b5256e9f3e4c8e645029cf2fb62d601fc744e38ae93530de38ca9f7b5af7a322e74181916d66ccd745135aa5e19da900c01ce2be8e4024fac26a46264bdf5e0f84492bcd2f34a483b273e970f76aa9ace2ab2125461d89c787f245a675e42bd6bf362e834007309f83d0bb2ba27f800d5ece27de7a701e44a20f724ec2615567ccddea1cc9b4e6a5b25c26ad9b1b5fa27b9eb9eab43a5ad46bd0aed93e763a889575e1a1b871a2214f7df62192b22e4cf64898a0cd4f898a5f20d7b6f7e2c2e97c91e9f3c3f97337e25490030292bb2f074e3b443f9ba01ad07223c1ccd27e8162bb149ff41fdd0078f01627bbea9d8edec0c14999cd3557e52dfc457f53858c946e660235e0e8bff6b7dcd405a87577cca1faa31798d655e76a0fb26d5be25e64e95ad676517c0b8250c8ca0ac2e6935272a749d4e7be8dc16bbb86315357505b0d8b7d7d26e85b7ce59a8cf7392c78e9e4928f0d891d1b15dcc04c3e670a1fee0e8abfce5f1f38d9aec9dbdf2212af01d5d5eceb59615abe89ccca785b6d64df9cb5035a67d07f68e680ca2d7ca18d3af8f54a11a808a87c8eb7771b4d87fa48cdba33d602107651a850fa1c15133252b7fe6c29c2a1076e4e4876e0b54011e2cceb90195d656eca54a08408235add95c04bdb5a6551e112e2a2e0a4da00f240bddfedcd1bf6dc225e6d69453b753072e0d57634d8d5ce89bed4a936c7432c921e241fc47b4d2b9d23fbcea5333ac36a56ef27886c0c502a24a8fa74f410e9ad8344f2383284e82b39b386e754548ab2d7f17c9b45ebd2bc6b0bc419eaeb4117f5134fb77362a96645b7947fc758706793f86ac9cbadcf931c2d5f4650ae709bb4538f9bfbeac5997d957908c1bdaaf9893377dcd1b3d2c56879164b49c52a47a7ced469f2ff1c3acd53a4231911a3fd0d78fc8aca42e148400768d438b1ffeca846d6359aa70b253093952b9d336a90603ffd4bb3d587a3eae2461cba125d26333bf50f6cbaf12a0559ff13a242d7a30de36060e3fb624d20c47e33899cf0b4c679134c28fbd3997e9245cb6be8f91e915384d96e5ece63d00fe6994fdf3a59fffb76d056fa4b0cc91717e4bc91c50f5620cf7e45a2dbf7d3af4ecb09ed6cd4cb2f92ca053a7f8919cdb29981158cf9c5d297f764be367d22d2a9022327734a5bd8136bcc3ae16583a06f15213b91d59dada922f498b1abeac34275cdc1ce5b85cac79128603604709df3e447c28014de210ad61275be3ab959529d8259ae1cba9798eac9aa650d99876c58ec4cdcf759be0926d08c9bfc285746d27c25d6f91fca285b5b207a5463da54686a58115d96c53254f3b2ca394f32e1d5b596b97f70a7cb8f864043f9c85460c6a2d9098d02c1ba72cdda800f00680e3328ea9fc59a0d2bd3321451eeb1f6eefe166e41f5317f66db134cc95ff21bdf950a509881bd271d8a1393e61dbe016c047a15b884f9eddd9c90a8a2ba5995d9b3294f6492c93eecd2a1b080fcc8d9b3660abc287574f799e11266cead65b1e1f8e37f618dbf63d083d9376db9ea5fc43576c78368b427a30cf85954ba1dbd7152c2bf037b94e5fa0338fb75db06b4827ea3d0007e4f09bf336de428891384bf29f71f1d653d0cfde20fbdce628a18a3af2becb164bb62dd23f4b6983b43ac7b8d96d1de13042ccd4a9fcc9dd4ab0072ac31e052c32064ed25c6a44e49709ffb764d4871b11cab2c8bf711cad49f01ef7f2529efaee66b69acad9d967fba5cb5e8ba4e2d83b4bec8e1b1501292a6d6d4b55557ba494630b30eb323627724f2c9dbf4c05079cb3e86ea907bdc9f565fbba8f79d3cdc4a9d0e2a0caec52dc8abdb3d16a40618240d3ca7ae37b739d7125dc638c22f777b5ec0839619a2842a3f96e7667db94a981a08fc502c6c75f10bc272b785376a7cc614a1f3aad8a114f3d6e9ff4dce5a1867e0c17e896de368615a9b01832cd6cd536834520a97a620a1e7c6bf1eddc745044e95b0437aad7779834456098d790150fbc390f595b0f33a2e6663f03023f8dc77db77ed1223f01e9da994f05a0cccf9c11947c0710f65569ef45cd267c06d702aa94dea009351d5161420e278b30a1d4242bb0070a3f721e4a01f887e69b443a9885a1998acd6db885fa51339f412ab8c6c0825f75e9d22c97b136092cb9c5b8e8e2ca53ca5b7140fb93872d52d8bdacd670b76a2c170f580fc976a56cb2077c73f28e0f2c6c4ab329cf05667188a17a9faa768291115db065d072c3ab80312196735a36970a43b012e51a0e3978a9fe62396663196d6222379103742f1ef3dac4ce88202755fab2c49a0023bb26508ac648133838c109d19c4699343dfec295a743bd462a476d28ef3280a5822985d1c24da19c28873fa927e9d6c67bf5bf2d9841c1b530a76855e239f72526f88d80cb7169ae997d864048c80c50dbff14422274ad165716810e023f54f3bded3913e49c654671cade3670f755fd32e848d612377af56e3d03c27529ab4192d950329af404742ac07eef9c46f07eac958aa4248eb4e1968843c884f8d726e91e8d8cbe7eb6405fdd717540e5602b0175429ffc5d163c581317ac549e6b915f41e5fd09dc8805fe9a76b2a679ff3b980f7960468a818362fd2fa6418a42b66e57d4829e8060d9a3237db22802bfa995ea26433bbac9497ef61951621b8f702fef29c8ef278760f3e9d5c1f41ee74604930b0372cb35a0a739fafe55b15e17920e63409449532d5017b2ef162914374eeb80813c5a6ffe5b9cdb99aeda7b9425ee9d2cf889302fd4475231dca064b14fb8f7ff3b9d72e4ec4b4673d509b7710db90644d3231eb1127a3164b1433bcb80bf3a750afa6bcde70c375d60a3edd90a1e3b33615e42afea59c606ea895e3d7002011a80d620f0c80703a0b5ad26d20e777d431614860f6fb65299b94fc4c27b8db76a033ef5d4b994b57b61401f50a5aea3921f20c453a2f5cfb26fa62cce1f6c7652ba39f3995d54f6356ac81958b637e4364a957159a15d21065ee49f632d80f76300c12c724b3f74f2057719ccf6e13f1f7ec9f477761d0f9b32f86af87f77418a8b411acea1eaab184e2eb5476c5de137a9be04a1428c0571f54633571a7f79bc0f8a591d81f138540e71d27697f0c986ddcfba5c6434f20e16b09de1fbc5fdb7f7114b9bbeaac258ba57c1c93fdd4a6edaf84678eb5655b02141400734cbe610c11c58ed55503ce9b80673244ec60860f8e5106bad8a2035173ac956343853a53670e573255d1dedf5efb0efbdb6cedbf2c18c7fe658aa73ce68a72043b44166aa71b57742a99f350abe7787390b63447e1aa852e7ecb19ce3c2d01b4cd755cf63a0579e4828e0fb7b41cba9c87d6d3c05e6000ab206e06a320045098447e1b14b0628b00fe40b9a2918dbca3ed951f8af1c9fe9bfaedfebc215b13ae9a1a3211a8b73158571792918f3aa25892be627ab3470de753ade7975e5befb368d78aefe2044b9f89f8259398c5e3dbed2c0f0587d6359b2e760aea8e9b4f327910c1c589fe9429d250c0799549af60635e626155cdc04f90cd238c766f2232f994fb11a842eae3e990762979f60a14e50851e2228d696fe2c1e2f4cdae551485a0eeeb8e634e891868eefe34601c89a141710b6953556827f52f3b096350783ac4056a9890bd73bea5dd4c8408f21406eb3e13adb770a70270b4f3beb680282b0c2af2015a270739c0c8fdac97ce3e00026ce4c568486c405c69f79a45d935f37d46023ea4e8432896aecad65489ec66371ffaf7b539c7cbf56e1d070c3dac58478c76180acae7b74226b9510330ab61d6df83d412a8a357e9211af4bce2d52303655955e3b52bbf9ce8bce88a72425e981b067d0a25931997c628fa4b7297d256d2d1b91b9bd2e04029bb63444993c668498398921344758595673efc9841ab06dc5b43bb921e483ffcc1e4fbb2e62c9ce479caf7013a2c3a8a29b7809f04cff6626ce4f911b883a3c6d9b77f387b79fac44c4c742540439596fda71162b370f07a557aff624cae4a7e1ba0280369fea49e59cf89d848feddd75c617e7c484866cfa1de53886274cb6b012f42a15d1aa1d72677e126277e0db6dfec6e0920dd39472a0ed4074a79f2ff44950b13c55cce1cfd12c4adbeb53012003fe5b1ca7359c5bcadb481dff47f8614785275136adc087e263cd3079df57af6cf2b32cf4cb6ddc6965063f4c41c7170974ed4fe74a95b1a03f5715d6c19b3cd79725716e0b74af3aeae4e99836344abc95c097b319b185ed8e7cf44792f7943e77da17911b3e3ce9af160f95f418432a0e92d05f27148bbff1785a6aca74e49123e4fcd24eb62215d1b351be1918c27c8fa5efbc6091ee3b7f5a381ae00a63c2e6cd486c99fc730276e15f8c0e4ae7c8e1a73f93f88bd4f29d03fda3d67b4234c15efba00d2a71f2c56db78c170d39a3327fa7335d2080c3af37c44baeee1956813265192eb3a73eff3b557aa701aa6c2e5cad3615257af973fc44523f7c3f08653f605f3e70940ec9f53eec6f54ef5a4b21d96bb4107861007d44db8068aa116f0e14c239a3a8dbd9773939a4bad57b47a2e5f2f7d6583944fc0abfd9c61ec4d093029e8075534a65aa91e8757c2e30f22d3e6c01319456d37d83828fdf7b26cbbf60ef8f19d3592109b27301af600c93766daf4de6a401e3d8e324bcb8b35ae6b76a6d22a1ee2f82035f889a8143f50b52d5017e093d96f7bbdd8938c3ccbffb618c3d6c3bb8315c8524e8a2efc2b9424739571138f2fa0af8ae01e88615304988bba6bae59189950ef6fc076fababb044541cafe4761116dab43e7e86ecfe231f3ed2224882a16fb8091d0d78c6f0e1fa984067a9103c26af46c24d743fe2005f17750fc4692d61b7411ac9856279ef89b742a9249d79471175ea42a8ffc9d57fbfb676aea0a7c73eec29d99d3f130edaae9a1866ced31eb14626ff6a2bd70509b79b7dbaf08451bc3561d697af9165202ce41ee574820eca958f02a8ff50bfbd778720dec4d0fba4fbb940d1231aa7dfbf80c7790017061bf4bdeecceeb1f9088be285261beeaee87d6fb01921795febeaea6ee7693f1bfa892ddd8da969d7f258583d68285d66f6579f9db0d17d5561d5d62799a6ed1209f2f78e35b10f6ac629633be773aa01fc5feac451242b9bbe0940b6711f4722e754dd1764642062f564642bf838f94788771c4b458a91d24289a731515d36ff369452b5035f6e8be925a143892725289c0f541b93fd7bb8500218d91d02fe3e68919acba23c5043c31a0e25a9270d8549355cedfac8fc366602c9b739c555460992fb37d586bbf737e7f1e4329b4d0316547a79811545ab645d75bededed1bc196ca13956f954e79bdf2e4bae01ecf74202c16a368c0794653cbc4f9e7961cac9e91272536e18124620549685caa3e71fa122e78cb2d3825bdc92b24ace5dafcba1cd5dadd95b45c4db1a1ec14d90e3d0e1685b336f560634377a92db93a352aa56616378cb9a96178181e41c0a22aba4d40769f15575a2efe3e6566ce9beee038f3054d631daffc986722c4946df4a2f8fb6b3f00849f202dc9ffc2f1d92c60aa911bbec75fad3710341d1217bfc7105b1774906b7484f27d8feed9f7db7538ba60c886397fe6bd692fb20f18dce05b566b99df3a3d03360fe98fe4678f3e9374e335a0d057ccae2d4e1f6521bdaf0eb8b8ee756fdee5703c2e71652ca3313aaa0a8e04fc2efa315681781b1d725f73b5a7f2a66bb716846712638b3fb11f59d4b26a48e4ab55898cbe16094f8e14625e2f253cc0741bd67bfd108acf8485988e51a158201c080b28f56e0852e0631f6914f94dd1a08e96ae2854998d22cf07f3b247d633e501d6f69d269c72cf5c219c98e92df0abb2cff42d3ec566c70e99703a8a8310a1c2d862450d6ba50f7a264174eb2cf8f5592052a5dc27aae7d45f60edb7f42c39489fbaa9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
