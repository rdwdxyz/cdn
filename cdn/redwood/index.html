<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7231a50ba39dff0ac74ed46b37e369a8dd243348be6f1fb3ce2f1508ebb002a24fb5bd7af409c93241f7cf83cdcf982c46c43b38aefeb9be6bccfa76bed02610a275ea922ef3353c3763de63dc8770a1c147c67935113fe8860e250f8c554bc0babbccc5720016e85a404a5924b5791c6eb7610069d8ff37c4c2d6f9d68c3c3aab0d8a494a0ee8b1eb250c6772d5e0fdb124c8a69e72a105f9fa2aa98375524c7ee85e00c52ba1ebb41754b0321910e235bc930670d7a2b124d85b0b88bfdde09a635f7c066cdb999f039f81b87489530d68e20461dfe259def4c952096a4256289fda0204c87dfcad6aacbfed5b233899ba6d6a7c8e88bdb9cf28e82950146fb58d16d384ea4837d46c3ca570b6888c126b79af965756d42b3a527867a028775a2245a2f83f233eb5f8728d45a1bbf3f86172993ace6c7755827d7658eb3f32209dc44e23c01c1e10cf76fb81c6b9bef84213248b8e77105b5bc676cfd3e7fac9f67d47bc38aaa3ef7bc04350cf7fe78cda4d1576b01b2cf0e608a57cae9041cd3ec59dec2a84fc322a9168d83ff6ffb8e1bd9db78e13de8afb364fda28b1c61df369127c2c1782c9acc7adccadd4cdb19cbcf51014a97198d3e30122688ae5595cd34e4ead1923bfc35a58342a5b9d38e9fe19cd0af52f8a9a1cefe93095ff541746171a151d22776a06547c7ede729615e0fa55b47bc4a7142ea055d2a093f371404d29faada78b5a32c3854385a79b820360e8ef50cb3089f8ef28598256e310fbd1d67b310e27fe50aa669a35f8aedf52e78bd057ab56b91e6531cc1059b155901efb4e3392ee4b25195c6e89549e81b005991bf158dbd03320ec1f2a4eed4b25f80a5a354457cc35cb9494cf7fc342b23560990ee0047121585fecae3175b96aaea527a05651e748a321e4e8c0e84a034e13e5dce425218fd1a0be628217d88527a0e85dc424d2061cb641319d94ed3cf0fe232c906752137af2e1bb6832e43eaa6c1e5a0517f4d25bdf85af062083ce09c36a52d6bde5605aea030092e135b323fd5f8438482f84e0ac0c29b1b8515d9c2402a45505a746ba5a83fdb67b6df3b42d45e081bf515c1b6ed1fa549e187d71c9a282d5ec51a8903655f7294a394ecbfef5571c20f1df9435cb013a29470076c3e8bd3b8db90059430f16a514e17e4ed6aa6fa4d6dd78c4b4086b9d95cce0f555d398005ef2c83a7afac9bd661bec608cd662595d91f880618bfe3d7182f8dea94be446ac51e86c1d7fb1a46fcbf52a03c651a9eb20512ead5cdfc2c42046aecbcc1cefca4c110e340d15086fac0693e1fc45f3da5ba30de9ac4d0f23384f737a83749318eeb830803d4e30ad7f0485b3dfd6d0489ff4b0ec330607a5de85ae9a5989f561967bbaf0e40fa93f2955b94b2905f5b6053b87e1384f6c3a255ccb0634eedb46a6d36e97a686b3ea110c2a03bde0d5fc6390360983e305ff74a6aa0af6bba8fd68eaf3cd96745dfb487cd148fc78eb9a81b3f5b4d52bb5d38e6d503db2431a451212e1fde21bf339a3e77dd72b9293c48d700d36e9b5c340513cdea96e94539be245fca83bfe71ece57af47f2d563995fc2877e3ded214c7e22c21ba855a6b43283fc38b0992513c4b6a9c9a05a6405b662ef894a2a5471fa05caa2e63fe9c264d1d390b1ffa4c6f92a61f78aef26c297205548d5fcea24b7e902eed8c0f2caa8e870667fd6b192002bfb4cbd5f10c54158b9d78575019a6cd9aced9007a629b0e0f42cfd973d0952d71325e84defb1f0e8d2a940cebc68c465609be81a729a9c6898590e2ad6b85049ebf9e2f6c5f175c2e374153f801bb6401f644a3767a8615efded4227eec62e76c01131c35c3e6221b26725a8f6a02d18d00665fdec25380da65133ada8eabb30929409b8c5632890d114c95b0b1c20340234dc1d0c75b17f34f0071bd120c88865234e8104a28bf460b3d5b128be6251b8e23c5cde7f2e3c89b8d4a553423ff9b09623181360f6bb08982b8f052e7ff30d078a711fd8c72e7257be3e0c0a65ef08bb0438764dd046517cbc8f95de2866ec3d99c1d7ab33bfad2591124ce03fefc5ee147daadba2d41bd8fae6a94bb5e0ae9ed0d049f73c522e718ec42df337be7f9ea0d9a17cdb7852723da61a27396feabcf3102dafc684d6f8b2a52cc1211a68226ce8cdf933023dcb19d06fe5102efdcd812241af569fc51a8f52fe1655a3d780cf79c260472a3b969da9ade09056787937762679a8d981deb7c234c662cac853991ba890e6651fad3a7223e3a60d80dc3c3bec66ff34c758c9ba82da2652e9241445d072afb1eb733b5633465a3334f1fa5fb974cc6d88b4ba2acb2d7383c6af0bb233efadad74abf8a8e28113686a79a325cb0d096dff5a2a15fde9a9d10d924d934d853c0eba1d0cb49aa6da67283e435023b1d32631fa31b36a0f61cf2fab4d35ed1f20628d8b4162f0c0e5df4b1b5a32c3e56336ef0dcbc21ac089aa79046c89b077baf9007ede158b6c568c74dec7e2b1c1ebde8f23c9bd3df421cd269930c49a41bb85ce1b6f1434ad4967a51f10e616252647b2dc0420fd7d584d6b409a3acab7617765f9a6fb273e7b3e5861b79f48f33e3da9ebc7f9cb12288e27aa5842c277a73754037040288dea8f77d2222f473ad21eda11eddf74a012f345ef1f9ab79f399fd2a62dfc724f3a0fcb3cc3fb31eb04b1ae3d7898a159193cfa67c5201d562a13f8d212e868607d0c30d56922ed123558278a9379c3ad92127f995add979dd3f03e878f3c8c657a7d6e44abeab7b87c7ecbc4a35f79e78e9f76481e47ed80e669af79e870930356d83073d20f7453b2c9bdfdc82d8aca35f01172720914fb62d0827e9e975b4d0f1a31359bee9239ce1738f0a34812ea4476d40c866c3335eebcd68dd4e6af68b05dd03be7ee06778cde1854faa117cabcbc50f6cef346e87165c8ada0e552df6615ed7e098df800129495fa3cd46ff0ac36a20673336907e1b70ff45456a8721b6b552f5ae984adb33ce8e60da77b73886d3c273bdcd302ee126b1e8ae0608873b68b88fe9832e0fd2b00dabd4589a9dddd7d17e5996b3493a9d894094968c518f57ca56ff1440154f0efe48482790a5e18b3e306ea2d0f6390798e3c27af7910e3a6889f9d6bcf914c80bbec0624513d2177c81b7991a47a4a9b6be2048736b28517530ead586d78f386864bd402e9253c811e134bedaf710926936032527d86e0cc953c7e80663cb745cfabfb90e0ddbc692e8f8c6e2c7e8a6c80e99f1480adb3ac5680ccf1724628d95bbf4108eba5b4f8f4740b1497116034a0e5e24bef3b903bfe6b5918d61d6cfcce7cdc097b0567d18697f7ab948fcd6e2d92c2f5636e43ef62c05ecff0ee460fc77b8569876fb51f09287f9ad3525e31227d2b6fb4decd45b7eeb3897a0cd9f5bef2c0205f8b5570a6a39f9448d9b351b45748a9caee772428050b3f21f42148d44ff544651995f709fcd0bdcf764357815e3ad19a2d574bc4fcf8adc7863fbc34a2e491ce5ee86cd7a9d5c9a8304172ec32ce9b7a1827769103d2275ee92a067fa526354cea59832590c8edf4042e8818a7b8f9c24d8cb0b603982306c2bb9bf0aa20310649abd00a1206fbce9576e5f21916398bcf4e5ddb6de6ac3d45eadf40b0dcb0d30cf5a799367be5bed5f44eaab185853ad2bf5038d258d8bc5284b9ffc6cab40f038ed80ed0883a04e940b032c2a375894f55f9b842b65bdb0505460989ff97c97e97403e953ccca1f5fb929b3f5782b0612d0749fc360308347a1ffeabce30994d669ca2145a5b40ac9138eff43d4b65db5275fc39deff82d6eb8be404a170ac770b89e16d3011b9ee03c68bfa1fee66e35e81f3c3bd37c31e240e007a8ca3e84a876d87571341bfd024cda3308eda24189ef5242b26f9e1dd87b7b676573d9d32eb45076e6df3fd8c9dd76f6e957c791b9d37089e14fd48de522567345d8f4e002217a451f94f1e8f2bd5082601e7a3a9db28793ef32e446aecca766d502034b483ffac60609d44f0f96e0ea6dc09cfed55aa99d0e81c2730dd54c22bec847fe72c3aeeb2171524598e8420e0288a9ca7690e670e24d643520f7e57f6f8917c3ce9eb18ff5f3d8402f4e13f39f587934e6135409ea1f93d2a1f5576fd01c3cd30e17624066af754a13940cb737e697decf7ba0012f7c7c173c6379f5751c41091a5e68d25f81428d96d6761b2ec445780ac316ed7aca2e745e71552f2042b2314f984b07a0f7fe9a1594f39fe5c7b1cd19e072c8dc27338355d328e8ac92d8d7840b319caf28656ee78ffa1cfff1aeea62a593af8aaa642bc2f5428651e87f86f41c2350a80f4da00680ec03cdf17fb9c06c950f1806dba67885b8b8771a89c86c67ae24449923cfbc89ca6792a98ed801b685f604738d37b465e17ec8871f856ceb04543e92293f6766937d2088372d0d584d2582ece8f151935505d32cd203fa7734377d604c612c207a54635073c1cefe8e61ddea2efb362f01c9a9648e69819d1cb59bf490ed26a786fda37cfba2cd3114752e0cde18504b5354a95dccfa54b9dd4a189d20a2a04fd8f11f42ea47cc24822a1d882f72a97220c009d45eacc9a4f5231edd8534e64095e134c3a89e8e4af8a5630815c0a10a100e67a60c46d28705ee88f75b27909420e9aafd7622857ae7f15947faa8ed7a725800131f1f8f3ca45cc95827f55477900c9b37c00a9f135f132cb9b6561a768fee87ec22115714728bcb7433562af3b86fa1a8437e54fdf1aff2db24cd911159fc1482fcaad3594d8f69923a665d368a86916649419255e69b999c346ff7fb91c3cdfcb07b349a1d40b49f02f2a22fefb51a904385b123b4a60582ae799062e5afe4800646da48df4099449df80df757898fc5df0bf3ec9a36559ac7f33779bfc55629fb4e80855177aff3d47af53019794634c31fd4c5377e862cc5f91fcc30872c5c382285edbc34a80c1489722674956ef29057036ebfd325820163a9744b420bce44f22a90e01506379c6c2e09e80be75e9a0b4e859eb503d7bc0a3472a4bde2574bb83e545e613427f3bfe37a1b1e7f9f5ce5996324445838f2f81aec6fa73131c7f305b63776cf5da65cd3b8c4d2d1a6ac4018226dbf5e1d3e63af6bea7e8051e319c5a7241c16729f25a51dd17c75fa90f652f7d479bed674e2f5c0213b5c76f22dde2ed47a885edfb7e7ddfa482a29f71bd2eae43acc90cb9db311dda41db4f433393de31ce809f5735b6c26fe717ff1b1aaae394ab0a1145665d00be57d7b296e268a73dd66290fea010ca02bf6c7e5943033b4df9f0a137366b34f533b60b946916b33910b7bfad1c7197d7d879641425f59466c035f1bd259103eab5f3d8db8caa26f0fab1e027a42187d5be6ba68b5b80a2ad0b423dc7f9dccb856d68a284711ce1aa42040610cab16a5889359d5dc4cceec5571a6a18c0f4ea9934fbf827a2f0c144c8620bc6b3088800f869867e872bd24296427cabec75413bbb7dd4eda257fcdc3f8a80a319e340f52bcacb76b62d50dcf876c61fffac5fd0259de02016d2e6d7bc63b87a93a54ad47584af7fe568e44314627f9b0b2590c5a178bba7fe4c7d0c0a80b47a22b977c7dafd0aa0078518a45e4dbb9f02da010d380abad20995c721d788fd8d20bed1389e5113655f2f7bb3e30e448215a0ada4d4b9d8a44fa3260f325f71b7826628162cb0d86d27bb752a696d21899b574735d943a998a7b287ea4545294d302dcfd906822cd86fad25cf23dc149d97c6a3b6764e512651d6e92a417b6a7a8223fd4787374a5c50f68171ecebaaeb187ef3d35ae79f0b00ecf4b2f9dd03569ca152ac61f8339c6896338b93f94442f7cf928eac644b39bf6520fbc3889bf9eba1044dcc4a17f4c516ee0a9215416ba412ded756ce9bc387e4bca06dbb3ac3c1692c4724c9140411b0d255fd11546775b53c019c9a5c652c8e3a49a9e573eb01bc842b7e79536eb1dfc49ddaa6ae20ae5ddd7c7fae74dc75498a904ebc8d10478ddc81afb13a0814ca412c69ee7b82b950451e45ff2e809015a8689ee5744121505d64e66afc33c4543a47d0d43433a5f4d361dda8b1faa5db006671c711e06b95e88d6e21856ab0e19691fd1b7b6e0512a6fb243d9363868e41c654de6fbd51be2b0329f556d82da6adfafe889efe0c69a00c96b3dcdee9487a5ecedf5cd62b11e12e11ee9fa3221ac6a0e3dfa3a886a86dfcbefbd584fb57d7b537112620d7b4cde5b39a3400326b70266d429ab76247549669e879606f7463a7171a271066dfda1974d7c889f80847d470b0136d3740d6cf40bd9d9150d38c850d203f87cafa72b28d7daba855a5029b3f77f0e37b3ea64278960ecfa200ce7332dae74da86b86b9143e8d890f1249491c36fbf3e9a1bb54a0e7dac5c43fd18138ec6ad5f40d549dfb4bca19226dc0757c1e4871cd2eeeaa076f1c645b465e9c3ecbe11fb9f0e8295340082929be73b13e1ba061d24471a47277e7a303612212f4fadf7c0400c3c09e97b1f34b5d69cc39b9a04ba2949b35ff4ce37e787b35ec2819262988f8ca2bf5e57e9c507d43842cef7a4ab39e38dcc86dbb5eb06716cf9b183c8fa8b3a7725bfb9b06ec673b547a4d1084611bfd12d3bf03339645a69978c6306540cc6d36847c53520fc44003548551fb3f42e5e9e98f672969c8b7e42136546fbc1959618458164ae1150e2137493a18c28db5dd38a52e416337ffb1f3e671f8c9258bb09a2960e69703641ba6a159122f167b8d91d1fac3ca5e1a9eaf1070ab18c4f13738114443860e81c797f7776e45e98c7a33c51bb3a167273a5e93c84e50b81bbc804fb0b58bd5970b16382c527f909f381f62d80e150d15ef9b4c5fd6eac4e4e6b68531c36dcaf22185082847b847f454f77250d46a195133d774cac0de209a30782a5773ab926637b6635cbb3c3887c0e30819eb4eec4fe36a979b8ed9dd989f41b16d2155abcb8d1a2f1b5758708ba171feeb07bc677ce6991b7f8381425bc2de8c03b9a2ba2f2861a998bd94dd1e27a76d30db5596f2f94159bfd938d1872637dd247b80fc549d42c6e512c9f4976678cb49b20967b4d78a4b489cbd09385d5cf76712d1a115c1cde8fac7cca3c7adc06c93aeae4e9083dd57e33d11183e944617c81872c0fcc0d65c7312703e6a198779496a0ab1629c4e1338db7dd746f95432cbd44d280fd3e1c25507e3e58e270ddaab26c3dfa6d81d285c08d7fef39db01dbb7a6eb8f468e0de138b066f2471fd8d4853157668ab087c8f7b0fbe6921a6d87d7b331a0b706a5e5d4cf0820880365755af42c77521dc8d72f1707980f1bbba4122a6181fd5e2f62cf03adcceced5a50c117c4b93642e487531a002d6e0865ee6178dff57c74828b7615ad164bdd938f2558caacdc1e6e21d5474fd5694e83f7e744ca1b85b2783c7de759e8930adf00b392af1ed4726714c47940b10b06afc826786227acc68ccb3ff3452d9a95678867c0b97e14f0f1d9b6e57107eb2ba5cf471ca3c417c33c94054a8c9308f73ae51bd1ddfb22bcad434a2fa025611c5ae31d8b26ed6379515f32067e1ba5768bd8c7f31b38086086c664297cad5ffa7f1e9be0f695839f5f8c78ebdba531bd9f19f704ba38a70fa10c24d2051ca81a081029e8e52c2ca27bff71b75d51f6fb298b468a28b5d14a4fb549a81efbea0f1d5bab29e1030e971b42c408d4a2078baff951e7cdc0b50891625a3c01efaee4bff569f63ca925a76a90bebc0ee3f2e65d741f0b3bf74b9967f0c3babb1dc79f9315487b94bb8ed5401a23af96673ffcc7ee0f7f305cc99dd8714037784b6dce28f5a6a9caa13ee8eeb8ef080f45a406fc7fb22477b45b1c460be36d83976eb81880e74256be81836748e1eb320464227fc6371e2168be09b3da0528b16ff0f0b8071a948b93a0cc9b72131b487f191373b508dc32ec7d8027d4cf58ffe9201de582b6e227ffcc2848e635914ed980f728eb330d932dc8454c27ef64a9f6603e7a7a4b36e56785130f92adb3728f385b3cdfefd565fa4b2bbe6dbf8c2c390b03cd0510c8b85a6109a40e475c78b884b6cb4ffe7a5eb53f91fac4d985d00c18707a674879a60adfbe90b4ae03ee2ae48d0057db4fdcf61b10617bc078aaab4f8ec5e5320ae011aa67b073c35163e650b7f03210ceb15304e561c16a14d79821c8b23b1025143e20169f170648f0a751ec81c5d2de7a7132bbdeccdeb5c24a7ffdd26e18f4fb9e78f2f8070cefc9a0625c1b14a1d8172cf64ff0ad1a0a51f0b15bb896b89bf62a75479aba992b96430a16b7d0b951ed34ed6611f8ed81ee1d4b284353750c7c9409a4ecddca517e61468a5d2a2703d75f0c818f96f825f07b93c74b7f4aac6eac835896fa6017390f43bbb4e37a854d2c9cad56536c43e306d47a46d3fcd21018c1904c9c773d451c7ebb2264b89e389271390f101efa7ffcc3eb41d4d66ebdffb59f7f528ff4ec622fb2580a605d699a11c0ba25c7ed9f982451cbb7052ef14b7afb9503a538d376222df15c32622f9ef2a7190ff89656ca831327f7e4faf8d2c2f3147b0788e0e03a298e1b8f1749cf6c410565fcb6f3590c1eaf4940b3fa9d901b20ab9395c3e0947b64ce484a58167036dcd6e1bedc134ea744cf0db9402cd245f0fb25fb7fca6bc3f35678180c2f74b1bbdc567099c0ccca8eabc677d199b70346af24c02d1c90a4e8cd65050f50955634dc09445f5712da6fd45cd6cf1fedf2297c05e6b4334ea1e72bc91a05d037765b0482f9b0d51b590f8747636cbd3bda2c2cc04255cdcdd32f31b8b1e65ce9f7bc42c15ea0e7974078e6b4320d9c186a41034417d498a79dd3d5f720d7e8f7211c117def91fe620253758f5eddec776ebe69cb8706c43d1b2ac63e1887c72318862c51ae80ddf2d2991b648b3780992bb634ffc9d1ce2a6cf2c81e962011509df6fd5ccce9ac14b8ee4285183aa0c2cb91f378b6135f0d052f679baab492eb45c23ede0ab43279b03004ef487ffd8bad2fdbdec3ec664b5403ea2a021afcc700a2330809797679afc45c1c18b64dda961fa6b391cdbfb1fcb0bffc482f3670b3e8b55e2aa91e1d3a3a3c431d8b06ffddd539f1214180085aa2eaba0faeae01cf9995669e38f6b908645f108605e65fe9cfa5e41ea7cf5394ae1be6e020d333510a1d6843408e432577c605e04685c040762c8417d719bb62ab3c14f54de35585d38a062559b87e741d1d37712d0f3405780145663789c3a2d48d5bcd6bea5bec0dda998960e2ce61c2e9060a22e4804006d3b004e3d031c7f21d04b78b4dc30a61bc9aa9bfedb206a0db2c94399ec370e853d3143829e737b8eac99eaa48cf06e438c02c4b2782ec69f79de904bb2e40402095388311180488f44364295baed6f37fa5aaecb41f489968c94241ab4b9a3c1ed7862065cef88d8baac6d565e462d10023efb6b4ab1fc7396d293b7ddc74f6658838acf1e752ce0363c3910ebab7ee6eb8af1c83f6d17355a918e82a3ac3867170817167a65b03b4f84d1058d20893de4e5cfdb315983c740d8b6d0b7a8ca8c0391ac6dc745dbf858f2962755bea8e0f4d3dbfd646661f113e2226c65440a11656e56ebe1210390b2ad54f7d3c29513cef553a0f47d98e41c4abaa01b5ca120f336ecb591443d44bfb19aed2b2d7f6c5563718ce306d8217cf3572b50c47ad7ee7e19e009ceebc3ca7f5211b972381fa5eaf8f506c16697df49519ab37a74e674794e7c1381cfe6d30a3b1fc972d099e7a27adca23799dbef2e861c98882f43b4b774dfde102057c0582a87a785ad88016d5d69809509aaaf23f429aba55a69f1cbb16e6ea98ff0d02cf8ccc6d0cfb0f70972eec50f0eb28a06dc3591ddbb9b3b8354b5e7eb95c2c57b6fa807fce2d91afd10a12d5fbfcad3eea05d742a8af83d04a7e440d3ae417ad355e297665dea538ae072d8c2d3b321679b87e55575a5fb469796bb22c65d9a3b21ba865ce9a5643e5be8fe7a5f8ebc2f84d135ff1b1be840d832887461d9f9e29b001dbbdf21efda70be2d1ce1ef33cdac27d541b328a7ff4ee7158c0f93cd2486bbe2ca8b48738d4eb34dbe322d0dd8529b48162b4454700870a440515d8a95080fa65feea8b10bc5a6dc724296f6a576cec408f9d31ebe7d1e48981d15ed59dd4256ee0aac38cf6b33599b2cfe23e963a0dd9641cb66a3400313054970e1b6620cae4219aed3d3bf1ac550ab33223a263ef43175468102758c9bc6a352469f1eab303339e7fda84bba079de5b0b8ff26ad92e7d593ba707924192a469847c3e356c2c3d0febfc272922f6b1747bdd495167b568822365c0feb5a83d851e88c989c4e41e97808e1f34577fc26d03f79e3003f7dd232726581c39316de6c858ff280d012ade27b4b9a52ecef53b4db2e9092f06accec50438eff59ae48b6dffa4320b378badd577d29a99a9df9d8cc1e55a8fac35447ee6061d10da2ec67ec2c4e3030b3258088b18589b229d58955f04e7a622899773d8900e0646332e4ee87f354b2dca075abb2e91c8dcc153de87b8a2e8081d6a9787b5ba6680fb6e7040b3bbc1254f55e117bf1b93abbc7c2e3642be95784bfa106e9d746dbb5922d1f0210167899258ca4a36eef9be0a3a40350dfa0d1e31176902b7165d341bc647ef367a29459d758f8e9eb4e7c71aee87d6dac4d7378a113378ed69de3c2bd5ec17e7ab13a9e12a9b9e5380652c35dcd1136998dc0e57fcf9009c5487aba28eb54468f659d8f4600da8e8aec58eb9b99ad399113bba0b68f4adcbabd1d9e34a99940c616b17d544fca349fa5ad4d751c8816928e029b1771d67b88ac30635e16cac2fb7eb0feea01f6180a24e9bb7ce01ddb71d1ef200d49e64d1e495ef0c67cdf230d150edb3da51b0c85c7884d0ab056523af257c90ab72a6d894db48a19d4ad525cef36d8f7ea56725942d05179b9e203a6bfa446c83ffe0fc6b239883a81189512c788725b0207591238c90d2892d890663f689466159f3a220f68132324ca1ba25cc2abd5a9ec8be0e3f983481b42b61ab457d9493d4e90634009a7e0a5ce2823492b5e661c6a44853ddb4f50ac258703436eb6f234ad83266e7e7eceacebde4ac6c6822c316cc1f11a707524450a380579a31a0b5a23ee57cc382246bfb5db098fe36dade3700603ff06bd5b147ae1cd8c1e53d12ca50206a31dce6a88fc6b7181f363d70063c5d36b36719fa9989ae2b55ab057a94bf4165282f163442d4a29b926e74cf0e26923174d0f95c1121f074e245565ea9bd3aa57055546fbe40bebb77209adb0c85e99c0fc0d755976363c19f53617248045e606af909483e031ce8e75c5f56e863da0e9980bb31e7efa1053ae2ba6a93c1c1f1b668390cb2097fe8f41bfb6c04fa55924ab06500832fa0e5a73ab4e8c3c381b5108f2aff61a5837dc7d5028436f3b3cf0a39d31250f082a9f2315ddf5e320c5f67747de35bf8ce9335f783f7eea69d38c8330676be6d260ca55af156bbe9d9c0e78e3e96617c3fa2595f598e9fb8b6fe59d4f0b736ad802fd510bda65d523f4f3dbc05ed4dec8943a3d286d409f6bed1f83138af85e5f64209489906e268d5a4ea259a8f625b25820aab708bf2da3852da1b146829d6fa47787f8cefe6e44785489b1e40b9114c091a5a301acbc50bc6abc9034567ee9b78be417cbfb0fce20c2d39d8f24277e9c7093c6af64a204eb66c964cd39238531c3dab8fa5297b66f97d34113bdf4ac03db6457be7807b67fd05bf17a2ac016b9347d6ba435655af5bde7c6c836d4769dc9f7c987f4d1a85c04f2f55e2a7aa52e09942b30e18553a732d7d6623afa3dcaf022249c551e454d201bca78e64b9dc3fedee888b922d81e42946d703ed314caad21034726f824ddf98c00569cdc19d32c26bb10561b554d238c3c968cea295c1bac0050213f25b6854d8b21cec4f79f06bac66b3068bfa29e9ed459bf120ad84c75dca21267ef59576726214189f4d5167ed4c91c34952a2979edaee2825164908cafd162b63d007e7aee767d09f70a7ee15c580e1e64ba7d89066f71dd1919eb03372c07729a67c090c010c03962c38750a0dbdc39fcea5e8fab9b77006ccd4d37520dbf6e64a11815146c220927882a0816581286474c4b74db668e80815bb3660736d5b06b6d79ef1dd42ca91e3082788bc59d4586e57b8ad27f56239fb2c4c36ea37ac3ad90f856aaaf75b545ae283a6017f06526de9a82ad2f6d3a6b08b6d890b52849bf9b8cd3d96d0e3f40ddaca2877efc48b752426c8055598ca252e221b7bc3aed1ab430917a71929c4fcb93b884e67a02db6bc7bc609a06c69224bdf5e52e3b7a5d939e993cca570898ca15ef58fe3209ac2b72d1ae32a73c7b355e1cb2c104c80b6c97e3ea08c091c1b0a5fafec546c8058775a64a286f5cd0bbc57297fe187dca7c357e79a270b339cdf49ceb8b586ee414d196f9119c59eecf65d5f9ab0da4d2405ff4656b4d4916e61548baedc912a891290b055cc3d3378576aaf3390ed6aa5e69e11a8bccc94d5658fcb5a0de9ead23ee0f34f63adc0d5b1d9fdd333e612635c85689465951dae4af00d5156837260f3b5f25599f878195f13b4d0e70daca6260ace4739a2be0ed60a86b508815edfa7bb8970f30c34db95c9a0d95240d6cf4050696af87390a8b48c11f25a3be129ea55564a97c6e472d7a800e4197a31c9e72c7970566a05e2ea06ee3b8f9ce119cb57232977b722e1934d17281fa2d5554091c397bfe5a0093d0906ca69153a8914a950c9a99a49db7a846b3a5d93382c6052979ff971ac0f6207486dc91c1651e871a9716cbf70ff10d06f74a89b799d753e63b6ffe0e69faf89024c5945bb020da5ce35c57e1009ccec43a3a755fa647ab63917dbc6ebae1400b3b240f49d1919f12e902250aaf85dd7faca08b2c598660772c2c8d51f5d787f07f56dc4987a68ce798ca836ebb88690616e7e4d06c9a6f7d4d72bb34a67d3d9adb3ba59e4c828303ea3232eafeaf3a75d10654f13890c3617f8d25a3c8f861b52a8082028f4c7d3bf47f3030c431263f52bcab96c2a4977e8e3c39c27e167197b28f475e81ebacda9a7676f5e546569ad3617c06e26b939cbcc67134a6ae8277fff8533098d78e83c5b80137fe68ab0c600fddcd48bbb127581adcb845a75c95074b6b205d5cf7d205e8131dfbaa8be71fa4f0b119872b165a498abd7d1ced1304c0281ab016e94daed1306e87e3f97d4182a10a0ebc8138737d1f3d15d3134b484c05f601fe708e30a48e3ca69fbccbac5957a07f2b01bc8dac68c4d931ee1eb7a9eb73a75dafb25314e3017d7a25440a76aae74259742005b0c6de8e6d844afe2c1f228606ab2cf00d14e39d73fdc1981216d991ce48ff288ec09ddbee49275b22e47365efb7349cc47182872a983d866f51fe0df152dd4907c39400d581261b00b210e44b632346ea04650d190ed38faf00ffd3d248386d030f0e84f61692f1b8ceb15f87e1b100afc0b6cb5f00e14ba2d88e989dafe9af82ffb99b43768aaf857c4bc60c6300b241be998297482e165438b648d2ce071ade5c06027d59734a7506c8850b84ebee20881ff47aa5f59230199bcc39fa5127b9bafe4f463f787c947dc91d3ef32e1309932ee0167139044c7f7543949faa9c471fa1ede4ce9eba4b32fb7036799a7e36a43a3cf39f3ed6383b72487c5fd6952e5c6f6f4bee49e13519be758aad81f2c470f5d8e4b09f95990f55f6015b6c2a7d8058e9e94c6215d2a8d9e7fd411203f305c293416e811a468f74183ee5e658c5709548355402c93fbd3aa61e9b30b3d03913ded53fdf2d2f134bc48dd8a82d21246174ba95bdf9dc51d82c3e5ad584f5fca5627d229ff9a9ad4972e7d846127930f61b6a412e3997cf58fc70fb0558e5cd6932928dcd91a9d8788cd9ea6095d0fee1d1055874e82391d5b042cdd37facac8887b49610c600e8c01861d8d3bd79a364f193118e0f3c9e8a9db843be1f75e13cfb12c9ee8ef51cf8e90f24bc148c9db5cac9e5a04cb95cbb8b3b2c5a1b61361dbfeb5988e96377a3c1b2d20eb95e9592847f30df6da3ab8a1dbcf8fbd151db1219642f8ead614c8715d3619e082de19ee226da7598b287f9bdfcb9a76737c11e662444cf8bf2b82a1125a220280dc50c21364557f71f723f33c26168e862ebe5c41451a7545a1094edfc9a437afa8b14232a56948d9d4f299d5c7c9e36f4337209e4c36f1b4951b323a94391d7de8037a09f24073395111b41efbaedb9009039b94bb862963cc46a2e24361b9b4d1922a87f11e8a0c93ada9b46d31fd7286b677af4f2b0aec41d11b571be659b69d523e9b0928e7735be5c0e86322c5599aa9add42c67c028556e51adf09551c549a82264135168cd5b3313df0cae595cf92bdc33d949dde2c39f9fd025a4156971963df28af42376def7d823a5e15e433bf98b2a33d120f228a8f9d936f015667555f3c5b43e6ce3e02711f6100609a512fefcb05faeba518946600d6006786ae2a902c1919bd3574152875eadf80e7ee27fd7d134ea36aa78202cd0796fe2db19f689538688e6cb49921bb297dd2551d3f8444d6fa3a29c726358b200f79888db540ea779d5fb34948f58b26c12cfe3e47012345291ecceb4147223217d326158dae1fb8c22c455d741635b37c6e37af7c99e4437feb8ce520967a80dfc5fa927b618ee660d19b5eddc2cf3195ff1f610732fb5fae9d61fc7a8d3a549b08946c4df7422b9b800df9a4e1b12de920e630eb89ee4e750b72629a2a6fbdc8c1e6ddb58e8e10989feded0e3a74e138f87e6654a9cf748044883a2ca54f4d13bf2db3ee7ebc826822132c30b97eb08e381ce799420fe8f208402a471eb224b26827764dfb5bb7875068da845d15d48aff8cd8ff1ef6d542918e7f7abb7ec9c8821cbbfbe85531d7ebbc0fb01bb08e6a6d95e7b268c2b6a86267decce3a3341acf5e29e9a1285d7cb70e7f7460e2e04f47d213ae1ba228c7a65d54e7cb795a5bac2f1c105205bfd5c45e4dfbe980fd101d09027375be92e91cf8c9973238d6f041e2f7a1d111c241b69e4959f12a8a03295b338e4e59f2eb7f19ea5466854260d18d1cb5fee95fb759d788884c80278afaf39f4d5cbb834a52cd50a2891416c96125d78f9a585e85deeed49a85f354212db2ba58da0232442827fdfb18d2036895ecac1357ea1218830b973025a8e7e2e54c69d547b8f188bcea6ca857fb2c119625aa86940eff245eb92625ab41b19224049876808d27764a251b1bf047fcb054f5072f25ae317e4daaf2c9854544b57f649e82f74322c173fcaa4f80e22d4f1be361131e4b9bdad1667288f612ab56f0e951686df215e9e956968b0ab6f2c5773854d856f70350f82a8f376da9cde7a88596363eebae37a443bd956d301090b5c2c1197b912f4e2141af140eb1092faef95588b6e6a7b3015b683d3088fb746a5eaba0afd65e5018987cf080b3abbdb902384d0d43fde5df7e666c938e10e5da610b9e3263f27cbd390749bcc20c4f368440ab725aa15578108c77bf45c447fe08d940f16754956ab015b7795f16a35c1fc93a647e7ee32d4c32a83f0de257e77c1dad76ea8be05886d1aadddb6cd417febd644b1a0123d4673355cdcb8db2debb752e1a0d6992cb1469ada4932547a30aa198caf3019acaeaa2a7f907488d98c53b247ecf3c313ff9d4e0f14e4889350a7d72f9abcd7e91afc65113571b4470e158c7410cea9c34a4ec63014b9ba066567984cef4007b39ba9f4f240514b92a2d5063c00a36829e195e7efe643fc3d9495207f7dfbb736cf9da2f46ff3c56d8dd4b2e2c649cf38581aa86da7e50b7dc8669b6e59ebb347b5aa32c846692f01b080de164ad67103ae8d1a34cf26853c56164e4c56c085c6ffe32a10d2aad5ed683f5b3cce61bace0002fa8a5e78c220463c4eb8c75d48d2f88feb607e3c46be4b6949ba8acf2de706dc0139e190a5d714176715c646fcd71b5e05364dbc5cfc1dad5bad736c3a09ec30896ce9d7556e86894270c44604b7f21094ba57f8021311ee4e8930ba74c70266e0eff6292b4ccd5955e330819c049ade6f47840404e32fa2b601fa52a2f45ba83a57f0fb39f768bd61f79e4799316ab21e9a5e2f785f1f008ddff3b133ee131e330bf4e5756eec26fd37a2e976c2c0ee018f6950b4399952a4061e300795a267e5da19c62ebd5da1a1a22c3c33b08cdc5755d65c69664c301884614b86d79b655087b138d7b51f341d27d50f885e1fb09a466213ac3ca30bedd19355ffe06742420e0d6869234058b32c9a45f602a48fcd3b35df509e294141c1f65dd7c554981e752e504b4ded8384bbc504435f4d8ea325a527dda121f8fea892fa31aa48aaf50cbfefb764f9c32b2a2d68ea82a2abfccfbd3aa4f98a90718d9def9d01041959d86a975f18ffc85b360f3bf7f63c39d8061a6f0d58542ec4d081ad5ceb592dc3115fc2f70c03d50e5faa4e762fb072df9119131aeb4c5c592f241b112848d16d8842881f0c5ecceef5e9861277d276422bf5105bc4fa408b723bc7c2a7608c7f3f657ee973f66ef449013c03ad376459af38939fea1a144f9521447fcd73359b20526d73b011b72a40f3848cfda8870d5aeff8ebe85c187242baf7ad4bbdd9d8e09628c990b38d488d67f568e25ca38c428a63a4a2f90aae79afa7609c5787aa001aef059cc94431fb3e0e732f73a3302dd606417c8bf3a609b33d65c6517bc3992bfadeac3cfcb939c4553dccdf0f00aaf4560f9f6f5cddefd4688a5110637ea5d477e3022a1dcb876b933bafd2d685aab229b745ad416f47fe8d68bcbcebbec7b562117f325afed0343c1be9c2669f690acfcd77df28377e7f3a89a5bb18f928bcd67a798e8bd1602b2df42b38a50e7903e1ffa6d9f69ecc5ec6e1a923b1e69a88eb976450a2b4702a8c96432a81f14e9538801a770a2c724cdeb54f00bbc0d1ff8dce03dba77281a0e3633ebc1562be8e753353057e560eb602ca3ef0aa1602f8718fa54827aa0d22a32474c5e706065f398f5eb11824c69bab6b95af69314cd204ad33668008943274f2222c3d0b035901c8817e84785385985a4d062ba98a2a3f35e7e16e35f6c4c65d56882fbffee01d24bf24fc28c72a041d7d8bb00f3ff72571eac6b4b1170c4c922af5759de248e0029d9c6a060557cbb036facdc5fd6dfe9ed9414d82c2da3f145dc9d719135866bc4a599ab2f3c3d4ba1f2ef35c905f3e63f3b437adbfc5bc4cf3d2985d329abeafd8380f79f32f99b10f8ca77bc9723c8877dbdb9dafca04624863ecbb70e1cd16492cbff2baa1fe9e9b91c7940da1cd5afc7f81da75ebfbae1a3b70a8db430479b92123a3e1ebbb98764328a55221d0319713519113630c2b75e0dd20d2ce53ed88149b4a9f2abbb9a1ebf92d680596184c72d33c53a997a8de2ce96c35ac667b716450aa372b671878be6e9e27ec79c25a4f0785e46923bc4a2e4f72152f06ddfc3d3129140e70545525e76b5b486c91805f589394909d5c3d4a97be1dd492ea5d28bf703c61ac46b393a28351f1fe52eb95baee6e8c0fd7440ca8147c45b92662ab9ff475bddece139f5ee737565c6976b260c7427430b742bd8d6013ede0acf32dffee0c1a990b469e7d68f8684f525f8daa3292b08b8f61c350472d3020e263e835ab3b02b53efd837bc4ebfef76b30ff22e84f47d7b13955c7e4a9f6770f082c97483cd42b1f944b84baf18ec518cb7d22893c5bd72ad9510a002464a8a4ef086876e7332989fa5745960878faca154da424b1cb82e73e1d4ef0f635359bc034b195a2b0959a805b646cdcbe4961d1a9e0063620bbf29136a4f3e3f872dffa6efc8cc68042f8191e1d8339d396e145000ab16390ab3da0dbd600d72c52aeec6d94e1a5e0335bf7370a6f12a0f5f9f416597e4fc0a8182a61bb278f20d235f75d638e8121324b429159163205fc61c8ac1bfc38a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
