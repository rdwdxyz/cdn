<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7311b0547805b5a08e6c1c5a619a0028a821f598c025b166518aeda12244943489cab55aeb233d486744c3dc13cf46a294618ad5a9d808ad1077fa556a14edd5e483b838ba50a0dea9cf7c6cc7aa786adcd173d757215294008520aba5d41a8ea9608889b9c5025ce22d58a3dc4816c99cd7a1cc66fd15686133d769ce40c6ec4fa672241a40214cc4abff2421625c47c9022539e0a23ee57e72f08ff321c42eb0d2afa3d40ff2c6a9f42a8c42ee1fd58e38a517408c8d72fd11d5539666858a10b9f9f56eeb51e36077a6a6bc3048d056f9c4d7d59ebfcdaf96c129ccd05ef5599158a6b51826051fedfbc8252154ad0cb22ef628799a8e92330d3d26a17dd22cb7c6562d9097757e49ce24b8924167a51efcdc03385c86cd3d00cfb5e4d689f71dd122f92980f1afdd582d6eb7b6796f13101f6fe4f90031e8571d567dca530cf07393d97e43cdf2819fc002c715b90671112378333d206f65e18efc774d3b264e7a4020f5ee53d6e5602cbe0965ed49c981a08a58d1a97172e6ebed6aba19f68741dd0949f59970d0ba00926090b09eaeb6216bf2621bb99a2a2d52340d52cd11b6895aff83f04eb43b245d5accdb3390c567151d04bdff6a3f96ad60fd9c50eac3133aa538f6dc9efb97a349e494c1cede14d7d071cd772115fd83c53a403b06687215b4bb3ff28ce1ef2468162559bf17497ef40a0da72441b77c15c36d954932bf9d6484d5f77a1d00d7211078d5356372e3d3b5056fa53d64ed4dc522fe93d0016332e30adc1df0570cda1bf0b13f2c38aea4138178605523579e8924563c105d21bf2e0b5594184cf0d6e6bcfb2b89c72263154da15dc71d4827a23c6487b9ce64cf202f19de0e477e7b1c7c07f48c2d58a54b19ceeb7e3b524e04758316d6a6449f9235d5544e1f6e4796cb2c2e813e6d41788d86e9808264b0dc810c04bc535cb0388ed39cc221f9d4b2bed7487652e0b76799d5a4b3940c4dc83efeedc602cf27d21a504e426e9e760e0e8d18697568905c46f6d3b93f07a30f3c6b6c1a5678780927ad27e03017596ca88a5c8e7e7e1ac346440a59e5ea8b471330cc15873fbcc5613a0b17a5e0ad0f0ceb3c4ca21458dd509c4c4448924de067cd6896bd42040b7ea749cc9176902995e6ac14ef9f80ed9d8986936cc238d50d12daf96c05a4f542372b43111de25d587a2b98727cd4f57b18c0387035c429a9a4a1cfa70b5647a2275097b8baee5cd2a947ef9f7082f22be24e38f3d07fb511b7056b62bd21e3c8e8ec1bc171371264b3d038477b675a0eacccbd0ddd68ec082d13b4a1a48bdaf2ac56250ae48c78475aba00c18d0a05aa89d0695cf62074c729b08ceca6507fd159cc2ee406c65cce8e50474e912c52089c0c31374287ba9c4e570903ca972f9a39aaf58e20214bfd198b159d9b8f289331f27b77ccc89fb7cae7407dc361b04c7687fc3765ee86aac2f2fd68e7fa056a85e73f2fad15af22a3949ea1c8de803cf3e8d987c0a7657a8f143bd3bc780d899c644694f8751b60114a7ad68f0ee2fb341c70516e3a5fa59246d65af36a22a16614057fe7523448d6dea3f79e570ecfd3749b13061f8847dae33751a09404296e1bd12fbdbfbf99f42e05a35f51e1df8a7b217ff6e6997d53b8af05eea4bb0524797d469781d2cd352db99cc18919929a2debcc728a342a87bb6c22e5b7dfafbb0002f377d13e72380ba6c5d78769b21e2e15a70e9cd0f2a80a7d6d972c4408ccf68a78af92b9dcfa3e222688f12d9cf93b0ee6c451939bdf1f4169985c8929193cfd58f8e4a4dfa3ed0a3c34554c07476a63e99e86681a72bf408dbdef737570307b276ba0e049232f89089c1fcc1e28ac7970ecae90b9b49766d190e44ec31591fa60da88d33f7ecc5cd902293cfaeb60a0d74ec0171f622d60758cb502a2b7e2ea6ed1f887a97a80cd259aca427beed36847365441d75af2c3391346d0cca449a2a34d5e4d13fad228cad7a242ab234bec4a8c8ef94caeadc57898ffba3875f357593b9c602d45aff30e64235fe987e2269c6d2bae622eb0b4937e343ed7cc6bdf1bfab5e0bfbeb66c24cdf7b52277903a9905e4e68adfc56ffa6860a5f2a121730f54b72b495249b3158c4a750524d5a66510c6d4fc1504cba5752e71dfb732d13db1b8a08f5c6a5d5b2deafb7993e06a002ba54cb71b749e4904a3dbec6fb7f12108f858b33634eafd5d75b62461db2356168323eac6cd97b6bc7a793a8e0533b15ea8d2efed5acb4f2cb2388009688d563751c1dab708ec25b910b54062517b2f8f69a7a2f09f56f310160aaab2651c9470efc7630dcfbc26963aebee87b21f30dbfbebddf257b27ddaef7e0a17b3291229edf5376722b43dde935f74b01032af22b5874f5e9a893525a0a94229c15a9e8151af898e16e6328dcb7a0769abbcb53c3584272f923aae23cfc8e35d48d81ffef937d3e46c22f46ccfaccd303f65ab527ca4fa8ae8b98f6ffa884e48576eee2bb805e886309a6352634aeea843b3654ef8e9e40b0b5d33f351ca99f5ecb9ac765a3088540a3d2e77fce992e8b015cb2b364099a77cfd2ffd7b1ef11e2c0a390494507c41edaeda9e6154b4a7e5d64c0c26d7e6800b1da91673c2e183fa59ab79518e95ef0370dce734f7cbda000cb8485699052550ab36c15aa078b50e0bcce5f280cb3a92abb1c34ec80cfaa6348841a724b549dee99b8b03686848eba2246a8f04040647d1d4b6cbb902d231e91f78cee9c8fbc327f3d825f3c8e79cfb2228522feb540d7c12044284eea09a36a212afa594f46a818446f5faad8cd67da31d5ab0c35991730d25b2629bffcb94fb9edb87dbc640f3e70551282b22bac306dca8c055d0370b24e8ebc436327d31caf263989e1b4942627d8ded066791377ed96c4393c619cf8017191f428164ce6dbff56698e08859ba501eb5afd9ddccdfd1c4e5cef8c7f4a1c6fbe0d0370d23c725b710dcdb2d6d8d14687a2071619e52c59790a0fe9268f60c7e233b91710e35dfefb76cf7d11ce40f255d5c9d38d071304455bbe25f57748e3d96f5f714fcc293782cde6e684af33056b301cc7a3bdbaee795627de25fa4ae08ea174997c1b9bc1fd45d3faf8e2900e3e83dc8e1a5fbe77c136bca93efff56fe0d80d2362a70135d2e5d83f7615b1e418918e182228dedd4bd532d6b8a04753f3e43e707e59bed292fc1a1a8155de7a36fd6dc8e7ff514f6ce2d1c2fd690df3a76f610e136e83eaa05f4a0a57a548ed29c451ed18d3837cdefdaf7fdc03ac5d7ded6894f373204b7f8d0a59e067baa9dadae4ea7d628ae82d661b9b5f7683fa62028806c1c607e1b781882dfc37d84d987e65cfd454d1b12c9873da6f51553db03ab099a16746a4720fed941373d198db487416de33ef58101045268f33c3ac888fbb0bb5c2401ce5f56d0b3129043d433fc40c4e5b78ffb44b2b4cfd60b67a1ba9c53676e2270839d139dc911e868b30c61d868e68f03b915180179e46f73706f9b747099f550a3f521d9a217368ca73209a596eb54529adcacdc399e4dcba3d5d771e9c333afb8b4ba89ec440df1dfe7867f35b8a602632b6660d7250505ef2cda6efc98515f059d3931cfd6e0b50d301e40aa6ecd09fa7454a73de05c49fa86d6dabea758b52966485d972db67f51f5c190816a323d82435098a8c692f5257679030e490adb90a3378e04f9b78002d56e69d921cda267e8ed920de39815dc3716090c3151b728550d5c6e173c33449118be6593e312a12a82f64e5cae5828750ea965d426e8b94b378fd9e1766a95db6c538f99866dd15a2afdca6ed1b21cb0594eb993ce7db6fed832c35df707413f53875a6732c3a2b7aefee8b87d24d588f045ec6d8d2bcb7e038f4c8d990bb490e385ab7288f5b8fb3c3e04edb7fecf0ade1324b8e9ce43593ab9306c0325acf939cc65e76d273f386c1b8cda43b21bd7d19779f0eb057e0a38331025f1ae72eebf22d9a31040535d14125ed9e69ab80482a003d5a91aed51a2185b3efa26ce4fe48f54e9c54c20d2aef4fb22f0b46df8d11d19b42175b65025eebc31bb3cd93b34eb46dbbe86b022c47721620a5b93342d994565cb1a06c41dc026ff5cb3af51930c82cb65110e4900fa6185d5e8aba72b99b6b3dc1ae50cbf328729d8deb9f4ea3d30d79facf3b6e46a75ab2b4a2f8b7af8b3a3055527d5a06477a2d127ed4d8e78bb32471dc4995416b2c564e65091a600b5362cd1a0fd3e4e439438aa7ce36b0b490fa08b311acc7c5c6a8bbdebe7e62d2a3ad2dc2aa7b5664beaeb9e2247df466f29a6d7463c5043b7f4c08a05d0bc67c8ddd952395829a8a4e393db31a0be3ba7d2189b7534d921c7aad28e40434f880070e8146ca8db0e07e03ae6406c87fc6006fe023a96edf0c84af9279281c6892f5f58ff9b62f5f16bdc63787438ca07542b0cc86780634e76a009e9e0f70de99d290843574fe8f2bb5ceeac4c52babdb2e9929067918c31f30d621e23ab4244159ab3729ab9c63bc14d98a289b1772eb95b29ec2e9111d670589a0d9a55a44fe29f5e5f7d1a307f4af42be9e54be4a8cecaa55fd14982822fc1cd75f74adce9320058b338565e1ee4268301028e98bf7b9b9b6fdc1a74029805fc5957d24453cbc3f1e4590fb7e66d8f84337373957b4fb8f2a2cf2ab6192f7244bddda9fd6326d236faaa131844acfdf90a46238d4f2f33fe9f2d27ad134c0eae077926b670dc444d721cac98b6f3f97858e917f5048c21e2fb3531dc422958377a01b62b649439a08fc6c73bd4c28e3b220038ca8a3f29cbbc3854d495e4cb31d293c228b774028e31da454a2c207c6a1ed72aeb24a5789699e613d7da9aa74061c3f1b81b50365ffe7ecc48af60a6284eb93968bda5c67438e0d5e1c60c6594884248219d737a5212b5a81b929bdc2bc3cc77a6aba9e7ee98b8d5df90c4ebadffbbd829673d7803ab4e52021fa8fe677355942f2fd83a1ef5057ef622fb66d1bbfd944f5bb9ded5b2b906971cace51d40731a66797e6023a8ba665ab1ce7832a4e025d6a57052f2514f0aee501af3ecdcc9d4af0a2b573ae1ca3f115bf2b62483405a712af68a29e54d0157e98d6d4a182c2591bf200e81cd7e2cc13e5fc3b2fe745590bad242ef8a86397a67903a74c71c6cba0093cdfe21818034ead0ae18f0bfd4bcd74db39835946637ccb29bf3a69c40ec65f45bf23e435e9371984074fcc4d68fe05c14c4bcebc16c1210157e84bc6912f37a7bd14109a2e1748f8605c2d3ac3f5af1ed7240937257ce407815512e3844a59a182fc55d1520a31293b025ceb6f1a5effd87123f52469f13c21803f7f014e7348fcdc6450957b2dda47cdb41dcc6df333cb887877cb1bba0925bd76c9e8928b258c774a4c2ed771ed1fc49a163923f014f087c0c05d0500a1c127c4c8779de5ea8d477b418dd48249bbb54698c8c5af346b4a131a6ab7b3f92f24443b0a3433c124d606088ab8699847c8c5b915790f2d59e943b74e2ac3d656af413f6297d80ca6ebb4bb027d42d6e33dc67bcc0a2e860a0915cbd1334ad78f97c15d54796d2a509e690128b97b94be15941eb3e6c1137970f204daeeac2f110a3d536bee7ca8ae3240e654ffcd97e720a3646b89ff94ffc5b670f907bf5dbfd59d9d0e2634f732a975e10fcacf1ac36b2803576138f1af8fcb9b1c4f724737a4e667899e3060fd93898793b7463669577e643037ec8b44150a75ff9835ae7c04d013937fc3fa39b589d2407de90782775555268f7adda3befb23166d31aab246970144fe6214d2655f6aaf935b0f015e77c1102651c426535a78a8909ce4704b724eae1ddd7177e8a4359ff4224fb2703edd2beb0abafde651b9e7ba13efdb2bd954c3cf0e51a6d70460938006a9efbfb14c3c4cada956496ee62ee5a9411e125d9ede250fbac91b006984578237c0812d96fe26a1fb8e5ba2a4214b06ecb1139fe88a879e905439f492215939f17e587a31a8de220bbd188dac4ab5fc1884bde081c19a6571cc093818111b62ef22d02e6216f0a5e0569319efc82d59a1b14c10883a7aff67ce2f6194c9380c648d75c24f1869303bee6c4c0d82e94490beadeb87d285d4d2fb374237f73ea5dba9ef704e8a4bddfe46493ddd8d19d4e790507f2d0d944e6b77f4e05f73491bd72289a7cadf4c42e253fd190a4b0efc1bef881a5629a0aad25d329bf26156b7d1a8e416515b6db271fed201a87b4f86843400f2a28df469903397c62546fcb4aa0aa065efdd5e3c9c9248390a3bd3e4eba1b1a42ea31976bd715fbcfc32f0f6222b04323fa7db0c507e4889cc8550b51c74f7880cd22c14a3545f4619b4619e50d13ae1ac9848ab08292da94552a59313f92e56dd54f3ffcb5894ed956b1d4aaec82e626cab5cea0d52f3fe24656c5876fba83a39d630c125d8b1c4aad3146d85840c0327ab5b204671cbf60ed627940315eb7f1c4ea136dd3d901c5d47ef84dc38d625d3327dee38ac3dbc0244200dda62c0c25298d0d06017ddef1550f20578a2c8482e161d39f7ad94b1f6f84b7744315ce018434d8393b31a97b58aacd22ce5f548c565f25873932f953c968df86dabdf5f7b1b383dd7733a83650503f90d2304821275cbbe4e42d8dadab8036baf1853da2cddd617f3bd830e87427086316a64612085cde6d6beecef05276485f040c4b46dd118465fbd0ba697270a6d1fe90d268c4f8a95421ccb27859c1b05d3a3204fe66dd44119d7ea9e10571123d03a28066cbd91ddfacf48e6be6361685965c496dfd7cc26b512b2db4a40afd0e197b12529002ff9616a0c566d004fd8e51106f292f5c977931b394e569f97bd3e657131ebbea1eeb836091b01a87911cbcc3bf9712fb38cc410cae400ac4736923489f4f94d1bf7e41bbe0bc4e78884340ad46c7b054241283bc1973f2c8b53ae9ce968158ebebe4727446dd1e159c53f960bba8ca8558043048a0e80445d72c3510c82b7cd046b75bd8edcd046333170e30674fc4910fe7496985db96d34d45711f3df9ee0e5e56fbe296147c905a8ed3977e2614212ebdd2826096be51aa58688c8e4cac51027976516f554d20807884be17360f9f36c866fbb5a4f42e2bbd69c7c3dcd7a55bec556388ee10f7697c377469dacc1991abc453b92da562aeb20fd1c2014dd6fdd05ed553dbe2cc130eba4e3a9ed6c64c4f1a9a0651061c705a10716b3159235562babff9d9d342dc93f626c295e57102778c4597c7b34620b17ae9bf564e74e2708aabf77a3461c1d125acbde29d0d107a754d36a410b7b41c3495ada321fa4aa70a41bdd2a25bb9a99368ec5d120a56aa0ea61056826f07050a8c544fbf1ee359d91943ed599f5fe58719f0f6f974483fdd6a5ed59110070c9d20e14bacad51e5c03046ebb213e84de28728283785805ae47c27bff04843a16e6ba30922b44d968fdc447d40fac8d50a9a93161885b3b62d6c280ed34229a9bf0250ec1de45f89df8d9e03a336faa039c697fe61db35e342e2ca3172c60e2a205466ff60c10921a7bdd553e3a5bcf5f1182c7a23ee04cfbaae21f60a7621562595e7867b05c91acb639df4b5b962db69d2c0baa837820f2ae934f35c87a9a0d31eaac3194bea40cdc88c4782ad43a3297634c3d109d52ae2563d8d47a8e12a92518fd5cfba9b10a8395add85ab076ab0aedc6f35db70d6926dbfc44fbf4beafe217806eafcb9b5b5058b647a5302f56db28772f9abdef4501be29b2f49ceb82492a5d41973523ce377ca54ff200194f0cbb87d0c92649d8f62b6f34a992254f1a4b58806356d2c2c54af140bb18ddb81f6cb1430f29918f874a93775a01445f23b76234d5ee534fb8531e9204f98615cbe8f3852237ace7378dc7f354333c5f17edd5e20315ea783d66825e1fec3d5f77de726b708e9d0e776c06d615c3d3af3b72b4f3c851b2a4ff5f0108f1f2abc42319a036e16e21a97ba3f24e183163f1d05bfc4789bb7a3f0bec622d0b1e82e229ff2e6f079afb0dca16f413f8e691713ab9e431f6b4825cc9b6fe3dcc417bf0ffe665ed18c4b0ce962633e95e747f7ec955911a57f674376938ae7a1c61fb2fff225d35c5d948b143415e7854f066bdc9bdceb544527251d989d336aeb9888d338ba08d0c8703441609165f6fc8fc5e0d5487e250e173ee3d0724a690cf87d61117625d2964ec4404f680fad4205a06160915cea932a3616e1238dcdc60438e7563f50e771563216a787afa72d722c939e2db7bfb729fc142fc176f052e2ad88a5cdcb27f27dff2053269c33bde1b182b0fce9aa5675c0c7eaa8532b427ab5bf8ca38e4b51adf00220d40cb034e72bedc70d976fa6db5541dbba5df76aeae1353a2742e6762301add9d0054e72c1471715af00a88e56f795b141dd6a5f3c23da2b1d7da7778dafdc1c105bd04adc733f7fe266f4310a42ab92e767a3f86c37f5390cd5999b72ebeb7fb981aa8ef85c02f66472c72171b367e903b7b7fcf25e4890f35a2c26c655c2f8e0bd442eb4ac56a80fb504e882c18e5469379d99c51d5081eba3c68ee68ec157b21ec502c8fe549e62ac36cac80199e241ad07739e336bd72a57647072b13bd427be0c96453c86cc20b3fa8f15a5a361ffe941908577ffc33819c6dbaaea48a89e2d04628634479d0fbaac0aeca407b83dcbc3a209cf3e53295d5e1dcda1847c952cb88e6bdfb80d93549d058ae960f9c30b82eca0d06224180c7c5623ff28b9eb9c9d386a6bf6cdd40d6b75bde16148097f5991b1bce1acbc9dd1652fe7c99b47f007ddc57ab9e191c5f38531b2a7bc86a5bdd7da5a47c750b6436ea492dee08463b86d213c2a677948a95ec0608b4e6da99b8e7b3f736714d203aaa5ebdb746857fe08d1f9f1c702ac41edb7f76917636ca0d5776e769f40793af6ab9800b864982c44195fdcf173e2ffc473faa0b007072c1d78bd9f477e8b3091b67f2bdfea323aea34997560cf009dc2e4134486672d1c1af7ac70e7f32c6bde272bd6df20229d4da539329f1c27de465bafdacc655b518e26f992aa049763cffacf5b3721549fc944f53c9893a1e51c1f3085e3b8ff9c453b9aa1fbf4e32823603270dd9bf2eaa897f2ad96f33c73c73110276d2815dc3f04785ad228ea573cb90a37f030be6ac3e703ae1b9cb2e1164f896fc745a1c9ed767fe8111b3de0753960ae15d6bfb3a8d808060f96ad475a2bf53d5d28e953e2421e3d8d31d31466fb201a158158f0a395321f7935ec43a1adf7c22fe095ad67dbe6351f3a377791258fe32c41c0b34be1ca7b935ec99f97f9dfcea61e275dfdd2cbe9d8b1db0ccd0dd0134f0b2b224ef58fd4e52113387e6e0dd53a349f98ed4167a59b5efee72136b742b14b0a7d97af4060ae9be2469f89a11b4324c7debf34577e7bc7efafecb6513a206b3ae2c7f8670d7e2828e3014ce6911e87504709310d412a5c4c7dd4f5d863820641e76df0f07123cda32dc31ba59354bb3af3b5309edb03a791b0a23e430f20313632240345677679566976ac2211107d6914951c72da0958e8d1502c69a6198c3a410b4e42a5f9561ac1e852c9231f0230f9607b12a0ea8cc50622eed956b5048cd0e322eb158233daf410b8f86dd84fac6910f333e661a715ad75123131e94a4ac9c600a8a94eb5e135a5527d91192cb03f6b578fb5dc2831037ca828dbe58161467414742eb05fe7c32346afc0a689c105df19cb8a37c7b24f8bdac8e3f1d8d2c4870917127aaa207b9e618f95cd091960deb837a239875faf606b11830ee53f3a095fec489d74490f1394aa6861fe827b424079097c013581bda760cda0fcfa087cbdeafa777907828271b9a0f6b8609f8b879a4bbf41b81568ba27c6facf975ff9c3c7bc4f0c5c3d43cc0a9a4bdc382e50845c28312b89e19f0627f5b4976e8194caee1233ffd790aa8b14e1c912123674b352380da103e9373ce794570769c9e902aab2dbf8e8870d788fa97ea0890baf644609b33e153280df414016f954a98551db8d028936caf8a50904a5bc5eafc06329ecf76df478967920249942ca760e3c817ed2b6caadace83736630d8619679f1162ba06e3e49cde91e5f27a9cf93124620e7ab480f5de01d35cdd808f652dff5f83bf028163c071f4e799e39f07316c60e72e2e5b1d7f3bd3625f0d3107e120bf44a831c58fef42173e07bc32bf1390fc9d3e32a092fc1d67491828ffa5055b5e68e374d72bb84ee3e00ab27f857eac675ea50f89ca7d27c6d820684bf7e0bfd32ad847934f44443794fdcfc296446c59d13f4311e9ae987315ebc4121d54dbe8d01c90f3f719d7d88b06e75bb1450f1a493f97ec12d2cea5c65f1eaa100a76e1ed84ad7e0916c300cd8435de61068fffdd932b811c078685249aeea5fa37b6d8aa05161b0a3700ad8349c2db912419a320ce28a6453beaacd7c7a72469bb8e70366aa126baf633ee13ca4593cc48a304d8f88090e0b327a30a31661149fe1ea8f5cdc2a2d6bbd380850629d16925b725fcd5aeb638cb2a74fd57701ba6d2d99d06bc3ce30d4bd23a7ce9caf2ef425a841a4bc084ac0dfdea5947435f914c7169a0f53b8b870659aba312771bfaebf044a06850abc14d6d793016007913c6ad1fedda64648f4df97044d00c0d28fd18a419a2f4aeed7096d09cd02294347dbbe23da5f173cabd16179e2f02a6216a948ca4822c02750ffa927d09979c38c09181c07d1285672e13ef41a59c940177920200c100b0f2feda501669a8e2abe41c917bb19a635d5eafa3f228addd4ea83cfe9c3c1d4769c33ea0bd88fe2212af0a6d656696e22220dc5ff8c0e431804e178d955e05254b2e3329e82911798a127b1f20de9547b883c6695508f2e66ad50622d5d53e351541ffeaf9f6b1fc0ce6bf522524f9aeb06a47a782e31f2bffe74e6dda5202eab9d3e772b54f20fe021194251cb626f7fcfb925ba26d966d8007975c5afb00e60a40e522c227fbc89b31c42a82aa83d26b388764f924589ee6278d8605c419a26f34d5c98f651b43b6a3b42013e74c13c8ab9d1ecd710e25ff71dd4e39e9e9724dbcb46940a7eadd1fddd49d9a29f824c7db49f59385ae740ffdec8d2b8c5c8ad69028dcc785690bc7fd2ecbd97b28cb88653813a4ebdcdb2f411caf5e1847c0df0d322b7ef06d31a8c0a2ed1db7ade3d6a4bf2e477a995f9fc3566b59e3d631c851bb6bdcd9a492ffce542bc3a03717d823c1d78bcafa1b3ee4458dde69f8be04c2908213bd06074623a066abf57b090305b6584f1a1a02a5f7e20fe31e3ecab0893669d7ace7d15ef05119665971a416ec9d6a884fa572b88b1824dca395c0f716034b3f82ad3ea0c42bc69ffe63671f2f99a4169bf396c92d2e8e2eb6d5ac642876e57f6c4eaed3c20b8f3d68ba40ac864dc7bd31649897c0e90f56866bf4e15f1a07fd84028210453a3d30e9391fdb4a6cf068993c7fa7914c2d13454d9d891096ece4829c22631a20dec9903808810a55f14fcff3ebb1db117ec9cae56c51088f67b85ceb8f9f55dd65f28df80f3d632748c3adac26a77cd078e31bf551ccff69889eaef585337ac3b0201616f306198663d79899c077dab117b4d359a17b66b4cc11bafb216a2acf10ce265b9c6a7c9bb37f631d9703a47c5075cfb46974bf1f2db7858fb8d789f9dfd0a8bf395faca6b19d2db70f2bf85b019cb731ebc4d16eae4027d40eefe1d3c99c648eaf5e1a3fd03c1ea07a57c919feca891fea1e84b97ceb3e0f6fcff87a2d73ebe339646405f873ca5080b65bc8c72eff07e1d20e3d17b1cced328a1edee4cbe6f1853568ac80a95fbd209bda47f0a69500fafd939fdc8ae551e8454be74f96c8e34f5020f022a94e65a88cfa82fca2843f34993d8c5de6deb8a473030a2aeae4b20ca012d6fa2c6d03ed406dce8a49caf7945183edec1a77c2cfa6a9300f38ff167aa78df6ab1a23b8a8dfedfb0d545eeb76230ecac9eb57add31435b4e6a9d686f2d19cf05ccc7c6f9a7ab3645c5be966a9f55bf8aa1e31376fdf3fad6a25570e88b439f403de006ebefa74efee7155091c8441fc7eecaeab83a00538aabb3b3cfe1de3a5ee28f5ff0c07e5a946ca32f712d45f8de2a9b4871af43b90f8b918a935ff013fa6339ddb223170152474f5c04a1a039b67d879393885699d5f15fbbfa9527dc2124de04afa683214eb88721befeba55f2e1d9e1ba7cfe2dc31efb76c859cb7f32d3eff25c467357abab782e611646b9cac1cf3919a950514c4f72b18a3dda94f800961aefd8e3e6c493017b9e4f4b155e169e07170a54b0ec7589cfe8cd296cb58a75a63358e692f917c9fdd896b3b91e53dcfdbe531da67b9578037ac469f98ba0479e17565bdfc5e7538234db8df5b6f73de0ab54b319dae5cbf6deae39ae41f3281d662d906ccc006143d34d6fa07cfb404849b010d147dc682ac2d189e0725d6272837236a818e931c4b19f8f7e8b2a3110da7b7b81b7eaea1113c6a6e6910f77ece852bf273fc0544cab57692a261c56125c1e4944f28e4ac39830add240a577257ed1cb7c471588553f64170905408c9f3986cd86f04cd769e4b3a8737948dee3de261d4fa8325723d1c59d90ea3a8e64cdcab053197c6cc0c9e930687987a753c061637a2f5990e9251798c32e9526948a423b8ebf345a56632870a8aaaef000157547fd1f6e6bd541781589b919a027425633b345a1fe87bda46e7a2f348569491618dc4e799967cb58278edb20850986e70db0077a9486963a06488964495fa4c01b21ff1358a2d46053f8fbb90d7995e333e6fac6c6283313cf7b8a9ef5c1de994e0577001fcff4001d36478bca4de459d45dbb675792d4a4cb6257d3cfcaa63c31aab8c989bbf1e81398f36ba5f43adb66e3896f1e5e81b1262f0afa824356f5dc3bd70edb8b42c28fade2c1fffee36e25653aa697bd2fd8a42b31cfb6ca30b542b49da1d7d927f7d273f8acaf2821e5c7f3362fb2ce6529bf9c32d5dfb14b560fe1c4b883e9094c5f43f0773c8c751e7dc7729f88afe8951c0b9d59c86f29de4a8cd6731ace29f1b1c245423109494cc7d5e3c8a3acd0289c1983c777b42bb44ed3d18fe3f234d6850f7ba7443542d72b73b4880308dbd114ce3a05b2e42b3e2f89c32005985e4af59beb33c5a4264cd68258b9fec0b3c3c6d0034de450f7ef81883c7acc190c42c7cc907a478b9f759ce2134ba8251e815bc90defd007f46590a0d7b426821a4cb732a9a5f8e2993f2b1846c23aec5f842a0e8201b82da232f4df360d0bd8a3baf2f4d245d87733b1a74295f4ef7dfc4ab2b7cebd6f11a2e4a443eb6085be0a6ba12ee0b2a79a6887b4c1bbf4c1b0f1da678e2ef84cf5cdeeabbf726d605780f1c684aa1bfac8ac81aeeaf1872bf527ba6134b8bae3edb31db54ddc7d7c370c8eb82cd2eed707ec436bacb391534f3b0a5ae41d80cb650c416e22aab057dcf0016cddaacfc4bdb386319e7dbf4a6756c9d4b77a266d559c0e0d6137bfc790191106acf738dda35e1b4f6988690e888dbd30fd437d3046a0c8779f8a1e1a82b3aba38f2d6188320dfa6be690574a62f09782144bccb4669ee12922f803505c654c05b31fce1a668b3872e314159eba40b599569fa249add8e978cac8d997024e838d82ce923630fb2848f28d76eb83fb149931280ae8928114861804fe6eb4f85fa31ecde394d74910e3a8f969969bcfb680ba723f431807a7fb9435c18e068ae5dcf8af2fb5bd7943e2055a304ef81a16e40f830c1921a355ec70a7186f2a8476862e03514235f8c88f6358b157e2fbd42c513f058ff12bf4071858552901824a813d280f8bcf64ba4434c7e33dd0f30ccdf4103cb9a9cc71a92e5f0ed69e2ba7f22f5668fd4d02897f99719626476ddf80be5d42984330ca9126110a775f64dfe3af5ca32a57ec13954bda41786bb8c4140fec96d5e380f87022915769fe244b39030334aa8725d7663f4f5280ac368001da6d95757df2afb56862907b22d39e63b34dcdc5a720f32fd014197865312dc6279ea28cc2f091f37f47e63840e8a9a786dd01fa5f67109474b7ea90cd52d41d02bb42edc23e0f3922b720f6728d76f66485d3fb4b93dec62b6423474ab990cab88cb194bd17ec9d33917f46709551e0e299901a15fc708ea49ec67117d350e037382081702b24a7486f4cd47f0a5dd113dbe01b68c522b84b938b42d65d5ef7fbfc7ea36320ba0a6703611b45c78c3f8678daf43a23336affc9fc32749a6d4d511ee3fa2c3f96816ecafb97d830f88d0e4f6aa5344c0430844436bd5c226cf409b70b7353c841fa192d5f88af3040563f3fb72116b39ac9bc97c53cd18e8002139ac67ad4792d7aaf13ed23e9aa1f56ab32371e8b41ad1ff18eeb0b978d2588e6952505038e4b89f96b9ce11571f4609dfc06da3797b834296c6adf25856c0316bf60cbfc376b1119c1ab5384d8889530ada61db2f53fc5382446febcf3c1e901404a10ea3d46b4a8fcb2e35194250290b5000592b51f3685c6c4a1ac4431b35b133edc9cfcd4bb607d11f2542b4eac3ceb4691375e47962e56e7ebda997541f85b3d8efe14f28a1f6abb912cb88c5b1830b38b31b867a8c21f69c64bf7d1f6bbbfd81a91d0e4f1a562bebc1d8037ca731e09a063ddccb85ef9d7cd433ed7aababa8c712e729f47850c7b3cec9f604f41962ace8538815c93cc8cecc0aeb9e03a6c23b5ed687fb94113afaf5c242e7b2bb5defc5b5d21b879929dfdeccfeb61fb1a40e0135587b0ebd23c5f296ae7ad338d4dfec6dcd6b8cc82f07f707ddec6d63c216fe3f4f9c9815fdef0877004dde1b9d632fc33d8171898cfaaae697e1b04358da60dff84192d0f6456f4d674a9fc1836ad30a9333947113d9af5af88fe598923a3269193528f0f1512834149ed9c39f51190bab27b697174c4bbb059e22aaeae7390a574a620555babe60330bfd3922cd134e8830374cb30abdd6a459c5c7e3960811a79943757d7ef83078eb057133256b614bcb6263fd7ef7d492ca7eea3b47a676e2bf53c80aefc83c7c3dce379cb44d9d5e624d4c59f6310004387e84513aaf391a0d2c320ff4071f2bbff74857b4c413cd2c9c878eb88c32b254284b6553bb3440309d93dd822b1cbd52c6524c7b88ce2f0905550b91c0d5053d43fde0f83f0b44758dc6d5284568b6fef22eb869beb3dfdd648b7704297d0d1d5c2e3b539288e8a5fde9f5476f28c933d89f9c171395bddf166c19b4a86743b2928db14e9247ae17bb8a4db28516afca9de047baab876ad03d210f518a01fb1f49ba9e8e3dd172b77c2d05c2093f0c35b8b7f004e2ba3294bcfe6bf24c3db186cdde2fd293fcb912d9ecfbabea0be580cf9734c38f416c5096c5e0a7bceb4f9a7dd0ec798aa769e09d502648b9de5747b1eb5113570945b3bbf99b82dd484e9209f81e8b19b91267b4e9b83d475915feebd9617f6777b70fb7f94415dadcd66ab28d419bdefb171c63865ae9c44c9b997cd763a1f6ce53c4c210241882af24202645b95271b35da1755107efb6a6eadddae2b20f87bba57b8eef08f0c87a5d8169a070f3fb007c9391ed5b2e228c49cd0a057409bf60d9559a566874b71c7939f605c316e69b3f1977aa9c016cc1d6422f5e44d7b1cb0f281ec538073c4d5898a258e858107b3ab2ccb95eefef67f70e60fc4c1abd373ed6fe27e73836ba8dffdef083d7d9fb63d0473ba337e8b1170a23e5bacfef57922b974bdb06f7404a938d74c0e771351ba2bdcd14e6dac9d71f1d2e22c5be2d35edd4d190787a18469bbbac2e832152a744b0f9f2fa340f3dd219ae6b9426d5c02c804697b6e00dcbfde70a0a2b578a4ada6730e6a8e09c1c2ebf0c43ee1e72cd3b40fd4debe3870296409398733edf6fab72d79bd7db90650e75cdd1655e6183578dc3688db1fd7a9e0a1ddf2df9700d893e1f1aca7d83e746b98a74af31f063bea89828d0ca78628af4457c35e8407acf08c333ae1cb2e5afaa6dea940897549100f3a181d41a0e3a100cd7a09ef4cd4001c63da97a67a9b2f95f948d1528999e2bc0c808688c3ebfdec7e9aade2f79b033a6c38c3a91172dd97b4bb0a9a5c8748ed82c0eeacb1a36bfa001ecf75e232676ca7ea28ccf9dfde82df9e84c5f6e302e77df40f0a12efc523b52a80d202080875f81f5d38b5a0894d2266888b8e4a887473a73c4e57b7bce22699b8c385bb5ff3ebeb7f2ee3666b9faee2ba3a18c2b741536f4805e5389a9504b280384888f424aaf4f05aad181bb0a6f557442aa693eeb3625f7ff5ec72deae73309b6f4ce17f0e5da192022bc34070fa0c991b82dbd34796ccc907a99f0ee44b112c0c2bdb1d2b4acffa135c00f5b0b990813f67f6c893d2fa6ff14f3cbe4809fdf467735523c65c860a1df27e1b5b5976a58204bb028fcf1e443d10863b214835ca4f966671c5cb643b33d012ee0eefabe2d2c71e98ab8f7a21c0d0688be94879ef66fe0b49a9504e442b2c8a33b00b357fc62fc681390c180564779984c786b2312ceaa99739c4323f65bd5c68d4f1807249e916ca2fc71109363439e9b307314cd9625db6d129129c0865e02d9d362f5f1e157bfea92fd975a4afdd5f13c43a35b47c72ddcdacd9ea7300949c8c9dbdae91dcf747fd3f48c798c3fabec67f370ec33ac5c0913904645f4ba8ef690507028ecfbc41b0d8652da38944f1ca003c37b0ed70a77303d7198b3d13aa860debcd1096551e111d6668e0ac35e2a42270d6759a4e7ae2c810a861dba7d36d9b10a560123e8eb1e8a800bd238ee84850dd8797c5bdde4f214420b9d36f8e8409de12a1d33eb0a514398eb8fbaaf5a73c126fdfca0c83f2fcc5b0f882ff68c5b3e18a96113b6c60f42482e3528918b44dafb9cddc6f92c79b941fb95e95a38945931acefc57131ca328d9b84f15ff03fe8a29f00b67d0a0b51cf253defad922b5307983e400db08f4ed5052f43713d2709c6be7d7425c48a6f4c65a8ff8d3e1101316b6cfad916f9c1adc2f558037baf4024ee1008221b01ea906e28722377b2d705e3440cebeeaa6d275f6b563f4e6231414d0c60ec4446118bf8f63a4feb730080f38bfece49a1c96fd1d54e6798f92c03839b7fd607e203168ae7bb451e5670d2f106ecb4f1b091a33a9420227e73207b49635c97ec5deefcab94af7fdc605227215ed06249217ebfa62822b91a08ef9f7901ec6f292d3e14770b9e2eb7e6dc0a1e9b7b50ca72dc53251b9dad2f191cb3366cf3b045d92c40a5a0e90764ea955d765d8de2597e184a85d0d2270f9989765f4ebd81e583fcac26b0d244802b960464b4f14333c48c5574c9c74dc02c145dbe986177d26c01a5bfab8a1db6df9a9c7990f249b5fc43ffc220869af7a84ab6bf54b765cbae491a4eb0bc6330a4ea30267d0b536e53b34606ca7803a440cecf1dba1114dcb8bbf0fd0a3982cb3f95abc28d14e3b2080ae33c3749be7c475c575a1cbb5de833b47d52efa11689babe61d2d40376d4c9e58ad21b4db953bd0af167cc240f70ec5b2c6c7abb2e9db98222669f4f365f8356844c0d9b7625f770fc37f7ea4dcdc34572e6f8b1917b43297c19cc1aa5dc0dcf34ab9ee8772ed5dd1586ee70aab6f96cbb857ed6fe454bb29b9121db39bb80e3d5f5416ba47f67935317d7efe2a064de233d8dca32d0244f243e685ccfdf1ee2ca0c9fc59a4b5b0dd823fc395e6a108627cfef1983550bb7a8a6e01db6f35c2eb1f8e994607bf36e9afb9e154eb9e8cee411ab18e8f84237c13e65fee8e2876be08a8ecea47d9fba52367d8dc60db22beae74e7a05fb38eb4543ee55717aa9b55871c2c7b743b33d1ace746e4b8df93c93f82d1f3aa2300b6cdbbd160652a40350ab58856c6c89f17560e470718af6056665b81648e410768b72a5a6fd2a87056fd684afbaada1b2775b0c8fc06988e0235258ce75cddd2217b988f56766ea661f136449f6d0c937082f955e5229d73d4e30861370b4b3354d6b2f62bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
