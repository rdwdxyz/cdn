<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f6c48f5e16aa2393c8ba522f4cc2725c6a3a0b026c8667ea5f36874293749e426a92d45bb45b98970488ecf856b4be98361457ac61dec3aa48b105dc45c3cdcd3f379cb4e5ba86321e2566131020da8c042a3e30100cfb13c0c64171982d2719f25481f0c0f7c2656f02835259f92ce3071a76be036d7aab330da89aebc28a61099c5e5b67dcae44c83b3d910dca96a1c114322d3fdd9fab41eeea7d1bd4ff2431c41e7e5c78735b34e5bf00c107b40e4ffbb1e077e521f61ca963eab42cbf9b1bd2504937dbbc0bf03adb7439760f25468d040ad3ab9d6a152e519a6392cfe3b05a788219a085dc1b552dab7b627f78e3004d02dbb8ad252af1b287e4ae76176c97718e97223ec4ee16921a527578f8d3ddc31f919261db51858bed47d602c7e1c864a4e237b01039e100c52421dd8cbc38fda67898bb18fab31eb1843d0a1780e9fc5849bed2c170dbf37c73b8001f99f076c1aaa18820f0bea53cc4135cde599dd15dd0b9535319c474296383369514275d1c2f31a5ae7b52772d106422da775ac339daa1e96d70f380d4ab99277156bbc1a4ca0019a7d923819818e5c05ad8548a6f9135b2692e4251c1b3383ac1107ba5d4cb312d290660698301995cb2ee78e822ae4512b5a1f24d05f8dbce285b345f7fa933d3bb7a97fde49694cd2f32184e207a6a0a22035a9ce0f5e67f02f3acd5cb51a5fe1d2108d80258ab5c018c6fb04ad43cbf14d02ee045af77430a730aa75631c0cb0a191beb8778f92064842281ce387e083443581a2dab0754ec2ac8e016fa5fc6114f0665e7ab8a3ecde917a99c703368c98e3f3adc5ee34ba1a9e9c743b6446cfa2ef9229af1c1eb2c9fcc1a708cc0e314b04bb74cc1974da75c5cb3f5dedda850f61ad9d9aa6e362c885c229498a8d4bb7b672bb75d99413be9c3d3af7318e51adc9e5745072a7250b77e0b9e07fbe60238f8e034bed67874d7a44f732f39d7158e2d7c2e4531cb545d95b96c9728bcafc99b8c884736fc65f741ed6b016bcc7001b96f81c0e93582442f56ad7a0cd978fbd4291d6afb111da444e6ac0e98ce7cfabfb0ab7d2b60d9ff6b1bbad1ac9aad435b248ea574cfe95e530b6e5186d41fca7fc73909462006da179b983a802982158d51c27e842a77e927616639a5216ba8fb82d9cefb2a8c07e0feb0c1423a99e122700fee4af30cc80f8b4d4181e5f627c6c40c523fe4a3c5517531f272543962e177cd79a78175d2a57c2b09adc661165d83526a4a3bad834095f1dd155d3feb296f11d4f592b74fd8273009d25b9f900d9216843975f7ba097e5b8acc4903d70c1f5c277b2c8f9ea6f25d988bbc1a6c7422ac150488050a75ab5a9a22dbc8205cfe4a885f24d3e8b628aa9eb4ad1f9fade5c2d6f7cbda429abf49e3d0854100dcba7d5573a5e217bccf88b0f1facbb07c1d976eb235d6eec4fae00c01264ded9c7b71bcc26c78f9785a05b0b49ca8e73cd813213a545663c8be3a16979f8bacfbe62dce90c8a97daefe151d905a28ead1dc6a5f0f95c83321bc17f33b08a644ea89c1080d2e9939028b8dbca253bd5c6f1b0860293f71f4ec1837c15894f051145ea9b1fb4d612cb8f8408b163864f8edb75473fd6dcf16fefd03113e0401a72fc4d3f71303909f895837ee7aea29cfa114d88f6b2bcfda259ee322df31cb38e376982d16ab80f6fdd6b7de2d582e44f8217128266f8085effe06748ae90cd05f1c9e8571fef0ebdd673b9383a2ee61851031f53e16388a1c319fcdfc5a3117001fb4fea29f187bc99d04ee7bffa1ee94ff68fdb56e329708b0da77b135323427c076768da83e7137ab5ae6204633954803463ae907d83ae7160c4da5c041f540c1d414bec750032197343a3dfee7c74d2c0282429f8c88401db8440b5a9da02976417e3f2acfae8504ea75a0070d96899d803583f0f15c58c7d1598221ed01678f3b553bb62978f81be73b39aeb5f15dd86fc9b8458c006d35b48a0af1fc4fc55f94d9e90e5638c653288507764be216caf71bb6b348581bc644071911e995d20e075da8347205019d2b222fe72910b0e79accce8ed082d76e42c1b869fdac77561f6d151cc779cf765aa068b274e011a3d23342f1d91807a2bf8d1681238aef9d29c1c1df5ba05620089e1bcb69bdec6930e90c7a66ee7bb406c3d4d19f45294874eaad5662acc667b08f699e924babc8664d2a173ec719826f6aa1bbd740513126fa1d43c95ecca300283475eb0091c1f41a4535ab74f98045aa38cdfd27dd2ce6831d2ae7cc7c2e259e6a713a3d893a546a15e7fffca46710078e456497ea2f8ebe09cb1e987eabbff18e59f13a5a684f2a837b8bc90b905d1e8263b52f9cd9c779c9f6441a017596a492cb40e9136073330e92117263c3b563d5d3eb3bee22784c5ce07e31e9d12bfba7d5d3b15789dcfe711680c77cda6145a86ef6ef12bddce2790b2ec90be37fcf8e2068ab8251331c8908c85d26a5b58d24c470d964b1eb2e46827eaee68b323c56c349dde9a828b34254778235f00ebb7c469eafb7c525c2b7c1f5819c71f7afaa247d26a39c7959bff2c7ea3bbc8a4bebaee292c731207bab5bc149619fa6280ea75f4116f000a6cf984b553f417f4c21f991b137c9ac67e02e70355454efe5c8c808aac4bc776cadbb6df6ee5ee09a617f03488efadbedca8aac0a23c9511f22e79bc5e839a80a075a8a9957c030964dd51d9a479c78c55fcda20e050e9e643363e8099ab653b377e1d38fa146d09879d4cba657d3222ff97405cebc99f2bbdc6771d0d851e824a8f91a42bfb9bd524051637e9269b2856a133e8d3d96bbd04200ff22aac74a966580c7edff3dff3f6c054f2d5c91594c1a1fed0cd3447271f067f04c94114117b43a1a0db8f62265baa9e94b88845fdd23081851a5907a477194cb3167a77729a5c029b97b04e84e8ba905bbe41540911172c4fa028ab236f51524e7f6531f7b858328f16800178e485deeec1a06e6139d87718606fc4c65d926b648a8eb88d477f175add3d5a6f81736955f44f2106a5deae0d66c597d7d64a1ffeb7dfe15537070d604e7c16e770d7010679e801c63407d8c619ab5b795e164301176648776aeeb6f2cfa7afd1af0c4350c99cae912b92dff82a68e569a92643344c0c6ed3ee823ffaf9719db04db9b8dfb9cb550e1b8f277e55b1b8f90edeb4f5587eae59ca4ce0eded50f8618c48e48514f519aa8f297eb4b53bb78803c845a43434bd22984d0b69851f328562d50af90e1e481ca36aca33ee05ecfc453654b80aa2f6f6fecdf95a6ebeb61fd1c90dd64b36a1558ff4d0b3459a71fa146814a699f9c43c0a51ad29fbeede87b93fdfac89250e92e80e98fa5e249454deb4751c163bdd99b08d052c684d9f358bafdcd2ed2bfa171d6646bd6dd90de045e737ec9c0a97599610c5d03f0022174e2aaf325b37cc8780ac249476fb86f4ad9ff3d86db62aed2208f980e60531fa029d55b62239069547f3d740013b3d7a3146fa87164360dae6d9114647db539fa6084fd6a74778543864f74d28d9ce1c8e98263b88fad499777988cc4fb75f885caa14346a26beceee34cdb771c681375d2ace118352431aee216c5896b63dea413ff5d7ef352945e71a2e65584f7a0501dc787fa4f937c25b1963cf7985c8edceefee7a9e66186d583b11d1757b8e996593d6b4004b603f9488a03afd7fab0e5d54015a6498ed2b9d34de3aed1bb35b810ceb97853626d3255226e1db3ad44fa87b767ed563eb4dfd668b0459423b1a2ddd7a63c0e52093fc70c116460549d372cd63a2b3eaa35ba04f0ff458c16ac924e120fa10e6bb0a6b1fc5d50696c3477b3ef655035037c49176413be7f033a252d354b50453f114f71fa83af2d8a5bb2fa740839fd8c5690570f250d65ea7695c4380b86ae3d3e87fbafcdec4f1940c6daa8dbfcd392f8525982f80c95c100f604d3597a73a16febe6c76bbc8e5741d749db86524a8d3c5dc2033cbbf4b117012f9ccf641f724ee472e2cac7950677148193bad37173d644b5a285b4640140f2f2ca18b0a0fdc529e8e8740f527f1ffba5738135acb31a0d93b3ed378843997298d1c825984516c06c3c68552b9076e18d4135b5963940acfbcb369116a093ea2a80a161be598bb8e6e2da15b7516dca6fe04d70febadf404af688073e1951de30f601f002fe9ca4bb21fce9f1ee764cc76180563545c941102f6eac0e24d6b588957271c7df2c8e83818c00ea41b640d2172c1d94fa119c53ee678020a6596e519075de78528cc0d77731fe53b6f1e58a102aff2b1b6c6a59d24f3d0609b9b250448e333b1f71447e4ee87613865f9e7d143b2cafc15386cf0da0c5864708df80c24e759b5eead369636433ddf89ff971f87bf0afec2d8b7067eb8aaafda2d1d5d0afafb60d54d4449eff746b3a1185c545e64eb7e2e01c643255f0422bf3f8de5b4c9716230386ce7d18724ab8dd26dd779560353faba605a1146e6c2e1f705d80cab6a59993b3eaa34f837a9f843e81f35c52f8d7c815f356fc9e88b6e89dc7cd453f6ef120b8f7174bd309d149b07bd8509d0dbddb986a5e16643f5987ca85646c0d7272d556e3b9e3aaab836273f6d24eec5d849e9d864027078bd5f512c486e0df27d259541252cec5873cb551ba1313f8993448c9d2af61758e1e3fac242fb0fddcc3c837ead3f09054aa80aae87ada32359b12945d5b5dbc0e222881fe2f991421beeb8507d83f10ec72984d9e5641f708a779977b0d14fa3ccf7a51256c747f3ca7dfe0f50d8ba9b7f3cae90126938b3586440f4dee6fb433e7a37e0978519cfbdccbc2643f5606eacc128844f802e251687dd5bec5eee93b9e3042e53a96075bcde6bea8f4d0770efe7723b04be3315043e9ffb3ae092d83e783993d21a90b12a9e792a550589ce700bf0340dfd486a86dce220e72cb487927baadcf868b48dfe91136237de892dbeec345f5fb12acf9ba70c22cd1f21d854919bb9f88bb45d387350ffc88b2c9a86cfd55433fc306a0c11bd1a67c0e04fe27bf159536d9762e4e8f999c605e56de1bfa61cfc7ba749a66f46d1f3655811d0b1466d3706a078cec45508289250ff2e9d45473ec8505c2315217d6abaf9faf73f226c89254fddd0b58b64307d725219d2fd6e38fdd0a642c86adebadba0c61634fec4ecb463ad6ffc23bbfa05d99aa4a9d8944362191b792fc8cb825d81678d393d5151cc4b79e3bc3b9e93227d54832c0f1ea4229ef9d37eb9cc2e138b5c12d725caf4e5d3e669135d3e76db8741826fa85c488228d715cdd52c0d0345d46ca418caac433f122843cf548ad277c298bca476503d3c49f28e357903d99651773c1fafa913939005ff8b17294d8929cd471b61fc484ce343b6fcba97d7b5321c6c79c32d829c85d2c86df52b9ef053da4f955c774b29b78c7825f137c889a5113e1210feceabcb79409d695c19cf33b57806f5cdec72fd9eeb0509b3811af683dbf1774266a0c1d16f416312b6e0ed8a3cfecc145a39b2f9b5e5e049cb7b7c6b22263511e773ae2a931a6c9bdb5b494cdd6fe768617d190f791b7c4a14af6deea4bbdfde4b0e2631bc22a369aef19993fb49445723a1aca57af0b1400f9a82440e4ec96a8a2f73275dc0a71b8415cfc72b170b9cc57ebccb8ae87431954069e68489a1fc37a4fb6081b5de7123c231930c4adb006f366a81de060d56a97e173d51a37b6e9d0c529dee9c0cb0ce083f5b817c5a2077f402efed9bdcfb9c7e73e4a3adc153c07ebec9e08bf51563f6b602bd8381d27e7e121c233c2248e16e304ff9028fc846003f5ffa10feab8aef2946f8001d7028b433135f962be813a3db07f4bd6f67b6ca8b5e4f399dc889b8d50b279688548498e367964c16340d30262613f2dbf57e5ffa8b81a7761ae843b0a6c3f0c10577667ed2fa04396c31d3311b6cb4535d761a25eab7dd72ea4d0eac6c6f9cbd2b1c40ae30e3f1603509761ed5492005ef272dc44b5ff2ea117e569d2356658514ae2c1972ec1d2483e6366fd7f4a572a75559527bea0a00862833559f2a102971a01e2184d54e5d4e9c648c120c63b26695fecf6030a7f369709ded61b7a28cd67a21d6b7b094b7c63fcbfd38971007c47a2ef8b837beeeb81699cdac6447543f37939bbaf82031fc3d5a7d6985f9c70942faafdb6fba8fc2586768d14ca89b1a098de1bb49d403f6c319201b801f14eeef843b052da5675d0d0a137fb873ff5a7b5760235855d0bbcf424ba5ff73207e64bfc628dcef83d16bad2cc78689cc898a06c44b6aab208abfdc5c5bd42797f7a315f27b7cb2eb53bc30f4bd5e6a55d57b095687180678b3f6add3f7341d9bf1909886a0c080e3f999012ed8e2a89866f4a5436f0436c628a8353e02e2b14ea261888c228c6a005b5af1337f688224daffa637f5b91d8c583d08068d888c907df11b447dc5afd8ee7dc12540d3fa7c1587fac04a37749daae21175dcd906b71f037d634e5df0a80d21f594984ef3f83e0e10d5630abb6fd78ebe9fafff295c0b39898609d71b365b3f57aa374aa216f8ce594975204fd8c54b613a8db2817e47cf6fa4e6d1c6315ac21544f8e7c21a9667342a9f5d36fadb6225dc5d593f07dc729f4ea10341ae713a52b33b095494ee03f404e57036c91de8dbe1eb7b6e6394395c9f8764c8e7d01b8ac1df1540721e81ca87ccf2d91f4f4e01c03c74ea43664b04310a9d736bb76c8102965b22d85b691c06c51e2f0f0ff2931efadb316da5da91a31ce0c7d7f48d58ff3466ce99bdb8c07d5e9cbe802b4e289c5f6c8b91de33b25bca9f42e974cefb010f907bd53dd1922ac12f36809d03778057a8ef82747478e366e2f1c1fc794c6973f699cf84c2e6c189841d44637b73a5ac806d3d49d55625db4f2cd0c0ed2999b0c812a4fdd52ba1463bb15d29357234a5b1a966b0d9874b5b3958704c901617fb0478a80e24f3b844c24bd7831ca70dac53eb060b8399afc0c5f309dda12742cffed41b9978300ef592cf18a42e914df2bd988ca9101b270965a0b0fd681c539c8287237121216109202bc352daefd1604f3749a15ffb7aa88a77da67a3ed35b577c77f53f73d9b40e8348b122a22e446c5deaefb9dfbea18c8bcd981a10d6ae636ecc31920e07468af539900056a0996543a25463ec19306960ee4295a8e8c28e32bfa2c4384c51cbff1220fc1dcab7b1e65ed1bdff601bb8e222b683810958e1e09f08810cb8164ff206e156b2a741e475f2bfaa9f737e8a2ba978d28aeb487f12355dc12097e2640c3385b15c70bd30a3899d41cc5ebb0e8f0054f4b5ce7f4633ce547d65adab167204dc698938993d4b4fd0c59af7dbae5ba8fe8b51c5568d6d97fe6720a28d4401e5cfcaf8b91fe44e9177a0e642428046dac8dbcdb40cf86f95cfe13a0ab337ff9741c5dadda1657c7e7326b918d3e2c13c084b024abbea1c9b6ffc6cf1d6555989c0a2dbe7857292a4f6ea7f5c2201d1a39bab454d4b835209a255221857f7b88fa0433ed0da32eeda347523432ccdf6042e21e58d704d3fa22829c91417eaea134269c8b8897cd6038cdee8033272ad500e51263a616881ffd74586cfeeef2902b7192b110c99d26b7e6c9c3a14bf09d89b484252148c5b43c1dd06e2aed86f10bfea6e9ab3d0afc3cbb837cdc1297f3a2643be5182b47fb1f1c4f606b4bfaad24e7cc071beb5554b4a1395a5789ac79fd7c504bdefc909a9905204383d096b4881369a4a09e093d6ab5060225ca9381d3b28c266605dbf2a471dc7010eb5c71c154cfb54c5104562476dcc852a62a5aef70f5f93c0d540d0692f313a95948a782f6bfb5407845c0425c8ae1eb98fddd9ea4866440bac0baea6e7ddeda3aee9888b60afab3abde2239d78b2757da404aeb2f8717699dd897cafaa88165c0c19168bbc14f1a356749dd3a7930623b21cd2b0ec7b6635bb53c0ee6333c2e89f6ba85487d5a4710ed2b1d052f0ed4da61dfa7823be01dd80e74d3e575c7b60c015984484ac52a0c3699211479dfe9c9ff0ee9d0bab27372e9be2f01e726efe5fdf2405545ab3c5e44c3c68fe2762ebb94df2805581c7375335fdcb69140ee8935f8967e7eb23c4255abf08b376ffde1557f5904ba3c19978cc103e524585a9f948c3220dd6ee66143c200489d6c9577e78d4016518c4025baa1ab79c050a75ebd10107c85e9f2f286eebc1602886d6c8e9377e3c9f006d0ec069aced26149e2c22f3745cfeef3f2deb89e9c027af86380246c8b576ff9ab747f66d09e32c573f9931bc2a5dba063744460e5e05ac366f8b8618ab23465b674d4ea5a2e9850ccf9c1540cca4840928b6368d0bb266e1284c867049884f5c070fac10f930ad6b851ecbf22c5c51c33bc703acf2ece3a7defde9476ecaee7c8e96445644d6accf8cd103958953b3ec9410057ecb8a820b2620cb6e9d8d517df9911c32985a02cb039978c041e3d6c04b67a94fe5f51ca728ab6257d8b3b6437a5c441356bdb5f5b5409aaeccf65006a42d1fcbf1fff9747b35f552f3e7e8c17aa45d233de1aacdfaf1caa7b12b1f6f033e14dadedbf71b225515c32f1ca9acc417c97387a0506a0c0d86d9f61de6ecff63435497379f3c7deb5b777df9bc8fb7d0dedd4522638e0dc7f512792ad2221ff3c28ba627aaf240db484be0d391dd5413c937d64b42645465714bebdcd78e90781c7c3dc3a22ec120bd01fb8746d0cc50c4e6b898ee9997c04b579b35602e46d2ff98c3c33dcdc8c73ec5fbda9632a845bd434d3654c3000f6dab4664fe6bf1cdf88353d2a799e6d3fef29ac9ad201a4d2c98a6dd1913009a699b169690a10b5a7eeb726d1308790c8f60709a64752b46c808d478f732e5053bf5d0bcc686e60695f391aab09cb6273e2a5399a4a39bac19f97f0565f8694fdb7bb81bbb296e6d2901d72e3841ce64b8dd6028df044765a3345cb9b3321bbea564b6212e5488d4b29a26fd942085f2285f1bc5d8cada31a9ab5b567a28cd7c503b2a3dc581ce7e1c09c101f72c31004ac7d62032d3581d801d988edc1cb434687f5167fc6a51ea949fd3d77d6d2781e262172b9074b2ca24aac691d4d1c648f2bb959573c944f7cb4c40286626d2fa2922c633d98f9c32d53f4d034f83f6be840e1cfd88ab2c531e69118dc51b7a14a4b148f42b923f27e6fc988370e0e47adb263a3057bb26da74e9048d0535e0c22294473dba54dbbb848b6ca9f202785669a1d128a83361d45b57e5c345208661cc2e81e5d777aad8b1420abcbcd17745d41aa8ca71a42976ee7bd331797c55dd0169033b04f428319c7e0d22fe136f86c045e3ca3c33b0e0176e5037fca35d4f94dd3d1d570903d01258627c9e7f63584b1ecba3d3855660732c7f9733f498f09a015fa3bed72c870ccacc4882195b8b7ef86d496d7a429461c0a7749ec96c482129476fad19cef08fe1cb5b374438a57a1465db0fcc7bb8d0819f6d0519b3ed64900ed7173e8a85b050a9d3acc5a870823dc66956c2334bbc13eb211260315fb7faf5df228350627442202e91adcef95765412c16ae630a089bf9c51dff81eb57dc439ff4c00389bf87028aeeb38bd60434949def78b1e459c7daa8129033939f4c6f39bb5068d545cf2aef9d0f5be9411e68ebeebf5a6d071c28a7685077febbddabc8e864b630cb392aa130a4bf9671ce88ab645288190d3dca86bdd657e3e1b8e7a55cc29ea7fe0e1e7a10a2f35a23dea5f66cb9bf05c9de95e29252398565ab41b1a8e9827972ff1534fdf1522bf769715561f150e0746039acd59073834a64414f23311c5045a8b866181fbb497fd83f120088879f67797072cc855deb24d1598528bf18f281a4f3ec745d0aeafe526ddbd339dd0ef2863824ed2d82f1b53eeaf291e6becc11fbefcbf780d43fdade9dd0fbe898c0ec8a4fef8fa750db4c02729b73bf22cad31c74d98cef741256ef96a0913fa6415fc7ff97615075185bc638f5970b51f2a77a8d4e8d383224aaaa3476f3c22bbe231e38f6df2d9f6fb42d94158aee866ef5e457ae4524189707c8d7639a6f0e77aa725500aa0efc76c4a4eecfe735f31bcb6a0f703c1bdfaba0bb349771237147f590578b560b7b0c236e8d0ddcaed66a9665831aca189fa63362910bf8f7762c04fbdf4cb87afe9869e58081baae42deb7b2917fcc406cce69f350f8092de72981387d99747f45dc8cb2b76c855ae0aaef8082488f5a71bddcba750b5c720cec049b5ef8968c6c39b633b03e5ff38d63d71adb39777bde22fb9be69f210a2955a7d1435f0bdaad27eebef33f1972c9cd23fe7b20c08e0fff52b26b72932cebf4f92c34873e6bb6015f180fe57f329702558bf7e450826956c81f2e8c2d3ee4bb7f9c0ef18826040789a7c3a6658ff37994e2e3eecae0c3eb47d22c4082bea4cc06f896f5e51086b50c6d98ba32f67e144a5c596fad0fa994c4a9cbce88920c9ef61ea21fa45c08879a0cd5f0cab9ce8e487616bf7b215db4b1828ade35607cd130300d72ae63503eb7b1c9af5010a96714e46314d1166f8b403e581e1fffdbb9c284b9006622a437946e75a6f7ee3933c6973f3d05ff243f8d69046b839388922bc8d47be9e305a181d5ed6dc061bc1582002690cb3c3cab51ae4e46a3d799823509dc4cb2f20bab8a01d367325dcaa72565568425ce9c2603c44063f36c469041588b90b29228a1cd725b37b9b207ca15385dc9c0cd8004dad3cc017894dd74987e924e67232a69316531cd2dead3fb0c7857eb4136296da1aaa1c1d624453d476ef554cad0f77b895477dfd7d03ad068bfa02c82bf3fbf1d675a41cccff268ddd20f5fe5252a5d316540e14218c4d5d9c3bb87c8e34b30d510302b56b84df4259a114523b477e99222386ceb2ddbdc5ff3c3de058f46fc1f4523ff22c999d50a60d1d5a51672a4baa6a9d645072f5d38fa85b1e9dfa21299aaf12433a1a0ee6b182376456fa8e8a39d2ef38ab06fe63d19cbde7b862f80103c6a62f47a02f7c8a30defabcbaa54ba848f92040fd57365eac5ed5222c60e428b2cb832f24df56ea73fca83f00ef50eed2d307bf5b1c24869ea821979dceba54fed2fe15033487cebae333502baaecee92f36107b6498203604a9aeb75108d1a9d3139a2a18ece9b8bc4b416cb92c68c611a4c5acaa8edbff17f5aca9276ce03eaa9afafd289f76cd63442f7ae76688750543becefd7ffbc2cd8f09ed79747674e500289f32c5c55641c9e2a2e102549b813dcbb919a6899a1b20c352fef31365b20df5882085c5df3639016e0202a33de5bb95c0b3c0ac8331e9a869976d7977c8181f5ba22e5ca60c2112ea28490935d9d3d3820823f46886ed8e4c8607ccda87fcb187497e18ba5c3a52533ea5d6d9c2ec64b5cf86715422884b33e11ecf018f493dad042486ffdd1465f04ab415db7cdb292067633c30d25e238f99d4beded0bf82523b87e66b68d4a11492fc6aa8e8d1d3a9f0a2b0a34dc0ce3360b8881f5c1eff878b89072405abf870db9eabc96670a765af3b639ae3fb277a9d2ad89c4a74b8b76a4af940761eb8fd877a9fd1cce1e54d60a8d3a6e19b02c5f8ea0bead4bfba09227fa3529f7feef6fa05ed0c5e21e49c54569287e3c998745bfa1cabb4af1fa692259c35535894315e2b97dbd8ca55f20f5a1b0a3e41341dae7fbcad26ddb59e30cac732946d0d0e505d7f667a8edd52b7cb843ae382c976cdf86ec1ee79d6636153da445df6dcd88e65f8961f131ba62489ffed9668d741c455a01d126544a322d4daa0e9706ef9bcf92135087487c5a5d717c7c0aa2cdd15f3fb27c94014300a713972a8cd9f3a930f4a7662526fc27533142e9b15532c00abb5d8b73b1d1d9471f3b3193439b8b71bc7c1d9a8cb4d2dd8df18bd2493e3e475c861d3ec9c947dbfeae161c29b68aea6d3f81a764ab006cf0acf8fceb4c4e183341f985135d73bcb05301af324d647625293f090d82d2fcbd678c13222e69155cf60cfed0f038ed692a6f2ec6cc13ddd9d9e9a5a4d40b0f21de0bd4956b6d55d176f717469e661257381f9e22294a2e657f1eddf2912df3e90c91306c69bae8a533dc95fddd8efcda8d9c4b1fe1b31e7b6b4600f3843223142e36ea710c6e9d28e10166b9f7c279ce88224e5308b4fc155e7c7a10e90debe335e6648a0ca42c010d1882e00b080867f9924c69c765a6fc448e9a0031503b4c4c8ee9237d92e0401ba26c856d992d47bd63b745509e343db25d46ec03c75df4160ef52df206cca338fb99a8d2d1382c2b75dfa90a4405a65e16ff10d127bc745af07d17814325348dcd04daf23f7bafcfcd2aa9bf26d3efa024a9df2b3bdfddef0e8cec443b6fc98152cb0ba1d6307aa1aa6dbd495b571ad294055bfa7d9909af344505fa61d016d7b065b6f3ceba24585a1261dffa4910bc506029199ff287163ce38f2d6352cc67fe5e4fdebbe0d67b207ac8107c20c48f6ba0f64bb913c39ca67fc84b823459b10db5d55df8408c5529256ec6d44220e77a90481fb61dcdedcbc12ea1ac7c958b4d72c2a40525c0f0dac099c32367fe833b7df98e6172f354fb0544a3dad8f4b8cb0e679dae3a2587e7c2a0a96a710951b6365a640e9fb4a6a12e83b011baab3c563eed7377200291d6a41c9e8f736c80ace21b7b3c35f7373991dc561f6b3dc393082aa66717ae6110cab0d160bcc5ad27e5ce1392cad5058098afcf1676ae315bffceaed55035a7ef12b6c7473959a0ff6e23c7acef062fb0cb4eb01b31abc8b14676143c089c31430f22460ee502a28e96f57bae87c1e928b7b6a98c3af51629e70a121d136a1fba47d3e4ab43e893fbfcfaadc1283083ca71b67a144bd7e20e37a937d0b5cc435b7c06d5d944f98693e0a64cb0967b11243e735caf3b673e5c7a5af6c482a9252d4a3008c206938817d617820b9fdbb44ad4b489b3ddc1ee3eb5fbdcea3d4d70c5cef7c0992b51d76c153499c9dc4e55bcd65347aa5171af38fb908851048ea039151609e22053a86c799f1ea174127299188223a51f57a76de71c201cee9db9deaaa19fd9c876fc4a6101491d4fd46ae30a2ed32c3ecd387f639aab59ff372cc3a74c30585699c49f5a725ef618aeb5653abe3595501265a34a23463355733a5a583e0cfc25ae2faf7980d49731117f2b153dd06b508a28973e8ddd7a2fbdf5c39801b1207f9f7e47e347c39dd62574af5a2b67545bf58a1997c6229fca7470585908ca0a313030fcd7ca2019a65080803103b781930c879e9b3d8cb9034d4a7928e19bcd45ac544f78e3eafb65121bc3d60efb205335297b498c4ad054b716b8b18345b8d3f6958874f7bb17142210085308ce1bb67f1a5d170524479fc16d56bc34adf95d2d976fcf45e9e1ef3bbf4fdb92897a5c7f65995237225aab5d6c3c1a2308a797388090565fc4cc87fdfc0b90d82685716a2a4413af73068e383ac54fb4f384b374e9832e7a4424df94abb685c72dc16a02bbf8b6be8b77b93d1b282936942f873b8a3d00b3591f9e2f50c29efe81dbd90efd8efbb727682959f6b59b63feb7fd319dc6c3c657fe585c5f09f80dccb4c614a1848cd8e8798d5e97120e948d72eab6e6925492c1e39ef1f3560213afeba9ac49e7724ee288dc5f3869bfdf7f0db05ece7a5d883407850423c18cd5e0f5c9f7d8b89467852125b7df44bfda2e2c17a8bcad019dd5fbcd62020e55e3a6c8726cd8c8f5f47c045705c701f1ad516e2c410fa2c5caba28c4f8586c179ec9fa0eaefe5c1de31e8c474422551111acb0a6226a485173c9a99a1c8f3e7d1bf40a71ef6c3b4d39694cc357aa0417bb9fa81e52de5562ad977ea7a40e415384ab2125c14c8ba6260dc2ea6011c6bd0aa84e108d1127376d42ed32d666aa5a7f611a90fabe45bd76f6aa6fcb9b41c75973dd8fb88a8f5715c44eb30236df197ddfa6ee2b2293475a5e94ff5f32e362db065c157ea31bcf78f5ec2c487a337613287bc2cbb18d89a7fdf0debf83894d498a128006b54523789a160934193309c80539e0c8871cb870f28e84be44ebea635934c1ea7af526b7036d0eddfbf59334bf15782def15d93786be579346da9da7d9b476c523e276fe8e02ef059ab0da79221415b8fdb20353c10ae7c96211e15d499a9c5abf5e5dd1435df2556908fe9bfce793cb36f047a382a96a2032d6af7df5c40e72f94f9b870f0ad1c88093fef9027e36a1786bbc1302cd8d19fd279591edde717997db985c35108974ef76fef9cc6d811290fefeb7b0f5d27cb886d147c10547147a2bf07adc3947bdaa24232ff46bce056bd50b7780bc65293a27555cc74358fd4f7b32c702bb30ad52a5941fca61ad09834204ef70b75cf42436c767df232695d521deecd809fd3464d973a3e30b2467ea5bfe4eb511ec69c6007b263ec44f117248ea1a6a165ba1c031ff00164de204c7c5b55752ee8776e57ae78a1f9ab2656c5c8d4f275c4d8f670f3694835a1dc8de85e839860f339e7988d2b52541647f2aa2b17ea72400f757cd54f9256632277e63a179c938b21e27d6c97373efa3e2938213e5d6a6e14b9c0624960aa457f03f74c08f16f8927699ca2934f3c48f9060aac534ac5cb7631838172de6ee06ef1400b791dce33f6e05dd2461889a5736b7d4c75963929a7806ef3263826d7b913c0ad2895a23b09de1bb543b0d89e12f8e68d298f0a8ef014fa2a8b406a0248b809d91399c7edc020dcdbece6de360e1f0563ec0cc9dbb07c9366af1bae3cfda77513e1ddff88c4ff5fedd6de6ec197d48a5abf3494da3f81e5adf33d3cd346cb1b54cdd1288f8bc5dcc1255cb34f04f1811eae26cff8bb4b834b026d2fe3dc967221964d920190ad1bc2619334fce9f11939f66cb34dc866b7503bc0679087d449df2c42b9242463a79b86b01aefa75c3b0542f8ac29e1d6e176fcb64e5443913d5e55682640841bef2b96d4bffad95fec0be7fe2be597885704b33042a79a61c76500632a47b6f6c66b8d349d0cd19bfde124524f8b244744b6901279627dfd14442301847e6d5200c4a985bcb8cb34ab76939901620cfd171924db620966bd06dd07ed16aa2c2d93bb485adc61db783c97242e6fe48767c92b98afad168c3fc1b1aae1ea86657115a7f016448d9c86bf4df1fdbf91057bc765ad2a6ce26d2f206e7f6f50fae030bb27979ca265d7c750ab4895f5ed576a103e06065756e089e0460d7a48d812bdf024db8145b897bd0be584d43034086440b4ca91d1822d607f40af78d2a03076523e6f6276d864b8ade2146f5fcbf93a5306dbc8eeacfeb4eb590c86e57fc3ceb3b3609f255b2fd24da69556f19ee579366fce2f31b9a8641dbd752743bbff96161e5314bae3e3e546589a83175ddae49c159cf00d304228a2247b405e8738beea9f4987f6a0c33bbb265a3d3c4172c2fd4a8663edc77527dc0137b659135bbc9fe3b5c7af8645c89e92f637ee36125a9af4cd234b055313c70adf5a5008835d2e04a38efdb99731a5a0e247f293baf3e8cdda5cd9cc934d1d4d9cabfabb96f6eca4edaadc02b5451a566fbd35d5f6df7fdf4277ea6594ab57c0bb1f481b3bbb0b1f6d28346c4219272f2a8e781d0cae67da936dadc935430f99cdcf9f6546a379f7396baa36861fc096fbbacb38f5c477a1eee5283ae6bb3df2b5b45b095e50cfc260bfa79f92e4d5bfbcd0d7e40f2985693309ba64a11b516a2fa6fcd7eb375a9cc2c71d949b894635f2cca9b1d107999e2b16256f8d5bcd063214deac7f460b80f8fa2b9997b3353e820b972f2dad9100d041542200028ff26d3bc56d4db12d10c7d224ed4e2a4730c2f2184a663637068ee19614ec25eddc2015159693cd1ed6c760e2f0249f4cdc111169d0b70a981e9a67ac289edfb10917f48d1ae4887eafd75ebcf9f569db2d58033eb090b7db390e6f01f6d25b73a4a44fb72649c09ae79c01867311d8e795369f2f70fa79842fd82e0e496122664c13f92b3f45d2a4033fe35f6bfe0eb67114dae10d07f877ea4e32253bbb0a01f1eedc175e409273f3d89f5203a8a404b27a8a0600fb6c16259c1ad8b4d1f9eaaff70283fceeace9b2b4c9ab89e95c81829306422ebf6e23bf202f4db3f4f60a933680f7cc7437927d77502f9fe1718aa2379773cfc24c7dcbc7030f2dc3d7b5b57d5267e2ea4d17d1e7242f26b45cb3b3cf7219a6183e9e5cc649a14f5df77da5dd7de9cb42408812ee8f4833d0c2a42851b70c8b4c30af413058f9c9793f1b20fe2f77fc9b91dc45e415fe65eb8a8b66055161729a9d1dd7b6ce883c8b128d53c913e61075dc9d07dfe89e0006f399fc57d8360c7a656ff5be18b3273c3a9f2b76782e7ce2fd72e1cd513c2d95cc67237034691e4179694aa9c0540befaa632252df2203ebeb1ae3c28f36737bc3912ab2814602f4f341b457ae2e226d7c717fce6c433b48041db049b5a0bd1c91f1be728b916cf7169234c916ca53dc4c1faa98809c8c81a5bad16c6a3b3885cd4c7e4969d72ac64504db431787cca10c05ea70e64530cae3374f4273de4273e485c671d2a8b61f6a991f6cbda27276431d6faee2decdeee34d74ec56cb354020872055da85aa06032ea095cfdd099faeda25d3cb20ea84e340095ed68af8d7f4114d20e9bc36b32d462f8881b24735bad1f7329ddbcc300e76634386684a0d1e8a0aed770cc7c9bcf354a9dad828788a66fc94a97c2a8cee261a62e126a65bef65e8b3f5d8b2b93aefcfec0d1c42ffa1760f4d640410b0fd7d26f71184ff755d74f8e49b0875a76fb9c6a2f4393ed370f596893446e3e4552e43f3acf1a667f9df2aac3887390b74916ea8ed2ea557f6363dd2b1a547c961b544547b521b84a12fa3c8dee87c7a45361b4a0a88ac0b4fd17e21d2150eccd88f2783b7dd85c92ce0379bcbc2f2b5ddd73b7413dcabf673ccbf13a892d2e62c5f07ca2b0af0764c061da1d2e0cceb0ea731fde8625805171d7c40184feb6661b0a15f48fbfd8fec382f0ab1e589c7265d7870ea6dc4b3f9638805de9b91669bcbeed142339afdf741d9960c9199b4e129f8a5b1c5ecb06fc1c693591412e5d55e9ebc452dbc12cce2374abb6675486686c297da0d0aca78f19333eda75c0700c1841a81625d267596094712cc4effa19f3178b3c1ee347f57c8359fb70e899bb4a376681e1d268dbfe6c571dbdc2598c1b753f64d405e639d801e93590ff5fd569cf77d746d8078e1230936b11a65bc3897ff012ec4678069040503ff0cdb60ef5ed7e54473f6b61616b9fcf1eb95957e00bd3ac86e1d7f238020711feff977e9d19e63df9d06caa078c41c0239a553e5896c5e7231325a77d03c6393404a4cf2ff99557d049aa17a0d37e48d9110d4f5e45d3d7ada08db34a72f1cf4e6a4fce2383e64ef80c15c860c763be21035b297c080b35a5db9e1592ddc34f76e4656e409aecc9e18b873731b6f0e1d33a4fcdfcac6a17f43ba837ce7dc9db49f5582fd196726dca09cc08dd42bd99a277a371eb68bd095240a29ce3afbed8e3dabb2b55385267ff181c8f0e2f9cbaad2b574830d7bd0399e1f8da049d6c9b6193477295eeb3a07bdc30f9e61b846d97568c07529fdad2a866fab794f55cccb3d02291e669e7b4a52282da838c91c7336e11cacf1a962b51bddc04b725f12535d6fc67612e4730275ffcc1e55fce177273dd44be2f771feb6cb450b377f78190465f90cf040e181a9246d1f2adef6cb1687179552b5b237aa0a891740c23dcbd7096f23d37305af55a49ce78815c6b1a64970cbb6f14ab4d25d92c95d44b406f2da316e32eb3433f7dc386a2da4637ba6ee0b099f30678e089adfef048bde01cf5a0c7548eaf35135512eb4b85ffd83b9d3ff4010ffd145c3609b25a9b8ca83e1765e13d59a9ca15909890e5efe1b332cab6c0dbb88c13f748e325c26e4669b1cfa19b76fcbf49943f5b2cf97dcec26b756a0b8419aadd00d3397f874835d2fc7bb1c7c91cd0fb87fc61ce65a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
