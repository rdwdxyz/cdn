<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37972df2950612348a5966cc46e1ae63ea02adfcb3b150bfd01846d4b8c9f3993a0512bf7f2d1d6a189fdb7e47a76811d8ca8584ce365b18ff39942caa199dd33a3f5798d4ea945c1598e1091f9585247602f13445f44fa5df0160836bcd9f895fde04da7b70c603641ae859dcad2c2391eed0389cc789ebcf01b17761cffb9ea0462cd9ff83f07c512e5bfca01f115a724dde94a6ce9e4c5d1d2c3e406efe858f27194ba90261433dd166d6c02e9391c03b3b483d03e094a3c41dcb161628607529628e9259eee850e39c1370dc9c07eb179a7c795fc9327bf123def79e7b8f98a6a74c3e617a9494fc122cf0219fa6967512456d2768d1d54bd4234ebd75317d062147b407aa69bbd951225ced6cdf5097ce48dca4e29d8d132ea7db54d0c17b363db05c5cc0defc22fa17a5e878bc0f282a7236fe70628f6feef210ef550de95d991dd21d4cf6e8e979a9e51e293c667394839291167c9a3cb7ea931888b4c79955913d78d6a8f7ac25100ae3f007fd73dec9230f05ffbcfb79ed6cd89f8462df8a8d5d84128d2503c4f5bbc50847339663544b76d174a0f557a8c07e4299b36a0c184cbfb54453696f6ca2d948b5083d4d27d6f5ac1c330d5b28b7c863bdc00efd1a478317e11cb49a50fef6746e469f92597def60e789797c98b3f996773529c658669e3087722e2334bcf49b384dc42ec0f17f7f37d946dfa8a01fc4c2375298bdb311ed1385ec6028ac5f6a4cde70e1ac805bfab650fa65107e1d1ac6f85456d80f26b62a261e351c6c3224a8d20fe2ca4199165372ade3a0cccdf5e2c1139646e4321ea788d24b64e69b7825b21564cd506aea1585e5272dab43b42900ff58666aba4c8674a82fe63825ac0338481abd81210415c9d8c3c6ac67888d0ac3a0a9b1dacba8bc1100ccfaa8896b128ad40533b53a7abb8ed83cacbb4baae51112145af09d25ca55fb3be861c0a2f4a95d1954109e7b0c659dbda0cddc3467ef88ae0d1d4b7d66be7b24ff0723fed044bf05d56956333d5819747a40e199ce529abd25bd355ed1fa3ecbcf2fc861cab0a04c1f19901075147c6a720cbcf800ce947de5f01aee7ba84c8e422a38fabc53f364097c05e852a3ae3c2a44d7f6260ba551b29463f60eb7053eeaad93cede46fc99cff1f931d6b46e1c7fdf0330896919f204708fe6909de1e1062b972e74cd384d747003442181dbea049644c2edf791f7e355bd18ee4d3fdbcc43f42dd86c04e6566dd5783850d8b66d21a576ffcfd0ed20ac5112752e7378e4d919316859d01eb5c9a0d44f0601d0b2fde719699dcee522974d8d6c237f4a9408e147272fc68c4e6d7d29f6d95f14c12bd2619028cfec48687d9f4e64e012ccbdb388e29f93aba1b284956c57f7473750d90e52cbcfdb0a9bddd64880d17a2907bca6cb227e5c00f027f0323ba861bdc1adeedcf979b7c095093afb7732bda3ad5147227c1aafa671187b3e260c214a959e5aa66805c28631293584b5125984dda7f0213848a6e5fa77d5cdec960f2b5014591e7aa8f54c9e034570257649837c027310a29d1ebbdd6b8f60188d57929eed1be22e30e77023e8a3c5295e056e69330c8cf38fe4201e45af5d1b2a9550bb63dea5f2debf57d4b097bf40e01a6613fd6732a10b8e1bd8bde624f1dc4f669d21eb29941350aa5b3f27cda65219c55ba336712acb3b19e3ce6f664db5ed82a27ec7e31867ace1430646fb4c154fca0be447bfca762d9814d97c46b7a83050bbfccb97db18a91dabe501015b012b4ffffb0d353c7830e7cfea79d3c2ff5decb1da212ac8c4168b4d224c3f7260416acce0dcc677ff4fcce0df6d678460631696271b81ab9b39674567af61adfd944267184b2e23a266845a45412b50396d5c98dd2887ae5e2638a04feed0ee58ec81cf739919f9ecd7e87f2c611035ea0cc957840cc3ddad9519fbbbb139f6f7282bb1503640a69efd9e01b728e57b6199b4ff8a115c5c6d947c9562ea41c27df0b13bcfa8e359615a3682ca1d0ca9d03cbe5c7e863025ca4294c2449d80ec44fcac105954767bd11711f21390e3dd5f764a9ac54209b251c2c8bc8ee25dab05f48ede946b4ae182624cea1231845b40b27e3f96c98c3b26861a4ffeda84d932daa2470af702fcc9082d62445cd2d7315c26792fec15c97c45e938b61f9cb2e1feec31f7d1e96eac085f7d8bbf6f85a4c7ea70ecd032a318140fd68b6f39f35f320f62c2809f75ba9e17fd03f5ebca4c095b76583dfc0b0f4889633dee16d6a681c5124559910c7268c5e1d45d6e6d7434e0eaa6ab83af8a886ee35d55847831e8a14010c71be39c22bb2c44f5200eaff68c5e9b14b0e5853873dc09574e54c48da17bf8360a61f489bef225a47e025bebcdb63a2054fc0133e0af04bccda60f0ca2d842a9ecb08b33ca0febd3302436a96e35e21f7f5a3f7463482b6a7eafab4fa9db77d26c42e6a0317c4108671422cbf96df73788b69cca9b94df81b118231e7b521b4963d5d5eeae1dbe0fa1b31a74b821177d5889a5fbc44326186b28112e333e6d73d351b8f991dea8f2e4caaaae7c60ec718497d4e317e5d1e30b76ba8e593586b2c8a1e6053d942c82bdb7f4c5e9c3255a47fa198a02fb26ddf96e7aceff52de026e66b2a5b56664d3cc7d92ec1bcb87b63d3e16548162c0a73ee2d7e0ba4f61faeb047b16349ec58630393fcb83d3e039af7c19df5ba36f1293d760564f95ead68eaee10cbd768b5948d5787291e3687138cf641d63e251256be39e36c64879c6e7eb575a9b4f53b23e0dd17f1a488ebf580242d9f3fdc6bbdf9c99375a00e223892ae0f7221a66c01067501d0d699d0ba22a98f72e78861466d3993080c71adb36dee7e224ec6efef03cbb1d93f025fd4852d223ca4fd1855ff5a236923df090504fad3700c0552470b7e4e3af6af45a0254516f76294252fbf2de3ae227e3b9f1d1e57c422f78e5ff9acfd0fd74c7b2808e78c1ae912dc06616fcddefd0334f181b008d19f7574c5ecaafc3cbf6a951a9ad837e4c8feb05c4f7f05cdc101401b85598be389c27ef876d9d4cbacf793e81d946832ce9868351d496fdcb719ef79126e608212fa53197b3496667bf970c1b70307f94dfbdb622d97880d273c404629a92dd50c8911c88ac6c0c4ed6430eef6f289ef85838e1cbf01db52c73f728dc0a6a0817ac8d812ba540a89b6602a14ac8d2311acb1e7ab33d1aad64c0ee763758d4fadacf0171b93746fb9f1b654ad5fba482e85d80f1ca230bd5c1f30d8364d74b366f23bf52db42df4073e0fed5c194f4f9430043f366c9e4069fd1ce123408724cadf563ef77e0ae753fa608b2907932b0edabc61590f9ab380428c888bfe314a2f04f390dd08eea980e22c6dd1e5fb6bf347af353a5710780d4588f881aaf82fbb2cf35b0091166454e2ca6a07d4a773d9b8b5ffe67259411dc2f84da7c734ac8bad44bf52cdfaf70e97dbeae8bfb8792df26a7e165b07e2c9d5f958a30807dde1190d7b8f0411b064af9ab9fc2f9be791328f47347c0989cec9183fadeba3d0b6f87bcba404150030172954e432d278f64977df5a4d718a6fc8c739db1993d9559fca6b9421763a7fac02eebd0ecca1cb2b145fa986a3407b02e131de1b937174c45192d1da5d192ea6ca5bfa795893de9d5cc05e0448aaf9f5206ff8bfbaf0117b746a2d26ebb1fc6eebc6fc03d30a8ec9ac25bb78352139d4e85ecfab68b99c9866ba53fc9d4264766f2e8e619e18c93a67b56960292e6828ef40b6fb241303008c2b7dd1dba81985c2c8380eff181f277e42c217a885eb6f3c6c1f124dd24bb726792e3d1fc86aefe01fbc287f5cf215c36005406ea68ef9350b060c002e90dcdc69d520caa6ba83a416329708df751e463eff1acc8dd85d012f2fb6f8c93f834e0d87d1675cfda024c05882edb7e2f5954ee846cf89a24981874857d771a8f8688d14f3eb9d4495bb73ade82e2d0f5a170f01dfb5f3871e826106fba718dfe536ebec4c440913fe49ecb58868a317d72fb70a70b702fa06ccf2776fe01b24a8fbac63d0414d043573bb72163d4ddb5b9e538053f94d2065e991afacb8e13a003180fc92b3679ecf572bad8fd0bb38297e3d254870b959979bf8d88c0e0b52e7381a6f7ed71573e7a3cfe0dbb2d412bf75ba7ebab49652bddf32cceb16bac505c7fab1bc82df6fa1d9c497a66553c576a547e9015ddbde6c430f99caebf560ced8d555a94f08c2324d54fb6334706ab473466b3f35eb775c06fdb05bc34d9e4cec6a880c8e573e9a10cf82c2dbfa1cae5855e4a95fa9023cf1b789f0b6aee9b93aa24e5523e02dde4618c5d72be82dac2c233698f46b43f6da0639253ea4af8f7d00f4bb9335f42d125e2508d6058429329602f4932af8192cb87fec045fe1c2decd52d38c9d93abd9751cd894ce72fa61b359c36ba35b1e425218baa6f0a7f282a658485a472c5f5c1f3c6bdb18ff048af516bc7c24779a2c6200b97a0b0920493702572c358a626c50a2a006f5c082750216262e6ea060c652b280fd12c62161723c29398b5570648c4e99dcea611878258a795223f4b2a63fb13457214f25f201c7c7359bea2c55c8e1054fd77b58048b3bad7b465852c75eaa60e7f57ce2d744e6bf34bda4211785bdfdcd445299886cefcc038cc078f2d6de8bb16825c36f260abaeff687819d086259f358937ba3e4399edab6d70004d3e5ff2527fdac29e0de02d8295f9fe258bfac63bbe476ae97e3873d2cd5f68e1750e7d45ae9687cf4170a9f945af111b6958b3967236c8f24f00ddc6ea4a534d2574badd1483791dfb12bbbe8995cbe0d614ac27422f83286bf09cdba8f6451f2faa4a32c6c38ddc6c51ac7328731aabab8257c8f6a481a3438c396ca940647449b21f57f66b8a5cedc395c5933babc1370ea404359295499cbe41dada8e7c482a2496840b0f1bec7d2b1a728e7c402393daad2b58c6bad5c4d9a96be0dcd4bab2415019c1f5092360c170851ded3eb7737bd7e91391dd1cd496ffe9abe4d7d81db6c56a9ddce4382eb6837574244b8f34dbb8eb9ac4ab6cf4e44e0a873586d4c749d2f8ec13689c665dcf5cd0388c881440a38f9b1ca2fdfe47e0b027be6be4831ef7da80eb5f6e25018c888c5529e48b1f09a9c8b64ab457f6bed91f4c18f5125f7cf54ffafce50f17101c040f9d335c1563cbaebf9d4f82627e6ed298213499e3a76eee253a341ad266a311a9b05001941f470b1eb4c81bf93d2cbaa4b7205ae44b4ab153927b2dd2977050844190430bf067a442f60dcb64f5a0989fbc23d2cad98784968ca6930b8fc6c0b2da26169163c7916c1e5ccca7a213445bde1b866d7450e0fc7e74186b736b5f5e38ccdd841cafc99cb46f83f798010edd07b1e65fbf27946d8cc50ae1e0dcf16ffdb4d4bc8a4e76d892241476fdf08fc966c17e32fc5cabbc822ba3e2d5b383f70e9f942912ae6ee43504b56d8cbcfa054ca7729c5d16cd5d4a8a89646a6930a782ad409ac929020eb54556abca5269613d47de9a4aee4af64b3c7725403cafd0d6c043cf949d2d94c8c1c4da07fc172093386948006a0bf3d42d5d4e71b131a2e248d77f1b6726f1d2d2702079f48b747ce624573ef815b4da3204ee699a78a2c9d9d5f60531e5799e7de2c9d474c515833b131b3f5e58047203e8e0d0a771e4991f487aac75637f6a90dabe229f62a81557015a9d19bfa6de4f50d013f157df2bcd1d240bce6d0acf60ccc57f6a064d22e95b1f8861ac44b18862ced9120e108af7e7e7709166aea5535c6cefe913a01a5b130aee5a7dc0772920a973a6e977a99a39a5bca226b71fc8e04cf948d8cc8bab511dae5a92db27beeb231112f03c69d55b7a0c6076dbe329add59a93ef66c65afda15b2694347d366f57067451e04226cd12181b57dd195c41e2129020d452eae53c9e4cfb625f835f235f1c50c2eb3ce2a349dd50488f5954c58b01b5ca7116b9ec37fa3257e21621a36b538e14a6573811f368f5fa6f424945d708caa43057eb4735e45808b89d1e5bed611de109dce7327975e90faac5f96e5727db9fde29c9af627c21d41edc287cf17a626df4814eca5694454a9e01a9310d1b397c1377cdb8611e12a54c24c6cd30fb92038aa7de0447a0ab71eda81d4078b11fb8429ea3c64de4778eaa3fd08d966ad8e71eec766293e9b48252485699cc52cb8ee89870defaba7464995fda994fb5e978517491f9d12a9f033cedd6a2d857b93b9eacf89fa1ea941379dd0826afa37c3da75098baa4b7ade689c61cc6f9bb69378912ad89ebd47f18fba27311cf0b09e68c17e9705b3d8db1e2fbd9b1d2c90a38766da1156ee5c1493e40f4e2d8421f39bba6b647020c953b7dd7b0fe1ab103ab2808170141316a74e2b709c611324192e4756a82cd17dfe4f087efa9dbc240038c1325b5d6abac62f39e4c00305e66e1e9b974e22c221a3d30a13ce9f3bc27fbdae69b5b71d68a4712fb1ca7291896857963bb12c31489c9b49de650ada926d8c31bfccc1b4414ce0754702f52eb31e40abad27f55df88d291658da2e04c6735b8fa475d96bfa58357067c28083d2d39cd474ecb7cd0870c8babc30b4e93edddd76ddedfad6ff22c4aee88837e371c2d50c8150132dce2ac24f9b63e176d201cf108a70fd04975c16c726618471e486450fdf7290cd686d826d1c1d3f90f63d30e860e70152b12379acd0d730cd24ea3f7376a3824f2a4441fc07346a70aeff8ba1cc2b8761c75f86537192ee30b0cccde41f9036b45c52857ce9b4ed32a886920fdb4f0ee51b9a1f3cb93db15f2ac2feaa52276f18b90c90633b8363e92deb2f7aad0bf6d48eed365d2ec3e580be699393542d943654ced86d6cad6317dbbfea51901bd199253013798c266fa0a428e8b599ee9c477706dc12b12820605e0a870248342bd40b4fa07c534b3649156beaf6dd2eb54fbf061916e6611bdbe286e00268d01e8e2af7dfefcb1fc76d1817286dc4459f7e0fb8870c9d31af942838228b3ad643efd980b78232b77170e24a1ea1a26820a560e231aa60ec909518b6945ce160a29dd4c30bb5610ed956aaa91783f44cca074fb9b72766ad00a7234d93adbecead65e8c507da06d8536f637a9cdf78784118853b3c4e9f3f2153c5c551381c4011a114b96f57d7624a6c2c51128b8887105d5643911d35ed40ce75d7c97e9be8ed2a67be401a7a86e898da38334ff00575b3f545b2848c644a5bc6fd8f1d5f91a1f731ee27d3291417c9db08433818b64d82df4f129b5b1505c36df142769f4ad563798fe522bc596ca338435cb9e4fd0585f5374ef43b6b0cca760d84d5e590be2bfef0cbec781fe50c98c86794b0d6d7c695a51140aeb3236a3be0f26f48d8e35e319b00f359f7d76fc8162319064cce7d65e314763df9c1bc37a17cd7bf0f926c336977a538dab205e5aa219ab0f22380d99ea5569b51cffaa7626c87df2075918b494e9ae0ebcf1147074f587d6543840a7814de3547767c7b1a4a17c507d739f995d1baf24691f6598a12b48308f568cf680a79f1cb9c5ea685955a4af54dd397c8c4fa39ecbf5ff37234b91915ac3afc8634dcd965e10092efb0d547bf549f674633c3f43b1a1fdf06f32dec8b7473d8fd486eb877fa5bc820cdb95c6ca1250dc56e334bc41e8f43ccff31bc4f538207c586d2d2d10590273583b0accb89e948788cd521ab792044cb0809ee885334abf22a6b248e507fabed4abf4da8fbcc46ed8ec7e517d37bad748792deaf3aba94d97499fd28f542ff966107370b28d72af6ef486e716f39f7ea5d85e99171c21bf5ae6dc1feebad56759298e87699dc8a79b02157a1ca979565a1823575ee453fd40b6bcd9dea9010c15cb90474b46878a89a58bcca9f78584b99f09de4dbe066edd74ec7f8499332d1dc9337ec921fd2abd6bb4aee8c827957ba6763025b71eb46c88ec017cd9dc03214b6781cc73abc2bd5586c0440295465744fb27c1b765218072231d3aef46166960c6b534e824856f9b9d4ceea226468cb96272e54c3972ea5f643c5cfc0ae9a6aff1cf9bc985fae386f78f80bac0d64d15a8fe79eb53f63bf2e50c1f7cd07243ff31c5545972235dceed3d0f8d1e4529ffcf4e6b5fbb934cec451d8bffdc3a920894c4f1bdcabaa59421ce87809c4a058e5674a3fd4b7fbd5e8f248bd9389be675ba0cc2897c248ed8a616b013048de8494cbb77e0c1718bbfbf67f7f0f2cf7eea1918d2a30c801fb667e420b01a029e528d6b42e585d6a4576ba82532c4f37aea652d8ed011510502d8d7bf7e2759f3f78f136b73cca159d048ce4b28d4bad0aecebda59e24bb36f87d7950c5cd9dd742776b82964169503017c511bd8d17e9090d940cfed6308296a74d6744c9439d59fa7b62faa654c9996049bea8ca65b6f4cb5dfdf65108964fb5ddc954bc082bba8b30badbbd2eb69ced1538ddab2837b29ea24d449fd02edd8053a2e1b9cf99703445d6feb0c9fa6daa16df05a8347b4d1f4c14f085dd4bb63ae6ee9a5c62b41a09e23fd2619468bedcfa733632af32e27c196790ceb53a051ed9a637dec7d66c561c2abd3d41ce8818c7652e1232860a74dac4b51233726b163ced3ec75a4c8ed3c5de3f393e5fde98319939960f7231854233546b60125216c92e742187b9f8c3f88f4dfba3947614d4218e08414f67e9c20223d8580c54157f7b2f5ce92b8ebaead4a34cca49a4a276b0361ee14766fdf0a9305ef1316a4176d3cf64a63fe7990d2a365d2afc2b39050ac9b07f8fb607f3ecddee5720f612147a4902978cc500b8c037666b349ede2aa1ca428db3f553a5452ad2ed3f9d4c10ffed2488d3130789b81ec47ee970669d127e0117ddbdc6b250046c4a64b42300edb83acb1d50ddc5babecc054f4900387c2fe49b14100808c2bb18f0fa7a1cec577c5d94e9cf59e49728a61ee2003a562c371ef73bce66d7d8ad868e84039f6fb445eab92eafaab85ffd34ddfd54ed857ecfeae4a3721528ba34c85d877b38c58e7672d5aab6b20d621708b84590f90c6bd49454f489014642eb5dfdba9df649f6e0481ec0c5716bec9c51d92bb9c19d007e3ba3761b45a45ab6953473710756c9e79aadbd95a469b429e063b098dc947b84f8bbece8d9094f24381f1b1e8e0c7bc97a5869332f124ebefc44552edfdb2b895baad41ee2056c18b7bb14abfaafe029a9eab1493269e4f5cd34b69034b7d1654b339a874fd06c555fa66639b53d665e962eb68ab54018993130574061514b7089822a4890fd3a66fcc25a744d7b0d5ca0dae2e9f8c86dcfac3a390c912a834a438ce834263ce6c365398125f65b27615b0566e1b64f7316991dcfac3011a3bba507744a99041b77b5710ac4d49bf7b26f4f662a8738b9c27df4b5d67df184a149476132b5131959bc7ca64631643348dafda8a8ac83cb0ca0ea720b4ea7d0d1b68d5a5d079c10f6c291142ce1c3cd0162a491a75d671ae0939a1f481632beca6e34e826801a17a3be8f44fcfcd07dd0e9f7e72eace24180540595ff2eee95dae2cc80219d1c75bfad95f015efb4f16d8c070c2f5317bb30419736e35ac1d6dfbedd0a4344adac6b6e978776a2d390ca17416e9243d0c11b0b53ef30ab8f853a30a21646d683f97da4d44b00278da7ed122551671525bf798c76bf08bd2376c33adee7cdee4014565713b226346918c8f2a00eff49dc1131ce3af7df2d85c3b51d080c94de1adcb9c45868f1897d37a5d7b97ddb3354305493af512ec40d3714447fffa7ae5d10079c10f30c9b2accea6651fed53251cdd19e199a6f900a81ec9d32b0f6b5473ba4c7f16deb411394971d9bbe8ffba4188c9e426b12e2c75e721bd03a98708f84d12d52783405e97066e18920a47a49bd1b9ba234d890f2f30766bae4dda4bbc95243e27bffb5abcbc35e79bbc40a91049f01ed06bc3d106397cf720a9e3b70f30233e85853b91b9ccdcabdb88d6edfe959522e1e1ccfdb1e12be288a7239f995caca490487124b713bec16641003828eb5d46d92d7a690a0d3d6c849aaa85c60fcc7050b8429110ee0d0386a5d57beb2ee8051cad3fe94e0d26828024cbeafe1f1c5e9cc1d7c3a15bdd1e4617853c7617b5fc3ca3fae7041767dcb54b41bbf4b4b4759e4945eb8641c0bc16ccd18723660bc57815133818a7d41ed2d856efcc3cf75330f8846246df49db890de5a76c110d3746e219e647f220c3d10c95ade9b54a8427cf69b94e77e4bf7f254af1e282cbc7b747b9a823492b6a4cbb3e88511bb192141459c8a075c25b4e0df0d05955c2bf60d32bd39773160515f8a12d0dfd1ddbf83b5c71230efefa220af9ab82e03ce99be5aaeed88505a1f29ac98ae4abf90cf25da12857e8b9e37743bb3b4ae737d90b754a2fa4e7fe7cee4270b4bb10ab1c3dacbfe9f81085a39880e7c8bfbf6a1e577eef4887aaf1818e88e7cb70612aae3b3edae2b0ad0fe668ed767138a31f401293c33f3949f31178a4b44844b326fb1a64d4d71c85682548f0b00ad3b343e993cb23e939451947d20a1f00efa8e3d13879f5815def14554b83e2f02460bf10080eb6f55338decd8aa1e6eac12a92b27d158c8af7c89ae2c8dd197a4df95c2d4577230294e1507e94a7fc6e3036ef0319c6c7344713173ddd06f73d5a721b69eb78ff6d675b59869e02d8237b6e911d742f93ac35164880683f859aa9980b590101e0d0b0d54d40281fbb5cef71a05d3addf15bb4960d289957df79d1701dc76fec7fa61024177c98ea63c6ba5e80636f50ba0868d37bcd14fa83464fd19818d095e880eb9019c0aa4448be0901de4290366b9d76efbfa59bdd6c97e51976fb08a1eb7c1f6f11cf86dba1c895c89402f7299fba97ed541bea3cdd3a2c0fb42b844224054e0cbd0cce64b9f72f25005f7b7feda7ef0c70a1942980c573d771ee596157ad71dff3d4e84b5dc994ee3cdc777a69500d2e714c3fca0ad30a8bdb80569da0858870a29e5964141f78ab5735a035e5e27b7fb23a1be2767bf8773a77147a7bb6c527c1199998f45468398137ddd6b08ca8a53050f21d6daaf2a28c58bd5c7df923ef1835b56a42c3e1b0c75e09119f36f37849c6fd26eda9952bdcbd77109cf0c0283ee4b44444fcfc3a3ea3128ecb2fd429173ac37a4a7931873b2ef997e1cf1b94e77350fc21cec914951db136b3b4aef4212a68122384e2e725fd1e3b8ae5e4280c80f5089097d2b9de90224e738316b562b54933f32c7c8b17280c99406199693b4eff241b21f055af95eacc60477530317ce3f2c3a5003fb6ecb1d653c4ddd0d21ef2420e054323467226a9475bfa2c1dc21df491d3140029be8f11898c39ea512a0090aea60be67b6b6fd884c98776b12aad105f133debf229c74b5235bbbf2ec5b4666922ea7879564f6153af8047aee726093d875ee26ee99848a1689ba7d33c5c9b1f7fe3094ccd849ef8b7ba2624017741d16e18443b28db4e9982cc10cec5c1ea3a0526998558db27f04fc02ff442e2fcd39c05719c7668418d6d2342479719b20eb1894fc3f61cfa0b843c55320cd1f55aed57d8b94ef45ddf2bf283b487aedfff76c9e735d8c34d47ed319a03a610f83d5cfab01eefa8ef1c3a66760ff37f44e2854e238a3e8e71ea9e01effa29d00d1250664eb84e3a4f50d8f70a30db5847db5903cca652596d9d40564235fae0c9df5985ffc2570a635dfc367d0637c9ea59061586258dddcbb43096e3733e1aae580e3222a683ef4a0858e1b248f1241768c767f837263f86f3cabde0653ab294a70e1d40e7f4aa22d1af19ff29a6774515a508c50b3eb7311324b0121d8f594979dc517b7f293b58d1b01c94b2f3437edbae37e81b0720c94b10e57e753216e7f2e5f3c88065df69e4203e6c03d964dc95936331af7c68f5c3e0ea2c7b39b8665da2910fb61a1a22d742ff825589249c501ccb39088659e3d03d5a279b563c665b54d08aefec220e218f348138b84096271c01cda9b77a16c752184c9cfed98c4588d32045a606c1ff78b747bba195baf3a6192d61bca91c40aef5757a5374236d1d2a671e04d259e4608dfd84b9076f56d918ecf7e2a23bb81884afea7a5459b993b6f3e8568a9af1e1ecb6115a8104221c2d50a930c1517a187fb8c11b30660b02f52c33c563ea02c5df33d12dcd3a4640722e51a4746cefdb8f208ee75cd64e58c83a33bd90e6ba80a512284e0581cf1ff035ea0c6a75adb9e9dfabfaa149f6c8b1c398cbd4bcda40d8fe418da2f2753b11c0eff893a7271674da3fc8ce25463781db904f9fce50dc44b055bc25d6f15902c1b4d49db4a0a7ee42207e3222d083a100052fc856057b43eb6e550a274331d4ae9201302e061619945efd5e31e7b90d573fdd1e2320536346705e1fba2b70ff9d8486a071cb97ded1e578929eeb2c1f1ec7c652d3e06aa6a7ceb34af620b2de039972703703aece97c16657125334c89364e63ea9e18f8c8983b218e246a5fc0364483f362eb012521be08be561ac28b1e398fb98bbec54efb15b9b4cb64e63168456489ffead595cabeb4cf9d769c92dcbb27bdfd91bb34c7bd63f7ff6907e938e87b960f374d7287b92c4a6ceda28693aa3d93727c3ed9c29e7f75102307b99ebea0c0b98ee87647032663d0948c45d8631b809e8037da1429dfdba05e709ffcb19e8934532aca278ebaf17cd6e2cee6edd90febccc49d95740edb7ac87c786675e406d288185d4ab34d3a64854b01423807035cddb5b2e93e897ca1f0e7bd0371844d134732f51140b8491bb540a3068cab41c7673c5a2cf4d635c375c3481dedf9c53a9623d85b90c8335857319ed76df3017ca6a94ad99de39e3019d251fb4da091089cb558a8f719e976286a30b7b74f81826e219311df08733cca5c03f8567492c06eaf193b85dc97a0c054b4d9a8170181249b4c5139c70d18f6c77643a419043aec1597a13a519817701491d97b4f6357ca8c53e0d8c46eae04b7982bbe1b865eaae7d7b14d95ff426c485461344d64ad4075d8dc2b7b49cc98a76b2d86b970e227e3aec91a2abf4d950da5c9960ebfff2713d0b907053fc60d63fa480a7d044cfaed5a17023cbc5dfbd78a70902c5906ff40d2acadd6923bbed6a13facd97ab21b7dca8612b758436b2f969979102b8e6f449e52f85d0d85fd3477a6644371ce3b7daf27976c5538b1eb245e10d2919b5a437d300306cbc3689103b47ee6e6dd36966a92d19bbcc41ddd3033ae2a8352f021e4d98d1092413f27fb07f7b1ccad17cbef12afd6af8007c2ea6a78606fc95a4b311f5349446ee24844f8bf53e03d74657726ab29045c571203a14ec9e4dcb7038ce17ec2c453d4fb038ba873429a3d8e9836e590c1e9d77fe3a594b453942b85974e9536a646a710729b99657a93166155a8c659224f0a23c70325377277044d2aeaa4979dc02495734e0b3a76572c2f6aa9c93dc17005d8cbad78102682939319d8f32da42ab4f209960ba5a7722642629019da74b6f38dd3e2aab173596b1c7232a70847f929bac0750cdfce2b8d977845b3be30732a318868d7a38dd1f0e9f1995015c28d6cbecf5d1a321c8368c973c8fa647730618caa581b73b1725c06824606bbcf97bca5b9b61ec108ff1d62d385f351f009bbc2bee0407400f783d82099b4739eeb3d83f3c3c25e187315c3319bf592d39bf381a06322010a8f791bbd886b88a554b0a63a1a9477bd154246da423e0d74954b86f34fb12f4feb78f1c3ff4a634a78951320747c175f1a3da145851007fde41ccb1c65e18a9bdb5144caeae9f00845fdab3261ec7e1e3e1e71d23dbd849ab2a632aaac2c22b0035cfa369736f448cca4423024a24e134e02ee6efd18e6ccb78227fe24c79baee08aceae00904394590a8bcdc28722eecaac9accb9d95fef870ee9c3aecd0c8abd1fda09e13956f74d9c0f485d74e0ad744c9b093065ec56fbf8b1da5901bd20c259e9e49dd1b13e41e7840e421038d7ac2ff24a56533d1c95915efc665d3719ca14855afe0c0ed302b766776206c97fe878b6980840b8d2ca2e8fd113b2f65951ed5fe4b7b45d91d5dbdbf9ed91b5009ae72176f68944c482078677e48a03265b2a91aff2bdcd3d95ddaf140154440075a7a1a1ac9c0c90936a748e2ac7f4db31930dd743298f4f2540a8ba028622867734828a69de0d27e7c88796cdea595aad14f910da0725db66bdae92a20087c95b2cad20bb24d7cbc5faf7bd3eb8e6aa5f182c7428340cef8b743a049851a5cee04892efc0731c76ad50632b1939f8aff14a567490cb28c3ec8124203be141606cbb5ad942396d42a2e4a9f186af263819d6aa8bc95bbe9d771d2492f433fc03f38e2d3842cf0088bf43c80e4bfef05cbebae8db572c8f9c6553ad55cb30185580fabe52464dd8555e5c87fb5f91b66d73b413be1344bcdfc09011d38f1e247b103e7b4666d9e6c58a4e1b0b74cb70132e6219f1895a04e4ea6fc19183d164cb49003d52fde4a604ab61b3c056510d0c09cb610d21949550d21fae30ba9905538a5eb57975b7e03b66dff655436f9ad7134dc5269ba29e44be0e6d6093b000a30c1bf1c98c3c9cb2fe918f11c3d6ba0903750a5d92eb8e86fe53a99a81c884a88fb86a4b6dd79b3b7c573d103e587355ccde5c6589da1a09603f6ee78c6e56a38489ac680e9b5645fbf133fba8e23048fbcd234da8046e682d9443b7ec7b45f73495368be1448969210622e848b081aa60b76e1117c7617df3f6af1227dd5be67d7b295ed0ab0ad86f782651b087b2b564dd90eca59bc2763d62eadb2e8c52be3e7bbbfd9daf007ee9e7fff18d8ed18b2254c2b72741f3fb579cb8004032a83c177c0ca0fda51fc346599b30dad38cdc2d2ffa68336554b79f77d75f58ad7dd7242da9dbcd9d930f2d6a548f497d07ca90cee1b3b5b68c0b34e822d778d845c0c515c1cb98c8bc72a6969f4d0819f7dd91d7219414fe45b1c297167f786d4f18f018f6846aee890451315c1f691f55ab58efafa90671075aec0069fe7e87c57a054844d871d901baaeeecbee379aea4cab3b7511e40392ead4f4df43aee39989f4a018a27c70cf54cc96b1969eb27e610d99e8ee412bcd2ffc83c83449c3408677e2a8ee0ed59f8aeb5b4ef12be25c77b7c3ee62899f2072cd68f6bb18c2b5014ffa6bc573cc3631f132db773f0b4e9f6d48c723ad56e7df195e89f4390b3a276822741016def1b0cefaf80b347c43e9d18d3150e1f9bb3215e106a30cca1a07bb7e9efc94f8017825c5c3cee969c3580ddecdd390ebcae5a72975c6ef7d5beace75efe7140a50703794c37cde6be192bb6bf097370ae378f78b83ef3da1814cd80197d536b6ddd34450f5ef36346654926ca0de107af2311e089f28b80d76617cead3a72b76cb5d6d67da327245997f78b5dbff70f758fe5693122a8e0d75085ea4967e9d5260edf3c10d51722b08fe47bc9aa1a35b7b0dfab2f69aebbbdefa1375a0b618fbdaf7f932a58108d3f9917f31ff49f05f65d391db48c37ab6209a8568dac86fa51886732916ae35d61d95301b9e71e14fa994b11b1c1602f88d6c4dfef4a7bb37ec74ae1b7d99ccef51b0ce8bc9807e8b80a1f3323e837653b4d047fb1444da92af4eb00b4ddaea44527cb6c57286824a05b95b76e78cada64f1e6491aa4913ee93fbe1235b0b810cd3de6f115f4bf6d94250f45a29968038814cb49d582d11b5fb4ac2a284bbc1271f85fcd0a50c5f7db780f1cb98d71037a695a0a3e260f9053694c07d069abdf814c0dea0d13fb4d22fa677e334078406f6b7dd2180ed9cdbfc46889e176581c827e4c0014804c071e085b7bce41dfe4ee60ea86e0b390ddfee5064eb5d3e55f0ec21c9a5231394688fbf1091b4476695babc4ff7dd1d20f446f468e35369b33ff1d1facd1a4910dcea60281628a99fee842f3188aa9e4d0bd7e0e3d25488c2a472bacfc99f53ef5ebb04c7bab694744dfb21af09dc508ff09e14a3c665a3cfdd8dd3764f6e62afdf9193890ba54ceea52c2893068caae89757b9e06459b6718f73b25720d13917d356df31058e1d2b67972f0c45d9364ac8d6a71426ae8b5ea8d97848a0c0ea3af164420c1a3e271ddebd905dc6bd044ff67a974a7160321ba196996ef780ef801a5275b1e09a3cb51f08c8182d8efa991c413dbb0fefe48d46bd6775579dc8b52cd42e5e772cbf54c9b55939ed3ef5dc038e60b95afdf254db545a4b53ab44adbd10fba14f5d59ef16dcf440942fa8f8023940d073474f701a14e1d4438b68881952dd429c3bd096ef05ee6c04b4721c47967ad6be022839c77c66398ccc3f83a639f0611476ddb4ff2e54589e5a8678218613a6c0fcccb7a367a351ee083c36c0a0f7ba2ca6bd4cd450337b3f5ca0ddef85b366100c8706e411081009321be6ffba5202f6ee2d7309179615a0a1b5b60a33bce3382189ed2b4ab11f0c1dbfb36d50f2c4fa1d35320a051f6462f668b79d9f3262794b5d2fbe9a90990cc2073044cfd7d5927502c3235a85a1d83bb9c481f6fa5a810f1f383adb5d2e46567c8a2bd285365808aafd63a9a3f4e4e5f13315c6283d9572d8b2ad76d3ac1b5e4f7cd032f50d52bd056cbae8961eae4a0acaa222bcd8d242ce1d21e24a8b46766e1da7d7274de0e422b24b00cb04dd301a7694512fb32c905a4ef72e4bf05ff1fcdce96aa164f5625a3b91e8f6eac7e9528b56e3c5bf71e6cf26202291beb0dbe88f661251eef6cda2b8605a03dbd9da438955b884f5eb782a053e6aaa9aeb627f90321a724e23e5465a6689b1f566c8ebf663783915de30e5894223e3dd07b590d4e23c31504febe950e0118d31b9c7c4c1c6e6f66af693246bad43cc1355a393e26b7d619f68b48af140fbc68ff12796d8cf799da10cc91412ce1c24c586cf2fb371f6c0dcaf07c9f8e1b27e4757f99ef7ca5701d2da489a11646b25edfb1fd35f125118d89ca08582842e19bf79b3b6a5c5c4c6df46ce107ce45e7ff7b794f2c9bf2633989a5e95673420ab746a0a358b0c10dfb4051317202f6b6aa7b724f039f8cc70feebff7855301f1b9ad3963abc41722b29f874d9bcb1d7a87d1c7a07edfc4b437f3eea5248dca58751e58e23e011d0c2d91bfc8505755f2f8e2d2f23c03309833075abab947a3c2ed5e91da3b7a5ec723c11a85f1e1634204369353184a31e8bdd42ad4e6b4cd52fdce864425813e3b36ae833cec29723e5a9de9c436f538cde051b045fa769e5fb9ec07bcb98956ae0110efb07be557e33c660e545e2829a3ac1700325f21a1c45a74098d053f0dde8b42821bba5a49a5936fdf9e72ec168064bbd09e907480453ef3bccca17835c56ff62cc66839f3b4f28a3b968c700437bdd30d2790d076109228c2cb4e246963cea957ecd0cf357cd7df48f3e2fd53ce60f90fe29ffb06bb1f375614a05d3cca31fde78f09e652d10b331eda184409b79fb20db266804d7af169e05f1685cbae2f78b85649e99b1e94e0c86f9ec782966d49ef405476df917b72aca407a484dcdd5431783d0416c01c2557242859662f4eeea0f08a9ed8de03dd99b362a83797ed391c8c6e09929c37e5ec7d0a388959a0127a8ac5058e8d7c295464e5cba5ae3494bf5dfdb21b8723a12f7a65591e6918c8da2e6fc013ea0fb42a977fd203e8d165ef53e091240c90ab11648e29a09adc4a3ed144b7d26a1afe699d9150f570a45aa991d0994be3ec91f0e98458e3c25243f3a345948a391dcf754ecb0318055e5537e954679c488db09bc669ef156300af763a9e9b806806d8b4a1267858b5ebaea2fb9a90f4fe729769fae02ec448c77fd7744081fc56174c9c969083b108e7aa78e3e11a850b04a508a220abc0a9765cccfe3af317c10124c21f7c61551c55fc740a83f2cecf1381e54f20a2456e878636cb29252d688d45a88a4c5120c8dd9e5dfb268411b02395f4f4069de332400450ac5bf3ab0661e2d4c017fb894a23867a3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
