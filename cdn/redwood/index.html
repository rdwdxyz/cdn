<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c03a5c39584284a1cfa659b12b66c9ccf72eb49b1124980d5fd90c7cfb0c397f89912b5fdfbf88512eaa0feaae81784b2cf1c45de6d28cd27fb209b439d5da816eb1372bd95a6a95d4b60d50e835126fc835be957e79f8b74645ad8a18a0291c7b228e971919a4debad40157285f18d06ec89952428261ae88083ef0f0c72a0dd3222745a799cceb524954f15b82827ee99cee36680fbb273df9ce2270c3a611b3a9f8620e2c567fe32c0a1eb9fa2138af78db491207a3bb577ec2088c1a8d6bccbe4017c4c333591a1aa88be3894008a0609d85f9d5b68ebc5a33404a60f502605e8f9a211a5f2dbb75c0877c79a8ffd0ec310bb96b78eb25e9ced697738b4d5a2e9a68589cd8cb8f1519d3ba65acd34c9b94b0e1156a5bd9b572c91be1f25bab8dfe6530557fec4a694adf58a4bfe34a1f245973d858639637922f28edaf273ba3222810497a91b56fb59cc55aa6fadec40a2d626603f2c9c4ffdb19cde5c9df13f1457471e043919b43c0b4d1d02445d43a34c98f13d9855664ac1cc02775be7f22fe8dad17e6d9cdbba599dbf7c02ebacdc8cf82e563a65ef12b708f2af79358102af235a8e9083c0d8a04e5309cac5e187ff4d30c7c6a8eb5a24fed39cb397f48b3fdff2566d6b219be3fcdbc6560a27404e5860356a76f9a0383f4b5827077454602cf56606d3db51dcffa1cfd5a44fe95ed16461f6bd2d26bc375812ba8b0747a66a552608503c5fc90d02a4beab8cffd7c6f3d0f70b77903e452e1f6a42d8ff83e2a20feefa861f79283287ba746251e35b4f7f6f83484831a78b4a619de34327068377fd065ac1c35aa0f74149a4881171e5047955fbf289c232f279f8645233327d318e9080bf9f7fa8755b27f95c2907842704f2d24147dc8d202ce90b763277fa039d01caf3108a21fb24771ca2ec4e0d99b03f32458c559b7128e7ba0daed1ffe835422621376d49306a3ff8c9a00acc7b3a9572398b382023677b156c958a921af29122e5a48f1d2e58f6045765feea5b18e0764785e75b9c23ef6697da1b2dc5a7a1f37e6c46e345c660cced601333968129cdf75321585849b127f56d0d69212c288e5d5945b9bcd5c4f63ad8e2de4811081279f3cb1fe9b5f1730c05fc94c036f4a645038e8e6dc598fd444cb38e58abf3f156071446b562237dfb9dbedee23bca87be23775e8fb1145ddceac628d9291ebd1cb9ab0d36198f54849e88dbbe0ca8a10dcd8ef7ea155de2f1429f26daaf257cf152248cc6b9f72aef28dd6f4af8d3417bfc78abb6a95d924e0936c9e01ef3d8adf4fb4f557db87935754c8d60c30f147ffd4c902c091d655c8e0bda9d93260046ba364f6cd0b356c9f3f238818ce6040f20b1f9c84f30abf0b614f22e80a24557d6228a9a455b69942f3eb2d4fa1be502828ddca3c9dea713f7f80160e3d20c7b27080a40641c3618b10c699a909eefc76bfbe7200fcdef3096694cf447d769d0cf00fe792a1affd25ded77f6fdb6e8477dd01fafde59ba24c3c0d9cd90d67fec9d7d040d6970af939c35b5e44de264d04ea0942f1d98af8ab78186ed1845a40ef66e89811ca7b37d4cc9f4822e7cb8ac64ab4d259979918c7e0f9b32814f207d127df0a69580ecbbb2437459c18a66d7acdf46a07215a9eb231f5f9f80fefc40b1d1b4c944dbcd7cc662226a422701a04c7cf6272eec1cd39330354e57e75b8ecbff84fb70e84725b66a72e4fc14c98df0ee1f594b9b62f4897d7fad7fe49ce2aa764d27b6e68f947635b977088b5ebd07636ce9d189b1d6852d3a79a86715f38980c8fb0805074558d828ca4bbc018d460f48149d72e469c8330777d2c15e7bf2fb3c09cb45e4de2fdf4e8ba9c2bb06c34d9814bc8e597aff1d2eaaea15473b98a2ced1568b73d6a05a5391c392c192f2c3d7c59df536fff2ed98b7afff324ef7ca6974b8c27ac4cfc1585c7a898e435d7c083a624fed1f36e8827c545de6d36dab723fb9e175d1f85511b959cb9065696662bc36cda384e26d5673de980801c6be9f616ea1adbba5aabf5d5be84581b386278501325522034c84abf962fd14236f93cb1078132352ba7f6dc3b63561746813a87e9ce787664b019e8c1079ff8bb003d941c3b5bf702192c9f2375efde6de8ee2f9380192926c98e4da68876052f58af1380235434476b4e38ce243c451a7f1f9f2923d9518e328ccc8ce931c50c03b3cc0b43ad5c412532200fdf132b01eec4353455eb47bff3669bb7098cba2373b208ce86dec72d26e1f4b9d9eaa44a66ed82a9a79593ef387254c99db3e6e26ba6bfc036ae2a1a935edc9489ed403a688ce6ab9fe772beafeeac3ae230b343221f5eec9c2a16200b2cc6caeeada7a1f31501964a375981d731c31d4d224f89aaf2586d91ea5bf804a9235ee4957e9d705e16f9d32359b72eaf3e4c5cf3820e24a49a24b5fc67054d98138e0ad6c5ef6bda8beeb47a452cba62be2728b9afd0e5a2c429af9a2eb38c3008db87dc9226f5d19456fd8b255746d0fa45b37bdbd317c75a20e43b12519e21cc88ba64911035d0dd1fc5ceec9b7abf67530bc7b822a9f5b42ac3aebe38975636a5ee7b88dbd0626adba14d9e98d740127122bf12665c0a7d6d0cf69660eb27a5e28ad69e5a69ae3ee7d9f37ad6b83abea4b06c76f7ea3370d8979632b4b52e048ca7ad64cd24d800b58a09e211b1c4cef50998e93b9fb671163880eb135a71861121629e9e2afa558b03042e4b6bf48be8476a4a3ae9c2c6641f13a2be016fc602de3ab09a7cfa8ef36dbf45caa36acfe43b49d32d3dd392545f86eb1b6b58f0eabe44673f5ea126dfc4a9c8ba6690048b37b3c0cec421133c0972763e4be5a9eb85437947f37a7e4dd9092e626d5d351cae04aba1bbd985abdec47f5f9b2906e5989d2b9acbac45b9d35662b4b0e015dead3b132aa50b478b48812527daaf60ca88566ff14be4be394bf45b20f82190814359a4027c0e556009b1763f4f0395545d8ba71080c7618baf88061f3cbcd4dd950ce81181f9905bbc51b4ad7dcd5a6878d14da2ffa266a30e51596f491f573a10552b1622f46d54a56a01ccaf86a6364b92119c0c228048a7bfa536416964d429e3f5e4c4a83874e477734e330a181e2fbdbc4e0c9f339dcc529a5256860ce0e79ec8d9a1134ece7b113bb5a8286c98b010631dd7bcd2bcff494ed0d2593517ed7cccc23413b847263693c27e965b459f28569d6f9c4376b873026766692bbe253c13f91de9a62822c88d4b2a48ad560b47537d23e0abd966ee1b8425c486a9f65810bfb2e244768f4306ad6699dd0e6cd76336785abc9764c5fd9bc75c23c84f9f541548285f4d38814a283ee3a7ecec96460a420297e284442efe396e5a984791f9d05bfe9bc8d3c0196863bc0d1143bf3877672810c8a1031a65df4a467e87d8bdb295753645c70d9f1b0bd1c8991fc16fe8b45c800981fe70b434942b51e4993577531e1cfa88875ffe2946cf0de9214ed2d9685a98f37bcaf19dea4b073c3f50645c1b41db3e643a2042d3e57f2a37408891c969c78b357832b869290e716337c48ab2890ac71d8567953f5fc13d1876349a5af5123a7a474a82fdbcabb158f3310d906f2378d161b709088c1f2251b874e1c263971b933640923d47ff387b1538071444e1b97a8ee131a556fb07ee28cbfe8f331472bddfa86ef65c8a56e38d1db174cc44862b2cc7647bc00926d012e55fd9399c5caff9367b8cb9ff57c3af87cd014c06264009b5a45f268b8ffbffbb7638c884b0b27232bb9c71c75b58e767b17e2c7f1b32b901a853e3dd9b82c6545af5ec85138046c7a2076737be3030195e6b7e4f7fc6f50bba6a087dcab7dfb6a27d5c0ef078c439af67fd4dd12338a86183819e178d4f0547f75287cc977b705753c3eb1438cffbd57dd478d7b51ca53d30b478af81fd421eb1ac67e0880b142a6d6b46bdb52e71b88de3c9846fe0f2cc42e01e9cdd67b53e87e8ec7dfe18fcbc3b4df3bf74ec8a0d34d09589e7dc6061bd5128fcc308a2a881910410b4574acb0e6712e0ef21e975b11da48228e935d826d4ec111ede8886725e77641377a86e437fb2c26a8342efb6623e532ff8b125370e5a1407eadfe013ab5fdb909629b3b399899ba942126a129d1703144400345994d876e90670014ef8910f6601c916300bf0681a513ddd48c7a2bed646ec25083945dac0493dd0bf559969d6c50ac93950f3be99c5b7880c4da3641ffbce1ac49e2841c711df42145db8072b412efa7dff87a5b743a89a9a2151b32a8d8387a3422f23c589fc226b09bf24faa407578a7a1349d5158b2f4ad2de377ce5e89cda401294d33673d2844eee6d19cb03e7ff0cac3cbc6b98c5e65903c7551b8bb185dec29ac070265b42574cf38a8de14788f2ca093b106b559bafad91fcdf4ecfd9b2b0dbd04f7a85566508f519a6ff7f1cd4006c618c4c038788fa8b05e1baf6a6f9f7e2af65b2c99bd29a6e2612ab32933e6ff1010f9a5b755d6d0dad5699c2b24b5a1b29ec3cbbe410b059d1d15ac23605aee383490de84a43f78e5a6a8625d81af377d886a920fa9f96c3cfb7d7b1e39d39f30daba80ded60d1520ac6b6d88423cb44381366f3f32a8fefabfb01b389350a8164f064210e57e2dcc0096cee2e6a2d8f42f8c58e6b604b2f0d5b9b4a03d9e0030beda16273480209cc4718cb6044eb7b3d27753f63efafa1bdbb031e4b8a27ee73d34728e093108b1eb91d52db254e09f6f47a739766aad6ff1997f8f3660b74221879c9d32e1d4e67bff05870254d0a3447d3a3f0c4130ba07f727ad6ab13d0acc158c9ef7424bb7bbc5f95465d1ebfb0c12ce3381dd1980ab09039b1abe6b16e742eb8c627e3b11d55ee3d146200aa5d495afe48c4a82a6e09d24fea0723d70d625e19e51c04d0d36ea2a55d80e6e2437554ec5f87236cbba5a30690e47bc435e7957a7f77b988dfee3d47d429fdecaf9679573843ab5fec6e8111ab4b2b7275a15339a3fc37d128e2117cdef385861a87867ecb6ba457c525dfd5fde0c54c6dbb509973a0688aa2b3db57c6bcbb7c9339a880855221bd511e2c16297308df9242595983ea0dbe7349ff01fc4d503046b186a47d9e2ff8ed1f00f126c2c3e482aa36ef936136cdf871a43fc4bbc6a77026c20bd13f14976fba8ffafb4c02a1f2cdf2567404e9140f59f80450745fb91e7a172c30830a1e3ec903d4794f939c0d8e33da20b548f9dc23448a6c88ecaf42bf5ed81fc2c1dacf7d918e2a4b9fe08671f090e42622ddfcfe5e9287f8a260c89a826bfe0d28d0b244328ebfaa534f804a5bf8280d01714bfa48da45c3b14d2684d9347217b164b3ee5d5fafde8e00abe3dd236107ae10e91ea63376c93a693a6c9d9ec491cfa9fc0319811ce9f30f5799915acb28532c1cf19f04cbe58eaa10aa1fc24fc9a378472f67d773a94c1905b6d2e418383b4a1f0df36738b571f73fd8cc415a7fabcab548bb8fe831779a73d929875508c5e43b733c97a0e1cc0729102ab056209eaa493ad98fa08ae59206238846f4fc36d868360ccb92ef15034f4bf02072d22c56acb56f2c048fb4b081d59e3447925714f80652a23282b706b1a535429dc46b852c41baeb94875bd04d148b97dd43dc75ae3bd92c8d0e71cd698f198e600ed59d3b6968151ed34400136fa8bd77526cc203d495b65701ac36b28d7e53229c5a179d52361af568f5d0b95c5374a6540b5775476d286a2b469dc4fbfea3811c2999cf1a553a64b9d439fee9b14367d6e4c4208ea0a6874ee6776059e9872de5b8ed13d626c5bfa3a0805e165f512b59478836f2bd3d96c64b996afe4fba9712b51d420e79ffc2ba568a5e6b1599426954d122ccc17bdf4f643205ea7760f6666f64984ec25973bd203b9a35a4364d09ab37f449be870fff05f75547245e3296d40e7cf411b5eff1f9ab3ccb274abf324bd37f204c7e96826df01d32e57bcfd6b98dc3e7fc94b916f693091faec2b4e58839bf92f09e9468c748798dca461b9397399b54c431bdcab5f76ceaf39e16e99a8d7a0835fbaa6ba3b745deb241ee700f5b6e4255cf7210258a0483d313d0173e136b9d23f6f97b36f67a26988a154a3a129dbf5635743fbe6a4c6584d0728b9618f1627fbedc702923994ae947325a94ba33d7ea5bc6245c0a726ac347f9fd3285a8b57076357e7b8243387c0367dda66a95b4a1156b0bc609b781d8cdda84438c4d25649d08eb3916778ac71c7d941a3c03a827559f069b403036763ee61a94aad92497b3e1c7223ae8621aaac7cbf3d23763cb8cf4f8f419b7dca4c49b707281ec482ae83bc5ff6fa2a0a4d1953b921cc4b2fcfd9ed1870fa82357775c074b0eb7a721e69cacd15efcf91b2518d4883891e5b65971f48825fe14f7d7bbaa32f31f2d3f226302ac07d9e46ef3391bf621ac275f12d502400baa09dfb0b255d3a6c3a4eaf26642e6d63da1022543b5e5501b83be99db30696f852334dedae0481dfd333bc2303a60329c05e64f80f04e996899e05e76c220433ceefa655c0e44b3a1f72d28379fbcc4f6d92ab030bd1dfd8dffeb622edcf11752eb2b0c92208a412db3dd86f79e0dc5878adc925752f2615d346afc3beff6d36fa5df67feb331a197a9d1884e60609cf783b5e308fddaf48d78da3e6b4966b71d76873798629ae406b2d2a6ebfafa8cad77c03c1e71ea0b48368a40ec9207cd5733909721b7d4efd3d64fd20820537fe10bd4b7fbf70086e1deb365a8f202bd24b596b06b1c1a2364ac96278dfd2702cc544ea7feca7985e7d34b76123a434519033d51cce35a83117ea3e0a8c9f776abd8de0684835e0d0654e0672b10aa7558f7112f3c7166891f9819dbe723e9e91ec618569e2cadcf7ca7da91cb84938401c138d3c19cbe98c74fc4f5d25f6e55b24f7fb2c8a28202a3b75d616fd13607113ee8fe1c99ad38fbcf2ab4bbbffebc07a38f3e986151aec69f9a7345feae33f8df894095cc2aa89c15b557a8d22a7673a9fd5b0fa185a597cbeef32211f7029873a1c3c2942ade62fc967075357ec2c9647853cd0b797cd82e61ad3d6dce84418562da7452ccdb907a0300717b44de16e156a7aa866e172775de8118f78eb0ca5008dceadf78c49b9aa76a67f1df7b3b94822d38bf1869cef7f072071058fe0fe74ac70ebf36ec080fb984ff52fd0353e06f83ab1cae60127b55d16ae05717842f536feaa4cbca12a8eb0bbd608b92b4076fd3621efa30a2c479d88c88736934a4e0f241355f1e9add038f943c3d3d8297621dbcf2e25b0d999dd425c09e6c0cd7c702ad40416d646c31ecb831e8fec399d9af0a1f192c49f0d20524c4cc84c1e3e54826d76ac7841dae59c7d732bb97f975316a8abc6085709c399a6447db14053b100145926bf9e63e484cfc60539e5798e79ed8a11787710a47760ead1dec435f784cce1076e856c022b46aed225d7c19b3d7eb31f5634aaad62c5468dfa8b4f0923f655275026789d5be2eac035eacf2bec610f42e250fe3552391c16bb0da5ae6ced36ba5f7f8d784a4948cbac409f4d4f299ccce272945aef9c68430cba3b78f3eb8ff8ba90478aef8261c796e3429f9504cfa76759d7f9f4286a69708932f9d118c9ce744f51a2180a3b603f5a36bb50c611ced9b6bff5b075b695970601d32dec422b70750fbc44eff80c51f305d69367d381987d3d7392a732bf13c3c907fdfe6131a57f45e4851d35cc0448d4f798fc6d66e41360b2c86ff21f3eb2720f46a77ddf3cd32887e1dce705e77cc525a8c8dac5ef7c41f5c0f49d3e2381ff49593d1ff25d9dd96f0366dcb6d9d38cb7759e9d44d63b5f33c2c14762dde6d64e92b725a41513188c0c7a9773ab614dfcaa8e80715b8cc3dd13995d29d21cab26c40c3d01daaec11fcf2d5ae39ac6afa2af8556a59b06a2095b2fb2d587e0168f82b78cbb98bb2102da9c21cd6d43096fbdadebcdf57e46b459afc76504f0ee7a2e6a438d87db00d22e5f0aa8caf1759c9ad6478f8f688eacaae8a53179e0f571306a09b7ca0e99f81665c7f777e67a56a126411d24c3e863aafebae59ba1c7a0c2ba8d9974fd11aebcd767583a5cb528f284a617ffb37e86ffac18fa96fe81119044cca5d8c0dc21be4a653e6d998c46480a50006a964d81bd73137868d490b98dee9d175a35910d6f47e824b970e176f9dab743557563e3f38dcd563cac0f3eab84a6cedf8491fd1c9819959911eb5b8ba73e0781c697296fc67b64ac43e8232a23cc2f279b7505f97ebee900140fb6531505e4830ff15164766ca592a07325d939da5afacc1f6d3033900a80b8fd3d7f0f26760bb7a6344892cda7e7ad405ec78423313ce0a1f7f8b71db44b75a04965c03b148b256dc876cbaa8d53d3f50f1084ce983d048ddec4a34f8230824f8760ba0c1a912a272f95976f67b41e207ed9f6562a58f87efb1a1847043a00f5481af8f1783ebe1361b681101e3ede8962b2021bfbf417c9cdef05085f34717e026b75e080c901641be138d19c0803334d26fcce15d21450b89a8d9b1784f20255d9b61a86909df73e2579ab1c7ece7bddfd413e8e89074fc95a47e6489047550eb1adcd9017c2918370c8667fd692e3c5a1f943112a6b52c5817606fc13d406e65d4dc61391bbee9bfd0ef3b08b52cd2eac699483b89436e7ade808fd0cba5a5dbabcd620e9de8358efb2a368a69f08e1b044399aa0caaf266690f18b3a61cfc7f3417b3345dff63c6a4ae58f825d896ac7df569c2b58b561a948a9230bb418d9b0eca7e87868ab4e041883e3c43218ea4ffd9ca525f2f4651241d2e8a44b630f8c7906e38824ef164ba4e8d9dda2c810a69e79f5240eaa384c84de16083a0d706bcea24b9f1dc3ff6f736ceef293658689140bfad532a2de05fc82f47b65d47438e5c8a21542704c6dbe8824b1d6cac6bbfea052d638fbada27724340fddbcc350eb131b2fd016d6d562642a226a63a63010dada57ce824304c6299bf313ef42b7d54036a718f10e0bf47e5d4abc1dc39f2ad5ad72c734f2b062843e6cbb6b88059b57515408b21209d8e1f77125ea579cded2f0ce0f153d8176f1420834003ec472d5fa56a1f88059421a3f2813934ee6a847eac3e44f067fdfa71fc95e84047a1afd3e992b7d2f43435ad617fbbbe308c1901501977fe506a09d718e44abd43ab20e96bcee3ea834ec8071c95e02d06357f7aea7ffa688a631b4f327cae9ba620ab6b04aac9b9155f891edea6d673415e464967ceefe2425c11cecfa250315419c726e2c472b848add79697a038a26021bf3f143124fa8024cb2460275af9167c7d2ab6b0350d050867a6828c81472b7de7f599f8ff77c07021bbd35db107e09ab8f53198f34cb26a0a63e0b57f598beee68cbaf3509ec128b3d0b09b8a1631d82fee98b67fba5842377aa799503e0db641239c177397227c22ac723e63c361cd71f233b37af65c71c2a268712e925c2a148438ebf32f8d7c59f507fb59d705f4590e027b8fccfb2d4c89397d812400cb09f5517cf8505bcb782d18515441542fc9dc20579207e54409f5478c7338a8cbe2adb5f78a08c54e176435e897c6c297e458b129828c35d3cdbc054c8f3b2467de1340d8d656b76b1de3c3b1d10712ceaf8736626b114d595442a4af33d9aabc03d3185881279184d193b648b2a6050719b70f2c33762750d35d7036b415ff3d244d31294544d3e539c168d97cb3e9ba6b40e8d8e26d7d994402c52ef95259681037568571c3835528a733c69426609ad94df4bee867a4c6dbdddaf75af4bfa215ca9355dc131d4c02b03c603a7de59eff4f2cd68f84b6ebfaa7398cb8eeaf07cad32c5742f6c2f0ce7e2595e482dcfa272871ae7c60b9985a54d48f91a5b09d60525879d4f3c9e2ea5562911d44a81bbe983fa90572e88c8c261707fd4e94ada4ee079edc2912611f35bfd8e666179a05848eb3d41653ee2eb2bacf7ce5829b028427864bb9235a56d5e903eef1774b5ad9eb5000c9e27b6685c4075c0c9aebaf152d4693a205b503695de1a5e34668fd9111d7ec36b99d5ec2ad2e766afc6d7b4a7d4fe9444b417e31f80d070fc4d3471e6c506e724ae3fd733be350eaa25c2280b733c99e2e8d02f059fc905559b53a032970d1757779fe6a5f66daaa83802f130595da73a49d949b29cfafb2374982bf43e88a90613fd0f4cc32c8803759b50355dcd7617fcb7eb43bb163463013897e78c2900ec4d0e4422ed158a47e59b39ef937a646140f7c126f7e2e4b47a92b6da7a8ca9808da25827caa77a06e49bd9826744e818c5fabf7819ee134bf081bf2c38776b4ec75da1ec96b001c7b1f37d653a6ebdf53efed161c55ca85f619adbcbd8de13939db4b6b1883da6697ff94340541de3a4288edb9c3ba6f91cf07486dca3ecebb1459faaf0075a3968e76123aa1a86d6e727c6e9e8eb821a151a33ca4395ca9877dc264be0bf9676c4f0c2941d962ac9f309d89ef8b252ed3b8315627c6a95c49e2ec04fd5c228cb75458d40214fa35be99dccd3e53f53113839a8e12e2c4ece9d801de821234ebc44068583da2da751d2908a19044a160f080e7c4c8d55d69243934092d86296dcc8793aab47242b0fe8f374149e61cfb1799b4f5aeaca7752402c9254479b351957665d85a04255cc7bb3af04e4982db4f8e426c2919c2292d5937128a54f0274759b4b63f5e87a9d840802c3f05ff91be6f16e24797cd7a39a03acb13579c8135c8c75e0ddc94d7e4cd12efcd3099ede89e42b1e5555233c3d38bb6336fc001832142b4f400248f3ffc3be9e4d8361325e4ee317ee1d8f49a88363536c2130b304e8bc15f8342c54c172f377f73a17467107d729f188c71085eae03c3c6e7a939e8ebab87599ee589e0159de6f8ad9d9a77f0446f760eb9e7d510f8752baed663a7de8546e15d26451306ef48839b86bcb1adffaabe55b3530b93839abf41a5d36151cebd77d3bbeded5573e2e6d7930f8b2eb811aa019a92c934a8c9a008c58a2dba2db29617a8ba6be5d0146af5c1f8601c7d1f862bf11913c516a5a0542010aaa88a4f809d92cdda9e8e5f4e1e39c7834c3a9558c8b8e9280937ff3707fcbfdae6f080b3b647e6d709c23c84cbad6a4d1817a93dc12ebb679a73ea3cac095dd630f0b5eba241c55e11284ebd353edd78b4c7909ad7829651c9a3d48516df87fd5a7b44c6ebb1b53fcfd78fea8294518e15b9db6c528ec7d9022bea859ca2a0b275dfa18ce6663a615d57dc11608577d30bf209f072c9bacb1035686f6cbe763decd5445c39e31a88899920362c5489876bc31ae99abd6c4fc5fc693c7b46e2e4e47b0bb6fc694a51aea51fdf5e6a2af0ae3e253575c2f2039dd63872b6bcb286d48f0b9e5b4a50d5df96847244f44de4e9b8b2606a7d8f069aa005e2976fbe73193d5029f6a89dfd6cb35861bdb55e2a91b1e2836ffa7d80c5e41e7647b475399b88d01ed52332b90d4bcf21c9b7b9db7de4d88f637037d0450159c72058f6dcd2b623a5a4e00d61654e2227b7cf7685a3d3549b6b7a8176073da40035739d75e582fa6b6e83975f0c23d0d823ed7ffd2e1f4d05ad44d9b31a3eff194061b8f29ebba000bbceeafb5a6dc249e940da50e52e779895e0f8b136c659844c35c2e315e517056c409148bb95cf9d0afa6601539c788dc4cff966677429d033e363aaee49b94da126be050731eec623f7f8c5c9c2f54cdc80583df51fde276dc35356c559b60409f71b4b44ea22d0ca205d6940997c507673b4a007a18ec66fba4b5ef7a5fae6cb361d7997019d92ae2d0a99b7cc6536dddea61799395f7ef639d28fa875dcd32fd0184c9f0bcb787a7d86bcb97e00791e03ae7994659233ab54177c2f814a62780160bfb6e411e73f52818b9185a943798a9d76c9e5a741e5ea9782e3780fc7110d06377ceec6339282bf35acc743a3c4bee7d3f56b920f0f5c53acba6fcb77784446f190ea4d27803bb91458ab0322386b87d22ad04cab84d6133657d78c407e84d53e6e5eba9a69475b59385c25607f9efca8ae069d22cfa328fe578f6d9e533086f150e01eb1c5dfee050e2e7f5bc7167085b8c296a5011f719a37349a8681d83457fe1db2d34f9b58f892f2e2439cb7092793840447f03bb9209ccff28ceb30cf56ea698ee357bc1c48caf0dbb8f704bbdbf98c36e5d812de9a7054679436699e5b33501e4aea348486c75962a48426e689c0107c8446e7c6e3e40e3557af7ec4373eff5ea54bb53ffe4510f8eb4d38958f11ff86fa778d2819b4b696af53ac362b578a1c93c391cf49cd25fbedbd5f43d32f717986c9633618791b0fadeda82d636eb1cea0f0c755335c9edccad51a978b737d1c8ea7db9986b3fe655c005710958423b0e92e40ff35ad23b7f7f501d0833801e59546b43db4fd7d339362035d5fc8f95be51861de010cdc69ea884b46f6255c1b6ee05e4d05b2f5297631f5915845818240148b113f044e95b6e176e597c29fb47dd271bf56889f7c3df6afcf3946c91a1c94729cc3d2e52e11e76ef6f6416fdc1512d0314505677d5602c5d7ac305952eca7fb0026d189453f66596efba2d476346aba7752139f1a142c425e3591c10965a8f58859f9761042a38139f8fd52d239082468fec4edb9466dc0f3fdae82c7a4ab220c703c6cbc27d0f412017bf7638f4f37094f2bdfe0c87f4c13e14ab0c83c4d35b239283ffb2f0ef1b2a34ecc6857cbe74a753f7b9f62639894798fe062d7c87d22a4a20b6ddbc43ec37dffba38084dccc5741ddfc34f1a9ed22658bc72d5fe2a6a4e0d3744fc43828d6a5a2c05f87b194bea54754d17cd12b45d614514f091431eca907a60226cb22f8bac2b1cc904d2799874a2740d38e43317ae6103025b0b6be2264c9082ceb5a9cf164338890dfcce20e8a86ae5634efb3a9b3d00a8939f590df774a93c427dfbb5ebc15dc9b0ec7125c60f640d79f700b8e3ed86fc8617c4bb82730ca24347c828d169a6f9b2089e124adefa8dcbf2bf33869b3b9d782de74c689b9ede5735deee94e2877774550d60734abf615e6ab5ffe63ccd5e6f178a9c46137c65408eccd284c03860234beeaadd60de5f2212f7edc1cf2baf709a5be79d423994c6abfef2e20371cd47480543aa00c261c5f523ff08b765a8eb1d26cd5c13ebc8f1d2d06177d7fee9a663e8727b755bd2fc8c0542730ffecaa9ccca0f5599f1b4bb9e58f6703b63354f55a6c6d25bf2248af8baaf4bf6d668153a23629da71a026b2c43786a98d38f6ab44635b0e2344c539a3f4943a61e026990331ebd2c4c502cf7c9ed191c344b544579ba9db63239c8a1dd9165ad2cf04055427cb62310293ba0f53eca83882a6842ac4431ebf239754a72e6ae33b10b8eea495db3e544708fe032fc0ed1cfc6f37c661a60d4181c4cea73b56d401ed7b254d025f676fb1365f902d10754d8a92861624b8fbf2fe0639d651a6c2daf7d2169affaafd06f52de9fb1ac3c5be9cd82245d6d65718e03a204e12364f2a2000cf283e08aa19c99d0eba293aa525ccbacbd493c90e0047ec56272e3fcd7fd8926f76fe99d261ad610596e938ebd0a340cea9f1ec22354df355d0b7e9894e32917d6f351117398202d109a7d57222df2a654e0a99d2b9f255bf49e005ea61a6704befdeb7c1ef7c3d5db9435a37b36395f1c0f4c4891cc9ec6c9eaf4fe5b8d21f90b9324e5611f7bd98f69f300afc94541d9c6a3f19dce93f8df985331d3e3288c91d3769f0cf66f4e30b66969b920d641f90bd98fec880883c4f9c6c9609d9f20644df017cf61c984a2edb12e00f0286e51f9598c6f61713490f6cb706ac1f32a9f0841e516c23b599db58c25fab796fa1266b705e72066efbbb2b164897043bd1b591d04a217043e65934b1d25e8f3cbb28955843e1635d0c38c045a0375961083b6b6b614ee50315b243ffa6ae7ec41509c254bdf5f7d8dc1b514280a2e6767afc036b0d2eecc3a84b57fb01ff99b6fd1069b75acc3e3557d922c47b535bc9d86971768ce154038997251976aa69a8da9420fc05f0eb8dbd999c803e960895f4df29d257cef4b465f3f5e1d901534cb6254d900697133ffbf311c101ff3dd565d43dca43ae138f34dd1e4e206f8616bc9e0506ad979923bd240f220b8887e25bb761591ad0761091ceb3917c32c7330787855c0fc732897ea4d8fb333364245350d0b33f5d9efbf53e35a03f8594013207aba471af40627b1ab1c8c2d240ce914f11fffb45d6c4c3681d73e05e6c8055efa90abe1f1816afa9afb48d7faea7a6762524b3b875be2cc67cb324bd1ce70da11aca76862cea0a58e358a792dbf05434b85f0a1ec5dcc576bcd01d8d085f86e5b664b803f37db710c1ea6227188408b3d72bd7791efe31f629ad68464e4cf975a4054189fbd8159b3a3d9ce26700d6518ddbc72ff07ad4a84dd1b2e11834ba969d38d5b52a4d4099570416c9b501b704f1f4478033a8f255c48cfd00d6553659e992f5ea93e72771f718cb33202f1861de102921807f8ef3a143d84ea7be767eddca452c287df4c55d1cc9635ee96d0b04d98bbb616df5daf8d4fa6229ef92710c9b77b0c40a46aa314a0fa1d6a5b669861679f65d943dba67d83459c92ea68811615dc025e0c1330aedd90ebb587df29bd062f985aabb898cd1fc9c36382eb561879571846adc9f54071d32e79380eb894daf2714e56df755c08e29f00179cdbe7e239eca93dd64bc6470eab8c8d789f1b3aa50be4d57485887efe58c012d81df56b53156e9f4da62f9ce30b9727db735be25c66a9ea4fe428d502374307e4b46527c11e70ff47168aada20e627b6e5f6b436fd0d706aa50e33c4a2438220ba8c31d6029cdd3c0162211c3f5c294918125a30ebbbdb292c7a3ef78b0a08fd98ce8d7b91a777d30e118f2d51bb45c04092a3758bf79bca5069577217e3972cfa263faeff734c3705ead867b2fc469ccfcfac56775afa0af5a14c80ded9d6f526027f09f9ec86f8821aad2a81a5a8ae3b0429b87d86b2cd51130a05ddbe8446a7b6abd82931fb87bc1457412e5060314591bed66c9cde799dec4fffd4ea82d474cc8fa0787f5f27f06ef196c34d403a86f300757bd6cc96441afa713fea8ae58a31f092e682ed1c2d93162246022c426f1d430dccc8849339a58041bb01173447abe448c2abc12f0d24913c1e9732448fd7b00d13e8df90bd61a05dd62324cb59a7147f7e5a8e8593e12a1f2c27639f00e5f085b18223b8c1e260f3c8eb56fe24019a40b1531553a025eb09040d352d82c04c709902491acf19aebef318dd5c1f3fe9747fa9e111584bb4c466b6dd40d5b5c73f293a9b15e53c302f0c312ffb7deff5fd321b948a9297b3503f4e8bdd67ffd65dc1d9169d519afb37a27aa81aede2864c90919da3e50788e14c39244997a26eff46831e14cc4753c1baf3b1f4109187332b041852e2ae33223738546c92339ce25f60ac912baa574dff7f659f8e219313d825d2158bfdd41c2b9c07c0dd2530f9b69146cabe3396cadd534dfb241dc6cb43486982010f8811d5e6852d9693a6b824c6b6ce1fc8870d3e6dcdccd797a7f8ab330d909374d25f79bfee6fc1affda0fd298f6c907f314291cf6ac4a9db0f790febf2b99c4d9cffa76d684996161cfd3eaefb512e089582af387721583be5eaa172d4f8b8f5f83e1a225b6912768d325cf0d379e0b025f2d8b4350cb3f41cfc316838b2ea1654d4326e808ba8ff41fb50ab75ceb2b5652ee246d9bc375bf7346b8e79550d6c81829fbefcc90a3f6037f4e6d5a2f1dc6e20104ff66f59b130610468744d7df5fdb9794c77fac49293ee56fb2f536d83b847ad1ccef13c2e4d2e815954e9d8c6e5c9685929055c6aa8bead59a2419a989736bc4d027b5ae291c1d61ea9fc4da42ee93816e8634fdb56c7fd69e13acbc086b7d39ab1eb419c0f2cb463eb02a06e3f12a9fa2d2f7b6ea7d598c2a907b1459d9632083668f091eafbd466dd08a3e2d1f8178d153677611c6f43f84cae6c26d0b63d2ec53cf4f4dcaaca881bd51f261efc072db5710f80f0599489c36b1543242516667c8dfc5e1ef29e64f0164fe4c86321896d22e05a5c75303dd2a24bcd8cfb5a914c5a3412e9e126ac8412b9c213f4270772a04ed8173a714ff0c00896eb5eb39807c8f4b0583824d827fbed1c6e1f6f8605826bb965532411ab48c217a8108e58c16aa15146712728b5ad3a726be62f5fd062c6afce4550e7cd5865564b05f89cf190c46e2248fb0e69666a7376d589be58c1767b4c8f68d654d50e783682acb4474148614c99189eb4c0766749d4bfa1af086887648b7150516c441740b5d6658333d1e5e0564e18ee0e4d41c0e2f3aafb4208363fddc54c168c6d06dcde83a890def93b8e9cbf4b696c9e469a015dd50b9387abbae3bde7724bcba7195ef3b38a238d816fdc49a8dd4de75295d58c9f3f5f6746baf0f6367c20aa7659e6dd96fbd30bc9d68db6ea25eece484cec736cd8eced6c8666ff279015110a47a538c76bc5f1e6d34b72202d94c2c1b92f19d7fa6ec7559172b873a5dce6f2771127c6df55365d79812560aad3411eaf438287e20f699dd348b4b5abd54a97c2baeb4a2b1b1b29cf01a6a400b246ec9811148ebf8dc86c1925b4e75672f4d588849a9ed94f60004877453e2df7f9123e05a96ec09cf4537fd50f948c3f9b9247c5064fd7f86adc21935137959ba25d15c109688fa7cee35e67d36c70375e7962fbd25393b44ded96aa2e326b434ff3317687a31a79231576df820216f7b44179deae4dc3dfd49d88fb417d5b5d2b7615aaef8bf9fe622300d82764fbce733fc5190e2b10f98531e632596574296fd95871c4bae27a73153ef811d53437c4f5f846be673ff392c32f3522c95d44e63a8d9965a2057aeba82308512e5dd9badda18065ccaf79ac189d29266a1b5ba77cd25df332b941c0f981863d8564b030b9b075d7b9804327a22278495145812450d006ce01f0f0500ed4f82665c1ddf12aa1023b33a98190accdaf4dfdeec2b75cbc8c1cc8b6f306cf902b13a955f98f62c31f9c5e06f781c84a5c417d1fee92c4f0598f809c3f7876e913f006f115adf62055576fe7f1017fc1131abe2ed6c406b41c65c463dbfacb707c7e6b30bd1e33744b7054ff9e70c599301f992fc481791ed7ad67562e7a2ca3161a061cc6316876a5f4b025d7027086d1811dcbccffc49acc0ce41592695e2cde542d211cdd86e93edfe94fe36864db862f31a71818adcf91537fee46c26bb51531c116704fd30ad8c2f57389885a1d3024748372481c372259d5c9170a7a9eee719d32947b8bf2006a5d31736fd28ddf713ee4711ff46481580c5072eeae9a43258495f752f8292920c11ae200df6fc913a1b9976aa83e31667b3a14a44bb2102b52485f47a3c189a375a11c592b9d690c5f29d810796b8fc5cf0e28f36bb72f047cf92c4ac56255242e89393fada03c59abda74765ba9d999cd7197dacdc76b59d736ce028749f14a964567029fbe534a60b907c72f2a50c6fc1bad23dbf09e3a14d207a2592e0fa163cf9fded84a3e3d8da86697bd081c6705dff9f3535ea7e5a5f8b18b39db2b3f58fbc33fd461748be1191ba0cdc15e3fdefdb1469a89cbb2c13f796bd6106b8f5126707682e4ea4a2958d117a0ef81fc00396be602a18ce4d9fa3c27d506cf424fe8b3a22012a091153a1d81b800cf1ca95a401d9b197e6ce4e2e933763e2c19b022bd1ebd6bd44662154b07434215b03ae5da7e0d3a4f01e52694bdd4b65f1fb6f68e6f639cefcdf10870d75ecc6818e55e3a69da81c9bbc0366d9d03f2cdf5f08ba3d7d302d8f39e8c83d79208f9d8fc5f2b7800b9a3425c41395d536c37d77bd5fc431977a77ebd82a03becb417021809f9c9b949942395fecb42929947388ac84f0e000c9a3d90652af3c1cf4a4e53321efbe3dce1f2b1d3261d7cbc462cfc7efc263ee88261231ad7c5362aaa3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
