<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3f2592d9ba8686e28ca687b3f100aacd5671e5f5c8aafea4e55b6d28b588d9c27c6fb1168bf6c48ef1789eb258f9b4cc10bde738a2b341c4051074b0db2dc54255fc67d43a9899bfaa1da262672664e1a6748dd4e493992e565690da06edc4a7dec9ae38bb87f1b021abb4d9f06ca5a980f9befb77203ca152e1ee8482ca807a49636093e47af02251c9b44549df716eb464db101a8b12bf49b29b4e23646e1dd7526f10cfccde927116d05fc4cfc276356a1c5c95573bc7bdd6575de271d4cff4c04dae446776b5607c6fcf644efece5d22c33a22f5e5dd6597d535c7b926f407cc6c3185f8b95926a0263ca6bec575c957a5c56328442d93e303a3bfdfd3bbc413a37c90ed4ab5948184b05b932dde30c4f5227e6d808a12d889fd7231ded63ffb7b928fb41f10b1c72338aeea24ad3c985708a7c48cbc27aa46d8651ad0a73875a6bb8ac8621ef4638eaeca0d00b571bba42bec98118229b7d9a044665a65c62209005903148dfe7750f69f635318fd18c37c2040eb4595a9a92561a2b57576fa25ae444c2ca458198afc8da7164689d28dd182b4243f7dc329b93fc3240f4d39eb31be85b6aa6314831fa6b5eb52b178d921b911cdb555e6c22a9b7d0f57d8158bc43befd6f2411bb0b09c832cb19bac94296361454fce511b4376ac8e08236bccde2009be19687a9e5c35219b98ef45b09bc38f7cc9461674db3f6def015872e2ae1271a4596eb82dfe6cacfc4880b5d513e90838268b5d9c46e1724c3f6b270f79bf9169053c86bff9f8ebcc0ac7d86e206cbb4cec6543f2f177936c81116ece9f4446c93273dd185f71cde4450c61931381add54fe6f78e37bb5f32cf32077562d5e1370fe1ee02c295409ba33450db3342f3b6bb906b33707677c0822e3b0302a4a50849b9f4e2f23a2987d91651b78f5055f3ae0c688ad5f04361a0418f1d4dee8a3f0ba99e7e660ac41ac8a8139f0d7670e28a6fab9bccf584de4b010c24daa1b706e37132ab945d14bf656e6e4e92a7381d2afd0e95543528cf62778b977902ff46f0fcc9c34fd05c6f3d314d7664605e433c06895a0537036e67a088e8f9f9f73a6291d34447aa66fbeb6fc07f8604d345d93b7837d2194d4ab1b30073a2f6e3ffa41a5819ff8d65e6c00e4f16a0e7744d8a214ee65acdd2c49544aa603b7b2285298b09ea61be5a55609119ef2db1dcc867fe4752dcf7320f8edd117cdd56786c6551386d41d47180413665fcc1c590f3fc2f2beb0d522dce8766beba64c4747bb9b55e2adc5cc9106fd43c1ecc43fb3b48cd126ebf4fa83ea2d02e5d5e6a2147cdf928c3815103a261052a02f8ecddec28fbbb89dc5684813970ac4d162f3e5446974a026f0a8adf9667d9678f0f81211f5056b53c7296f538b756c54b83d9607a7623e07c1b5fb33bbe9964445cf41c3d51e2941dab6e24bb0366d4ad5818b95f31d163c0fc68031e2f96474f2fdb282297f1472136615ab7bf5beb133f2ba8cdc9e7cdb9e67b89de92834d5c5be7f864ce8453e07d65877e79fe37c6bfc4f0d11ce096889c84cd5e9cacb6ed6a99d628f2f3fffe4600f489e33fccccf5738f4651d9d5a137b3936a7b9543a319555aa386ea6ab6abca1149e42fb36cf5ab3b31ca560b85e07fbdda06995ee23aa725cbb97d4693ecf170db73c0657a622465ddb61e861acb9916f28d216e015392c205ceb706066cae1602d3d436dda65caf7e73655900787b8d0b8e381866f7cd38c12079341e72871527adeca785983c79afa6bb8c667c26618f4e7d25002377778f81d3d61ef6004929792b5d4db8e51972b677f0330328a109e7b59f6a3ca8fc2082bd088410df71337fc8c52146073da16fc52a12b96efe2c421e7a9be0408219937aba60c66b2e73c04a1a8305522cb2af077bb5bad901714a2bf180a3b3998ebcc52ceb0f35b6c7d5fde69f3a062beda00e2182509a35debb4c3071d0da3dfecb6c07f45db224b9455b9a0c7d4c252678652105fa2336b999ec0c83d224a0ff23b827bc34c593bb23cadaea60a2141addd902a805ce25f6fe40eef36708c5266c73630d0268d5541f5e931d971760a2e08dd577b060fe3ca6afe8482287a0927c269dcb355f67d6a7c07d2bcb4cb8aa3ea34347d11d27a5beffe197f56c1ba1ba5516fc70164fec6e46fecbad74073e8db8a52c9e979861408385c2a83c823e01852a49ffc42b9211a24fe5a512504537b274702ff6b0d8724254037e52a02dceae4a17651805fafa91be51b466da0a793979b462428ca8ef40282d136a57147e514764d0217b36ecc9472bd33e8add3204f842ad138f196cde589d35b8fd340b8fc69e150001e90186b80bf16271cab5254f25baca21c22521743105f9eea6eb6e7ceba1431a3bd2d8ee09d0a5bb1e955f92a25b738c872806ff0ac86219b52f3e8b0cdc1d58140dca68415613c045edf63fb0d1c3d8afcd81e07599c41c9f7aedcf8311c0f58eea07858515ba5a1231678435b3ce8ac62fe00d7d922b5fbdba89a02e0af6d32fc8f8a8e3c4b36c973d4e6ef1742a22a9c31ed33a0a78094c4adc81e80df81b3ce4f2184a6f7dc10bdd78c26999a75dac055445a9421f264f6f6df33f77294a663d85d07fa8e304cee1ca018eeb57b7e07523e031d6aebfd1242fc0b893102e867d8f61f240400ce280f59fb63b2473a981727be1665adb13bd96bb26cf2677b9047c394145ad7f638203c4af88d35316bae3d9f9eb3a8b9d29f7dfa8a1aeeac3e4c484f049702d2af82ce3174367feb11395c70860fc4bbf7f607be6c66e50e419f4437491327a88a211ae313e127e2dce8b844b17d549876cac0b503f0fe1bd7c23ac6a99bfa66172c360a81f296255e8a932385b2a377bccbcd3762552e8016c509ce9d7aecd998a37390db4cb041a25c09f707aec7d101146ae22e1880f3d4f4b7e7aadcb732fae72b3b1119d5589cddd0783f8f874e8ce837daf086421c8bbb318669f0946cf2d81e327e159c1b652fb11fbee829c34674e5f6fc2503a253140005811dcbfb18ab4c33addf0c55d7280dd5bbfdc7c9242908a76e9efb53b49f51171a2d00aec4d33c248967a9455be0eb4124c8fdb31d3903ae1b11fca15bbb4134f9708a56a9cde40b13cff4daa9b6f03bc69236e537ef35e83e6b6d82d71e54492e60e9caab7d0e8535b932a635beec409ec7edf879929402328a8b3547142c0ab4703408f6d291db6faace21d5b3207dc1c9abe0285885066b4649e83a5d732444020b2420fb3e574eb975fa617d8c07ad3d159fae0048ede8813b4e7012c808d85501028aa791ae1525d0b9f463a7522fbba2dee585609b029ecb443d098bb31f430021bc02627ff0ca61d8d8f8dd920031fc46daa35aa102c2f3328d7c514f51088d62a2d80fae9f95f17a5a4b51e25a79d5d0f132c42688fab5507b635fd81cb70081ba744c5edef21d492e194b2e67176ad3c8adff958a4f09fe8fd56e699df7a879f0d4d2c55ee85462a047b3996f9915beb1f02bdab96c9f409e94ff03cc02f58aae6264ea13faa61a7b55b0954033986376e52beb3b3d2d2ed86332ef75b5bcbf14f4a48530deeca69fbd76b56c9813ed83a26383d5510ac6e0e1f84ba6a04869e47c2d3dc774131f1276e183d2e0799340545fec95fa7d47d85227d6d58f997cd4837c441e255b224c993d30be1f3660375f26cd08b36ac7fb8885c710565ab7c49bdee8a10621fc2feef3f6292a23c426f72d28424a1cc5e9f971b99951f6920124bfdf67f6f7006b889571cfc55df8e5d4f5f7371db9b6475dd6ca2943ee30b3b6e640b7c517a9127636bc9dfc03076fe508982d0c85cbc2d97a903d272985164be14b68064e1a0c54c3e79e2eab4cf6e9dd8954178ea3979e12ee18d7d9ac9a833c687a64a45babdd3b609831e0abac431b117443342e41397d67dee88f9e7800fc4b8e47352cd66438fb187eeffc2e377b922194bc1aded6815bc0ac863b62ba566d5efbe59a2bcfda7edc59da2fbf3b8972cb2d65dc659482ace5b31dfdbc093331a2c1b8b12396eb8a4b9491006b7b542646363ea2dbedfa37e6cba4b350c8e6ff38201837c441d431793270a7b0ba97e55be3836ff0b3cc884c2c4ee905eea352e1c58dde7eecc36596664c663cc63f3080b839dead7a66e136c4c4c877471c6d2b6db7a94fc265466a685ac69e68374fede3479252302704948b260d4090aac4647f8b375a5458c7428839f758c556c6c71b20243477277fd6fe222e397ef9abba9ae8c939e84192bc16aa440f96367cc7d88189a069c38dc50656f23b444ef04cd754368b02fde7c6a8c9f411b48b9db5cfcbba3d39d182725e6f8379386ea2130dea693b67556a701994d61907095e6799c3643ffee236a1c56f9ada22cfe21ac317e5e5d3f95eed70e779dafa7758aecf5a99ca4502004de3fec22b1ce637e67a2fbac04169d72253619adb9cd692a0e51c833d5836f63d1556594ed32b1d53d88c709b90e5a4558301f58316d66015400b228e445cdbe456526103c43f53bb4f5ddace20b83f33d846a4f7e837c902f6b6c666c16a7c8ef0b79e306d87ced1ae24381c0158e7098477b0e54ff08eb960ba6982a4f3f2dfd8b6ab354b6ac6a5c9d1c5ba900e574495b1570ad3823d79da25771138145732feeb9c6d6bfad01b5cd658bececb8b75739cacdfacf0d899cca54df5a33fabf8c3d0cb105d8111b2d22bc819721183a99af337d0bd6f658f27a9a5db412b7e88c3efd6d4dbe4a2abd62ed9af180ddf82a50a39588f4640c062391cb2b15611cb06576cb88a81642d849bc1b4b4e6f6b0d99fe7973473c8ea8910a80ed6612d91e02c6b0330bb763b45498a65f54f0a7beb2a40b339f179e56ce22b65b8a15db34a1a333c439c71b5096abd90955380776561d5b8978665de30fee6239ffa25a3edfbca0f91e520ea13700a0292dfec63e46a5186693e64a196465edbaada98868809db6e75278361ab1244222b051a59ed4558d426a086dd579851d3cec9cf2bce7edf493fb97b77ff62a547224b5fa81c4106ac0342ec99c94389f42b0d7170f700fe0aed86ce7b685bcb8b3f6e4d6a4d1eb130093e07a831652fa9bf41f38bc093edcd577d0aa3a0aa177b8c618a5477ba6df85bb70c5d9b69281cc85d92e7dc0c87065d6d10e06372fc05663987c218d0324cd41544b6e520e0f71e3405fbcefaa54545aff3f0624c998317a95f73419e935e8e29adf610e6ced04d7583455677a0b25a17cf60446092cefbbe5d270659d7077c70b5a222088e7249958d991aca13454559c7355aec4f4688c54fa25bb3d5f5907d26c0f8c0683e2b0bb19b80d891571cf6446c0d377fbf988f942c8525318bfa54ec4003108abd14ea9016ec7fb91f4113247e91168277d2f3615aac556be00d44f83fab41f179fe9bbf6b5679291793de3b64e952d48aea1bc7e875a456c1dbb77645003dc01f7fb17c271b049c5e6f0de0346487af0b0497dde18636849f76273dd7b2a096f2d7d5af19bcf97623d27881cfb9bd85dc2cd229076fc29a67e71753de7c7a373a8923d9de74d75d2217edca6f3726dba62bac147b111f4e0b6c3c9fabb6cd3ec3f02ac82e941db3fddcffb2858063d563347ba428af14fcde5a5c4a89592278301e8f9113548df76166d07c8969e61e22a5779a51ded8d569989affcd4e723374885ac757623c82400cf04b4288a98f7ce5f5b75aaf4b103e66b22ef2400562c7fade5b85e5135eb448db288a773bbcf2524b04b0c2a2766226001f86b1be4d9b6b8c4a31e3332f31275967c01cb5e0efc869478cfcfe2e9077f9b3623ff6c6c6a3ec347249d7ccc3b454fc9ba0a7a1e224f9354d199e97dbe500169d631c49f9348aab50a7d82c73f4f9179c6f38fe08ffd89dbc5bb52933bd5ed248e17f9d27971b38a7751eba9d9f1ec8df59adc5cf0f7fa7cc7bad3d391ce8c7f64173c7e3e0bbe21228388fcd8ed7cc92006041292a7714eb86dcf6f1e83d9234ae42ba387562085596bee2aa001b32fb3d19a20e8b70700a9ee7effb82afd0ee8438d960c6dd3fba0e391492575fbc6489c13832f3bf04eca1122a5900ff0a523373e7744ef7dad93d385b3a63e27777b339c385b74062c54d113a1c08cf51dcd976c9aa360a814126e7acc502d3132138a609e878cb5e476230cf2d7fbdb04e3ae9b074bd3f593cf906385fd9bab92c2421a15b5e0785244bdffd84c4d590d8470918f7c06447704f5064159649824d3f6f936651a9b6ce9c62dab55b14c30d7c4edb9999dc08d20392a5521cbbc8cbe5aef33160fb28dc0af8422b2ad26fde2ca30507a62cb7c260af3749baa5574820830877fe469b9ce00cfb70b86f06396d10324f46134dfe75af3da53e3819490c7cb07d288c5045dce2f314d1c19899a30127b91ebb9afb2d36b9d32f008da39c7e99b5c4440217059ab7fd72f61af7e5b0de54cbc0df498da7ae16468a3e96b8e5ec33216ec86ae697978001feb0f18ff214f431e25db043e914bbcbb3794f50eefb0202765b38351c293ef73103840f78c724fa815934271c5e31281e60345c7980eba7f2301ae9b51e7701b201db004fbf0df9522a6da6b827a00b1af9b083dfb54f36f86b1a1e2fa321c5289d904cb877178dfb5be95a2df84fe4e0929e7117a2f1bbf7b1523ec5342f1e145826279335cb688463c5c90fbdb6c90173e35c1daabe3257087b96d85a4743ecec4e11fc712022a265a3d36b9034b096fc7e1d4d5ae8c9ba1149ec81341533a4ed9eb3ff02c9fc09b4db3ee746f05909c9a95dce67b3ea24e08271dab5151ed617ee1ddbc0d56e1e44d4332ce88b599bbf41b7e04b487bb4c685e0403a22df4c479837f298ce3a6d10613da497351e34a218e85cc2db6a29afb1dfc0e0d6e7c5772ecd903a707cfd5da4c7e5444dfc9c0ce913647c58ee4ed719bac2d67c17ef172f78acdb5b4451cfc50fd5b7e8f1be4c5b484eac890ca60cb87a3fb4b5e9aaea241cd8d285ffd631ff877a9150b263df88dae142692342cb3334bf2b755d0a66fd9415774b7abd7faa1892ba9bdc456c6975f5d49ac6ff3e89a15aaf89217159ab66a006701d344b16c41b68afbb3d6f7c37e553203197418861f995c3c07ca4c0e7f143ec8b70a5e57f683a893fe83abe1feaec4ab71b4a30b4577639be1f0cab9870f55aebaee63870594613e68468eea5ade3020c07efb7f0214a31833b232d511dee09b43f3d10f3a2661f2e826794daa71c0e322bd6e30f086622ba512d066bdf8ef7febe56c2ffe9f3b7980dcde897fc81259143d9f189325ef452a793adb7f7e44efc0459bf3e804023042daacd7d7c91b5dc33143bae9650699b612f096590cfe3a89bf0c4eb8672a0b9d47a840911e51e6f28d213cc6cb8d7adacc6b57edf09ee82cb2ee56384ab7f6d542e7ac685c04067dd2bb4d239c002bdc3afe7add8858761e6c4fcb595a442f7357da06bb5e09eb28f49bc55a3a18a4aded0556b189c0bd344bc918df38bd1c609837d459ac42584f4ad793770bc9ef32e0e629babdf9e6fb913970b84441fc5dcaace980c2fd1bc84da0a1fe0ad0871ec0e67c6c746410fe11e3cc9f87b9d18c15fd29855b70909a2dd7611a6393bba9717e0924ae915c755b39a34cb84342f77b843e70e73c1dbd31c67e6ff06669bd3f68d94e1039f14237fc957e0e31fb98f3ce74b0863e951aea9a6a2021b4b078734806f73bb2faae5a2cbffcf5a440515945ee095d6c28ce27aa35d42acedc63cf8ebb9a92b3071f62ff0263a45ea96fefe2eb07a4f4aedd16c27bc94c7d0e1e1a6f2b27ca902c9acf7952d7cc8e58f8ac22499b32f8eba58c7307992f310d75d8a2da632726c8a4e8c5f1a9eef226b05578f0d5e31f890cbf773b3114a92e35d1230386d7b030600c33bbe40e2e099057f8c3a5e0e6b36c01dcfe3be48481aed5cb3c3f8cbfb3f0dcd9b5828a4938e5abc8656184374ca8715f5d973d79383b991f4f208077f61e4ad3bbcb84453df6b45038ecb088b2d149f24d91762f0ab19a5d71a9fa974409fbae63b182661603cfb7fee3b97e1754bd6c840c7bf506f30706bd98bf3e125b9e4a79e1f9cc12ba6c5f651e78fbb38d3c15551f5fc0fc5fd3393ca2aa63c61511a2f973634eeeea1eecf82f53cb53402c953973ead04a8404f1f4116c2a804b209601e9ff60471bc4fea76d2234f5415441800d0dad750fad4358d2782003996d08167a3e7c0399fc594187f2670b4a89f319aa4a731b1ad9f16697a40a7c6b68e730cdf0fb106acfc504da9af87c1b04d784b433e6799796c1240fe447286f7164cb4a456e5ebd372acd124cf9f130ee2a028069d8ad78a372a4cbb427151023d58f6ec8faa325e046adfdb463bd4bd616529f859c0a2f3ee508a61493608814bcb7319f886366b71050dfa1f4c90bd6ac1c535d9f8f6f9d8919772e2bb43ab968c0c5ac6497d441237994b4ac51a8971ed91a2c7b4009ef92f780e8f8f501bd26fb46935440c04134498053f7621d115045e44cfc9c4a660a3e596fe4791bbc91b77b8628126421536e4940741856c30ef1016fe3133a04e5ecb64f7b1d7a9175944f61bc4ac4189b50433906e8346cdc46daba0f0085efcfe5e2a406ce4077f2b1bba49f8fa984e65067993006302109dce198ddb1746120311635f836964becb38789d0c00dbfcd0ef9c4727ed22f1bc9b7898524e82270a8280e2ee76d6bb4b518877370b84c5dcbc5ec32ddc947cab064b7ab855d647e469edc0a9e8ac094c7915afcaf4a0bae9f97b0cb1bc8c0f7070213560dd850628f2b9fffaa680b750bb0548be907bdbe52db0d87f14c0798398f4d4ba688353dd48472f2e67d3d7ca904668f9702045971dec8ad39cc86fcc1b8aaf4f940eb00933dec9a1129d6d5531daff1a8ec9ee559ece6b39c235305dbbf9f465f7032551a4d227ff44b6932436a80ef1c5100b07b6f91c40e307e118b05e46bfb6f1e4c4e4e6b072f96241a75cb20e4c93fcf30a9968f75d8d33c46e33193e1dde26174cf4c1c31a0a7f4fae44b426758a7c40884b78b4ad41fca539a44f5338c94195ac18d829ccc97a5900ea067aa84fb3617a10194e3d56bee7dc2648edbbc50655afe74afd3fdd35556645cb0c939077be5908550bd8c62d373aa53597a5c97945fcc7f1c28ce7b6dda1c1063956cf9ec75cb012b547e4c6f2d79102b18c4e32f2a0e2415d937978051fdb2b4ffde3e2804de0a49492ebc85ea69caeb090215a764ab3a063d8657195d774695e268b477925993ca0c3cfe401a11fbda57ee89add03e944a03e7d74f9e56035c02fc35ae469d5329d3f1ddfe4276ae5eed10107aaac4aa9de3457dbdadceabd336a80bc515f5fa2db9ef6ec110b2ac79b5b94e72d9824074626e4db32e2b6a45e580938fda5ac021cd92e64f00f36ae086d45903a5378802bc5bec2b095cbc4296d247a343e6976cfd067a92e66e3fbf410a13bc98955d304c329a18012d0c8fb3f71721e080130f17d21f74ad63e2a0ab52c05980f8a1a6256f375469ffd421c0acf43072e3132bf6ee12c7a1a713134d715d4e775626e3ed182b468ddd27ae174c86e7e4396ce0fc1344ecf14bee45d9c205f693c575bb9af1b1dfb93088a451a7f1cb504b634fc3d90f49bc3012e350b75588bc832bd1e2ab5f2990de688a89d90e0fe0949823dddbac38140f527551d7256e4b00f11a42e18545deb59866edd3d1a0451a80c2bdc89999719f0dcccde9105c6d2f0b79d630adb0433fcd01d417f87847e5dd91fd46545f637c33ede92f15cb341278a8f2fa9d5ae917557425152730824b0d67c7ac68b305a270342f60b16cf0261969007897bd350c7708041ac14d57f4e596397540156135c4d0f19140ab7684106912e3c32b6c4586c7200d3e3cac98b6ed3e42df287212fc5ae46d9a4995857009ff39831e029a1fe5c6f2938fde237c0f6841eb9591b40dd91fc6d9cf6f5d4b97b480766f9c45337bc2ed7a78caf3e5a8e94da157c1b0d0018a3124e8897f7978638e4da87720df9b32c68b266593de7dcc460954bb832ad328258e9e152985587a6e6d91daef5acbeb62e9656456c1cdc86895a07cdbdb1628aa6a64a7b1584cf302c58dd660f0422c668d85b4569b2105d42016388fdef72d0ff5c97b47ad19c75662ef72f98d3b4adfa915d745c7fc691ecdfd5b1f8e4bebb08bb9d7380aa1ba21dca08dc732228c5f01e4c9e9f97631d8dfc9c1fede40aece19919d2dd854c6e9d87cea50d58e3a77656b3a5d133bbd1d479f076d6f0de4bc90df7c2faf41410876b25cb798bef8367a1903fc07f013af223c7426446cc693c604cade518ab6bf53df991b525d7122c420a83e4dc3841d6e7dbddf9f0541b16e919a6f6a2b055a8b6529619331f735de904d2dfee13a545fcd5ba9761b9228c3014a451a5bfaa65a8e011cd91fb4066ce62dbd116019989f2f5fa5d7c15f9518451c64907e31ad415c92b875b97b361abfeacec8b5653e5f3e7946165dcca107900c4338f6b16cc8b1d69e771cc9c4368ced41909868dd8fd749d194d1a54418d28076d3c33426a0ee1e0b2f3fefd788cd30468bf9449861a90e449b61ec5c8a7d27549f12a9fc5ca8268f8c75ce237419eab25d19a3a65608ec5d61024d9e94edfef0acf011ab963d0f34a84a45694e1a88c21206968cbace6e8e52d398912e972d119f039ac9a4607ff31bec53473504a35facbbd6c36edd09ccfc0259e5944f85d4b7ba706f6243871a337b4dfd0802a356c9439c24eea00d44842dea2a88695a63eae7b42dfc056bb9b2115f1d95b88111ab8063a3d05b9e77f73b5a4fdba6b3b55b758f1772a323f0d084b8c94cf679827e7d6e4e54e59d6fdc1307573d9811f3911457eef671db1403d02f18048faf70e9b11d28420ae4fe25770a15cb4be1a70e5a85ad526223823a1d667c64dfb6a043fed74cc3150702f5d4405810bdbb7e9d2db99393b0f3e7306cc5176fbb8321aa055aff1547ba088df46caaeb8b064fdeea0b689a2f5ee4a47892bf5065cc4115d6dc948ff74e2f4ab6b5a95f5bbe6bb37564ebac097766c4c3f498c1fa5f1992242462e18fc570dd9d311d5ee57145dfc1fcb4fd8fa23f2ca45bcb9edc2ba19f32d8d39e828321e514453e34cb76f416884d1bb8e8046783edd81e9fb8fcee34088bf218001aad15ffddcaacccff67cb11e00709c3735c049d965465f79ba95387160327c3de7a64e5bb4d2a4c7ceb6867949f48eb1c7d398bf8aa64e10d54c3a0a08cc0dd677f2218ae3498f9e62a887644c6365605b75a3d6dae2dc09d61012c83e88182ef20d840f65a6c0464389f248ac198c3f7bfdeeb9be0a23ba7871ec6f93ae274af976d0ec6a1f8b8d559af50d54f646c837f6b35dda2ac4c14cc331b6711962f33504b6a8449f611333eec01a02138b60919b795a1b711288d25c15f2868c70e45d4fa861f4c72ccbb99f62dfe0fe663e33e06d30f5bcb2ff988f464bd5ad452386caa2f3eb7ec460c73ba464ef35b979d834ca8c2114d0834db135f8e538492f89b91ccbeeea666af8bd255134e4b68b2b5c9adf5efc5abe73ad934cacbf7213090cf11945e1c419f55abd209c2832211fca12888fafc72a9a960cd7f4e5d5f389699072505e09c254d0af55af56e94ea6605da0f79f51d15c30d00ba3045049d487c716bdf96771c87438b47220b5a22b90324547a3a0866441c0a2b8fcdf659c3ff076c63ecac6453f345b5719dc2943686d00b7546fdaee883fd62082ca0ca5435280b5420d7045df8ae781a351f19c69a0275eebe01424995a289801cda8ddee404f1b1f2e48d65cad0cbc46347d03d52d55ce1c5d680d4872a91afc9af95424e8bc37cba1c05dbbb6ba73ba329b0a9e35eb925ec659369f22162e62a4fb373eabef7f1776f24fd9db5565da917437ff5dd51937d4e2f62a68a834a54dfe3a01b95202b8d7fb6ffdaef0bd06d1003c521c7f1650ee80125be0ee8931f3cd5edbb4fe9cb449a90eb9100c905a715f6f5ea026fb09ebb9e6943ab42dde899ac663f4b874e79a146afe7c6e06985d30a318f70c020f57f914ea5d6ae7337819a97d36614a7919879dd8d2788ccfcf3a0f2ba66b9f50c6ace06527f29d571b4b3180fee886ad70e35ef82625f5e2b71b3f03674bfee5fbd5b93c4a12c1bb709f1adfd016c1cf6b4528daf293454ea71360ddfec296be6839de3171a23ca22ca764caddb6267df7e2e1eae102f607f725f2878f5268a0d9dcd1927fc70537e3798db3e0f4510aec97617a0de576c1723fb62daf8f11b0a27e657d1813dcace5bd07df1593e68f56e6844851f74f20d00f562bd1a97a8c920b00723503d3322bc904a5a16ebbba646f4460a9d73bf3ce9cbbefcb4e7aa8bae99a6444ac6a7e832fc90c27ca774fe0bb29d9d7d0116b60cf19d1224cc7301787d5954307f1f35c0c2f1eee72342042f14fe01df1c1832dff22203d5fd1b9b6b4f6c37c497d50f6b9d2b9ea41e828a5c9b01c2d1d9d39c2301b0e0d931845376c94387d8825d91472304b290928f0375b1356040c817bc941f4da0fe594dca4164e515dbe2004499c8e9e94104ca3a9dfdfeb6160798cafdf20fbd4f7b0f0f00c1109f6b4c38ab7dc5188ac32acb9a09bd85f26aa547fccd645e26475d0266381ee7bc84770ae3d50e6c06dd2cac53a36a225349a75ab6bb43004884195c9d1707ace5f04e2ee0deae02105a9b66de67092eb9ba5b0c29075238469a02446e40db740fcc83f1891e0d9e87d6817bbeb29de728957aacb71e56c888345444151bb7a2713d0af5a42e5ece1af2f089bd57e3e6fd4f51aaeb21d239e015597b33b62f91ab767324dc93ab1bd35c2d85a4d8050c794a245548dab0f35f34a13998f175e23741a7e595a166703bc2ee945d8239a18c0b2f2122421691b40ed1632ea3cf1a28a19d4646e50c5d34b1460c5198ac7eb41856abfcfad0efa95d11f8a539dd36856e20f3f5258da19513556bf6ca3ba17e4dba44d5780cb2f4b82efa039bad4eb39ef3e0ecd6e03c7fdd122303ee743e49a6575c5292b9ad0ca6b38fac54c4384a075d948cee67b4f4a51148ecb1830e407ec2f0817ea58d67718291a0e4c717b7635558051694d6b70ed02555db5d30cf1ff3c1d44ab36695abfe9c3a54a8bd2107b11c289889c1e39dceed47edefadc9985cee9c24ecbea0d9fbdf0711990f623e1d2e6338655bedf72b4a0035db19bcb7499b2e0a57688f82fb8574125508999c0ed834bd4d415a53499d623cfb14c82948dc99d8db760819bc35506a074504117ebecb9794cbd32f0f9707f77adbccb5857ec404e6b509e0bf849f2c82e36e49a37d12fde254019c9e199eb946ba57df0a560375945915c011c52e239da36616e88be0d4bc309acd83a9556cdd5a1369e3b150b603b8131d59d0cf5d5cdd5a5a8bddad431f28e4082cac953f9d9d4518991bbf7e7a8d9866036c0fe42494c95e5b6bbf789e1da6a3ce09d4b0d062675f3fef229162ff48f26eaf6a92bff77d724f3a2c20191183085fb61522febe32cefcbaebf1f37d0a78e318f935c95d2618a56d3d477af718024e10637101aa8f0dd4f87096f2d21658149ee489326fa3669a3938255d29a951e7a34795b6980da184e2195ea8810bae64957c858f72c6ca3b13e619f52a8885558f77072c10d656d774a77b6481c6385ee9e96668438f04ba26f2ce63f285fe187314697838544e9f3308da32acd448e955c92c891d8178f90a664fafe55780351d8fcc947d9e5b39843e31428645cb3d892ffe76e38ac11329601130dcd70981c5c9d089c8923301f761b062e3a8217adea0f3255301fd7ecc1d791b82da46eeb1b791500ddc3b0b0b5391e6df8ec112886f1aff1d419bbfd5cc643dde8a8f86a9af8066e879d373e2d981bcc3f11362106ce7983445283ede31209436d406184764f89cc85e2919debd2218fbbd7e2f97058925f30c2fce5071cd7c1ce734907419ef9a75ed428154e2a65152953fe8265cd7d2a63f0bf951f9966e6aff21a3e196759bed0ce2dd499964f1d206aac808764114fdb4a0454afdd0c2bc3a1efdad39b8d9d8ef4289bdcbb5236fcd9aa8f7bb3a59221d46c6fec1dc42a323f5dfb29d1aae1e97d177ec3ae1c88a23c03a7093219b77e94e16bd9bbdb21325423078df063a3e2a6d73615b401b642f07e0da6496a35ad79ff1f2092a3efb023be6f47835248c2048f8ce3696775d00fa19e9dd8e506f956b40afdc9899ae0aa42ae94cd1a29cf4b8a26a1375c41100589d3a2a6585ee8bd3c567ee0558d97172bb4bff5186dfcaed23e454dc1a6ce3fe788781e750985ef660cab3a01b27e8066d685423ee6f4ef1c787f74348630d367f8d2fba9bec841cdaff507e74db087d6ba8da17e3f35a7c9de7e4e17d535b40256cb772909b57b3e626621c2b619d76117da25b734dc7f879d79e9e26c9e1b31fdf9fe2ca263a51f00f5cb5d05a5f1740277d07b4a4c049582839dad403ce65f8b07f29cc62b338062ca5dd84d5a826b2e5392575f87eb469af30842205ae7e80dc79e4288feeffb78f79b900261718b3740e30c69f1e082cf4c3603da1149085c3abea0bb8cbcfc3e636178150984116d7e3587d4637e1184b624c98c4349a0b0bbffe97cb5ab4fac01e61057c1891c7e906144124a69239f8f976b37b8bde2ed3d5b1021ef19c8b40a5e6eabd3426db5da18465e25e77677ebdf933fc68ee55564ae0b0f257235b357351adbdb7bc8d1c83ef1abf22e07510d7f3c029b4ea11deb66e7fddd61a2a026a67cfa315cafa9830badaaeea805716b836a8872b651883ccdbedcbafce2e2781aee2098a88ed749a3c1229f8a0ece998abc4fcc8eb23b53646733fbe12dc5bd1b2d0dd175e654ac4012a7e08c8a37e46273a0c47671d2c8ef14a8c31da912432cbb2cb25c2e976e20b72119195457b77caf857fe6d82ac008dbb3273565b506d3a6807ea25d7e470c45ae772fb31f6628a720df01a357b198d1f42a9e90866f33d00367c53c480c1479a5e33e31ce6c597495c208921826783c3b359d594102a588c7e0909fe439f93a3e2a4331cdcf7d3d358e42f88e282c0c61f7031634e94c30ef39734cd9ea65865e28c3cd5bbee783a6a79fe87f114d61444949c6670f70805a9a307c6a9307c8971af59387ba0e51631666fc9b58decd7bf782cbbe039b7bb6a4daffe6b1dcac5f300b8cdef6631bb01f6af0b58824925c50427911af1d94d1cda02fd676e37388f6a5b68d55911a227992983fd257e647abd57fd2f5c418626838c81d1d5e071dbb39ead2ff10b4f0ac04cc6e0769373e99e1fe21334b48d8f5676978f982a3c5bd6e9e72f73771f01c66576ff1862c22cae68ca48efbcfbec4be8a17a651f996f6225f04f502c8e235d3c0fc48089b9eb5d9b8be33b645cc1e8e2226cd0494a3ebe16d88fc850cb35c7071530fcd120cf4a5d5443c1c7c293d9a52a1b59f1214654e7cde8f0f0c46dda34c0ae15b0fe837e83232debac80885eddb446ff9683706e53b0611372d021ccf57eca4f47b7be01f873b30a92aac970769011f21bf1394e4edc2dd9b86445446e85ad029305cc5f6ade4b1715756dabf9459fd4701748e3458e1cfcdc2883d1579de2ef778a23edc96d641bc6f13f5cec37eff9fd5d648642149a4a76be1abf8b809fd9d80f5c48a59c87432f51a6b200f067fd199b3001d9a3563fa7785a79b54585fb2a6f8b7a06d65e1e701fcaa4bcb2a03b4c45dc2d50650f875c6ac4f64021029b9982536f1fbd02a2ee65aab8467d90cc5656f819e7a03496778b4430324180942179ac28dbebb481df1595837753b4bcb74b03c19410b6b378435dadd344ae9ce5a7c9f1b2e308d3610cbbe1f4b47abb24af97b0167b80c97a18d451067fe666396fa8ef127f3b4de82b66abcd70a7d101eb81e92f78067c05667eefc52ba1bf70e2f7f9876fd3dceb868e1e9c41cadd94923f8c83c32574aeac441dfdd78721c800250062a00c05e3b9b9ddc3080923032220e125c6a8764421277cf4302f8ad91d594f1ef0a0e96b2384e07956323f3efe127b7e05c35a9d7f0b9c8ed93d3e2e5364ead9a6581237dd1b40954c0a51720a3e6fd7f6cf07cff3cfa81fdfe74d74331fd3f7f1312d2e77f233ecdf22658d54ca0be4418afff932d16c8f68ffb0b1b1bfdaf99bdb5cdf41c22040841f20a00a6cde0d126a4a343542c1184958b2a42621c25e8ac3f0cc0c3fa5d401870b19ce022fb014cfeffc38f073dfcce94c4993f88f4e2c9b79f22e9b890a756bbc9d88e716ec8cf725c8acf76f93fbbf6752db5dbd709c365fce657d0e0046426ffe6249b2e327fbafd675b40a5e07e0263496a2f47c7f637ed6ca6d6943bc47e7e2ccb196702603d677909d15956fb727c399c781adb02cb1407fa629463b6d6248c9e7a6cc6b28bf8835fceca83819351bfc988f1ea757876c78c06045c883c76f5bd6e883b46f54fcc55f41e55f09cb5e07e60962606ca589dae0c698eace672028b139c9bb62c7e50b8d6778a3cdedd2ed98e59f01d502ba15536e816be0ad1f4cfca51c8875477a5c2907155442c9571cdf4208fcb80acd24f9a546664e1fc06ecfaa37988cee087cc3d22372f1eaa1a53a75037be754c70c21c256ee4eb4f00dbf767d9fd97691ad546e7a1e326e3d5c3db754bbdcbd78d101d7beb2ce9f68d32624f38d865c895455385cd34af8d8ab862453b01db56ff1af4a7a36ea1da45672eca21da9b58905fa17a11c2f57a7974e377fb9026e4f38cbc21266d7f2b88fc4c44c487c14fbedd88d0fdb767cc028805cc9c4892accf4ec682b2eb1791c004a68842f5cb2e9b9fc1bcb57c81d0084f2207cfa06774ccbb9974e5602dc7d9a2e3f18898b47dfafd51ffbf1e2b1bb9a1701aa8e18215c5c53341596f89c10cb140e15e7be25a640f8f4aa0f171549c3e47ff6fdf4fa372c9f39a217ab5bb010987772cf8469fad43d0fe7ea942bb0dc59f48c03c82d4d5a5663fe442248499ab449ee5b0b9388dee1b6816185aedfea5cb3d8bc0145b1bc8addc8f0a282220515987f1448c7993505be3c7f296f4133d2d1701b74e577a25ab2d7352cca1cc6b21c2a77b89b0d024dcd3d0c1188661b47c66de15ede1c134d016a6e22cb750acc44325a0db663edf61eb2af1a934b0cf129fd439096ab5b6e21ad8e38dfaf76629fb7ff8d997aceca5bbaab331a3e47015a219affdfaa5bb130e168cc1e3c81ab2e1389c9af52e30bd965b07eccf5e1e24fad8273686b6b14dcec7d81e831d67d03eb40ded638d2e7e1d30ce1cab68b6709f3e50e937ff8cd17a1982dfd995d0100014aab60ef156875c851800323c83ba53b10d27b2b54c5c20c579d00abb716ca39626cbae93380861fe99d5bae585baec7b02885f40334ab93bc27490db9f454e7464d3c1b9493dbf2355eb1ecb86c3fdac6feb9fd64bb75424f9a803320793a2b9e3c25dd61af73f3ec6262bfa6742d28333e45ded5862ab40f6d3f24de84ee2d10300c66b576bb7e25777ba5ec6cf94854f53e6a37061cf86c43f0c8bc0ddae0d6fafdab8e9ec942d7f536573668ab851dc3bb3c097fb7f2c653090c820ee4fbf0179740ded0b0ed1dadc0a8fe29bfe6a293b99b9f5aff68a54f2918a300d60fb749507eeb6d7a55868973267781fc5dbfa3ac736f1ef05bbe797fea656a42165721e01f5ecf7cbffc02907af8f160daa3cdc3d1a149ce915540bdca0e97b61c84b4095c8ff73395f95850eb4736f2541e95a8e132a3be50a5338555481a5674dda9bc731e27fc9b8ae28618693d3370a44c040eb33228b265726f3d96bc21a9cbb9607b4576f4e0450f7c85bbd92d8a801f98d0efc89ccb80fc05c88aae36deb37de0f687a67af5abd7589d99c6bd09e8f11cace7dfbfac5a095c93c99af46320a5c5404849e646b663fd02ef21460ec5b4456a361d347293b3b4ee14032a3fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
