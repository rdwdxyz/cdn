<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c800fb10f3667b97d614c858a272a05fd63f8a99e6b74789cdf37519b728c77ccba83daffd8e9d052ada783bc53937ecbac8ade9f7dd9e23f581b42665b052d20d4836d7a3b5b0bbba6dd6f86f0a5073ea41ed4a92e1ec96932c1f4a9611524190cc2a9c5ffa9424d890663a6ab214bbbfb54974016235b9f7950b4ccdbfa9305b1111d9d81ddcb7c6251644956a975152212e047f6fdd8a7d7f07e5d96bc34f9b80283285763e4e20f1b8ef337a98dcdbc487a2d1e7042365a5a7e5e44f30b534fdabcb629b22f37a0eaa4e86d7903b36d00b6486bcdd7ec72fd2c44d691e87a257baa5089967201747f514d361fe3d42bf07c56b075db989260ddc24bd1b64ad1c8f99eed457d474bcb4dcc3bbf330ea715ff3e1c4eed1f243041efa66e47e9ae475beb0c72e89a39c27ef057d46a8b88ce65d5d816e5ca6d5c7f7f11d62397149e96f386f8f03855e3bdc5d37ac1d543d6d101720280c74037f93389b70fc434b8df333c146853f18f0e65277762d9b99f6d7823008d02ffb759a29d35fb40c97d17e452b77d8f8da8f00112618d00e9ba00bef8b1216aefd56dda97919ff2cd016fc680b62c89c5f28ad957d40042516403821c4334af81e30d488bea9c35bec113a8d0303f58714c6cd2b4c30688a5c0ad03be3fbe459ae90e1a194a18d624d25e3fb0a8131e6c1c20989c4e1c4b55296ae5aa82713bb21e0c596483dbacc71728e83094239d828e76e027e05b303c77c11e4d2b22182eb15a2cea3e945b5a2ec4df1a8f6f99859f2531d351e78d39b4b666330da510dbc92e924b37bb10db369a0013b382f4f7fa3a9bdd911a62fc3ace05a8f985ba7fc34f0f93c9927debe7e390984124db6f111e93c94df693ae98fbd7bda3c80027582478bcc81958b91b03a168fea835b1fe2da6a6348d88e1c2d95d08937f168fbb39071aba7ba5c28ca916e16368766d799822da3a8e58044cd48d53660fbb9f75060fea0976da97603c61e1bcd3a496acae7c064835801e30ff7ec549caef58acf2e71e62cc76792fcdfd196b9032e36855b66e67c3127b351368cc75d7321640ef0c87c4dee496a9d2baf610a4e65317ab2a10f4ebb968dfb2c951789f48f24be9028dcdfade808bc1904f9d401a6ce388479ac91307b9058c3102bf4c11c1bd61e1dfd3fdeb245d237ee85b634abd121cf76a044aafcfeed1599ad4070eccee24faffebab79e45b55b86aac46f004dee52f0ac7489dcbd525a7b8ceb3eb7b2570e776eab352aba59264b28eaf3e4ba27595f7a077d043eb63a0a2a7abbd30efcea0fa95a6e537ac450ed4039714e7cd33670fc97a2fe956ede55a136b09cc278b8aa36522c92625de622b4e3c6a70da63e23b6695e53310542539b31666fe666e81973ceee22a2e14c605f4fd795099e15c6dbbee03fbac06f09cfd23932531d2d0a17f31ffd296120fd95ab8160a07fe8711ff490f6d78ad592bc558a8b92ad8ee31451066d7d2008f16e02a30bdaa4830533e73e7615dd98db1ddbc4a91c20673cc3bc721381eb60ca29a14c256b295142f2d323a90405abe8da6c3ca63e66497daa34d3672157a45c9c4c459fe7f0161c19e8ac2ae52948525e4cc1342af2778ac5053f3a654aabdc51098832ec1eee419af61a018be937fa48df874268a0979f6bd35fb8db79d0371998a36774670f0774055c9ea95e0887fa6883e3691a0c53a0550c7b0c8265ccebf27af20cbc13f8ad52d57aefe0d2eb6c06a62d26f90411b87da02085a6c131d265a39abe4d35aaa0bafa7e60da6bb5f234a3c9cf6a1fd1174689b07ce088e940fc30e979d228101d43ac5a78ce8b3a5a053f0d077dcd13ea20000d8c26d50bd7e339fcba3204ef3aeddf36234eb143c31cf3bcd962ca36290d9e0344534c5cfc6c3cd31362d7ace02a8567bd44892d35786edc419ae74a7feb470e5ed3ca28d467a823c9e8965489a52a32f9a2c6ad2b176b6e3ab3d09ae8152dcedd666a6bb00b2a178785814682331ca67b76656dacd7ec2400d178019671cb91681d90a77b35611c3ad3fa1e1f2869b704f430298aa7323e3c6066a4090338b488a0015d3b33baab4cca2de47d40425dc2c11ccf6542731a70a3b4e3fda404a0fd4dd57cd8426c7bb1d4139cc20887e6993ece4feea51cc11b0fa53915777dd9b2fcaf9cf9c1ddfb23a36987652441e4738489c440609d51eda3a843b41a40c30745bb84c23e6e491123382439ed011ad6254070f5de9b28798e2d9de7367923ec6fa33cee4192d53981a13a9d6673450f794df1845c0e757774f60231787d85b1212b45c92f5b326ec24723b133d698019c7662b5fda267027ca907e245438fa105c3b0260845ea04ad1989b580896c5eb08c62ba7e61ebf40f2c96f318c940fded50646060e999872fa331e22f1ee27cc62a90ff9c317b6281d516180bdae8562c971e97a4d0b44101d44ea6f4183d77ecb51336e715a31993e93fa11d2d0dd3f8e352ef05746d734d9aca03b66a81e882026a1ba892a182958bba3ae34a2bd0d65a5e19ecf836cc585449532cff515d68a1a44f0dc9bb9c3a6b638731a429601aca29a05206b5432a92bf93650309d4be4d8ac456f7776727c7cda2471697846b87f78e448662c57d754537e94a2c3ef575b89395cbc9f46fce3871f639bba00afd75e18b2c090bae6cbcd12a813d721338f20b4b04d2cbfb7e59a911c3c95e7a25eed6b1b1a0214225f45addec927a7efc93a2e1bf2e90375d5d219b879a6b43460cf6dbd1bfb1d742cdd2b37ff53e31c2a3f49b8accd93a64b931d6de98f74a7d2d755497e2b7e08eff0efc17c8ba8751b6303a43cd8a1eb0b301c15f5b0d13f58f01cfcf9dab0b83473c4e192842f55075e698efbe166f1224d1d8ecce40a9c002b7f13afecb7e5ec547d9048d80f5ed023190307f7d6af79a55ae8d464e149b902fb8b5c72b7161ce0f8e4b90b4e088bfca3a41a255346f3aa97c0a06da711600e2a465ff8c58f17ec5d0a6827dc1679d47f30b05fdb2bc4b37650d5840b8c06aaf07016b135bd276d0f4f08f7a6d8072911c2c47afd64f859f5f6278e9703cedb44c38108e01e35e0a9f7eb949733c841d7fc14c88808e471e36c7c83be844b99df1246601c5c737706d5efbd25a93f0207241abf2d9d85a7d6581ff783d6dbba3f00a99a068ccaa4b2e508eee8836f2135ab7c87ca77cb74fd720adbf13725020739360e5001c0b5b106b99ad469046100c3dfbc7f04106d8db492c7b3d8ffed049a42b2b66cb9904492f9574e2a4c8dd9aa0e84c3bc467695c2f43a9d21a521840dd73099a58e6ccbc16bd67c24bf35166208d4663172c4b740a71232bb00e4105fb47e66006ba8b94c1ae3c06135f01c28dbf3711e7d4561135413213695e4ec6ca006a9ba3496fb2eb3f67fd71da42b9c192271d4cc6e647809a8f0a6b72168a4749a64efb4ec02d9ab3dcbf857fe8a06cb1f9fa849606de5f6bb065bdc88cc517be528005b7fe23aa4d0e915febee28f80bd3804b81f8fd8aab841985f9ea9c6c40dd948f6a9c8ac456660f051114e40624e006fb7e480faeb173dacccd59689c3d8bb481ab382180b9b94c67125e439a68d3b31accc01d21dabc196c478f75e4f8b5f74d188bc225b975d86f11c1f61e902dd95728a883d7ab55ec9e53beeb953d80f675eb123b6bf3347c359033b42849ff794c14e3ad1314751db6c633e91437fb2e903485479e5dd11d6ad5ed88c440d25bc400e04554459848c403166af0174c9ff6b76792c5c10d1e04f7a6a93995e6c91443213df1e5b6ef3653bc82c9ee5f36bbec9ed8888b3b2f33453b26c3a752ff8f67b87fa3161af4e5c356092d80ba850063251e099d9da9f6881273ba4d88bbfb893fbd90d6dbe2e2732771a579164e6b936eb2f60ea86965e16e39c2ef67261d96365d0ea36fbf6b459efdae907f4bbb13167704245ffd0cf8962d1353c855c6739c7d28fef32ad02602dda0ae1436d7e2f16f669512e9f8d0c84931b5ad98d6c6887814400aa40d706877415386ec19f43a2752edf0893b2e83b3f75c78b147c22ce5eaa0d8d000117071b52002580dff1bfd06276005a72776762876b75a22450d25d74e9ac9a0865baafeba324acb25cb6cef083bda452a40f5f47e23ab0312e1a4ce618371db413225f1f82bb8e80b0b3cc20c54ee90d1a039c9f47ab2c1104fb495a368e4458c03f1080b0493be4d05fdb27a232ee7237a3116f3f2e7b70c2b63ab4a16d3e32728ec64dab8ffe08ac5b701c83a2a8b432832943ae0a8546231010c6f324dbdf8457d39008c816802f6a619e48a8a33df9e5f9110e8ef606e5d6ec37cb6a134d6693128c8b2fdd66d422fbfdeb01731230372ec59daf06a50da17c1ee546eaf2cc37d148d2cb2c2cd0fc5c99f325b38c9aa2a179e3b9ee27d39853f57780224c606207d094d0969bea2992063b64e130dee28d43e38b342b544981eea0f2a60ccd616d16b8138ee5635683f3a1240d038608b1dd2594081bd497d9ad79e02513a569e31ff9b698156711e847554938a91c011d82d958a8509d38a295068ba542f16bc285685a0d0e656caddf18444ed48eea9e32eaa352a807e52b9d82b7c5603c8e166ceb49cbbc7902c59b3a145c5025faeb3bd731e8b74902af230411cbd754a9ec4c5d855b7c8d20df81d6c69b0bb1d281b50fb714158da2eff6ab938fa2da04e5c2a3c5d2913883eb4ee74182797a9c498534b19e3d2f454b69f4c2feadf70a3cdaefb2a65c4e1acf7409c31f6349dafaf0bfef356abea8aa25499231fa1f965e9088e1291945435d5641c39b511c2dac96458ebf4810f0ee65c02d2b84ffa4887d4e7ebdf0a90bc7355fc68950f17136fb410660f466760bfe2c08f9b9c138577ce97beace00857ab00d2f9269d056a958c3f55204688cb3d749a402a89ab82439ba181fbddc099af58acd236387c658d6d3e25cc833e2594dc26256a231a72de943ab29f5ae46056f9e32f40eb97c772e63688a5e66ca41a7ee36dc58469ce45236da9da9fb2e65d100e4b22551c886cca27468d55e4a170fedc7d938e8636a9ca5af299e300210ee48d538c6cee20c47faa0a16287b8111b429ee9d1e40f154ae7942dd8f016ccbe9e5185467a7c1191e4cab53618f7ac9f2c8b371041589552ea55bb47ec7325c665ef3481385f7982788f1c266f58c7a3630cf52e1d5946633c754bca5635003e765cf05e7d0743037573990ed86818931f8bfecbd757d2d76c3e0659674fd3f3f7c898e2bc681f1f526628eaa06a5f4ea29e46c1e884346c88fcb4b7672be47bb8f061a52fbede3e3d8a0704af454696508bfb636c24735a69c1b2b77a6cc84392dcb25034c4f004cb3d28c84b9df7f5303d247ac6df83885288094601228bc6fd8c27b855a9588925f69a11d4bb139c1fd2481736baa25a68b32ef46f7065dda01bc7bd24a935c1179752ec9fbe0a76bdd0b04feb1e4bdbdf9cb78644fbf1cd30b71035bc03ea1b240d1a1e3934d77c7896fb0b4935e487ee896974de5f9d9dc1c4e956fec6dcd50869969dd92ef8e3c31c43440216f7470ada45f0476c62f5c7f90d8b74f840bbdc399fc9ec8d17f37643d65e8dcb962c7ea23a9986768633667c668f4a1667261abaee514d4731aa5b5ea467efad727f6ee308983af7c99a1b38ab28179ede350b3a40721f619afa08134dbda10d3e885744ccb73e8e7694d9b236aaf684f4a7dbf44d2a5208906a45e0ece93738a0034dfbbca2aff4bddd9c87f6bd9006103841cf797b3150eba27fbf0da7d6c7483f0bd339123fbf663609e59bd9074ed1d574fa78259d2ba5e3c0e8e40a770b8ca670be4dff4fdb70bcb35469eca8b7a41868de57a3409ab9105bbfcd25ccc875a2fccd23f0ac3ae7ba4ff97c9145830be0dc8e4212cce65c56b67835568f447216bcdc44400e3716e866a8b3b52e63bdd10efc7e4c0242fddcaafabd8fcf0b754894a00a8849097f97cd1adbee2c09654032e62cc0a3ce7a7052fd2f681dcb0ac2f21250c4ba45e4d2439a2e1416ac5193d477dd00d8ec888ddaebd99315d77bfbcb6affbdf283bc7caeeb0497785ef160bd38bdcc067817f1e030482fd41e38a915183fea8d5df6c89a277cb277fc9b851b334498b682be93aecaf77687201d5f4a35d14027c0c3cae3bd9794cf50c73edd90160b0871a304fe96432ec6478558f6aa4ed43ed47b9911a8499a7ef662302092e27e4e6541ac7e1592911f8f37856c121e091b652493e67acf3d20cce34a34a93b4e3fe0eb53216aa859cfc3cd042b091f3e91b733278c77b1603b6240671f414e1e1d785db79af723f7722496eec1f3f36293845bc931adf63b66d822efef4790cce68d99990d50a53d82c12b3cd8b2feda2e8a386ba85901f7ba4b75c90713c02097cd79af3773e93ede2dcc6e846d6fc5fb7483d40a6869a4d9e1e5cc9272b49f9f0fed0a089f2c7462d2c3e061195807a14aef130d96a2a095f24c1c1325449efec323aac8c56a26aae26020528ba463423bb6f1f78a48ccdbc372799cc67d029fa8b32991a5d234bbf35d6e2c3dee610870c60ec136763d7b20f17a406b53333b577211048ee001babadff772d2953fcca4e082b7d010d4f083ab07f37c6bada4ec10201dbca116b6ff03686e81db7d97009983d17ee69bf45e9e8b152bffdd9cd964d3f9cfb2994893e75daf9e56214d5b79f4cc6aa0d6d8efcf908421443084a37d7f294c32a9e77796acf85e8ad2aa793c26d72ac3153d0dda43bedbc17f89f068690f1505c5e5345ce07b7938f9251c11d56e6f156f20984847f0aa4a4468a2b94091e0eb76c2bcd87b9bdc0bc45e44ac935e90874d4e0966cbf37e162642032d73b74cc12748f8c1c369dba35889a15f9f6960679a2aa9a73d82c0533221a4a0d19a106f9d1028cbf9e7f99696346d2b39a569c62dce9a37955234ff0f15d18450b7332ed80bb15691213faadca758716cccf297b42720c67bc4490a16fc5bbf76936d09f4c3af0880ae7886873610138d7798a78e8a45e0510ec7bc98ccddb5dc4ec4a90c4a795fd7a69f244f9b2cc5986e89ed0d26aa5e339ccb15673eafa33a27f7437d3346876c854a1bf3ad90310100814e9cb927777d54a8830513e8144c9409af59d8a42333bc60556e461618eefcb65d2489c6b1987a8f2618cae11e40d91e860d4b8c740dea3c11c3560ce285eafd9262a096b4850e9ecbee6369749efbd3ba0813b472769d59abf25d1ea4b1b4b14cb714dcc9ac202c11097b1c34881a5419a946c9cbbb3c5c7a060b1acca05a83fdf45d3b7cd634cf57821342e1e291396e6733d3b6dba55cc4a58ba5b91771dd77ef4ae5dc7b5b54b30023ac2befa19a0ef939740227a598eaec9ab41ebcdd5e214cb2991c72b53688613aee018c970e89a89311b5bb87815e4f733947a946a932de4ba6189ef8924a70453e4cedb9c6b27d93f6f4bb9cfc74aca753fe7738d9b0c52cfc403f9f729a7e270259d7c2f2ae26146158db1702852d25b5a88f7b668613c1e76044ae216bab485e16266118f6acdd84eddb0eb72a657856ef6b9871af46314c970c0183998b1492e843d5f96c054731b67423d9438dc3e4c775beba6889b5fe6b6b6444e8c4bfab30527ab39596f29c289edc7a324ffafe285bf142fd9ab4fdfc1371b2e7da7565aac33d90e16c3765e762d8c6dc1b7d698ccf2d92c0005e7174eeaa333d8f0b9eef54dd6b00e6eb4c7dcc52a5cf450d7b9a216f3b2124377865c757821d20e4fa58df397339058184930859da2dcc855c3c10fe7341ac3df41d0969188082e79fefcfd34dca9048c68c027891a1d339a192c6d6916f874ee4e8886aeb2497e8d4a74054d09c4c7c51a5b332034cea41d1a3dfb52889bad5045e9541e11e8891b7979904f067064a717f8f63390ef8c0cbce1f3a5f17d73c1e0055f576adb865d934c53113909f28a4afa38ab3b2d6230b0ffa41e37e28310bf9574bd7b23be12c696e4e85cfec904cd8237a723e25477f7c0f71fbdced92c7e3c9ecad227ef713fb3ea589b619442753b75013914f6f9ad424b7564782787709cd7fb9c58cc0ea40b3fe24a3d6d3a3c7a6a06e97565276db00f16fa6823af2bc23b9d631088523f0a0550a13046f32896dd771dfc6872408028c3ac85f0d1b9f1d0c93f9f99b35ddf0fd75edf8fcf7d478f9496144700d867db3df00926c4ff91de0dd3858345cd9a8ab1b972cda902abe7414e946ae0595a8ed6ade67108e5bea46bffd90c61e6058820615f838557b6e88985a52a27ee118c834eeeb4abfa5c8a7be229856b41ba37acc0d7442f93b3cc0c2744f48656ef934e27e3c94186f263ecb485e3a852eda283c7563913df663c5f87cd8fe1b8f3e8f5d4fc582a06272f3ed614218113c3f8944cdc9c08bbcaab33598e80b18344f09b2d855ad387b142b4a89f05f9a0670bad6aa750a44e76dfcbb1af47756b02bbb6508c944a99e983299a5b4e15bc054e743d263432f52e4ddc1f3332902b923ceaa3dd6d2f7788882237e708c3aedd5ff1fc017ed50b0577d793607b8247465bc65d3a31cba065a428043edbff0983d17ff4761fe976f7e1962ca4589b0ae43456496a40f427c2a7126fea8e61a7de7d258b254fbe8f7a71ae2933311db121fc143cf1a82da9fa3056d11a57ecb2711f62bac87e743b77b2fcccb7844957850a1fe371fa6d54f4effe873bb94b7f2287a5fa6577ae4a013cd93d32dbeb57f47ae08e73bf2cd937f276952258f7d43bb75f8faa690b514ccfd8aaa59d5ca827dbdd158555d34deacc16b6783013879667551bcdea16af37c167436c5bc2813b7fb6afc7d97aa6c605d328f50290a6148dfab73b6cfef1a1d7419427fdaa3db477082cb9789d335fdb5ab7d21d13d420971d59c1199cc105fdac27fb18355dbc6d09a57c6682b4eff3303d075dafb9af86d448285682d5f763cb31d517b04a992b20482d5eb6aa0cf3cdceafb27badbf3baf1af9ec821fd055bc82fc4e0d330b43c8c64ba4aa9368c65f4ee67c7ab63b8d578afd59e4611e25f7d6e8bf43bb433a202953a5411d9d1dd313e2e97c33a09f95ff041d240a2a5941bd58633c67aaf6e155977d5d14d67cfe97d547c81a18e8109c570766df001b509ee49f3db7b4cf9235adb1f9a1ffd68b2deb27b1bef6d7a96ac64deb3684bb7577f79a8debe8384cfb3c6a401fe46bf1f4afe29fb26d3c7da399afff203d89186fc4c6e32e9dbecbf3f3abde14cf0e4c7bb4f4344d373db784ee13e99116c44c551935e9936f94a5bc2a1f5e45f3bca71e5a4efae031eb03304826337d20b798cb966389ca8c71ddab1046715f49bebd4893e84aa24b739cbd67fbfab3081b4e76ad58bc12cc8dd25aae749ff12ea360bc696d942401d466b8f092da74557ee1239095ea3cd81c7191f174ced650be5c54e878f557fe39726ab194b60cbfc786497f2616ff183f42a95ba24e34f24858c9f018a89a66181059fdc9bb1f6b354dc01bee4b00536a00f6622a644fae0f5c382eaab66452eb721ba86e4c18239fcbc5c096b65b8eb75ff7bb6471ab622f06641c6a366644f286f4052264baa0ca47da00e03c29b337f0b9eee811afbf79d0f6140c4d79d3f124c721d5d1076594d3ce58b3394ba1306726965fa31a12c6860fe48c1d7cd4fa1f21c338cb5cb708a98ddbe32e9619e45afba414c78ba551320d7549738da42b3013c9f4ddcfc336b05a3946eec2eb131119180355f8f0680d32f942e1d41646ea0958623c9a08d04bda8ef86116a98c9b721524932e095345c6483226970460444f4ae156ebf1c74d058a1e567af64e9dbfa19ee69a03a1012719fd85018ce4bca0bfbf1bcca7e2e081559824da4b4ecb5c4ea001d8d3403941a3d3f721a0a99c3ded36aa41cc09436655bee6c013b77933cfc08468151a954ba44a132ed543a2cefe5d67595ba45d9549d130ee49b9f15e61c22cc7e8135b57d59d1de28865d449d6e9f2eba0496ed6d81683a5cfddc2098a4a35150892e0ad1eceb3270a569b3e062ec0dd0e1970dae4b8309c5da3f8bf84278f41e80609e28d9875f82335b606987d121c21955b15c932119a11741d1852e28c4c7adcf64f7167a97c836ec227346bb43ec8f24225a145b99ef1a1ddcbdf99f24ac7f7f772f5e51f8f8a8ee0dd6d8c4d03a7a2a1f7d5a89dfca0303ad0ce9dde4774eb599fd67220deabb6c379cce391a6d53c6767b613762a4e1254ffcaf391e1d9db6b4c11df04ed3359b5e8653d63e29b59f996e22783f3ca1719168fdce917be20ab159b89ca6c891e5b88fe05d150fc707ca71c171eb9484489c44bfe142842979e7136d95c6858925d53c6c99c1bdde4bf3cf99da75a8e9c248e6120e8e6600ab23bbdb1014882652878dbc02731322344ea6a484510f4990a57e0e209ca53fcc8c3fc18b854cfc95be402a5c40bc44920ae0fd5039d82875406518a979ea78bdb849a27b3e20059ac83687838fee0e658667c3a259248c4c10f80ece6460f75593972c56ec34582698b9017a4ec922e8a91547562aa56cb84f36dc8b08054df3e80389f4d5a981df2ed3fd565383d50a1868527757166f10085b27d7e54da8defa4e2a832d4384d86593b99ab870dc45b6d43cd02c619173e5b1a417202ebd63f9b2c7bff8b9d7724c2d89cd873dbe7beb60e70ec4870fe022476fd4d6240073939a3839f9110db1384211cd969f362158e89ce7c8da36106a33a09efe91daa855f5ac7f7fc893150f49f053a7ccfc6b5202e25157f3818f66ad7887e4c8f64ad12170d6121b960c36c10de6ccd4056cd6b056462c6897e203b3d1f7c93169d1ddaac7c7a0442975a5652977378fa1e9578766274ee5160b96eb7e6f4fa169300d679d56446f777041d14935bc4562f8d242d580736e290f5473830e770bb240cdb7e4ae10034d77883d7c2bd6c99ca2a75c3c3bd420264d3333c88b5e8e7326ae7fe7cfee85ece9eba026247c79fa50b913f4d481511d181ce00f09a42a475ee4e533cda5eadd3a78cb17e1c9c80801e66e13bdbd758476c37ca7a5466ad91c1617fcb57a3d87a29a17693b33665b7416e6ac2784bcf1259240831e442b46f399a1d4021469aeb82769755dbc021b44f708ce41f95600e4689f87711b776314f99118dd6fb3619770364dadd11d2b0fc9770ca882acc4f70e27bcb1149d076f6db339827856496ba6eb6fff758f0d1413c6702ff768e15bd9a2344bef50daaca9af256f452e0a2d476407f2e9c28be51e65d9da80fcf0fa96028b74cf497f5ecc18bb7336c39324994dfb5ce3f9b3c54b777748426c02b4ae5edef2caeada9c443220f92cbac495d68ad4c5e856479adf5df3474c247c06a055ba2002d728927473ea5e8d317ef7ac0ee8ab82a4b988981583751789b5302fc64a8c20e993deac8693f7eafcfc49214913681ea52c80b01108c272bee47a3fc32be3a5e2312aab231b8be3dc1a8d2efcf5324b49160476bd60725d755ee6ce0783494757abb2c53eaf1a44a670e33eccd35839ec8cd3284f05f1cead19de9a6acb559e48390ed3739d33f8edd65e533bb5c1b595a7ff57a98a126ef802f07af58da334f6a005126d9dfeae40df8e3e220867c58cdf51db6e3a901cc2b29869e5fbe484315566bd05a76ddf6f237d05c89f89c6f7bcf8c8f73cbfa3b77904ce43fb191d62d4452a975878142c1dbbcc5b36abf2ff7afdaa9e59bbfb06f98b5f57228ee1bec7672150349ee90d29d5efce3bda8717d5ca87731d1f1559a2d6aa842a3d65c8cff2f7ca51e037a0536ffb9728f6bab08be63b834290475681b4c860d5a412a7ed0ba71b6c82628075db959efac107affe8fd8d521cb789e324eb4facb10fedba17b8d4d7721f7445cd6fc0fd4bb98d5cc9ece1b42a7ed6180fdca492cb9c518f4b4b0ff29741b0da95d5b974400bc17f3eef86a7078c140bd612142e19fbbe631c3c22b8860b2691f4754281eab5d5efd0982f88658f7a6f0701a96be3d34da4983953005f31b023f222461d786041e1cfbdb85f62d6bad2441b4aba506686e3497cc13178746d73d36ace08c3404b33b848591077abefb724cfae949f8418fd6640da59ecc81ab0f0e577e1a0fcecda463761922e2ecbf4615bcd740244fbed5d8079ceb69752664f8450c75ddb8a52d434d1286506a2358cd9f899f32a3bbd389f19e3369affbbb4b70e313db870d160eddfa1b111930149e7e8dfdff478a4ac523302d5d4dc21c0a12dcd131d5b1da6ef225dc7e954529a701b6dff3afbfb2db49dd251ef6c102fa22bfc2f536de05cd17394764c2fc4e03f886645f24639b03c379b771861c5afc1bd293504da35f31382bd77accfd93a6ba7cb5df3f1a3f9197b4bf519ed4655fefae26160b585b05d877603adce7cd8a0227afcff80fa70bc9173193c382f0d01aa0f7592ad706e17b831adc1461fcab1d0d6fed72a3e73bf818d0e79057676599d726142dbfe37ae630a28f932bad9a5a78996b2dcfe41724d81c7da226dc76302e03a3824564d5ec31b31106895a3ec8dead4c78faf6f6c63fdd5f18a31df7b757462abd3613029752396fa853997ba70b961a1e92d941492f1a31cb711dc4b990bab5fb844384328f683e16027fcc172d405bbac2827cac3f108bf708ace6025ab2b5c9a13935c7ef9552a49b6bbc571bc78c704d7f323d8dbef5603fd4885dc44633dbe2c3023a1eb438db27aa64454864d5f3507f60e32486e58757f71249dcd4194b8e80dfd95c03ad0d3de9ea3178e0e286c066fee834d1b7c62e97e3cd25c1748f663efb23ec37f68e8fc34a41215402210df24449da892198b088b521e37a73ea1e48ed33933fdeab00a4769363bfa7513d9b6f136dff8bca858375b9535a6c920aae3933519b615bd57195dd711fd1e9c3eeb76420caeff5322d997a7a38cc9a42642a7da567c82699bd60b5df410be348ce98f4d69454e98735dc9dc720cfaff40b08d33932fca9ae61a95b760780e84ae1804a4b66e1c7cbef25a21c8439795abbea3bf5f6d16540e8f40ef72f6b91b025183c4851605c7b51732b37e7beb0fe23c5c7330dd829001697ac273000002e1d974fcf59267b41d9459bb582197f1845a2c39373bfa7df0cce155bf2e53b7dc46a470828365a259823fab33d31208130e4f7799d981cf479b6e9163f23799632f5a040432db19376d996577a6d63c34520afc0bd0c8d68feb7792d8495f667597327df4ab03d90ae1012ad44c99e48b1459914798be1980bee23ad8d5597e83286a5618df7e252d14c7cb19d8c01f04f4aa0ddf35b139ee63b0dc4b41d149eb42b818733236cdbb33d8a704177cf10efc6e84b6e2ca06819db52bc9df66d117d55457df09f79b84d716614078f68654c61ab23b59f22d0aff5f42219ae56747c544b191e86437e34ebd60f4e917767e5663baf9867d909913d52701480e4ff7e2ecfb23edaa8df4856b1826cc4ac00ca844d7ab7bc45828d077359b140512a9f3ff854e55419831addcbe7d17c8ca5321fda4fdb0ee88d3be72c5f94e790b627831d723f97f0700e49af778aba8e229dd0ede56f4e3cfdca486202e1d8d20f1647e7b5899006b55b0e8b523417fb273b7265e9353e8ed42d17b598ec0683cdb87e7b60a9e7b884a1c639867962811a3d855a26284f5cf46cf1118dd45c2b1d5bdd82d1483a23d90e68b089a36b3a8d143154ad4474bf1c235da02d68c772fa5ad932b2944bc38a30240ce937e3bdd8fe291789d2011530b2353a80577ee61b37b6956ed12552a4ebb9013ab32bcddce5a791b004535a087b1a10cd8ed3b5741a1a87fa89db9096950a760fefc97bcf73bb9c16f4603b4f8f907f5cf9435c9cf6f7b205701fb40c6d97d0b7ebfcc33eb0df6adedf24a2ad5eb6fadf03e05f9dc4908cc46b1b39b87e4573b19c0c29a997621d850ed7b2de0b012de6961789691aba207b0f5b2bb0e35d4a0a5a454fabe3747717336c22708355046b60b2537d550f1265a6bfb4ea4cbc91f7e49017788a336840e87fe4d60a8efc7683ca47ad98c7e47a1f2db4ab87def53a542f7c0fd856b4c1eaea54d1e960e7078f6b1a58e8e514c842d5d405a49ac6bbaee0c81b648afbddbc4646b56a1b5f347e67d84955770296099002d84a061f69cf2df41a9a9f538f356e1a75c148cf320d90dea3fe7e2370f6d5ac774c672ebb6d5c405527ca1246cddae83474ed2ef62850236a2ac4b7dd7d72f8f83a17e3d88eef6fd4eb969a0833088c86356d6d0c4b373e279ab0de33b7df38977a5248e637e8bb78946145784094508253ea20ae8bc2a88b09690ac8a7a52bb8843fe6cd55d318ab0b272c477903c8a86301da7bc77939e49fb22dfb747d1af3617e2030c9806ebf770165e130d3cba2fa7426c1c63019aa612547a907bd685ea37d54d7c3e026f33520b1d940e677c8169267b633b0c9c56aa339ca46a30510aa1bd1b9955dd572b30467d625588d42cda8bddac64c0172953eaed290b62d7d68ffb9697afaab3a50729fc0197c1a06d0474a9862f6d9aefdd27deca80dbd75bf2931c03d2a7394e91494fd57294c2fe3689fdbf18afb7e81dfa4bcd41d95f13658db339f9bc05367f426fc99c7a8e3155fa2c0e106e121e16d21a60043ad8f29a7e62d279f6776dca3f445bd3e911f36125d6560724688afe21bdb2fd3e3750eef10d29ead07eea1fe6fad538969022bd71d50c62c94693fc215ee8aac8cfb496a059550f54d3f3b74c629751f3c63745fed788ac637f7b1a1e4c9dad8d17ae14b75d85c251ba5a910cc3f8b67ffd7b841ff6d781479f2f2e374f171c82ec0817318a46ee78db851713b211d9fcf99753b41268cec0816bebf3ad1bce0a5bb0b946578f28110e63d66fe0d73b7bd137f9311785df9f12e84cd537ee017e019ff393708b93f427aaeac314d962228aa21fa5eddeae2a2c4bf730cdee4dca4492dae8625b25468d753242b8d4870ebc8630e28094cffe0851c63702b14cf4f1e7eca249d59c5f675b85120cbefb4cf854c164b21e518f239cf669a7d58942ba9c591892d8f9fc3ab2764ff55df5dc5cfa04b6377e3f04f7d318d4f99d35cb720006df135ca69ecba4993b3b87a0e20d11c4c6063e2eb3189d9b3a0eaf7d9d495df82892428d96f6f212ace17b960029c0083383d44a8df07f7b692496ff88f32f8a45edc36adfb1e510a361cef5a96dbe4ee1762984b9a4875c6f7aca24e34f2f4c8b67bb1e1864dc3a645a5d84779fc35d84fdcfd9e02ac50c085de464f57b525b0c2da10d89d6c4857fbb25075dfcf27bb6bc38a563c90adb91cc4fad564c2bce3f474577e8edef7db857f77e74df65e0dfa38e89dd7ed4891d0c7422835cdb383c0b9684dd48d1021dd7c8dd952b5be77be7d3c72ceaa8747faeee452a9f84cbf61f058e194c11f16829555032da2f289ef91d0728e7efc94d3b88b9ab2e2f4e8628518360946321ad8960c1164b8197fd4db1931bce1a9d3a7d0de10b9f0a6057cd14887f1b84a7b7875d746c99b6c472613cbd1108ab44097928475acfbc2191aaa3cb7c5bf8c5cca554be1b33239ba757e0dab27209aa62a4d4f3f0db17bd428afb20f484d4bae6dbfd601de07e2b9832b17f474ea84ac022156b24760418d7e7a81447a16ee5ff75cce019a0b04ea26a3104d0e9686b99c30818b3b2505ab2e61ec5f434bfd33f9f98cae0a86aabca9dcd37e8a452114ad8ef3e8151b445dff0e5539b4fb24250fd7bbfd7e866cf57233cc72b035c7d169ad17f83f84d5d054717fa19dcc4c2324aeb82a22b843b05006c4709334eebfb292a663219e354bc5f5140fda42f52d748c5af96b59d3ef16f770bc0fa4dc442ce7d1443f9070183442f338faae24e9b0471738ae6fde7ad4adc964ab2f860e07d030670cab8a7f7d5f385dfbcac8d07d4996a50790b9d69a6f862e5753e17d5efc5ab590764dac77058e1c9cc8bf0236f807fc3771f8990d01ffaff7e402ede2354dd09f6002147d0dfc3b7e9c372024cc4e3bf47ebddbf8a8695b598698c1670151489b604e6729ba34b400e4c4becb3622f983cf754eb70b4897e2e6e9726a2bd2f01c7c50cf7f559fae48d35c18f9dcc19d4c9052a1d3d69e7d0cf58fd335039e1b2a7d4bf3851ffafd820a7397b06f9ce8e9750f2010fdf1d292d30853461bd9c0fa676ecdb91d45c4150c78192649c71946beb88de1a4815eca6721f76c8d4813cfcba87bfbd00791a599a8d09d6c2630f71e78e5bee808d76e9e38d77467baa475ec054221550ff4bf4c8fcd56f48534f1c72f07ddf8378a585bba43bc1a81345a9c1b019e2ed2b956f24dc70aaf34e66b3de97eb19e57aa79b950dd639b5f67e488580fda0ce6542928b9ed60acbd679d3bbccfd1c88eac5f44009c6860c29bfdc6b48ee3b254fd7105b69a4f376979cf338982e1f8ce66741f0ed8336b4ef5d84756ba8953fad1ad17ab02a55567f772ee279a5fc3541d6aa264b980cd26cc985924475cf727462121983a61c4671af7a2d655f18aba7b6afcbda302eae26fb9716eae318accb3be6e57dd8e5158281d7fc8063773a28395a400b5fcb7d30d15968c6e880eda93a7a82d26c1fa8f67abe7ebeca3fd9ca6160c5a731bbdd8a71b5fc8eb0757f5a04e60b71e1c7695f25cdf3e4d4da4dde43be9ad8f3fa5a4f4451ec16bf518df2b78b6d224b9fc1c984cec1c95bf9a72398c468f18c8ee065c3658ed65026839fd9aa18e8894d3ce430216760400c04343b43230947e3ad3972ba4c2f2656da192a1d786f7fd7ebbe6b932c5b4931133555c6feff8dac778bd4dbb694cbf71bd9c3940aaf5e2ee697774dec408ecfbb288e1636c50bfa71b091394ced533ae9a1f24274d06739c28d9635d9aac0eb9e73fbb0965c71e14e17b460ff09d3ff8af7e9e5875771c4e6c2d10d98949645665943a8c089aea744bd35f57bc7010cd2b9387f788ae656afdf7ee8ed57d30690a940ffa04f9e722b8c269492a15094087dff83460bcb9bde204d8aac254aa2e2cf210d0381d71e5c310bd4a7e637aa064fa2509f74f220831b74ec8a396a306643883a39f99fd16c281900fe61dbd2b57781caf064286a9dc76fa93f989105b1208771b9b6945ceac431f2f834b7cbe3c71bf2dbdcfc78c88ca28c8455a2ba8aefc242f9e3b684105bec470041ac609480b23b8cbe0db9601ecf5cf9274ae44ee1180132ed88c1fa359de3d6bc660895ac13d6cc55adb1ae055fd2e97949eb5bbac83d53bf9f4cd98911ddb1108f66c182aeec0f0908a29a1634f45208eb3c6a1beb164e3542a682b17fad05dbb830cc09c62804cb3fb631f3d3382eeeb617d42b693324534e24bba15d496cc6efe850f0863b3a55caabab71c258a20608b2af3127a1064f8881d40f4eea54a35f4f7065f4cc703b0cba09efc9c9732125bf02fe4ab8368c59a445efa8c834eb9221c034e07603f05b4a05120665d15b41009f884af6bb3c066468c555787707aa713c8ac056eb057b3e2f7f11af8c6b3fef886f416fea50cfbb8b6185835d16a35cc0f204aa31e77be0e9c7347a76ef0e18e6ebc69a36e2029618e25e2623085786c0db9d07abf711b7f41e85d9a387d8bdf60359ad8c9d7f04c7852c84cfa47be949ade482409eb347f7cb718df4fd69e1e9e5a625ff53a55b0a69367d6cfbe8a3a0419e1470fc38d3ebc97c82ee563f79cd569a23375bf4d857bcc7203ba4e6279ee7578d9c04876a31a6fbaee7696b4f035db04c4381ce8719adb2ccfdcad359cf93fb7ea3cb28b820c89b79b5a9838f7725e36675aff810193bcc2b95946ebda91c38743ca0487e52404d3aeaa08da4c164a71d0cce68dd1c00193f6ed1c91147ac431ee75d7c10cf76101e4e801f7774136736e7c338f3125917d62a553bf5ed296f749aff14b2cc6c9170b29a1407ff1739324b807277eb239c266d48db57b4dbf59c3b393a443ee271ac5ead46290f6c112a4c5b3cdcca5e46196","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
