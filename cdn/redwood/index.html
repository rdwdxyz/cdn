<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d31a763ee970bad566a0b1ed9fd84a4805a1a6a791a24553e29d856b339ed19342f2f25fd6e430a3ec093f19c01180f88948a7b8bd426a744f603bc54a300c5d4f90fcf529587dfbb32c69939f96c4e37df47e2b79c5321dc0623bc1a6228b09670b8e8d08199cd133b7d48e957987b4524fc30b2a0a1dd7c84edac502ac951302e1771db600f2fcd8d59d64a7f5995a013d3bcf9dbacb95a563650a48d80cacc1991618638dd4747dbb18365492813faafe18d665dce9ec52dfa03303ab8f9698d1f6f494487f49fcdda2dda71cefd079e14bad6e3db14527e6c51541bd4d99dde0c4dc52ae832806fa50aec98c9ba35ae9fe111c6930e9e70cf8a85c728d34db32042288c70b18971c48a02d18f98a93430256e19dff09425a49c99acdf10ab9e96206b36e0b519ffc359cf4f3f6251121e6d9217913258753191be68c82559fe8951003695593d1c8c539966a6f7975bb8d69de331abed08114115acb6cccdaebbfd25ea9f7b16590b62f7eb3a08bc83442d94202bbde6b4c41480d2f27e3c80d33078c65daf1e3701a09415bac45b8f28c4bbc365ea73cdcaf057b9ca2ae727b1545f272f235b11ef015de1a40eff0f1ddf3e7857a6ac3c43fb9e8ca5361d68afc5b98876d246dd159fc3909131553f39851087f6f86ad752ec28780b02eb60c8864fdb4e0bf512e55ebe6884925f1eadbff536902c1ba14fe91986f6c2f77e47d65ed14c0381e10559732205d02256bbfd4a55c60fe6cef1364c0c49aa3155e2ec54b98478b85aad05bc8e330d6f3b75ead2fbfd111fffb409acf374b54225753c180bd3ba2ef4f94e90f15d2d6f9a1885f8025466463065101dfb6ac4d818832d11b33bb76993c2392eb726ee0df8228a39f19ac279dccc29bf300abf819560cfd6a367fb4aa5b162ec17e4f1f7dc6c9ab81f819ac0e8f5b9680625953f71616c7d8a9cfcd7086a90dcfad8e25af3bcc96dceb39340a8c06e78c96c25afe08cf5bd8a1ddea3baed77df56191dccfd1355f627ec2a76c3ab2a360d1d0a1d10395e590eadd2b54f000ab00a87ed975306bfd6221d36a71291d3de5a476d063530de7373ec086ececc5767329a20c9a78e4bc29148352cf0539ffa6ca2a81f52bf80f5393474c3736a5edb25b57e6a3c46fef12b3a92c1c57b1c089cc4f72ab319940f4b2b95b299b660d5ae84bbe0a4f3e484af1225427f5802f4c175860dbda5a122e899e51b5d455ef249970d30350d976fadea70db8fe0fd28db8263e1fec58a515a75a8ee2c0cfb0c0e09d08d4de51f2fcc5ad78748b0fe342204cf8f2a89ba85d75897089005f3c5d48fb095418af98d40acc04ef64b4ac6610265f8df2d2062e6fca5d63fc613a9598ceb400476aac9b18e86f143800ac9f64860f6c5bd317ac9ea5f5069bd126e682bf7e4eaff1d22931c47fa46e5093bc1ff2c5c1e21c5675553d503313d37ee7c818f7294fa7fd7267aaa21f00d0547fae2d97e84494a79105d9015aabb3611fcd1cb7bbe0f13fdd664ddf4f100001c823c577c3c4bcc5d6c28b7a6a0ff5637a22452a04cef6a9c73d26068fee27c4c9fbd51bc36e744dc0a19464b441da4737579e80180f5d979e046df74c3022bd606d3575ca9045d81763ed5de0c3d70c7a929972739f1c7482680deb04a04c835849482d7c88fc832cca4b243e4ee241c530cb998288febe4f9c5100ac7c2d0055768d1d1f31763fe44e2a8cb0916e6fb003e31b9af508eb73c774d1686f033fbf4ccccd9fb726dee8eddc648eea6fea1bf13ffc282d43624eb55cc0d2e0307ee0ac261b967a70e0f5c91c5cd23ad2cbf4b7e5f4e6248a39ce563d1d3dd4980b071ff4ce51be7aac7dc3bf33e2c88d11c9bd79592cc770a8841a56a82bbe2b7bff854e69e28767d8ee27f805da7983843c44e18fd6bf3c582820bcc154e29aa0abb864f15d0ba085922e703d911187fbbbcf27ee21e6a48b635ed704e2feb74faf5bcf984866556b7118d30fa06820bc4ddaf249843937d335bc81ba58851d22a417cbbf41129e4f2420d716995f8e7881e07b5782e2057164237c2818d78398bed0a231060deabea3243d15c7c0973b78d6a53eabca2a5cc79089061bbc472c12345d229d8f0a071462e121e14a799d2839e7606f46ee5990f735e7263ebaba66aab7a1acd8fb565487faaf2d9cd97abe43367632500b9b8663c4d479906275c6b38e062d35237e4e65e262761c7d973415623cfdf99cda962edb7b99523438ec679c2c0abba4b574364065e9eb20665ec3308ea88069f7bf5aebe1c1cc16d1c6b6b075fc3075b13bbba6854c2caf3dd3b4b3f0255b993d4451ddf525d0442b45d7042fa521fbf18aa8714b614694eae835cca5c8c131964286edafca0bd3c5d1ceafa3839d6bc57d5993619bcf108cbb793be9aae0087fa952c7826f165e91776011c4c3e838a2f71812e5e5840173bb3c2f7c957770647d3f881565687f475d184cb40192f20e5df65af9571dcb35ba346b0dcbde4b2c8fdc35b026f05590a38d92b5b9749b9210bb1f74d04a7ae212fe87ae1615549234c59c946434900d32d42ac14b8b8a450a1ed39d50e7df24a8f1e1d40a0e0471ce6ef677a7c3b51b4c93277e5bbfb28d64e4eee32d3ad6dab619c118435f0248fcbbc1ba16527fa15c269cd9081cf51280cbcf30081f0dcd08bd8ba1c1547d80d512a283f670600d4ff412ddfd4c0447fc81ed10605039e51d04b89acddef66d7c4e0d4e0a50ba2750e1e84ec093cd01298efce845e15af33f399ffc6d628bbc27550e91c0c7960a2388ef5591ab5412eac7be0c98535e1da3376a51455579e6ce2515620688c5522f96878ef88489974c38d249461d5cae027ee6288a5afde310fd8a68b73df8a336eba5c3cd67b7edfaa8c89f50791db4baa5abbfca08357550bd4df479e624654e1d32c287271bf7611ce11420440266f39f8c203a15d69d445ccc515772d07958c535f96f63f535d26d5b3776e88d780f86e5838c6ea11536ed53a9a607b163ca990c4201bfbddc1f8d35415f1d06a6eb8c0c80b00f7860b33ad47573ad8c8b962087769b33e313086570fd2450d9fde55bf9d24d839a7e3dd8f366dab891432d24e8124424422366ef0f65913764173d23f1e5008586e9619f6b10b3db251b397520de657a6b55232135399ce2d051ba5f195c6032ccfed0b10c9247f5fdedc957c60e96cabdb3c3a1fd61918aed038ed41e0365702bef550524a05d8103b4f7753c6ec0a2e2f599524176b5069627769bab6cc62bd1cb35bc89bafdd21f7412125b8ae3b8a712832973e85e8509634182670733c8750bb5d43ba49c690e468d7c4909d1977415384c9fe732b20fe801b564e334786ca516998ceb891b625f8adf7c7eecae3a26bf87025e03cfdbb10760bfb9e6b10dc36a67c5114ffb68fef919f86b2e095a9a59ac6a2805181416426bcb4806b2258ca1b016d5f7abb26bf42fdb96052e052b3326592e3d848eac1b4b4fca11a4bcc8a9423a5a0c0bdd912ec755c217c4ef35f6f5a642778718945cde268025a33d2967009d517bc2a9acee9f983eec16db69c1379c60d0f0f2b0147a8ac87c1baf5095cea7a0a332aa0649431a3d90b4e82d031fb3c293afdb2861b32efdea24736918f7df50977871ebc30dea7f16ed7ce23a180697a9da2ea9732b64ddda573442237ae819caf8c0fbbe1f08a2580d26309622582a4c7d7d844f0a2d6747f060a9bdbdda4675c74565954c381da5638708650dd27c0290935e2ee18573659860fb53e9616f1f1973eeec9a459a834f92ac25811355f5d07917417d193f4d0edeffc376e1c40701edd89471f9f7c6cdbb6bbbcda33056a8072e5de64eb90cc83f9d826d51ef169d65e10738711c78bd22897d77af5f21c1dd65f30977ae38787acf03419624bb08d0b00402d9c4924acd65933d5d3b139d38e7f3f326432cfabac0f29fad08e25078c0fc1fb2d4437a5dd24414b18af904145188dc8305b529d98387a1449c68cfc2ce4cbd4538eb496003d007652ff09cf4684f6479deb0f5bdb120c6b323be1abc4ac4950ef8a14f298d182427de5389d7b3f517759754c5b63149fa0699125a1ffc85d9060e24c4dee157b26c64a47c272c24dc3ffc67d4cd4d0e481ecae415040a9e2c887a66395b16c7b62a7e308b042efecdddaf96385e1640047f2920685ec3efeae2a433fcc5920c5d270f27b11b1a6166661df22df9e870cda7cd562aa29028fde6c66cf9f029bb90620da0da06290728011fee5680c75dc6111768a63c80a0e47feb074cdf5c76124f0b4a860c3a8663db51bf867b272dab36bba11d333e4c0a897604baf46a2397e928d6c475cb4a1f70d2f8c829c6a1afc3b0dcde96a1d75ba5fa23b6d1c40f9b2aef02cfc32549ef724d160c39410c4f3ff3d0a6c7c48b156ff13fb7a29c7ba197bb5e0d3201d033ef14f12a95fd5f85ab06cfae15774264237a3c8200436b18f742184dab36280f9890bef6562529d87be597a0baf55a0d5db5c9211fbb97048aca23fa3d52c10959520d2e85fbdc191f7aeb5f00f8dc994109a0364614c58ba13bf8b652a9798b00f7ebf6a4124882eaeb8e871ffe6dc39e1a394a0d3b9cf76d3ea720e516f1c08791ec5c843910c3b3c7688fbbbdab47bb68c532c9f134225fadce75c71ca2ac6e9df0bcbf2d43d4b5dc2bd144123a94984b8de57c53905572f31b569668246b87ea06338e4d2160fa0a8406f901bada7846b0a3376149042ca3a40338dbdf6f77431f3a447bb0c0aa273b74d7787824970473ed2c4e06d575f0c36ddbfabb28011c89488c2446f979f88ce5710fbe838c80d849ea7271951f3bdcc7460c645b07a590ddaec9331b6ca7dfb8d87e9a2a56bae9257105945d9872f66f50750597e8e0ee9d8a8a90f46d71fed6d184074411ede650f24a44de94f11e7fcf56d551f9d4ce55abe08a7b51700898558eded3acb49c0066c473e996748397054729bcc7a688d32671f9c7c89e879f766a107df01ba2f31affa941548ca7053334345bee72d463c126a23c5fb96b4a924db744528f07362aee2d7a2ce6d01d856bb3f60fa7b0706696702ce9f346baf325ee7775d49ba4395d8ea1169863cec4e77c178d340ba30c8c07d34c017ad0e2f2ef0b6a6dd2d9c13b428fa93f6f4f84939058ef9d2c7f53e1d105527aaeeb7e733ad09e902b365c5c0af1fc4d559020b1ddc9e353321726a043d212261901be6e129f3d4d87c1a3c82c82872b603b7e159e3e5a25dc0a1d464984a5cb434f2b0baedabf0dcafd284176418a16eec976d2eb93a74d6f4889ffacb0a048c99161d5b8a107611d34d131b4f71f5f5639104935496cbaebc9b3ee744908d6afbc3c175c3f91fc367cb985c65c411ee0c6a978cdd51020e4c2356f6d153c6b2ac0974764321f251a897313751b4fc69e3d008947a485b6a1fe2ac24996f42f3c69d6793cd2cdbebfb03e1ddc3ee822e23eef3df0eb3b844628cb89a16d08ff5f002c482ef386959d599cfc18c1ef2cc86fc02f4a0f1707693382d0dbb9733a318301755bf1db561bfbf6eaa4742e333f4a2663fb3a142dff6c1ba0c74d41cc22c3ff12ab618a0793f00d2732b17fc3cb780ea7aec3a981b59a1eee75e3d5ddc1c6d6bf7a498d147e87dcd6a0179339a61398d34f5a101b85fa0ffc498597658b6762ed92fa1ebdd74be5a14fdc924a36d3c8000498249ed94e53a5008a1d7e42642228ca0a0210409604887799ef8f7b36ea5445565da4c4cf106ac5ad8bb584f71d8ab5a425d05947ac570549f108816fb26deb8a03b0a9b0eb972d108565a01b56a141f857d5a5fdfa2bd40b74bf9d10b1e33f6c1481a1f55baa280f79a8681769dea7391e373a8161a363de51a04b2f2ebe817726fdc1ac9335a8fb3612628bdeea0dc8ccf733b93ce9bf603dd0b02789fdff72441db9dd62ba80ed9bbea3411cd396fa901d33445f0bb478209b1d7005cc2a97bc942ec0ea67af02ded7b5b5a9d13e8f5e00db94621006c857b7d19060098178cf31e86cdd587de77da8fee4183472ef6d421799f133be859930eb7c71cff87f1a1e0c275fa6e3d3b82ea38f321a4f57ebbc3b008e602b07975a097c72d8c6261b71d4a2483095b602f78c75baa81d41983078ffd0fefbce0796e2e68225e18f6ad981e079674f3010fc9344580fc9d0f95d9cb704488ed630c82cc221d4c86169244588ddffe5320ae7bc36d4f9ea080ba12f11fdf40066146e7526b3aafc947dbd30b3d8cf3334d99e22d93e9981018e900b25ff25e44b93d8228932cb918240e83f887595bad2c4131d8ed4fb3249ae253a6f6cc3bf20465e267fdbc47207fce7e752aa61d4db84ce9b60254af351e22686ff575f48eac2a39519255f77c4ffdae2a9a0e62ff974f30e993bb9777f5cb144af7ad683a025a070dccab7ca9f06db5b218605163f76d42529ee11e4842ec6d2f53efcf06e579577c65ab49da4e9f7aab642b5ba624ea38f028fe1e5ab8b426c0dae4c2cd8454f671e4f2997db69576b8b4e48106f344b1c16d3fe3bb740e6277fd93ce698f9349076beee210b51645f12bac6f0bce6ddb00565069c60249fbacafbb55c70858adb3cabb5a8deda92a3334caacfd395458697735709ec28bb9c3ae726c71d01c2b4590cd7d61a756dc5f6fdaf720deb033864217b4ad1c9536fc5c9c6b3ec3cc603213d8f8e3fb09ccc94381f58aed85cdafadd1e040f0b31e6d929c445e04633dda324da80df1bb10ece951acbca7253db39b64f3a6545ccbee9f6bbf8cfacbc8f43a35a8ca9325201a920db72a1b8c5a0f113af5527675f28f42a4a1b4d2b42e69ad34d62a4cbb1474dd3d9249710339e61e8f7d45ee1d992332a4dd2974000023e71442eb8f214bb878e96128936aaa40181b2af715b26f7b9fee46404b1cd895dcbfa265c4584dc006f66976a613d17de6cec1fd7b0ac9789ee75bc25ef432bbe8f7522c6803f80cc3908128278977b4f04f435a5748eb1ba13d2efd0f7c0811950da7a46e81a843af8d5be64ed6a87be3fc6d0d04f932c700581a0b4dc0f5c8e4f308e11260e5fdb5920cb7585b4238f5189b8a2b4e35ebc82b9783b88601353ee06ecce5e0740c912423594b58df0b5925715fb24e5bb9d3bb6ded15cdd872b2ee247fe4d9f10cd48b114e8cbb09b8eaf83ff81165cd518479c580721a4eccf313e08f9c0d28d4f3d2a67e1f8774d749b0521872349f21f7b6edc7bca0d4b9d2a6614417c020ff94291c916a0ee5535ec5b88a6fe88ed87e73c5c57d577b1e8e2124ff9595fdb761427abe17ffbc0fd3d4bc25fe47d43ed89f41d72e866982a7824376cfdd562993ff21e60a4c81921a436e8b815684365fcd228ced88501b3fa019225a7eb9c7d95ef75753d36efad1e6e5483edd5cdd3e973ac62711be335993c4b875b783a16f4a5b9d01d7c6f175754a94c265f5a245cb05a14df4e777b2599dbae3272db24e5a42608624c7f39e1bb26f46e5833a4392674dc7be368e3bcb9488d26bac3224f756a8b6a4b1bc36eefea70ef1482978153eb4daaedcccd5df7536fcf089b69984ab38f180944f9c88a34a769234ecaf5eea80c1c1fc3ec8a4710b4d22394f440e83e012162a5a0db1bdff000dfea1cb956eb15ded82d5328e1b3b9de68d9cad16d44d1fcd769739fc9dda4949ea4ca8a2fe3703198a9ea11a2015f5fdbef1c7fae27613626cc9ed407e88563d8a94301bda38dc2bdc31c339b6fc44b20c6bd8bb77b33139d3bfd6ebe53475d5a662e7cacb95649c31bf814fb348a3ba9914a1982e7251bb47b32c3f42f77e84a426cf1e75276d1fb570c48387242097e323df0e67fb54feec0eb228641802df74e0896200d8c1fb8fdb0f178212fe504bee85825c48c7e8722d76ff49830fbb38899b66a757657a9d4936da51bda92b40414da458e7e29d16cf511ccacf271ca2cd5f7608a6c5f9bedc85ac60b7e3aade67966ba24c99f772ae3466ba040a12ccc5a423301ebd9de6b786bc191cf7c0c9cd188dae88300158cd1f3df5d14b5e13ae9316cb4c3c15d1ed3540e26635540f28791fd74dd38dabed251891872b100f97c02ad38c570d34b943d6b42ea72583e81b2de75ea6f3dddb07ec5908640c57ffda3635b889e09d1a7aca552b6d375bfbff853d3f8826474f938b5aa495c1a26fe00fbf674d14d9ab282ec5cff8b84a7a9dd1a15ab47eb4bdd07314bce97e3cd033b485b0215e548a57ec08673b0af8be4fb9cac6dbbddb885132527ba36b8b1bada4713fce1af7c61b88d9b7ce72ca3f6423b10c7ffc5ca3c40cc18c949b0a9c36c3115f623b2c4efc3329977ed65d1ec053a54055d00961354c322f0f5e357ac79d210a4c5fde9d54bd3b44585f3e750d1aac8d7321fb68e90a4fd5dbdf2bf21996e6032a020f55c776d89ce62ed96ae0da3b0f407073afd17fa05d7529917c9abc7c7241dcfe25130cf4cb0510bd5435b2ad1cbb5e63cd4662a904c888020c56cbd594d2e415e463e38af33fa6aadf339a7563c64cfea04d47d3354ba38f3b1d6d1a743d174f95036cd419790add1dde81351722842da1a1f45381753d57efdba7a2854725cd5b4e406c87eb3d7b441f22bae6de7156492fe91b366c8ce15bc6f416637cc60a60e6b0eeded3e216d0d134a7381d06a68df7381f5131f9af3471b20ff04947b6e91206934eb60ff3b631eec0f2513dac22ce9e911d6a2c84c69b6ebc5a2f258516b13e83ef8bd5452bfe009b962b12ce762217452cb3ae65605670f68ff1aa238aba5c973e8d44948bea340fb4871011f84fab894d3b17af71b02113a0895d5e6b997a764b6ec57ab4232fb7f17290b3bc78fa40bf3ee0acb58377503ac65c4979c1f722d285f43b42a9866ded04361b543e37ef46ad0c10230d3a39420d82f19a223324c079b8ae67fd45f23a14a8475e0594efa240562a5f10424fd16145f9da7afae385dd5d431294549161339709a495aaec570a9bd14f6a3411c50ccceea876549c32037850165d5e0746b22c9b1e1e13afb5601af6d3a11231953b060fd7f03f9d27837480955323cf3d108ce17add271179e51f19c74bd6a2bb63e254d6d717de07cb7a88fd637df12ca2c55d3ac81ce067e7515ca0094b4fe20eb5ba58ff9c0cc7c92c46e919c7303cdcacce44b04adc00eca836e5dbfe63258e97a0c0bfc7af47aa153a741ba21f0b22baaa6d51831e0dca916aba67135f7f939e15b018542ac29c1b043f264669bc287c01d07a810a991087f569e7c4e7b801d2ae0a32edae6f9d36b6b146cba72eea752a0b44569a16fcb262ab44fc3dcfdd151905d5edef9360c40e7a6d0dcd9b5d2e53579a4cbe61bd53a2ad2d48800d985a37f9ca621accc9bfe7016b685a15fcfd87d4d72a7e5174c54c9f0c0c3b21b4b59664f3ce11c1e06ece40e2e4703a51c88bff30728213ef0c8b409af1f21bcd9d86b05c1cad644d5f1211f287c78ab8e6c1a0379b7142888811d2a51d1f14c907df41268ffe814702b136dc2cbf10b1de49a593c2a769cb3192450ff5f9b5500980f60c0750c5372f3c9f7a469ce920390f21643252b3cc1048acf2673272e1060cce8a7e808e31e620d92316a491285df5e5461e3626fb7830f669764aa23d4815b9917c02f61fac04d62ba629f8afa4003a8bef1d2582a97733bdedf3ac4c634d1401011c262cf7a72281d741b41c7b0c3ac2679209d9ada05466bfbf58327c5616d009832160bc416e977f8caf66a54f3e337cbcf2e5fadb212e087bf16d8c72fd7e6a0f1b053086d316cac751dcba1389af2f3f84ef3d4bb6beed299157ae81da0e98e20f5a6b92af57b8dd81430313a5c341b389760423b7750db610ca8751aa2518f91f9c407d00c1bc692ffea459a79eb662dbf09683a47be4943d6735e73f5d1844c38edd5d989046fa282900cb27c7c534c5b7d865cccc2dd18f0d421d54f4bdef231bdd0a18691df2aa7178dbceec36e4225bed1c94f747a22aa54fe638999a2bf6956404f7a5e5f2b91b3c56db47bf0453502df2b4845f61854d1fa46b5f34f1b6d952f9da39fb078d25bdbd6a46e968cd331835626d832dd792f0e71a6dc0824e4092cc071a9b7f359af971c8e113bfab9ca0775cbfddca9b88b20909a5fb9a4f5e358b63751cc5ab7a8daceffe77e8b3af11aa12bee9a2e24bfa2c7261f9dc8690f5f277f9885ac91d5c1bd30ebab33d2eb2e5dd4634a1e1296b2e1797acbc4051b7f3a310dbaded95bf28424f878ba14ef760216babdbadc5aaabdb768e00fa71b89877c60696b14366caf3ad44654a5dcaa02287ecb9655e6cad34ee06d9589b4ec3bce171583287863a6ae50aec6243f5ff364917675e1d039966627c2dd23f6032bbfef254ce3a1d0129dcd91a691678e4498a63236fef8a9742232529a5dc72577138de739f30506264e211b0a4a9742b2964f7a05bd36278720f4db7849a6cd937db1c8157c138e3d1d5bed2d695844b0d7f79d24adf641658379cd009cd3fae2aee38486af6c4d0cdf894a9c4c860730413e228bd74de5d8e5a7a91571071618ed8071ec46b137dcf926dd6d7934386eaf835ff02ec7242656780a29597589114004b710e48f8a03b26728d1cb67704e2d34a51b1e25f066067da1c726cf64912007e42d0349a11b5204e7bea0d6766d43faf59f8c1f52a5961664158e3b99f3ee19a7145aa577df36b6cb582f8604629b600bc1e72e6c56be8bfe97c19b0fcc8feb5dbc42cd55566bcc8b7c958625f6a99a9d646dfc107394a8ad2244756a5f4735926e9ee4a8ce1f2bd40052a767378461bfa5e5297f7825ae3688208553ed054007e6cef352ff0b2d2ee5de44e0212437c3411e2b65efb83afb4450ab833c70f7ae782505dee73b25c90aee655dc0e868a09ec439023cfc114cc73c3b548df9fd5f3f065fc0063459b1de73d79d270473e033349b37d82823f1cf34a0eb29076fb34a42453e68e06e18f37fc7a60dbaaab4e500f3582f974d112b5d7458875325e1f2b41a429ea6ff3265cde7780e00b9d0616bf446e50593f5af81663b2a49ef6f8e1aa725d5a15ea6cafd31757c36ec231352e7826ce2f0002da4762817cf0332267f024e18a33e69be19def26701cad7c614dba8e4b43ee58eba8879f3860015d5a9e3e18e63496fd7d047025e7bad2e2707b9c71c5fc549e23ff32118e81799826014abc4aa7a414c86022ff496e967393db1c076060b31b8feba6661de46474752316917c1de72630b58e4b9d00b9ef3a3ee1d32ac5de24c9a098d2f5db80be70fba1323d2c971174e0ba37e727c36ed6bd6507242339c064cfb7754d73fd133e71f6b33819113ea098299ab3d0ea20a907f036daecfabbed25ac5f6fa5ec24d3531ff0536847362d6d3dfd2b3245a74ef4e1bec870a9ae924e4127210b030aa9baaa88de3e6c82d8a0d38a8acabdfd7dceae81359d829881ef5dd1235b8b35b392cb6f39ec2048e88400848f3825b47a24c130ca8a39e0043d6f5754e11ce24d2e79301db98dd8e1189240f1a440926ba63ed65c7c0f0f2d51fbbb42ca53c9908b05b9964096dcd84d6d8f5fda0fe1f6cfa8a888f3f424bdfcf186537575659c4acdf4c23f05864db8b73e48005f2a48f2af721705b2ff14e7b8420631990bf6d9692f33e605a86b46b8e1da79c2749c8c7dbd338bec643571c477f4cbcb2022b136c1bfc1376bd0a548b7ffba4265d3b2ebcf7d01f63491368c873f6e721192ac2b94958e1ba92b69ee7fd4bec9bd062f5ac3fb83a9b5895f3f94d2f6643ef087efbc0ffc6055558414e994e5cf3e78da8c1510c9b73b5475a48d314a014b560f05fd4cdbde7c41d2d305edaa3173c54a6ef9a9643619db488e35031c15b73cd396fc4c058913cbf38249aea05869d021d42dc543ab071f394b5be56c2c4e43d2e585b39cc2b76181f5e3abb7b6f99d3990486058e1def79c9d434a893f1a16a58b9b254d0a9d7a8f61d3bc81690fc1819cac013a47a8b08eb4d3a8f493743947344213afbe947fd9ae9590fd93848bc243324f8bd6abcf94e3c621db6cbcb930e20f552ff598d623b53a45b9f4a67d43a8a094f3b43b736693482cb1d5f5c9867f2c8ce274f7394e2755f51e4c327b9bc24154714af9d2fed0eb5d0e2ad974000d4d8faf31c7fa258cdc03dd3c11c30f0a642e5e0c4744211b18d71288f5185eef7a6143c87484c8a38c8abcdf844c8248afcb3ade4f9b59a4ca8cfaa1b70f8b9734ea3dfe56181697fda24189a5a40ae1d57e8cb297b67708c0c6d7fe53ab513d8d90e006568121734cd0958365db74116c2aba3accd892194c27b4ac6771621db5ddee7d61be294fe9f30ea20b138e7736504425a701ed8ca0c82b3c493053eb40cb149ff2145c1e73513b4b59c0b24588b7c45466d01fc2baf108ccda455ccfcd83282e7cf8b1f8393656676d5ec1a58fbbed506a2f3e3ba7c2848a13460e38455e507933907fd35efde2c2498508e1ce4d2e9b4fc48d1180ef08dc6136d8f8039a06a338ef8dcf765952bcd02d91a097412360129f02799a72fbf79b54aab79bb0d3e0810be635957f62792f9ceb48c0fbdfb1aa164fa157dd9aa8ece5395dd50ef1f0edf9edc7bdc76f2ac28bb90de186f9de62fbe37cb71897ab17f0cc64c01bfd7a5a8d4f4b8497c0bd7fad7e3c895197f190ef97a3bba769f7077fd3bf01e77e83d58bdc49f20ef39aa2a0ae08ec0567615e241802ba1cff36d0a3aa1322033a7322d6fc4ffbb801f30f10edb514abbaac2db63cd32dd53d92f892bd44bc953fe69ad3984e79f835bc28832d4f2bc056cf7ea1af0be9bb780b12ea928b45cfb3b11988931267584163e3377bdbd58092bc50c8dcf4db851948bd7c9012343bf841f9bcab62701fdba295cf7223a2894e87708cbfb3209964e9570b94ad7d75233785037abbbfb15c4a7645a7629ec65212663e7feb211ad22d8f9cc9f8cb99c0b14f6dff05b2f25035462a4ccf82d2cd88080da288646f35e6fffe524b7d5350159a202686acf7ef68f6974242a2aa165718301f521c8ffa156b25b364db961dedc23cb83e8af655e617e717c2aafbd6c34d61b63fb6f6e70359bd204af92f724559588f801b5b95f50d5515cff7699eebbd99ac3a1ed6ce5ee69ec4cb54c73183c9894b15b7412ce3ef2e6d44f563b2c3048cf54cea417fcb826ce684315011aeb6e538937b423445e9327db9e8f6e67e2f48aa223bac4a21f5101ea8ca602d5b8e08a2ed6e58464f18f7e534b6e41a4ce49ff4c9b3afaf530c6b233b4633ccecbbfa3aa3512c2791867ddaffe4852d441fc4e8ef883bf3914c6fad3359c0239cb0177e53593275f33785c9fedb7f9dcde34434b3a0257351279a2e25068e97f9c261014526381fc76b2718ee0912224be449876323a27df21aafdcbb70dd9c34aa0a5ec8a7410fd12a373b2d4d1a49ab5496afa4628f4cb2970c5c72a457c410bb30baedbdfefc5f2800eb56b2db4a74f797ef3304871d73c9325e43ff793b3f7353f544e1d9d1235ac3332e7248b691535d0dfe9f3217213f6550b20fd802eecfdc9935cf547c605f60acf883eb949ae62a0f61327e52c7e2798adba37e2283f7b4a5db01a6f8f1ddf6246202796425a9e617846b53a51e38144d1450dce1db4fecbfe3ece22a5e7eccf0cbdf75ba2f6062241df64907a2502d4b6df49ba5ad46b9d4087a06dfdf09cc0ef03ddab72541e309311e0767f029f11c26c6077bc4af043e46520cfa6a5ce415bc0dcf030dc0c107d6ffc5e4de1d5f1e339278de576f440c5d2d757212fb9f6c07e36a3243d049bc50062592313a753af563d4c2b6294402f0f82c1d079353af5d12beea6a453fa2be047dc54b60200a6c2668b3d242af749f207fa1c8f637510175320c6fd35f6bf5fd340c1672d25f642d29e8cc6b6157731652e8bc9971f10450a10f58b2b454dda44241f67b00de450ebb075de436b6208ea7ecec0cf66c1ed8e9460f51278dad23edd9b1da7c09cba082dbfa8f32804a71eb93fbc5dd6bfb0d0686390f767c5f59f92f9738d485f0108f3006b5930cf8953367ef2dc4278148c441c910d4dad805e178cda39948a602c71f8a80fa8c4bc4f7e423515321814f9c732ba85ad241fd52f0a71ab3a688870ed7b47569c336f9550c95864b76a2ca16ce3b2d2732d88505b5ca334cfe6eb8407566ab8eb8f454580b06627e4c4e803acb111453deb07fc6ef52d6e0845f10013e3f988b9e8762f14ea02e4727dad4fe52e8ce1e0dfa9c74d329ee6e4c0008fc9cddeaaf9ff6ce78a4759e1a27bdb5010a6870b05b7927426e98f8291d29e5dcadc7fcd50396bbc401ae88c28718757770ac3312992b90c558d537ffebedcb9262f743cc02398129939ae9fb4fa8885e50e9a60028a1853d74c91ccfad71a04b2000fe89ab090f4507b1168d3343be6dcf82fd1a74e6832e08184cf932cbdaa1adc42a59dbda07db1f443b5147629800f063c93b71dc5ae208db2ad71df8f50decde48b2e2665a4604c30eb570cf30a0e0451260a7c4511547114fbc3019ac73ded68fa9ad3069fe1e01cdaad8527996ad2ecca0e882eed8b9fccbf858ec798338517122d372ea088a47ad435f794e56bbc402a3df6a90c88b4e5a192030344845a300bb82bccb727ce527c0bc6522d80e8cef46acf98340474018cc87ccc1d4eed2f84b579c7a42edb31efb5bfb2f6d23ab65a8d0a2210102d2ea9b5739ce0a25c7f61529aafa7cdc8b5a02dd36f777bc93c234878b4fce6c83c9b2f7244248c442524f89575a94e6e60be2f315427b4c18df9736dd0539103486fc3181394bebb3b10e08cee79d2aa31dfd36ae83e226c020b643dad3c189e65d23b16211bbeca5b3e4589b94f07e8275cf1bc2678c72f95142fd58fca31f183635ae4a3407a1b1f94e3b4c8e79201d907a5eafa31c066823f0372f750c7dceb16ab6dfe5639b4635e5f0d2b3d66792bf90ca10ffc5a42e14f70b12a108a0bd003bab2f005a8cce93c1ce75e0b0ef01c36beb2a6fef981f2f40ffbabc5cd73ea871514db81a71cafdbe12fb2e8eab485cbed367efb586da0d593d2bb0d5212bb93dcac3f221d6668fd6b77e93fdc6716f9a424ef04053f9f151c57548fa00afe89572e7b6f3927b7acd1ca0604f10d203d92b7eee0f7653998d21daa41015cfc85022f49f972e4edeeea4d265d20e4828c6c2923164a12e920d6f70b4cc2ae40a1531bd7e2e150b3ea6213cf4fbabceedeb723b1dde04123406cb9bd4a28e4b8af5724f0a58c69c122afdf9c300d42cc85e46a75bcb2a3a5c3f7dad8734ff4d6e4d3c299935b4020740f74aa79ffacf7db74d22106d256f86eb2385c9841779530731c71b068e938a928b40915b968fed2afbebf8cc6f9e0f2ee9c42d2d54d8afe699b7b24b6964747fdfbd847846a9311c7e2023b70f979deb3768312ecfd3a66a88acb2315e575b5b3b1117ea4f52882b071e2054f0825bd4bcb340865086b3fae724004305a37036eb3e2dfa513c30728b6cf08d850d7309608689677612e5abfd0f799936057bee5b369b682c8874db05c51bf78c7d20ad5a92df3dc2b904330f5f25e490143d25111765173620b9d26b4dc31f236acba51a1ea7afddae601301fdbdec7e741de0a2175466a3c9a325177186fb11bcd58778e517534160d4894349b0c7f19204b6e3587a600c05a81c6c6fd60278706b37c3ccc13731744270f0ea573b7772753c0a9d71f4ba4451f039a18e7887cb222c7dd2b733e4126d985f31498a873b9ae3d67fb377421ee544b84b1787e516ff9ef4850ed0b1a1785dbd047c120edb04ea4e6dbc86e3cc13a1c61d880846271780b29f8674d0df7d4437e749713a353dcc6a845b753db471d0365295a18250d4a697e14edb92a366e30fb104e9f21d6fee7bcf476de50bbdcd1d20da9ce495761a888ffc2dd9947e031c3d5f0e234dea69e990ea7ceff8e3c18c3c0c7ab91eeedcde55e9abd1fb99f88e788532ed89679bd8ce65a7930dce382c345ef15e1de46684d3aafcea59a405a63c2dd7f9b26b280dacd0fd2a63718764ed1218b38fa3ea725640a4143faec651954147d18ffe3da9fe4d360579e0a56456102ed0c57673762b81f66d2a77acc4d073c72bb012ef593cf2896a4c7001ec1c6225a0f62109542f32d11285e0fd17cff5832360bf915a2b039d1686fb7c3fdf96dc47554568e74b2e5a42ec5f977c6e8b17a66ef36e3b6baa168e4a53f96cfffc0dc4fe5760cc3a679627060ff2a0991d9136e0ae84937f7a874ecf751302cfa43ed20c34c023156acd0d54791c8765dbd9c4b565f012b366b724303faf6b5868495d121ef0c6249e47bac929637c449a5f27f9b0f23ad3e50f445cd5d56ddabcdfba14f8b754a5b8e7cb740440cb87c05cb6bcce45e79c112179a4773de35303a0bcf20fb6f84ae20a4f23b7cbf076b2550b6138e7f792bbde8d8cda0f3dcd3d60b8be8fc7479038f37ce3ccc5eccef9dd7948c758851cc16595d636043c99fbdf585d9d8a2ea62e16a2eff6ffe698196604bb46611e095a66a423d8fbb4be8778b4505566726b16528f5189439f12b45070f8383dce7f3a16e21cc4924f1acb949243728043ebcf2843358cb0831729b52075fbe3e69df8655fa1c2ce1c53ac7478e202826a0732846b0cb3dfbdb550a05f23871b4b075685b904e1e845114f57fe2e10002024e14a0b783df9c772bdbd4fb21a7fb4bab83b0e2807b6a20e8f0269c6612b28af8dde747e212fb2aede036ce80e8ddfcb937d231b128269588e0e0f49ef67040050d8c240d2839c2c6486265982c69b5300f1d1e1d4fdff21d02fb6e6841fc457d82112d86bc856c5c98698415dc54cb8fd138dc01fa4162bac0938fef97a62811b3936b83159da1b0c42be2d6507a2c05e62b086c39c880b6fd9d193e305e9b11b45cb5e2de0cfb1d37aaa448467318b88b72463b69d49d68c9dcde475b38e211de03f1869560a822c9b248cc44cb07ac0ace033040b01d3a5cfe8e9d7e563113582e821f4f6118c72fbd263937de0b75eba3571f68b3a9937c3d9f45abc2317860918b161ddd4f46e01ee6cf0e1bd215006b98cc8fb3e20816c098a9b1c972d8da5b80d83d408537af828964ee79d45e70b463fb0ec4f42ced301cb5c30bc78326ef67aeb736216b8b5993dc6ba54ed2770f6ade64303f8b43d1db98e9666c6838b9c28c8984465a2de3e7ada0180c5014e5918d3c1a71749baef05faba5a2997c13e9c354c5b30d8eb472a6e64280865ba1ef7b1192186381c26373ab647d569f4c672e6b54c548d07b797ff56906955114148e052e169dbc76882f2f68a19fd15c16cae6a40dc268fdfd032b856b33e6623e3835008b707f4629753387e9397edc9d8cbe02d2d499cbfacbecd17fa721a751f00863ce7de0417125fda1e81474cd5f27695e749a1ff80487ba6b7e471529a9d77d07dd50f700998ffd849315911ee47b062c61587efa65811cf77fddb2a0f392fef70cc3abb149984107a5b5ed984d8339e34b3d9f35516ffd2ee03d0485f0da30abf2154b286bc537447cdc92b74fe53d1417eec837e336744e361e3ece2f617058af7b81f591bd024ad576cd180f57e2413feb77704b63378ad68c642ac1c2962c7cda834040461fe543b10b6b0142db8a3c8f2c96b4a974a33380a299674e7ea44bd2d80f90cb4f834a329796eee4bcff4d29314e25f1d6bea520262a8dbe7a1b981b9a5e668de6d7bf208b34b6c72ddc533d1d5d60ae42b65cd9693b4e34a6a740ef08bc91337a1c60adeb80d310206d72250ced2876bb06dfe506dfd6d4e33aba83930ba27deee95f054914d9b173d6cad6a37e23661f11943ab6a9463bee5665e64ffc5398cabfb849f6ca088f4cc05a418efc9db7c51e1331557a66a3af05939a91198543fbd83d8fedf5fae84c4c44039e97829d43fdf8d16997b0c18802dc3d2b4d0e7d494277caffee1a340f0e16088b494b20fc313a9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
