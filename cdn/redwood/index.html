<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c174758df1573d311d28c18db6afe16e691b16eb4574a5811c6478a4c248ecb3c5e86a9ff74484c990d80c5ea6ba2dff3ca39a06c39432b9eca723bc9f4340f4886aff30e3e1e52ced259471b99ac0f477a0335bcac567face9808ba16091bab0e157c93e72db2eb88a3f65373f9004d3db07ee1e61bbe1a7ade9266744fc9c4a89bbdeb4ca4b8253f42d9eaa930f1ae5e0627af8b76e3fa9e631a3e4e597b665f7b63c1d6ef30c0f91e7136c1515e514379157af5bdaf02621636e589f0030be230977e975a5c79f5c0c7e6c0c66308d51b9f7c605260f19852bfdd44e20a02e22302b84d0596c37c7c13ecbf6aed69dc4374403fd45b6ae04beb762ea5b18a7d95f8150867d1a677a710e8bcefab69c0ced1ace96c5caa77903d0c611e5116763d5331930dbf30dd799e1b7be477641e491d0a6b28860779c40e911916434565243b0c8ffab21c69e61546bdb36aa2655004f2b2b7edbd6214ab0e27640a8bc7f02005a83da8abe2970d0ee5ba1190774195d64850acb7e084798f6079f357845416b6835f875ffa20d0c9a2afb2d6c9c6ff146a868b6426f526f5f31dc7ef97d141b46cfbfedcdf460733c421d0ac203158558bfa0b55176cf1d981367c0203e48099407ba2acac1d521809a963b30e81acc6984e022204720f619ca3f072c6b3e8898337d59b784291e3a3a396b325a3dda35099c1754591c0c7ee5f14643b298a982659d924e0f48dca2f3d931f7653ea1fd91f0b669365be6e6c02ffaf3901cd7dedf2337c3e0a2a2358e48f00d22b4f05beb6d7db84e6b27ea6da1e36309c272ed89132a229edb14a49c67efbfba14507ca2c1f2a7f83e4fcfd3878e18e7275e9d2f8d0b5c5a08fb4c1cf423d8dca9cb4e15fe96d649f0a13ed45ed9afd546dfc120a21cf2e9312a121de09dffa774ec9e9605e68e3e7d5ff715d58599767be89a2255b48f09f735a4ed4b456c02f1b3c1e1c664d32a876ee238d2da5dba13fbb1d6fb4784e2d5ecda764030eda09164997b75c666fddc5b0a742f1a1102b19886a5ec6464ad3d40cce2a6a9079ca05b2d342bf83fef779bc31bb6162ddcad62a2be628fd4b4dc337d45dadbc737d6c8c7b3b4011104a00b10e8725f051974d716aef21ad100b96d510cacb69ad417fc67803c4ad1aefbfd334fe0f60dee7ef3963b2320aaa0d45ac5073a6f57c8c6aef9b4459e72255a94ef8c95d61b9172e10129b46af0519ea18e6bf8c3f2a0f0b036c1451d0ef50fb2f3607b3bec16cf72e852b6ff9953687506f12ab0d04c936415cf063dd5bb855b918d5281a43c563fbc78512ac11f84c5b95ee94f75191594c517284fb9fe5811592ef43fa4407b7517368ef25f0aea662678c9ca9e1c2f46f46e4a477d6d5c2efa704954420c0df4a9b92d420338e4dcff25d6f5d4e902e725e1767a5d941c9337f6f7712f93093180e76668fbefbe930bd7fe9829534b4eb3258964e3780aafda114d20a009bdeb65cd01e5451382f3cf57b588ca8e22547cb5904f459517f9b4973fede1f19b2374fe6d75c00576a3e5fc23068172b9e340784c57d78a9ac095f26d1df711b9bb1c0cffe0e81257a25f4867bfa92bd08c25da93d7a597c0a01413a6ee86077f1cb45302f1f0c0a21ab1fbca5ee795a22e42757d29dc99ad3eb21ceb0d42e4165b8d9a08b4342f05153cf6e9bdf43d234ad1dffbacacc60de0e2764c55dbee0cd889ed7200938e3420b0abbeefc5610457c445c9060e6aa63a35d79aebfdf2425f235f5fa315b4fa504007eabf453b2bce31a5b5f47b4b6a0b3716f9287834ecb041598a9779d813f64c8b231a01de735fd555cccc61477d345a7f03a718591e3f9d49642b15626ab557d4dc77f1588671844093361dac142ded35d8e157ff3b88af32d2bb9ec529d919f10496130732766cfb4b5b366179039148f89143fbc7e9c1bf40495c9a1f8eba8b4105557387c9f732501d27d1e3b8aa44e041e87caf5290897747de6ac3f2ae598ea2e84158f3939b849132498777453d85c3885bc9e7c7c3dd60c277b00b0747d2014ec62e44a82477a85a90f69ef2101081a784acf8f2123c80082cad9a66f553028369ad51aa671e2c49f9e06283bf7a9c0593fa5a34837addef40524b9d1fe2dc681c46a374b76c9f880bf21f3ad5ed001f1292a1e307c0808c7d2c0f54623596736b5485c36673b10816d3809b851dabdf1e6cfaca07fa2e17993e1d7485208301464821eb87556b127d13e52f2d74da52b89584ac2741da2d71d4208ddabbefc10170edf539607d064d7f3c7d365f2bafa9dedc98c92c720b70ea778a3eefe8f37ce60148211717716bfab27557dbb368dd2f3c62a38e49c628d932f7e2d63a5451e481798c043bd3fac5dcd3643e5c7d257b3d78aef2586d011e003b3c008dc0134041dc15fd30fbbb6a4f636c644511429828522ee3fa56c8d6c6eb96ab045a673ffed856b018abdde5280453ddf78439743de1abd7bb96616edc6f6fc5af57e6d52bd5f7234def064ed0aca3de3465a3d976b51203c9a0096297e56dd70fb3287e10251ad375f2361bb2a5db01f5fbb48d8000be63e09f4d4ba9ee5855cf257475dc379d92c106c2fc037f51334e5dec93025db79a753efcf14361a5bd8fa20a7a36c28d2534e04c233e5b6fdb2f0a66c13d48998989cbe30d4e9e8e62676619815f4bb635e533890ca696591c8f91995bac0ba1d9fb0b7a1537474a44c14068fd0a92de69a90ab2994c627dae693117558d0f8f1610034fdcd6bdd1fb73ea8aae0d04b33264fbe3d8328a318f3934d7f9411d23658ab2922a1d2de61646ef4a8288c88e18ce2a3d8dde320ed5aa316d148a137edea41aa9db64665738b340046965b7a063a63cd8d78bba3b8b6a94247b3c5e2c0f9a13fa35a7ac7ddb1cfe885177caaaa5f317b3a8caef888f6f623b21da4ac8485c1ef5140ecb2d20398499df88079d1520e56540e06f66d3b638a2dae6bb371fed51e5a2951796cf8117e3431a7a3c5458711196970dc1b9a563d94deeecfe663e9b20fb5bbc319a003b1d0c2c32f03d680ea0de69e68f9b2937235db34e6987033b2b59f2f9fd58b24497d4067fb3c8af0b98b6e32d74450fece8752bd3503387ba8e5195472ac9f54935012d909e286dcf1f80b68be39e7c09d67d8d04b39ebeddd031828a674d5999db9bb0bf3ce2b1332355ef890b90f70154bf6340b33ac6e264d87db391739f2cf375182219efb0fcd055f2be63ed3910e0b8d9c49aa773729865a439ca06cdd872840387015c136403bec1a0d01dca573b50da5a162e66bca31977e18f0f6f998b8c27c295be1335c39f4167aa1d5c6a072e0ef179896774fb01e461c61b699f075b93961f8d80d331f9bc6f64a66224e3a32f6bb0d3f8be651a8e522a309f98f5a89ee0d27d293c645ddc1294b12e4e6aa54d9327668594ea0d89b81fda83c5486d023983fd8975d15f5771eed48ba54cf11500bbe70a7a87e3804d0fb20b44e2b26a6ca85c788a591e761c59121dbbb918e7c06e8044192b042a5e664a0ce1224dced3ad61e3e93a98e287a8f987c9865e2d5e930f8dcfb590cb24e4efc886bd4300604d5eaca33014250fb63da04e7b82d4ba3c9b2d1812c0c7328eb5b945651af54b35b54de318738466a1a3dae274fd47b25f4621420989838fc84799dd941cfb8c456561a0886961e6dccf5526c4746d4b7a8edd67e1e11db84447f76a95c18233a8ae92a089a1cf145b765756554030c45087d87648aaff793639cb2f4024549bc086cbc2e3d875d068fbceef2633f0da8bc737e829896dea4236d4e2caf194daa1a578d50b6a5bb0fd0042876e375bcd03bab44ade2645d2b413495fa71dd34454e5cedcf8212e60a2456e4152a367bf75890daa81b85ddb5e579f0b5274300d4bfd63c5d45590777a8ad7293e2c05f27bd021820c151201ba1b258aff12c52616877582bf10e232da824bfaa005ff944f17ba60f6194e663b562c08c8b9b3df56d142ea138ba5d86d023cfda05ed037eb7662d6e25060f1b16b2e146c1bdf4d22c08838d089a44bb91273332a417f68a328ea26f5c1f0d7deb6b45bf7f0dadc5a1227c274b5852474c20723635eb15429763e1c2fce341dc792923aa58c577d379d90ee92a6d1267579b04e8dbfea1aa1841439f2000dce4cf6c7aef1690146f426e374b76173f74cf408fece14aa0734fa9afee9232c2dc98b89e24e5b830e755d34c0c43581eb2133d8f5aadb7cd97741bb62dccb5d6424a5b584e7a41d1b3a0b4b7462fe56274cfc48f6b70c5dcd7a25472024a31b3367669c7b915525d3a99954d88b79b9dd2730048c5157066b81469174079f616a7aa82128787e00da2fb3d6ecbc339232693129f478d59200072bba1502cdf28a864db135f3c4f7b1733f1e75257bf79dd20038fa8f586fd9110a06188ccfd2424409eaec0e5ace85225bdcebb6ba5c94f5b31efef76446a54d416c2cd3c67ce97b93fe54c8ace4472434dbed8b555c12403c4983953ad01b3fb2fd9c157894973ef227b5dda1d8e6deadae5aae77de9df9939c86b0a8cf61e31f00e2a4ce83d94e60fd8ad876cdf83d31240ee970304f70491fdeee78f8b2c927a015cefcacef4f40294cb90d8e22695ed65bd7ea64bb38e569c49098a703751ae0161fd3d847a865b1f5d01cd099bfacb981f83601e17a7dcccc90459f52c6166aac149d4390be43f386a3118c5653ac60ad2152dcb96d90f15c4751b0d7443d160e034258c471b2e14e2bb92959f6356029218bc02f1e2c4cb65d9e5f6146b9d51d8497366195fbaaba972518ae52c9648e93da827a7ea00efaa59e626d485f30daac1bc9c4491e791581bcd580a919005a9633a107fc7438ebcc6c0ca7a44d6adacf0300d66a7c7a94855e99c358b6d798f87456029faef16fcf7b1341ae3817ab29b69cffad31282a4078d2ade9777fe2da1b634c76843ffa4d4e75ae1fa0d703c5fde3b080825a83cfe20bce4f57f48b7f89f470f8e72a5e9475e43b73934abae3b1577e108d140c7753a14334d8e02582fa32b34de5b0a9badfcfb9525ee153da3e74321370a1b973303c892173c98a6c461a097bc937dbadb24067bf57dee680b36ca95ff787db17b13fb5e82ff590c54d183185dea3311425c43aceb016b8202886db32ecbfca60ee755e3b647de3e1adb616f7c78c7047db0b9bbc477f96edde116031db0e015c4ab835e0ab4e659b1ba301fabda852edb94ee87b5fb7df063f50e4b40ff17f02d2ff4be0ba4203f0c10d00dac8bb8575c356fb90f15b99c25c4eff0fc6526f142bb0d9b400ef74411cf35fc2e2cb8a71b8bb67461cefea43b73c2b144da64b77a2ff2d3e4a3aa464e28e490d86dc9b53146a1ca9c7b72133488a4f1e6fbab6fc79d970c8d4d241415f4c10e172bf651be9c6bf89dcc2a6b3166e97d6a4ab39f4c3c4b0c83b2727101e3cf839daf281332618326e61ebb587efca8822030d44abbde9b7b2dba4cee7eff1ec4d1bee4c80550f44f619961a53cd6c11787d4b0f134efb63a57ed93d9a2df3970df3585eb6aff14431bbcf83ba9fa932eb14c922e2881dbc0aea6f891fd10a6c48b73ba92d1086da4921f6549111bd60027b069d2cd1642569b0132be5c97b047728d6da3556b24b5246ba4fc0db66947393325a2e99556670500699d89c2152d79fa2ae430d6666fab7785d75e3e4a2bd3a794166f64ff993074bf00a66e9e025ab7944b8e1620bbfb23c8967a7a5585af7b27054c1b0e0f345cbd6c0ed23b3e608d5cf8cd56bb1fb4cf2c0e1023cb75bbbe441a72967862c4c22dd9f7efaf893e5df35ba676f11946d283de048a1267d2d5c4e95241007d3447214f8b5c3d039440f3b72dd669d508ec6ead1be958a94a2e64b369b1ec13f07dad8c3c9c5ff67f2de7b4e94615ed939920e68ebaf026ef874df661a1bc27ede18c06c15204c9733737cc96fa4ff38028d709d90ce12648797f0ea1abfd99b687e0f90f7e4b35efc0da92af091d54c8eec8ec06b879c93c1a3ad5e63fda7886bb5a8995ae108007afa008d1eb7cda680a75c0881d9be4e9b714e9985bfd189434e9074724cd414053d6064de8bcee3cd3e34a5381b6ee427a5065324d86616cbd3e9b06b757c3bf5172407e505d6407f990801a2c4182507a640917738afdfcf65f1b7996c8b39e7fcfe4616b6b1cc5c2918299366d30f36f780730eb873d09f8ee7c32e75fb7d9cdeddd4b2d481298abf933908366dbf7cc4a884d847049702af867bc34cf1e2e2753dff37590d7a57663c42faaf33dc937792d21311b4c38bd9b49b9328185ee87ee129310537df4cc5c21a240f054990106125508998ceaf1d0279894806e32843414f9cfd2abb4938404715844dbab550b2f826f11bf105c7478f67f1bb55fd811298c8c90b4f504cefa39170be8ec5deb6a4540597b982b2f9cc467caa512cf9ba6e344a8884d42f1f048134cd5acd37c229febcecc70b751fb8675c9639ef27edd0767d90d3a9909a70fa0344793d98aeae9b2a0c831209a4f1dc5fe99b8e322e6567e9a274cfff51bfc6e5e424f73e41c4a7e4b6313f3a55ae9b2ecb5c7df4c527320ae83bc722564cf7bec227fac5a9eaf142289e2d549e36b707610b07d2e4f22b96288adc0c6a49209d2532a52f399669c05f7c88649dc8bd0f4891811a8739c4da3971b94f2dd7285e1099e17c77a494e06ccd196c565884fc684a2757b80f4d86113afea7e93d7d7d677e5a8e28a5f21ba7a29aac6f5e245d4ffc3372ec04de012bd170fd927a1857dac5024d60878837df536dc083b1a3fa9e44f92c25d329a16ac6cf9c5501d9d44fcab2bfc3947d93d4405a570570aaa05782e33b0e8ebfe1290118c6b4d39995bf514ead3f28466d0f3e6522bdba106a06a8129fc1aae89f15d0363535325ab3dd83e2de9a7a3342fba3c2e9d239065fcdacf355e691d5c163c45403a6da5aebd56829d08e6e541b45558c99ee599323cf11811dc27534896bc980de4398434da04471509832edf8a30fdd7c38541acc4d3f9597cf6ce97b32d5a7935411fceb7b3d5c2e5c5601221a23eed6f7a3714448ac53ec4e42a33767e7f400c0d4cc6e27a6fdd6fd2902ad637528d380f5f21898da03e9daaa8812f2b0feb03a94d36c40030133d84efd12a12e7ece4b0de69f30aaabd50a596d26a1727714174b1a840bab8f1e4fa2b083b845f7c67f1c02a4256c19067121d128048a20147cc6e1b90b98e8747c40811c4a93c3f03b5cb6dc9fbfcfe1fad651df85e8388fe06ac6968021ed4ba9ae7874539a16bd032caecb0e0146abe771e978b3f0927af1e435e03a2b63a4f3b6c3eaca69cba3e6ddd1b1fbf29e21018923bee8ebc54571395a31114c95eec9bec34433e9e051d07c87c7101430ded3452866b933b35cf030c482558572ab8c6bbd2456d35cc8c8ae93b6dc2231f8c17653c6fc90eb60267b95c1f95d9f93fd9f98dca08c3518a8adc286829134a6981dde469262963c7ca2108ade9a4fe7dd7efe15473463604aba04853ec5ba6e5b66444b79ecec1b47f103295600f4c7793b2cde0807fd7cd807d71f947abb8da6df2337a05ee958ad118e8a27c8d1fd4f27a4048569e182a680d047234abdf078e0caa15c02fb9aa89508d42428c29715983bfb525e140a785147ccaa6e74d44b47e7865ddce75f302063d9a766d70b400436a4c34df03b5822e368d69879162cdc2eb4c0b16fb684d36c4119f1d1cdcccb1993a158bcf6650feadeb168e57a8f1b829d1f2a230a4f1c3e2416f05cfc45934708ead2005472a37e653288cc60a563f0044fa9ad116c65a9e75ab20ebd19d9f5b522ab8339df70176545e03692eae9dabe7d37063e262d5bcd90787e5bab0e82b6b8343d00409fa0c897c00165f9cf9000d6109ff28d2f27c729e9c3abdcf962a51472360e26b88f850e4c433494f416f91ddb272ac5f61a49250e7b30a577c55448d48ae2bdc73c48a1706506ab8b4462480006bb0e19129bf02679940c16b950fd5bd6c307eef55a89a80dc739d6f2f46fd859939868810c2f70961b511397b0dcc01e099e0a317127a6165fb9a935583275570551338e4f170b9777d9d46bf318a52faaa5caa8f555a5cb3b0ca179d8ac07b854af7454312f8fc5893fe4e67bd5b46e51e41a262f783b324606509e7b07b33629d75b83f7552106ede5b83ba261c5f12f55b59db5f5f43f2828052dbeb95e9c0fb0b0ccbf680fd92501dc6c027e681ce76ccaa99bc7ba31594465f20a064fd61140ffa3390440c8dcec5776ba5716d5bc0da3705a5d8f6252cc39835ea047a3183d8ba256b9a0561b2e36e56662d88038b5f4713cec8aceb5d683b5cccc7f9ff2b28e52850b333d710dd2957004f154ce2e910ea8181f274743c0234c10d219fc5efd9b4b3db673ef24fdd45647ce9e9ce3a303b4de15f3b7189afced60d50504aed0339501db3af792cfeafa7293897fdba888504e2a02e2a456f0ac56d5b2bd320ab96c31555cbc33ea20b71001c9cc9858ed80714cb8b9ace6086243587b5abaad98af5fa39b6fce7b520c167c5a944b769bdc48a9a554224cd77eb7ae1ba79ca4191a3c4f71fca8486434c40ba7bafafffd52cd69566465b4899dfc87d78815fb6c7da903e85909cec7cc09f66b6de760e95caeea07b5d5f3396a76039b97822d0270bab6aa1ea996cfe2217f9bf991ee05f42692939e9faf2111e8a1d4ec54669207cd0181757e26d19d862ab7caac5bec95a8e61582eda0f3a617d4b992d59fa2cce6a1a51ec184d216331b78d3ad01d3bd418e26392efb5ab1956f6fe29c292a64f0b0c2134b8dabdd0765a6f3986db97d6b71e1d58a6366f5df62acaa501d1c9106b4ab60ff7ee2c7d92fcab6566e523561bfedd6cc736f1024402f76c9d9630fdb745fa52e0bb31de1a4610afc2ce023fcb0ca7f59ace6c66da83bd486f0e6487cc0ceb574bccb9e13d253c95bb74197fb2c13b53c6ba0346e014510a6f57ebb4ac8321cb418c4a7a04f175451185f15e7ce827e5cb00a97ceced5c3c752dfd47e35dfd2fe5f74d08e1155d07f94663b5cd6b1f9cecee9a476416d9a16c37623ee82f9cd96a06997856c26fba8e755c3427625e60546caa1a1f3a9808b762bc234b0e5053977b0d28190a706e0aa32f22e485603d0708fa60a0cd5ae10b3827836bf9a64abc92ee9daa86df89fa16bcb7a89a3f3fe027fc137110f81f376330d110397474acb7cada5c68a6a2dc021814477791e6347c453052adf9dee8eda24b3a1a6578d51e8acb885ad5be48195a7edbe7072a88295de8fbbe6ad27bb9bcce5100d3fb830a53e12978377b3341b3a89aac788d8a74cb7ffd205a08979f83c6fd4108aca85fca05201f5b31753defbb43d5eb87d5c25e253b2c578d5ba7a14c7ae674f63add45213e20ca9096561e4a334b6acfd835cb0f5f2226915aee81eb10449b8c831853f79c714bb8372e6d520cbf7b6d12af606c0ab1968ecce272bed3330ba6a0125da08d064cc4e741198b779d4538e0f891b2a9d345f7eb531c50cebc5b387f8d393c561ce35acff684f6444ae251daf13204990798042630fde5a6f8b3b0781f2622ae86b25937f90677298da0a1d6109bda019139727f07692717a3216bf8954b6a7ca56e6fd2cfbbf6da74a9658106ff720b9c85670d0d0e712d8b393c30ed39fd85826f340a8e89caaa3047b3c06727d73786d30682051e82ab7d92de4d076998f5f8fd0fd77a0f737f8c2e1a6b6be76a9ddb8efe7d6e0c57dcb9ed18995d2e53808cfbe8eb647bcb3ce2850cdc5521ed005ec2341365ff91b89e3df3828e732166c7a5f2774757a579f425edd7d345ac7ea8e047c19bd6b5a044f507aa4e9e7ec9a27c786e7b3c9185bbf866045c5996ab53429b0c7f4779cb483b804df04fb6672b507a88168de983677c88ff162add6ea39a7d05f7ddc0f79c101a252a96615e32f9c2b83ee90e076729308ab13541468cc6c767c9d4b83f5854b47e1fea8a283a62281e84387fbac98e58601e688febea14311b48640e961ec5a9605b1dfbcf022d09666bd81c973220e9623519cfe75d9c44af4740b97805af1035cae64e96678f9c2fd5b3e5220ab424e2d93e9e4c1a5d1f2221d7abd37f464c050f9037ec9fcddb16b1f51c92f38781ba11e8ead14836b88eaa969c4647be32448954901c04fb207df24540f88d1bbe52e8a5e7e00068d0c57de0b7b013da65db1ea536946cf00efcfa3e31aa6e1bf190be652f97bf4aed63b59f72cfaba77cd09cbd024e210c297c57fbc53825c4422282318a4a99ca7c2e90bda0350085d293c6d97ae1018c6f2ced51cf8c7374025dc4967ca743f03eb2c1ee90866295d308d096653522dc6529a4873e276c0896884630373be691693a1c7922d298a3e10ec2535ce54c5b3f447a288f9e1cc2f151f1d696d3b22f700c302230feab539349fa7ccfbc18f46c438b73bfcfff0b13b0511d942420572319aa726afdf775928be06a7f1babd0de67e9f9f7cc8dfd487d2b8d441a991d8c9f7483a8e8f256bdc7685e9f5c4ea58ee139f0e8e173f8299c4f73b560d5a54b5a5ce82cff3d2578574afaebedd23a846aead80af1c1cfd98aa7ddf54802d6ee78848057eae5249b2b67109fad798fa16c1d098ee7928d49f471ac2bf18107d10019d796fde068528bbb8c50280262eb8b11a39e92fc6644f29dd9bb752bfa532a3636d727ef26ddeacfc3894df83552891675cc7dfe6129e57a4482393733b1e45adb6f0c0e1508a0323249dcf9d8fbbcc07453cb0d83b1177ad89f27d9f26daeb6a15ea59fba6eb4d29db65225d683ded719143dd92d8740fc9dccaf6f8f7db0f11091d09e8e386e269c98cb25a023f58d2e985a5069978c5abeb40931844fa7b8a2f06dd2260f812ab645375e26025082506db73ec3e9359085489bd4a07a0ccf028cf367ceaa5e1f5e31a9a26ee491420110a77e3e37d1bbd90b7a86af7b0d30552b15d9a31d0bbd0fa006cb83d2ba541ab6e0b51cba4f328936e242084dd54d5cf3515d412bcc9ffd4411432eca4f88f73fd38c01705065449391749bc76d5c74ab5725a7d8159355c394cd9273ee3e309a0b5c9c16f79f0a91f6151c147ee87cb7014b82bb27004c517b63ccfc43f5ed303fa8df789fe46b0ea26c6be78b32c050b4fa2507f43556f93066a19078c1f4d448199fe93de98aaf44756b7c536c3d56314743d2e9c7b4ee02bb67d85ce7d0f58155e4215bc3650eb023a67680ca188d5e0950cca9c76a2827ab8068c119cb9aee96c1c7d6164fdabfccdf47e9586c3ad7243ed63002993546aea340f4f4d3f796c1d22c5ee93b43807c5204f566afd8c328b432037cd665ab9abf5d5dcf14910e5e97ef387c3c16185b8dd0d23cc2bce91664710f50aef3284edae8279166480c3c36064817db9cc286a28f478c6fc2d8fec0f5a6185a0e763ad2cde0023677560a8f5dfda29aa27ff3041b9a39b6f52f4b401b39be2ce68fc258a1c5c22531b3deefc51695ee7c162a9a62426b6480cabd411025f8af9fbcb3c39cb8648943f2aa1c1f2e290ed4dea33064929c29cadaeaca6af6be6925c6041921a046d8c3f714561f0d6dd38c3816e6990fdefd92c9f2b61909a43ec3143d14edc6f22b89808c8654eec241e5a8e03a1f1720280427609813f84e87b93ba937f741b3b746a345f06c146e8ef8bcbe65e5b0f5215c72db78281dbbbc3b5e1d7cab59b097225e6451d370d87030e3d7df839adcf9527e679be31b0277183c979bf2126ace90556f0f1234991a197eb1dd0baef3c38af3b6a3eb5aa755b2be8d956a33268bad78c69776ea3cb88ebfb3858b6b0e3e5ca8cc2f80ee1b79dd3c8e3df4fc9eedf656229312ee43d70443f947308e20977afb49fb4525fd801de532dd4959983514b8e8741da58e2c34280324d883c52cdcbdae0f80285b03f3eae15f9bbfb83635b3a9008bbd3b1a08f180bcfc0c4071fd84300d6ad9a7e70b4d9af4a6eed2b9b0e51dc71e4c411ea0c51f765835950ca327e7ad0bd54bc6c3b39a5f108cb8d410bb6e0403ffbb55c1a44571e8a0e80f5b3a80e212b42861e67665a25b21593169f5605c03874629a8ee9cb614b1f87770a0861f0b4a6b599e3427218cf70ddee9d672a05554a9770461e23d9454da1bcaf4147cdfcbb0be55654a87073432f55efde63f7b084d792aa20452f0e24d76817437db2d9e741e2d30d1fcbf9d8a66bf6265759fef42094f6851c8886ecf2a6790362757a854b19b9081b6483dec6a38f38568323f3b2398d9c445514b6e5eb01a28a7e256dd887567c490d0b784f2268b87ae59081a4c8f014f2c9de31139bae4e33af2244fb36979566eccfe8b4f37a19ff9b6e6448835cc7966c067fe08b82b9bf8a22e29ed2bc45956acc8a5b89d99f0767604065a73a3859f3622108457065bb1913b3334627fcc0b8b441eefbd886f02a338df6d36fa15d1a91ad319fdc7b921b875652504363ca35f91e2f68643c18757365018f2180dd835eebc8ffe2909449cc79a51d4dd2f3ff3598fb0e1f091c9c76c97afc4620901928184dd77387b0fc823b2a8bf3a9f58b669fd02dda8244ead4aad27355eda9369b4c474212cd0cb4e318f9b798c1ce18d7b08766888b4c1bce5a44bd517b0d55b843c1e0db9512a8ef93fbbc86599444e26d337887b2c2acdf1332b0f04a26af6a11b817921d9c8f95edd6e26aa23094afbe5a2670f5c4103e658b197b1241d69e95088bdd29fd56fdeb1e8b92dd757ddf9384358c9160ed01cbf0e29dae399820327b79e38e901446c9c05d2b517cda0fad1310327239f799e7edeaa25dd358bb8fde1363cd3f36cd3d8fe4fcab60d1b37c4f175e88d04f6c2587af9a37c08a84889c5856cf8cdc1e16466dc8c7924975745d304c501a4fc8051f1ffeb612c5201c279ccb4e651de8cfe04e6d1e304fa2d02585275f1f73e199c496f04e45510e94704544efb41e6f2807d8be3811fea1f209277c6b7829ca1275ec958dc2848ee1c27092ea940ee3f59bf035117c0e49fe84c32f220dd637a6bd50fef091d085e487d4e46c8d49e6d51245a2835e5a5aa968f26676406add8e93ce9016eea4f0c93723bb5f1900097311b1f9cf6295fa7071d3fb4a7bdd0050c38e7613974e44382947c72f7f4cbecd98cdc6ddabf7bec7387b0760732355919ecd88bbe8bab6d18b6065ad1cb7c367e138113f10a66cbcdf137933e5ecab568d4847e3171d48717c8dc1d167adf722f703ed2ebcea39b0b0b0e8fb1b9110e11da555561f493ba05d04b376c7293fdd339b0900551600edf3e556ff435981b33fcab1bd6aa6525adea41d516d2097fe0c426f958ade645c1b29f04efd03ef77b195a418fba8efc4359c38cf36c7cec7f19850664a10465cb2faeff2c23b42c15e0115eabde4c68e0dc6a97222749e39c0ed2b9195480720701bc5767de522de422c40375e3cc04c0c2348111382017a34e87054d278a55fbd413606743822aa89dc513b819f2c625a2423428dbd01dbdc580719ef9d7d149fc08a70e26b1d0e33298fb82b989a5713f5f99cdeb8d1299592cfb271eef67fc036ccb34ddb4844edb2bf57c6232be7f53967cd04e238390aa16dd22b2d171da63800f944564da53d4c153ae0a0f3e1204bd99404e9f9cf100df740697b702625305e84f601788773c012dde94de9baed1f9c1096008424f5a28773d6c1c20fc30dcdae8d6c79246877f58e51fd85c4d8c4d17c44200da9ca0161a5adf2b90d5be486fad2a4c7d9a9695602ffd6f7990d7ae26a9e833587c39903952566954906ef13e3ee4c09b6a2874577879d9f1f76bf8331733c52fffa576056a18011f75b10eab30eca2519a97d397ae6278223823c9f544658ab72e89dea2377537987cdd6e13257e74008d7082456802b6eb3eefefca83eb4e23532e4e8589fd39f625934f568562875d2995ffe8f115564f7edfaefcce067dfe7812e70854db062ad2a67dc8f1c48118c3d8ad0c23f63714afd5f8433a68bf04a16069e4eaebac78b6e4de3a27d4915900e6903301275279dd7c1255256da299a942bcefc344f3cea46d0fa605c40d26e0108429417f65218d6de41ced9c545a5677360ba6e48a45fe4f3980e728cc6898dfb0333805dcbf032e6d9863809e7b959b554bda2309133b07f5d0b0f39883798a09483ffadfa9ed1e1914e26e879771e252d89a9467c48a850d01ecb6fa188f762f0ab08d0750e7b9579b21204a83c7a4ed74ff9b789cc408938f5172db71d26f311c793810eb61b6f885a8981066c379fcfcd036ef5b28f2960f152f74b1d21a51af014a37a447ebe7f5e2b0b449cc9c19bffd28fc82dbbdcacbda0d6db475f67b7c2f1dc33692d3d0dbca93caf8866ec1470b631763e9f747fd1223a979ca7dcb7bb9184797118b8549eeff3e004074b06618402d83f89b62211e003aded6c45529fcb0b1f1d7e16648320ccdf46a408e591bd2dea66e86d979f0e3f681b762af57b0b8d784b6caa60f46dbf81dc2ea1ebf42fa72a24f20efd8d8634950bfb83268eb57a980c55d5dd321ae2cb8ecffaae13e5a13948a5e3e5a5ab3f95f641faefca023bf7b927d0135244f725c1c58d2d2c054c1e0bd3bd226a2e7affcf4c608020b3ef932b379ea6847ab41c677ce1030db7b16f45c2a8dc6d9e4d22195d17197a9cfdf85002faa2a9890167d4a1ced9a6d0300ca0f1de45e541aa82548d9eecc1cfa737d739a865a7b96a7682a22a51d049180e32c28d7f1a82bad907c7670fdcffa857114fe45e2b32a2a03f9e72e0aa4b50359ce742ad940246b896f50b8bfad3b788cb03e20a7449b68b0367c3f5e313e53616db6bd75edf063a17595eb786d6af50f11ad645f991a8c84120667166000dbf325b76891c92fedb5d00030f43fcf730c26bfee2582613a91ffdf94dcddc93897e98420f1f486db07e36459ebe807cb20cfa14749c09f4d46be4f17a18dad4703be154fb18f02007f39802173b83d7ee0ac48c0db8cbae703a4613147a7409f14b05da9da8ddb48f2d49a67e4771d102d4a75a65614b25c0285d2476cead1dc21d119c29d3298c4e9fd2dd447584991210dae5a9c122ce904d973cbf6c0fc8e7ca31206234e745f1c828945c1102ebd26832efbad95067c9b31f03997ea32d5c8e8a72b37b40739db4db24068e8ffab7ca98e09462f64f31c3e842d2030792ad253fa051c1790ef910d6140b5c11352a376eb9997cdc46d8e6a33159399a050d9af8d82c97f54c15f3d5955c47d104f931c6ede7413c22b68df79753db2db960501a2cb99fdb8ea0cf57b070dcbc74baf159642848617fcf31dfd8fec60bec19799590ccc0b9d33816addbbdd949d5fd192b1b36961d314938ad2ef521ceba7d0309b978e5db66799ebe8644033f8ed4af5b0614e22697335297a2b55980d516ba9d5b0a0ee28ac7d6a98129c6977eca4e3af4c66a3e5383f2128c76e4fed4ee6137266f926fea36b1a03445a9c9ce25ccb72a04a81b0b07800b42e87ac14e820977ff4ce801ab97e230791ba6d4e387e5308317211239bc154524d0107eefe7ff6404dd2fbbf7128444680c8a2fdcada09fe22da50e638abddfcc46548e836ebd7c8329f21ea088ce43a6b6316797d82746b17e2ed3df4f57d5bf0705d2f10e0ae1f0b5ac5aae91ab8899c9d309506a19e91cdd6d4ff865981dade2254895a7d28a43e06bdafa964a4b20ce674dc9563b5bafd23c7a91aa345360f04cef9d13056bfe3040a35092c7866c992f8eafed90ce074ee1f23175af59f18c94181885b1d624334d8b6696128b81a5753ce7acd3e2b4e70a10c521a6e52270895e2172986605581b068a87e00cb55b2dcd7f204d76959f495c767e4200e850888cdae129c9c255da00356251dd5e9d62e584d41a0fd8cf3361e592c255709b8407564fdc8824e828d312bb94bd90d2487adfbdc8eb8261b3630b3348f6c249b51df62c71b11a89d5a7521e2cf68c4a7c50c4d083e5334903443e68faa1a6b9557125c4d7228b85978120bcc5373ddf689c5529d66789b8108d116f710f08a9cefe9cc909935689864659ff12242729cda478625a61b7490877d7af151d632a0c45adafbaa4c068ebac91eed9c1b8bed913503001aa8d6351d06e6b5c16b4cec64ddfb148db45c76afe0973e323b5a557a1f15995fbabea8c316e69b0c34974a2993141328b8975ab070ee5aad23113114ed223ceefc75d54c7920b124a05903090151957523a97dd832d515949d3d5497032dc1199fdf2c74fec1117fd824dc2f815d3247f49e82a3b26c3958f6260b2c69ac5dab16a941a170d9d50a5c56ffca1f2efbc9a3f1342d4676b8d19aa9390fb928461e84b8a39d8de9420b288f5f01ba2c9df7de53898f3d28133226d8720ffdb96c9703e2b02849eed81f4b8787f98009b133c208c501b1bc7d1fa6c73e5d48c9ec26a19d84d045d3f37ea485568185b8dd55a5143128bd3bd9a0b23e04b70100a2016377ff506baf72827fb0cc4ed349ad6dbc823340dd7e80ab2b6239a0733689349897c0fe6937dea302c427eb2dc3e174227fe405753d81bf374e3053c94212382fce519c23de3a8134150b5688d6bda00ea8ff2e5ca39baa64948339a7c263a6ca86427834dc7087a82e946941d57244d6c455cc2b1337e84f10be84deda278669ec1736c96356932a31ccd62cc4015f4dfa8f5ab931dbe2b5f3ab2c132473425481e5c3f73b5db40d30bdc0bc47d171d03f1ddeb4033dadff38f0e25626815456e94b4a83cc9125cbe65e282b3400433f4b6c1a5cd50155fdf1cf48ce5c2d89d6ce64c18f03c1d9cd3d0b3bf5b2c57aa85ccdd115b5305e13e53816abe10ac5cdf4e583dcaaaff58abdcbd64b6a945221ef63b9b4e9dff5129055df87686d7b625adf15417a054a6c53336c26676f3841bba32007163e3274b6a9963c252b138b66f2e84649a8e4ab12053fbdfaca8523c416a1c4904ce02c01fcbc228d66154327d1b1b9a5e57703afc23b8e05fa65a0aacabea1fd1dd52d45e0da2fd7002e5be9f39bbb70c0299cc56e8932da2601c992bfadb3c112dad814f1bf95a8a52a12b24534520e927e007d59e2f593d23b0674b8c8a61f0b8cd54ad06fa6fb6bdb568dfff52f1d3701c673b58ae139986abfdfe2178c1f81df0e7055b397128a6c7ed67f6047019fb8f1ca45bf65eddfdea410ace4fc4dec4b3d8db655c42149fe49a73e06940d51187c19cc798ef9b30a3de305a4e35bf954b30aa824408b495949e5a3eb7cb8d14d3e9c3df31436b48bd1367bab4f2e408913ef81582e9a70f042b89138f9328d38b4cc76c79d4825c5610e3a24c9730d32655b336db87180248709afa3bda1880bb8848257d2042f5f5ad37974d7cd0125bbc33f53f64d2c3272e6654d395e4dd0a3afb6a16e5d6ab1a64dc91c97bb30e2f113ef851e2955562812aea08172068c8b22d9dfbc47b5971b6598e938cb100f1c08362175f990ffe4ab5ad3227b85a622d637e87e36b3276f968571866f63c2915aba136cecc9a1e889950afd6d7f23c5e24330fb30c09345314b6ac82005c25cfcb0fe517310d0268b94bf7ef8311edbf68db653d26f418e350c36b8b0be9f17bb748c5088884ae68ea8b93d72276a56062d613ed866ac2b026bafcfeb64834a28bc7c52b1a9aaa02d9352d16695bfc0a5c099a54e54b26c49752a7c97d2d70116a02ba6aa0384131bc61347016d5719cad0821fe4e7f796af178af65c51a6c586f4378636637bd1842b987da40b6e2a759b66f3afacfb357e491c91b400aee23ebb06ec03b1fca0013acd5d8096d643efaab1fe4397df7abe7ffc884c9978ec9d8a02aea53647016b47f2c7115d0e2463582c333463e78c3b78d6c3f1f878e0fe020fa22a22238a61d9086611108d3434a0d22980771ab560dae9de6ca3ea6081580397cca92923a5290b4b5335be4d54bedc0acde0ad767bc561837f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
