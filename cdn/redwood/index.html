<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a540e50f8947812d11c2a5a02be8f196fb91f8354bbda8543d0c8f7221a8b31bc648b026cf0853ac438c99a44348b5d56805e016fc665b64d05329aacd0b294a00d90f710c7df63cd70abd052519fc959d1a738402f25b048d1f13300dd0ebe724b6bf78f628f33491814d2e00e969fc01facb2c5025da8279371ccff7d9f127e130949b79a9252bf646ef12e82e129d9ccbd2f4fd94b7f0f331dbc58280e25f4f5cef47e11da7b4053890dcbfe660de05762be9112c4ff95f413e1d8107ee6dee28531abd5d05f393011408e88c123f12d980fdec529f291beed63e4a2f5f04f33b66a4107bc7ccbfa01817895230d226672c650bba6870418c3752cc149b000272957b493b179fbf961c1701685747869d72a75693371f440feec80ab848ff1b3d5a46c9047e4b2ef9e5207c8ed94bd343a6a7b9f2f7bff711a3c9db9e2a230caf4458bfade2fe4f7c18c237270cb204644ef363519bc5608d06c29b3c568d466d9b47808a7d705c0e0980b5e998d1fa2085fae99c440cba5e10eb86e68bb16c295d6c767aaafda2033fbeba8073746ddc37d4de0d28b9955d9c5f86401ac2f939d270754bce799d0155337f66de25ba2ffabd75908bf9b9dd4291a0911952d2d62675f1e29a9ce06f6f24d3abc62b8e51dcd2488de9daa172f518015312bd941184e9c5df87d830a2d380f963c00701d40a0c215a2514e011806d142a65bdb7b1f22967953a1f7bd763e7f024b67a2b601c4be73df8359db9d7bbd6cd64bb14b5a5d1ff7a511d03f34af3358f8ac746779caeedd45d39bf1a7f4c0a87fae0b36110398190af9e0953d07edaf1d3f48d8b90834252ea8073c2fdfae75749a3a0b662d10edc94709080b8ef8a9e267d8d5dc7f1b376a176264d2fb12efd9c23c3c6fdf6d2151bb60dc1f44f491400e83d680498d5ed2152e8fe5aadb37c7d3968a584bd70d63022019b8e69655291eaafd986129465599c7a845d0e2804557a2a9b2c857218d0c5b10a13735604ea26a38d5643f3b4d6faee0b449d689a6c4ce8d4189ce93891912a29a7c43397ea7654d9a88194746f43bc4964f6b87d8a05e6e962720ef0dca385954a074fbe6308a0b246c60285867b89fdca67cb4e974dfb40f5e7e8608ec597fe250e988edef57d471e720da8574c2d07616724dd00880b6b508cd9f789f5d9cf97fdd31e1ad8e2f8c7db6d89ba8221e45f9eb96fd0d89e560fc18b1c597cc094578221c6b47bb253dd31a45626c7a3bf2583e311c575e75ab23575e34b255875de98d2df44084d8bab2d40ae27201586d86ada14804ae6673b83433e7705b5d6761c573fbff7016eaa997473e5c021e2745ae35650838e46837e0b910a37ae2da4083b4972cdc0a0e25712f38d7b5f2d221f2188ba00aa6333db5b6b9d6a78cdb8e5f6a3f89bd89400b8dc66824bb016d95cf12805967bdbcbbba48018a10f9ac9810419dfd458a65c0a490de573a9008353dd60c9aa16cdb356df79d8d5f08ffbe644b7f456834f6224efba89abe6cd8a322197e99c90314df0ce4b488c93ea4fc37bb4556a5e369741a1b927ff9a37c3b220ab990519d6e84f2f0ef1b843d220846fe98009ad6b79ca4059a810a837c132b60ad26382bda0223b0aed8d3f3058aeacfc894f477092e3630921d8b556a7ce78fde4c97f08dbb7226c07af2257d341eb58abbbce1b510d4165272221b521b61069a5f597d6365face49cd0c3d88b1b03d8c389183d3a2a026928e52f20963ff6b173deeba762771a3f7f851e564740a11304ae31aabeaa0cc25f8c9efef52f0c784c0c9a63f0110bd2ecce33fcd07b568c731841e99d747f87d336f7c7edfb0429db3978a039fb10b51c2aa85325c28f0993d2b3b0a80daab320e7ed622e93fa4b5685a350e4f4ddbcf16ec6383bbf3ddd70a5e7ead05b76fc397a10001bddf4286135b5f586c6d30cfb664440499d9e89605bfc9193dadf95d0092d512f43924b95c98af64bb586838144a43c4d16863acbd2c951b224db6db01fa8cbf178cdae198400b9a3928e8ca729eb30c22c785eb33cb64ff9af65b365b29fe18d6a9b85d039be4e15631e81204b0ce73c7ad031747ddaea789523daa651b833ba5882dcd96207fa2604e959f0aa75c47c1532001b4cd2965d5bb8888424daed38c6124cf51f97c65f764f3252268f47a5eef4b261ad7d1c8ba9ad5bb51ea0413a87b970cb05357fa9cc00701f6751ee75ac114f94e1363ec035de4bcd21db83b180bf20d3591345882ff8946647466c05d68e71dfddab5dcb800e3e2bc055c6506193f634238efb4e2b29d06639830c1047d3fe08d94abbe655d6aee4fe72b9ecdb62e3b65f584e2f9940cd0a1f28da0995c43041ea0578f23d7620160df47eaf01992b881d9d69a2c129e3f7d34c68f1271261167f5129561518fde83553761efda24554eccba0a91ffae135ba0183817ed044a46627d0830ff983e50914b337cc33f9bfce4ef872f82de8e90b715ffe9168d039f0e70a51a0936e4611a66decec90d7aa3a83f23acd9e6fe70ce20f2d6ca0d6c03d5acafd84af46ed2d88688bb148b8c7c075fd7a45e3293c1bccaeeb44eb4cccf43a3ab5d5dcf29eee346e8e2b4a84b25066f86ddf4e1aafc2027f464e2364fd4c4b2c42b744cf6c4dde026af85a36d5cd3cea1e753bddc55c3ff8a7406d962ecbce22b8088e7087fbd6303d96f389a7a56e419645cd2ff956c1be3ca5e6fccbb17b1fe89d55990dfeb749ecc0acbc03cbf3a60e888fde3f110ecdc86e080f1bb5e5f1aeb7d9e6197c071b5c67a6bc3a824f227ac9a1432d1930b9a54bb700267ef75973b25c0bb6574cfea1749776fbaee197a05f977e4bd2df062857a5c80501a7baa5d1f3bb6d1b1a2272705c8ac92cd0376c7a64c8005ee4a21c23cc3c0f55a2fc4b5b65589f35a779ae2a0c887ca6d3f9537ed5819a4068b2bb6da08103bd6ee761266861ae5edb3280bd68fc0b9affb11b8e8501e358eda834484abbc88ad59c2c4d1a060878a8f9f915bb312ca2ffe130701a7363fed260d805e089be2f4e87c82e1c3ee097059031b40b523c079b2566e72b58726486938146ae930743609fb93df93f3712e92e6de835bb0b63fce99591b708eac08cfb9a843cb2b91c09d5fe6aa3cd22e25c56cdb629e1bc819a7f84ad0bd0d7aa9fe54fbf230a31cbc5910b00130965eaaf81d462ae51168abeb3a975aa5905c2d5995c79c84aeccba07b441225a26e8256762b704a7d5f79511848bc24756d532f70da9fc95976df5cd4d6924c6fd7b7c21a3b0e84d8d3cbcab181a9317b5ddbb9c632aea2304ad9e84bc6ad3802b0efe0fe2cf6d31dab85964173bd0a9bb79f8d0d92c3f63131a59e80e7232faf2988480c58c10bc3cb95a7db8be7de7714a5a4e9981f55dc62766248e672bb7d015da990268522df67935e99c3c1aecb9f00c1b40af0e29b1fea9e93ffb40319548c17683430f2981c93780f11224941053095a2fec68a1fcfd26421fae25631bd7850d50ffc55991abca9bc305fc9f6b235602250cf827bc1d9152515997f5b5788022bd6bed35d12c10e51c79ec1b05d8a8446d3dbeb5388073c48c1dcd075b37518365eade7594858c46a924c8c37caf687caf4340c6762100539ff659e737627b95c3a48ca3c6a5405321eb1262edb97bfbc607805be7d4ea347bc1f282feea879a6d94ffb32f683856b73767b2b939418d01ccaaed00dcdbd38cc5863bcd3de8276abfdda8412c6c0e80cb5fcb179fd37c7e1ad1eb3ec7a046928653c700c27a93aa5d318175a401489e1f1c949f277016495ff6e2e6a2a2b3130a65bb70554e6af0912b900d6ba78e712181341dbdda590004549819de9534ad9998ae5c49fe4ac84016e7df4ad9f9227cb203460a1f5093a4a9466ff85951c7321344062aa9d950f7050a8166316fea42dfce8a0c4ece4883779ecc3a8b719875400dce93d6912e8bc0bb3c7b4ef4ed0b7e03cb9ad8ade011e1aa4f5c8e4012c3d3e9aa16094b04d476e78e15ccd3cdaebaa82dc79089ec9dc8e36f08651743bbf0893cdf9bad036e77d5f5404f27ae3384417f68ac032356eedc189d250158ad819833d4ffda63bc5ded6454cb030a5c650399a636afe6b0b2f62e20ae59f0ecca24f5af460788173c089cba3ffeb944169e5e28339a0c3a451474ce496c42d0c692ce40c4219c3f217cc13dd3a6673d8e2bee0c983e9d55f997b774b6107a8690fa1d709fbb7afb4808339f6a161dae39ab99d2c8aa0cd7f64276ac66780d073bb3034a77b1e771f6a80cfff3e145c0f175fbcb2d7221e93c4d26bab9ef4e18aed0453178a22e1d40817124311368c2beb4d40fac967d6c3ab9907a2b7fec78cf830c6bedb90d263bb121efd1d90f8ca68ea4d2d325024f39429b86bcbdfad1ff68ede0b293a9a3bf09468b3d4cedad7b45c649d707172d3e3681279543e9c58a13a7e54f13f8ffdc5db3f54a421c511fc5fc6c9caad01df22b9e1c8d3991877740df3b52e604ab04fcd03b9ef4e8b70955fd96156b0869b024b2df9f42a3f545921a62bc5a51016d0550c7bb2da5be2e8487c4f844f84d089d4d5171f536a50fa502650fec9cf712d5fb3f284106f27281f8b58023600cc55dded419326380482fab39d1b301f07dd23330f157c040f459dd9960c68ae7973104ec346caabbc2ec01c3cb2d4a3d74072a787c2d2e4c409537cd31a92d83079013e2ce9a7be94a1f4f6deca6ecec9c6367c118cab8c84c8a8e656cdfda6a20b47b06c33e22f5557f8edff4fb0d8abffd9d05f1e0d1270695cdb51c0ab65f6160625badbab857f053d2de066aac1d3772487de11c02a7ad77811f6347514328552ae2b43c8e47e787d36ec342f89f93750c5e46f04567c7cd608420f8a20e30f002e96e3c0013f619a811581e8e348a62e1df68ea3b61f466dfe93e04473039973b125b5965cebba542036a10482c44dea4914a32446376893be3f35111b8f969a8091b6143a23242d821df23e3572d889a30a34c39c504c231f21f0d359a4aeb45223337c9344e18c44f44d492901f3a68f20fa9d4ff362f0d994fdad2572be6d4dce516145ab2c8595f933871cbcc7cd549f44f777c875ae219a345549c2dd944942a9e3acc7c6e0bdd2b84a97a800d4bad7a26fea722a947e5c3e56ddf1c93e9d99805aae9dc0a133c46247fddfabbc42d754a512c6de995bbc6f134ac81fe10e4435fdfee54cb55ea2e740f5152fc73104468d4e44eba2f4b6ca027cf8e6d9e076536b16a198f9a912071f367e8dd1bfee6d58cf99f89754173fbec2e5492333d4a17b0d0dd9f1cf41aa8e1af0c845056507bf62a42cbacde83331a877b5a26e54eec9bc55fbfc28bc0c60f59d0123d1286d9a9b2466af8812b6e6b87e9ddd92f361032f27746e8cd89aaf24b1c3e30a7b9613e938a4bc44e90c9f8c3d44509998a7e189b1b889dea6d103ce1d48dcd9c3b4e510bfe0c41bee99c2b75b9bc06cbd6434a1febe07338cd9e5109cda82d767a495f1f9b8d32cb0e3d9499e621a40be91c73a59038d340104a4b1785e7535272ad22d6ed1c88509d23d6620a48e8d72ff376cb4a873f222aabd18487b92ea49241af575cd201f4a0a1b80607b4133dd8583468a7ae6ade5ad085fa3e9753b0c74c6e43fc9961976f3513374525dce116e08354582e190fdfc8c4047dbeab68d26e2cdcaa1882b04c4cbd10836ac1d6ec6dae9584f59ec2c7e01fc353692f5d1b5ecd30111398eb55b61e042c1547b399298602507b060724cb76578f31d0549018db03f70fc25cd7eb844580cf5c84ce45f16130bc94c53d01381121b45fa9902ffba119fcb69ae45df7c59df2facaf774fcbfe5ab76783c809e066bb6f507971c867a48dc40297b493660ca46ad0020aa3ed82efbeadacca1500516d68618b41e951a7b8e72f9722a4383656f74a061213fcd850b0c74f564112c05cd3a72530513f4259eaf662c94331b076df9f5536210a186acaac72c4612dd91ad4d14162c472c4a8c9d66b47bee5e919d462e8428221c15f3cc27b27321ca2f702a6f90986631e3de78b0c97cc9f8176234486dd228f94facadc6778635f0785b92d3f887c93cd956474448fd6f175ab4f35c7de9524a89f3c981d8ed909703f287e6c3617060ae16bca5079be68fae8aac95ff861bb3027efdbeb91fbfc05551a5a0e8ed14a01152fa2f0657ea5df2ff431b07323be386b56f558fe282cbc8fb3f6a8fc951b38be1163dea861d7c61257f09f16ad77d451aa6f49b4119e3d4eac985e5ed1a4689d23b04c3001603fdbf77d35ba3b6497b98756317cbe2157e90e5ebd420e558cf362ea65218d0a969d88c3e2687b2842f998d21ee45322d6eb0dc4f8128846ba57db6cc4240dcd59f07a81231f993a600d50b342ed9a065c056bd68634c08fe0691aa4c37bed8a9253cc101f8e64e2ab47ba24c86f5bd6cc8579f0f60830b287fcdaeb62115733089dc9ffe115407d543d4ab69b3e4af50ce5a0a134b7dd7a21d476caac4cec7232245e79196481ca4a3e2df98bc60943b50e2cfde2687766ffca8426d81e5df860ec3d42f40232a0a15ea82c7a6d79789ef80f3f7b08cf1c49d389e4d16ed5f9235ea78d5c65107390edd9017350c555941670e0b68e5f69c0aa00fb8ac8d4e07d8c4d57aa7e6c6a8b9966e10a2002afab15e7e5991b42565536a1598b767dec88c0809fef01781eb407b6d3923909a4057364780607c8ac898dcec11ca84c71350317bf0ce1aeda5341b164b864500f9b52469f2acf329ab5639da263c384e94e13f70b5d59c37167bfeaf29f6d3f2464962e781065d277555c86deaaa2a9225c39af993e6f205a7ea3f96283e6662129bda0f8e571c202cb606fba262e5faec09c2d17fbef0667a2df57beacb54deb0eb5b7d3b117cf9fabee512bbe9a823a9e48391f9e126b3702b4c0c54b24cb8b3ddc784869dc35409960da77b93e496ceee518fa0581645205acd03cfac801f47430992a7faf92516dd1a9ff6684910816227bc4dd32778fd8cc1071454d4b874c8c6569d04621255af6ac2eeefdc0e3dda967471ae6f3654985b88502944417391bd03fada4ab8c235a25aa77fd738595d2780a06a032f7b81a20378d06bafca8e005f139c79acf8d9e14fafa224f2baab683bf3586ee6c622da2499c3bd11bc9dc67f164218c98c07688c4c08af3476f53eb079d34f016124c7404b6f11a048e32e10849b41f7409d0f640bbc9b5c85957406f90741cf48c66e6538c1c30d4b3fa3fc0dfa84acc45ec0e1723791363cfb661c676aff38cf7c110521e21938c48472e195578be9211bba938695e0baa5bd0f70110f59359719a58467760e1bfd82114c1a0160229789bbd690d206e9015ab5e82ebc151c8477a1246a81fe322e5e423cef829718c77bd25542facebd8e3ba54ea6bf0183646d01f483a4008c160c96989ddc82bbf92a72353ca4f5e35badd60247c031d2267d5454557ff0cc3d158f678e9bc036a13edc4d553095a44b37da19a5686b38f4e01891efdeb6e9f0b4ce427c1498059bc1296d6bae7d01abcc32922d57e18b20df90362cb54fb6769764fe1d57373f45aafb5f816afad0eef0fc6e0d69338e72cb889aeb012412d2cb20155c67330cbd499d9d284bc5fe483126fab97f4dd779d50bc1dd23adcd784f9f995271559783c94304d1d7358717d6a906c073e39c2e311a65ad69fc6fe5a197e16c3d7fe1b6a54c2065bfc2fe3f5beef2783f0f651b3428ef74b3f1fc4a46373124f34232d703df1be6ecd1bc293db5caed9a148386b26454378de64c754348347dc1c517016473f6932089c62c1db20a499fad2fb352a8380694372ccbb4ad7770de67e3a739a8c15a1f7b1786249a717df80730b5e7ab3569415ecfc4deac43e17cafb255c6b74aeaa709436bac1a7883a4afd04f80ca9e57ee202979d7e36b39fcdcd180379b7fbc9763ef2e839d1a6104591888f13692f785b90ba538811e224ac9407f84a44cc7488ce5b278cf88b86495ccf0a904ec27cadff218b8b7816e4d895d5db68ff719232a73a75a1b70c7b4c6038e103a9f33c5e0b14697439b32fad504523383d236aa6a0d1dd10bf82193a0cbd599b9accba1556416ae0eb6c509ac1680a30886b017be46b8c9f556ac70ace97dc470a094f0bf0dfefa5a95469564dd129cfd66e0f80ada3a476bd8adc6b0b5c45c242751e9b8164e618c6ab13d78b2fec60d79ae48a5438eb7dcc246a1a275ebac1981cfeff87fe210d7512c78c81a14f462e7c75998ac9c0dd023b17b6e5784ce65f8c4197c6db19e1266d10dff77f0d45e5ede2d8e2b47dc83bd3999d514494f4c7765b6a63800628288cd8de3d0f3b0b26aeeafa822ee0fc91335d48d0eb01fa92168af5932287ffdb2508161d5ee4a9c074268b739cf9f295f2e5577735970cab223cb651aad904ba6a40183af3012db4d1ce306b79425a8cb4a6d596aae02bfe147a008f17a43499ce97cf27169bfc0a0461074a224a8f7f8604c40f27686748afdc67ebc90a33c7ade1c8079d5a1d53913fc83fffbf99600a563efc948b03092cd95ce5ac96e55b6bca7d4578b5ab66e7371be676162dd52e0a9b67b1eaa6e82bbd7ffe62bac6cc5e1650792dfadb68a941bf33ecf73b5b851bf0d1b5150867773a6013e079069b938b349d6eb041ec470ce528a52cf6f69792cedacab597f8275c895154d123c6760419574a21ed90474231d8893f4be81e6323c86f1a43517d8fd383a51a66f7bb12957d233662d89a1c61d1153e3493e5f70e6a8a7912d7aad753e8770fc8bf994443a6fba4fffc663f17e51523f1f675a86acf39dc1d382e21ac2773c7aed58a40b5e0d6d82063a1eac62ab0756c0e7e5e5d4b7328a0c09314b6aeb04db71e648d83c271834e5de999c9b177cf86fcf141d1fbbee82db8bd2af7c85fd482c9302b1a2a0784dfa834e0ca502b91e6c9de1a1281ae95c4f0b7d4a4301341f4a85ee2a286dd6bac72563f77be16e42a7b2022146a8365dd915d3dbc3c5233df6615bf4414f15bdb7afc4a6114a590307f9999ce68e84dc4e1612d56a45b9f8f8464ccd5bdb0f9460d05a2f893d5b355716070fd2bdfb58714ca10f1cac739b647740e3434cda3dd23979facecbf1f5df140d729b46c3e6f53c81cb5b6a94cdbc757a5e234f0abc0bebeaecd9fcd188407c37cb4996b6058c023d9b948774d5cc4855001ebbaed7c5625fb40fcab3f26f0e455926d8f3438e5fd783fd5723959ba9a79aaf45e3d44d6735fb9a7ff36fd6486c879d3881bbc81a8bc04a1aaf9352121ebfb78fd8638a3c4e8c35b664b46a44c29353568e89aa49a822918aec9f344bf8869721b8093d456e5ec3576c82515fe8f22f0d4591e8f17a81e507b3be353046e819c8d31f42b59badc0b50e91c751bfc5c46780b5f063d4d7d0bc094002459ce7f1d6f062d51aaffd7cbc295264775f2ce002bc47ba4587c64905290d8cd33ba502cedb53c1a5d0cc0a9fb60b329ed607af4c01992f87b199d696a8ee62c2e14e85aababaedcdfb60c1aaac1bf9c20d74559c6cbcde874c11cb231de62dfe5a2e511f5573c3c8b9c67c3e3694ecae7267984a8a58a9ced4a0c88625132496384c549facfeba517c67fcc41ba876f72e1f4e2ed5e9df8ae9d947588c86e42d1ca8dc395c7e109962bae13ac0d8df8739fb2bc4b1c1b9bfcfc1c8b5e5365e4f9d4dc2f22a9214cb8c73b49fab03c9fcc155b3125a507b0fa2b74b9be6a986d0f9d6c6e09c4e905cfc034adfcd9230991ca7b53cab9d50cc7e84ac5c24ca32b182187fada4ed3aa1e9d7d7ac6d1f6fb8755cfea9c26203d612e24ee79552b721f123ceca9e34eda3c254bc3784aec05a41a6b66ed8a5bc8b6708559bdbbc7f3881f2331ae1597cbb59e55e0b27a2f46b0a67cf35af7265d46a53e304c1a76cf3df6318b15a20988d68a762254ecbb981e23f606f32820e09219e6efb0d76376a18f6f6d13864e5783fd039812481d0ea96272fc2eaa4b9fcf6bba7f41a581021193f440f6b582f7def0a08fffb7aae4bc76f51b9a7e574e0790e4569eab1b613aa4a2c8c077bc4dfd7c8b81c16a0e3e8d6f17b81b5461ed8eee3897911a23a743bb2b7fb96290143b47b0590d8d283add33d80e081c4e15e5fac37be1a2b8d442a19c0a47a9f17958abbc59cd7e95c9678c93f15dcb8b7e7601bed9fe6a1483ff46fddffafa28a4bfffc33ae3ddcc4312cb397e979c2b89287583c24c39b74125fb217319614666bd1118d70f697989b0b71f583eea911cad5b74289f0cb8b3558ee001802fa861301979376e4d333898706b6cd0cad7842224485ad02fda1cfe2f36ef3bbfe3f6a862b55d20815e761ad68de520f91a61299a2231617227c5aab3e823c4cbb0871fa9cb5445c1e62cc024f78b1a06002175be8625fd096b83334997cfe420374c209e15addf8ba86f30b0c1905208652a7596724303b334e323711c27daddca4d0532999986aabf473e798cd316ff7e139bb53fe531cf56da9660573c1a4855a4da4a727a10ce3800aca017679a780d1fc7e8720da9850718b55e041132e2320e33b006e0ece78b082f6426ba02e28fca7e2fecee8367747e960a8148ac726714e3b2f0fd6bd96dabec196acec3b9001a160a7f8218b6b92f442ece380d117cadbe939a15a39e0d48d6e6a8668df3a1f8f0fdefaa563b7b99c9faf6ed9d12810fff7233d93032250e8600c40bd3a0e4f5a4cd6dc09f8e5ec1dad4e5c9699aaead81f29f9349b4c1a66bf72b771d6df46eb1cc145ed69981bdf9b684bcf3e01f8524e5dfd594dc1c6c7a61af9260359e4903215791d11dec33478ab08c8fd33bc5e097fb47815b32cd38b767d6aa19bec827d0ce0b23483bc704b31be8c07fc2a07308d40bb2f8c05524d5aeb010550bb344a9824cb51add95976025739f420ba7475602ff7c0e2796c3f8b167cb19c5181261f90b3f344dc34aac786b4e8634b99eb182b7187cfc8c42d04c7954178829686a740c9f5bb9a571d13c06c3c33e1030b9b05025bc3d85bcdaf230ffd7bdfdf529908d21266d36372949e0c97c9efd739c43ba318df561a8dd9209122737ab3e8f6d10fa3ea9c367b9de1e22c642a75b3e90eaafc3c046e63f67008ac1790f5e7503ab38f355919452d3c84e8f4789b724bad98ffdbff5dc4cfefaa970edf1f36bc607ef2efefad4e416ed84b27aa868ffbf375ccc841aa7da99ed208073c41baef58b520310600f4f02c7670ecdb347caf16807ef84be2611b5fca49b5c4a96aaf2231c98af03175df6965821c5966bad58e3b85a2bc0242f803875562d9219f1b3de5158a4a68a51adaee9bb31ce892eba830ee2c2200390834effbcac16b1f4933589265e73f670f1d8a6bb9ca85715ba686e3e3b926da564210e2f647609cc45a324a20ea5b75dddc19bb159605fd0f6259b668e71d1a974ef9aff8c9478c78fdb1a3714a19faaa23569efab6bc62a97975b810588a63ae2b03f590612d561a424f777d043f9a4f1fad42fade132b1b3701627a68dde243e08f3a4d53a667396719de076fe423ecdbcacdf64ea22b3c2354e47b7c44034f19d5ea5411504e6f04780892b3efef7d2643573e1a9cadc1a22dde0fc217bddca918481efd4b7a08a1c8a9e3ca06a21f6d08a6ef8cf666ec77a6eaa88a00e448cff4bba09561370ac348ed142384b00a854287bdd315f95a1f97e7c26c9606b5b4adbfe6bbb9bcee5d494633c76b594f7c60391d020bf1f18f4adcb0802a971f1a55caf7a7260f58926ca5ffe256a3f0bfbfa215d30cd153c9379fd7ac42ee175b6f2e3739e62d9a8ed7fdecb492cecca343e75e385230073958e71a134be508bf29ee6383d7bed629eb5cd05773ce3ed95a60c6184ee8ae1eef1f3396ee3d2ebc0eed190dd9cf7d6c33c3649dd50f3da7635fa56a4ab8a13f63fc95f3c4391a5f646b07c7a064da5b9eec8a37706efdd2f0aa13eb498293da7f5dc44ddf2804403b4257457bf941e761bed01a287c20a37f4127d0dcf0bdb90904ee0a3fad6c449491a0e876d6053d17f6a6f4d817a628be5d664795f5cb86819ae8696508263217b412e210a7dd3c9b470fa9f7587ff94f827d95c315a62751042e908c797efd2146c19fd0ee61f6329021526f3b57aaad72c4f534783e465c3314fa70705c639827be04cb78381c02df3204c86a8e1847d2ccc4313669bbc9a84fac6f2c61b929609e813e337b100e51fbd318451bb4050c253757842692c65617b8f819d7caa5e27fdc3014a33966c9d9fb5fb7fbe2d3630afbc644defaf3d66334c3616a040f44b3dfd5e9bc1ec9f74fefa77b42b4c2964f373faa1062ba7e7a864718e2ee9228fc53634f635d0c62478585d8aa88b556ed528e8b446eceb469e7344a1c9de1b9fe3a69a5a330002bf3463e481dbf67fb8362bc3da7ae3d229de2682510ca46cb0457d4fc34fff1909e2f4b357869eb369fd845fbca81c3f98f3b92cc63872eeb299118ddc99f2a6932647d947006c773832e68788d057e3d5c9a484dbdcb977da04ebfca643811f220baec4535e2e087fae35e29d193ab69e48a609fd80fd78bdd5d871920382196f708a3397850403b4f38febeb947592c78be12e4811ae9beb078d6209b0ac09aa67d7e3150e51f7fbf30677c6036ea4065faf511a728041d22064f845f533744e285c587415e4f0be302a200ea0ce2d7c3531a4aa1591327a39967ab9090e53bb47aa53a77a7cab2e7981eba4fdf1b8ce594fce05a27b53c631db16031e8990719dc6b4d44de178cc3217e64dcbf713e9605336d9732531e32f6f5f2bb9c4e28521d2b0f928587064834002160f177a483dc2e953cb6eaf77587a1e98c0d494250e33603934a3737abf05f5f47221507eb9f091aee4d23821908e25ecc5a93a6920a9207e587a3cff0cf8f3b3d52700f6deba28b4c3cebb2c21c713f7c99e7e7ed827e542c5c26740182b53e9551bb739dafd5384b9ea663ba04aa708b38fc8a334e56aa7970c2b048e8bbb6ee2eefffb0bb3bf21d3e003221d112107ad9b582a577af689aa31ce4046d3e3a8a7b784b3a665e995bd788c66cd6b510a63e884f066e2693945136c6a4559e29b4d68a2c1428a5a348bbf23722c180e75de82e5e7a5a367849c088fa17a993a804d405a5a69e2e7b597fc895d715014063ab2837efc1e6a55017ae4e45974e7c0a03033132a6bd300f3ade796aab3210be5275cd87a151eff9c4b9502ae52c58e999ac7daa4ab12cb9ce4f68e770ab8b57919109632eab91388998827697bca165667943303f0eeecf3b10b4dd2aad3fbaed68682177f272e303d78604403c4c91bf74a98f9f76f65a4eada1ba282a7dd5813935d1d37f76f8e64c48de682ec1a246b2f2144bde4e36c1184820b8abbb0ef66a1cf0f6961d60228084b8b020d91a8b9fd5307d1b19006636ff3920e2ea7f04972b4c63e46d55b65ba4f59d9cbc0f0afa238909550b8f060630be06697608a8bcbc32fcc886e6ae712d87c4a0ae79a7f5530c8c3b005e3b208312d59f9c1fc2cf593862d7d29bf7f2f9e61bf9e75584311e45afe882870bf5c273a64ecf09d3ae922fae899b025a56e90acfadc440e83012b39c16cf87e66e71ea4ad5a5b23b68d058cdb98eb047826c65d3f3c06ce340f3b0d2ee7baee84782d3e66ffd33b28feeaf925f949ede7875c1128d24a43c70bb888f4e3a5ae608af0fe2de0744c10732cad87cccf9d38b2c96af38bf7b4d06d4e22240cbb30794cc33774ca96eb0e0f5995c3efd71cb224d5304fad2d35f3563f23f636d7ffaf025969eab1afef1361edfebb8f5cffa1b89caf9d1592d4f75ea8562158018b25f9261a9fafbd4931fb310861551b03d2966e91845db6d98c29375a5e8046bf0feb0ed055d7ebb53cf4d05fd905eed7f78318e9cb51aeedc8d46dc1afe51ccc67ef4a8b58f59d7d83e436de5d7ef0856f2a671604f0525136e0824b6d9c0e242fc3eaa0eb91d9d4500fcb22ee738c42aa2333045e44ecb7664ac00e61359053a0ad4920ab00d2a2993eb6931d4b9c325007cb6ea38657a7885817d0440b1036d7e493fc970ed40eaff60feeeda37cdd489fa23432b05627242da6221a8ccd111befd0a3e7171310cde35f41666ad8b5caf872c70aed81fd8490adae6c23377602d544a08822d6b9562aa518a6071406f876dec163bd33c924d72fadb0f46fe981b7f8b64c5022b764e0ce54271bffa9d7bf63f1932f3d6ac77a68b82868d7bbb5b603195e8c0868e332d6c394e05ccada72c62466f45cfdd891d063e2fd71a91b5583d64d7056569882b5cfb108bb46c29d15eb6d7fe164c561b0c924028c917fd9763ed99810303ad60033a73186e9deddc1a09880255eaf6c436312cec1e06a71890ec31221085cd1313fdd3ac069618933b31bacec97ac095daedc56876ac56467003e2c0763245a9a2eb58db3befefc9fa73cbfe0693fe698ca8514b7a845894a18bc35d3c58526238b9975b6ec41c6e32124f8a76c75c9ad5db8d7c72766871a27af7e7202ce334230696f0432cfd52b3d5f2043783bbc8b50ef748acd4f2044552c581613324d5d71311ed19dbeea4b53e76449810be838f211eb169436293ed7fef52864d22bac147b70d69fa9d158774262ef917f799ffab2a0dc4048949a91b0d36c3ffb01890774fd879086032734d41461878836ea8217206854044e5cca86de95ca3e3c225994f20690370e70d64eccd33d45e7cf05c3d019a98adc1abcbd56d12351bfd3d191a6f4e849ed56988ddb2605c7e82d1a4204564795deb20f3d086ea6b61a36c396b81025b4540892af3df047c227c189f9f9337c33cd05cb6f57e7c40dc382f23eafd98f79ca15d349685929fca65d1dcd1337ca875c470d3ce8a2034a7dd146c840e5a8c122cf1adce6e7c198f085c2db26f3bfb1421e7bf8e39c9a23bf307778367c71bc0c1c461030ed4df7e3b26d9326771b28553bdcfd000b151ef0b84aad79e5a77b876f96f024bba9cf6c52a8f94f008fdd163b71ba4d54d214ec9e34422243ca2fd53563824356c4e2ad345e03e35a858e7282661ac58940412fecb2f1c59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
