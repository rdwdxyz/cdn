<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6d3bb233be9743694a1f4334bd0aed6de9e09b477ef1a42cecdc430797c0ec9dbeb52b8f3a9a4044bc2a45ae1b287746e4dc5fcf89ed74fec55fbb3cd762a446fa497cd3dfc33fc250ef741344106b4a71964d499e9d90682d903f94bb72ce54278514740934bfd61e3f8aff671b87ecdea4f39c42b9380009ac42036667b58a83afc40a62ad3314890c78eef983a41c77d46dd2bb8a5198716bf3365a1ee608fa4172728a8ff01f3c515f9b119321f1338aa4ee6f563eaea79e45c37a287fae8ab6839d3083a97b99216a3628d5529ec59780f93cd5e31d727be7d0d503fb7847ed7ccea449f77e0f9df263e1c8bffcecd100db016d911d67669af7bfa0539dbc73cd43b93a917c23fbe7474cd3a663ab2cb564f8f2137ad9569b2f505afa5214db257e0f87ddf30d4b1fd02ec1bbf68f353c3ed4be52b5c24f91aa6b06665896b57b5de6f561f486f190983a09db3e9cdbcde468165885b1628c392ffdb9c9b7074b13562df388cbbe7cfa1675f2ff0aadafa61d017eeae6d80ca12dfacedfd1e7d96b628d5673ea30ae8ca6bd2647e9888d027768fe6f4072fe18aa107f890360881740ce89bf2c09a55efa6d92d7dee9c84c468d8768a93872acd20f21d0911bb78551a9ef6bea05e7994233f82b775ed0a6762aa6c83b78e866bf42747720bd855d1ebe22f9360b96253dd3e3664cdac4c852f6392cca757e884d85fa9596b81159a21cf1971a212e696fe8c18538b8742e725abcdac8a4640ef95fe0625d648c32bee722ff5a4f83e609748bfcbe88a953b0529ef16bf998bcd76d4e31eceac7dc11b817ff8395cd5a5847410041e0abba4a46251034f33d8e0b17d2f2f1083bc29b79a6b1003d5be20f15436ffb8e5b4e2c67f9d7c930012b39be4d00e40b9bafe767e00e69ce4853a9eeaab7619585f41a687380655342c4fcc74984eb18e8c07b47ace3bd1cd3ff5924fa7b6354032d96dbc799ee5c1ad357ab93a4230baae22a0e4fdd80fb87efd1c349bb09a6e088f57d3f6632581a7389c7ba89dbe56550a18d68921465a47751e01aea4c90b63f92b8dd3d41add7d4608f64834d20e04f860141f49fd1f6a9b008d1e99bd5b54c647aed16867bf1c61eafb7aa6990f85360a5662873808e971d2cdfff42f3a89083b70b4ac1bfcd09a26006157aa546302630b315d871115cd3dd75430ee6cccef31b8f214d246b5bab0f29fc0dbcf471e36a5eb1fc67ea3e2f17c762a94bea7a7f635c853a318e4c04e59d3510edec50bf2675329b614c756b72149d99972761ba08f059f23c290df9c700b8ef7023d07d77d892ebabd9dc6d20e23045a521dacf0a66d553d81e44c912cbc0902e49c2b75cca4dad8195ccfe9b8ba5c95cdebc3c599f808c0259e80fe6d5d1b3d6bb2f857b9c7c8ead7e8a30e904f39a9e231404e3a7f1150f96bec705725cf1ed987789e330266b01dfff4ea8b4a3bfa5f22ff9b733980e0a746a8fd89962c3acdf29fe6089ba39f580f2442a78e80ad50516ed3881e2349a91cf5f8dc1d9b9115ac52dfe94e6748fd570f0cb3cd88da7d2f9cbf27e531a9b719764b4ae51e4535fd2818609373f3f28ac736c6af13a5e4e4d10b8c3b42ebd8f00c82096fc0d4d05aef539b8b0e5b42880c982e1f360c55e6f3b5f8872d2392299b6d221eb02eb126f734fef264979275026d9337fd5c2e129a46065ce6c05cb7cb37dfca7845255a825bf8e2009329e9e342fc86a5568af0443239f0ba1b8ca7989b85fc039f4a8d21b087db992a810b92bd9d74f48a515107fdbbc6b9a4fff4a3d44e57eb5b274a0885422f553311a529e9c84aa9218d78da87938df4d99eb60be3cc1e69bab0fc8c329fd37088a78d1ff53a0d54ed6ddf3d4ca8a03af9caec87e0f64581d911728435aa31feb9111a2fcb86d09f07590dd2d2e7faba8a6a7a38f93e888d8693ca68e1a8c50baca51f5c04cf91c144600ef9184034e2c64523f84a29cfc6100b8a70b3f60b20b6a2ae135fd89bbe6ea96d749e692fda082f5e1588fe490c64281dfe921bcb849a0228c457ba8de46c3825926f614e7f6c2b129fa89f5d140c06dd7fd576eac7c1bc5f916e25bde52513d87263fae86561598ce8649eb5377ceaad8ed5ba1989b4dd035997dbccf81b89d39e650fdee0045800267d8664446c476283cebc278b1b37adb8000fa4a8239683916e16b787e79b33051151af3ccef7facd3206626e891b156ab62edba7e9a02db05416bb902db05a27c0dd5c99fb37aae8f2f74da84be5d62dee7ae6a48fdfcfcdeeaf1219aaeaa3debf1ab5e1129703fcd629a79ffdc56b7ffa76b11d598c7982e5afbf0cc4db7a5b247c1d1e3a2180cd2921f38f7eef4b8f52bf146fd6e14172737581766cb3274d75d58c1399dd6f0da0d07aa6557a9a78c030b6b92b834f9288c0b2b6c4ccf8a18f8ecb997da58c6d23aef28bf66e2540d1fc224fd8f2e8b96cac0e59c3a578b2ab3846978c8ae03be96dd9f2e7d792466d5de537aa1009ee66e9b9ae985e91918171613ff40220178770a6ecd662a9030abba4df0d10d14d598c86342858391b41254dcc28bb51047abd47ebbeb0b7b50e2f1dbe7199e370e0bf2c57412a8019bd2c52bb3274c3b38356183ebbbb24f867b3d876e3c6fd1df7b52263503ebb36f9920d1063159251732710d4af84cec6ab549d0af043655e93b47510c55911f79f271a5a39d2fcb709e59d2141d79d52d5bbb630f64f47ba7fdf13afcb48035c13d84d12f2f1c2cc16abcc45cf98f5528ed71d53272778a48461f99cbadcb40fb96ca43b407ece1e13c9f700b170c8a0909b42265e96be8b3009f8a391aff9c3eccc34db05ad0b8a92ac0e3ca1a16596a8079ea7bfc17d65798ba594dc6b061dfb9d44a7383f89dc90b556f6cacad63aa6365c480cc4c5f86f754c79b2ed3e142fa9c731b6e498cc5e941dd19f80d667f8ba63535df450086e701c624686d87b5cea240ddbba00457d0a79d4807f46bf438925d86138ee4d63e6eebe5b36cc32677f1a0c78af0f642cd49dfd5207eccb8ccc07f31c950c4ec4e8bf45213d2b27e1d4702ae004ad7f2ca84e5012c280d8019f82a23a44b1d9eb08aab3cca76dfc988f363e62e3f2368afab40b6d8ecc1b23317806ff42cd7c9e115d16b542657d14de54e2153b728203cc6df1414ea52e558f571260eab22e4033bb27381f59cf7777d4cd14af7fca08b6e907082f195156cf3f255e6d80cad3b2fb46d9a5a7459abd819c3aaa31b85c74d3f5cc810d0bd720b22375d846ab341a8d96679b3877ca4a36618e317755d7f3020d37e41847fe64b7d3b9cc46d72b0a080fb6cc5273d8a2f0be009a49d0783d61e5ab6e615bec050e2fe5806219c6245153f297647264c510ac53ee3fe432f1d96f9a416698b7d4726a3888d14937dd7ab4e87bdf4d012e371028537362580a4c99d3c710eab0f1decfa050b171f2a4b3a99617d06a11673de3e358ad750b67abbc095c399caa973b1e02e8a7946ab25b1d6eece503c23e278a73f75ba693ea54add118de6edf683081ccb07b30fea8b7f19f9550109bcd9f568e5c2c1e167ee06aebef98aabff3a7f8f23e4953ebb90e5929bdc751246de18810cc0be813100a66ec292bd6168b0ddb17e54e44407fc87a12a4026835d6b8a6f5b88bbfc94f06b6c38c0ea46033fa6c5443af729d2c49be6b9a400c6a657e3c0f1d6d67ba741575e89e8eab131966139e06271dc2585f03dc2d1048a5ecfb6860735a232ffa6dc7557306f8b4744145aa01425913fcb84df4a897a24d003333f66f44afc77e06c93f611e5ded369e87eac9491baf8bb2dd36cd41a5d43127dd96a7e287c8f95eac268118f1872dfc79de661afd2e0cb4d69db3e14823e8df66753e3996402e490377e26f910c32e6aa3d5cd3272a6823ae608397e32c6fae01c91c738a63d23972289bdb6417146ebf9120629dbcb58bc4dd550d94097eec38d18f15bbe010efefd234d3cbd66a31b568cd471a0adcd5a91e9b7dbc23cad9edc822e9ca935ec02f721391b36414c9849afa70c7ce914997bffd4dfbafb46c744f1e4c9efa9b7a013d674f515e590693acbda32089401af5346c075a2a885f1d403daf1a4d916e036fd73d93fcdaf383af6b446f87a7064a7ca5745f1d9e9c30691e28116f93d3255a4f02fc7bf57264b8ae37ef7e7c4d2fe6df7d67da85faaa79da69136e19bb865c54c916a40663de8ff20382b9853c866f2b9d8ecc8c8e13077cb903935c145544556d87597d3d9fde9c3e6b74c5ac881e140c4e81a9ce2ae046aba0e2992c936d4ed9c066e0df836142e8716e2c099e003354d479d37cddfbbcfcc047cde96f28257bfa19a72d2e056624c212a679d9d3fc20bf726d6f48ae3e5c2058a8fb89c9a78645f0951135fa7d7ff66e576262de3e0300a01bf78538e0b17ec31db1472476de80a4e33e2ec976c2b0c092dfbd0d944058e82908062b51715ffad381be833b11f84a146ca8bbd712206b331fa7f1f95d82b5d2cc6d8f8da4d537c27e14fb1da3dc60499123dfcad00fb2981bef8f07c150376bab9c10dc0b5962c8df1f0a2d16a1a03641b2ef30659b5b27d809ae862896d925e65794125316dda7a86d72cfe4dc9e8b598ac46b6b07bb566c9927be9f553a8525a61f4e9708e8809d5fd783bdd6b82298aa10e54516b957bd288076fb42bd8122dd9be4c46b30e07e2d251a34468fc49d61cb53dc53d7042290ed95468f2ca52e9981f7e5a320fe177a5170aad33fedd26bd7c71b5120d3a50dfc6f9c093bed45d2dc2712e5522105e20aff3852a968e0a67f548b76ea01917fa017fbd50166a6857f5d07bcfe5c28e709d578e045ed9db6544babef748d30aca0b3e5dd5151ce6003e8f797b972d5f9bb4cd95cc62becfbe138928a0bc3a4a89ebfbc06f9a0b6c0bbcf18bebbd62bdda74aeaa1a5803690b0f33956fcb9ffc0d94c5c716248b0c41dc3447ac9291dc47abbb28b1a5a04c907a3b1c7a36889fa092997e0db3300c66e0bfe84b8a5b8d2e58b7fd0dbd6c4069b97cb0dd973a7bbfb9cab276e426502c283e9c8da7cbe2caa2b10f350606ef6e867dad2088f027bf93b0225403a2713b88ebcf5108fcd6de4f1f534943ce86c0a87177de47e764dd182dce2301cde31c37eb78137a82255f70b427160ce03dfe969c71952e4d1219b521806b0e7af722c627bd00e6d8b16d3542aa992dce285bcbd483abbc8561e8f9f0ffa099f8c9b760f2117e1514eab5f6481b78689809571278e08da7202a780ea56aa6229b3069459aefc0772c19ac814466869bb80180e04aff70b2273890e43f001d1411a74f8f72ce103eb52d902c9849b0c36d6864441155d37b7a3059dd0c22566da06d02d75dfc330bd0c061932536dd93ddb9a4614123c2705f633f620bfd4135f71cd8644040a4889cd48e8c0d5d68c2eb50fb623e8e0053ef51a82470f9d5c4d57fccbbe8e01292a5c2797d8bd8704cedb855f06307e0b876554deba550a15482a7274de74865f249363fc409d0b6a87af3c9f6fece5bec54b06ba38ecb7c528fb88c4dec9288d585e6bc04b9f6b64fe7ad07da6db895e800480bf39e827d777c5a0fe0965c1bc073ca160823a24e12a532c694101750e4f86e8790153407f0b62ac98457df71b192dc55c9cd9b257fcdb6d7a08cd01eff87dbf53f389983e4bb37ed7fc5e8de4420c9293752dcc8640a22ea4b7483f434330a4257a546005227b5c10eceb12a7b8b9ca361ae10c7842593e71fd03d2884e718251636e0dd021c7a1fdc2052d374fe0eb0014b34a5d92019150fa8b4e76439f294ed47ac708eabda89f765d089a6ce6c692733f7575116d730de22475388de60b02f6403fc1ad22bad8ed347f53e8c90eb1d3e357022f18af1be28d3b9a0255486d78d9ea49157653e48ee6cd01ac1a97ff5a1c9a8a741efbc4db5f80f4f6937abe658d41577d4c944e1c879af7487160a98b3f7812f44aabe919ce5f1299d43e8de7e66956caa026298b293e81ca0ec8ad9d718d779015c07e5014c931186a4f5bec8afef96bdfc92c73bada8095fe800f299d8a63b32026085c9307279adb5b98cc6125d776bec910ed1049fc0ac66a32f51daa59d0bff710a3e898fb6322d79786941e155d7c9f9c43124494d617b76bbcfd20fb1349623a930a82986424fbf44e8230413b3c00a60f9aeec3dd0bfff38d4730451094e564cc020aeb3c615e4588d97439634043ff662f6fd3d96dd3e8a3819ad3fb5f5d99d15cf9a2463ecd08915684c5c6481ca20ab675185e37c42b93103c3b60889781c8454ae7a671cd3aa6a3c62fd64d5709846f2f3419ee9b1f7e742bd2f5b4a0aa8fde7298ff53153cdf94229cf462be17b8ea9be9d258b7f249176b0af0fd7ed9c84d1eb4bb600974d58b230e9242521f4629a19348fb63ec1219242f10870e7c1918d21426646f70a194e0a107da0e182f8f88e209568d37c0040ef143bdf2cff6d1b05ff4a3892196aced71d29a6148e604650d661bc4d361156ddb06396383c33f5daf831b0cd98a39101b08eefac14bba39ad1d1588470f487f9b9ce71f80ec5bdc21631f84e254bd9c9ab97a61719b92e0076a26a8b81fa7f07b731c119802db40792606e159cb56887f698baf1d52a936f7540d04bb3477daba13902a2469c554dab94490c02a089d6aba9c8c9744f73c7296902d6882efbd0604377f43e51fd25790a55be03022092922bb3241980988558eb7cbaf2fc184aeea396e4755c50471b72ba1754120a05205d3581ea8f5713fbb77a6a379e4c331ecb5b094f23bbb80c61b2bbf5d4a52276cb798d03e4302a7970f1ce7910b386e3485e13866d2e491a64eab86c26945778d44dcb46adcb87387649997d7c76a9f3c5860fa77d17018af740eb047ca73d519fbe71a34077efd6e70438f03986ab3304bfa81e25fdb2b9d2fe2a74c442c3c1cb783679757f3eacb2f16890348ceefcbd57fa80f6f13f9767baad4d864eaf2fc6c1b31aef4744c05ad380952138d894171b6feae5f76919042754ee5301235b25e9e0f6b4f202b98fa4e7893fef8777e192d1fc1a1ac0e140daae30212d1ec89e2ac8138f77dcc0710565ae59f3ef167c7237f78efcb834f12830429d499f3150e4afae7b704a21d596ee35d1978a90c91f96d84131b8668abeeef253d09426bbefce44ebcf012695c836f1d21b053566659b154d7baa2b1785ddc002fd4f87d7a752ea037dca5b937aff15fa13f35174a6b0cba6a6e6bb2a3ad292b32697e68cca6c74213ece36c0e017cc158862d0badbb76d8cad11bfbeab2ffb9676c3048fb701adf299d509266cb439a8b09b2e1fd5eadbe371ae4c685b8c57818dc3c1d0d04467c8b8da24471d033799e1f2ac0c1b4c708069b7ce8ec04d5d789fb85ed14bd27051dce70138a6265ff57641e7e4014cce87782f0b4d1441d15363f2f86eefb6db680d8a69b443d510ec4d1af2d968a9de8a12eb5be50294003642f9b9008082e1f50590a88ba65a3fb709e7e0e99dccbbaa8f7c49fc227d1be5369c4c990d082d843f81a720f7df375482b62eae8b8fff332fd71b72c84c94eaa2100a88866d0b07d523b7455fdc50b1a437014c4e2ff7afc1e15b6efd67d9e3d8af2057458fc11412cc5f861fe8fb30e8e5930a93e907b9121a404dea416a849e290b164d411a409195fc6cd9c2f8e5bfafe5851a3ef21fbcfbab56b6bf6e92a08c424a3ab0040a13ad7abd52fcdc49ac9b23d75f7b93bb720c2f7dc9f9c2e8c7cdb7e9ba35c57c4a8cb618a1b30836132385e00f767bfa43a2c3467c2c2c89fa1bcdf347eb70522817eb44f4a3d4127c80311c0206842522800266e39c30f004acd6ec22808e1426c588c4a31594975d654f127d001b7bd57c9bf26168e291df91c9c303aca04d7a0d3704a8d74f9c685f5c70e556417ecce849b99df81249be6c528afe09325ca6177b87b3964bac0d2e1fb8752268f4c7f7cc80771294c5e9da58ddb0d1f5fac50907bdafd4a174537897796ddeb0387578ba263df90de29a0ff26419e65a3a83f9cc66c6d398d4eeedfcfb724afe0eccaaa0ffd8e77d8fe612038b3d3c7a107ce5a67e50122d252e7b76dd27cc7a9ef1e36d8061de694ccaaaa45f43a0fd543a3b20345e8388996502135ea7caf431e2f51ef567ada61cc7985f973ec6dae3b63b7905f4253ad455eb9128b52e43b5e59097bf20d7b7e321a0dd86a33118e1b3c4b68ff6b6da7fe954e220743011feb9008cde450720e058c8fcddad098afd3671f23c1f80fbd8bee7887a86baff68f524d2d6349466d1f29b081fc8ef64999ca089175e24a5bd0381bf2e39b614e3ac736d3ebfa5d0ef5d2ca888028359c1ab1ebe9ef2c905e4e39e013d25dab21fd88b22a82a7cea1cba2efd3d3427945f5d105931494ef202a9e6c4a8fb4ddb50db8f158eb3caf56a9215495432f8f4cf91c05cf76e33543160e51f87857a2d96e3dab3371741ce7e71dc7ba99de939d4a495058e9e672f7b7e19261f91c82e5cc87e92bfa1537cf0160325b4c3f493e4a1274e54fd55f231f8e83774156b4b710f59cc4f98fbf99308c1ac5648fc644f2a98472b704507b4e82d1077df5624b7938219c19d20d9b49a85bcdac509281c2086d48b75768fe7a732d527b8197a1850f7072db4f3a089afd062ffd33b2da540061efc99bec84c0723a6d79f51f26af2d0ad1ef39e3c46e6e985b7e8e85ca345f49a3ee07c50bc60e4813e4d2d7beec84bf475dd7d1911689b0e72621ed146ccb8a27c9b2e20567d850d86f19b39eb6644f71cca38286d9c743cdc3a4e9112a88606dc4f3ba67a333bc6d5db522189670cb8307521527aa1afee26c880e73bee45bb949b541c261b42197b371b7ed7fcc6b36b63b8c9588d0df404ef544b3673feec428a0c5277fd2a50510653d41f691d98a2875c51fde4d5dbc9281ef8207afa8d5696673d4aa6cc885de8e6c924b7fd0bab88d4db20264539b55813de47cfa3671f8ab53f1771c1fb98ac3ffc4d89d074b07532b3b3a70cb543b6926a9d224ebdfefdc66b7cfe0142dc4951eeb66e749b3f2291400a5da4e786e29a979beee276dcf9b98b79ba49bc8bfecf633d7d7461d618cf07e6457951ec893e1c50d39c44540932e33beff7209ec5f64a3e8c2aca0646f7d41a20896200f3eef734027d4079a7c886ebf0a6d84f2b05bb39653de60bc30270295588c8af031a191e19650b96a20882ee342d571da32a1620f5b83e0cbfa7b8f43d0cba0baf829505bdb7fd29b2e660deef6ed1ac707582f5bb4777e33d94f86b19a04c0ad1748af73381b90eb1f7ccba0e4553ef9022720ebce87bea00728bbeb166f5b728a9ae01bed9e5e89ae6871f162d699d05e052515c9cf96f5e930aa7cb3e86e2aea339bf4d0e09ab845ecd944414934149f8fc3d02112c7d72279c4587851c9cbd12f9ceee746e78ff448ef534cd8323fca98085b4e7a29c80d73d0aa866946101d5429e2c06fd73a00029a31953873189e68df3ebbab7f381d4e607a975afe839bc385c8fc2d9884b7e3159e9cda691a75b1706420ef2b8ee9cdfe71d541a0b91929cf76d6580d2253e61f824300a4b594de0352f32f8ecd80cb59505a7eb05551d329d3abbbb84f2fd1a34c444d06519448de8f79c9dfe7ba0b18cbd9f1f67ac10d43006c6405cd2d23bf7a85223e041c9f5466e5f73ef712efa6f58f1a7c78ed8db08548a7b0ab0733d6755460884da0802daf5b37641ad22a6510fbc2e80ead137d49a2802a87b6f519a7b48c3a27cedde57fb9a02cb5a5b99641ae9a974713ad7edfe6f0595316c4371c5516a4ca7c0cce217522e215266c16da362e31ab89120cd9eeb0cb8f27ba9ba03647113e130249ab60c04e690d47bd9abeecc3af9df342b8c78c75413631e08323852e8c1d669764aaffa0427eaf1259ac7eb28dae527c1ae0f2b3ded86056c3fb5eb407556e98fd1aedf18cbd8a9aac49fd9f453a06c8f4959d8663507ff0f3a9e0493bed76ea77364780f63ed5fcd5b7cd3aa99cc515de015a113d94c25f714a9a87656a6ddccaac4e9132cf0e19fa6532935960cd5ff4650f8b9b16b21b889cd0bc5283a2d05188058f7b4efd41ffc9432087b32b86b70b6d5d8c9b85a26c5d8e938269aaa9c7b57d96d304a328e53f2d7aace5898525a764a6e39f2e127686a269b18b25471f6508fa89c44ba69fad8237c41c35cae4d530bd343783b0a2298c20ea26cea5c326545d954f1b954278199014586b106f684214b41ff1f8c048768b729f8fd3c5efa17281e24005fe322042da3749eb6c9aea77fc9d16fe699a5ea5d795b5324fff8cfbba50abc10da3066c86752fe8c961d09579e524c0448530750be3e27169e9cf35df01f5cb32c6835afd7f69da3d77443f856f1284ff721b1743750034461ca0ae3cc7caa9977bf1b38e3ba7ca11448af89b73b9a9467ce5a8d8a94da20556f2634d8cb30e46db03653e1c05a1941a1f549198ee075c018d376a94411d6e6509e09b18436d1d049603243c546c567cef568d1c804ee4b950f4813279bc5789af8786e6717ce533a950b5cf1f69edd57140290f9f38f6e7f23b309eca8e9262ff336116c05f57002ab09bbc88d83ad74ac56f8740e456eed4a95c699ab892ce9d3ad3a26e984008ae16ee50cecf8e2fc438040cfe5fe3711b778ca7b104be9ec57423cde8df2433bb365392d9f416623212514c5890f3613a90438e531d9038e470f8799495a7847dde0e1134f03c02e8c615d3d054ef647ab312b45bf4a21450b96338a18b43912b86767522992dfdd0504a9d258c266a463af4c2e0627ea3758a652fc1a972579786ea126ea41933f79298b170f34b9a85c4f59c302fdf43e9311457ea3cc8ce0510f2b5fd5c72218dd1eea98e8620916ad59576202f06b832efc3ea332e8004e876f259217491e90a8950422633776b4667792a8fd0b58450d9509288c61a4eced56809985e69fe13dc4bf3f65ba2b7e78f5f6c756cf8bcadacad4d7eb5b5a330fe643f5eeb64c7cefc6111d62d0d6a22d72364d3c37b978ef1dc32c3d53222dfade298eca0740e468b880fb160bae1e4f0acfe186a1dac840063ec6639adbe269d4f2fd1e40592958ca1e58601af7723c0af28db50a0634509e22c20abe8214b2a8e9adc893ac2a589d9057843d70bed623df9df318e3cbc073a25613bd276147fe6f3c4ca3187a6e41235c21c892a6c1127e389abb7afe7276f3d5fd97a8cb24ae171118a3e2250e9ae1e8bc713e1d5290c3b20bd77deb9ff5465f9298ca6edddaea944ee5e3413cd4ebca09a67e74ec5ead4d2285dccaa8cb149b70c58afefe9a78223896089b90ed05db833de2b9c43364a5a3fca6d77450712ec2f1f33dc945a65f464d529a32acb46abbb88958a975fd5126218147472641e20ebbe4e409c733573d7b8f10dbb364721b5d2875196a59d8447285a316d456aa16c53e00d7b85c4488baa4bf1d4a515045f1769fa40d7718e5c710e11216127d6f1cf133df65e38e140964c15ef2fefaa2c260fe92b3d414573fc58f6e3d2ea08bc3ab59788e1b0f964d106b4506b5aa1741f4d543c6b24540392285954d4a4e0c64781859747ce4e65eb4b0d64f451c657ba2259aeb2425f85f841cb0ac327d2e926a5ac1b3b3ab855e5b86b035e0b01d044acf46546a5767104156db9c7a3ff0ab94afd77d8f9dded7e266868cb9f851f44cbf5a12e054da55afe4f48acab6ad6b5d8ca82949122680308c096b2d2fb128309f1478981ad1d9793f3d33ab9e3c36d174888af751b1ce60f070935e55d9943f492bed8784d30af8a455003046d4b60f59080b2e6e097fb8ed215b7ea66aca98bc7a560d301c940a00567b18f1261ed38490b17dec2b6b99193d582c052814842a2ba1fbc56ff48937e2085d2e391686032b8df2381d3c922510c6a17666402d749bc6afec4d6b0dce42c62a110c4bee434cce1e177de116fd52434843e1add5f1f6ad6b42924ff0c437cebd2e75efd6e501fb638165500f9c80a542add8343614224f78e4de0cfaabc1dc021a5fa06661346785447de663ca2f6735a8065d4242c3907dd90dfb089e6c8e77e63223d87f0fcb6a52dac04b0bc84ec85a6220747f9d05a8c3c7100781ade31ffef8c1baef05772dae7e2512a591caf87cf0fb594037d8e1074476447055a5494ad3a75b898590ce0be44d8e6e84913a2c425760f1f0862423191e0cd395390237be411166cda7941db9c74d291360f4fd93bc33f5d7e2e45e20f577bce33d1eec5c26e1959ac583c963315d1f20a7cd3cedee7c01d562255cc7053cccc7ecd6df44e7f365d3124e560eab64eb72e8558c1633e9cbd22a162c2e1dfdf6c11fa271b1828874d91adb07a4b0471db527b1eb171c46acd58122decbb6f11b6c901545e99a0bfd2c359bd60104e0064b96ad3eaa6e047f4ed636bdecf826b0d4e6904436667bce616ef70412454b04aaa9023a331e4907aa5294ca86a3559ee45dc885bb7ab5b3d05effe19a8a281fce7a798071ff91b235d51b1cc172d501fe8e6dfa6f9bf98f1b52c08d54f5b8c61bd724d401c70301b503cd0ff7256cbf69685cc9f5eabdc698a8f082fc85ded842cd42e6e5a2ded72ae8e9f1ac65fc66750616e789f216e498700c739549b0d5a0b149fe2472d20c4dabce7e824829b397242eee9e1a7c4e75f201639cb039ee98fa96029fedf2d3fcc08aaa25749a51bf4fc0ceef40b42e1b97811b8effdb65a93c6cae56359deab7631901fd4536a10a3bd6b9fc6f0f4ea70e0da5283d0f0fa48da5395014ae4d09f3dfa5c7c9b8c01a79c06402ed34e18f9df2aa25de6bd841d28a334334868177bad0c5378c2b43f43eb9799fb0ffedb2e55c9115494c2355524ac0ff1fbd836e54ba6a672b6c2c2e603892cfb43d65f86f77afb0cafcd49a6f4396352ef0e9a81b40b7984577327989bca7259d55627c11e6672fa62f5177e610d7c101f36c81d2b2b922a7e5e8292d8fa70b2fa23892202fddec8d3c27774d2a6de8c85001fd0893a48f489b10730b29abda65710b541c7d8e8e89b0ee326da9948c6f44c7f9faafce1e61bcf360ed33cacdbb7bf95372d7c58c204c8a625a113c591e216ce1d699cb85981f0aec3a804d17602eac39db37f510d7afedea12d30c043e279175af647c18630ffda848b3d7a40e1ec1077ccb97de574efeb6760c1d6bb2d30e04fc1a81ea56d75bcc95652a951ce0c829e7ce8764c356a00ee2b0a30d4ee8399c9955c7830f4f47e498915d54364aa4bc7f3dece9f5831b8ba0040f6bf7e75f0014e20ce9371e9988a62f7253f18bed352263cc468532429580bb250fcd950bbc9e4400df6ed5d18b58f31a4872224ed040d95578b9c8b798e7ed9b62d2dafb5b0feb3b7343d4576d90d8bfd3d8ee061c78f4e7e7ed42622949e06d189386da26fb40f90928df3b51d85de25a1a23af10f8dcef2dcf2e4d03c1cb5eb39e903b8eed048c5c9a334bc8e611df456cc9451db2688ea237ab0162fe7af7dba5c0d60f95e0551c1b51aa1f579f40a20ec38bb104da6d0ee4352582d2ffd79f2a71d51641c095d81354ef9dcb00dbd105974a09ea9f13cc711c4549de42aac8b8bec981f1d3df35b0fe38435b1afddf197cd31436db9f48a0c0fcb17d6722354eb842d9fa0e2005865f61c43f274a3732f1875047a101cc213f26d4565b06b902176712bc4c10bdd84cd463684b106bac3f57cca69192448a6bcf39963f4327a7dcc906867e7bf54af15132e8ebb0b1dc555b16f3702b97b983dfdd9cbdc13b456c6e002d9ab750cd5701e0e60f540c52172f56aca05a7479150146b58bf413fab79bf3d8ae89a771da7b835f08a7cd0b6fac4024dd377df77c4213c2ffa35df936933c63add7fbe84ded9182b91d4f026c85ab88444a673969e02c79bd2c0f51435b3aff1d07a0983bcee6d27d486047934f0d094b46ce99e5cf990f240f8ccd84c74dd5cd803d4b6573e516deba46c8f87994397cc35f5fd38d33cf6bc4e789f5e5f29a6d5f930dd4d2ea4c8cba1e28defe2da00901b5c68cb00115eb36b532fd3664f2e786d004465effb4d386fac3fc17642028711b5ae180e6db588ab8479aad2d53797010e71d9a238aef6202aa3eda64ee5114e8464601e9338f13243af65b8e4695b33f3f490face6c4cc9577b3426b192601c662ace7856d9eb26a935f624416edc375acbbfc1decd02836dae19785f6c4461674364aecb6687adaea7bf64c165322af5d5f0d75d52f136945f4f831bb9568d2aa05020cfd7810a727882fb097c524af65029fe7186154e7065018a6dbbce4eb8c6320b66fc7fac81b831908bfb9f99a421498dbfe9303309c49a7b03564c7039214aa9c082b037f2213b51bd6298efd76749d26804cdf291b78bdddb3a72b1ec9d445939c5be31577f6c3ba9d9fe1cbbe76c4b025d04d3c137f7ae8366f790fe8a2fcec8f7174c26822bb0a72211da43067aee0fec6d4c9d5cb69d62b751f760cf3a6676aa70ae052830fa1c4dbb8f890c43e893902e0b2d85419c9f91c4f2fda785d1ab3b4d355c960efb9ca21b87ce84f0e6c4e77b6742fbf37e05fa55d59fdefd09657750430d8c4eee953d790cb5b0929974fb252952ac52d4554bee51c65b2709e77f23b0734fd9ea89df0179d9dd0d205b4a4bee6c0798dd23c6cb1405912dbf3b33e3448a919af9bb288d1fa5e782a9de97a2fdba07073cc4269b4779d5ca44334463ab9c0ce92131169b0a34cdb544247cacfba448e5ce166fbb04e7b9e5bc70e6df8342c70293499d5c99ddba5f81eb6375c4b286df5c702d459b316e7604833fece415e04612d22a4a0d52ac1b1b0ef3a127d1163b552149aeba84d89e329ced915c2e1812ab277135dbeba616f662a5986ca61cc6f0e556d98ed57b7c959957af1048b3e2f5e4565ac39b677a4a4368cbb9037dfe471678d01b90e66d263688554b5841144de5a3098b5f509fd556eac4d5025ee98c572177aca01c39a9aab2175224159446a34cbadda375d349104072e3bdd989a69e34dbf56ba4c89436c313887e6fbc91e4b4832bbb41f47e992ce9841162da0d1dc2b75197b5d6fe89b7c216d8a90a9de137fb3aa7699d4f0a55ee417d6cdb86cd8b9d1ed9b9d1793f26aff22032357617d4df8297d3a0469fcec7c0ae1a6f84d07259317f593675a9e20d1cc157336c505c9f91e9cd652dd2dafc5026e08cb441f0c777b195876573626b6acb7cc07d9c2f842082be63ca5e4cb321f0d84963263a33ecd107375db1dbf0b0ea4e59f23522a5a0004273a397e74ed4b425bc711a7b3d0cd140ce715e1be11f278ab05d5d32b248a42334b743bc2dc33f9a15f64ff957175b42d71317510c117beb05873982b56439049095daa4a5876e5581bd3c2f78997cb1491e3fd2cde15bfa7fc1f931cc69d9cce7aa2e62ccb16beccf52e454c57dd406216ddc82d1f29baa004e3c8624e6a60d1dd15cfa52357e7c41602608919a5eca746b8257c2377ebd3b91f63c74b54927a3b79d83d1cb7a757e0ca67dd0ac92e13241458925ced47b3535510b6b3c756538db6244a45c6de3c69c103d20805813dadc37e03cd767ea1eed73e3dc93aae5efb64ea4fe18937070d2cdd355d77f47f6ded07023db33cde087104a06ff544094ca445545daea78abeedf2078461b533543f3f5a4ecbf0291329a0f6c00f5e4ee5d3808bae16f660808af527db59ff313eeb65ae1d4e3a87ed69244aa07a04d283e7c038f4a450cb17042852edfe97b09befc58c5341180f1b26f6a04b085cacde47875d360865e6da2351a0753bc68aaaccb35ed39afa0392a1c93f30b4abfced0b5b66b89947c0485c763f3d4deb64b50654cf76e968f8459175c665340e71e4ce068f6dc2bd47979041e2a9810e82a1b743e29d340c956a841ccd7e447e414e577bd6f60894c8ecc8e04089b68600ddcaf37b292c804e855c47ceae9c090b3d3fbf0296b01b722fd0fbf22412137450242247d168a626458e1f9e0ca5f80fce55837e5b7ccd188898aebc61498faa4838ae1148a92c47871abb6cc273f3c46a63b610ecdea1eb03a3b675cccaf220649f15d6a7b4b671669715079da10a72e044fa809e9bba784a2ea8d681d8a75dac39c6635871cabc0a7d85522fad4327b4aa0677ddc6477e2cb0818bb53bf983040cb117670afd9382aff5e47e25fe7ff82e378cc7ba3c57174c72974a588aaea07963ee070067f43b10ca14c6ee00a8b4e720396663bf8c0ae7abd8f654a6b476f5783cb8a61606547b17ed5717b3e460075ef4cdd0ea2d651c7bbe9afdbff44c700702bc0e8f7df968d967831e91b48a5f95683077526b299d3d586086299aab753eda853cdbbfd6421f55e62a2457208e92751b3efdac0585f7b74c2321d2af5b861b345ecb6fcd12750f0befeb2126177d7cbbd46aaa1c0ad7c688e946eb54dd7320bb55d5daa48040be220bc5802da7ed51f3ba34799e5bb51d2404c6ca89bdc620be45927d577e6b9b1faa2d398bc919f9ee5c8200c2e30b523c581245be1cf95822568ec539001a3de205773be4272f71a3a13ce82825afc421510e3ce32f8619b7dca6a02de60416de6fb256eda868bb6485144430b80d4b32ed7ed2c9fe754eeea26052db8ca1b93f9deb2f360dcaa68c3d4f2d7556b29aa80fb42a3e1d78a81ace33d4d414984e8a6d61120252d37c59d22e01e251bfcd39876cc09062c29985faf164ca449222877121763becf97dcddbee7866a27eb58695b3e5474b4c9fad88ab07e35a192b0a0ecbaf4769199794f4729e8933484b962e4e7098f102a7eee2a70fa1eec4f87e186b69c57d0a7efc20cf78f673d18847e83f3932b47531ea327d92cbf091390fb4625788453239f788cce2e6f84e5ca7a9f05a0a12e17f5ff593ca137061f9b0e61718e512e507cef7b579cf5ef8851f4967e8d040b5485a3ba84efca45f749c2ec1354bbbd99dd2e0ba6541f12c04085f01c0c77e8860ba85b3a88284f95d61f757f6d7cb88a7c7c0e1b5e49febfe3d8324a4835b1d48424423178f4b8d20ffa7f3f8ccc02df16c12e3cf948e69be5e3e71da4e3e222e82b4c1a3233ceab2113d6b0073cc2f0fa88635f02b79a4309ff0212cde6c28091b2d8e6fc86ac072a856923e94466aee90d968cfd12eaef2d0190cfb1856f3c135866022c99c5c03e92dbb9fb50bfd80b8472b5420cfdde015a4ca389b204bb6cf9135e9ae70235169228fac1ae779142d9452a32f47a1ca8b6de55cf13529a82d8acaedb6a15813373182bdd19cdd7798b56d62e98783d11d163ea31626eafefd49751b76f3b3213c3c55dc56670321615b9492fd0a40fd4b9bd30dbbb1a1dfd5b1b2243a0057d617c5241eaf62b881d2a28f1a5664ec4f4a5d3cf0e72bc1784b92086c81a3d84910a20bb86080c9524067bea22762400e0a5b215c666129b9395404d8428e38ae15696ecd63680ec56cd3ed2a92048af7e56d35eea78793d3be64a2c761f744beae109bf6bc48eb9ddd1f0ea8f3dec7935ef1bd4a2184c028caa24f45c84dabaf4f9806271f5932f21c5368bbe78b2429fb6f87b3181cc657b922ae724dfc9712473d605a81be06096b753b808dfb47ffcf3e90e500a9cf59cd86e4ec527780a6cb0945b905c3e999e60ed875752bd89b6c9ea272a719d94072c13f01a76b2ab229f80cb1d39530fb651bcc5c094337a128a890eeb01d4c60039cde0e1044b4b66375d1ec75c1d17b6c2184736a1bae3c6303aa242ec3ac648b369f0f73d87c4eb8b3ec020ac1aa4a59df640ff74037cf59b09d7451666e9742f80856e4210fa06ea82d2e09028a0d06b7a2c4f2ec354d941177b107564a9738b509009df48a2309e704b6380f3ee0b7a185b4d351d54b706018f9bc823b796b352b3d48f84632c6e81a0a4a9eaf23be89252d06215b7054e7b0a2582e641f5a6d10ec737478772d5679d40980a9ce9ae7a7b50e08c05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
