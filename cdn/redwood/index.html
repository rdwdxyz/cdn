<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51b4aeb251b67a8e8fa3f8ca0df170f3d48ca1bdd36cb34fcdd6258bbe41eebe93d2333153b5794da5fa2fde4a47ce9900ededeb80e2049e3e0fe798f56b399c86c3bcee0007aaca4aeebfb5d09069ab91278b8b6539bf550917d927c873a631bd3b47023328507409cecd0e703bae07b7c3f4c24524eb79ed1bb7aaac8b3066ce521173d2d979286ed98cecc1000392852dc633346d1d00476c0fdf545d5b06b82df08cf579408c59580898bcba5e3cc78af43f27887012da3c4f16fafea439da213b52f357d1ec2482cd58761c06ee1ff7973bad4fc1d71fcc7911b138b1c9b9dab9cda0baf8a9df476e258e34bd3e5c012f44c68b1554a2c16bac74e9b2fe3454e073ce06220339c64ccdb05e6715a6e7e578a9addb28dbd0d56548e0795c7e7b1183c21b5e319c587a6e8888a8a437f661ebcdf624e347c65b13c73c8f1f20bae7968c48861069dfb3de7b00ada8f27b7ce1aff03d375efc4464156c2a637e738848f0d6366116df566b275310e58ac274e838b53bea64e888599185189ca2c63c3900976eb05b9595c889b4df115ac47911067b17ca7af3ce66f7e8ba61f1c06715c1a8e0771229ae7503fbb93a264460e0c0c54418272854368d7f7ed5d00a3618e796359ca40a837a32a197d018de8d3693a59fe8d99d59aa387d7394dd45104a88bd80729241ffa4c7fbdeb296aa6391e8a31aa6104917b02ec400f95ab43f83c75869e20c1dd3101a1fd1586679452d2727cfbc8b4fdff75ecbc429b9d20ac460d6af978a5634b091e5baf58f2e4ae353f85a34114bdd055d40597c5bd4c96a02f6abb7b2fce3c4a4ebfed122fa0029ddbd35f97e81852ad24fdb82a738801ebdde414f5671bd23a4e72b4ade00855bd8390b0353538070952c3af270b18b9c1a9111fed7aceee69c0719687dafa9a1895c64d58b18af1ee86f63917f41f2afa5b3eed9636970c1c003e6de301d9bedcc927b40751d7b7f079e106712a06ae9fd327963ed3611d7dcc1a8406ab1d28f8136217217f3094acb7b78e013443c1cbd40150e1adcd587bd1616b760a13ff7a9acc0a624ded209ae637131ea22e03107652d56b9caeeaf643c5a63131a910d3271b50c41c460daab1b416bc77c0f2c330742fc1dbc40854ee20f5b5a04e134f92230c324de1b60edcb44595731aa5cddbde70d75a4b1a7608d23f4fa0ee74120f9af087dafa1db0e5790d5b3c8cc73eb205f67d0598037c0777c3df9407189d0562ae7d4758a07d1f224fb962e9d0d1b9caa9f4fa54f943d23f48978077c2411f217ff6c32009268a18e5b762ea25806010bf51edf93d7403bbea4787aeb5627290120ac37322e0502f15cf33805976c02ffd9e980b014d0cb1cfcc793ad305fd411550c37c352d893e87d9307a44996fb91a42ae3595ff820918ad1491416dacc45517ad8a7668fa7455856f213f2a80fe1421f0504260f6c1f664a290ce8f630f52fe068416eb5153f62dacb5e68bf6a492c4595409502f15a052994e5021e385b400a3c9ac0429f860f5b55e0bab6ce7992fad12476e1c3368375128b82cf50bad6b460623d3788e2847f25d3644cf60234d718ffdd03f701c4dfc2a467ef75731bce78a78cc63ef4bda8ac717355910652744a6c56b1b20449ac90131bcf309fcd11c6240b7569c1f71108616082317457ec490833bff0fb14c1992806de4cb9cd6819f1a7a6815307b20ce6e715f851b372f9d337f07923789963b714c672a826292e7bada9e8849837c31d7ffb4eab732b158f1cd9503ee8199a9f00361e7107ec2363b32480cba12e997b3010a510012e111c954bbf8b7ad13879f20c6ece82b3b54431940e6a2061f5d65ed500eda211055bdc5fab0488693ba05453b6ccb60c9e9448f40b1641cebf8cb4dbb5a3f39746f2b0f12e0ae5e0005ac3d56edb71427806d0936267be7aca976426e985c863085b083f204d52ed4b209ca64411905e0a7bf417a6309e157cdf047a9b6b0045a067ac73c56d254ed366eaff686876b059382f8989e1b134f5dbdd82b163484dff48d9d4e49a835a1f866f3bcea14f6f8fecb707acae42f6d28c32f242e7d7c913b91a9a1b767934f446ae36ff2b41319c92f371c183fb56ff0cfd8d82934922e08aabdeed6c481f037b635f07429a2faa4b39e4abf00b8a38e68cb45b0eb4e6f088545d5383d744d1654ca82f0f3681ac3dd8c5b0c05bc0ac18c302b9e36506ebd755a670904a853575fec45c35769b3d4103a9b424b524253f7e1ded7874054421053646e091c511d62040e42a38ff0a40f6ff32e65b441eede225b0bd2a3b471a64aad687f0206de7a3a22a761da4a2b43c7192b3cc079a9c78b3d3c242b8ed98ed30bb2e36a64b8b087cf1c0969cd90c96580205c014d928e551fb589b623b6119adc042c087e5015f776792842fcd37cf888c7f6e6ba280c96904e1046044fcdcd080e911fea2b99e8f9341bd7d37b8f348553eb5459dbcd74108c51e23c4226408e38ea584d35f06920806d8a938482c2a903b1f092f43add26fd78bc6ca7ee02f062008d6c7230457a94c053c22f83325c370a39c3dab1cb98c54f13b99940a1291e01e073041e4a9e2ac0278eaa8f30060948b65d1813c31d63f12c42f88c2c6ea4c3d76cfdbde8785fc20da062e7cd38d0409ad1de9ff181a715cb07d1f34b43e3f3880eb5ba7c8cfddcde899675f4dd225bee62eda10d9d2c550f00768b16119d57a4f66e521d56703796cec07d14e844e843c5e271e7083f556cf7bb5b262b14a1390bd4e722ca0d9c58c5eae645246332b012d96213360c51629839bbe10b004e29566081c3bc8361d14d25b09c72f311c06699f4f1e763e1a6316f9ff60e3b10fa6c2085da3741a91a87cef4dd04f48cc83ec02826fa67c724e9113b2405ef477be7f3c883a6c6bd6491702aa39fe3bf42210c4dbd4c7c13e66c859bfdb595700166bf7f148b429907fc9af5ad64d379ff6cf3c4935a9b85f0631135fb5711ab3af87d05cf0fbf12949afaa4713411e239397fe331085c962829054003479c033b078f2505ff159aa020e2debe582742e1f6e32ac5f7cbef809f5546f262167339dd7f4bf2f54242688f03cc2951f512952aa8070b7527905ea7e5a6e2fa0a2bdc8484a3eec7678773d823377e6e2b26eefb92c76e8f203c49d86c536dca85144df62aa73aa43375b77c77c7d71351a0b96be5ebd13e3f52c46baa4874f68dc69cc96f90cc2b2a1f3e3e24276b6f3e30b248f2e5415a33424591ae9ceda8bd0935c7d8973c64814a9b71f88b84d6f3a126c96741fba5e7f4e36380617afecab072fe0d470c1e17cbd14c1118336a71faeb5bf2355fce20ff27b33db98662979a6ca2f8c62f91d1af68afdd898a4387b9de496e92abf85b4c0a46cd008b268dabdf801de1157c3147a89d74564231b3b5c1539c5c493212312f80f5478eb0be2f535069cd97c59aa547f631591b28fcf2222099742c54f445d5904fb027bcc16e5308de5d99aa9223fadff30e754184d1b3277a460beba56838af02e6ae99b39f498232a4d6ab01e2eb7d246cad0c63060fab59818eb2c56230e5be93069cb9e63216d5b6f37e14766a178b8c52cc1b594a9d8bbcdb41c808b8f7a0a6b8cd6d01ced3de86d937ac0ede7cb2841d9db1116b978d0c462c054fa9c502c837f7981e3b54536737f29dedfa3a034113efb4f3045169e080abe3fe2653ad0b4304737eb7d6665c2db5a0c7e6c7f354c12d7b193f94c8a0b78d1f914117025edb1c1ca0ed6a39e296bb847a24c3dd7eaf61b2dcaf875aa00f33f1108bf62357bb33db9d32f811a1807bfd84cdbd9c03ed11c2e7fe63c898dae479c198bf3e7ed36c4a6b82d3e400fd01f5d8243efa2d82190a3996e586700ba76ac433eec6a07c68e6d46e47bc3b819241618272060a3cc95f1e08164eaa12b09f3ecddb4ac49b0e9aea704b45b768ed3f5437258486ba17978fc8f80c3cec0c3bad603ce6edd1928035772989ea5f926439574b472844c5e0f4fc774ff42c9cff3878b45b7ae7925bf80220f77d4fdfde05cbc4b6cfe599c1cf666ebb4cbdd63c9ba691337d372019e6fed1730703a0e5dd5c5b2f4e09b994b23f3565aebba9b20e4b60b1d8d4600c6474f3ae9efdb4b29068df574db332ad0643accfac5819b5323bcdfc253eea05889b85a7ff32042438634f2f46a92cafb46d75336705b37f1c6ddc38b57d48a7bb2a0523783bab8782755d0643ef9593b113e6bd5ec7ed832f6947e25cca10a9ca650dbf8d8b7d5dd6da829ca3d60117b2ba96bec72eafa1160a691643d65a9ee17e6f82a8c4d4efeb9bb4c5328d4f7d71d7fffb6e0351a6547041395fddc55052136ca3266c8dccb5c8f6df112d61b7dca1d041e9aa9fa55d05b2df6f69d125e9edfe3876721bbadf0aaa48585b9bec98666d1e5ba649f597fda20909ee2c7dc39b47d6218f4b8eeb6445f8da672f27f4e4cc355d75fa210b90f66da954a19408181e762622453784b11713380c07af4e0f49e4af2a1eecfd50066099296a0ca757290692f1b65a18e8c1f0080963227c89e1ca78c070f639ab4c6d5dc6910ae12d1925d73e703ea9af3a92783526b670e5083b4b5aefe6c134e21455b4c05364d7e6dbee4e93770e3e5eb85f915c2dfc45ecaaf65f9d2b11eceb86a96e98db9025e47072bc76d61a1be41e66e45bac388037d9146d65eb0c439d3a134132bb277b48c26bd4ff74c886a6cf81a9f4d1338c41ebb3d88619ff32960c4251f03cbd7e62beabeb3d791428f85692eeff40e2d5abc9672eeac19aab504a6646e0c37db72528864d5976f5c1495ab2009676fca2be2612fe507a860457aa59b986d50ce8265b345c3dc4cef83b8419e042ef217e2177259a19ba201446332958c2943f79f8da9a0d4c6589c90b7c320ee1aa33cd4e439107bf550aaeecb8dc0a54fa544bf7a285bfd51ad5fb090b8e8ee9da75ba71adc57a5f678ac6a3718289ff4a545a3b23b9d1a18b4361d275994a7e15096509d00e5bcf17cce6e31ee46690cd830385ef7055e15fc5e17275f343f626e49a0fae4ab6a67e090ec59bdeef17d19ba7cb1fee14f7a8c23d2dfdbda4479936f7862215d43c79f2d41e518f7a7d50b376608673db34664eb91dbdf40e833cf086c60524202af5f1a9d408a6bd8e0dbe0f3e690b455b9361b6c631445e62b2ffa411db42dbca877592a8c5d4a393111e8521c0c61cffafb5adb854c26f5511a903be8db54a3f888e50abc0be81e4a6b649996becb6e7350fe252abdb26b246842b4c2b71426774c455173a23219294c44a153d12a64311157821a5ed6a2bd8e22d081f03c1f5bbcb15fcd598f860a1c83e3ceebacf66dcdde310508251824a799d854c0c9764cc097119f47158cd4ea77baed219ae2ab29c252da8de68683b6a9db550aa57ff4c66d239db6bf00841abd347483d7e4fac45421f4fb7a94335c0874982c4c0445b861f153b1dea1d1fb451f726cffb2971dcfddaa5e50d391cff5f69afc51e8416bc63df9f1a27b1b9ea57d02e4f62db2939717fe2d0a6329ae945601fe26b96518d911de8e982710eaf488eed82f7f66abc45050e058a72472f7e8e3e3059adecb6d30208f5ce266c0742657320373bc0c8ba1e503383c2f672b5fd2a3ba64c80f8a5dfb6e3d5877dd2fa74fd83fd77f8bee8a62a2d35a4f086b2aa8c2f966aeaaacf732d6a9046855c7411afd954bde679e9074ea0acb04d841d71c26939902a193162dffb6c9175ac92249bc8f1c83e8326a18ae1c28c560747a840074f792cc3ee4dd5a5947165e9fbcfb150fa225b28aabf17b452e86941609c3ebd87b652461aa27ccabfdc29a9b1b0bd14be39eb5e3e64ce2b1b861477c40c9153c071320d391fa02bf659fd2f62bfab407bf80a74ce00dbbe9a20433444fe7ec6cc142676baa5e8ca7b431db2fa7779e2527f9a231f643a371f560ec43681ee9e4683a9f149ad464eb3d56b0807ba368c0808e8fbe9e0df2b50d2b44a8ef946ce7ca46811c1492b01b63b03397eaec0d3dbd459e3772393a4cc8739a80bf48af1c6fc2af4ec693bd563e558450aa451eb6bdb5d0a996bbe499650d01c27724f7cf9d812bc2afb100de701385a847359b27748448333b264fb40477d44743d1cc3b5b624c0feb18880059a7e376b8588d609be45d56616708d6f5fd40a378c1ab9b18e87b382348055a5c2f1a542e07c34b37c7f41e2e67c15fc5bde25f71ffc145d11ad149b562fa674c8e7b26144b5ef22001610604d5c89b977bfda0cb600f747d8d09dff0c84267f5e0735a2bcc533ebd4a23495fb6a9f3693496bc293488339fdf9cf928627affe4dc9ee41d1c25fe4c0dc42f658da6eb206a02f204d1b386a6981812ff752446743403fb23497e205a2fcbfd15ae9d8aa82c64134572afa3257f2700b191d70d17510ec30f9b7cca9d3983fa7a62750201eb4e9db70f003cae18b9a5e2a50f731a2b0f34cabb04fa2dd6d7d4dd72075672322b2603898e410174830a3ca57922fd066a0fa27ed5ad56f28589da0364f12e086e63b79caa8f7b5217f830050d0f1e8ed3876a997f021682fd8c16ea055be0c9bd2f6cd0029d19998cfde42c3e59ed8e4a50dcc57e36a26317ad5ed628d6aa3172cf13c9347810ee6af03b7730697339485df228eff3894b0fcbe0cba4731e91b86c1ee7a99fc88c7ad5ece4c759478dd749afeea9dbb913998b1de849725f046fda88944e16021cead0a4d58838f8b470e3affb649410448c7f9c7551cd0ac9b784e61b0e01af4efe29baf2b69a2cd45434b8741ebeea781bbf0857745422de08aa29af4d68906b6fbe61bc9d852eca18150e492d4109aa588d551f4b4f44aa2b81a4b1c7d3e5258f06ddb48987b21af41edbe8c0d90ef89042170fd7421963c2a0a946e952f3a5b179e76be9ee533f3355a2d6391533a78a2a3875c5005e958dea13600b8d679a8c325efb0e58004b920014da10e9afcb203665f67c75964c7963cb27d719324dca3cb2a99a9c39e94c45197bfef2c227acdaebb39ae4cc984b521077ae94a1fcbb24121a76efb34e6637efe10adb14588d5aac8ef737b20a438d985b4130d9fd3644db044f4f6ed8da01f5e03244161fa80cb5ce58129e2b7523366dd11e4ccf5fbd7d68a9bfd1be62fdc787abfaa5725a55bbdd2088423d6e58a067b00ebce0241a24ab8fc6ae1c33577095598113b0fae21c24ec642fd0fef1a06c55e1967606c04b82ff4a6828846ca165ee1b8bbcc4a563fd91d507d17cbc1e10bbeaeb630a021438dd3ca50840863c7662e696858f12740f376b0a552a0e2e5f451d6ca1b4c70eb8418b297eec4ef9976d9fc830c4f621b55cb8dc6a7ee88131028830cf6d25adcc660d0c51382dc5eee9f763f94ddad108ba107bfc947712783155e0818ae024bd1a4df64c77a1fbd645da382aa7494c3b1a4b384bd2010bfe156a8a2c634be4324942076dc66cf91f69fc03ac5903ed08fcd514fb5919e270f9a40e5412e9194f058afc2593c4138194641a42a253886dc85f67ccf379e286382dd18ae461afa2efbebc3dccc1db109ac24d6a3eba4df3a2628bc382d668dea7445cad369996ea357443be08d2850d3dcb3d75ba63b16ea50f43b2c640931b0b5402223655509b55ce0600361fb0bf5a7a488dcdfdd121f6fd894fb34db278af28921dcd41ab58bf277e2c4b1f16998a478be2cdb12c56f4084bc99fcad9621c62c816c004f489ca6cb9616b66c7fc3a3ca0415f4b5c07e5c805f73bec1f1eb5a975ff460b63bf76fbfd8feb30ccf5ffc04c6217bbeb3c976f477eef5e9cee831147f1d0644e761d4183e128551bd56ae99c6cc7f0a70f77846336a0c50842a73e2922529a3750ee210fc57b0190ab87ea4a13ed6f6244b986ad0f267b50a639153268812c20a2a187d2345f16444537f6e79fed11e414b5661570957cc0c30e6641c87ee9baff4709ee99d45a47c99c198189729636f5371ea473d1c78428d2dca70b06a9452ed5803a59c6a2170f7bb37c902248827d50b764fadd8f22366fcd925ef4f64d6476c09ffb82671f9ef95af040b4892d2dfa16a2a7f6d092d5bf64691a4fbdb64a52757fea6fe1a6aa85ed7665ef933d99b5cd2cc0121f0586362fab152e0e37b214657c5e09352f86d0974370985a0a755f71c7fa1a774d7a0ef01f12ee4476bf55652d548f7ed9266993074768db7380683da87f649238bc3f199d36468f15edd7383315b592a33ae7f18f2b617011080d8119386644721c80f8c77b441ea5cad95f088a6a333033bfaa8ff96e32c61eb91ffbbb41ade8bf88662ff3c9e6485caf1ebd5c85e93fb6f52d802481c4bcdf02a1fc6762ac256e71ccf74dab620780ac2a1c9af5ba1076db796eae7353f9ea304364d48a3d0dbd4d1029e6f398c6cd5d347ecd5a6f460f253a63162555987629400cd35c71737241e942e411317fb1a23df3256ee3c36bd5df5eee0437e16527e05db2dde1df89f662c4afcc3cedcfbfed4a9728771771a5a5f000c28c45bf9a8f4913b5756a5aa1242bf315b85630779ae215da314f15c7f206dfc317ee423fbb0dd51b870507bd9db88a753947ffa5e41b8204bed3103508f7da77d40b5bf73c4550757754f182a29d6aab456d23609103fdc23b57baea3aeb877f89c2875f85d6dba3d0dd84eb7c26e3ba3f1a024ff44e4a56530b5ee31a16fb4d366ab827b6b1688d75fb10e1e96707273aa2b1fe5817deeee6ae77d2cc85c45e091b7afd87af834c2097535621c7e75869d354454a89215d60850e0306b9a4b7d88b0b57a948578c6273e34877ae71e398ac12b8c351abe9e4b6fa825967ae2425807eecaa0901a1047c2693a6b0bac4b3544e43f6e5d03a042d7d34f38bc270b56d4a0429a994d2b981c3a9d808bd54b089855f8e7dc75e93939780844bb13b36c6ee556ee22cb77596c2203c985c8b702dbb66d04534b3225abdeb7cc57aa1c945ecd96febadab22314555be57185d2e423ef83307f32396cdaeb661a9c1b24397db957fd57fc05db2fc2703a43e0ae261120138041be8918c566315a557562aa6f425139f4fefdedff3582fbcd1dca934c196827df35d58642a8576b81ecc53769625582ec7b37b8ee594b7c58afd0c95f97226930a9511cc207aa2dd92213d4a8faa6a9ed412c6384686af5978712d4f102a4c0305da2765d0f1f51de937235bc18292bd21299ad33f1469cd97546c692f0a887ea30a3321ac595c4cd932b0168998946cae67aaf5f70d85fa6c26749090d88349e1851f5ca22b78c34f199acb136aae31ccd90b07d47bde002cdce80d4e1d2f271a17124150afcc40dbedeb5abad5214b37bc760f952cdc73fcbf804ffd38aa5b8108bf7ca759ac7124a411e1b05cbc383030084861947c4d6f5d1baa6f44b46b97e177b48ae7ea884923949d5294b180af7919f4a430dba43a771ab74e05e89181d647c2fd6995ed616f8c97b4aa1f8ee66ee6e262144fe3061a8f5aced753ecb309b11bc6357a82549444c9f4e8d14f3b41b4377600bc76a0dd58ce2767a338bccfc5627a06157fd2c1c13b71df678aeda0428a4d7af3647bda55699ffb5468f0a481256a55244b1cd0a89fb18a3b8f58db7be176a5854be6a50255e8b2552c119f294b7476236e1f7c7dc878e2de04d26aa77123a96e2a30f734c234a63451690b42cf950f7dee69342e67ef222d99e5d0926a69a4f7e537b102fe4ce0a2346f5a32f91f97eb927fa2373ef9ed2a7cae36553c61d7cc0803e47281d6ee8e3c6576230a81cd264f6b4b23be794484bb3ab850e3abcfd6537391187335d0de7bcda7ced28024ac53e61458ca8bd2d194f041889eac51cdaa359f44cd74c2f6e999f03813f060a954d2320d87aa52ae2071723c7fb6b68502d2de6b848e42121ad48215a5f8c1641316a3ba8c6496bfe52130bd0a2a62f0bee27caf00f2d7bdb4942ebee471445583ea9047c51cdaeef297a12e0e7220df4a6d0c2443b4bc9fadb0cb1f47b22935dda351d4811cf53ad1e061fcc2c4caf3657321b5d4d6096408bb18bd74da8fd4e38b30bc7a18d2d6c7626fc8187c53c845015446bff58f231a247c79f7cef3933ce7c074414a592ad9c18d1921812b73559542553ef75dfaf9fc6b6af1503503d77e31e3e41d9d37397778b1e84110b0a0dfebd4825908a2863e6f0c3d9aec8208726ac75621ce17fa10fe131919c530e3273efda3fceb318c02701784029e36582510a400f22661f0fa07266fd91a5b605c83f6ac5a7353c3126c12f70c849a3d1773fc88d02bc9ef35f858d5dec8bb4fca953ada19e71050eb8313bedd460a652d7f9efe284af9c65890d7f97c98b12b120784e9bd77d01a4453dee2d6b5f62040bb8b8c8e89f53ec2b6b315913db32308f9c6eb24d2e5f0a8ce2f08297dd693850716758aa08704eac2f78fb8303196f608653701479c768b436b91419b1adc601cd3bca0a02950f3bf6c0ee3b7d43e26b36f26f6f53b9c4fe6e25fcf59a078afd1cebd6128a5c6c093790af19074cbbe9c57d06310be85969fbfe634b05a839ee45ef4e049bd59242d3dae3fbcaf3a8c94efbf9223cf26058a933d3b1ea66b00903048369fc572ee08f107c84d18b7cb54785760f048fcf2fd1d16f1e7143b76ce71308d51f531d1f0a8c4be745b9f58ba330666f357f794e538093144a27d85504d2bce7a2b0215a5d28de0e825e88f420f7f1615dc9fe1006dea15ca5b59f11c9b7da1da47257ceaa01aee8bdfe451788230be70e965413e35951e0d607261a05d1c5d037ba06ba7956d99000d1bdce29674db75d90537eadc75dbb0d84a88564d94969f7f77f839759ed2dac7a1b4512996e67f394438a8b0079564db3ba45268b6fb132654c752cb5b3476e720939ccceffa27bf17080199bc1c825714d85301cd08793240267469dc2c4844f2759e3684839d67763e667c2ca9990b3dd9ab35d9d7f45acccc3018f2084dd7c19ea50d0aa0217d2ff6fb77f3fd03e5444e64db0d73d0b7eb349d60676b7ef4d3da5a1737ef17c6bddd51d94488518e9729ffc51f7ec1c9acc0e7930c3a6aef4b7bdad86d670775ddbeb382b96e6ea498a98b5cf8b3689be9c1a2d210a570ee3a40f2ec4213c4d6614a19bd9f74d6607e0cc188505df180126c053f5304152223a1ea4324a5cad1a71c90c1807c41c3dee480883b1de0345fcf4ae000d8c6e9b9fc9c300e4f0b18049f074d88947b7f519ad1a314473ebc5a475172ef1d09602c4f387be581a6af4dc4f2f4b97e1258cdcea7e027a4d8c5f1dd1165663085f611baa1b66ec418c613dba4fe15609e9a9c5028c695b67e9fd8506d1b5a0cf93c38b55ca9261474c47c58cd67995ce5be55b0225d7489990705739e5fec3b35070874489f12ec6886ea89e04fe6e47e63dee32edded383cc6e5810746ecd038ccb2745a4e0d60a037cd8e1a1094b8e628e04bcd7ae66e3ef4adc1d6f36bd10fa4c63f9e0a79502258cce6c855d7e34d4b0ae387f93923bb0d649937a5ddf8d5f7d0100c593c72511cb5b7edd4d989c31943e70d94ea2a29d954ad732b0fadb7c5c79e4a1a9115453f96b446de18b30a4177d618babb1eed7ccb45a79c64576283b455691ce39435776f1d69c54eb8e040414fe79b7bdf1057d60012b72821cda40f3ebf28a1483f61c6295f80ad143646a9a7b3b5bcf2d676f846e86650f4431b6942a41255a9ad2e63e1af3320336a9c104d7eaaaae8ea3e729fe28fcebc940faaebcaf7ff76f548d896843f00276e6d98e0ec3a340d6b24d905c765977a21058d12c3b0a4f44dccf984d87a7cb29b5337e6d4095148775888a9c6c0a1802e0b8f8bdf0e7d9545d02a2fa6de807568616688b0c5fd5443d2d9e14c345821121ddfab3e641e5d1c1e3ee1c38814e4fc4f487818ff08ec0f5111f28bf2c580384aa592aa5114d8bb21b53a7b6cc3c1cd9d366fdf4da2a0352066da0b20714870a2305f390b3137471438ae4b8f16fb5ac74f83ae991cdef61fae6712630f6ab6a491ce4bf367323ca4bab9790817cd32ad07b2f8e3ef22d619a7a0ca92cae3e3ae64996d12ef44c68345d968badf91dd08c1b1bddb644a584a9199723dc658fcc00de5fc558631c7d8e00167425170d340ab6442b3ff44d48291e12a9e17f931a2ce19860ee74ecb26bf1e80c25b5e03111e7488ed3136e2ff942e60f643fc0f7129ed7228e33ae5c2377f580af930b3777da7e04636e67c2c15d87535c163b6708ccaeb3f57d4c694384cd9de947dccadc4524e68c397cfd1d03299d95da8cebc80817d24eac33a5413bd67802cbee69dd6f5b635c418a2c387080c8e0fdd6a27800b6849fcdec31e5e925321b68401078501a7331057db01f1fd07a4b2355fc6921a0844e4bb89e97485b6e025c51b26a6e20f560e4a5475e1c24b9ea01f30e88a6deeeb4df8c9122f683c89d1475ee7bc7c07c370ca167f0fdd19e74c079d99f44fb4654fc1003e9222da14d9d2ac3d4713062a1442b1fe301e131001b308e87c025a95dce7ad1a9dafa40330472e686c4b059b80ec742b55d7ab536db1157cb1edcb22263ec729d81263fe3e81da3a033e275d639b66ab4d34c9c662d9cd5a607adff1f04f9db4b1ab88c227110aac209be88340d1cc17bba57099222cf566f6faed9d6c87006cb755574b4d951a0cfa8708fedb2bc0efc3e311d183924268988c68df05aa3f084b923f85d272bc98fc4e7f42e7544cd3b31722e1d1b87a4e4fea4d1f2c5867625013946b2dd285602cb8e43b53135dd945ffc52c08f638d358b4829b867f5b38c31ec7f1c295354869f7498b312fcac89d018a63a9a37f249032e7a1550c2103165290cda2a0eab383f4bf30f93cd7f172c70dae50f1f2ae7756379d83270c3097a541e14fb2f09a5e4c05caba0b2364d91e3bb17b30488bb9a2f9dce4e62de1b30b9a2564c73e606d3254a0ef63003bdeb8c9571c1e465904e75220de33105d62ac6439303a5ad00be6d07444244adce9487ac8d4b2d7ad980335ceff0f1b4f515c3b4f760239f9cb548bba56b7ac1d100fe69107e3e2bd8033f601c1dfa6d24e037ba2c70791f2af787928829cdbfeb68962d4b46427af036bae0f1e0be7920b23bfe23d8e6a5b832fd3a3500014a27b6f959078f0ea50eeddcb2949370ee0d8d54c9b0d1b915053a39c41f107eb2bea6474af62ef68bdc08ec6bb716e116ef90e7dc6d3b16f82f56fc7a96770137fe306a9d66c49f03f7d1912af173ce28677072f102cfa77a46d40b4c04caa1b544df4ed9c953ff5b3446423ed771ab58160820045242f184e229473d313817209ac1922179dcf5dde71d557ef1edc98128fd7041d58d901b6fb35580b9cfa58b23597268978bc5c8f8f10bf0f7f042cd8c62b14574c24c352bca25672798ed7af1c92eb1cd73f630befadc047a449d5246c8bc31589865e436810f38c4e1f99b18a554cef2e0258dec63736a19900f453a6ae2a44df06843a6426d9ef92cc9bfc31f39a9abfc52a914d5f4a81593d1ca21f924a2c8e2e00ddcb6cac22ca75790063c35011b5fea45539184863a0d1df09218c8e603178f4721c4a1d64ba45490bcecf7f97998e948dd4df53b6b11eaf372f51f97f9d8d7b76a93fdddb233d25b278c47bc1c2122cbb3f21ac14321e282a6a7724d8f144ecf10a94dd1334c3fefada57f61c11a4d7c0ed6356fe5dded586c3c25c1edc359a608e879253b4232f2b57e24543610c2b6ea37050bedae488d1f6917e06d7e8ec09b00a3b2c5c46c1ccc9fa8c166b80fc432ffa232bd66610218354628bd46100b268c68d6171312aaa210b3d92a43b921b8fd57bb108e03aec62ece1df19f48413b40b1e29e4ce7413c80236858f9fddd1cf0dcbe95bfac84b36e8d2f3d05cf7459d749b76af68a171307731b144ec7e3f5684df851e138dc833963a791f92d1203efbb2ed1e3469859541a35bd6a5c76c2cefdc32e2f6e9b064effdba24fbaf4d2d80f5dee3a9739e1780a559c1ae2641b87b844ec27a70fb03430335f3ebc89eec7dec351d86307826d970dc95f63a7941e0c3ebce1f1e1fad1993d5d5c21cfc499dd554d8610afb06cca1b2887058aaa241812493f66d32a0b26704c6cf7c95d71c3d0c11b2fa27401f84ed155d24e3d63915738278d07b9b1e16993384a3a567b05e96cacbaa902242dc190ca8c224a2238316bbe92ca579289122cd52a575ece261ea4499def022649fcb46db60b986f018109612f8d0b1ebdc6081ca9071dda1f2c16057913a45a03c0768afc4878ef59e5ff1123323d323d21529a68606ff2ab7f9f2654ea06184a5009d12552caa63c813960622fbb080d8cf6e36d4d22afda729dcb5694221560a7c2c548e0a43710680fcef1626c19286e49c24d8373eba27134283c74881d1f98882b8c1ea24af8993725ebcdece9ac9935b0381400b1a3e8ed49c169d6c17305f06b04720c1490d20599411ccfe3a7a43d30ddd284ccf24470517ca81f41bc79224510e77732dee30e0c5bbc88b33b8140aa9c6476ee587df2ff2268a63da1e062fd9820c93ef3efd53fe7f3eaab8f2ba6fb8113b28886ddb0ea3988d12df7cf80f1d8942301cd7612743077fbf01fbdfb0001bda3afef4b4515fdc5d46e26c996d17dc7a7c48b3b563ccc296bee9db9c67801a424499d061f569470fad980154e4ba54cb628d1eee03468b6dc351d129cd2528c085038f9ecfa5e23f243f84fabe702f49e3dee58927b37ffbeed63b1593c510666904464f9713a391c3a7f40be9a921b4a97c64c6be90fe718481583a03b25a361f6cb174fa8387f6d8ba2bc112d868e62752f8602700eb54f84cd89a5303cf2cf62193888491c66c50a0aca3e38fc51d8fbbc6dfa0b72990a23dd3106aec2adc7378b923c642a69b16895a1e6e3415936b96f790fc5edac16699b31996d9384235ffa3d89488f645d590b1e8331d25bd01d96cfa3a91d5b334f00d7a4a01d98a25ab1ec8d442d9a17b34f105dafbc275a9727011b2227c5c5ef6c730ddb49388a982c3e982e4611b7b738c3ac69eacdc9ee10145474d689657f9bbcf13485aaa97c2403d24a9bb4a08d32afe6d597844cfb10cd9ee60781747bcbd103a30579461c0b5167e263eb7506cf9f27c5cb8947e11a38f88954b5ee7611fd3e6f5ca62cdb8b759d57f47197b82f2b54d9fe37278673fbe89091bfd0cc2e7e0fb55dabb4654078223273070f1fcf9dc9c8634505498e952c133b6f24578467ccabd5f2cfb923c9aed73e6367ac284f202c323ea5f3b6f36d67647bed19a5592f5392fb273c153d220088d88fa6c3be8a97664dbeeea26c788894921d68d23f3e4fbb70bc4dc4b08fd21cf2337e60851c785eba2de1a57eff915ab690aa54ff037330d130bac7dc6f80c64177d5ebec7ddf90216eff9e05de036566b8bd001718d58d5f72d203dfb1ad84b892419db65e41a2565e61362e11bd6c9eeb8e9ae38a482c7b7ec5c425161236ff649450021857b8395d571ecbdcd8e6607e03e28d36e2552ab4ea7f90e074a3f51504a63c9e293ae5f5845a3fde81e4d11fb7d574fab6a9b0a7c3ee97f56dac5f5e7e214b6fb4e0d088988faec053e9788ec7f46aa6142060384dd60aff55174f785ca13c37969d5c2e5ea1019a615024b18fafce08cd8c7bb4da0eb7e85473fc73c62419e3e894b9c42878288db906a821c871737dc8161683ac66b7e7edcb1712f384af58dbdaba64f4a6e52bd0ea4593e7c6a9fc6aa9f1184379d98dc9fef797e3f9ab858d0c0434ac394e53a139eb9ad696066feb6783253cf9beff0f1ad6e909f4f53b295b2972dfc572b8b5647d019640db5df0e166c8c40f5d879e329cb2603d87c5f977e53819143a094d0929ec4a0b835c02c964d43552f5988db6f59c794eb7ee308e2659a62f7c2737d462b1e74d6c1b2ff346aaf7a3391cedad2e3f7e3214e14c83a6ca7feea1e96232243cb9f054a6bb5d436c6ce465e6e1f9ab0acb9c85ada62487db08f38dee1d18a3e6a4dea691cbb5dd17e9e36eec4a52259633696d2c6a6639e1deff8d8c55f2e975bb529f234d777c4d7abe859bd3e497277fd12aa70730d0a9970b198de5de64c53eebe666f9c605e95e348fa82ccba8de3bd393a66e53a568afc1dfcc5f5d80ab23ecd298e5b5159000404da3310c375d6f83905d8ca00f7a747ff59b53723769bc3ae8449cc993674d978254fbb983310ab1f69f6c22d1464d32ccdfeacc8415d191a92f9e05354541f6b6e5bb0a3f719e59bb6448e407be9617a73b59e2697279afa3d988794ad22b176fa8b0b920a9ff3e429e2eef9a1fca9b351285a9108fd1c8ca3726ef443b21e7fa9a84f21fd5528ed968a142dd65ccf91caad29a2294bb6cb16ba0b751c7be79276287a28c7d5ee403a53b0c64a28a1878b9e17ca2c884a0d89e3f92b68c17de03f446a016191523e2f85c5868e96e883d5248523013dde00c761a8050fbbafff748a3ad14fb10573731ae55178e15cc3458c90f733d6689c7ff0fe618b29932879450cc3f33a467c077b99954c42abb3d15ba4532a4be9ccfa07c52d3a541a502fd3b3e3fe07554c45ca9efa6b99ea4588d7a6603bff4af094a8f828356a85cacfaa4c4d3d3b14a911300a9b3e8a24934a70e426dd6fe6ae13d3a51ffc43530602e38626a4a93899cf2c2a6db9b7c7a319934833ec39e8a9fd36f668e42dc550b786564541da7abbefa7fddf10ad07ce917a4b97628dc24ef0d74539c401c3530e9e9128292e8314599438f4a71a418ed8bdb6046ea6f5536c194ceaf02b81646d3c70b29b426be34201e16f3bf781b739b04d07b9758b0800e710ef7863849338208bd42f71cf7807d6f814bb50512b1cc3d507e59e3c084e237cccecff4db1496443cd4a63754ba1d99a9627f68d2d39e079c9212d9490c5c6b5378d9ab2616570f640fc6e859c4f9d7a1cb6273211223b6675eead1c516cb74a4b531611bc785af5a8ce5d6537db0fd555243649029e227aeb988c371e8a810e4af357ebcb42db206fcd12ca10ea02a8d6607bf02936b4af9d0de9ab97e264046c75b11e327a1a91ee4d50ea09626ef9ed4827e3ace6f4c68af9f40d6028d3fea4f781c7f392f35bf56038088b54ba64f1648103eb1bf2c599cc912c0de7053f32ef30656ae5b8d6f3caf95095cbd7cb7236072718d685c41bdc9187146860a8a6725a69b3c57970e04a240b435c962060bdedd159526aaffd5ac1997c2d703c0361a8dfd0cb815e3de3e4da4cd196f8cbe7c4f189cb6d83cf2ade50bb42e0a96e0d3c5f782b03fdaa1b890313913be6724b6602d8fbfd33ddaba2a29a433350211ef912873c48c921968512822113c9f8c7281e624631bcf530053c969ea3c7b60c598cb07eee127a683fc61e1368def0a768f54303b56b8e704b33859ba37ad9d5513804801d5900abed4e06f3f48dad85b2031077d8b1fe347d1d31dfa29284f6db7f92995949367b56374804448cf760fa0d23cc25bfd73126d7d4b52c69c21bfaa9d3a5f2f2ec7bdb3efa09ab5f87a54ec8c5d2d76ac270e1181ef243127c9c0da724b1c4bfba74f6eef62093c1443cf1f13a0984844ca8a804cf05521f5b26ab3664f00119a4cb6f95de1f21bb460dc64ef3fc3e098d6d7b4b9719aae2f0e8f32f62d12a4b2d27025fba74a66a62b16c947846b5f801d583729a8f9e207517f30036c01f667972ddbb1afd4638f6473b04d29d006e532c39ba80ef7edbc88d2a655049b6d347bf7f6268fcb5f45e30233db57c7a6902136881ffbff0689ced98795aeaf21dade6aa505dc9202132aeb207c3f6130bef310be0c301ce7a20cc12f3174abe7a07202fa7e172c47633e22820a58494db173fddc286530ad8b82d99d3c7ba2439f07c2daf11837a31f5753ce39a6f616dc894217734bb8d3a8423dd1561d2e0e307eb1fbe5030077028cc8ce9809c7a1e8ef79a62571f7edf7a8f83f423979c1dd1b3d54de2a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
