<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d87f8a953845462204923e1cef3731481754cd1d75667368f1bda20219f2ee3be81fbb123a90a6e5420b91eff8705ab42996dc6782ffe76772dc123a0b68d4341cf9c48b34a6acc234b918358a6ca8040c53e5b5edafc4ded730932d27f2535e8d7e7414ee8fb344c0597e3ed14ed015053fa3b06d9ead770e3106d4fb722e03294e13899bb1f9ff85811b4cd47043af8387db339238e415ad30cd70b4c7a7274a588f0134390dc9d649d847e822329d5ccc18d53a769fa5182ffda0d6d4a72e2d160ee31b97339766ac697574a41e6d5f396d596ef7d6c182f8cbce5518259b00bac3f7ee67367d275971ca6d903e96bbada00106e90cb7d323ac07ad473faa575fd096cfb8996505a0d0adcddf023553f26658901341b751ab8807761c311190c1957e550c332ddc976e1c7f53d77a377887c667b563f5c627b2ea0d4ea10e033ed208d9761d094842d9eb4f24036039789ecf69c19e31d6d46a613f0bd322d88b6642ccdae154069beb451b32bd8fe721aaf99c78f68ac8622f0d9e8b329281d091272ec8f6a46791452c2b9fbf27e8bdb1b332e77d21841d9379e8556bd5418ec4e1b10ee819d53a36d530e07824a87cf99a3686e037bcc617a9fa8837a189b882eb0b937e40d3c5738e7aa6c03c62ac4adbf7bbcccec52b137e0388d39042b1d617af75c5a79fd083ca50db28d2a33ffbfec8908e0783fd97cd5709edf4350486591f6361b6d906336a28b2289283d62af4953ad5fe873ce1abb61269fc5eca2e495871e58febb40af600d22ceda0bf21e81172f3f506033dff220cbd4913c92bd8ce0bf03f05884a20825d033e829377c7c98127a8281328935b437b672d6c477e37ff61e8978038aa7145b0034874c26c5935c99db914210e505cf5f2a2c04c4629e5b84c45f6ff83b557ec626abab7d124eb68387d23fbca26bfdc58c7c22bd44b53ce58a7a9e2078968d496af414a9f667ba5efba1f9ccb205006b5609ccda2695ca56206904cdfd1c898121d804658db30fce62a9ae01b750922c9f0aa94e330aaad7fb73125b866a39c419cc93b0f9f0e6936411737c8b54b26c0bfe44acced743e08fd9476a5333ea1430aecc309ad1db84c03b057a5035445d29328c084c8e45ab305bf79257d952f9dc7e89175a420615c772ce67db438108bb1768d91b8558209b6848b58b4e0c131de0489f40c099f97d4cf7b06d9c1b452c288dd3171cd54ed0e28854921dc1816e44029821ef2eb4b473da0f8f38351e493ebdfc9ef1bf9a17bf597f9fe6f2c468b79f37fba1ebc35438afd8d2d87059d0ad7707b6694e108882a5f89c79847269ce5879c6d542a60c0faaa39635c0e1fd5496636de9bf0072b18d347683f9281f49bd358209f583c7378f0754021b6f70535d9244f4877a8485ba85895a049c8462cb50155e72974038cd8f731bf1f53d0c787f3c1ce8ebdd7a0690569cdf1d8cc4530d761c5e238988a4094eb42e14d0f336b3bbd4f99ac83cb338953b9bc20882dcfaded188dc3fa53818ed8f2a7f87ec2de4cb37baa42535f43154fae091a27dce9fe276d100fbd4437e40749f5b3ace61040b74e5a45d6fbee73a721a5efb19c3e0ce208d5b8138f15ddd12448563bc595bfc61ea4568f133826870fb9b45b217ab03b7eeb5890fbb755e76946006f2edbd6bed4c96c0f09b67459bba03b4a3eb8c3d026b69a8ef13126b2cb784f37b1daec730ebfd0573010d53ccb11bddaff4fe82c141f9ed83886401f2d2741f8650b49acd72eba8ddb0d61e2bf1dd1541d383a6b06adab6b6bcdb298d5e758d63d365ea92738ce17c099801d4be76da12d86774c6ef4044b0819eb2c9d59ac46a3199b41628e6c9de42f851cd7a3c0da8c1e168c7e924b2e0903a7d489d5caa91c5679a33e03f8096c7b0ae9b923175a11b3374ea399308c48642775330448cf015c4dbb3bbd3ade8b47ce7e7cc0c2a60dbf0756347c34093d614b04c35e16328a5107d2b01442584d9e388fbd1fc800258d9b6de67b34e650fc49276cbfe86c7c7c98a4c64307fc2bb2783aa897eceabd211e504bb72a920a96f78b479a2d20f9d87de064dd78e5e855e722f8d7f2076a5dfa7258d1c38aae7769fdb1fca181959bb88f661a8d706b3b41bf9d1c3782e0292c79f0ee2193d2d6bd515a588ef7e6656bd604493703753d7363cc4af6023b0aa23a954b2d6ce55e6759eae2e0b3c3f18a0251beed1f20ecbbc2dcf2ddfe27180e8467dbe3acfa27bce3d6171bf57e86928f5f3798718623d7243cff51602e3a7eadfa40f03d7e1aa67c13d87d566eace17655333547fa92179903f081a4e04d8b7576d8c35df72e38781c30977d27c0c9bacb8b74a58a4f63ba5c118ca8b39a498307f8e449ecad87be6206a1406a3ff0bc086943c42ef72f08a9130c2fc499c8624755de441b04b957edbbc05d0724fd977ab40656cc719eb45ce7c81498ffba3b0273df710b3e3621e10595896f7d681d11c987ed940b7a50ef63cf6b1eccc890c1e337056f6f6c8c4b669de3bd23357297d84225c6bd6f90874c18cd5d8e4b807a05135405d96cc4b26c9cd183f3996b32873fc53c1e169c7756fba847616af950b844846d640c7dbb8a174bcd141395605ac7d90b896941a976c359a495f10749deed30f223cc114a273c96c806ef01278c59c4ac6012c86464767153b91ce770d2791e0d3aec7bc2e2ccf8b92471e66bc1071efbde1f4c71d057c6b5d453ba12af8a93c0001516916080e66362f2ae6a4ade6dd81df800b5ec905d1e76fba8d231b0bd9a24d4475fe03812b7d218d3d24e5c58f7804a523d5dfea5bfa514d9958784d5e0b9e6944ae5103a174e5ab033dc01555862a644dfbbfabf0621db38ff136554adfd261496fde4a779058394407dc265c59086a3647afae78240e235f116a74c33bab07b2ce9f82635d917056077b56b6b34fea1524f078ab52295aff660097f8adfcfeb4da9c08d0777b6d3a1b19b83b0e7220baef57f06173c216e62231da38c8551084fe20022786e0bf572d4f85890561a51ad355690a1c340793f2f5783d997c82849a2874285f73473726eddc90c8a1edb493fedebfdb82f8c478b4502d0c6ca74bf2591e3ed0d80bc7c2dd63ca55fc34ee9b9cd886e18cb998a34861c3011874d80e9a2cf0b87b0b5a7ac4db58306ec603d61e1d3e9cb387dfc189604517a3f9f64debd28bdd718d4aa42cacae2e6a8dc2763cbff7d02abf6a29c79a5e0129fcc87e3da7a31fc85c8c0fd3c41063bec47d0a281fcd6b38c574d22364f1baebcaeacc2641d94abb5a66238e401b5d0db95ab3d88471d7d6a2100fea54ce3346057eadfe3221ad54c09aa148312c05f278a264f4da986ca848e6edf7a9cb88228d6d48fe79e60b4ae44605691aaa65df01f024155962c87d0624861e36d0470a36bfe5a915e29f0e4970901047d420e345561153f8c0fe73910f857f6947b4a31e69f31cbd94890b1a8e9256c1af437689f07d400487f165b2b8c535ac20287cd9dbd1323575e6698b0e5e2f7f6e4068d7ef3c116d7e8cc7e812bdecf4f81dc187fa55bc1e00949d173f88d96690e0e7779719b7f54aab86fe34bc88ea6c44aa7291b0778393bc2527eb56156f02ced0e7fc43b8c7744e5f7a97466746872f8f59ddc15b6fc2f8ae860b8d430eebb083227c1a29c6eee0037e7ec66b02e6379df22dac60252411b25b8ab8e05939f42ab1351c214a7ed7a041e5051997dbe3373e30cc3c864d69621c67a6deb1bb85f56d2476e65c2ecdcef6eb6f94ad216027b0736921eec4352440aaeb5a107196fdbe3750ee6efb7bf3cebc127d03bd1ed9a020a5e50b91e0f0e6074e94d912e25687aa0320c22f48fd06fc4cc60acd82705b588c750395a277bd1c57ec7118bcd26964f78b32bb73e7fb46e441566dfec17cf6160d1cd820b04602c85ab4b0e94582964cbd8b681e9ab82de3ab133a32258bb74182b5ce2e9e226f7c9aef0c992903ca9533d75a9fc1d058768bfec555e9712e48a8d34a6785fc5f24a0768adc2051122bf6989db8fa4e18005fb8b33facae517293e3b4fc23b0b72e1a23ed8ba253c0ef7a969d13a53985705b3d3ea7d09b20979894f43cc9f80c7ebe1cd0f799b6c9a2a71d83f0d288f285dfb6ca7ed01dd0d17e5441c00293f4452745889ded2bdaad921debf9a5040d23fa07ebb39e0422af1c58545425e8ca9cf6cffb806376b8055e81c27fa6671f909fccd8d9b2fbea9f4a53d574087ebb555e1a22c3590475e2420913814972dc3f5449c1116274cf51c103b8c303499381e14ae1400e1174dca5b4dedb7208ff46d7e87d0fa1bf231bd7171b1196fa97a186a7743c238662deaa6de8ea2eb6ba0163d74d785ee5320fb5fb27b16b63415513783f3b87ec70b3ad4ae74946acc269d0780c655d70c7a7173b460fb05c6141c2d1720d0ca3f755b46ec39ed33d28c566cd6ea3cedd9e6f184a759746912ad93746e333d00e4e51cabacc858e4b5e3a3ffbdd3491eb103615cfcb1c7d36600d7d11d4ad5bb5b9a0bdc96053298ffe2b4a98eb03b735f0d7bf4df9d082925b28f06025722459b9ce461b999c62e62a0f918e0abf93b07ca9dcaa6aa4cd74442965f0984aa0f537cb2b604e10f0b61dfd042ca8580cc686e3b13c2f787aa2728223fc093d5bb2f148e228bb89b555b9d4ce1e5b483fa3ca9fea7330806c47cc9b0d354a37a4b9043618d351cae985880c29a0a7014291082bdd3a5e857652e07984fb0edc147c3a821f204736547c80571a1f1c6a95770164baf4decec071bfac91234fce4d8c9846f7308b1ff60a3f0c0d057f0959bd9e978c725b804b386ea5007ae7838dcbb23335c18e79c5f1e43a6bf411fed4178c40e9691e399e9d812d342dcf840961e94f77e95b38118051a61fd2699ae0ab8e175a0148d0620682fb9ee44b3695f942718007175cf057379df8837bff16ff1439cd6cf8c29781908876b93c19b76ed3f91fceede6edcebafaa989588a4bc390d07e3b1c92ed6b010c92cda828602ba6afd76fd30bbb26c093e1c2dd5d69f1e8c33bedf6cdeb05d05edb60c5552ec9a748c17dfdb4fc36e961899671168718741ca25cbe06a37c8fb6131675e371c9c2d097bd1b6543ceb30e5108c81861a68a54d997390acb568b53006aed60fa3c0e8cce7d41a05659673dce03fe73f90c7e7bf07284a6fde7665bf036f056565994a4902b045d7c4a37c479d9cd98e4e012b94f9fb061030adbe46b0567eaae62f1adaa179950c7eca8d0dcb9be9983dccb7c3fabb597f1fc4e785aa28e34643c3f9978de6b83a9d844fe6997c0398c52b2383e119ea5f1bc040c8006c29fbad85e7276c72aa8c92e96abcb9334b7ca99298febb855ddec294093969505c3b0a5cd8174d116157ced70e64e424f5b8570f9eb4aa0120ac477b0b05e1ce8f136dbd5586dedf4e314b028cf8bfea434399e523ebd9d873aa433bc11d44f5102c100cc90a970039a3632328b610483f471f466295a2066113a36b102d0152aaffa1e89de40adc7bc9fe9252f4a5ab322e37c1f781cc1794d710f6c3012404e16dce8db8a2f5ba86bdb4045906eeaa952b8e5fefcc74d4b10ae53fb53535d1e00fb2b46bec76368686558b2aeb6c56e92263cfbc62b3b88c5b2de581fabebef7ea81efb3d73633f5f2fdf9e8e00233203d63dcdaf15afa510b1043da2653f56c4621f756ec305ffc996343c5557d843f04e5bb8d7974fe5dbb5e619bcc872008e96def73288e4de9a48fd0d3ecde9fc8fa4c110d85d60a23a9a6896738f009583f168bc89c4546399af306ed04221ba157ce7ccc525440d723e178eee02a4ccc1519e0f3d375a1fa0656f3953ceb8b7fe64f40091eddaa539b737eb6f77f7036320505ab7d6c23cd34c1a2e024534c8a93a1f8c39b9d26b3e0b897cc33715119853d7ec5a932f5a46fa931fefb4c03c987312f12e41fd683c548453a058a31a8eceb2bb0d96d5a62f8e48485ac2758ff7500dbc563ae7c679b4b6d6eadb24978109a94e48b027f877206c3a293e4ab4953eb8e2433010b4f781f9b4489e60c4e72ac78bac3821a57a4ddff7639eda9b88f3fa248971d8baa84df5037db408ccc3f77c1473d7758983dc47575f470a9646d21a246b20f96dd6083fd8d34b22b1fae5ffde33623c66d006f82add728d3289207fd6e49f41530926cdcf46d7777d89d2fd9ebafa5f76d62c6b79ac64c63c7c4afe36ec0e632e9ed5e1b7484a751ab85c42ea3c657f8b8acb00488b57c7ed52bb8ab772893c1d84613f058ee2e0df751e5ab95d45fbe351cc56dfd88bc3de8b366936a5656db0ba4b2878e4f80da01e1e5d0271703e5c807aa7620326677b012b65dff958d2ffba81ea2605786f1018eabb66d7a29667cd7cf3fb35bdb9bbcec302c29334ceee3e5ba8dc11e9e95970e3c493215160098fdd4808dae097ee2c3ffd234bc84f97bb9679e97680ba8ffd0a7d58cb559a5f9ff7017f3fe09085999cd6b54627a0e5ddf22504ee6c072b0b5cc3633088f319b99c36101e270facc53186f13acfc2b74564956239f5c83e69dae1ac609d2b40aa82a081cfd62fcc9758ab9f7d2656eff179a090710c1ee83127367cdcb4c9266f6db8b3ddb6c68db0e71b36858ab9c098df401df3649dba7890d14f6c457786bdff604f8b846bb23919b8058c0ded858b9a7a9a5a9ac6e92b6df4e175d1a1036e74a21747edce589132193be17fa855704d883865522f0260302443509a4a33a4cca3e2a753a22a4ff19e96f6b258f1e354aede96401eaba58cab518a014df8a3d2926a9b9f4765872afd2cdacf275e761ff715bb70e19139eb4847b480667b01a8ba0676324d2e9a7f1de0f0aa5f940994f9e125ea4e25c8df3c9bb0925d94051621ea652c90263af0f053cf49fc5ae995f218a60501eef61609375778c3b40b6fb702e709418093bc19e7d26e562e82477b2cdaa3578c6697f108cbfb4aa25f02c86090992cc7de4575f23a434158d220d4bcdee3ef239e616e5dacb03ea5fd603cb96310c835bb87a91f2d21a5339bf9cdd39030e2d1767014ed5c092f44a7ad7817cb05d6b9265fb010d8c434fd60b388eeb090a495ef2a26bd109d8c417fac77c811fe97dda7af5a9f62df0a02220f3278dfb5298cab31ab42dd74459b2d7a803c1c0b7909e3b534050ff9c441f0bd8089b03b8ac0de3e10d8996af7da19f856f45fe16f749aa5da647dd5b7be3b926dcdc146423ab3cd622892190d4eb05cfbdb5f444cd7fdabaa4a411645dcf2aed6eee3e924a893241e6a9afc4fc8ee5972ef6f928fe50f1e9234d16683bba7e4ea4da9939161400ba4bcfd6ec5850d04305651e062c5c8384884cd6eb4fd904c82e0b4d62503dc8b2965e599809113b9219d765c98c8fb98c0786e610782c8b25ad293285ead55ca8bd45036a609b5e4ac39c9da3cb2db33652931c181f741ec857b3d275b37d0618d304f8a350a6cf8fadb93b6ffa8172458ed9d8281fdcfdc5ff836d6dc599d4360de09bfa432687bda61301653c961bd536648ba7d8dd54727af5f27119649220fb8dbed0d72d01323b74701354b41609a60c0b988a58f2ad87ae84912db6f1f10247a89a73e29f5e64950aab6bce9847dfd700dc3bcc37b18333037846d1083034456dd1cd1401190a8041d63b984054a1f6c17df5cf331f71bd8ce49f25c3bedcee64647231d6bc7eb632b89629ab6934cc9557fa4b474626a4521f36557966109fa2517a5d2d8d35dca90985f9e4ea1658b19f123b8c8ea4b2254f0536f7fe84a7cdcb4f0882eaac240619c3e95ce2db183d146d465b7a1a46f729980c6e9d0c9fb6e8bccbeeb3992c8428e456f92213288dfcd87ef688fbd399010c8f96970f144863220bcbcd4baa23ac3e901e17c78fb0a09a0c91d6d779310add0f139cebc27efe7ed776103ce71b0728349424b1a9f8953dcf9cd305e104697fe2613b43839f9018340bd4e1573194f07e1dbb9cddbc3065cc0cbdd762daf730418d4c5bd094bafdf36583815723ed325b99692e808771fd2dba98f4ed00b648de3a9ed4ceadd7797ca03f174ddeb45407948b2cf35fb7ca754d3692ae2963b7b9b1dca8bcd0d5bcc727f921f793fc60d77e26fdae95e42c4fd8de6b99b16f2390fcaffc531e63ac5e3dbcfa7b50e29a404d17e35b1cb1b8cb28a398a8f18cb9f0c637aad5d9abbf505f9b26ae373fd259e28beaef3635e2097f03049b677ea78ee6e9cd401a7363c7800dc2b1230c6712e7fdffbcba982d12117ab13ddd165c70d884bab157cf20583a1d2f532af4b04c3b3d695fd4c9b94dbfe0a3e61caaf39cba4b6185c73c07617dd866ad19e058bde7671913b5968a91ae5cc5f597dfeff7ff6cfe61d910cb78d538aca9bd8e947f67ccc325631c20e6a24921a05894665c774be6464ad5c6db4cb6a9e2ea32e2c6acee370660911d5123fb31d23dcb2a0dfb3b7356c6279a91d5375dc8bda998892dac943f274998bc703685b7d9ca3b4b1d76756ce41138de6ad95d0f66bfbdb31a00c0abeb36b5dec03f7e2138e9611dc39e5d4a0f235060fd0f147cb7c8962b1eac516ce9856f88a825616604cc4cf72a88c47fdb314bf5bed7ec31f38fe5ba1d592e8c8c01eda10bbd338ec954c8e28a8a862a6ebdf78910c6e5e5e089ac8236167b5a5c0ef333a0cf6f78b5ffa3e0e24fc30e845cd3d6af437aba12901a3a26e6fbb9613441e5a2c33b100e16561e5899e6e2646e9804a9c5738e464413cc82303017ea7c8743fd5a5b3feca86c7c81bdf60104872305b9b8db48c11c17afc86759a1f628c84a6324962f16a745570764d655a0ed6e92be0b1965d39683d9c799880aaf9e770054a159c9073c049432de995868f9b7f3523f165a44b3e6f3cd8310508065aa7bb49e54aab33553b6a99837d458b7d6e5e8749fbc5426f05625930a7171b14c6f4ffa4a383b40c82be54a2d5e3cc3dfa12bc566a88afe4a2c4ed1f3c72a1356a65005b0e46918b00e4682fadad0d6fc40e5478b73b4fa8304e2f5781b152b0d71ef1bddf08a28e84638e37cf33c7b8d84a4ec83b3dab5b3f676cb997be8d0c7f989c4db2f2a1ddedb872f0cb9f9090a96182dcab9f6b213f3a444414940b899dca974602a4c6996f1f8af352d978fc4d4b84bd664b9cb3bf4becce3dda4575a5a268579c5aed7aabc507122821ac036b24932d3cbe832bcda274d3bd77d4f08bc46ba7ab6704da7fc74c07d99aeb52af2f0f1bca0b1f8cc09ad3699a91489c9fa95da88f55cc439cc35994de22d1146e3b925ac5c171dbee6ab5834834f08d8bf6c67dc170e1e51c74518de7aa13b273874a4bfa3fba31c4762af26d1d3ea6ea8d588627d912934537d5e7764e3081208589bdb2ef1deca4eb91a038f21ebe44cf168fcc0763cf7549de176648dfc46e8d2a20934d8b4b52708d2e9a58560bf6936bc343f5bd12d7ebbe268604c3f2d70fdb28ece48666b5e29e0d1cb51dddccb24cb76ac6717d1db6df3dad0f7466bd996b3cb3e0a98e3b2444aa26f4c43e991ea390e37486e9180c5175dc996fa4bfe4d5c6a5995035f8e0f695197042fd6a4a987bfe34864b644d0d4807d4ae4a7556f0ca8eccef62a9aa0fd37f9bfb447c05558fe4282e4297ea4858c85541cc54213c56a635ad181c4eebc3ac63337b412caf612fdcd4a4800a7e236967482153cd2bd5385345752238d9da7921b63870ead970ff1dece804ab44f6125d066a0b221aaa9fd8f9e9ff43cfd5d881df78760d1295c18a0779fd878810437c9a3d179732e26651d277366ff4d611bafcbcc1e665edd9ee74fa36376d070841a0a1c012458a1a9b2c537287e4284a9615b7b593335a2e1471fd1b5616b80e318e79189d838d36a91165357c97942689d7dfa5acdb593e533d84687346af5bebd672da17df7110a5c0a6556918fd934a6d5a96f4fcc7703a6340967ed2fdcc08c308416fc276c4e5a4aed0d4282818a65695354e6d68ad6f5fff3df1e0da4911bbfdf2ebf9f77af0bc8c8b86820b69c4839e3115b769461a2b4cc75472500992fac109904487782c5d73a54c3974f7cc69af6b993afaeef15275228101da340df3144f9893130065448d27dcb459decf6c2c9d46bf45a7617590eb4760b7b8a291c304cde3fc1537d5340d92230dfb6b5d386fb596f2d389c5381ec7b96ae5c5db107a572ff8dd3b6ce69b9db58c1e0b68d55b8aeec1017d10378f0ae4fc72e84eaa945c5c53be24093ef9f9997f02b4f2368eec417d08b35caf13b5d21e9b7f3e14c620be7a93caaddf8433e39dd191ea2ab99bd9b9f1f6550d38f2da5a3245c9be02517870a7961002fcf0df1f356225ced45ebcece54848acf73d02a826a49257d4d2c49b1be4b2e716b6f7b0eaecffc3e78500e85a7b8f862e0218f6c9ea4d63d8c9423cd5afba7ae4f76966f1471b54f7963882d08fe4c7e7bf0dbdd16c36a5ff57b2a2c1138d6a9d517f84fe13cffbd3bca4fc0aaae513175949b84fa67fd33e4f3dad86267bfa478c1938f8dca6c00272608d7b1c04c6c682b7c96e5399ceaca0b1fe3bd122afe9529b11399ff24c3da9232191b836e15057f225ba3456029497c73554ce36877923ef6ea28e4044213b52efec9a4ba628de88118bdb5f861bc456d88e3fc99790418cc082f42c8f186918d0abdbd59c500064191149dda59543a085016778a685e2f7ba38ba3e96e9dad3f09875dac12be216103c166f0768f24de9ff7053f38d3358b2350ec6f388bff13a3b0a67d3e3a6ddfeeade6af81bd922675ea48698af78836e3a16277192d8cd974fbb3e970e4473e6233c1736c54f9f0d3b62abda411681db2cfce3f09816e6b51fec067fabd52d9b699ac50c29ce94e1d6eb02fef36eaa7529c466612efc01781fb2d39b171d1890a3b0a06812367d0a2b87ba84fdecea742ace51e7fb124531e389b41ffd6c6a021571715ff868f649c450684f943d65cda6fca6d3e290b02afeb9495d3acd1aa9345cc278803d039e158ca236e9bbce70687c1c9e81bee8a7bec88cce370c2b514bbd115405139e90d6052622a10345c0183d6a5e8751f1fdb982008db2f55769a9ba745d504adcb8a802181b2c3ca57a7f84d0c8da95066a74c3b2648a6bdea6f8f12cbef738b0b36f1e0ea232761be73389c93f17491ec94fe3a1d79d276502b3fc290a89b135f0351f7ffe395317320bb4dce192b514a3ba257dd00d74564d16c415baf2e6ed7d7f849b2790f1258bae33175151088c5bb272c456f7c6123aab44099b91a39d2e0e58d5fead641d5aa8dcda818ad7df02e9aa16523edba5cb1d4153cb6e6034d03effe29f28e8194d4396cd59e9aad507ed8d390b68cb22b43a10d229a1a1eeb768180e5d5239b4504aa97e891db9798cba78cc523380d33b35fb0620971aabbb32ca598a34c886eb52313df6c903bdd1601a7947d838d628e33a8ab90d0fd63446a2a435fe6471547c901b1a8b80c9fd3409e6088e924a8f9b39cb405f4459a238c998278331238f432ae91bfb4e5be7f1e1c0fa18c79f38d3b52dde5b1d576be803b65391b9cb250a852e77671385bbf8df97f0ccff4bb5d1a9a09440b9232408ed50d800570f5577afda825b405ec94d1bb42d71eed0ac77fcc84a8745e0248a19ec0ab02c1175dbde7c7e27ab6ea05a6988725bb1a063c851dafa02a7b50627053a3850e8e1e5c286a8dd454d9c068595e2a69603bdfd4709762d53dfa7301fad9e2809654352e660f6180f0aac7947c0a9d07bf8e859cc83e9ba2450aedb5293b6ffda9829d21b446f75cb41a042bd78702502e918286eb35c72f681c43455a6ad6104aa5a72c2d44aeff59a958fb2f822a73ee43d66e81eba7dfd1d057725fb99c5cf2e98751add8cdd590bd20d992d722f86f965dae1f1761fe7258d56ff3330282c7456bd857f5145bc86432b98426cad86782fbe45a1903ece26886e128d3dea4c48625d93f7cd083b37f9a20ff31cb697d47a43ed71441089fb0616b2e054c9082dbafaa2dd9b76198d42ac07d60e8b6b1ca36664abcc8ee733975dadf8dd53afdf7d96a73536535a2e269bbaba4420eaedc6a0606dbbc411e6421af813ade6aa86df29a68fae12a5049c73ecdd869a209b0085b3d508f991678d74a4056fb9740c982bb28aa018793d659c06998de13141638c9b7201150b5e4c04091207b1a21834e829bae74d7ac7e5e348f8a4f2e16c988c2c09f9155953e46bbf2f8f63f618dca89b17f06fb65e72caf483e83e82921740a4db7296893a656cafe6a6a3a0f70f6d4841fa4b1f9ba3fa7d7b21a5049ec5f8d324eabbdcf9d312b8cd1ae554d883e7516cf3f6a038aad65a87821daa167b38a95e0b0b30d3806eab1a7abd8c12d221d77efc5538adcf879b8132534aff66328387655e11877306c4b35089b2fb47b656278dc1e3bace4645a5f1cc79536c4770396bd88f9c58d78a2de2add2f5e8d1812417cd6f5aeae8599a615388c0e2ce4ecf4a5a5e7c60bcfc873285a6998ffbc6aa723886b9675f08bbfdb87ed69cea304106edb7472e64f3583055d10ffe557e00884177651cec9407a20cc721c3349037ac4cf9d47661f353470cfb9f639271e49607942b93e706b66f2dcaa69dd0b42495680e45b2864943f75f1b006a4b27ad81caef0f7c38aaae400316f47569629511ea410aba9831a9ec189b329865b408aae51d79ce3a085656a41932d150613406240aef7b3b40f55df5d648b13e8207c26464d18ad48483e1ae182a2b1330ff6b902557303c0f014c9613a0da65d2edc203c88bd8fde08d03a26773b5a60086d38c4e1da98d77c87112d08146589fdfc2894d3d591e3e2f599b1d6dc9c1d934e71667247be8a4c3d4cc83cb7738c497fff1bdcac99f65fec2e6305fe61352923fdbb7ede71bc01decaa2111b9f9a351e83289d9139a9952e9d825e3b67047de343362432dcc82a46a45e63b8bf2ddc5612558e80aa3986697c6bd90748b60b4b5d536b1c3c0557b86b7a1c5c915a99171c6c717b726420088579a6785e4b4f0626f8ff0c966c309b658ed45c8f53b3d780e36a62c5ec64ae169daebb7bf66f34f515b90eb245998e1a228467a0c0e7abf442d9471a1426779336860e076529f4de28133a224f7db587048aea4c85c957cd8d7e2c8c4d6f431fb4aff4709dc4177adc90ba722c02109483aa4afcdf84c70dc653bf911d7e9fed51928632886b619c7f0ff44c02e6f71a0fdb05e620160a794f456a2ff7c97ff7074e6dd71a40b2e86612b53af28d51aeb65ac50871d71b977d784de7d8c5789867827b1b7d0c4b97b09788f1a1d9dbc55a903f49037e097da81f3f2a579962fcbb4e6e46744f49fd55ecd8e6676db423f5c5f38db14c4e43fbd37fa7bbc75de7a78127901255779e4bbf6d31eb9b5c80efccacb8ca9b1b325efb5176dbfe56149b27c859c0953c78b406d860cde0effb544a10e85586145c33f1ed0952e2d942a13d5e03e524796d05935f16c4fdb2897b8fae0dc4abfaee97a91e0bbdf514b6594a230a766e5a83136a59387e434a04353ed11531d01a8b5c008ce0c7d633360381b75405db18c555b982b6b5e0580c6c8ea18e1a4200b41e15923ced0dbadc87e41a3c48f1af2c710bfe3cf924c6b69a2ac025a4c33379f797408ac78b8885bc0e2021300bd7edee27613e4901b7d91754c977dbccfc820c8602f8271a870b08e02bd92fe49e2361f432bbf45320895a9b2d4c9c7fb26ee04742c3aec93daa487490ec1d0fff904b035aaa6516f369318cdcab83a3a6cc3c57fb355d2e7956f6c6079a33faefdf541bfaa44adbfa12e5adc7770a872b534be119f6ad17275f2c9e4b43fe77796127c4c121bfcae95eac5f55e206153936fe14876404cce0fb0aa74ccd97bf553f9430c37a10ec81e8a2bcd777761e43544c46e8d234a7be0fdf380fdedf14a3ad4d89a44b357c42ea07279b3dae43d349418b727f3ff08c4f502df4ee7414ecf3bdf5a6e057fb5075c1a97d1b5aadaf637f0eda253823f41b4589cc35c2d8ba075962378401b5da1f5c193cd4c24d6f8438ab64efec691698cf571d23896b3bc86cc0ba2642fcbeebfb75e0de66b01978aa52aaf6fd3fcf516042ea6b7a6881716919ba34098ecc75575c5dc5c7fb8fa043ec4d3f7b6ad6414f4ea2dfa0137fd7fd05d300ca96e6c87303ea851192cfc434ad144e918962b180a25104d7c4a816b819d59c66d2c4d555ddd3e2670166cead6a3f2c76e18472d722384c74cf255d4d366ce52618f3aef7bf08f4d3dfdef2f04b7ba3f7f2a6bc93841b8a417939c4fd4d65a4a4e5ebcd7dfbad8c9f19fe5e35fd41ad80cad7188a32ee44847c31515cb3bf827f538502ddb83122c39fbec649a0f37a34985b3a55a1f98ffb5a23eaa8dc456c120652652902d6fb88cdbd21aa091a1a1889c2808daaec10b2cdb736270ca85fd1e8c7c260858845098b06674e130bc90268c9c191642ef5cd078e191b60b00e584db6ccfabfb409d0542db5324f1dfb26c090f0c8fa0bda4a5bb24db97bb5b7ccf91c7e289cfdcd6ac782e124120ee19d82ea73b5a3322d1f3bd0fec9469f69868a73a75fdbaac3176512d35f5ade75b2ad7ae0908c699afec7a498f6a0542a5f5dc0b9eebc23f703a0bca0fc8b1c06bebea21d4f5760f14bf232427c1bf70edb23c79f9d3d713801762229a3e14016d83fd9923b04d45304b82579a45844f618b18ac3636610165a4cc5d5e4a0c6d9410f1728f60f6116558a5269eb0748c36111cf33c1c625da3ce1d9f58f6e847d17c7c6b4cc3f83979d5fc1e1127df8a46c48907c1c3720983b8ca9ee44c177f74d4eab4898b00ce5ba49a702beb913765f0cbbf369ec85587c478bfe20a74770ffb3ce4f8978dd671034bc3b50d4277c994bf6abe881524a63f9bd5aa80e2d1709241a34dced042a0e7bab164566477a271800d770175ef0f17a07a5112aa9035d7a838a8554c2fb1eedd516a538b5e97929f5824a44caabd0252eee98b4f4a50d9b3fe712058ab0187f77020a507a91a8cb361f9fbf147bf51953bf8612d66157fd553506a230d3ec5052c4fa555c88493782607f353203c97b8243b8bb8fa525f26f4f7cdc726a446bb58c8469fb55d2623ee487ba46afecc551f769f1e2cc685ae5b875b4f34f64abe8c449245e8554dc8f038d09a02d2d68c384e4e2efd7846edfd51b8afe341b0d158774e16a9595951b92c42b698e9985ddc531b68c3a91ed960c0bec9901b46e654aca8793d15c0062a00991a44fa0fc478926e73ab3b035f1a20571a602e22e787de40a2c02071bfc519b68e988fba9ed4ad61bd56fb55cfe24930732fa0a371f56f173b2dbc2b1ee8e5c26adefd6c08aca4cde2e61a15d94f7131df67aabf69ffd50d62db99af0595d5ca95c4b16406c5b5badf27c58b8d03b3b810d3e9562f54f7ef25b1337c8c208abc61fd39bda873cd9591e81ded92d940974e7aa96f667c80d5261014a3f35ed61f907dcd7da464bace1ad0af539399fdd8f538980acde64ec14d61c00acc97fa4b3d8984d88c092396d5fcc90d51eb3054e22d88075050642e908261f3a6b5f961e72f544e1e4cdb67dd253309e02a15111815f43e0a83c9c218fad12dd6e71a69a0cc3fdcf62c4860138674214f7de4789302489a7125335a4ce564d4f34c92bd996d3f7a5dddaab19d93d1e32517f90be04dedf4c00c7a460e8bdb2b115c744248772d94855bb7e7c2bc0c68f85f49dffc1a09441076e648db5650887b09ebba9511d1927060ae0f6f326f5c329b9e92563caea1d71d6940a021617ee0b6c28a6b4c7bd913c6dbed240eb0395b37e776c607edcf6d2a7e3e75c982340589f5bc2420faac379a03a3e0ae302f616490fef54863af6022aa84445e5ec00305c5e1be25aed8a374874b1d72c1fa076dac8d7f3c9c2e65eb0e77f7719cac894dba2fabc431b6133f968d06229fb25dae8c194ef9df04a567245742f6dc3e6251dd93d6dcaf05825a46bcb342570290b1116ad01f281bc8eb30a94ab79235e030deeb35d5181920c52e663d106e640da9394806ade5b201c2669cf0fcb1a0840ccfb932376f2aa37ab94207e074bb139e5d1731fa352db814bf1e5399e0d69010ad3447cf2017f2b6d2a543a467b361cdda33905131b83a350d5bab4eb472ce9d66fe408c1a5e6155de47d27a77a5421e79b99fea0c9c3faac7a70d91e62e9803f5e1e25eef8f1998a1c5b26094edf510bca500090699007eaae0744739b9182ed65764c1963b091025a8f4f29a4e0bae5fac3439fc5e9815c9eea8fe750db087e318139f471a0ce9551076aa0375bba59e50ea522e3d314c9c44e3d576fd8b9a52bc5014660f570e82c1d9fc970d427dd62ce4e576877bceac1f69ae622afeb8ae12d50c1b243acf369e3030cb2a532cd348e390cd659c3aca2fce8a5222b7de863dedf6a3934d4d5d4265c3de3ab7e472ea06d568bc0e6fb13f0930a9d65a5624ef091b22502d37f77528fba0d248c5d6a3b9c6b922bb2154a7020208b1fb84c0da0193f3b3fc53264006e98e1e57ba8b464d6f3d2af511ddaa24dc4513ebe4e1f900b2aff95c71d404d04312a4093b53513e3b815ebd54d97a060c36b7c05e3751110f006bb15111d047106b49f4b5fbc66297cb133ae59a65ed4c2fde7075c3927ba533ab45775c964d1a1fe711371ad96ae276d477b85306a40ecacb604375d97a1ef62803d1bce13fe47a7140a0c1b5831a158cafb440c4bab5e85993bd06426adff559a255e8e7b666eaa684096f8172fbe51034acd2d714f054467e645898c881133aee0832c1916bb5251f4e8b0a0cbe8acdb4002660acb2bdfc70efdd23272541a5f81d41158627ebad5eb1f2d3dccc24b3e057b99a925760864f4c142d4ce9dd24375e1206718287b5a44469f4bf7526f78b29c6b007d691124058f92a3fc7ac579220aae56cf17194fcd4605c010fec44762f4a8942db64794fb9ee2646fb12bfda338b2c38046948cba3938a5948f8fe0062d0a261e621ca9a9aaa9f294cb6766451f71473d523e6cbdaecef44297cce33edcec9dc95cfcda965e37f12c301b84162f770c257e9806d42982cf9e984e03b3b198bca1edb27b0af7b969fd087264add474614d1ea6d8f914becb2d590b1c0d0ed42d003023e2aa11821f55b9f92c9493b31493d042b8b5ca03a5d5581b39dcb7a255ad11fc5c0f9efe10e56a82cdfc6a0f68f37df8517ae67c6bc5fc5756289329475cd28d19c489a53378e846d4c1021d32f43452cbdd2ae20b859e8715188b102329a8803778bf53acbf28c34ed6aa0ccdefb818c0a240cd547a8341cf8db279b3260a2c53e7ff57782b514419d173ee2d62dc2e0bcdd55d5462fc014067f5d47119a2433059d732fa504e3af9309c9a49f8c168ef01a4222455ed22b9c00303db3e62e390074773c58df567a0c7169711bf17294133cb129b445546697ecd709479e5f33c51a761f3a2ad73d7d7fdd5fc91bdc4326c7aea21d01cccb00855646fee3b56b79ba61f944f9f201106d7307297a920fd800aabffc89a35cc993ae663dbb32ac271aa1dce0f6bc9a225fdd5c43e3aabc1a9561b3365677176d529be3411c16c39f3db2c2d10c73dbf748f7ab02904b51774d2bd7ab8ac372cf6dbc981cfde8761ebe7096f1b436e6f5d7f2c4a38f0218e6e9b00f36764b88d66db2d4089488a0268f843211290acc2c7a2c790962efce157ad094b8ceba8120c69d54fc7a5a3758dce84c26d5582d7a711f7f0d16cbc38d8e616a70bd1a6996265f687da3426551a712989eb678da91f3631330c13bb9af771aece34613ed14833cc39e43536e1724241f29a25a20a43576193e6bf7a8aabbab9038191f7396f51712cef7fdbf9861f527d222bd74fa61ec2a90b4abe53b01b4f2367d3d5d0d51cb05c92c123c2ad1930b26582eb5fde49ebc2f893cb2b1a0f84fd15e073fe99d190506c5aa0a2b510e3f334037a2a704b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
