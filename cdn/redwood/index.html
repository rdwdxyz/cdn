<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a028c38f5e5349c03a58fce542e17580cf57f7b0bbc9f14005b05fd6dc1538c4b3146340f8b84c312926c252f0179a55827dddb771d5cdee5f72c2e92697f276fba984c2a6a17faef324d5482775cea028ace229e145b7bc2995309aa55efd17e7a7770d4205de3de10524d3b49ddd7999325a63a9cb9922b2d82557b8b34bcf3de529516808043a495f54cc86f0788961cd3cf3ea3859ef19b3859124936d8821fc42f7453566695f250afaabebbd6e7cfe2daaab0121874fea68f4efa0f4279423d5e8e8ced57bd32b41851e70df9ace504a6f28103a2878f245bb66862a2db4f8fae96fe8a54cad09a2674f7f7a29379873264e1100e1c4a76c1cd40941ef09460166545751954c7ebfdd2644bb3806a5f4e08f066aa03baac685e33dc701c844be60f5b4a2e3567b4dec485e16ac6dc63f356d0e11fd03410e4ab0bd49b6a5a3a9b05692e00f67c234a80c2f52ac5057c4fc06105a987e8af06d7ffdd95ccd761d6051c23bec6d7d76bcf250e627405bba30c1bef6a72351282273966dc057bf13d5759df66407baa96207c03095ac90bc3342c3a245e3bb40f216875086f7a5003b24d7a04986c67e512cad5470297e5b703f4e38d8113ffc9a2821f7d233484a464a2f4f7e96a522a4a1fb550dd1a8ac2b2ac0a0d2a58abf5eade46829428836951d148f6fdf67337d7114d98da87d3485bc4d37e7908f943dfeb0c493f4facd8580be17ae78131c6fe6cb487004d3be4b30f4473e6327a053b1557d5fcdc94e7a700b000c77128e825a2105d350d9e53b7efb5199c4fb4464293bf10e9c747b81d64adbb01924ff7fb06ba7cbc77b480d44bc409fc5bc73372c2b77762bdd86338e311b91e2b0d7cd0f867ec12074ce2d4b079e19ef83e9ed7708eabedc28e46f56ac845afa973361b6318bdbfeb6a1d99abe3e524f9ab0d649a3f6c1222546a8556dfaf3ba39c44cc6a462b48311b7e0495988c268ddd13fb1f51c3c50c78a9f170e134dc4df7044a03f65f2c34651e356538a0d1eab97824aa94c3353b1855acd41ee14b6a309acf682f5bff23f6a98722309f96354f03d49392bd22451eea6e1761c2c8474791635f817871fd12cb4bf8de523a06cb347ae4d8803cdac06699ef00452743c0f9a6b04daf324bf21377c00d7644778a2dfb158809d7fde232e72c6bbb799389798193455b5bef6ad7e1768e4198c7720efd6573e902fb905ac20fc76eb622428be6560f6a220db6c25580d36de86667fd1c53f2f2473deeee483a3396da065ee8c9d6328ef9921c83e2dc3c1b1948ffd88608e3f23d9d72cbdf3b7921ef21e714f526b0f8a3e7c54ac842f00019c8fdfbc8c78757b56c60aa7535eacda96e0451bfe1e5250778e32f728e58903ce996fe89a0b582a0acd953f792b8c2b0dd8b350a2c4008bb7217ec1a7bcb0e2b941a2a83f8e1d40d91406bf0e61578fb63072fb105faacbe2deee783d8aa6540d5225f4e2a91cccd92c84789f68d24eb855f21ff4bc47b842a523290bdcb6a3f0d5e04bdf2583b35cafca010a932f99503b62f1b17180a30a5afa8fcd75384ecf1b52095a96a5328e9e41ac91e2cbbed11bea1285327aada0530ba971b251ccf70a085d92692a12dbf317321cd574ae6f50c1befba508a49aad05f2c7e221a9e5dc6c6901b91ed0fd452a20d1b54c66b5de8008a280e9e4c1d10e75d221f092fd25c917ec270ded5d5c6157852f29474085064f557293a5d5572fd0ef67ab46e4aca3246c3ec45ad07082eb9527bf02a9259e785cea0f38010fe0ad791dd80a738e2c32986e5865a96cd61865539ff95e4e955a22ec404c0f145357189a895ac6642f3cc58251d59bf8b46716dcd6494c53daed32a20f789743507a38015d9e3e380fa798e33da91274f7ec28b9a44073dab1021341c366ebc7e6256e127d5f5b1d09c65bb76052088dd5a87a257f9a2e5fc941e901a426d82ec82eb95d6218f749e09210999ba0adc38d359c14835a9236f1470299877f0e4faa2bec5b75984e36798f70cb4dc1dd10bec628d40e501d3dd0e26b0d9340ced9320bd0f486fba268c84d0642406fa73004269321d9b45141781fc7bb15bd2083a5bdbcb1d0396dce05ef13ad7275527c765c7a719b00d22c40bebe2fd1d64189777347f3ea751764f3b49a9eb008133d0ff0ce432f41cd5baed287f211c059b9844b46be4ff3b01eaf9c8994336e031a80bff1a389357fcf3ac84bcd947a29f985b4a9396e62422b391d6375734706cdbec68b6fd78b92b172f4ca87932d3f1690957e374331f48eaf47ac3061cb67fafc4a68fb031488f7ced928090f003195a376d2a4845970a216b12baadaa336a8849be4be2ad15318f28987c54b3a3001155c4f27daf3ec1caf65fb0facc7d224c372de7d129121f8cc643e82f708c3a484a05ee5bbcf17253617efe6aabe8523bd46c9b4898dde0fbf4bf1201b6a896e7e9132f6a56a59bcb2f26a390757055c6a54df97e5cbd8098cfe902601ac190b744e336ac94c617f024ac880505ac2e5ea9505f14aaf4193039562cdf4e44c0d770e4722e1a1cbd30bb41322e9e2b6640720b8c2cd9ce1a430e1147dea9f2b36c46a0b510c12dde70907a38659effd1849fd377a67dcb1c424103defb3d145f202217fb92ef33e1e54f015711fb0e84bbed06351026f258c0c829d20864435e81ddbbf3a0c3f0706b6080a98f0510712798aa057fa54fa0702c738eb33ffc77faccd2efc840f0db0d3f91bbfe749586828def854db94484c3aaaedc273b935abf2213460bed3018c519a1a17b7c58ba6c394b477fae895325fdd69a22b8d294709af72734a346bf7585aaf05fdadd108775f7ce4fe83a96458fb68e780b7f8fa8196557dbcb8845141c3c5784576ff9e78d7d7047cad913d8bd1802aee00abb07143f6479f1ce1084694652562d3575ddb7354c058545707b84390b98c35c83c569b0074fe95bd9c5466fc852dfe6da004de60173f326c4ac61ed47fcb97da4c3699589665caf1e3818d857cac641853dd7f2c67d0e97c7184a055821f3a198ffd3be1c0615f5e3e61ca42bfca045b7dfc1260899c1de3534834cd6829d11c5cbbcd2b0909cf4e40c57486afa4fb4f37b8bee6d258d7797d09b76756993f0e52a506357b1d93cd8cb49044b0ec021636e0cf0748dba3c315f9afacb9ad8c52a9905a5422dc3c9e904a39178655eff39b331c547f84b74a81c2ec41cb0487ff0578103abf40c1fd584bd89e0817a828c0c5f1b8a28b11d506541ed0b026aa5d20d3b38c293b0a90fd479df337387374f826db55366e371927210e8c5b3a954ad83a716bc7bb3005d3faa9be691a4ac822849dda9d5635d953011d07fc8c8ed5d69ee80c9e2a88248902c29a4a2c43d6c6344f6063ca26d67d571c12795b3fcf4c41111e4d9f56b8e5407bee2ff17fc83fb3268a4ecd3b134dd3d379df6ae95beafba02a2b38c2b941c19f60a910986a54690305d99f7f4cda03dc3463e37183cd83898686564b759ce5196919637d7d6d83dbb06b24b4848dab1b8dd48f1bead01747ba401d88e6ed5b72c5366a371741b7b70a3ce3dfe2025685e93792ea6f84f3cc401da1cc9359c0741d01779698408c4dcb50d9fabe1a81af0a52750ada0aea3855e89147a04bd3d485b6540eb2a2cda83db7a7db69ac15c3f031c38f784852dcf81767b435f472de33f2ed3ead85d35647c6ece17e570150f44bccd38cb38748c0746d51a4c9db0b7c1f2f36fc898cbb98ebe55ee74c38dde916c62c4a31d38d1534ed9aea799f69faea7647e69f107846ad39a8c789a8b84ab20b4d5072cc4dd09903c1a626bcb99848c1f3ffb8ddabc11f78f409bdced810a63d16170ae485f6a011798a4a82d0484d7f0e2d06508ea4fd42940a142d4d017263e767976abdd088bcab7e5fd35b7a2bdc5f3b8e0437dd8db0eb4b07f551d9a90855bc7d3199487d798c73ba751bce661e414c69f1dbc7fe145a7d7e714d673bdce93e289a56d61e63141c2adb3b50ed555773376834de440e65a6c6c73cf870ccd013d82ef32260862e459c6581fec40944092637371d3b989d14d1bc834f8eb8307e9b7bd71e3bab3761654a88ebaa8015635c30efee711fe70a89a97351ddd6526404883b58da1e6cb3e3b7a786a580bb1895f68bcc8164fddb0294a16f63184eaffff45460148a4e15409f1188cfd1269eaede02e91f72d872eef07d4329bd6c5726a1a40ee2bf46f5ccbe88430eb42af0e3b527ec011f77ad86bdb1c93a826f2428435a2051004ca9d7ab2def88a9c92a89a86519d1cf3d5c72b0d67cc6bb0af9711bac3f53f90861cb3251c84b8524e575693f12a3aef2cbcabf96d33ad1f3bca8c34a114f082f10d6a3b3fdb02aa55505bddd8a82c9b1774f7e30790a7554bc5c5d8750e4ce90b0920a1a13428d5c5b1938a8cf9468ffc8ca401f10ffcdf933ac453af14b781ecd13f314ee1097b7086cb6a02a42ee7839fe30f09f08ef9e0e3dfd511340af3d44ca16c639f71637edcf48875679c8abbcdea869ad559148eadb9e31d78558f5d465b1629bded799485d223ad8a4abbfb898beabb182bedd8379e61d6635f79bf9e734fa2c106c711e1d9e23dbcb425e81304679ccd612c87f2e42feda1d0b64a7851030fb87fde0db86d4b60ebc771d6ba1166c1300177a690c79dc7b729ea169e9febdc36d353af35eecf10aea0ce9460e128b67abd8cad0e61241d1d8652a4d16f0e76242971510971cfb59dcb76b76979577d785332d73b1deefbf953ba34cb68d19f52f3c3b40a64b21045bc9bbc902273056353d7e39a0ef4cadd4ba632fec7e4393ef7c858ec0a5ee98b8c67b5ea45377d63a9904097ee6c0ee45b2a510d506e5e9b183b79b7187d6b672708f23ea9e4ef60f4713ed889a747de95fe3b1643cca43456e105553ffa8b933101de178df8561252e93bf090b6c595d28d25ff0b50cecefad41e968ffd9c7f544f1356bf8c2b73f4245848f03c2f6821ad6dedb1ee84194b3ea43542eb30c890fa15f99c80b126e41cad102d9bf055140cd57df7dc184109997c5c6a2705db2b1e0369ad2a42b162c5472e1582dd9c419859bd21ef5c8e81db56cd20059b1f45287e3e75f574072eb82d0616c551d7999456dbbd1880bc81775bfb9e83932fcb4ad32ea2258884b1183cd36d1a99e68d7dd11a92a6fb6fd9a6c0762e5b16ee3a292bf18d0ce09dd7603b997c87f1a2a41398cf3093d9440e54b22845179b1c09c5aec0d92de073a3982c301731b6ee32ff8281b72a5aec9df9db1a5cc6d74f0c74d0cbd3f142366fcea4033c99eca1ab150a3a769675d46b6397a7a9c5a7f7d52494a13181625c1eaae6846dd025509343954e1bd62da283d3490812c9d49094b1441c3ee2d6a3676bb0abec56e1ea104212b56b19fcb4d618014834d655c0738f2b7df3c685a1d82bf486c7d37e5770904563f1f7b574a0ee7db1b402f3c9f00ada3b41beabbce4bfddcaef7adef2e2533e995d541a828dfb10f89463fc6246a1e17f7ee1462306433b01b11217c91d9ea0d5ce8c2c85493b1df26ae02f5dfaf5fa0029141d9690d0c369b25c6a9b4845a45553f98654ea7aab3e21e426a926b2ddd38fb458f832a69abb77615b740e4dd2fe06da5719c3a33c5d0616130e51e0a7fde5c221229aab5518a76d940d6a239ce3172b652ec3f4f6f3dc96fa15925dafb5506a58d1c776b91755e18c2a35731ea83f4a145406eda0e7772eaaa161042e9693410233a88a7bcb83193788e09b43ce143e16de10dd0a8b904e193f90ce2042438030389f8ffeab48e72dde98ab8f01d294a22db81d873f00f418f32d3f8a01a00659d793fc45bf4af61f360734cdbc28e2634840001a67071784a910199e12f448baef7d284e0598809d90a07aade17345ce4b1401339d601b80cea4708d6838fe2a3e35b5934577eaa795ac6abd21bce280a7b65c6bd9f0b12819c0fe086154555be72cba7659e270c12dda403b1827e74e281af185eeace2d8e66ff10b12a4fc52353681bf141bdbd9661a8e954701cdd24551a50e5aee59776efe1c1c46624bc2149e36ea88d076abbe6f4124d88d7fa742d57c615bbd59e49258cb868c8ca2e2ef635856c4d9cf56d809b27daf48619a03226bdc0d6c0822919329ff8cebed8a9919b38e7d1dd1f1c0e364bb9797f4480c326a6b233c61886f4a0158eaa6d54c68f9eeddbac2581348f65f9f6cb8192063faf469b9bfa041fae94cde83b76b9b9f1b1e6c5281de342bb87f808ac0cc507b0d83d1b934721ca6b88ca69b255c6f3d8dc578c0a5fdae0a036d5f0dbdde9611e6a20d064d68dd3f279810d4f04569f3d30ee1c38766c0e350259ad3f1ed2321d659588525e7fb7649586a02d32c1af43d29e8204d062a8f23009320dff881daf1d9771dad8162485c8717580db0cfad73368fd4fff18b14aa6633035ed9ce0b5dddc2f7437b7a404a8d5d67feb270c9307be18de7ff7658403c629005ecb8d6ce482172b8b09bfe4b2b5316f5ef99dbf5d8119bbf498dc1e3decaa7037f7d4da8c2d3b971df103d9b90c0d7bd027860b055811aef506c65938f841e0ad821168912ffc1bd1961799b296c66c1cac654b692fbcca8003d58e601a0ff15d50447f88ee643186049d8a4e28f9d1fa00816bfe7a5e76ff7029bd13357abd15b47a186ceadc54a14dc9d97864809ad9c5abb4affcd6a8747d239c98b6bf5982726e09b08cba7bf0b3e5129ad6f67c052d0b68830f8e2c81c35620f9da87e0d168ec4cfa4c0eea93526884bd276b788e1515c30886048057cc6fc2d7607b55aeb392b21c052d0b4dfced80e9f539f0bb1d84e736859680924371b5a23d8f49ccc5efbf5c87ed788af38582518133f07ddb584b39ca1a932c5ba4466996e966f42e5f8ac81d78f11ee4777dfc7dd8009ad2e7301ec8500409f61fca45fd0826c9ab3167faf4a5e291e27df2befc1ab7ce24fcaa554f1f91c20707042e2d67c8f0d9e2dae60585f4c1ab2effc1179d356b2b50eaf6d150f8a76aecd5ea878be15abfee23c258a66a781efeb2051c35a085a7280d776d6105df03ffb645892a9a5a920e2632937b99876e3ef1fa7936afd5d569bdeb79a262c9ad3ffe73f7ecb0d027a2d2701566f312f3ab032d8db44c12c657d7d8a71c47fb62adc8130f46c50276aada82be8b17ce5a337b7b51a03ca2217ba0cc9db49f81ab581e44fe138688415065807ae2da6afca050d61862b8c558cf981a150566c6e48de7d7fcc99a95d7b7f24621388918f6861e279fce152bc5c5dd2837c57de13d4b51c9ca866282eafd262e82a7d29dea37884a88d7c8035702bbce925da12716050afa3ceef6f07846eb0b18ff0a2e5827498d5d654a7fb1681092bc53ca5c848047406c3fca78a79a2ef25732400484f1a62fb3607f0c1f43740ca4c55e1223a9f85ff0dc8ca5ad52928e0b1c9113edf771c1533c045df6a32f77f3d2c7333d65d0af10da5a95a3e83a81b0b42f8edc17637aab6a33da3deede6b588ce2bb3e9e3bed45acea67c3036bc7b08db43b30afe2febd0da08d293060b9d80f39b6b517cbf6686a3f82908baabe583624b893cd4ed9b6ce963b5443880be13544148e5f214b6ecb49b7299c6eb1bce227498c6cf85aba25f0baa3739929e8ae89dc0df6b027d3ddac45ae59bc15336afb085f7b012fbf120638056ca018697dfeac5a45d1eaca73c55ccf2026fb365df8b74560bd94c6c702b61553cbad25603ac562b9fa31ba1f7b97ed4f7b32748e2c9a58dbb04d737d5a8fb1e2090cc433d0ff45d54bf91a4ac2871e8f88264d45a68081d8354057bbfcb6b871481fa7a4f2cec52ad58a4f8ce9f7545fd90b2d824bb4a7f23ff9d6f3fc82b9ae1f9a767b10ec4c41cf34960a8615306e5c52cfcd7df7a943256c73e37a55ef7e46e63ea40b67a1432c70fe715cea98fd8839bc1412313336b8ed2b66ecee6042e4497ddde7494e58665a22f6fef8c83b584c065efe8c731a1479046607012ca5625e1fae9d9cc4bb402e441e409d69ed416155c061fed59d5069a7e12156b9ff12d0da881db5e54b94dd227257051404ed7279c8cf77fd2b16bcf4472e324eca1b5e58f55ce8653fd1bf3705f7814a7894c115fe2bd0114fbf9c2181374e292b6267981aee53f726f9f212d6dba268e479ecfd67ee7df37e79c99d1f2c3d140e291b837962b6297fad548448c20086295fb659361d92e45855a8dba94d69328ee8057e40623fc241f30f0d1b2daecdf9ee4bf20dc5dddb68d33c9d56c44685c98811a47273b4955b7f67a1b80a2782555747661182ed168bba047f0586455204b38c2523abc2dafe293f84bea97eaba43f2b38ea14cc9b633bd8fe6541fdac84b89a3848f53493d6639ef529ac11fdf8ebeaeda3c5239093c4bc75193e9d74adae3fa36bc36fc075e1da1cb456c9ea4e028faa06d8d52e3b071a6c8d7cfbcb3a306e544ffa6f27ed1663ee025b7bd3ea3d2de1d438da90a14fe0d35279043ed02d12bf94bf2c4124085696c4c5f69d475ec4e766bfd015ea1c8408e1bba00bb216d0956d5c5fab5676d4b568cef5b590f7053c48a3d8a9abb351ed4f2072cfbed4f72879e7ae11d570d903b38a3e1944d8ee8ab19cc88dcd613e31281df447e77fb0d2b74ab6592f4203ab3c261b2e47d39516b78d3e7cf1554074910833038535d412bf802d13bbbcb3b6e50f774278663ca8c1b3b4ba3983a148053c1a4f3ce9c6125e4b11c343e5c4b5b75ba26473dba27852d2655e01939b01bfdd048bf3b91f8d91c8ce290d0840206f317031472a8142522709808a2a3563ba9f37384e97b84f3c588dcbb5955ffa7f90f36b7fd23ef3664f05e35ccb9a74dfa98bb526bdaddc255d0751f023c0f60f40803f0add30ffeefb600da848dcf3ee023a674959ff74f325342ea8ee05130ff65fa7f2dca3e36e3cfe6a7ae8edaf244f05b7d512b625cbe8495cb8e08108ef991d1401430e2a22c4c8ad759f679ed4e019127ba9cc7a1189db841233756ae85d555de0da62978def1df811d9a8dec1710069f035c206b1d969007a2f5642559670a9e334608797b8d2a0a1ab38f0f6f84c50916ebfd58440e82f891ee98dd800ab98a795f0fd33a79524ed7f3a8333ae2374465649b1d3a2a3f9b3595f819b0b11bfac548efbf778902591ce3af50cd0a2d108ba44bcfca3ddf6123ac36ad6ae535dfc42bc55e7146368c5ae6697643ce2d64cdb862b368eae8b51066b8c86e2934932536c1d3f1ebee18e8465dd444345e75e901c25cfdde13c396f2929b32e1c69523c170a955dcdb793a54e45fb5d92bb739279c548ff9243bfb7d50f56bdbe98e856e9f5e23cfa3b3a399e97fcad12ec65ca633b72c6bad9318afea2522ed6916af0a05b56d1e866adfcfe6f557e0d05b9616af542f121c1367781576bbf360b63eb5c399070f16a25f422806f467e6a369f960faba6bdadee3bac19bc39d168b1cfa832805afb50c886eb0199b6ad8f36004bd74a395a26050d3236d216c048d533817f4ef351c613586b543255d222319369e4ac04fb7e6fb37a618d3c73c5183939040f6157b7972270db35db956b607b7eace89cda1ba8eb93d7159599f5731f937908312ef510fa794abb8aa5e7047f09c665858f5d22f5afb120d6749270c42a91352ec74f3d4e6962c465fd76e9b11e8b8a4b8569f2c619036abea4dd5df361764c26c79cdbbc38048b41a89a1a29135291c398ee2d22f71c77391cdb259b6db262070b6af6264564ece31239dd3cc8ca12463a5bdc34a8ebbacc5c45e2ea6eba30a0e37be5095beaf946c349d70613b0a67cc3a1e9a3c8ccee64c551c99cd94bd352ea5120c16878805fe671a97f5ba3b2b3e4f3701eacbe93088d2852361125d5de34bea712a05f0947a2a616c3cd53bc27f664399ab93886e30752f2b7b1443d0f80cfd2d237fd5410e5598cafe796080eaf10656c2bd6143bb9428be884075b073c5ef8a294da2e1694f8c23ce9cf0c4081e1f2ba4776f93914ddc59c30e8fc242fd9595252e28660cb8580fa1b3e313f4f0a3221aaa48f9df6e6a83922c57004f2d14957b87774a53249ce0277dcedf4e82ca1651f95253d12012a7e41a15a8c0b5123464ed80a3d50cf31c894b1adcd2d308c4d74b5fa14ffdd9a200456e9bc015f5ecf7c5353b40fa70a11e0a352e94f5b28c3fee807bce1f8528dbb182b322bcfd666b11efd01d033ef2877c5a308cad9abba29c5417d4349a64f1cc7a470db0f6ef469ead9e08b66c87bdfa5fa6bdb74ce51bdf4dc3532092dc36ee7f41aa46e1289716b03fbe0f43ce5ae334a814c7f185e24a49a7b1061a96944d2556f7286be6f307ba143c8d8ab9a3de76cf63af76e5f093f24ea6e8122b22a9b6db70c1cb5f2901189d7610118c60cbfb49b1af91baedfe3c46d09132423059f168c61c50bb70f66774866f665cbc94a1ab415eceac74d5fafdcb9e08f9963101954647ed4b207e5228aed474b44947aefde7f3af4cccadc0361ba387020faa165ae86bbd0585ffc231288a5843da9a6fe6f68670911a1ece44820fd467c6ee2a86443ac7ab70bdc156b938b347cef5f91b85473dffa774efec6c3b7ff85510ded9f5cc85fa6ec09696896298a03437a05d80202cbe25e83011aab24a65016a8932fdb1879b33fc0db3dc41c731e205065fb5994a4dd10640bd563a1baf24cdaef24e802892d9ba3c3e270dba0003c9279267b3cb716d42876d50665c77602821e0de35750c3ba64d21ff949447c625c80ee182a26eddad4835ef25b224b28cc7cb0b8cb93f57d58e53911332090bb4537a649b6c3054cbc374453c463e3c76641f3d42926a5dc2f604bf00a6b3cef31c74343a3fa7c59e04333eb314e4fa359f1f4617b6d5797da5c73774062195bafb37637ca2dfbb3313c80eeb06dc6c8d338d9438c76d7b6024656ccd4c615723fcb4d1d14fabcb8ab7de784fdaeb784d7e7ea7ddcd34ccf19116792aa369eb097934d03f80a596312e930f5034b1a11cbff6e83d61a0374d7797aba0bc6bafb96bc1f545254446e56ee17917159d17a5e2916ac8a3e4ab6b39a045b0b73964795db7708569a20e892a4f0391641af7e7d10020f7b59a2ef11a43eb0d4cb28a71ea1ec12d5f4fafaa3da72fa148a66bd495756e9cdf4ef4b1a7b131d296ed339d1b5d5c91a722393d73c6f8e526a4be8079580755dc21086a7ee7d82b4fa029c7e73b28e82114eaa0df50f47e8eb6063be92f1076930ce1ea7b99f695f7de62b09f8780dc91d18f5e1f011fec310ea884702489c14ba02bae37d8940f96e9db565ac5aedf11d87d0ce18924e99e9c9a2a5e041c73326a396a7c574d237810b22cf39d3ec2622bce9fffa19abf12c8f3902879081e84b64b81b34a176ad71361b3bc059b63a047236914152e22951af007e08d42e6b927b778e88b5d5c53f16bb698570a4fd0069b79d9b56ac6e9436e32b30e30a94c83420908b12b32c27cf4059b6fc322a7f1c9844397e1e377f3f34132b1221e2ed5867fd124dee958b8783b581fad533d19db09f95c40615d740a6da28207db51c996aee586ee7f34dd9fc45346fe5492485de3842cbb461555e7237cf9a83a372575fa6914eaa43d919b59245cecc9c4946eb117aca2d38c643d5db00f0d27d5f249b6fd986886bf764a8c4575276dbefa190462e37e35badcb10b74fc4125bf5f5807f51c1e1594fdc65331c054efa537751ae95c85ce2aec1673b03adf248bc823ba5bc4e14e12157932f88b193c630e73f7c46e7e28a253290012d4361d248294740c8c2702ef8d5f739f2a2f4d08a320ab488a764c3965d579d2c65e22c24826207e0fe8287e02d37608c4701de06c4ee5a1f6c2c8623a73b99d1b6ab96ab92e17153cde143099cb428760d70ebe2ee57f3b812ce2c5d6a728dfce373cce21a6fa48a8c17d3c77d0b7ea9e9bfd9f7d5458302433b3b170976eee4e70e64f037086066d61354683b8a61f45c563b7d128499cda8f111a41ad771743f7ae179adbfc08b133f5368be32593aaa83b960338c432c34944c28ab10b69af986f3d3440b4aaee3a8f51a386d7931c14893c4376e825b7eea40b439d1523758ab6023ae4c27ba734b5e41f9a5e1997304026528af40e873659cc38b8d2919d66bb8097594154f217a32e4143717edf7dbba74de756b21e402a9779ea640fadf204cbe967e2e4d716ed87389438f9b6500e3a3eead68ebd7ca6450c4fa14f066b3ea730b000ecd40a9461e765ecf329dac93bf081d732353fece14fe6d3e2f4d18e678f535f815581705ff81093f297ce6cdcc8613b9091259f69e36b41848a479edfa695b1c04f10bca451d5a5902b33c2c62968e3bf95e38ee8c2b88619b08be1131b144dcb3cf399e8b431c1f9e4224fb9f530aa5756cc7c257c9d3ed718e1e5ec7d754393c53185f91227a959af4c4a4a14edd4ff80bea36558cd0f17a2efb2eb190905797a2a91a43f59bea7779ba4e010c2a1ee9818105e1d980b0b92709719aa811dad43d09599ab486123c02166e64bfb50f64bcf8e750100e066c0432c692bc0c2f22469082644698fd71c1765ee39122f0ef4526d603ff6f8613ecc6bfa75cb8f939988005942b7a675f30ee262d77b4224faf3652572543bdfc40bc07054a08de89fddc47286c8eccbd0e44dd01778787d30bc3c4deaef26b150cd63e071102a38ac9a13b8457b3ee1e7be6cd07110b96ae95f81265936f2bd929239c34bb2cd9f30507b131ea2e0c791098cf391f9b72b62359bbb1c83fc9e52a3de800a222e7a4d9cf95586b285e5bc7ffdbfe011161d6c5daa854404f93f86410005e2dd555491968813960b1104c3c5b7f57f610b84fc75f224248f7a6b0d49e9a51346e2d258a96e96374f7c0d0c0ee22603d1ce7248a7aa4627783eb13a2945ed4d27df5f0e4ebfa953d580c24877211cda2fa3cc654ac833b5a289a1813e0742c84bd6094782f34b939fa78f38e801ec8c0e8b1896aeb5f9f61f677568c23043c8eb8e3228a8742b56c33e2c44fb72b0fe0d4bce7f511934ce097d692dde61c521784af28afab2b345915234f36ab9aff4faf13ea0d60cbe38fff7481158ac82117d1e8f41b09d668b45783483ae0da9645ce996b49ff3046867882b127209b58abab3207bca86f2e9ff265a868a1826040777a05cfa8732c8dc8228a42776fd09037e9136950d1c074cb76132185c65ba1cc644674d684f8836122583cc79f1c080d9c959e56f2c080e84e8d5cd423688138847dce98cf4d5c0cd938cad0260c30cc2ec133ac0c35cf4d08f52425d3b4e03e0807a6804ecb78b88d03a54fc47cfc2b17a8d264a1f6ac145931247381cb316f01bf65daca325957d2fb11563092f3abec5f439afcaa8a785d9895afb21487822304732794f55b2f75a4acd0d118c4fdcc55224dd78d44bf8671b49aa7fe4aaa0036a7329b1c9f8a998362dc40125c461e2e76591cf62b1921852ebcdde24d9f651e2f760fd43841947518f51ef0d4fc7831e1046053c680cbe7b5ed7632a9dc04e859dace68e8ea2739bff8b882dfb7531626536dd355e59ba37f6304d89d2a12b1779a2907b1acf3f5cbb23b36da8cdc4935c672d3d1ab6d95471148a745963177fb66ecc03c4930af77750bd388c55b17b4fcb49dee8037a0044ac4842cabb4aa66e16bbbea6245d2c87b36ffbadcb375f6d0ddea7b1e56566b6633e87e2b2123e57c1f81d2d38b325294a526878bfac8407284dcaeb2275946e4b3d2aa27f3a17888c72dbda240781fea7da9ae7b39fa0c69c152cbb60d397e15b51c63873b2ab838f95c69855ce2a24db3f9690284edbabe3e26ddf1f7bb697a8c27a874806ec9729c85181bef8c7d12df03adbdd0215428e6acc4816876870c798e1c485c7a0f3562f2768d6e229451ac91f531525aeea71c4211d912180ec44f4873105fedf9c730bd62f373edc67f2847e7c40b55136ea0e2e0087a5123da318a8679ae98a6e5ff8a255624639fcd093c6f1289ddbc5ad10b37e276455462bfd81e77c69697e9248564b368e4f0476c5f680dc879eee16d116230279d5d17febd7bd3d0e1593d65ae91e72f613c47309033337b80e79982d8fccd5a40d8edefd943432752f3c6553a6e0309e8c7fe9c31d18e58b345659ea109fe09f6cf0f42a39a0aa85ff423d6f36db8f0383214f5df043642a9057abb1b2564ac44d05ad457dea908114ce48bacf38bed0cdf2305f756b1b99b18f1d8029fdd45266474d4ff282e4bf47b548780954db33b5646e693cc9fb205791b5aa73d08930672a950ff6e5ecfbfc1388e38ddc335aa29e0d67163725a32a42dac782453b92b01c13c68765068c91f7eeb3e6262abc9db3b55deb33385eb811490ed2103e2cea310edc21665a067349027c638cf03c0cdb3a363286824204acfbd1a6185c42c07f4ca71c56a24571495c9bee429aaa5aae9bf82419600493b008d08f232aa063d2decf0e58380fe0fd4bcc3a296249d915167f6b1e65276a08cfb6490ab441d2d2d8cae63f50e399ba682e8d0bbcd834fdec01bb860ea75ad72392213841a2a1891b65551a7c7645f9e7a68305f48ab675bba67bb0df6930ac3d12b90327b8111ee6a7292b6bbb26fd8a8b63d759577eb2ec4dd8c0a28fe72b9b174df5a0f0cea257fb2b9e9e597cd46e27c8e70646ab4becbb88688f0b6ec9912e79a07b146be8e25a23a2c38763923194d640331d55614c003db7c998fcdd69368e46cad8869d5fec50c03674ce39984755ec3d9c15cebcf865c130c1deaa41d6e47f86861994afa75132e2d4003585f68f7c7c623535555ebe572a16c4a815c86415c94842f9b428fc308d74af0fb6a506fec7c117bb7260b265ea51b8d81309e2a745e7db0017bf9221e93f21011b91fc4a3b3a3e94acfa6f6f8d4c181860bf38e6a6d35a66f8b757215f47a934fea24d3c8be429618daee71170002740d4330a91c7b0baf44931416faa865b0af58c84d0836df12e280b2f63f105acdd0d9c3ab556134878326d99d388718f076b808a95b93bcb1f9356e0ef9c6438f1edbba0095161e7101e0cf5b2ae641478b62d310bc7055b195819e28456fc751a4774984a133eefe8a25302c4b7158d543d1d510621633229bd5f2b0828e17fcddaf15eb671ae9391744cc0fd4e75fa0815c491b6747c91d68befa3b2d21d56b02cb075da9933152c8f7a0e512ee030c91045b70a2564360700186ce051567893d5f1eae505a75b940f1d30ad5340f48f588f8ed24a960b8f591ac49d70d08a96f2ce4388a632e31ae7f44d698785be614a1597e39d1b5fc72e7b598b292836ad52abe0eb3a950d69bac63194e9620e1806b513571416bb63673ee3c3dcc158d00bbedc0ce62c2bc3b56076cb657f10c2f2a1ec636a76f23abb0f37a87c7664c56dec49667f3e4d0488b44702d4738243d2c6a83df2e9ee94a8506676b2695b492b4b79a675264f90361be134b5b23ba10b1a1b570e0be5e0e93fee45d4b90e0982bc048d15cdeb6f4f7df4f811dbf4e5f67cbb32cedd218142a31a09f4557911fb78c96f88de26148b5b888a8586371f953f01cc20ffaf7af1c5c32f5d239788c27a7572a5b72d76eef65ed205b5a0010137c63c40e46da0d6d162267657c184c747fd964df965ad21a89f4029d3ed62bd4acbf56c90b5a0f7e03b587633d2afff2b6f50784d39b96dda843860724cb3a35a2217411c01b3566f66644dd5b263d0e363a05d42f570b782438a328a8ad2924875646f9ed29aff8b7d6a579a1492986779e4b12a631eb8fc8036b643f40f1c84886ab51c0cd2268856a6f0992df25ca2bb2133aad5e42c7448779bc188061dbca5924b2c8fb3c4a96f1e573ed3ea0434302e6e797f09ab4386712f2c9edcd25fb13ee445fcc65e9fc0289cf205140cc100f00a70e72d5ef34a70b4e61bfbb1d7a69c565517fe9f3a841ff01dd32688a252484bd22092cb74d71b42189312432829347558387a8065d4c5763e76eea2908d41b8d2d1cef593852fbe3a1ef385ec92c38889a33eb9e381217fac6be6609d839ca726ecd77d7834fccef9ca708d7ee6ef815ae28a3335c49e081839b320f3d6007790d831091109daaac94a5d01cbc5a4460f69139831e02622e6ed6839f5606de14a6df680d5a4620b9f36344d537b4746989bbd2fcf0dd97eb32ad9f3f6a449300b59ec54758b65c12e9e9987f0cdd1b1969964154d3876f6d290de4340586121f6ee1852bddcd289b8bbb70357dd62a0011f9ff461199e38fae64710ef7f219f6279321bfc50f5efa4241279467d939b9a6c6cf47b3392ad5f658b505143cc8f09a0392f64946f91d9fcc7a04bc9a0c272f38c67d191126413d55ee16a4557fc8d81b5789447cff03d7c74b086b65ecc3044a6f3f68f50ed7bc1139ac5226636bf9e5d4ed0d62379e9afc132a4cf3cdcdeb3a5d975f8a0e914b6aa7d5c76d3031cdd73a6718c34ce72b0aded6f591308fc74a74e1d3cacafe85daafeab76956e94410318c5dd8c80900e525d1bcbe19df3d27d65b3ab51a6aff4c6e29373fe9bf0d8975b5d8309faf651660bb764d75052d1b6ae3cd53f282e2197c94f798dbbc096f020cbe05ae002e0ece50e6ba5d40877fdfe3befbb743c0a0f2fca4ed665e301ba071723f203960d6168e4a54d9ed8a75b0433bc8c6319524f530ad99d43bf02702606b6d12dd73ffdf7c05fb3ac21a8e31e47e812cd21211e94a26749777d29aca6b01cd99e1788c498d980cb0fce4f129d1028ca81a480b0c9e017c7c4a0d8d2455bdddacc2960905001736edc7a18ac2dc57baf31caecd597e93bcbccc0d57fdf5000bdb4f933a6b490f36341b88f66cba06918b375ecd98f6aac66cd282545068ddc97a89cafe885535462d6b096b11f20c4fc9c5f940ea9c6ff3274d1ba4d6126c9a4e72a337d131172fd53e5b274514aace96c4ec7cdba4718ea97fb6cb6185f7b5dbc38c39b3765b6686025c8f16bb1c2063f5d3f1851e8238e76cc8603df9f06adfa8155d7c35e4519446e416731e85e7b2468f36585e0b226b2966d3cc1d4375b8cde00d2ca781c702d43f5966234b0a565a34d39a9c6daf39ba922705fbf38afa4d7c9c18ee8ca193c1ff28716551ce3ae203b572a1ae9ff9caf507ab3691526578fba47c9426747c2eed7c7bd5e8ad3b73c723c4a7eb3f0ba43f1a8c63a14de6620a1058e408ef00a99fe988607da99b100180594dad2be61be3309bf3e9fa2cf66b67145278ba50c0c9e38b81b6e43d87787c651ce190d2e5efb4399ec871ec8274f424992f814bf351d381262dedd73ea81bc41d70f003961610ecb8112227e3d218ab3e8f3177b993cad4306e7f83044894dc0506e8440aa979fada365f9f4b038ee66c19153cf32f034d6a4a2ff022231b188d0001b71b62655a5aae4a58b9b3c8924f6f92d8e4ffef00cee42115095cd1decc20aa3ae7860d7068f76c2ee55a62c546f1cfcb02dafdfbf6d80f586a297e29e99c36c663de87adf95a7a0b37df127abbdba514e6b073514d15c25e3de83d23e0e8ecfa6b06e550d9a3f4fec187a681a4cedbf0d40d19f61382d2dc978718de4116f44de436f7b0217bde9ec9f3305e9f48dbe1ee135ad5efad949487e851414e6d7f63f94ab91a1e86a5f55262e7400d753ed3724825a2d56e5cd56aea5b65aa28e449af6d22f33a2ce01110a0cd398f565be9e6568a45b9163e578b68aa0144508d36d81b42511e85a2e13f4beb37ae0683c99c79532e30b91543ec1bacfee3ab0bedb81bbd09c84f150570fdba7438979b447c0512d0dbc8c6a255d4d95acea2788abbac3120a5e9656b0a33d0c13a6f5e1d4046d7a18ccb0765e9f47fde2896a5e59cf2cc74c2577fc3288bf4ecd81507a48e7fc9ab6ade3815207a3dcf8fa3212ccc0203037e9c13a4116ffa180ea23110ebeee8f3c25cd41d15f4f5ec9a044148feced43744b91165c26ed760627ac427d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
