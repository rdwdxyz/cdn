<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db32ddcae0eb2e2618be2132d1a2a39ce9b58dbaf486449551181f3ea85ed3397fb4db765b0d8b92a645275b676822eb4ee50087c8a7882835383aee096e2a236567ff8e5bf0ef819e85dff6d6c05523a91292b94a1ff2d0becf2d51900215e2b2678ed6e9e27d3eb91ba85bd27ff1375a457a08248bafead753676b6bfbc01c140dee2fd4699674da46f479b653edfc678face15cd5ebaa265d2dddfa6e68c91d5ba405fd91706469266efd5cf6cdd430ad616db2990601bd512afb055835892c7e717ca3d7417bc3c8caec63198d48dccbce4aca5248539becfe34e7d356acd6aaf3a8769d99b2fb2fad7a6de21d94bdd51202aa1dbbb29c6f109b70c9d7b49d309b4b62107cb961f55e847fd866131e945a1e95163cd522ba6d041ef00f5912f07d877a14b357452b42c30567433e78343eff4dfc952fe11682b3c3c24837189510485b52e772d93d71fe23a6d4e25e86f3f0ce21442034a0da6a505521afb568c15fff582f66421c0fdf711bdad6ba331fdd66655e836eed19fe559fa2034d4ba36c1b0ac34d01d85f12957089bedd4f1f907a1beb04c0a2103a0b5e192b753ac9c002179d7013c5e1c3aefbf6213a59022f0ad629a436291e9f1a364652e118ebe1df08a6ba16986d0bd2e499511ecbeb1263f07acff88d4d2f0bb2208dd9c5a240a816a8553420cb9ecd0834941956ed98157184082efa9fb354550d8f0b70f11785ab9db35b38194928c162e5776b1e92c4e6afb8c949d0de7e65d3788dba10058fff58ac46a61780b673b21e7dcd95c8d266b3a85e9d0d152b171111c97bc8b6fae3e6f6fa721b572d36259428f4fbbbfa2477c76cf1af4887c8f8f0e6e8c82aa4cf190ae8613247951e561da6e6d4a73fdbb2af33e6e2c15d6d1cc10725ac69a8591d1dc72ac88932613280aad1814fbc70a88dbbd175ccdc24e3b7f5894728c6655019fd99877b912f6039daf50e12691fb5376692921cb8be741e7e4715a7e0d20922a0817b4b05bb6a96ae41c02b1120ccc60841b3e2b01f6e2bb1184f0bdd8a6e9056198617a934a0953844b97cc16dbd1294cd7e9061a4d3517f02ab4e9664984cf9b4394c74d0d4a03507c039a1a188dd7a4254f48d38362d87b8aee504a1bf710f9ce2fd64fc6a7ab27cc2d9afee6370c06aadcca7e8d10271663904948364f320da6e84d074e6db016f83a760a8bd9d69b31e07756d94b8f23988a7651e5e519c1a57ed016672efd22beb986e4402c1a4dc3936232700898812f1bc1039fa70bf7bc92f26e54c55646894ebaa6d9510948ccea299627266b3e6f9af33f45744b7d0aeb9081d675717ac2a0350f86e9c2ebf8239d4fb58bdb446c5ca4070654925c14e817cce2efb9b942b4ec7bbb6459886098e8c7e3bf61836b7afdc1a25aa48bbbc10b98c604fe33be3e4a8cfdf0a0a05cbb563e33d94df99c1e73ffc8ed17f9483ddc4cca2c27c790d81703a2363ff9eeaf7cfa64bdaf46e8a5faf96cd92dab938ae61765183e1644f4ec2d05bb24607c9f382930ac7ebf3ac82109afe7d5c25a0963f74968172636751e930d3bb4d60a70825038b3ed6c5a856c1095724cefb5ffb32644c91df7791080ee83f025a317828c075624e57328aa760a40232f638b1257e6643f539c3dea2fd470075f4407a92a3df02a81b4f3f957b4f18beba2b218d80695771753644530b05de4c88dbba9d84d1bcdc6f0073c89dee940a4cfa0448e1d4fd7313e41a013e2e966239c9c4d844a3c7b90dc6822be205e98411b2ccb61715f6c5d48ce1225575ba9e572dd514c22c5f189a0dfb45bb03aa6df9fa0db9556d61ea772957a5b02dad5782293f3a4506ada3d4d4a22eed630a6a74ee09e6086264023c4a2a07b7da7113373767953bdeefd4ac47d3b1768de6f70ac7e3502681448dae525a4fc5a4f877be0eda1c5f26a37bfb9ec3fbd83a0deb4adea854d4c256b0d49c9712d45be7c93cd47bcd7f9db0c4bfc26d9cd73a7b2d642cce5728bc52cafc6bc3c8eedb0ef1c823d17311ea37c8b23815ddeb46f696730444849dd004dbfc30fe95427c57ff831289c96c0bde9132b2b5a5f2157d2adee5893fe56ba437e168acd80c56a3dd6b7959c8d714a6f85713aae404c74772332f190289ad77c72cedaac9e61d4fce26fe230e6a2060eb82ea75e89a98b6de7588555efa589c1c5ed16cd67daa7028ea0f2dadccfd972056b2de9d09e7de7518709bc69ebd16738c2189e855b9e751a95d112812aa00d3faf8d0ba27d04df3f7e6e418b7e58b24273bdddb366d6ac43f3e143f9f57eec036b8c732c52316ddb62eecdf53887fe0eef24178d98c372be6736f6b8e91f4cd3602151e69d0dc4a34d3dcf0b8904c2fb2516d4c4c9e28c3a5375dfad6a9b6f8435d125c2114cd0d0419030c9c40f7bfea8c82c7cd39c7b12409e1f5b34317c33684b0db80b9afa5e7efad53de9ba181047d691d498a521ac766855e6f48c6a6232e190efbc2d8e0c83cd47b5885943e3814ce35d7bfa06a59e4c91741d3545f0cf2f5ab0a574d84d01335df527c4f941adb9cfad7d9fc082891268837fbc984aee3f0bbe533333b3c0731f56f9037da29f6d9d2f91a4b1ef8575b240f058ae0ffd676cb8ceda143ca5cdae9cb975d910a036986fc953299903bb5dda51d3bd26df3ff68c4a68850cd6248b5ebf5e734845897429c94c1b5f5f726b16d54bd49d9fda3810c8268b495fbb5e73fea38a53a3111457ec850c4ecbdbb1418974e37e1b89fc4aae5d3b44ad281003ea9bde3b3e8750cf5b14fe3de443e20e4d06cd11edd5874b572992bae00a6bea8d35967482021b6f9a9af18802d7357e6bfc51f56fb0725c959c70f070dfe0f0869e85d8b61c76597b863aa25d8ff48353f93a249e7b343d508f09d7d0aaf03c8647c9ff000d7be27ab8aafb2dacf6d997863d25876a6c43f0cdb66c5834249078999326f901596aa7917b3e8f142128f939f2c9580189d476191ae740c6c45d77d6d3b8ea2af2b46af16ae2d364bd375a851dfc0fbad2e05bcc9d861399ff16da2b667269aa479c1eb63a04858f124dd674865f8ebe0b3413dd550d0081c35994b2a68e8240b39a5a5a7a08621a0790855801844dc8af4020775a2c72b9067472792624066eb378cc070160ca63ebd57876db8741b5aeac81ca1523201a62e6c647271656eca8e310a381f1b4dd59c3f559fd50dcfe768f4270c2e56a59ef986570dae29a1ceb28b0b86582fa1113ec2eeaad2fcb0fca931d67997c4d7c5f3401f53391a03e70b6feb7ca1a8a60dff1e4694f59ed7e4f689db474c16471eb0aa7e194e57e9f999f9635e4ef5365288a10c587c3357bb41229d7f12490fed172b839d0a684dc80ac32e535d2767fa1f65fd53b96ce3f005170f8f69021929ae663dc7976c721ded12b79a36bd41492e6cc0ee8b8ef11b51f0ff2a14e276d3288bd05716c1d35385acbd4e40ec8bcb8ba02ffecfd3fb9d9fdf8eda30b7ee7e4e815023e93ce2c3461dbc40893f9755d43e5b34ff59e88bb7cee0dd46edd4b263e6ce5b47f3e15ee8707fc5c98567769d7c7f58085706bcd5ab6e3eb06a0d6d9061a966671686a53cdd54106306a36eee83af0476b5d934786d58ad4a6681086dae9a72bfe3a0c50f98ae8fba61a6d7ff639f50be6e7d5817f2d9d9694b5a1fae0d9c1eb38a011caaace4c14888501e6fac0e60a96cf43557f6c6b7704c7e40947c9afb20dc9918ba8616473f31bde7af6e6b06867d18097b79847e6c858adf16f5717d199c70cd7b7e21c4cf8de4742a07222da33a548800af7869df0f100a6b6d78ae833d09c3745751513b5a88697400c4d4a7a477571aa2363344609a03c1dbd5561996c9e342e29577800f87314e67314b16c8ea6ed2af417d5e3e8490e8abccccdb02aec033cff2eacd4732110fa1f69ebb656092641913ea0e87d86d3de158e3b114e8fb0aab876c7c231fabcface7500f412665422900968ab9c58e69dc34055ee21f39f49f7bd44310194aa3fcc94208a486d37c0105cbc59ed909f66e74b822ceecdc0d7c057bddb5a600f29b62fc01d844a74d37bde413272f6d586fc68891f781af6f5187205bc3241d198f76f45bb83a56439ebc037a6fd6948c518de19c1d16e9b2da415831d7459761181cb030b0de8d00cc4e7e7ed183660a6499590107fd0690234b0a0ca1c70ef32da775186878271b2133fd48793f7b4bebec2cab4c8be47f6776b4c2c48a10feb32a3d9b75dcdd552486e1609b64df845d495f4f66dc30c426fb7a422e1d5bf0b9a7727b3c3410aa157d135e733eee2a0631b21d3553ccd2c3217820ff44b3ab738e726e7fbc44c6d80e820c2831cce13d386c645fed295351761fcb04a8c69eb2f5a85402bcfac82683bb0631312ccc5b7d4fecd021632a96040acd19cfca424c14509465670581f02d3e2ede2262d569b20a399a1d0dc76a70d6387b4bbde5ee935623e3fd65b3e2949516d6e5e53a7c92f9123e97a3e5c351d9efac04aeef08146540e1ea9e0571e5bdedef4aef27edd45fe6e07c2928102167cc68c28ae7272def04ae666ccabcee94dd6752f98a186b490bccbcfc1b6b7a1945e30bb82567e85cb5809393a741bde2066b12f90178a669c891452407795a22219142549b929db87135d5a18624fec04ef2a44c76d80265f7a39592f17875c54d823e23d03b2a85f9ecef038a1740f37e67f802b56e32e28ca187472abbe756b816be9b7b9c7225dd0c8794e776cbaa818b6ec90a9eea1250c5d8911048f9633bf78936cdbbb1f20efdc3da7b72b1a968f5b2fed4e5290d5ad78c6aa2575eeb64f46819b4b7bc3e7b93d1e7ad62898fdf0f1f43a8c82ccf43111a8d3baf729fedf96827d935b28323d357aadc6db661282ad23d0826caa4beaeb0a5ed485881c8dfc71deb653cd2c1b229d5802a5d79cccb28b09711a3a6fea04da59b4439a3b1ebdce1ded02180c0ee3b86a7f28e138d347ead77b86942da9b6465454c16181b9e3167f6f66dea52b93b175d805c0d97c19302b2f0d9a8d23965e3823c00d5c5739e7046e7245f4eded9a6c9274888b7c42a162c86573a78be09d61437858a9c329931f8ee743f0ff92c825625c37c486e56e3f02d3644d43cdc986745af1a63451e6250463b5709a20e2e700eeb283c97d9971332951fa48c19b076bd318dd15ab496cdadb7db083341bd9ee1664cac8f5d19dd83fd9cffea97a65d6e3d47fdc7afa536c7d37aa7a8feeaf250a2dd48990f1b75f22ec1b58d7b4e2fbee562e4f7e07f08c12d761282b4fce72cd61e4293ada56884be48791f780d20e44102d8c7e3034d3063a27fb021b26b883b9081eedc11a2ff3b6c8b49a0e87d93f4cb6a22d450586404d5656ba98258081a030b27f17240603c7a60e1eb90bcfd091590249b4ba7aa0d4c2fb848df3965ad7f02c965e2ce7ecaedb7139f60f266ed1a335ad1fd15ac064377e1aa6c38225a17a08314f9d2d12968f9e98b6a541fac603d6e97f4989410433e450f56a38db760879742191ec7ac93db82b12e93208f7f44268170054ed5e2f6ec91dd85cbe4f60188f005f8709152a390bfd9b6159ac93179fb2e11abbe0e56a24554b71649c8c1c417ba58d1383c769051988fd0b118a55d0d4517d4d522955719635fe1d51ee2ba64b90ed4637c0460032e58ba5348c62bffb64feefaf5958837b19f70021a7e661335afcd0f9ba0af766a5961f94dd1decbc3ad74a78b02b888902359d3778fad0fe4fcf5fa2bdc34b2e8065f74f5e7b0e99f1d2a3b2c906ea1954907a3b587fee80c25651e30b92bb9d3135cb5622932ef395b99e39b5859d2f86493dc8ccb8478e516fbbf3752dfa64a369d7e23b18ef182726103153e7ce31340ce5b4556bb77369a0b24c51e6872759020bad8a09c053b7f0b3dd8b9e16ddccc6f8a8a640b902857d06e6cc76139a709331e1c487aa0cd0aa9affd3ddb587da68506577e38a7b2fb38cac47cad52bf833a1a7a5f29ddb9ed77242362045723541e445df6e3d32637fa68722f1751189967e36b8f2c5c9d32f4caab044e6cb559d4f7cbf415e491a65689b95458cc7a3afdd1f43f982847036e601eaa47f8ce7d4e27a4611dfef1df10727bdb7d612fdfe26c0bfed5785ed1726d94482b4d17fc6030e9bbf03d5e5a126599bb45a6e7fc7c48f9adb70373026b659e79155f399f85fe9afe9b50f9bd09fc04ad86892d7c0e47089c3bc5d00b744c71c67907116a4f75d41ffc4e852cfdd01391519adcf60253343b9cd384558b5b5200a71f39ae5eab6473546e42995e5dcf99eeb3d5fe83da92f4e6e00a6ba999fb63ff1c48023c348d789e6b8d37441443fceb7217dcef471f21f2e21576d3b0ac662165b032044db22f2c67b630ea89c5016b6640db958423824734af1787bfb074b76f1c4dbeb19f3a0091ce4720432ee16c04f3261577383490bad902b76548531831247b13465b1bd80851e3dd945a28d946cbb89943672bf1046beac877d126afc4c22afdbed45a1d8a900fb77ebf0c2a9d312ce7bea0f5f27dd0241ad19ee60b1f3daa896f3a61a2fd1de6a252d5c79727afca3696affc1d6bc10cf561e45c8c402e6d93def4e03c3e7e834b2f6ae6afa3dfdf70de5146f6865ddc4ad9f712abcf6397424ca3d82952e4019b30c0ec1ba41cd19fecc0a1836fb905164e1243bade06dba2635aaad5fdbb981e8611689f1f5950ddc02cc8a5288a17fe99671e88669db9c7617f300cb9ed3e8c3a9aa07c30b440b7a2b322ecfcb534f25c030074d82459831ae3504e85ebcbd40de3fbf7c31778efcf00a5305e81101211bdb928c90d65199079c0858e71e3e1784f8195e256eee42b9f55ad6686bcea2288ef76bf0c03c011b2a1b4158f65a19f72634d627224c9148c89c26454a279416e04d1dff0e36ed0576bcb18bae1bfbc485e7e16fe31ed76ac1c9c11e902a357cad16a9b9fe9af8749760c0a0158ad77be2af18cd5bed78efdb6eb020377b705d7e956a2a4e54e6a5c706e5553e211f331e275a5e1f2fd8246cce096888a42d69cda2df8562708f2f56803982bdd8106155c482568bef6a761bf32da274a7c723abec2c2ad86161ff0b8bc035e1cf42a84d36c02b8d3cf359a389c64a1d06cb25a0a92710e138578083ab740676d16091feecb7652ed2ea7c25106f34a04dbbedaee1dd9744a1e5bee22308977f5d845e842e10483a8d3be2c01761151f8d8e7296d18bd30f54a10ecbc2c0cd3901c22a19c613c1c91d6fc87d1f980b129b4a9b9fae41bc389fad055cb6a1871343424d16c3c10b74f520d129f113d1f64907be3b1da14f4de437fa3d0e10f20769adeb5aeefccea5cc5536c48829eb4a0a8c4176b2fe87edc68b2b097412d1cdf4294bd645c809fa25d5132f7d4602ba3c4e60fc3c353656394159544ee1317b503d9869379f0e757ac2299bc82c56b2231646350024f95a8da26ab0806226f790b3ce53c5910921d3bfbbfe90bd3cb5f5b3e485b0fcf5c8f6097d918484a5dcda30bde1d82606bec023fdf015772b2cd5317c7b946335e84b1406c52332abef179adeb274ce6335ef7af8d1267a6cbf0ba30fe713c3da634d38f0a9a7f7d74985a0a30e3b0b3a8d277d25cff82c8c1730d4dba27d6874bf1dcb7bf60f56409169b6ae57292461d6e430b8de75c8ae6da946540d72cf936c908770482fb9ced36b350591e494322a7ba5989b9093cf775b3a384b852e0bb2f57011de65500967491225fe3ffe2cadf4e1e8e1f377784e6a27aa6ad0dc69ff1861312b4d264c45d71b0acfb8e3926b09a9fae8f434074cc9371f0b888753567c967dab0d58ee1dc88d35c434829d0e50e66cd37fc7bf9402219209eba7f0ac5f6897ab84156c98fce1f1b29fc4abbca6ec60f79b124a829fcf79587a22dfd6af995c2fff69c82f9c2d2ffeb7b08eadfff3e4c4c0d7bd0bcb7b616f84a201649564789576f9537905a923a75f5d7f1db51bcbac38bd18b817730ce2a49c4389503036981d7cbce04a238ce3b14ff33c5520050fde569340e4821bf4bd0071861cfa8c9aacfc240ca85ed7a40d5866c2ac2c7c10c362c94826ebf9e5af601ab5cd00fe11fdb8f1cdf67c2d28353fd5f4758728292e992f6633d1202f571715e43684d7885bfa379cec14f8e8136ee9357ec3608e7c0f10d379fdec7a61c6a55674ec04e0331a1bce9870b46c30c294e0515d547a30d066f53f2a2318cc0e6c2b8664ceccbea54d68c81c323c3298d4a6c1635a93993b6e37ad0f6a5da417b357ce2db21ca548b76a83aaaac89927a3c6091fd703edb48d5d63fecd6e57e5947061d1d0cc17b09a8f424383e5055b4b97088eba9635c72ecce643823231672841a21f47b7d5a33a848be1ad9e5bf7d81459892c91944b50cbc269050ec279cd80e18895f724be0dc8f105a77c863b16a1a2e37c93fcd65e37a0e4555fec5998f46727ccdfa652229941983bc8aad9d7a107b5ce71bc74bcc3d4e3bc100207e6d0b338d74065abd065a7c41d6bce1423e0607689cd24c960b759ee00b07165c496311102eef12a862189557965cfcedb8016edafc1b1f62a1eff17dcceb0a81a6f7a8c5ee5371ef74e62b809ff2796d484579d61f90b02d5c4b687f2d7183a20498ebd098602911677a6d0edf087e26eb382eb74ee82bce24a50fb2f5063463327b06b574e5398d1dd5686a623f30bd94402aa4d441271e2defb689e3dd8c6f8edf4152aba1b00e63744fbe52a08c83b3bc0194882dee86d58daf86cafc9880a068b3e556c45777cf5d60cdae07e71341b3cb60e88175f95313a36112c88301175d863223241be696c892d051adf628defdef150f354243d2a1a65cfbadde010030b4f6d8b48acbd1bb430852fb7792bd38198fc0a99987d242ac63002f0612ee9287eae39860092186958d71410f44944df290e8c9997d50d5391b953c6fe526714d9b9a1b7a6e76bad3db8c9951a2c298a90f822f55bb3fe612fcbff16e966872156ca081d1b365230cb0db53d9cfe5bcc6974b019b765c516333d0b0ece47258ccacf3a538d6aee62924f49b38ed3c8f14992e576d53d316e583ad5d151f115bc067c529e7ec911e07b6ccbc02a5b48cba9374dcdf773b1d7eb202907d04dbd184afaf176cfd73e3249031f70ad8382d68d02aab793ab2df210f1ca03c035bb8478793a3d7ea2d4db0155bd4ad555c400e9b882106715ed9095c1f8d1cf7a963f0ad32bda4348d54e0d62903a6241b9eac5791eee8dad2a705a0fe7c096f67cd42005b4829598382a9dbc6c3a8731ebdcb02ae39ac192be3882a47b531186ebc7cdbb42a61dbc3a133b549bda4813cbc84f320d5c5b2aeaa17c55374098b8abaf2e51b573c65f3dec29a2ac0611f278b8e06a13c22aa527d31c7a6b50814248a0b410bf38bd04ce6bc6df198357b1284a1717b49cea3807f333ee822fd6b6088f7e64ab934a7898c5dcd9ac56813fac0c504bca44e4dc0d340c3364bacde1a30212816a535c9b07720b156a946a7f049b1be623460064734acb78fd808911f36561b8ac1079c1dde5e22ce7d12a33351e270044c40e2fa1b386d2ddab06d9fe0c075b8c488072acb8d9bf5568e8aa904c126ffa8350ab6bb38b58c26f1c93cc10e9a0122e71d53d6542dae89e5b0cb261a79e7df42d47ce15b45f8ce1643ad3b43210f6d90cbd418749bdb2aeceecff45c369b624459a7d2aacfae65375738e9402aa13c6b5daa8ad283385af15483bb46f157e81842316b0577a0231b52307ee7d9e519a79fc8fa7530278142fba2c4d4047e1e20ab2dfbdf49dd4b57ab0f1bd865d2dcc573304448eea943fb543f6fd071833e1181b4a7a038154c903f2e4d6e3e2faaa8f4358a8b68dd7d743b050c5af6297d74666c11446642fc2e475673da551a754d33edafbd6a1f2e85b81d6f717b0d91a16c631f197228f42782b82222efee8cf5c67b3d11a5078a7c4c3f32f7c7e831b109e7bf2ac2870608e4d6a9ed020c33f30f5f00d7d8ee8bd57db8ad10f16fba8b1e93ac8bfc2d892daf76a82c9e372ee6e672f32d77c86cd04f7315ac23c6ced7e0bb50ea7845fd33bd7bde565c5577b13aa1f5395ce5852181e27c5ae6516d294f4b678121cff46e2a8a3a301a2fb23bac131dd3aec2c89597add04d2c94ac50c8ab276d35c216d49b8be9dd6d48dfc36d2e8da6c57a8eb6c6731e671a3ca13a88fcaef0cee1340a2767fe9f49d68ac9b7806d4cd25cb88f48826609018578f2d3d8814a81feac8ec7041a62c8b7056098c522f11809571ef1575806f7a5ae0ae5dde4f7228193dd3640e7f42aabde7ec27dc46d7d823febac60d20ccc6e33f97d00f90cb3aeb8a90f2034b766acf82102f08308ad99a624c6220972dc8dda9daae279fde42f2c83f22e1e9346281d7696c47637b005b61d8c2b73a1bdd0fa67cacbdd3f39f912682d2a1028390a4981c8b6cce7cd0b57a9c9d73e92d34a8324616e4cb71f6d270047769c7b180e5848e6f4bdec201c0ebcb4784e54b29c3c8d31f67e8ecf64b07975cba7e84c33ec0e9680b30b15c93e875752d224f12d25f5dee755b86dafae43b4015d1f1c08ecaa48f410ccab98fe23c7022233894c455759804ae3ecef4a70f03b3e5f23101802abb36036b39b9f5ae206e751a0e2c70db9718c5bd9860d71b3d38a1f586a0d8f4a1c24ee76d7c1584ab52980232094098efce6c6cb979c9de81c1b2d75ca5fd9869e7cd8b248c6f210f17c7c6009bee9ae8f448d256b6fd012cf6ccb6e19dc668a0607ca98d43446f34a3c50cfaf75dd7a0bbdafe805b6371ea28f91ef9ef990541ce1c522c2b3ba53a6c834054d93ad88d7077f2e097196acb57b9e9d0e5fd676358ab0798be1e8e03616816240caf6376862792fc3385680e982a53a21565f0e2c219a72f74b157d88571e7716d840ece7a4a4a9e874af24d26361bb1b4367681a63dcf6f1165f858d1e94a0d1a37f305061f1bf83a00af5737858cda7e7a1a60dbe7482f71c9be7aed47fa3b98bb638d0768341e3bd668d09cd56eb9d42a809e2d33f7a53ecc581b5c02883915a64a8a7c9ec747fac883f21fcdda66a33ef7716029112c72d20a03f15f34a4113eed85dcbe473b470fcf0b2720d2b51f68822fc410570cfabe85677d3acb6c6667538d960832cd108ab3d3f62bf300f56e7364454556440cb90b2ddb998485c761b81a5bd17adbc8077787d43e7d4aa3f84d4ab62e0249b65c7ec53b632cfc999bb85f78f98ba1f45dc68a5ddd76b635ff770261adca2535b7932f87d52cff824d2df9b9dd7df6c2357ea2474303015db2573cf4a1403cb0822bcf03d8a45b2a28ffa4453069a1a894e8774a1b2c18c339b9af32ddc49188b84c4dc8fd62a59fd54b1ec99236fd5333b1efee8492de6feed86b6d887a180b9cd694563aa126acd76269162cd92fb981a42704990489723080357cf304a97b9052e16e38e09f699500e6742adb5e626aa5d610f539ddb7837df5b1547702d542ac07d17ebed4fd95ac885c8e150940355cae58f91c94c591cb26776d43152efdba9f1335a916247b4fbeb5ca2e43a63396de889bad09b3536b297852b56701a01504b4f458be0925f478bff81ed8f7503071f6d4512032645bddfc0edbcf55da84397994a5d78c5ffd4b3b90e5960a172d339333d8b1af11525f86b47770ab3300cc6d2dbf18054b8b27c93de9dedbf0474031e957b84e9c02a2b8b68365dc3f32c089cafbf1a7990a0c95544a80112e9c65aadbf7581536f50f450cb69135a5e9525b3d69b02e0e27d2400ee2e37943335af5a904cc32ddc985a5b7bd1eb4b281f896a0ae9321dd71a6bd4af1577ff7029c67968c6d2c024cb6f431c66f31f6a7e7f9ca855affcb52a2976093dd69d1a536bebdf3b0808726ff0d781c2724107abf51343b868d4b06536874cfcee7203e9bcae6267013adeafbe1c83457c546a228a3a9fe55748d432bc5822eb93bd3f28a29ca88cd8b5a9cbdaf5df3e5bb7b6ab19b15031c74866f8b1546185dd6cc9232c373e18b11953b74d86aeba8f9d8223973e06e68c624e78cb3289657522bae7b48eaf10acab45b72c1239acf66803fe26fe0d63c64502663d94a646477a558807d0953bfd9e9d080318561357354d6a74a1d0f08a02911a68e8f96768f0badce6173faf47699aad3358b82b05e41f306ebbe38ecdcba13954073e30722cfaf2704cbf938fffaac1588e07c72f7282130a57260f362057c320e98488127b40aa9f901dec7099df6493f288da75690a03b7c97b4377e1578e7a5cb90fb0730096ffb3869e7244d957199c81237549413a55aa0283affbd18d6a96dc1350f36fc403ba8696ff735622d5170b17d99618429700de139efc66d87143ce8507475c874092a9506fa0a071e6b4876f931440cd00cdae75feb9ae6cd8c28492831c80dce56e4719828adf834d5a42512e77b44690e072c95d0eceaa437cb610b79e5da90e23a30fdb00a1418dedb1fc6d49cbf8b61a49c7f642a02c49ce8fbd03dcdbfb54216df46d237a1e6fd2bf7bb7d604a09b394ea34b69b960140f30253ebecd6badf8f6eafd18c981d8af8ff6a6c854ff0c63d7b79c26e58345d78abeeb1c95b36b59c7a8f768c3925f477120635bebaf7f1627c8fcf13df595d3a3bb9601f9e98a7fecf03520df3705d6f3cea002a744ef85cae5058318ff07b75511b8d27630ab5dbd21204a850336d9ceee2ef7d8c60e1c4e8e34cfeb6b9dfab376db6565f9dc89d9ff342b6962d16c246c399520dae024396f7a31cc3ace48515a80d4efea88b5d428a54837a0c722a8bc29d9b13caf1d6607a65e9945f8a7c62ff1319424113baa6675c4a395514c616977f31f4929079cf401a54b0e770b1bb91f9fe9bcc3ac13c6a37da6fb765a1997e8c0676f309a027eb237d45745517790d2bafe75587c988f9b4b303c2b6ef890d5644d8c895a7a300896c1ce08c5555529a74195c1ca49720c776291d226a922138a39f01afea579ff1f973a37efdf883fb9ac0c00e5baef48b041b8cc641449811e5db94f5a7643dce9c188e766091d15a7c231e7634f35b1a23259fe9f6a9400b417b5c8aa15864c9a04b53fd3b80e88701721dcaa406543709bfe3fd4f3af41aea704d3069e9c0cecf7c3cb64bbe76f62204e9cb72762bcbff701adf23417ed9adc4ce768405bb81152e41599057c121a524e62f80ce772c609b0bef2afbc6e7c59017ee26a7252afe1ea33783ab529107ade04a9a9b78ea8c9885d5f0d5153aecd7ae046a92262830e6301a0d23c747a77711a38836290fcbc40c1e0422b4ebccd7c30296381af8f1930c0c273827ab3a05a8fb03444009785532dd0a652e7a10419c16f080577c7db6cd259655ec52a55901515d8582d33c3a158537d7d23fc61f0e72eff6118568dd8ebf45e63c689060744b2be01dd1ad0abd1301837f6dfb821fbdc7948a7348f6251e079a66921732926a06e18c3f375cb14a7cf7fdb788fb914f8e7fde12a309d49821b62d2ed24b8bda66aeddeacc2d0b916badc1684fccb0ad192ff9f52a783ef7967067514f3349ef55b4bd034137109f08b4d958896465cfe932f6fbf8a6c579d45561f0709ee21c9e099472c71810204f1ffe77b6c8251830c1c852c714cc00de96f99ec3327c2a26596be73cbd00661b233a95f894b60a7db7b3132134ab76f4ca04f5c8dff88f7f9811c7890508b87a4b445afe9f857d1d09b430ea5d965838b4118197965c9d015c919a1fcfdc4751e712f7629ea21d3b9879f40046aa288104be3d97e3ac1c2bf6bc3440203892c583e0f899922bcf1479843c76eb4ec9ebdb8799bff78ba51b7850f74bb464f7b83802a5c17bd4dc35f3af360c8c8084d2debc5c234ded375c6ad49e2ce1c81db385174a979077dfa892302a66f05aab4659705f0961abef366fcbe6a2e3fbe721c0f5b35f7ca9160bb58bf2dbbea0239676b230e50fff574d7449c0db352ae69f3da7cab001f73ed7dbe8f0ea11bd3a142ee3a4c27d8abcd23d2b797b9615893c5ac22fabe40a7b9a46ec8af866dc79fd6520b50e8f45339a4e0156794fc8c81c0c9e8390650bb95096f57ea55008fc2633f853d13e822202afc4a4f28a9b2f74c9d401146fd77bca3a8fc40e4ae920fc9b9547a4c530f1661e00425869e77afc8c0afaf80053299aefe4382ed5531d876744088e9dbe8489889e43e4fdc4fec7f21f9ded97dc3a12f87c04fe3f48cba0c1e25a973595c090cde633a61549b090050c007f8d56f21a629e63647c1c858cbe11d3192c902a7cdbc0f76f0067598cd4d85f487f9fb053d10e24e3e9533d5fca8c275516f4fc5b3a1129044e85aa43e86db290ce64b4f99c7ae6b02ef3802bca448c528a9a999c83ceab064eb94d6f765f14f619c9707448210e5b548e85bb3c2a8ec57b8f4aefc974a1440437f8d8f9880dcaf5c8d1f86aa2830067df2d6d25ec8bcc786a362b27a0a41718907945c6dbeda7a0e86fad3e3f1be9036a0d0d9a9ef4d5b348c5ccbe4f7cf806dc9b26fd3572374ee516e9ebb1915905b350159cdfa0a09967c4ceffdfb04881dfc5621a1fee27da7c97805fc8e30949b5fa97dfaec4f927d274f92b401c0c498050180b6d1d20181d6a66ba5b78d3aed33ac0ba2067bee26721119c62e4f1615df9a604cc3598aa190316ae2af8f58dddecd2fda6dc812d6a388f90f995087705f0cec5c60b99ced28fa712a6475f31c697e26fd0fb46f6762db12d8426826cc3ba1fb26541105528b100a531d25e6386eecf16a462e91197f2737e641d6970f855caa53ab0e7d4cc35ba9d0b618ed41759d0bbd35b5ef4f703e35798b9a8fefa6805f75cda38c4baca216a1b0d5e2436d95ffd68a1ffff93fed6721236380f0c869863b9a1c37c38b1e55b4a122bb32fd54ccf55cbf661eb72de054454674f84876cde902db0967999e39132a3eef4b4388af8f14ce51cda264376d39531b00910fc879c7b5f78bdc4c8ccfd37cdc3ca7fe634fa2be763a5438ce327e155dcff00a273890076127c15d4228e883482151892bfabd30d8ab0ce3ae4b7d038e9991dc90a40874ec3c787a5b67ffcbdf5ee6c8f7033f2dc8632d715beef2df23874fcaca1b45853b63636e2c6ae7695549f0dee244e44d7c735c8339181744d24daa145d79052bfdd8ce9eec95c6ed5bbea4060a149a294df0e537376cd590d8e4012cafd9bedd6fe416031a011ac596a432eb6218e975258a59c860a4d3b25553ad55d8004f2f6c9cb3bf1ae977c75782d9d80854ab91e5aecfabe0849b9193726246d4b53801c1ed17b7e025822a39f13f45555b52f6708c94c82998683312568533eb27eac1fe1143b160a570cf2c7531cfe2bcf06dfd1d123b107af2cb1bf60c6612e2d379985f362bb01ad587edd03391e6baf072c2a6228e1d89f8576c23ab812a3f20672e133f9a9f206618f39bb2b401aff660ad5e53365ad55eddf6476f68d7badec695568b09dd148cbe37a322b2bffdb849417c893de4df3acb04668fa80332ee513ee32cd51ca7a6580875a8e0418da866f94d4c18f6d5a50e2592754423ce860365d8f320d5b24e78f0cf4824bbdc7010af7be40191ee721d66ba7bd9639647f07fe503fbad68c5bc2ac0e21e37682b4e2212b4ba92a8b9eb95a15daaa4e6820421d1d1a1f30be6033c85ee255d151edd28618dcfa450c469e7edd11bdaf065b92dd7f2c4fe5f8d2df12d9301b64f8b669a4c3445f03fa736ddb2325c337a1e476bc0bb4ca20cac43d278e7ba6770a21d1fc7697f97392f4f15d11bc223bbd0045d111c08af73fe7b8ef8da8dc2d39237d43dce1d4f0357c706cbff15d3592fb5d73015f72ff4099f8e4bb8952937d691b54653c77a0a58fd92d6f8bfd728433c691c2811aa4ac5a6f5b8564463e8523c4ab2b590728474836d023b4f95751c1e5b1b180d6f1fdf223d7e9c3fd2d37e844f5fe774116e9dd9dd1a1d68296dcebf6824f81c4785f39676b6bef3835bd6d839b4deae00fac06a319a335aae3c24fdcb94b9fd0c6e9c4f6c1e19b31b6e10a03f773afaf7d74f7adbdd832b3fa88ea9e7d494a0bebd9ba3698a962f87e248df03a440cc46b56d1806fb0df38e2caa1bad5432228016c9ca1ff63b767acaf3ba01a804316f845deabf0ab32d7c144a4a5b7a4e150ffa6c5ceaae03028574c56535ff6aaeb6393fcddc2e0bd2e6f5e7af62c12f1b30b8e5e70d8ca3fc95f5900a8900698c9290beb9f1c9fa6a69d31cf3fa666a1535389decf5618ee1b49c340fedb9e4e5ed71633776889a6a443ee95293f1448a4acd3a5fe216efe593bd5d18e675743df826bd2b17de20c96bfce283cee14e7e8012ca4246676d489c32f5460e6c0c20268f7827f6f18e58fffa15e67443d335e05cba02ee802d614f8d905983684d013dad5ccfae3867857e4939ec1449c01fca95a344417e48c3ca7c5c6845f9fa5ce0fffd60b040d2fb9dde26fac3ec6199647ef7dc2fc71c9df602b6c0c573c3e205eba39ae9d57a546a44c78e662fc5e3a8c0013201319ca91ca82a5f045e05b711ba5949d570d592ecee4edd1eb04f0e7b418009154a7669ff392b472db3c29c821a3be6c5498c237d44c18653ed6f667343af415c21f67b3114ed4964eccdd65b261a9ec0e1f02dd1fa3dc517cc2562a903da10af302e3fd48c8d5b17e804acbbb9f6b073387aa20eb4c92d86d28123193e5476dedb61b4c0135cc3908219fcbf23956b0316554ea27101cd72f063608747b7c703f2d86d705a52885d2fae2599f76144a02169fdb8cf49a63098802742feaba54499d19307429e7c62683e35892df453075b056438bac63063a69de659a2030e58f731f952a6e2451e9e8aec0908234a043b897b57241e24dd59dd28aba82c6f6d73d096c8d7bb7a0a4a882ebc4526fd1d23e53b2c3ef623dde3bab36cfb3abaa0314b292d9112ce51a4466d90505eec4771dcfaddb2d0d1ea565ef52079152ab97e8dce914aaedc5d6e68c1081e22dd68ad69ce29677e47b42a5d02590eb2f90af2aee8e6fdae1cd0fa9577ad5470d3351322889104270c07b073b0d42f703d57d96ddb6335bea639657c37b79b59a9fb5b3d8cc8027df80fa34b54aaad41fcb0904d21067ec079948834ac42e4d4a90100ac2a2cac036587680766c966efb8bf781156a5cf5dca5442cfb77fd1e24a11037ab94fe3721bc8573e61d95fd0458f548bcf52549c91ff074a78b87456c6b1181f43725575c85ecc7950033ec32cb13933ba44f228a7e92b01da2d15bb5a6652b7e7b5cac9b66579e91b62fd8b539d112b30cc9dd751775356e9a3f24dea7a879374209df2bd652e83e2034a380624ef4039045061f872ce60aa9b02cb2110e76db4ba2232459c21ded01884fe98e5a3eb20eab2037f9593eb127c9fc6244b7aa872c8a7456a75895246341781df1ed65d3f5474c7fd9ea2f6f296d82d299d87ad2ba33737941e2b453aaab98c758af7471fb5b40ef4a120fe9ba825d1dd6c0f15e7943beb9a182c26495c8899c15a79724ba97fc7cfd99ccc9890e1e19799b64e9dccc9d7197af71aa229c38885a18fba0e68c023564ab8b91f545a537f2605e48bacf3f3563dcc55e4169f393d838c35291cdaa8235e161bb47e61ab1649b7815226616b493b80570010e364cfd678b3e2dd56b98322bf5b50bfab7a8255670b6466170ea2a9d3c4ad42db2e30b5343b058ed0efffcf17cf6cbe7d5a4c7984c5379b42b293956183ff4d5174abdb52c95ce97f5311896f41f550f92b462f49813344b747e4ae933d4cd8a3ddbcd516c79678f9216660338b2e9ea7e7e3832a6b609c3403fedf968c19640e59606ce3c770d2f869a314f2370c99e72259f96046d907b08be428e02e10535cd0a27f62f95c1306af10b75440e43af892990715a12a935fd7bad7d48b493bac655cafa521e5e5e83ffd474a45db5fe47b62acfbbbf2e26ad03d8d5a91c10f7b392d38e01cd4d20ac14d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
