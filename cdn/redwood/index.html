<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57ec0421bf4dced9eb0d4da9d61746f91a10fdfc008ffbff91ee0e2224ee189257f9fdfd891d0ecd344b5b5a351d2fbdd7440d597b4f3b20e0fe80d659a7b4f7836bce3ecb24a9d0e352e60dbbdc8c54b82ea9c2d0859da901647f287bc1eaf2dbecd4327187f8d9c053613a8abbcbc555667ad9d9de5fdb39573a7b938ff1f84e075681df0ae0d32a8a2d15f3506b0dbbf9b66b797fa0856b15d133c183787e059a5669a6eead7b04a82f13e631b26b9579783bc278ef0f00749adb6cc2133d51106e3f29b818561cec8c429d2d5a36f08025b20d2c8e15aa896ae61ed16990101a8d78f9a485f040f703b08d716747b87d0801cd9abcdb4b9c9c65e6fb97510ddf2d996ecb4fbfb22bf0df17245d704ec8b8b6bd8be4969bfc54dcaf30eac81239438a7b217ce8310c8c2fcd3f7cd1cfae82a1912bf00c01c8bee09a21b1f697901752ca7bdd8d53971a564f45af2a8f080ae5d6cd2701c803fbe38c2cbcadefeea6a5b92af12c8a30fdcdeb90b695921b3bdc01c5fb5796f62650c4e9334c997fa3cfa291ce91f2ed9f946ae2b0ec4b22ef3651f9f42a35365f75db107b4f78d8b5b5db15831a33092d70420d6e2c006b80d4592e1b0bcf2078be3ba137d7e1a71ff7f19f1fdebd4e2387d0bbe02d575231443487e4729a10aab7af8f2bf54dce714bb06c8568c53f9afe76a1970e42f6d65bf7e219dd85f7ea5af31926441f336c02a38a60a2723eecf5af6acdf6b60c511fa81e1740acc1186d77f0745a5578cc41a5bdaadc65007f9e081e1331db321efa64cae37e92b3bda5df709015872a72c5591f7601a1f79d766a796f93c36f8ce8b74b1bd99270d8d0ba34b9ffa62f53d5fb463eec83e9e40e0cf11d371ddba7346a6934b1de5917a65ffb6557b85a8606ead9c996b4907c99a2c5d5d35946ddbea455853a8404f41008de1a421c23c67c57d07d43258fa73e277fb76d77eb347ff1585285ad50b44d78b2e3e92cc4879031554a590c0638151879b3b842e1a43e50497f64bc599c45cd2d152b799c58ad6a531fb3bc6c55f03f3f04c22be22cd65b54c37c96e7fe73064461d4e8032f485a11e74f9cb618c46c65649b14800f4e0977505ca7ce89a6058a23072622795a92f369d7ce34971279426a99f80693d3b0d227b376d08e347ea6d511568d80daa0b8bfb21eb4bf6be5cb2b776fd5a7ff15cca1143c46143ab4aa9d9fcfb36cefba8d803aa487953302ff3eb4eda18e982e2338247b01a54f9faa3a8ffdd589b0dff99201d4afb2c7959cbcaf13352fcb7fcc51eece57999487b450bfe88c0fd9978d7351cb6b3614b6f14c3ed50e47f2b535439318820f66beb229b198c632339553940667d4a68c7083dc58c03ac24b459e4348ada3d582d8c54e4b4cff0be70e65405be13b4f979a7574ef019fece3f6a89aef1a53a467aa2e3f864a85c6fa234208f3e973ad6d80848d5c09ef7edc1e0f721548f5c41fb706c149176eb001a3155aa0d0ec3e5d1ad827212745f1d7f5e21922f133ced9b8f80eef2c475f0c3b93906cb078836c55a1f2c3cf6eae4e8f480c0719eb8ba27d8c19897de81a658f9727210bfdb834305f6f302c43b090f1132ed35d1ee0852918c393da07f1f56570c6c5f3a3dba6929bb1477270e11484f7c742f6e15594bf5af0e21187d002a78d45bbc2cfb4e6496875a130a879514063abc4c69c8ddbf8e23966050bd869f9ad1181368c686e42499c0fc31ac937ddaa3a8a55baa0d12fe48403036697bc73f0024bf7b1e49fec4c9df1dd5652f8a9ab0fad75b18208616cf5da5fab4365057c4c018862a70df2bced59ec37487a2757074c64d00df6465c4529fc645cd369056c33176c847fcdc31e4ccaa155b46c9caf7e220442f86b45475763383e7d4835b6bafd9b271105cbd7504b3d960de7906752fe4d9b35f940b0e8ac23721de45be66f8bba7d12727525904e23f82f017176fe440f1156d9730fe0b6ead8c93607820525533394e9ddf7432231611ed5460a90b0a7c3afac968ba3c737503173e6efa764d8245aeff4aba2f9235e3953889dfe032c3f9a0abb98249f13eb88b88c0bb99dbb26e017bdae3db6bd294aba73fa71f7806f9d0589923968421e1f15bf19ae10a40677daa23d0ce73ddd75027ff94ecb7b64091489de8b0335a3a70de40535e4719e1e52ccff76c5f613120f79d400c8fda174f12100c831b874525deb90507325f8c123dfd76df27bc71030bfe69fe5655ea2033500f306d105a61be6a75f37dae764836136eb919bd9764e0ea41a33b237c27e3f30dd1b83b0bb963ec1500e2454fb304a67740020f573e65f2edaa685a2050ffe795de4854b1fa49e839b55637af304a9a41eb28d2b6f68489dacfc066b9141546e5d8015a1b542766b8df59792e996f95ffea6640ae280ba16fa701e8595c25321b51f96155871c2514f18e5b81113b3681595a1b411a57af4f7fd766c61f191e32ac7c7cbff34ccc8ce7fa67791fb573cc159496015b5d5e476d603a1b2c31647d86d72c7cbb564fd5cb81c835c60f15fd807c0b2c3db23c786fb9c6856f3fdf529a36592de85f16ca8999c62df90f8085f4d637d590654c8a5e176276493fb18e9bcdbf4e4192f8dee67c04f949a1c4c76f386dc1ba5ca0b9475ce48d761405abd002e6d61930cae03f021a25d1e800f875711105e4fd94d7ab58367fa20d7e65e6915a80e8ef4830dab2efce640a4203f4f42b69ce81133267d90479c3e199118c36edbc05d5a796fbb2ce11ee6a874413786f72e67eace7df2575b0df183489457c70597a61df1b30f88eab4490c5c988d3b160619527f622b2372e897351a36eeff17c39c1bf13b9c4497a9426bc57184227a44aa42c462021b8b81bef96b9b6a8b7d20944ca22ae69ea63ef05cb3dc9f1562f0d93d5997ab14c1080dcb4c578935922ae7419f3d92d300be58958af0948dbc6dca0399d4a46e33546fca641773da118a138f6778b6701107776c759320373097ae68caeadb4fb104322436658560e933ddcd546078a7e56989e2991f81292a726f7e03888d10961ff8ee99728f7e77124306c16a43e987b6bbf7b55a9608e83416a92e29880caa1a085064d51d37a7dd69861058a62e5edd5dad1c2c5d99306e91cd940a95ad3413645e013bb2f6a9f1efb15fe98e6f3c4ad67200a2bd3e508e8bbc56d4426cc85f3ef552dcf7779c9cea8fe1ebe5f5c3774b59b7e1f051448fd928f3fe5b15fb43fd3d1d21daa9c873e9e156cfadb8c090db0d9fff9968e9876de03528c3a7627961c77cefb5a6614bbde9e38bf3b5b3b261edb29c1766bf775bcad459d53bc1c871fba06958112da64a5f490183d7273976774628327b4f0af90cfa3101ffb5fa72441d53e87d5b8b0fdb1ffad401b457aeac0a9651f9c45b75c12651819b6183a40d0d0b29b52eb700ccd1fb7cfbd484ecdd20d2051e860a246a2789fb63f2627f10dc32b6c89aaa3caf2d9e32bcd6c5d3fb98ded784bc834db1e0edc54ea774aea21e42f3ea18dacdae21ed26f47003624d9ccc83519e7d01eea8c43ca6ca00eeb5baa3e07b6da27456301214a2459f837c24dc89f3ec1387a9da5e196b11a185e6bcab444faf732bcbebee2b4cea2276fcb992df747b04caa6d8b46cd1e75bae9a5f7ecbb3f8cf382ca4257da87062e55420749719dde52a9b62c26dadbf52960e7afcbe2f8497b4a0bdd192e41bde4da3598988ca4df200fa53108d83c085257608a73066327b935ab4f03f4ef8a60214aa80c8e0872d003f77c179aed9e7cd9dd3f9e261146f3e5e19f502cdd0335d505aa90c7b4ae5f601a01a3cf2614d8147796cbad5f59b168db32588619b1848897282c782bc78378e66db4928b95f28e2d0067a4097a649db9c564787071dbf6ccbddd6744b534f666fdae40df93054bb0f913201e162d659f6523b571db4cea87c345c9c8a3b06616ad710c0e68df69a8d15b93df9b25f7a61c5e8dd6620ca8bbaaf66745b373d73bd3637c8e5094affddb867b4e5da8d629c73ce5a643f11538d46815873f7074a149cdc715a4228b6c4a60f59422205d15fa7761a57669c608cf5bc1a7e093cb6a6da0ab9f0fd259d343e4695bb4ce63947234cebf5b9d1eb0aef054dac773b277140f3b50f80608cb8a5845d8b3c67420a355838c69f6043b87f812f453da1d5aacba14aa2b4f9146c2448909d641c409d07507087d58f90fda543ff0e328342e586f4996230a391dde085722d6dc5bf820fe116b613f2a5834e5e3548379cd935ced3034a4a568fc7810efa010db9f1cff4d2d66c4acb9979ebd1045ee24edbfe8f8fa24cd81970d7365e14aafeebba864b22833fda79b4a61fd76b0ea25901a742f0d463c3539f052d1561a665d4b2f0c335ba06f6721eccb7c018303a07a2f6e58e65f2bfb64a5b0a03382ad82295a4e4b5abfcd2933dc7219069f67a666a594c8e1d61fb45d2e67bbbdf7062034b9b147c58844863f328cc3d4593b43d55ee4b152df86da70a789e79798ebd13959fef8bd3a0bf120b8dab3888b963703b08dd118b4b72f2fb6467141007fd11b02599e4adb37a90aaf082b4517821cde705992e333eb0d558b0a4953a756d93453f33017a53acf709a25f1f8a7597546a65810d19a278aae2fe88e36fef56d2bae27d0a49d90e63aa7bd36e9b734c6e76c7fc137a27e0e8b2873e06c0d99c1b8e4c678b4458476e71ab79a15d5a53969b2829c76f81b834b6889bd6abff73a89cf470754b9e53d0c3de9472dccf4d66597ed63391bc791ad2ddde05354b62b88f32300012e25a3a803311a6b431da0ab24926661320e3d05538c3403c17baaaf5297865c85442b8b5fafd6a09abf000031fa2ac976d0500fede91fcbc44c5fba1d6f4691954d86263ccabe050f41cbef3dad66e375e749fc185aa00cc801f4ee3c97435bf7e02913a81f417a867400d57d4aa3ba118b8e20ec7080916a1e5089b380aced01639978edc8254284e9cca8de4af17d54eda059fbf024100d707d15ee4fab5a7ee16c1980223e3f01f5c3e1fba9c4c8ee347feaaf5ac627ac37a25a90a313d038e69c8881b9bbc8bed42161b92059febb5e8593357c6f43de3b761985d5d073146df0fd7a94bac22404eb2a67ac511d5ca62c3379ce540bf27459ee9084b6495680fd14c011360d4e8978ee4f88bc4c3de7666c6f384c863d5ea6727889460c27be7667a10414182299a71f76edc08d4e48f776d287e4b7266eba888f79de4de69f5c7e10c2a3807efba8cba864688fac106df1f244ad91621d542805ea42afd99758740537297f9709cf7d7ffcd1eac4b5afb0605b6b91462af8dd96094efccf3b2f3c19c31d3eb210575fd0bec6e63a2164d2003ab202d6ae4813936173920de1df9f97c1f1ad49c09e0a3382ad3d648cc1655da6d33ab76aaa0585c7949328a6ca5347fea70bfcb59e45642bacf280e7418f5cc5ea7ed80bcef077bebfea0920e37ee3c5226e2cda6c1074bc7d4a388b88599b2256182d8503d60e623064f59142d3083bcf658e47db3e0fcc96d44047f77919946e57979e026d6622f30ee016935e04bf23c10a408997077148e91129c371ea61c3850e40fbd872de9c94f3167f47a21c8025fc3dedeb4f2b8a9b8151b15f1a90d4d29d3d97eff863849ed4761918887dbff4d957102a755140683b21461b23fee507d35f3215a6939a030e94ca50d26af03fa9879aaedd3308eae68f625885d4b06dcb506d815857faea427573ee6ac1fdb5eb49f7198c715f0472f0c6d3f52e40092819d345200377ebcc63ccb0b670089fef3fd7b277018072a5d00df53ebd5b8fc9945df4d3c7831651a500c72925a73f1d4e1f14ce59da214acc54cef315f8cc93704a70a14f35b54a573b0622e23c0b18e2513a7eb06630b0c56af480836f6b0799365ecc88d781d0bee3294e65f51d63771c85b4fe347e3f0cc8d14cb10b949000cac29f3077c2b82ebea10a49d8be3e9d88b1f4768b7d194f52593034b574afa9c122d95dc524599f1fdeb84cbd85a9cb0b7e8804a11af3c0481ffc8d26165f252f1ee19ce2e3e0260524dc6a5367b69592e7c4182ce06393885b55ae8fae0088b61acbd207fbd0ba9c1deb91f67d82266a107de4b89250140e1b83170df9d9fe04c58aca5948a63350d95286281b8bdfa65a4dad603499cf6dd33cb8ebe6457b8dd82b159c63b55d1b11d3c3c1bade32373f678852a18174484f3797a4a531d9c0bc9d6525a9e71eca86cf36c05f3d5514eae7962776ac132c27aeb6da7c937a01891b5ea5dd16355c5b620ab938bc088dc9496dab8b15d82dd8a755c9fa078075666d0939f1f800ef91f185e4cecab1b9ee23e9a271f49757a917fb0050042a58d437a3b608bc8631c358a08055fa9a322297c1e49338fa39873b6146b954765ba406975cfb14dc3f5390e075ec99a57850ed2701a509567d0004b630139dde8f0e162bdb1e8776a1e6691a850ecdd3b300176767b10fbd439d7ecd6add036ab1e6884782ce021fabca18ebc81a261341f858c94093eb8acfaa2f0f9c5fd8da0c25334bead33546e199e470107d2723226a23cd019db91dd624987ef078b46620332f8044e3d6c82e697ef8dce00c862649ad42d01f03280ba59db8de61ff73156cc57a800ced7dcd1e46a2588fc1700cde9db854b3ad85146cf800ad2a3e5948142d060dd0d4367cff00c4bdf1e7d6c457a696f1b4e74924ada42e7489179b55f5a5b2fcd9580a1ac73fd2bc78e058340e2293c4411531eb8e6b061aa67d87820e55eca6a91b145d62b4a955adf01df4141526dd3809a52af551cd8bdf456783199e4d17c256aec542551233f26c2d8205fc27c2a25a4f912e49a814f5bd5f8dc57f88c776aabcb4a637e34278af4d838538bb66791d8417bb37a79b36512715230fd755df471f94b0a74d20f0df68a06ac03dc68c91a39415408548e0ea30059ce71fb9f6a90747737995d61f2cd8234972edbb18511d04e4e1670708dbf313c21bd1be0719cf1e2fa68f5d462596ce060168640eec1164e671c91f881e761dfcf3483f3147f5ef8a12db14e333e94886008862d1534e79bd5217c73e9111bced56f273a726720bc552ee3b4d4ca6a9f122b3533b415ee09bb79a0ce6abdf9639176c11c2c083d317255640211c346daab4652c1785795d160299e33eea1441696e215f7fae91ef242a0d997833591ff83446e8ad7519995269a122668c23f0b1142b7489294d24a2975d4da2097d59c6ecbef21e178c5705c9bacd4413b5e51b754de311e2411fe10d9903d81ed252892e2f0bbac50af888cdcc666abe4278f10c427c560cbbd8b82306ea075af8ce7bedd4e0b0bd1f0aee09e047599513a90464442aa2e3b0ad70d514e149a6187e563bc4b01a84b730bff0cf91e7d7b5f3faf596ce090e83e9df0e1df983b83362cde9ce19843672d94a677020d146f9eb97a1e987a409ece8d5f3f7b07b7f170125f3038430dfc2d53d5731c525761793748693a2dca7866488df6223b1676deba7d8a2e06f8d5faf12ce38eca36d6c32a2dbef352a637f4139bfb54dfcb67450a8010d3dbc6c821aa0667727f18e3abeb5bb4df2e9f30ad9098f2a0994e9ce8c0c6b7f5b661d5902b0c6485d7a6cfbea3d148d49577fc7e0c1a8aafc88e16ef6720cb290a79fc94bc77a10290067ed5c8406b7c045b101405ab8d02b42ee9d71d1aae793b58598a584a25800bfc6de517afa459876a101c639c94090c0ce535e78351c107fca185b3bc973f18fcca2dd04fe0da6862a2744e87f1490dc6cb5343b65a7fd0a272f807da9759f6d09169665f9ff9324153f3ee12fff43dd839efb129227a00e9edb1787dd15eca866dfb48a07c4173ce38cf33e20a1d30f1c4421c96a7bee444ae63b093a0d5521a72de43c9233f852c1a566bee417c4b18c4368a1ccb90896c8deae875df4bba225afda6e36d2e9a334a4bea7508f38ef06fd633387cffcc8525ebfe4d96ed592df4ba21be6788fb9db86637e56cb08027045e4047eb581cd1bcf210bf0bda4e77e252527916ddc382331b499b9f0206ea6727b454ec7f3ed0665e6a50b64f03bb2de620296a4d717cb12e2d81b3d1760b6d910c755baed73fb43cb2c6e2f3acd49be6d7c1889d7c9eed42381b1043db17e82a5a018695441bcc35264bf207273da39fee39a2007ced15b6195664610e15e01c8c52c78e221e72a7e06da46e1fc7531ec05929deea96c3a58687bd6c02cd049f024f91bf375b1916209a88f2ce815ecb4539aabd5fbfea1dedd7e20eeb62bcf39bcdce4f38632636ea0034cd3a130968e074be4a38fada32da979ecec2753392387847e4faec1470ee54a9ea52f44f0e1387391e6f131e37f3690ed801b95c638d7530a70807186b3f51d6d774e86c8b061e960c68eb996722852791cc7bfcea78f67103d66dea4cdbfc5bbbc942f6044fc1ffbacca52c6e2621771d9c40649c0b267ddeb2f0d415c37c837a58a5889748ed9c4e9698970a7e6cdd7801ce295683ac7ad6a19bc86146892c43fe4ccc335786dde0a4ecae4a1a19a7fee86cd66290b061a0a437a61f094becb140971c2a9aee92e4079b93d43a79b5f14b5687fdd02aa2c5dc36ea4b3f78b20292fbf070815e88689e03f90dcf3c03ff624da0cfb09381b9f99c6482054aa848a8214525cb86c34613ecb841186b4617c459efd8fff412c7cffb1ebb146fab4ea2d62dd83c52129ee672569b29218f14c97c31778049f8fa810119e205bbfbcc3c54627ed9c12879b0bb1ad02019b2fba3eda3ea16089c24fba74caf7412b175494ec2dbd343719398db96babb0817a09ef0e34334348b8c05ba07b70d0420e97665e86f77cc80dd841c100d490773d73bf752f6a8cb96b06cb0c187ebdae5aea087e6e3c97fd4786d7617dfbb2f63dcf3b6df8b820285b264a83e930925272c6d2ab7e0c5226546cfafc0a4054fde915b9b25db48cc0a956f1427a3b2c2cdcc10d54b1ebd7d9728a172a5fe48f13ad5d5211cd9289342484128e460796c34bace300505cfb693990bff2b09ef1e0def3d7ffc84d02d0332465449c68db783e54eeb48c345557a76d9d54b30086b5428a826e2bca9487734c46bdeb0a322cc662000a8d81b9a884711e19492e983767d12931cb870044d17b81e157aa7f0f739883a15883e9a82f61542fad125f20017de17ecb31a31b8c4bb89472416ae55cc9f39e0f4572c239e63203124981c408d92ccb8016d7dae120a82bbf4ced909c8469df0cf8b3ff4f135d8d0bb8e54b3f6dd25c60e00739e08a214bb00e7405c89b32f7fa4c56e8de475e3cb86efa37410033e07cec4b0e66ec8d270163a7ef191c80d3b89c42e9d6997e4a4326e3ec88890d4892e9b2176efc96092d08493dcea647109163c4283482a164058ae18f5e4975204edc587f866e7b1d9f501b424dd18d46044efdb25db335b6a55bac3b03a59a6b01b63eb334223f8b7f2596b81bd6b9a32208c1be185cca1371e650d3e733e6ca52b95a44809909fdb848d0f6d31c645e54430754b165486fe7f3b1c9d503eca33ae21935ed5154c93e339ec66968bcf7604fde4226dca455ca4158e16786085af4079f1ae64cd1dbf75dbe67740479b2098e1ebf8eab0f6ecc9e04df377d3493c5c9d971dd705c7e1aedfb7063ae1dbf067d047f46b8249c1753bc0d8e0c817331911f8e72717b06f3c779f8804e744ede230f60b99f3e9f42352dfa0aa0642e923f754b4a0c16f79b7e18a70dc403834a3c27f837b24e9b7c63edf483a77234eac11c21f9be168e24e65c75134b04edc7f403f3b7f572510d29e0b11606f127699394e66a6f371f81f0598b06d606583545a320498928b6cfc06bb199cf4b450374c78d21f94d6501d96c344e8377a9f8ebc5d57a7e0d499ec29ef2e95ad5cf6b495e8b34dfeda21a0f86fdcee26c88ff1ad3d6a1de6152f432bd46da6ef3cbf808cce94c05d2b2825da0b7714444c777bad240e1320f059cef8130da8bf41aabcd708247e898aee2302f9b3b46f1cd53ff01b43df00019a4cb18da2d853e79d7b24ba4ddefb4413b45c6c1f3f3e435a2ad9b6a3c8bc63014440642c681181cd0367d2a8c1b5b78ac2853f9afed5dbb5e3bf622d4fc007540684ee9a8618e66b7aa5c12e8572d94672262b47651ca630c95b3a8d998c8ce5b4343f07fc6df5340e59c97b1c8fad2bbacc0a2f3f32b1e37606009df18ce8e238280b83a4f42cf73e3173730a6a48f981a0ff4b5cb86df17674eeafe3c06e973ea6fc706dbe7cce751ec56d7b06c3037ad6cf843bfe5af2b19762b2ce030594c493e39e8cc6bbb840e742c4f650cf5b59fefd86632c688a9140cf06d80fd94b3a0b777ee2c3d6e86c22a74c144ba4fbaafa0b7b90be0a7562fea7c86d20637de3848c6c812247fc1d8d6636a346f82d4abf2a87c234725d8a37d23e995ed2aeed08782df00cc437c71041a9e5d9c0422cc553825e464744685d70dbca7c4e8137bbc714704aa79e6f45a2d89bd24de3c637d8288e6523fe60c06c4466e1a07aeff56f9d50ffa884edc30754515750b9faf565cb8ce95b6ea1cb4af606bdc6a5f2587dc001322ac0e9382a0d9ba21da832b29955f8b89be85699fa915f583c4eab39791feab8df26162494ac94faecf8815a28bb58daecc288173cc395e8a633fc0cc68cc0c606644535bc9fe192dc4eeb5fea0b85d5a656d73e9b39bfb725389a62a21685bad7b004d78a4d25ad792435e54a5aa3dcf816f58dcb405aaf954772ab7bf5fae4ad71de03d07001b24f20032332b8517b2288dbe45881c23cd8e9f7984cf179ad0a1d68054dcc4eeeb5f05928f82baf1a4ccda54dc9b4aaa347f6a258e1bd60f9c7b20d6cf9d102a7667d55e76a3eeb098039171ca0d8ce7b62ca463d9ca71667b936b29a2291ffd893ca401d61fcacb6dc51054de2e109743de6402fc9a6effd01b7a341f0bb13d4592abb9347dbf6a3e1435905861a7819cce4a364f4ae2ba905af445086f1c074313aff6b2df707b89ac5c8bbac4a4df4b830d0d86b2f7dd6c0569d293d39fce38a62d344603c7970f42e42bb07eb2150995e6f51d2cb085fe128ed1cc49a3986c9f118f13bfbdf8fe39e857a9ae990357d308a1ea3f1dc218f5c5b7f0f9c2c053821d755813172fce32316dbca81a5c459994e0e9a44f295ab9c4687e50026fd20a8c03cfdd1381392f8130efb2459a171ba6648102e5b33e1f38a965253482f327636655833f23a2fe0b8069fa9b307d87d34bd5cb1927f129ee76ac852f56a5aea87ba0a9311999015f4bc5db66248873ac56016b6a98b3a15d871f48f06ac5e03e1c3a06d139e3e50afe8b054d00813b70255c5189a8356b7970319a462e6c9cd0eee3b4d859abc8c9789dae45559d91688f550abe67c160f959f4e7fc9f07e5600f45032f229824809ac1426e73591d84c628e2340fcb6a65231c93a55929fc73c8d247c280c4bce7f4e26c28f0bdb5aa1356421ff9a8e98773e9df93a0933576fa31ccb0030c4d0006bdb8dbf6496f6f3152a0fea541cdda0260665cebd0d3da58a842e95f7b134ad42ca062844998d4bb5af59ad269d488f8f35b2657098d832434059a6bf1f0b76372cc5cde7b904c2bb649aca4834bc4b1b457fe8961880c28fbb5c0eaf880ecc03d880f9d5613b33188eb11cb3da97ea0a3ad5753db1c16b5ee563da6ab6bd7fdc4acbed3e183b0b4b51c7a4fc68eb7a44fe89d790de44ca7cdf2eabb71d268966a3bee1e2a1a2fc6e7c93dbc594de9946d0dd2f4761419caf16fa3947552cec7508d972e6aecf5c3f44b93fc6d6738b7b578f81a69c44e4ec8644918d7a545f71681843dea6bcce833077e2e76f84b0caa85c19986a06b566eb3cdbfc7f81603d3c620c2824b5983aafefd86226a96de46ce52ba4cb73292e93eeed8f5529ccbc1d801feffc278638bdc3398aeae43dc4344876d896399a1dc3d384d6d0d970984c943598441e6dd229c54936b0826b08abeb5c0d52dd64e288d62deba20d175d3676cec6339efbdf5bcf4e105f3f5eed648c3a2180c87ce3f901aea5dfe2fb25228e90dab8f05c41d15841741662fd2c59e86930bae31333f30f3c3f7896e8b81987ec563c8941f700e4fb89877346f2866ea63cc203034996f03d6e28463675912a3ab1ff586772d4e7efd01031cf7f65988437706d8e5379d0f09d4b98eb3c9b5d5601bf9ceea0e7ab59a5843644b34d26c60fdbba5dab33ba40fc84f37502769f860122a3deacf2b99895e0e008f5e4ac3bb4f2ed9d142a09ef4d6eb0982f97b8243bea4afa5353651667463892ce948a4c4ed01924be63d6fdf160ccd8a37c42a58a182a749e87befb90d1f5d39c2eb8a93d2458e19d73d48cc8d408d4bd6c79d1f04e72a42f95b6c4e8c1828733dd1d3cb919c845cb3eb730d79624b30c800cd73db5223db82665a1dac704487f10c765e6eca599d741968a398857344ed03051d73cac1a4a432a9c6d4c1daad9919bdf0425938b1259ffdcc9f3cc43581ad3c164714f67ec6408db421c3a3847f84902afe498fa827d676a40e73d2de51256cd29025c624ba5eab09ec370a057c56da57481ce12f60ec19c46d46595d923c9b35bd234dbfbc8b4a42a2f7adab9da8670a3cebcad3630fbd3eedb80fd059b690ed010b880a901ddbaa4e31870139089daef4de0a5384de7c8c974deb7f4d192f37dc216a4b9ad21e5e33ce23a3329ffea26e7bf7bbcd9685715f3166f9707d26be181db339d93ce86942356801cf71d68426052ac5de6d4d26bfd717c4c41297a6c75e676860ae8940644c7a1de17c70c92d0524039836a9a9bd4872e113174dd059c2bb739e39fb912656eb887a9c8a3ad4cbd0565579eb76e9bf6396969344e703d3ca2258e5fe6ded1942634e642141ccd89cc9513ba17af5db0d207b7406e0699dfcd7114e7cea31193d90a982f4458e415d1c62b065ee9256877dfce1d9c5f54dee73bca20ff3f96a4b23f2a486a043f8dd34f609859164b74e068a147f5782f8d82e0cb86dddfa2f983eba1f9eaf4198b5d9326d7a2c49ffc9dfeef4700770dbc1965bc392f2439350973a5efaa97bb7864f855d918bb8c2f58ec433dbe84bbfcd321004313e4f285c4bb86e0aef8775fbec438c20f24889b2122b29e619ab3c4a3e75478b97d9a32a837e265fa717686628c5aed66abb9cbe019068ef423173d3cee7db36c823e7f2b92f16cdbefb0fe9b69edfbe4c39065a072eeba6c06388a51d9d5111d426cc11187f1bf4751e73768a60dbfec2863041aee98b5fa6270ac392a7bff114219c4b27ae971ca49dfa4defa11182ee962fa924ef26b1a0b51379956f0e332bd58d9bf24f1c2a9a2422d9f4ad0a6e57bfdc8303142429d38f6e0c983cfc50cccd051856803e746a012a30ae59b9b7894493021647b1225375f25f81bdea25c35fc575940966b81e7f4412605baf727025f05bfe30bf769e9b711a32271fb7644edfcc36e15e2ec08b3d7b999fb43a78b245ac9ac90bb4ee09feb58c993dbcc279b622f5407768956d7dd752d8af53a1380f5cc897e3baede56d899417861e40f0281444be2d2a3001810b77c3e781d530a253123dbb0080001a6fd67dbef2a92e420d0d02b807d7473a989ecbbb9a5f77cd599f0d6de22db02f1600217b52aa26dbd18d0a391b79265ea02a33b9599a83170c674421388cbbc30a0736a4c56cb244b2967494d25d3208e59a167b6a2adf6470214c43a633e2f2070256e0edab6370d677e715c9f7b05830f9f8c02123c8a322c96b804c8f028d973391dba05db94b523a2000ce6656bf618b65522b88fa0fced0d3ce9e9de870f7dea665ca3f8e77be18284ea631e05cd2e9e2026babf3541d878c4dffbf1b6157796ee12627b42c5170cee8b1da0da189f8706acc6aeec0d8e42abb1cb9ee7cf3991dc5a97a28071054fd8f9ae265ef02861f35f600ed5b09de046186f5fde6f3745e02561e626c9245d9de51c5a87fb04bcbdec9ca1ec86a36c276d06f6557cf3c5cc1bff17b425ad364128eca3f3ab0791d21b2e7e1ce2665cb1e266762e89929eed7996f86d3d399acc2b48c623a4f9d38419de119d3b1a47c33a6d14ec3b855e41e5fe799a3b3f3a41a1e2b11b08b08c929705a34fc9302d5b5d02122f397afcc21ed2285ba28398f19946d32f239ba7e819304a174aeb2d39f9a853c3417376402a8fe62dbaaf041b3677178d6ec669b1014c471c68fb26a2979de7a19bc31d1001cff8d2987d1f4be30739f00a63ba3ea24370e0052df111afe647b38420d0133e4f67368e9934fe13623ea45ffeb79cd460649134962210d68b92527ec0d8f9fa581e52f1f9833833676593fe63436cd816adb7bc9feea98ce5b38f6e6d55ee88a2f8d78d1f83d012c4658c0cf952ad1d3a6c79b507e86b88e7003ef5e9bd57634b915e43c8c81b9034e8b135e45b08dbe7d0067d62ac019998b539ba8d71e389a3a2f39ef5b7be79d456235118e3565cceca56234399d1a20913a59924be45bd4f8dd0d6e178c7d232f1342a91f99783de4044f5db55f4158feb8c9217215d2a8ad5c31bfd66b81f8ab7e44c04a59d90ff6f8148a36fa2853da6b571005b6cc9f98e540c0583d2caf7ec422535a39150fc00949b238e9971c74cd30b3ece41f99363a1146ec196fbe17a680e37211f6c44824ca06125065086b678c1a2f14a7017b674c7f90de7c71221342e9469a61739afe7baea9926d18353522fd08ebda0c067d902b58f35509ecaece106453ccadc60ae28046a7d8369f8a28672a034ba6ee383dd0de09ecf48fc47371d01f260703c3312c3624a71b4e8279274bba421db509db635247c3018666947a55940cfbfc5051b39b3e3caad036ef686adf1837d475c07f82a1bd4f544212da3ff35e93529391953ee38a9a1b9e9f13dd0802a0f9c8204752a787d3f68326504f21e3241b0aed1bad6a9d7c0c53e86b5c80b2746595d7c37c2ca9510c2c2593d8adab081217e0966255e0cb634c4b9f3c60e2a80f20108e1511192efe5516263a27b49e5e475c2eace50bb5fe707db712ce254fb8569a484b392acba1070e266d8b0cf3a648390419371d21a9c68438af13e63bd9a6e669657082a842d2e1c6a3ebbcb44ee804e1546a05512ce0ef571fe08ebfa0f36cf4a28fb257f3a97b341f7a93f6071e36ef065ee9955cde50bcaffa8ccb0b7fbcb31323e599c779d66f153628d39827b72554a5ce3cad25940fc8b723dc793f7007679b9ae66de34ca56fe8e33d101a1d633ef2738fe5b8b2b06345fdce3c088700f1e7e9dee95dd02b87803647afb3e6c367f59fa291e6261006ed20f73817a991fb2e70f01ad835edfdfdc74492a6ea2365818557887043923cfd0c60abee45a3fa80aa5619f3292b00935c61174b2ab32153678d224cc214c4fd774106656142c94a31a62bc16eda40ea53e85d69f4edc61c1d28e579a4a0add4349ab9eb0e62f48dec524f9dc4ee31574ea493bba2730cf940f2e6e01ba22419b0e654c2d8808eaf8db751e335685a050bd097bbbf078140b41c3e9c4848c8f96daa8f82df8e2adaa53f536a3ea6a5f288b5cdf2ac95967c3ac5bdc3d0a36021492802a6a62dcec9b621d6a237f3d0cbb4915ca245ef1340f51677b6e92a8b42acfcf724147df20b01cc212a7806b81cb1f3ee3ae9a881fecfea83cc3ed179a4f0e5c5d08b17bf80dc6525df5c94bc73553a00813e8d5277d32a8d0f6c061ad26a236c945d125bfa52930b06e13ffa7554bf32fd6c4792df60a4dad19e1fed3abf20b2004dd3c1110c38823c3ddf387924835c697df60a481974f2d1285dfd87a4d787902d6d18b3aa847e872467ebfb933054c7b522a51bf91f07705b461fc3eda218f65a3d40265e6d07b081a93e1366b6e0903e61ea3ad331843a381532604f2d3005fa5972ad9a80634d0fd2ff3225518a34f82bf8d3894669bbca8781025a6299de2ceace2a17cd225881a2aca121ba75ab3237b7e740f3748cc76d601f1df303b57b2d73f33e94f4d2a338bbc631f459052487bec7588d26fc1977beee0ae57bfda8acf4533dca042a2d6459475188808ef9c9067008f7ae94cb6bab6d9f5d8fa342d77076326515f7b448c38ff0eb1b548c753027a420453ceb9ba0cc1facd8ecec3ff500f51471b229418e956319775568e161ec66214ad6365d5a3ac2fb25a92c33436301281fecf30a22fe47df9f8e301c82bdb313ec11fe628489cdc8d3261ff855fb741b2501192fbdfec7511bc6b57a691f9bd562cf61523644ad5c066ee02f7cd5bdce6d1fb30f95321e9598232283541eb2d6db734a88d3cd940b89f400bc3822920c775bd729f33f5d5fb5134c1e944b0d554939976f8b25ded82d9856c1cad5c816b7f3684e3951fe36517d11d806b21ce87cebb526b673df67ecc4766ef952d1da446f0b8021b500412c1e3058715e37d753b715a3a42a05b584bf388cba4558f86cfbe87b8a711fce71f27f8f849e45ac3e7067118876b03ce4d0f02d6a1756deb0ee46afcd6d61416b3fb75a194ca8cef7292d97d2b9a13435652f540366cccc4f43380380599f40723b110b5785fcc3b5f087a38f3d3e0fcef52e4e228a855a8680f165df7847926e8b5d862d7edf62dcc3fe5f8bf7377ee66e5b0a7755c8bf80ef9694f03fdb81fd3e8e22cc7bd858958c8e379695674d1a9a0401447900651b4fddc305641ce5a265a17027307b78b9d355338aa771331f246e7b58fbbc4d2d1592e326caae9ceb68317b08f9edc7d7e2e8b900fbb6222efdebd412f33baa39ade138491377dd3eaf0500fb9969c47e2403648843212585133a31bc266dfd025a95c063e63d28038efc8f8f4ec5e89f92858996e2e3971b6835c8509360606997e836a09ecd76a61ee76651d34c4c90dc0b12de304f7c7d95547c1e299bbc67257fc9110ab4d80c2b5d4f748de2bb9c7565c6dbd9faaf56b553555225bdaf574d5c1115c41f956f49dc988fed91e59fa4b8680f9f8fa0f77a2f52a9f9eabdaf0868412b7eff105db82ae64e6eb162df74f480427bcaea301a7059dc548bbd6a72634d447b8b6690cd1ce9d200ae8ccc161333ac8c1ae58932c547820fd73fed7336653019457dd70c4c24c2ae043ff6c5ddd6a13dd1b13609ad09ff0f14f0dfe5b2ddfc0b1275862e8ebbb960456afabb63f986f0cfaacfb443622a2f9bd5da08ead12d33dee2c127b04f9aa4c06c4970fbb39c8068e129ee4a5f3441837f195e34018bcfffafd0778d62c64569b505c014b01ddaaecdc25855e109022238ec47908805958d716c3b7d305a1fc09f7a8063946ea096c25bdbdad27a397a148bc1a83b574df4a03a5fb5cf119cc44a0bb1e75b7e31cdfaeff2f225cd6de0e2499cb10802ce4c07d006c9c9c9db6f2f7e74cad4ae32e220141ff08a0ad4f7dd9c6bc422d87e2171a8cffaa7b44cd76567fbf6d0e3581bde2ddadb599f1c622b4a3dc6809041ee24e1e59b37bf4359a6baf4bbfd6e12654efc67970afd05c3a4f787b13aaaba34d246e4c01226754a43bfa524fca2d76a90e12eaf800d208459601af07c3e2f0dbec189975794acc073524c3569055e9e437290c973162356b2f835360fef1ad2fb2cb02f72e7554495f7e8bd5b070a0782f0f13422b437f25befd899fd7b62ae815d141737fa076da896d245391ab02eb2946ef67fc966b541cc319fcd5621245dc970313b43967ebf9e7d67c92b0923798dd58f53fc70f5a574e836cd1d0a5bb9a7870fb1c50d1759fb0833167346f6351868f12e652b736c3aec7203865949eba61abb2c564ba1f19f96b57fe94e227364849271d5a5fc283a1d4e2c728f5f5c0366ac9feb5d5c74d07a6130184d490b8da7adc74097637413a7bea05ba08ea625c1a53a978bfedcd00720b023ba989e143b9f97c66ff3679ffcefc5dd00e0ab75909e212d9c6914f5637f935207274aa08c82074bc4c3addf497a6e807a08f81","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
