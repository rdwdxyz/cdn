<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2773f13e0ddcccd4a7edf99ef83493bffa1b1b282ff5dd699f00d5a98381104536815658adc09edd36ea4c2ddef48a37cdb02ab2633fcca5dc39e5420017fe11443f20965f3ac01ad31ce5dd366e9da885c28f591f856a86d085717119b264d3e932bc734c60f3c63e93a62ee849c6621bf26f0bb17647fd669711f6c7f58fe36e6d40c93d39ff71781c994008f77ff0e1ff7ca5c64457c14b476e33abd2d8351cd98a0134d702ab7aaeb34b4ae11a5a5bd11c80f2b80d6828256b934baa417ac03525d3f419e480bb1acb9fd62f17e9413ad546e92ca4d73907f3ffa5933398ae864b03f41df0e04575191baced5672f09349aad8082326f9f099abef224485a27b0792decbad04de947f995d3082b641f273d25713236b192f4279ce257f9fada947e356a75d6a072cc4dd302c36454d8cc63e95f94fe5d39e7e74be5ad46ab4ff164d124bd02a9b70a81c9d0ecb8a200f3f7a8501b6eec18b9bea80cb94940eb8f887f8cbac907e7c61b7c1607d7d0ae4254cdd0501878c0db50a7e28117a3b424f1d26cc4ceff3c6465ad4becd00acd78e4e265cab952a13099fc407eb69db4536eb19671eb254df9e0ff2e939494396c3c29be64cc33fde046d008bce24301943fbea6eecded772e83e37f20a0375d872858bfa561287872077679200d7ff7b1f5c449a9438df42a44e4d938de1d00fbc1866dcecfec0f60100bf6e9a1a202daa7377674aceb8c4e945df9a93e7911d19289018ec5f7f3fd6b50a1d93d3f124f49e85c38c2b24a9f9e2f3be1fd69fb19059b3ce3df5b68fb68091a4f6d771261daa34f447430a974bb008007213d51b94daf2412d4e81e2374ee2807fa866935898dc986b0cd54c7566385d0c7e2b00e945bb4bf625b1978eb52a5ba0be3f588a20155d2eab28cdb437b157f5f5e2df039494cb504746606e4ddc0bbeb69b67e25c78935ed246012dbc5a2b84ffb05df0d7de2f1971fc13fd74a82f814d189cc21e1001c3cdc89e19a5ddfddf6992877c3b3f6c928dcbd37337dd21eee93ed77ed4cd49ddc26aec2bb4fbe5fedd8e45e80dbe4670444afa97151551afdc6b9066cce73cf8c508121b3b6628b2d2da1742189205f411475f7eebd80c82eb5fbf53cbda3b59b45d0fd509aa09fc1eff13e1ac572eba4cd63e23704aa7fc45535f80624a5298775e0f6801dce3af501a3db9d93528b53a8872a562fcb64e24236a3a44d31c344e37ef2fa64422c032439f378a9d46d0dfa042b544e4d3b782014d5306d2d75578f244f792f5d1976b840a4bab70b62abe4921a9e3e3fdbfaf2d8f6047b1b4cb3a26f8273cfc227fa0f8113c9f66b22ed40dfbefe6ccee95af337c62cad66b7b9ca23b3945e444d5bd6da35d43ce6f64cb82aa94ac5fd2da9f7f0677c593404dec89de110afcec35b05fc3bdc4584e315e46bba8e4849d68661147777c5d5754c812f8e5b0eb5024af2ef76d867371220c38698c6522a50efe45478d59f516dbcbf90544cee1334e128c2f0b78c286e338da8c0c36dda6f2dff565e267455b501fe176316abe12035b61083da02c9c8d2014cbb40ef2dfed730b631d1b1fe8dccf746c507d6f6347544f5175d1e62d03cc5f3d594f0a80d7eaedb2b386b25685c0ee495d85ef21578c268b5fd0da9b1291b8effb23612cc44a7f50c5e10a8e301c0cc1c7f7de7974cb279ebf6fd0541fbf4fe07b314a4f40bc32baa32410195749f6038a76425d94d84b0826829910ce0ba2a8c77345c1c6e293032ac2f94dcfb6232cfa1ff2973fc94f3bb33ee02b7d9c8d41a7d0befe0b701d5ace14270fd4829f6f2f6c0f0df30a0a2ba241046f62976cdf03014a49f2f37ebfe104402e2d0bd1e0e82b0ee45ff93cab7a1c4d332db8fd2c038cd692fcacd972a9ef550840f39527780c97bb041fe2b859be3057fd307da5c1768d960f99459e6fb6101ee12b908af9d78945d05aa06cf321c1c2e55123f3d9fc186fb343a96cee4e2ee1f367aa440d4e1c57ca076d708bab6dca78f4607f485ac0050850d9544eb2e56731f0b7ebf18f798a0480832067ad31404b331138e71ebd82ced32557ec6ef241d511d59f2de0ab1ab5bae3ae34d855710002231e817c0dc63421686a9da744434217d5a9528847ac6e01cd0b0ba26e3515cee728f6e80fb93f4d9663f9a2b4dff044e7a477d1d3ca47157823270e56fe00004f4ec0afdfa334c8410d59f0e991d697f51153415a42fb91a4e410abc4629c65b12e6574802e22ba04037e5af80f54eda2fd8afe78885b785a9bc2d865380f67a592a859b6fb7a0d94275cd49c53a76bb17fdd9edcd96a2b63057b82b2dd1a4dbcd17788536e5730e232f45bb81793f0e6176ba6789eb7602b004758bfdbca06675b24958b5dbe51092a6c7cb6f47ecdf00359341f5599b5491d649aaa97d218c4a98c1f67c4dc325b78aecef169f420d7b13aa9eabc55f6458d4ac5be28991fbf4504e223f87a490ff0f9df9da30fa23f91ecfcdba3a0a61d79ede20641732134b157e3a08f5af46a7f89cd616eff066f56ea0b40cb90db9f8146024f708473e7c1cab06688383dc212ad54f25c21f0dbbac92351016613965441eccd2168098c930fda28731080dd4434bb48024d1d49323243e68f9009ef162f7a270348816a8256245aa20a79e6b082032a5bac2c5daddf06c5473d5b7c8bda2255e29d16a0bc88c7f1dfadeddfe0efbdcd6a1a950560e65b7c58607ae8157854f2f7a564991f39e39650bac0c5d675323de40f96691c56782d898c2e0b3bf569a8500c2c8b394c0fbacf15b0d5f4618724d66536f063765b053af207c5b8cb79be5514db0561f7750b22afb6ecda6163f70f2752c2d5b53639ae7542419f8d9b44c5fa7e207482cc9ee1079e255a08021dd052715867dfee3b14517d63c2bc05027f060c0f1f94209bdc179fc0372beac3239655dc5fa5c87da81498570d6fb1c1ee73b26ebf5ba452df552c6fb97de7d5b019c11e452b8a634643cb8db9c43ac83c681393b65160db77afab8b9373cd31a3f0ff4c89089e3510548901ff22d4d4db8d1aa8bb29bbe88b20e7568ee2b48196baf64a5a4eacc3276a4159cf55a7429dc0683e5d7693301e67e4b8d484f5c17317e7d8b144479d648173bf4e1a324deb3585a18612136d83bbee627b7c6efae9855ad7626e7c4db2f8681f3525b6318b9e6c5f8550c42d14f32a70cbbe84dbe74e010ebc2234aad66d340c538c238265afd5802de70d262df594645c2b97804eb58cd4090cae70d08d929ba529ad710008b23c8e583546b87413ee23c45fb0e2d487aa178adfc299e15e9fb82676b4084896e377704978e5b6a48105e3a86f0307c5ea8b37a842d0ff20fa3428447d7d540a22a6613cbb727484a924fc4ae71ad1b4a4fa8fe35296588e1ba6dbe8d4325f6d9778788dbb51234aa535a2d08e9e70f77fc6d6c5c119f54fc43b76937fe6a674d999e8dfe02ddc1b73cbdd40ba59f09723a227f40dc77fab2afa927aacf383f2a2f21b82abeb8300fdd5e25e5290eb1b7e30d819252a6236e9c6cad3e4b81b3e04a29b9366da293a9f94a5df58db291e6c6358694c0f08d5bfd31a2a88bc47d15ef99e3914d300e59fd849a8e073d8069cfc6e57ea814e4a4df6075a034077146cf64779c83372868fe69dc6b66b8413b3e9a6a2bbb6f07741833a583e93bea3b77cd1041307460feb7b317522ecfce3ff2d684910f4fd30dcac1f237b7081a55606906571bc6d298d2d5e003f1361a03dea66dfe3f752bde62d6855d298b97aadaa0ee174c218d23ce31a4d06ce79ef2db520d6dda48918adf9de29755e71d076769e553a600cb052a5b7b625d2854a0a1a0fe37b3ebf865d9e857e6cc7bf9bebf9fb071736fa84883e82e5024f0665ca0df63b50a6f346c1a883e6c155cddc730a25d5c654b6d276a38cc5215b9042394048f79a235bec13f294d19e37da8dba3633ec4ae971b52f8a9c473941a0145c9277470c248bfccb4d6e878917bfb2b731da9b536255f3fb49fbb7a27ef4e1731661b863aa8b14a0f53869cdc5458565ddbcbf6e6634372ee766df08228379a40cca68c9895902d2c15d978f016a005483d7ad8ba2f16b622102edbdf78cea8ad16ee4db9a78b832062abeb10f27b45bdbb50a2f3815ec845961fcbd854bb55da86cb216668b70d9599ae4d8ac4ddb682d33fe6792111d6b1b492ad23453164ea04550ff0ee47af333858d5af2e8935cab2a3ea36971af3b481deba58651ba25212ee1e5ef80d5646891c26f123cda56d5f67d5443cfe5b360c65a072965102ada4c42a1490c69c72a8948945ea38d0a8439739c276b9c958506ebd303a10530c1a9264ba4964ed96ca9f29d691c4bbc9780b6c1dbc1b24ce851645158e1f4cc620ece003cac6716e0a1273f340819e982c2a414b608b4669120966135fae10104689210b14ce18fe26a4fbabb3cc7344de5c95208465f9117c58c7bb8af3d8ee03e32319f76eb1d851773ba8264f3c727ffd24743df23311bec740a6f2ac47d618b69bfc64c38d5e96d0e615fef1008360409c82f0e6f167ad78493dbc92bfaa6c6887fa5f026d4ef106edcc4eae0fd99807e5e84a165a8af9a8b5055b69d7fdcd2e9990d6379d74cb8fb61677343a3f4981f98df886dc28308417b1a6ff726762efa745a5116fea8b028989a23bec586ab7f10dca7546596b30f30008768ae74f501419ead5150a9fb8420b9f0f3a412bed7550c606d9015b7d38d7455f8c417dc126da943f119c664d12ced0320b4b687a4288ce2873fc8ad85b776eaf2ff28a4d4a47bb08c5f8cbfaf8bfd2ad10b9b35cf620e04d5b8b7c35d348da9120df52f0463c9c3b04bbf2ba48a4852b03a15feaf1293d0e21de2aa9af56dd826c9880b190f4321713c094c6557caff3b7d4334ea0039bae1bcd4f6facc98320a331066baa70f89062670517f89d19f0683010868406dde4003e9a1d259a0d6f1399ad2774abb613d9d0866a6f506cb3fce36ebe0b111536a7ac05e1b35c47942c39e8e7a557e75da11c1761349be90ee82406175470ed4aa6f6ddaa7c10a6f81bce8029a49ab2f8fc3d9ef90152b58d7b248773e4d2b22a22c0a54efb6ee3fb770739887300749c9d614614eb181e5f698a9124a5153026fd3beb09ac60757c1f3487811e64e931a17fa98b9a81d5aab864998347a4715ed4103f361426825b9cbf43ef2c871f2860733825f349af37a21db8d882897fb0093d2b9f5b4cdeece39e896ce59823c7574308af2220a7bce43d745a288b7200618db1b50899773ea49f8d510e344f2c481ed46be29dea540c328577ea655251f19187f198f98fc0fbbec87f7f0d0f872490d2e3b6c5195adb8140f25004729faa53faeecc716575e68bb8095762260585b3b8a7ef6a3b859e2b566fde141ce3f0e11ae18c8314013701a139c0b6425afcc06973eae405138c6ddf899a4cb9b2a0709e50010f695c8e77217ef548c6c5601e4a9dc9a721f1a4b83e3097119d8d28d83827a300223ae2a095b877af5a4d265784288e6efac77673a7c9c0a59f5a2864bfd16ee6e15973f831fc458e4d495d55866fe7916874370402b9aaa56312d342dda7dae84c34b5fb6f36a68f7179e8457f25c7a88965a8de9c23c000c38a25bb798ccb6e27e55fd327291d652cf182c151b115ddd68b30ac20caf46dc0bd6a80e03db1e138e0cb1fd49e97d1847539acff29a653e79d6bc2cbb6a883b8ad9987ec4517030b4a11b4cf1a1ea7f67622e8a850264a485787d4522852ee62b67b10eccf85c8b4c4c275cea989d7e45e3a7be47ee6dec7db21ef9d2fb7d5948689498db9d90c3982ea7fb17b65efb64c1fc7b1a07bd645e0d848f9eab5430e6e6248e82c5a49c212a4e6489a2898ce97e462584d711b681c6e54ef6675f6e7d8f950464b688a3a84f5320be1bdd5ca21db21a8c74a220a5048001ee6481d97c52733116ade51978cd02578f1945d2767ff98296b6c64130c8cd276bbdfca40d145a8574e3d44ac0f907520c57ea118f269d2afe8f9c89eb222ee5cc90dc8c6f107150f8636f0eadf7f6633acbb58af9add11c74d37c67d5d3235880f7aa752e5cdcf9c90244f6d00a03396c512f5496781e02eef423726c6612f4c5e1d2d030b7bec9fc0861e528409334cdd69dce7319378e21ba3652b41e8a0b02cd028c746303b90f91c5d1529123df6176bc3de380e79d9386c09105c0b427ca86968252aeb647932064b7f43b073cba3273c90ba413bc3e2e2e66edaa43f574e1b150b84883b08ff30cdbde4f0e6605df868d7a2a13096c47029b3b3c1950437a46830a5827bf34a7a4abd6c71b8ebb4dd4761911dbc4e21ac5b962d11d604f28701aecac065c72eefe5162a4bd4fdbfab14f6db115467a4b12c370c91d93a2950fab22824275945bce41e86cd9594fea723e9a0dd8146d215578362da95effd48d9071b79f2dcb2b2a289ebdf7cb7581d2605edc71389219097fb29403040e7b9b366bb119d093eee43e09d16c43506700059ef8932d945d3547c73535ebba4ce7f7a4f8d26e376933b5b99932efdf73c1c96a06e296ae553682cf6502c458616c8cab1a7e92a99e5c3b7f52d1a81a6b41fb743824629b95aa8e6828ff296adc48e8b624eb3ff1967eceb38dc8fd393314b15562b8fe27eb1650c0c08e3fd47eff36b0b8bfb9b8ec7031e3d4c61bcb2ce5d2cefd438fb6000b97df14b2d68c38495e343c8eb72f5acf501bfc4523ae19abd1aa0279aa9b6ae18608f157e33cc95b9a04006a19654164080b32244f5e0adc5bca4b17e327cb2913b4946404f97cb96eece3e329b9f1229bc8433cea6ba3f257a6b3e836d9d96d474a7e641ec3b701ffa992b79b5b2f27ef39ab69ca66eb4ddc4edd07317023dbfcb8c4e50863d4ee755c852233b28736304694badbced58abf94ec6b48c14bf0d92f135e588e734c67958fa5c6d426d9c34d052d78c038580542cf927797c765d2f0d6bb255d4a9240c1fca01580b06d7587afadb412b7425b0bbc5bef6bed29af4b2dc8217bb35733d86ced49611c7c0bd5ea49bf149c005a5b2355ca97cab394b73241173eedca6991c3a687c47e3687254b4e74cfd02e12ae8d54f2b26fe024c2f0bf303dce82f5abbe7694d3fa766b817189113d3f1b7787730cdb4d319230e5e4b4229719a1defad306c1e2092f274b96992861cb8868df27c4f13056aa1ecc56652f6b8101f9e5e834d32a51e0f177108e3f18864bebf84678ff100ca8124dac590ca62efc3e9c6dbee92badd0b37d88a497e8ae7a1c91898568c669a54cf2a3385ae0e7effa324500b8d5a7e465a8de1d0ef3a52c9d2b16eb35da715e77761efa8d1cd4012e6f447a1da18d91ed14fd470a0e1ac2194566067661af618c6296e244e7ab4776c61f09b7632f2f892ffe069055a788b51e3e73d50f7657d23ac904288e23be1e007dbe654e516f4f025e4c4ecbb6c41f786300de806c306d2a63d4444c1a6829fbc3cf05f7172e3c117d699c7052a384e9a40d051ad12a51d0d7ea8f9b6b165d0c80d474f72d218ac21aed7ae4df99f7cf74f50229f6cd950faf080671633fb70db704bdb5448997f9d57b68af5b74a6c38ce9e14b085cc90bf338b6fdfb11b722325e466eca4aaa13980898a5b6c3a150a304cc1684b1573a5ebb88670372fc8bc7b5e9b4b3a929d5ba18ebfe5ca639c457d2361f405a2896dc780561724019f3c234d2e31f878d512160e0407118c861ea395fe99587915a743a26dde57c5883bae1ec35e60492574f81adbf5f35d184579456f6254121c4fc77e8f2a1131da74b50c2183ca2f3979b89e249d3ed242ad08655ed0d4c70db5e0208702601f906b9efa0ac186eace16d3e00163802030530aa5a98225a749dc68818b6dc4928e5b28246baf743c3455e467807b56f6501f6650000921acabadb57d176b4a544b68328a662cfcb41410f2850ee89a82247a2ca0e32c044f33aa3a170abc339d9c68c54f833e5374e2e7ae871b3bc541be4034be8889f14c0da5242ce5b0acca4f163bb28537af7a2a83da75a3d293984d130e3910191f2ecbf09a515857b78e6cd0255fcf8820008cbc321fda09b06aeab8890a94a7b77ef0cdd5b8bd0999ece001ba4ba6a18bb69b1a46bd3dd14d976adcf648cfd76798a2feebe22a7486627bf2da3f401573bab5099542c3ba3b4da03d99d93a7bc17af2220b10f767bba632015ac83c023c57619b8c4fc764c42fc761b13dd4285282e9e021e9bbfdb3790d2b86c21553416da85a56a42d92dff546bc2455133b2c5f824e43b748e56db87bde9cac6b2276bf5a03df74db996bcc520dd9722bd6c92a47d50e9c699af1c6305ea15a284b9c1a962a72cf40ba5668ef3ac9ea5a4deed19689db12716a238ef4b18f9a8be3dc65b7aae8ede8b25790a0131008299f44436000241e728037bbe52ac9607c715d855fb80be7bfb850d032c5471550f7f6f7f8504c826bed7668582eb30a3958e8c3200ff8a4f72b03ac9eae42746c3a02354921dd2a50c584cc43dadf2dd4a59b7e9222c64707b58e7a68dc9877e90ae130d241a914da0770443074272246a16e0b3e3c8aa91345c083cbba53197dde8aca2cd700b1afe4d5bf7b3ffd3473f16c2b9a47401e587eebd2399cdd5f940069215ad12ca15b91e850cd5c13e16d354978df8c9f6d1c58707302f5760a7bd47fa3da7c67e2b12f30af46e94dd77566ef77c7476cb34c6921a371d0656d2c8d6a88b5fd96041796f0ee4b977f54d962923b279f3aaf80d64299b1ebf1f13ca6f539e30310d861287806ddd9f77af9df80d0ec94a1d2773d54b106b4cff3beda891459e39f4beb4ddc193bf3195ea822aafd86212ec988e320c317983e6026e1c9603a8a3a25a6e95a9500973c382d00a3ed8e33eb658c57a08f9d9d142ae857dfecd938e876238c8ee7c88e51e02cb6a488ff70c29ceb0def2cc3af8b720278788ae7e63bd978b71248b69a68e9985765b9145450452c7d7b8a485aee1c0f05a50e18195473a0a167115d48c2ceb660e273375a55fe0887cd1fd0373bcd4faa9e3f244a7850dcff80188e87b1762ea0580c6fa4ea879453715bf5c229371aeb313d4b6974c95a87f7c0091fd1b7a046f8fa62a478147addf21ffe230ae87d415cfec4de2fa97fbf500e933e7920ac1096fdd05a612e9f20516634074574f1036d3450f8bd0e3a0e4ed20227aa8c2042a98e7e06e01b3d259612d814863afd89b3984a5191f769ebb25afe0fde2b345010039e4af437afe785ff8c6ad7f8a66e3b1ade89cc2a2b6b9308477ff3e8ae94b4fd1d24855af8c15c37dc03f37607dcfd0ebdd786927b65321248ae605e8e2e2543b7abb3c5f3b7921ce56ab30ac53808f5dbf293b072de0c99104e16fce95cfaa56e4dfe757461202f90dbe80c4aed5a32cb44c88146b50bf6e15a641ad5587d40126c266e481a7f7ac8ce52ad43642896f8fe29c97ea9012245824aec27d0b6976cc1a04351d30d357e0ef6da597341e6166c717a1784a406a23792b40f03c6b01ccca0f6b765638b6ae625788bbbca58116752340a5e21a890d19cdb0bbd4343b39bd2bc1e68360ec5b0f699079f49ba25e67b69cf2645118cb00f9b6906fa2278f04197a56ff6dee3080d9915dab10689ddb1555d552453f79c21907b869d9f4366c342130e0b2a6ba1f2019e014f42930490e19d841bce5db364563696bbda6a2c7ad0fa3e0d82a19fb3da154d24fff4b2bc5b4bf749a9966fc39a50bfff79f0af3e33ab2da7cdec07c769e1a99374434ff8c86b2fabad4fa0a05d70d43082df32aaf349286ab5b5f7584c877afae9c9bb570f59166fdd12b32a4e640851f653bb0ff08721d7de7bbc5cc7e529d20ccfcce2e8c38961515f5a27031df32e34ba4f76ed86655a5b6c76cadbe5661f4e3adaf28b7627a56efd232aa9a091f58ee5896f5b3d06c58dde84af8b2b46a83d7c79aaa5576482203a0385f1a14ab7303423f74e11bc8686605f838c6987dd8e0b248d9e61a7f4b5264bfedfd27f8072727ea30250975322aeddf562fccd0dd0fb47b5a1e7ef2b182f5cad487cf0710f63f157dceec87b9cffe5944af54edd5fbbc8d717b20d20a5a8f577fa75b63ea7ba5cea4ec8ef0654d453c8f58eeaf24d6a6e6a9aea67961d66468520cd572a5deaae1ed7a10d82f95125e00c42ba0fa94a044307c06c56f11c62411b6b8acafb0734e0aba4c2e83f9bba8e7bec19ed65dcc1321212f3e041bdf46928b391c4d1a3203d368e0adfb08f2d1a7d77b3c346735029bdd403953703a8b26354298d244d27621f92bafb7ec1f00a454f8bfa6c5e29f0173da04d7e9d5e6c0b3cfd0ef9d1149c02e78d842c6e1b21c049e9d869fc65635715b6156fa1e0a82889a3c24dcf0bbf9c33bebc76859ef771e17d1a66b6c5bbe942f63faedae7b843fdafa54bb5d1a245541ac8ff2a8eac2a4325cd686e52d6520ee724777f234c2177cd67cbd6650f44673d8e2a7f17d401581bc4f47a11be89003429a89ad8a7675fefd8e93c73b0338a8fa1f9cc04b2722379fc7141c3c1caf38f0edf3c49478eb5155c1f4597c0b071e91570386cfca2425f8b1ef9df3757b3ad08efc868aae3cddd171ef3f40c7abce7a2dd71cdb8eb801f6c49ef3abb993ef54cab458fb454ce0c55c490129ed7604763a876e3280403dd2d3f48c176d40be207b90a31496cef8e32ac8de2eab9752ee7e9e588c5821302a67d3228b65029b80dae3037a56979af7963159bf48a81925b1bdd43c8d1ef723fad65b826477dcebeac1dc4c02182de6b80c3324ec0a405eb8eec821e9608d7e20b513253dc5dcea04b55aeb2560de3884d0adbf427f4a8b474c51598c86c9ae26db410919e7d3b0155f9197eaa8fcccc56879adb30255ea4e92b7b3c851cb80d984f39c2adada1a5644e7e50731d2d164f3eb2ffbe87b268c014ba354f228f68e404ed1920eec90833db4c1c4dfa6bc6effe89584c312ab8121890c582f17a99c5484d5b236e445c2c1b56203ec23e9fd13c14244a902a8c1f6a62bf469d0c775be3623677e359db995a435e38b5f1b76aaf51f8cb0ecf931a3ad3bccf5b3178a926f6eeafeeae6802fa0fd045843ebf86e2b44cffc1a2ff49f61b3f88daee234ce092a3dfa01d9e072db6219ba05993777507ba752ba06a608348892ce112f495cc1a34dc7d6dc3b2df57b703e7d1f7a0ca86409479cc42e9ee39d7cd9c111d21447043ed13cb74ff2916d87137ceefde323c32ecffc9e14263598fdf7f7b9889daabee08040579af37ba58f4672364a632037a302c2da341cd8267aa2b1a804b1f2c1d5793b385cd9686ece978cd7ab9a42aea5a7547adcfa4417b87fee57abae2dac5997fb7164c57c1a6e3e68e5874a80b6d6928f968bc7eacf9be9ca5ee34268175f9de0b930af7e0f16b54d1a71415096dc603e3391845fe09a2ce82ed90c1fcec68ed3ba648ec5e0cd65fd62a041b3a1c25963b0d59c5d71e20c29f292d09aa753d52bf94324a17163559b43c49b4f9f82674dab0c94ddb89964e773f3ba7fc965ae4c1fe466fa6b0b86ece21ec1dd53d5528853f147f7354bb885a1be18d6ab1ea1229f492d3aec14b2d10e495647a75bd9cdf0dd86e1d32c4b5218799d3a70ae117110a5e5bb330e4716c3f78da7e84ed760f8807803c1e3872732fdf64c7216848caa9e754cd41c054c802890c6cf924f2453477ecdcdae93b32b8f456b191290397db30b4e813e79c579bda18547f0039e877d48885f74ce103d1fe41308f5570a639b6dd45850db1b15ac6efa677dfaa84843648ff858911baae46b233ad37a5da512c4fd66ba360a60577c0be8f261e89ad36a40bd95df01c4bfded5d101cc336823939c691e785fca95bc7ed45444886ac2ed9f693cfb5ff530037e2ccec89cf9262ce1316b4a2b45eb14a54d8c6168e702884bfff9acefdf1eab209bf1ebee92b4182a1d723af77c5d8992a1e90d6230b27e2690fc8202d09b3460dc81096eb83e083ea500604b1a3238bee4a7c2ee60d1588a86f38fa844eb30e5f3c0cfb9f4f9f22337fd430b3a4024fd4e5bdb2760fbc535d952aa0522d1aed1d21d60dedc506dfe0f9a23d9dc4a52513163d88234ee1405dac1c0e704a1807e778a82c49b8be0ef5e1d38943019a905c4d35146b985b6e1a01f0f0d2447afc42644e01d5de86c3c0ff3367272bf0ad6238d2e68d9c18250001e5822deee1731ed6a69d583459f31a86db87d6929df706691a0cc054298ad837b78945d22bfeb2cba2707a57325366e9b1c58443d371c80b6aad7079a48bd01e683cbbc30be8bd83dd23b4e2b6e8acad75520b8d01e672ac8bc06473b4f18c8e6ff380ca2a6e2bc409c11abc95be479f7904b92c49b6b4d12beeb67a1077d8d811fcfb365b41cd11524e6bcf054466472be2422bce1b6136d8b1675cb2600f0da394c84ff0e121cf3ffe909e6f1c4f933d3fc8a23e7790437c0ae90e6e8ac59a4e254544ede857e823ce6dc8d36d0b84058de949ca542b50f86e04e5193bd1904271382c0cbc8357d5db0d1045c80e6aad667f422636c5903180e2a697dca6dd4732b389d7f689eca15960ae279b6bfc70f517e0c5f53103e15fcda2b7cf58f4ca4110089a7f6fa05bec4ad868165954b14ffba9db73c5a25a3c52cbb9c3b484cc460bcb7f7a1accdad67964312d086dac3d8e6d53240586bb9e70c10e7cd50beba041f2b0bd2fcda11d82d2b5370f7a1871dc85accfde9b323e5cd7c51fb3c3a84175301341be04e5b1aadda27bc36692889dbf60e55ee606944689542e461737d583605d59b6bf72bdce5bbbcc09a01743b731fa51f555bad8679f8de4e5acb6bae44cc0e771b360a1661080e4ca571483973c2b6c7c3a9dc51bbdff99e50d34b364e36cb51f4b28bf4cc6fd97f2c4f91324b40704392def07a7b5370cb1460506df339e372c783fa09594f07f2aa2d37c492686ad7bc67874103761aabad68b29a6164de685a3107121929aea3181af2c578db4985dabdc9df72f54ee2ae2d220d8eef90acdd1ae2003f8f357db03ea6134f640ae787a48b629a6402a93600680b5da26dacaf26c1325b1132753d01ac5466b73201e6e6b2b438b6a27693c3d11e3d351966067dfa3fcdf4fab0a8622b638181b1867569f92c7085c000a8be076fc8270c69e19a112589782a099c8a4192962880a1b1085f90068c22268c3ec30350dd52298b94f56ce6c0839b60223bd340d8f4ee4002036b356af31b641f045e35a1774d510a6f0676ddc1a935661a5c0a41631cdbb7ad300919667070c2891f0b39b21317d7bef928600a49bd0eef61977ed59d2e4537d5e593b578b11e892cde1c9cf0e6c3ecbaf4bc13d67b6430b309c7a825dd6190299fc12da01f1a1f26ec533e0be867987bc31af5c38c6cc24b386b3d5319d742d9487ae1c1037c12816263a3c77996bcec8cb235bc0396b4f3cf64e6d82ef2946501f1b336d5b31ebfa9959e5fd745f43a8a0a074778e18b5a81524544f8b8c03fc9e6beb23491c8bc0c35b46e48dfed1c9d618ab1b967969b82c706df3349f9ccf4a4a69fdecdcc706473312720a2cbd463786d4642cb4df576352105b8ffe44790b06cc2afb31353e415557d1d80e23476d035f0d101fb6be12775175d043b7ec8e96b51eda4ffef1995ac2603b07016c37092a11a8d20c1bd1bc2555c3ed27638a84a4ed8af675bb5068da97f55879b5bddba9f4ee10935cafb64896eaefa64bf4068247e91e8e69a15675ea1efc92dc7fdcd0d3ba3df2a91c524a678e2fb39a988eb0922a031e711251fe65056aceaeb1f138776f24164053aaf53cddfd65cadc2a21670516a2b8eb31e4df90aa99f4a78b29dce9bfe94de0f9786cebdb2fd19a7dec0f742eb65b16650e70a891839160280eff021aa8fdae1f469423ce20177db1e6240bdaaab44682670405bf43cd2633139e8c79db3915bf0a6fa3a4c87d001b817c923409b7ab106659f0545039f63944846ae1337756bb31e3e2636fd55a37469cd9086bb2fc0e4d792897996899e6246671787aecdce828ba1f3a3ab50982f1e17196b7ee044dfe10e1e46644ca852f4bb5704e79cf83c0081f29fb586a8e3b09debdf24dcf1122e6cef194a10503a41a3848188678426de06845a5a47034470626cd56388743b17966d20da068c40be3d7685857d766d5ff2fd2c9882f7db3091aa79925c37462823a7451b8516064c74ab9b161b7566ed11cf07dac09228b842a2900c8d869d9f6140cf6e292db5d16f8e81149b7ecd32571f32d6c8848782aee9d8ab79465764cc006b73c3fd9054ac04d340bff5586fa3d48ca5d19aa4a13e9e50721c2f4c8419673aae870fa8e6a9d3427e5485fb2c981b8ac30c7f3d3e1ee22beeed51eb01c8c2c9771dc488eeb40fbaeeba1796b558cf8d0cef50c679401200fe702a272c45c1a3348ce6e45a02d094ddf9ff90db4eb68c1cf57ffd65249b49e7cb98b34ed84e3f7d3939c8be971dcb6b26bca595ffc65b85f1d0bcef82a4b57509d41d42116fa97a4f696d36102d76f8d72a3466481622746e585ad06757d8ceea7d3feec0b3d8a96f27d37ed6d917b33d0287b9f2a0997f7a81a4c45ed3295dd2fa8193589a12cd0011da3d758ea7a97e2a4e3ecf71b2c0c566845a67dbece4a7880f33e2f6ef7277f486a88beda99c21bcdabdc867f972c98aa068d2e6f73c692be1eef99b6455502a37fae020bb10f349617edbdef2e389abaca1f1d9301bd870f9e1d32eabf109de3bf9309aadb6b2472e4becf92234ed46e01152d827fe4587354e5383f0843ee568b67148a67ddfba9e38e606321bce9eb63c5ff9dd517540c9e43f60ddd90f0329b4816f1ba5774aaf03be8ba55c113d76c43dcc75637f500b6a857d5fdf09100144cd7e371773c0c15908199794d8dfe158f0a4ba1ef04d2dd4f198c9335aa2dbd32faeaeea759f2570b4e0bccc5ac7b7e4d103d352e05ae7061ca876a3f2565934e4836303dd0098f1c3b0f1e3e4dcc12928b621941906917ea04eee106064757a9bd60d0754d90e292f0a3471e2b4e4cb54734d94c02e39ef766114cc1791c23511","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
