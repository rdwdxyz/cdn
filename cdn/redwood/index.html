<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74bb7b04888207a37317010e0bee7fcdd6f0e49f4d108bd86ed5270fe8c5789e6af8b1d70c80aeeba48906a9213bd109b4512723bb7936a3090c3e91c1f4199c919323c1ef8a2d78b52adb1740f0f48f5febf4bcdd08cda854793d5fd01b92673076e9569d980e149a11046749abff3bcfd1c50cbbced9e82373f520c40ded8e3c8dd8c88d12ba414415e183b61a458213b2a008af5641c187a6fb8c7d25754506b90b62cf53eb2e6f5c503bfee7f2f616baab4fc926e82e5888f01b86b504cd9997282baa1f5e174ae70a89606d16761c568c9d8524b606f23f100f75ab0984420370aa566d7793bb3192a77c76ffb0de9521035b45f1c054af40a08d4ddab02fdc03c895a2c47941deb65a477419c2e0489820ce93a1449a9fc655085dd20fde6daa525945e481fde6b67cc34ed8d255fc2acf8e72e78accc5c8a1c13d28235fe6be6a5578873eefdd9a985962c5cd95b72a02b44afe6d87060a2cdf994ab105f9770aaafd58a62a34c3e694a1422af9f9ab92fd0b9534d5b031d386ca4a18f55aca0a7bfc2d8032ee4762bcb4d77489b97c30bc6fd6cd725df7ff7a240281a84b232be5ca8a8875cc05a9226d3a9c37d2c08a82bff370aa8106ef59428b4cc14f73151f105c22466675fec50fc22418044d6ab225fca2bac5460a8f59c35b9f0b484097a5206cc60f3d2e8e40bd9d71c418778b327b327f8b93031d84a55128cfb2c22703ad7abb7b4b858fb24854651ac54850c7ca7f3afb99e05ee77670e87fe8de595cd24d54ba04bbe5bf0a3f3fdcaecb747c6a24f5255d319b3edfc0dc9f9d9072959a6a175786c9c0abcffcc4108dbc9c4f4eadbfface576b66c3623642140470f7dd38d37da352db181be0f04a51a36b3d1d5b5c9b54a59f29e4bb3f5e9bcbd5c0977bf71109a5bdd42b3cecc45d449c311051bb1de6128e916bb7f59dcac5e82d8fac80bd30e0350ecfd392b524cb17581b6b77a62a7da8f671f86ddbb7addd5afafd6ea7af82872bc91a459c42ea5d5b6b94b11d93c2c58ee755aecee5d2c3f96679bc5544e1f39c753bee9bea9c51a14428fb9eb622d12e8b7add26b61afe2c3db2de085de75790d52b4da44d6c3b34cc11867be5fadff827b79ee0fecbf619e9f8d92bd3befd8748fc120dd0c963e530fc46f82e57bf5d488eb96fe249bb79b83b3050f849095750844b6d9a7440d45a52183b98ac34c9de622681cc93a3ab5248c81ec6de4d162780e04ef09a7d0a7525430c19770cd2a161dc9168f33c249715d37efa283382096b2a74db191c90a9734c8c7c2b377014baf0a3011c9e5f8ff65d174d3093741d0277a18ff293512d99e6511143e99568ceea45690b80bfc06c2eff3805abcbba265476263bec10e843ac2b84ee531d063523b9481aeb108a585bfce051ef3d1bc77a5623e49727bf6695f12d05bd30fa07712fb8bb47c15ad2ac2f5b15d808ca443c192c71447c161f4ae85a15c9c9ab241a9cdca7b53d2fc4b45234d972f626aced1947c160f9269331712cc76976d0e367e6588755aa2845478f5c528b6de35285e15021dd523f67848c2be2979e24828e4e5d0fdd562622b8c150589bcc19760790f5ffc3d6a71fdc8ca9938e663f75d0c2bd7a23d2ce2e17a8aef0241d078e75e3cf83dc5f2f451a752b674546a30354cc732b49918a20e911d6db1d5b0f6700219530d995aca8cbb7ed2c96681881ba12b1c9eb789dcbe275b09759caf949467755ac4ed85e7ec144e5c8917ae72afbe0887e7b1052569ea1d5b75d2576f65116e98526993abd97a072add0e4c0b1bc607e35d188b41c6cbee8f8b5a0c915279cc92f160143659468324c918d6e1a052cdb592fa159a94b4188670396e75e7d0eb037178e41e91e601ef4bedb5922812e686b247070ad516074e29fc04316e0ac6419f73b165bf01321bef6e5a3f473e4de39b6f49d3eeff56651de0171af65e6487fba16a0316c0ba36b6e23a370da90bd56339cb7fd4f5650092f31709f967ef0e1d96f49bbb977c193f7b0dc3c1c973bd71f9f14cca540866a095e0cab6ce253a0652304476eebec2a1251dad6c666abe812dbd1d6a601b8912092c1c310b37b8cae1c247a576ad9b162406e18a6295b266b0d14b33d2394e91c3c231e1da6d1e9b3d08a9a7ae56830080e00a8c7d3f7e4c07c169b2027d877795e40ab4b3da9a2ecc5dcd067f800c4762b1dd95af802b6cf62c3a77fab7ad522e8b1f2de302087c9b1e37d096be92f36646a44c6166ec1c51f949eac00799a75a41c6e03135bc3fd31964d6fc75383bf4f808b8e9ba7bbada4bcc70b78a63ef58a9d4baa8f3c86b2374367f772e8a3aa0f604c532c0b4cfc70e7551e4370d57dfff48832fbe54b17db3f70e8aec62f252e496e8b3e34ea2843c408d7cbcc30e1a9c8abe2e2807db0716ffe9bcc0de5c5629d8cd7f8773dad4384f8ace710cc19b17e714780bdd60571869b03a0fe15274fbd2900df346b6e9ed672b7042176207e608cfa4fc534dc378b0db77ee2fe4baba37e436c26b75c27bd66918fc2801b9e27206c5a9979de50e82a1b227c66447cac47bb13b1d303b396ca7051693ffec6703c7d8143d4fb9b662d11274ac289ef9efdd60c01d48bfe8b2274e807c9101f1a0e60afb881801db0852ee4209f61185bbdce436c77ea3dc596cf133d0f981c0cf8189dc99b47518c7fbcce03b6e336457410f34825e36fc3946022afce0f2fae011609b73d45c00100a5c69439f44c24cab6728b3ff2c021f8f8806f1f52c7bd0c583b641135ccae2fb7868d50af734529c703c249f28f371fe9f7a2130b35065edb6910a17c39ccfa0281e64536d8def03caa1b20320d2c91e1a684dd9f3d7a0e9d4ed413acc521e4080eabcb5812898cdeb0bfb9a522e2dfe4832d2a0add76c059a6f7d806baa885b9a133fef0199a3aa2c9ccea6b0e4aa11c5077713a3aa42946d5b8970ff07cedd9db54821a0df9a8deec83d7f32f7bdcf94ee7c492a098fe115b62d06558e96e3ab946f03c83010f444ed8afd935c5309811a5d983473853dbc93231201a398d31dd146fd20c3a2f55a72a7f58f90704138195709c89deddfb88b7c5d39fe261a2766f9138de8141e2e06bf178fb1d8918fcab01a74bb482b74faacdad07b8b9aca36b5ce10d1f034242c58f8e5f6e283737f67036e242de95ed84be22a03470fff193a2dccb1ffbe1fdb76eeaf1e5810857ae07436c469b167bd8dfa267b3bc038d0295addd5ad83ab5a2c428fcb6a6c797dbacb93506d71bf581e689a7e3775150927dc4efd2024bfd0bad40323e98b387a1224d8bdebfb984dfd7926f1bbdddaeeb842a85adb205d4354a8093b0267540bab8d1aa8ffee8623c89ed13cfa755e4ab6346b3e08bc2537bd0cef856f92571bf2a5f4ffb11857e4f7e83bfcd52c77e15d73abb7b436f29797a3b8bd61a84224a698412f9cca361b35debded89674101bfc5e531fd1537c1c294af1523615a7c7463d135719ed71280b925b8ad3be33042ab90f68e15b4830460103ab5f5a78804fc0effbe422f1ab885f07b07286a92841dcd8968e89d19163ae8ef2e26fc658667ac96b5b78775a6dbe7f0e40d9d460300d84dff5ca76fbbf92ff3cbd70d671a9c5fb227d587781d6aaebbdef177aa989f8d6274711fda2848b449d91d180546931c0553ff679d5eafa163e88b18841857cc0b9b0bda1658e5e7b894604a983866e5941fb527fae091533da36f5ae41ed17b2978eee98b44f5014e1b5c4df874d32dc331688b7b55a14a03be4c0d271e02875d75f2427d0f26b215947b233feb189448133ff7efe052cbadbaefbe4392919dcbe0c979e0c7b79f03074e03497fc7701949b5dce99fc04ed53bc2f36a70401a24700c17cbdd571a1d326d25e8a84e7d71fadd37235d327d18bbce944ab6f30aa439f42101f38c8236a9c25ef9585b37e34ea1dc9cdaf89655a11eea7e616aaddb3c9256675291e40e9cbc0d5495c00bf764e28a3b9bf68639a0d088abe74613409190ba8ec1fe3b4ec25162263f6bc70fcb30e2d548e3aaac8e0ab2f7faf0ef65a37b9537e49d7a5aa97b5fb9445a504e69dfcc5db01c9e4612e0ee63623f3ea2fa84e4a2d680c4c10e581acef67238f9fd98fb057d63bb9b598fdc4357859623cda0b7541c217a4e5561171044da1daf43b6b2c856a40e9892df022edb82632025e18bdf130240814580fe83ba35d3b6ed191a1bde038cf9180d236c5a90debcf99585581c80fa78db7ddcbbdc4a07c142d09a2e296340a26acd40ea183aee7a7b4139b362fc7d50512bd65d6e899289a2b60a0551c8bd0003883d94d165740a4e30fdfbd8e53e7785bf92dfae21d6f44d938c312f452d523838bce69d330e7e7c3e659bcca0bd58e7ec6dd1be114cc55b7e39e1799d5c485f9a4803ad9be2c079b67fd5fa8895614e97fb86727579c2260867b78c9c8cbb6e119f15ca401b085aafae43fbd89d967c82f5115f6d7cab914e1daf7ef71fa6dacc8759ef6b5f3d284dce8f0e886f6b675acd02d5b619da58f836d5de43972a354f3ce3c63ac5ae4e254c996d61277c1c3c2fff0abccb91ac7cc49e25f94b261db75e5eac2ef6dd64c08dff3c9cfbd55ef661512f361e2aff4c6b57664516fcdf6e9b1cb088326cd2035e59caa17f1a09100a9660d40590525ef0364aabc30967312a4ec33de1e153fd2da859ff6d7cdb88b1ec0471940b3e3a35c168e086096e3ec5d23460b01f69044fc333c908ebb4d22986dd824001ccd2bbf3b52140891b5a9b63c2635db028fffdee99c26279f20eaec730a09626c89a020ce91e487fddca29bb178acce83b5aa0ff1df174b406cffa0d2a4b60dfe8e403b71e323c410ea913c22c1c1aafc3788578034a43b9f530821f2647a1153cfbd1f5138841a52706a5137cc9d4519d2f0413c01cdddde8a3de20af7fa496c2a79e0b3c4aea25f61cdcdbe32df1c211a207dff6131b7af5709f1743541e0b9b0b99994a782ea85df29ce16784f67f91cc6f5a2e74474a211b0912994b73e54f997f442df5341aea0d91149b0da2880e7485426bd7ccac532d9440d226ca52ec508ccc34990c9dedbd6c93067ef69e52c023e45e2d3ced2a8323f0e7336db6a52ed1d1b17b4ab5a07453e11e6c0ab65fdadeae9516123c289108c00052e911e9f17c9260313dddc2487507bff90364a4b0f9150896d2c3042ab9857a1849a8b22bfa273debe1f30e541b917ef17b2f6703105352a96e777d9162077353de62477f65d71b63c90a8cdfc769b0db735d55306364cbbe8647bd425efade173da5c26ece8a8999ca60cd60546d6211c9bb937ce4a94b52101365e38ac28e6ff3e0f1e63c6858d090e62137f3c32b0c5fab6cb159be6588b4d59b554c6688e2c14abffa70f37a8968844add2b86e53604dea0ba1d320d898ef2a911e7f97c897e3deb6969a989667315e06a516d558f20195d240230f17211084caa148c7e366fa98a162abb40652f3e448987b8d8779b4039a8303efdbf9dbd044273b7b0204dd715589182d9537394d9f45122bee39f98d3e829fa4bc5c597361d51b8fdd1947cd24be51bacbd8ff1fec22429a75c9fbe07a45525daf2e8261e312e79c60f5ba9c0c81f4526f9286f574f65e4f055d99cec9f028d0cf2e94b34b92b5e395b986f631f35afb748566f7dc2f5ff664604820433d687cffc6fa7b1cd1d84712926542c8f5760b7ab38ea9056ac2aef776bc4954d15edb5fe0595d37d40925bd492ec6279c962b5139942ee82a06a88eeb0e62214a787a0fc36ff3c00be093ad90134d171cd0c54f2120a8b7fa37f857b2c371c7489a810b8f60b5ab5a8cb7a207ab23c09d42411af27241e5f3bc3b6d4429d9bfac01025f46721b59f3d43f6734de0ece413348d4dc75f50f82995d298e2b03c8e850eda1d33c7d668cba309b470fd01531db5e14dfdd49250d9a123303fef3ae5bf316b502c84975ad5c3098e6c9805aaecf0dba6c0c36e47fb23019d1dbf6ca8fb05cfcdb3b24f4481c659ae1b3b894d2c35833fe961e66646816a1fd90f5d9e4c4286efa3e1adf44a5bf4b26a1b4277fda02a7d835039e564b4cc07a6c3f8a9d320c07cfe6caf2be78ba8d0e50bdcdce297896134a316cf96fcac6f59a7941b41be8d2cd9f44f9191c4703a54cf94e1250ce7623f0a9f29f25960e9b89d7ca06fba51bfb0271ef9535c1a9a295ba45f65807da6e98d54c106cf644e140fe5e9819510e0d975b4d3f450425e931a31ce0272c7d5d3beb5dad246f8d9c32afd09ba89eb64e756bfa48542e2560fa63de8d1d9b14706a60cad8f194173c516a6f5b13bf7b3a73a8923205b7a2aeb4263afd9a4722ec7f0e297531a97d623f54aec15cfe9597d0ee94e7b56722cb88a7b9f8b6490f547d4914c8625ab37f5588f0dc646ec4e041c0c32d102eb3f571f48ba4386c84ede4c3f61bcfa25b929480c2e5ebf368c097cd7a09d672beb6b75cdeebcbe5960472faccab05be16b00cfe87370679adc46bcf7860f2c479c5d919edddbe12e027afc9de51ef1fccd93a146f4324a9bc754b942059c0a840290cf4cd9f141f4f390bf365573eafd249e3e4837fbe42caf5d80668ca5ee9a79c920d8d6389e2642f3431bcd7b22733d1de3fb834d4d599237fbf7e5a4b2800e637ccc3e306019fd5391728bbf995219ab3f3de41e3d472bd081d5d3893926032b3f34815a296b17141c233836ab75746297b4b4af234254c11d064de981e6b24fb8bf5020c29a62a84e3ea3363e27d08ceab270c3f207aeb5e8139c8d06bda1eaf4f3b80fa94a45f6f64e45bbb01d29e5f71cfca193e8e3bbc104fb6ac0d3ab0291de617bb94117c631304e86979f2067eea3a20be5bf4c0408145768b10c5c6641769c096afe5a53d3da2dd2d66c02e107c29c882177a43950d45b3293083e8fa37dd02b9c90859c29231fd8bb487ae50bac3fde6d86740f58bc4f3e224d334516c6e6a7c158a57e3f874faac11943283103421e67961170a4310a087bd301eb239b1897cc31428cc004186c7ccf2b91bd0ebec286af52933f8297d7e3885db2072b8c23162915c99e0393fccdf1ff60f942e9f7f14a7636feb89083b3cada6c0536b364824b804146e877037f78eeed05e00c6ec1788000002036da9d20f30540ddecb647ec633ddc11c9eb7d52a3f5b51966388ead32a054eb14ace30f89edae9ba846a55beb995f37d537fe05c41ce66046b865a2b4666c01c3461a5f32b915a70ac487ac0adc75686a5fb10256f25ab21e7eecc5c98f69b4af33fbe19e37b88e583b09afb5e81aa7d6c0b09058cc5038292ec020f3ac2e1be8e032b2ebd5eb1bf9226d146b7b3af4a99559c9097ef3fdcd607c056fc391c2f6ac9dc859d0a15799f6f016d828b7cd9b3292b443dc010be2a5ba61801ce0f7fb5783444d7749da59857bd165c2e8c0dfd45dfe642c7bb9f5b0609ba571091aaf17ae9168f4ea6a11ef4740406de9df548fd03af61086d7212702739a248f9e2e7d4a5de3444a33a9443fbeeef42404bc586d1ddfe10a0d52d96b15af8f69c9b110b4cc4d8cb27072ab8666735a2c061857648737b0022a7d0bd648d300ac0127e7c6a613a1dc463b4b747eee780c375b2228d2bd27024a0a129ca10facc8c65f0e7be9b4f3d54b36dd56b12e4a191a43c9c7231e17ceb2590405b12ce423b063442f3332d7cd5c7fe3bf6dc956b44776e4af30fa0169850807f49c4b0b620fad2d65d0f987778d2a62ba026c1542e17ddaefe302c5514ee46796837c75addaf767a43bbfa7dde1cc37dfad1e9a99c3e38855c357f5ae83fd9da43f500e4005f243d6fe6859a84cd498b9cccc0c77957627d49e984acb0296f54b7cbd9cf1d83e44478411da467aabc51f1f40ecb1fa6a62704e5b5984ed43db9a2fa2c08b0badbc5bfbbc664a4184b52f85ce4fc6abf122a09f4a266ebe7ecf273db68a66fc0725927067f1dd554df84591c90104ade0449b69923efa71c24b4229297a9441776f7f03648b23e3e7561b790e498acd98cde73e79d8e7119fddd111e637376c840124ee44cf36a0c048d7a87659583c6b61b52f7b49fe68c2abb210dbd6694a34f168eef83581e735548a37e0913719c85d5ca98eb0e12aa82fd7a0c394113562a925653a34ac8be2b5635813b36adc4a901c0894829e1f6d63a0c75da59e0a9d3febc7e58c99971de42e61b9481cb2d16c4f1bf5ca38aa7e9939915b26f32a87bdef352a2c398ae99582acab3da69deedcf74ac82fa363b21c6ae32e9e43b3c4f1b41a952c9a6b1c5ad170f30c861f1400f0a54ee52901c851c3a38cb14406cd49b9cf29cad30d92666cf92e3d37e6d2b6ea86e5fbd3f89b59478cc7761c93757ce07d751111616de13928f8e39b919789335dd4b6279c753421a95cc43c10feeebe14a50fc9fadeddd207ac87dd5e4abbbcfcb3b419f86725e25aab32e3daa7c2e0dd188009f5dbe1225fd4d71dc6164492fe23eb42393ab0864413aae6d82013192467f1a9da6ebdc039c92b4282d01f0967ada4c6a7a906fef13a6a0abb50c324f560ad7139adb2e0eafe358be058357ee72d75b22784aded7b83d8dd707fb4e1d5369e610e655868f639d6edb4e3fb4dd7372a54f837c25b2a46a9a1b165f05aa0c588a0dc1cfbd5989ced15372138f3225af922df37b42cb31f5bfdc45737d9b50bff652594a020162ebaf021212c4c4614e792c6fadf8edb72b4834213b4b6157f516c0a484e0699aea5a605899dc1a002847eb2869575b1cd3901230ed188d88b90b23f32e0dce83bed7a97410e67d4b37dce0dd6b788616fd6f01054f88d377440a0a93a01dae9b944becfaf96098fed9597c0e056b8403962f21ef989517c4b09382d493fb7abedd15ec2b3abc48dc37bf4aa02a0b17203c933694a0e3b45efbe85a6fe8a4642c6981182bf3180bc9643bc47c12b2cc020cd6fda0eecb271832fd52b3ebebb5ac8fca051ada2d2d9b55f940f449b92b06e964a961b51bc19f0999eeb40e17c62ce17927db2d47ed23613f8cf1e41da3fbafeae795e82d1359e34765f6ebee4b8f93efabd3075b6d9f7a4e8501b33e496d9d6c1ea256fcbbacbec8e8cd216030164bb676d10242491da9f7c4191f7babaead527a147953686b22df3e43480593614b1c7261caaa7510ab19227eb6cfec7605d74191637b60a5749fdf61b08dbe4745d66a52acbc2b656b29f572ca0f1c443f0c9dee9f10ada307d8ac1ca414eb31db165c1cc3a23945d85b93ca3d8374e97f4cdd83134b80b88db7f1c02cc7a7b1d831342ae2d9e339d5212bc514100079021f81af18bd566dabbc7d032d0a0495db140fcafb3358695990db3144a83e52ace63caf5c954c79c1d6669da83f41d08e63555992f211b2ff2583c4a5a0619d8e60d75152ddcd40207c66b615d4c81b5839bd759332fd2b207b6c5ee7367b2dd2a2571555a8888a57036a2f0d5ee669c32f51d489e53cb38e43eb27998cb3398f8e749a82e093ecd9bb638820d0755540684de33f1f025ab062c2322975b95cb1d29d0d7b9a8a2037418666afdca905155896159a47d06f32323d349e3e915fb739ccc5d37cd4a9b7820da8fc7f6fa74ba432640a23a316d12b582b51cfcbd7dfb68aff74bc517fb876f989ba68c608e113ea2988277745093e377f15345c56ad3122cab597feaafad51a2f625afd4fa717392f696f1c63e0a069a51e5b47ce7d96dd7d3819c34af681d47724cd13e65510690ab7369b9b809c5adadd5d6d3477a5c2d3c2d3b4e158cf71bda2359eebf79753f8c141b2ebf42573f837bf46da7859d8cef40271c836272c75df0652a7e741f5475de9ebef514e261444ba746a3d9cd06a754cb309147404a25ef61adb7774d07707969043ba3fd641083e5f9489c003d355b9c337a1cb8d27dcd391c45841c0e50e3f38f8f0c5e877ba6407e284f5a9972e6f694529b2de8802eaecef3e12fb2fcfea325787c753585042d68ef1c8561b4f7d6ab2c65bcb4344b85f2cb5132acdb2266ca8da403d78a6a0e9ce73a0bfe82c546aacedc724a0db40f0e3580aa03bba6b94db70bf7622068d753822b3a698044032f89ede56c291c1826cf704399564dfb02715b48e6106c2e33476af56c85c126037fa24bf1c9cbe6ca116368c6cfe25b5e1c5d0c1a84edfe9271e1ab45dff068cfb9997157220e932b453cd8a39c69d72bea05be51e1aaea66f0583863899737c68890be8f75d0fb20134884cbc32e50bf3707fba10392bfc7bbf9e355cdb82a3de834beceed312e855596f4867a7fb9d2b1ced5d9e17d79a34df2268cfeeda7d9aed259005881d7afbd7d0d3a164cab69543a71b1a55409e3baf872833787c26aa364b07388c9c027408d7b662a0ad8a63de4ef9bdfad8c4058e647561b6cd0766fa5aad37133bcbaa1e1c20c074f910fe2cc91805d36a61bad8fa33459dc0eb069ade490c473bddba923fbb3e0a83566d086e4c155449803cced4d7057c0a2999b6f5079035e07539e1ab571aecfe8722fab72625e57e0f5bb5ebd064e78c5de37f28dae9f6408df66750759aa76b30252ba4dfbc6028267739c0ad4c46d21f26b25c0ae1b1e181ab051046aa0cb3ba0638707a49cfcd705784ae299e076c8d3039b73f3351489fa21c01c9c675c65857517e35b284772bc855f28ead192d39f74ae96d37c5850a27b7626795e8b1f5527c807009abbaf34a52ea02d6ebe4462bf34d147e234154406d1db79a7c63f11bd0844a5ca78b2c50098fbfc6df5924c5f0877a4abc16e7327e1e265c9f9ff84546355063641ad93037e7dc732fe84c05f24080da56c11f583798069467b205faab50dc28c0a4c7d2fd0abf7443020843cd35182db5e1f213b2dc3efc20132ac48090134c919feb558c75408d8fabe7719d2670f81a50a7d0534442db19e205027df8e5449ed301a005e439c64b363b11381bb18f56ba3daa3c8d1dc87b191702d639e7cbe8ef575bf8d8dbd97298a66ffc245a6accf51af49956f8f67d2f9e1dfd26d2aa6c5369a5c18661747fd43cb67dea073845f9eaaaf360f0c29d8b3d5f05c57f7d6c33b34ba271b720669446b90e33abe81dd24774609615c4911d1317bd4a9aedecf77f9599f7b0499213aae549400f431ff73a809b9045cbbeaac833cc38b1042465557f46ee7d8ad9c5bfc298bc9ce7d30fa0b4c8025f810027fb2eb8467535ee36f47b00515f0a23a80456fa5d9f8ec85fee2eca0b42b12b0be28cab2ad5023e14b8ce13f935c42826c164acc29d4aab2a120fb55781be22703a0c7cb5ddaff1eccf80181a1ba756f89c88b27ae252dfce53fba2267d03c1f591f9ea4ff6930791bafd8ea6a2b22c18cac902fef7e1395a634acfca1719bfd4a74381f82f90c2d225e535936da055cae8a6e5f4eca6b48e04965f8ce8a3121e5d53a47bed7b09ed125cdac4ff6a0bae5f15a80ad1985efa21bd77808341355c1623e5dc27a1437b8a4e9513e8ff2e9bcf804a6ca0d537229d441f4bd57692e2961fae72bc1169ce2fecb1a61033d9c63f1a08e7528050723e80af40da7c27d0a1c1adc8684c52d9023703e1eede58bfbf0325027b3241ff0f0852f66a09a1cfa89d0f305f52318ff08f2054a39ae49cb8d85b12d2b8eb3487681b3cdd418d8350a24f3a68ffa64e8df9593f679e054a7272e76afd598b8251efa353a04802ef21808c02266115a09e7fc8bd650c9c7a5764d812fac18053e8b1dbf33a1440774ee40c544f7b909742634f137ce91031d51966c914ceaa994e84cff3072ee9f095ace9b4f3457af63cb054b090de67ced15d7eb6d76aaa45023576ed0e257e9b097b2371650e11113cb755f194527e9b2e02c00d12a29c3fe6531b18ea180f91cceecbc46059f9f051d4e27358c0a6d24b77ae530b8006051ce89e715e741ad01ba5623f5fc1b5e3458459bd033438c846b102e1b4659eef15bc016b7b57ec3eb00e6964d2f13cfd9fc60a192e221405795eaa1b9400ef354132d18669c0edce09ac833db5ec8c3fd194d45009f44e67fb97772b9660601bc1ee4a423d565f9727c39253dc163674e8e269390188faeef3f7983e721cf2a61a99620c6e14f5e6ce247f4a663e8eb9007d459085e529cc1d40cf8514b683ad937ddc391a8684b32c12c7c3da67ae661ac5e263da352ea1f045f6ce179d90733552a81be5a0e85a7194abd51201c9fe069addf26d86eee71c7c8b705cf424cf16415215b76caa91262f57267f046956d62f99d9d4f7b9a30c0d5e9abb528259e450a1a3151ca5a1db0681c7f7c62f0b6c8439367a47c22651f71abc4bfdfc638ea0b262169d619fbf2a5900bdca60fe1e168f2cd8ff1bd23c69d903f937d1b2e7f8362deb590e8bb13fbcfdf85c876913d2addffa66cf8511fde49e42665cf745cdc6e604bc64768b1f4e80025741f823ab53fa2d521eb73055b3db6f69edf958c841c2b1e0361aa7a09ecf5f4aaca22003fccc89b52bd4cea156cdbeba46c17cc9ea45ffc0d74bb3b2113f6337ec9287b3d51ca498fded89e12582e45e5c04ed42358af67961bb17d1fa713160d6f1b9a0d7e629dc9615ba1ae66b0aa2d69590aebb96758b6d61e9b5566a2232759da8a390834a8adbd0e136079bbb2ef0cbeb5b2bc3898b4051125b32ec53886c00145425f3b798b1052fdc63d9a7fe486a427cb9f323d905bb5bc417463addc6cd7a25feef3cacfe3c71448fb5ec7986ee381303942e56848b47831d90edde1008ae9763b8a0e0d8ae437ed961fada4c31a0cad6aaa87372f344a0a5979ef070ef189bb1410ca641f327f9574b2a745730ef8bf7d39acc4d2c2e0b62cefc42f84b0c21dbd59b84b2b1ee2b5c64961692d58291f9c9f9e8336b5185481a05337430f9f2e191f9381867d7c04142acda9e317708e0fc6395a97e55b0b9f53c4f69702b1f44461ec2244092eac79fae0c86737cdca6d8f98994ed0758b696d3cc520f028a99b25e1fc80e5ec647c70522731d8cd092a0658d1058263be6a32c7c5fce488e304ff1b3a97e27cad56d800080d2bc1c3547bceac82b0c06a80c07f440e1931f1cdde19427e2395cf65a41373197ed52f45667268697337a00354f385306009b93083895dcae42c683bbad9b5504bfb4a369a354c632913bd9c835cdb0dfb0f540d1901a9652d190056fb9ed0a68014670580429be09e6d258ef2773a692ebbf78f197cbacad507f393bd4ed9ec96f1a8d0facc7e1a98144d94590d70b290b6ff64862d3d31c60acd5a178fabaf50344a321ab1b456e4d98d8a7a093dab85a8c7523ae78e49081608a3073c175359ba4f6a0419416cc5031e8430d6797547a72bfc71aeeecc61193795427fe72823c9e8773c9f3bcef834c9be36fa4c71ca5aab00f94e05b22352e9b8e7d5ee03f16fa2c5729baf4051e431494f8dd703b977bdbb55fc13fc0694e9a96f97492bf09e663863c9fcfe0c0195dd135c4215f2a30097022b8d395be6b590c48dbee5c0b9b9d832a51378c221051329c6d26e8bfb79df1ebf7e53558ca7a30a88da440d675bc44a18bb6b5c65c682bdc70fea9abe5dc03a4b5c2f0b398e8215354f746ed1008c2291308f311af923dc2bb81e6a57fd0871ae498b65e4dd051243be835058230e95e61281b524ad0f2b1cf0b108e76445904a8b04973fc3853c55373ecc97008aaa8993d5162caaffa8fe55ac705286c03e9c17b1a2aa4f0c00b555d4db0b5a0bb8809fdd3cfaee0fe2a1e8f29e24687042f4ff5363c8832efdf82dab2220990414bc2a440245adc2e401b365207508fa3c3a43f2beb51436f3d5bc583220352b7f2a8e69bf0742f8cdbe466359bd64a31366378f9ebe890488dad400604fc0a6399f52b948a1d6afdcf9583c73b68fe420c0515b3416f4fa97857b20191e7f92bb7ef8244a39d3b79cb97be5bbf9cc80aba9ebe9391b385496bd5c22b385b2b54450a3b5aeadc243b814b05d110517524112dc30450b283bbdbea9978adbc0fc7a522da6962059fd59e03e4be0074b76be2a1dea6f2fdb6d693e5be60615e59dc406a4bfbe916401494e916e37d5b05bb28d1ba0305e5c4e582d2fed2689209102d1bc721e9373610a12628b7b51bd2e16d9c850b933e9befb78fd59f8638ee9dfaf7be7f0b2a0a3c7d6b139ca788f9c59d54b5043083f8e59869534dfc26707080799d8ad0f3054366f8e374d6152b48e652a4a7331e35143f18eb7d70a5d9c371195570cf89448ae18212eefd31c9fd4b1912d22ce5d7c7ca72bccdccbcb50a7c598be900cad66eb68eda81ccaaa2de109739a4f643e3a03cf7abfefc1997e7f55d5885fba05ff24c5221163645337fd27092d0214751a636f7f03df7504855d6dfd4cc561d87c25251d2485c3b0e7e92816bde52ed46f48c369adabacf916a933fb4eb65817afbbf725f71e7bff92a83d12ffbcff4235c533091e228e0ee46ffcef49ce8a7ac808fe6ebee3af33bf24b2aee7b580a52d31eb8a8c7564496ec6a8c2851c15be1fcdc662b16a744bc0e048052b12d6cd0442af4ae4b8d90be2b40aa6289b3db7e859c3c39d1aff1ded5fc59277e9d89703383ccc201a18beb02560545f98be91eaeb4d868625ed90c8b625dc0941f2d16b263a8dce4371b0bf9e7568c83aa23438a2dda1957073cf64aba5c389d38804323c1998b1874e7ea52740f6e2219314d2a1c1431fdecfb7517551ea2e412b0a764f6ac34d2f85901fd222c8f32de9957b539c7fb222cea71eda5babc030370747de3772054bff4f6217894267852944356cb492f1890d7c5b2d851889f2664839e7f75df6c7c1a943b21387f9772e8de74be4e333d2e27c07731220c073043b87df67f6ecc3d2d577379b6efaf07da431b44f266511c7f0296ed0bb23f2a5e744a82a34783d71ef30be4f720ef0532f0acaab91fe69b127fc9995b5e136cf0d5bc1784f23c00db441568c4c705d1290a7a38c4616c8009db20cd711d6b78660c453c9bf01d506bed88e6348c958effe2ececd59ab1c9c40152614f9ef351fd0297e0a4e849c818b07d9750cfe19d5157e198695090af617d5b33c17bcd2ff2494bad9061e9d4f2d1c08d0ef80e6f65668247b3459500d26b65e98ca6ae19bedf1f1acc6fe0ba21035abe8416545a41e83e39fd719041cb7fd220f415f1de355dd82c6674417f2bd319fc1a89d208870ab819cf93c8a02e8744aa1945068a49331cfd24e59a7aa0f10b74dbaf78e25be28e0e7e81a63d477784c2b98b279d971ebafa6a0373d0604660a4f2979e0bdcb20f379531c03f86b8d223380b754d15f051cf8b24b05c5bddc05f93052924a9758ba3d1b05d08418db0e0d189099d18b96edd3a2020a9153600970d90dab23954f0b248e7984dc46a3796022012a77064c7f90c36c65950a68af705a73ceae13f97a58fc76404dbeba843091e2d74d6dafd0091c148c60337113a7e851bffc504df334a077a3ae97e5aa10ea19da630daf8fd1c36414638f9b9dc1c50ceee1e31a48ef16c397665c532b474986cb9361d17ec0888c54c86a24e260d3da0aad363522ea32cae5fc996e4e33833c0582e513cf950931da884b8b2bab573b26c1f7db2fac314255e72abd167faf15154edba9c1cb700bb4053961fd84ab71934f73cee177251cce7e3aeefc7a5d0ccc89f08e0802c1c716b4c8f5c67ff8deb1faf74c8e3df244ab7a8021f356b7fb66f602fe2f561606af9b69f3afeb2d28e440e55c083775735e69b028ec03e8877bb7706e4542dad53aab8d253a718fcfb1cca00736bbc7a3e916fcc6b51f001a82760ae26b208c10ec1c6bb57d8e4c911961ee2c96bca99c8a2f8acd2276d9d298300d01a8189701a29fae8c215aad9b8d611b653937eb7be1795737ed58de179ddd591672e253643d4a04c200ade8e7bbefe4875999639c710fa4f6bacf0b56d2b8ddf6668858f5243b9aec301dd932178a05fb697fa11cf22bc6765e689a05dd62c42b8bc2391f546a5bfca165212feec1c3be39a66ba97b35763b5452907b760f380b0fb05b04985194d67984b6557d8817234cc6b2c1f73dd2d3fed4c43f92f2f892d10404efb28d20502ce70424402d13608470a04a0c241818d3f4a3eb46881a677d41396f94952917d1ee73049bccc29f7b6af1f731d0bf53ce451cec9e8e6ba3c38c8090d761c9684b5995de0f9411ebe98456696900d2c9e38bb803cbdc505004a2a142cf766e774a7714eb019700b096f2afa0eedabd9474ec9be3498bf604dcb5cf8f24afbddc22ca430c2b2b11c0273df5b5529d61a72ea9298a1a5d2f0d268f35ebab0e8ee80a6b683c9861e103d6ba43636bcefd995bdeffc7597e46a5f32e2cfbbea1c258c8ffbd4c6f83dead83dd4d7abb062e575a310b62e4dcfdb6cf69fc32c1a23f3a09c75115cbbe74e3e2f3ef4000a6e8c3a7e4990a62394bfd8ae3fbf5427935f712ecdfc656af93250aab90a7378a69689ea2e579a08ba6339e99ca28130e4ce0c76303bdd9b3429b8ef95a3690758b586ac485311a54d665ebb9a7c32d2ccee5cf50d10f9b31a6f1ed739d61aacc4e426d7f262237fd78c74c4e591aa69099a64b83c3a1ff389b7d9b8be3005682fac46ec74fb793f40ed955071c744c81b14cd12a6f18f16e85239f212f22a2c503c4b3c63de84f4b39d2f905245d2747497594fedf5856d2e9725a330f572060761b28084cc737b74c79b691fcd4d10d53841b4d55b9398d6df9c9594ab219d9d73d1cd29a17ee81cf3c0ddca94a0e50441931ef7dafe1239c9a9b340f82cce205a8e9743a41dc969251ec76f48bd250b3adca87ef2492574b9628276ed048a53e4a5f498d1a9c962a94cae11066258c534967eab2374780f61292903cb466f3e5699b5ef37c4d146700190a4f9007ce3f5da5d1fec0fb4837eb9c3cc7b39f87f9cc719a0231ac3d14ec05f5c0c7f5a38e2613679346e06ad9a4eecf695795fe90b85afb0a0c4306d264e3ae3ed5fca695852d92519779df04bad94f81e3f0c040a0d2b94f2fe74002a9fdc71c67b74843dde9fc53d0cdbd9fac9f8ef0bd43b542caf936089100c1c5297d1b22a7eb54b8915d6d7de9c5c0ee7f459eac81848c52ae125cd4c4e648cf958dca05a9f19d3d01fbfea6a715ae4571088dbc1b27593607788419972abcffd1005515b0326b18eccb7c35622787474443dac4cdc54cf6e2256f7b0985d15f57bc91c2d3e6a77e5b1556079ce88b67579b9dcb545a09a515378c8f463180e7fd412bfd421720a208b2e1d002d081fc7182a9bc0c31b964c89af9867843f483c2ac76b997d871b2807514eea1b70f767376e5433e9afca391dba5ad61149d5070da382e35cc37999db5b9ec48aab543adcb9f493e15d93646e17f639aa6763f47efaaf92aae152143035578e20344f4632cf55c8bf9b170bf10292bc5705aa68787249b33104571754b7cd00b30ee7b47a11670006acac6a6e0a629a03c241b0b0ee12a00838c56acf3a42514632d033544b601e2b7aeb0857b57089d7ccea89c5f556c312be529887afd652cb4a52ce4f3070cda27fbc9172b0dc7b565d0202271f44124a758ba89b5cd6a715df60a73005b64b8c69cc2ab726977ca35c3c67ad970f3cec13295613e03f3d8b9d1b6e4a149550fdba5cdb4902ca933cdd7c214c9a9b1c282b6be29afd693f9391021df9fbd1e168551225f48988b9ba0b24a8b9489cd85b108837674b16c922e15ed9cddaca4aabc7300864a52650aaeda83fbb7b08b6102d67ae4c8950f626719c5df8d8fe1099ebbfda997fe51b87a89d29168c94b4bfce47123179b6c30e0e73aea5b196ad8dcf06550583a4642573f3c250428248fabcc933cab0f412b24d9603ffb208f58f2413c7e72d126edcb39da579280e32d7f331aa2ad11e5a958ed435ca88c838670005257c3fa8f23e1182a7f11fa0d3c4ad9dbd9cc40e4fd8d78f87ee2776faee4e60a377d0dc3aab6a45cc9093dbed5e4cf969f6ecca6a3fb321eeab47cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
