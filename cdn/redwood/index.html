<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a92f9e46821fb1ed8c1664b97b33e1a8d4dcd1569c229fd726bee0175f43f66fc1bc62ab8732adad79242c8bf3a3bc2006a7558627a03fcdec9a36e4020c6f73588610f0763ed7eaf9841a7fea5699e8d63bacfc2e58e9f54a5b02f983aef09e87711cb6baaaf0d9dde15683b7b95fd76dc2e7a192515dd963617920018c4b459d069e653c33e034bc2853f556e7f046bc3a0b865617da88c91a4f03fb6211670c12005dc6593c37e9dd87ff4715c4d5b96f5d5961b68ad1cd4a86be9b6e3ec2e198f341ce5440e20eb545815de728a6510fe932615abbad4fd349670b6f1eebda4e62c0b749711708478c3cbe34ff9d2617bfa4d84d5ea4a8dbe6d3027d458f63fc6eb3a4cf155035ac726db06bcc304aeccf7c38536ad62e0ba45d1508e25cb60b20c4fdc69362a0ba97fdd09a048276e313b0323f9860a5b1a165c65cacb88d3b361040af153fcdea18b2ecb2d8c233073bbea529a91c096376f8fc6dc338389cd532c1f08c67c1b57fa169cfa3112e1061c4604d20975da2dadfa76b702ab3a580ae8e456a2ed0c1a371870bdb83188d8d299718ad480e66c781a25d4dc46695ce17074749e262da65643d0874c9cf918004e46843905a1346124d467464491533dee5aa9142a3ea11c55600aeed0f8375884169dbe34ae4d6baa857a33a501eb5e75861a62a6f76bc86048828c2437e94103cc5f36d86fdacb31747f6dcc59277fd6a1bd8938454c99275cfd24851e7ee59ec356c461e51acfff21eb7567352170744c18f597cf56c8402126c7d50fce979926ebccdda45cb921b1cc46f290d8d81a4bb1fa05ea577264f516338fc76ce49c41db0af4a7fb5f341918c03e6dead79d6e75d4aa8786cb09c97293cb1bb2d1fd90d863ee4727088d0ba5ae26523c6dac89f0f9e56d2c4781145eabc12a7556b4fae00bed13f7f8d5bce209521b0445b1cb3f9ebc14ccb497dc13275d36ceb3f7c20abf0d2a3f3e225134e0c6cac0b3a28333bbfb702f77266ca036f5d673c742c98de1b66aebaa55c580f6fd5b705f235a0fc9a9ef3e015893ea10a10009d800252d84868702e95f4e4cd265491cc39177ff618ff6f39453bbeae11b399b5ef5421b7f12c307257b54c2f7510fc2f10570b3a1743bcd7e6e9a98955b205beb577d477a021044c068b1285c5512bf7ec4d5d3b0a9318cbb2cd735f285a0392d566ed875b4decbbecf4acbda5cfbc0cf0fe89493a5ceb1d219ca72cbb21b47b03d0e884126f519b026fece087d44beb095e267894e323cef864c6dfc0eb4bee32fdd71e153fa9a5e5c55842d964cced132b9a72c7c751bd9064712221387ada8ec5877d8040963c76b8f670c656e0ba4d8314a52a21eec5fb456e8f8a56cb2e9888c17b7cf7eea8e26a91e4798ee54b0582def10ca2c240b630eae2007802e656a1f516d70fe65bec52afe09451798b60767990106dc48bcb1a5895ac3b70248d6cf832ef1e90c8cddc594ed4be8454a10f2f3c70d11b1947ab29f960cd2d3bb3ad08b2b449c0d22d372c67ca0533db193e475240a82c9f6177b5480fadc5418be8cbc0d6e0f76c7aacb9d4f8934f73775c2ff4506009ab56ee2f3f6085867c974b3a823616f3834e6283bf4b61e416da931f123faeb5a34dc5f5f0009533ef30fa5ca837d11da9a4f6d7a9ccaedd14496faef3dc8986038e928632c07d99a19587b945decbf9770dda86a34b81f82e5ce2fc18a6d0863180664988d717f107dbd7681209f55db1a81302a5fd0e99523290484bb1702e2fcdf84af13b434c7758844d731e8ff0e1709593f476bb257044ee64d94329daa15f47f7d49b39b2bfdc13d840c1d422d36cdef0c4df19bb8ee963966a51e1b5dc3f68ef5a0ab401c2d93be591f48adf6f879cea1f6869df322323a1ccef8ef92dc40db8e11e5e80a6582325f01d831d29ac431e054e8e9e867107993e69f45b9df8b209f44a2ac87e437ec5b2a6ae5f05d051c40685b384eb661635b3e95294735b25fe466d2cfabbab489e4b133a83cb1e145dd7bb8509d278c2c7091b4d114d99286f2074e9171d92cb48e308664419946ee4f84b475e8ef9f1af03892227355b859f8251347c02a63765f7ce6c2eb481bbb31927efb97238358d7de40e706cd93de9af31557891310e0972838ac3376f392fef2865ea70da918d155ee5f2c5718297d427924441e332002b17a43c460e4ad8da784dec86477c350c90e6807c02b999ed2627f8555bbe32d6bbe3e79d27495d9f544dea26d14d3d0f484a48f8079588cbcae4e9e20f9ca75f9d5761262e0e1fb28300b87bb078e2d8b26c08f23667afb9b862554a82d4ad191d22fb18c2f83cd55a8de6d8b4440aac834e49794efb13abd2ba1bde2dcfb2160ef1e77c9644d5acafc480c45ddfc2b3e7a7eb0ce21fc41e0bd05a273a2207de7e5dc6d20205c1178e38e96678235e3e01a3cf19e050b1dfa0ff0659bad0b9546d51cab7fdc075c3a4a81596f1b5b3818cfcd7f14b28ccaedd882d7c9f9e3cca256f2acc21d0616cbdc32ce0ff0da8d3aef1010e9ce8fbabcf0c9a425a50b3f7129db04d7ba3f93e146beff6485ec3e461bb0f113a15777130cd3fe42b60ab96aa00f04b393a4e19789f7a308e49c1de8f23a20f821162a33be6ba22165bae4b92b0fbae41af246e785e20a02e388587c712e7fb7e9959852f3fb4cdafffb9689dc64c857d4bd0ebb59cfc4d94d65015c87a964116bec4398fe7261eb5222036ffa277cedf539a6e00837aa89afe822d81385cb4ed930017b6a375b6b8c0ddad210d935f107fb538096993392ba68553c4bfb9d9ba5550f512308a8c7d1dad863198c11d1e3444fa8dd479c4bba4cf9073b4c93ec5c980f98dac0578ad27f5fbfbe70546b599ee11e782f15598f8a23bc540730de1e4b5b1454ae7f748608ab8e5ae35fb3bafc45bebe2692916c845ff672a1f5ffb64d5db28e8658656f5cda3a4a5d424af6eb9fa2b5433f91b7e56b1ae5d3414559d1e875a826f357055f4011aa98ff9954a1d522c69476d94419ffab3e1d9eb6e7b2e46cfd2495aff3dea8875e0c7de3e96fa78f471d271107f62ed2bdd66ead63663006d2bccf99bc659fac1058615a410f4a7e65ebcc778a4f120224c9b18d47c4af650c056cf0e93462cb765934ad26c7135d056e879f02058c0880cd0984e429cae6bdb7c9e9c170b5e8ffe8f7e07d9dfbbbbcd78c3d75c33a21bf7af4c8ce443a7d01eb16900305459f76bf2ca038be78cd5d9d5ad22811fc32ea283680a14c5455c73acdb79e8556b1bb63ed11b8e4f9eb605dbf083a2c6ba234eea451a8f51342068291bd133a32280a2155be91f3f836ee7af055587c1d242b71f12fb839d906ce873be01b817fa0107d32102b6b137ebdfef9b0ae1bd4bdea8df2d1268b2e8bc015fd230b7b5bd4503117a8d001442c972a3abb3f0628e8e69ae9d298467af02e8649d75f3de44cb2a60ab69b4868e9cdf52bc71ea378808d7ee585bfa437c9cd32d87a74e8fa7d1fd8fa8fbfdc38317298b047e75789985a0de196632e8edda29aa325b30f3b5cf301a809453b1c773de591baa84537e0c7a16275be1d909ba38c384d61cd713bf2e09c7e72598fec36fefecfc4cf3985631835840f59c177880a011c96f0ebb2a17073f31fb9eca7abfa9631c15848c89e21a8f8b279b0f442ea3fd8fd3a51aef706a65c26850b9e9fd7dc23fe2fdaaa4c158c6d468d5d70df835dc2d7d994ba143784f766baf10221490393f0c6eeb5527343207c82d22ad1775c1124f5ee0a86200ed0562c41c018cc909a3508311916078c33d37510cb1deca8391b123eb34a6f10099e32f7f651d16700531656e8e18f2958eb57d78880f220af159a78d3da067ef0131db7b605ac555b228764e747d485948eec4282b6c4af890b9ffca091ed5bbea3d92c00f079d113b92446a3e121ef20667dae5da5c011ef4d649929c44cbbe580334304b26c99527568e5fcc84977597339fae74e20cdac17e6753c95a507688c2d140f7f5065022c833d9709666179643db243cb5dbaea77ea237f6fffc3e3b37ee4c319f034a620b75b118b7d1c8a8372f287b2d26e61e402980a868a3baa8893ddc421281c447f715df669b07c91a3f1dc59dbd930313c4d8f3288946bbee9abcf18aab1af787aa0c2d6ff149106fece62b57ff39cfb9c96608ca11a3e7ae199cc5f47602c409d87820cef6915394366c9c6a89d517164a453172c357f3f94e244568d15d2cf52e7b1546d2a831d290d5e4b91c8de7e75b7cf7f011fcb814f84ef3d18c6ada1fdc99bd97397802730c20a8604fcd80d502c173b95bb2de987b68187dd5819b84bf6c1fdefccd799007feb52cdec484bb3c09b2e5d3a2246e1845ff8df04f255b51cb12f4ed3c338a671b6382b803be46b35ec5378bb557e6eb22128446fdab1b3b8856c54deff56f828ee685b39e598c862bc86960250f62b5064307bfb6bceb8cf53f9dd85726f09eda926b653b40e1c6f7c388f0c44bc0e89187578e779734dc1464c06f342752765ace0f436e631f58a26f3cb9b91d52cfefdf08013e0b18fa391f47e61f628dbb5321e42194ab9977a9d10f745ad1bf0a43e42770d5ef6ea37c753be9fdba1392a020eca77036cb484e37d4505b7b1f36c2afccc8e41d6c4c924692ca33042e1a4d29b3fd8b88d1485c2e93c57899d1a505e3c14995429c9b34da4c535ba75c9235db57458a97ac1b6966f03f7e1cb7c05a06687a0ace2cd91fb52c5cfd85174207b401068bb148cfc031d7ab9dc95925a4a6bcee6a7ca1a04bf08e11a07d2f2dad51d2fe12b57c0805824bbd14f33f84af8e6de7c190d7f72ddcf4b4ba4c7e5bd6249969e6d43def2b5d3094244948d97d2c39c5f33ee6290f885707587730e3252495924763708a771df086de29fa5e594fd2cf39ceeeab16310580f99a3d0d3c3e7806fd7219638216d9d3b65ce674e0c286a1297556ea32d8e666ad6b58f6d7af69025d1a6b1151eb02b2b6735ac669fa26c532282e1988d3344f537f9f78d3910eca4300c86e5ebcac24c02fe69d8f4e06f797741562d94a20742f86e949a47eafbf7de82b876c2370713087629fd9574ce2cc7ed511dd9dbdf816d1a558bd261b488558800851b0061a98b99768b78d728a3b94116a54beabad98eb62be83987832f4777874de18fae59055e19c688e840a1721d7d266c750d48d306a78214ab5169269c0f79e29b8ed85193081ba4f84b3af65780a1fa4f77d460246ec5c9ac39741db9de8a40c950312ad69f3b98af19032c9a7a2ef790bfabef1b1c705c6875ffb5cb71b4e96b532cf95d96bccc114116c578b8abbdd479894431118e412bd1cafc7b2c76f9f5dc54fe9de66cc500fe8a880f29a921c5c98466b17daa68c70fab898160f77ce0b0b14ad5b8bb9b21cdbad21295a648f735c963722169d1d3aa391b66f1523158cd1abc43ab0d3fc138fa0ea20aeb493ac7437dccf118f7e5e46e304172f776cfa5889667649d265466a22632511f0f4eb06451be89ad02da3a8d0a194bb12fe0556753d4db009d932e339f23d1aa9cc3577f341b056236ec7c4dfb8b0139b8c1f62fbe98b86afa5cafadbcd38cee24a0ccd9f130bcd583704a9ef19637dc183a58188b49a25376dff88a8266559f000d8a434e78ad7e98f89ae5d230573794a65ebba96ecb49bfc9af2a512a1cb7d9b613ead400459bb1bca3e7b4b99f4c535ba57c3616f3064c2d65b38b58e547633e4d9d20a91be871688e36f3aad336decf9a1d91399f90d09498b79bd84efac645207032994a7c03a85d2b0059dba05301b15505491619571f6c000debf71a785cb1ead60768309a99ae5a4c883ff636df4941f640832fbdfc41aa5990e9e64fd68160b51851e69dd169cbf269333e5b67cfed367315d8c96d9dd89e36b7c9db578152215fbb1aed2f04a4269f7bcb8b82c7efe85658d561356165b5325f2b0a35bbba9d331a36b74312f98e63d14fe8db6f339d5d6a45fa7d56e9c7c3d357b310a30cebaca9799c542e9a00bbf8302af36e7faefbe6965b77052de3d08028f90b7b2fece8ec94b550d4a6555878c322435b0191cc81cb93770015726ef9990e6c9b2b510863d7c1693662bf812a1abb05b22459ae80f7d1ead033bba0937086a73281846ea37851c91b056e3dcb64ca35ebfca7019a4aa683802838908015d96a7bc1ec3b2606d47977045cfdf1ce6d1109b213d73aa0247df9d18c91c2800179a9a73b6962089003cf7728ed81504eb8022d09b5961da0c39bd44909ad3e1b4b8b6b0dfd962768e7c64e7804c2a964eeb5b6ebb3e8f5e4c54f3c51df4fa1643de3366e8e75d1eeab5a110365326c59d7a99eb96f7d88ee4fb2dd45916c90459f95cb23fc0fe81d76d48ebd44c0f5b2e2b9ae4dc4727a23a50f85557dc4983743ce8453506aff7b297871ddd0b2814c540e0f251d5cafd8ff9ce27f4b3a3e1163293667fb32a2729f0548035778df6875da5d200f2b1055a8e31e3da0ed16df7489982b46db20fd591e02990675505dbc7169280e053389d19ad568bea719b33e74c4cbf04fe5121f4593096495c4154f549478cb989732aa6c2adc6419d095afe46297790f4d079dde491f275fdecb51c3ef5b9261ef91c75ae2aab2646a44e61fadc1441de2e35dd3438ec1ea77f9dd8581c3e5a7a3628a445baf9c6d8ada68ccc4844bc2c898ea0396908fe7d21a8676618dae5b32ac529a8fe07871b6771aa5370485ad5fcec26b0fe90c73ebd1100533e87e4caf92624e091107fcf2ce75672d95e1d2e7d64d29b6af3452ee800f360e6a0e207c3214225a950efc2bc060c37275d1ae5c6ddfb5dad863f9acbcfdd3fc86e7e1fbcfd0c1820bdc67dcd30b208276c1030fa7ea7753fe7709b4a60601b5d0b17c4c622bcf0ee3ee2236d5dd48c4b21436b1a0b2139b9d9b7350a39f1cceb3fc7ec3061b752ea634f4fae1e38547b5226c46b869dd0bbabf56ef909c4f31e8fc286be7e7061b620d864965198158ce2586d1f8d32ea6fcca49f900a66299cf39f7e2ea3ec046e19e64119be269543b559f06bf4636d85ec668ba8194914236192d7ae8ede1f972d386133cdfe3592bc83a8ddfb7cb3fbf2671e440464ee32e423f951c5d5400b687ce9137176ce575aedbb801ebed51dde797e5db5b54d84dbf9902e960f8d5ca718a595ab9aaa3befd7aa7ef886bb52b3b4440be117da5b34c2a5e2a07dd0883a2767d7dbb88ee1ab0ee6940202ef5f623552f8e5531f9a0477d37e16703f105e9ad573fa5ceb7b430d06d261e9e37a7e8cef532b6c47ca1ce62acb634fe93794494a75cb5bf1b31b4cf183061b85f9c64dfbacb8d8beb1a18d10a4ad856ef1b734ed3b752bfcb79bb87c270d61778afe151bd7c61b1510ff118f31cbe7dfea4753d1abc3ab6ff00fd1229c9d5209b04cc24ced46cde60d31072f35835bd7c16812dfac548cbdb2829cb5647dccc3156520371b3766cec4da427c7dfc7dead456efb52e3fece4c84f3ed3267dd919d0f6dddfb0bba2b6d84d386ae7adfd7798912a48d457d6384ae24e4d74d9b0d51f037f6ce9adb376d289f3bcde6b942a91a58913ab723e1c143d86208586b3285e4ca5123092189d9a1550e4ee4a81eb354a9ea42ac7240fb22916254ac7fd5d5193aa6647dd63c284e2f2b60cea156a278adfcc8034c917034d2763076daee0d31f34e6c8ea09b4980dedf8b67d9693ce1a88da5f32b21d63bdb3275ec0a9a094679e82dca60bcc01fde596e557d538f2fae2a5da562d2138dda91c245e3aa1f8fb8f978c190a884ab09760517362b1e5e890270a8207366f08f2324efb8b866a91c895bc54db5199d5a6960add9728b98dd513dfef2aca83d0de5af2abc7020f29147d9cd7515d612c56c1f68729337a160651846c9e50524ee818f49a0cd97d1873337d5afe66af5834bb85cb11951a94847398784adc302b38d9c83a30aceabcd2e5cbb3052735a6d1b25cfada22e7ebfbadd55e1b07a36aae977b55a5afc55fb9008b61004b452ea6495152f96e390b8081af111e2e1ffad4549e8d6ca0d22e33ceef6309220b21228f1d120b93e584d9a443be7ef8cfc7dda9a6d548c1d2d627d4faeb5e1b17dadc51e98ab939e0c3a53c432c32af1f08574d0c761f55961eb2e3aab10b50861193c1e753fcea0f6b5963868fda5474dfba70737a0d1572ef320037f3781e137dd3979b56b9887c8ac547bb6e945202668bce3662a3a336739a14001ee96a8ba9d5f0d33761895862851ae23959433f4aecde847d76c99060595896c36dcb06837aa745c4376d32480db7f9ab7f76296292d9e316312e9efc70c82ccfaf7e851dc017453109f49f7589822e3bdd3126d6e1879dbf0ee65f7d3d94cc75d1a3b9bea81f8e6813ea1121ed78242fd5757c09f7fb0433ad0b7941bed725abb729218749e1fd24eb7667d063b609d345a6d73bb13b957a843cda85ffb1f49880d7f7da3b7fd11b0d7dabd8e6a00c689c650d69e931e281bcda0421a75f23e208fb53def04d5d8e3fe1096132b1162c729df5c7a2a65ebb6da204cbb59c095326045ac52bf24d98bd92df04541714f2ea9bf2695be3282645f2cf9b80232a0472872e906384b536c3ef61db6ae5d4839b02c087bee795bee23d6b30c4b5af07ebea39fb1d71bd36c18b557ce7e3dc23b009fa15e1cc476ed641283a96546f44ed88dcb154a0ac3bb63224f96f3662fde08b180619bc4ede153d86d03c2d9bb65162a9cf7930d5d182a734e9a69ec50c3a3a3ee994b0cc456815fc5fbc664d9bdc12820cc8c71662166768602ebd682649eb1e13fde85d8c8a8db407b3c94ed587b707e95e3a057dbcadccc3e602160e3fc754021038f4ce6098613effadd322833aa561fb1cc364e807c32be6a6fe1132fc0a687c4aac7f846b6ec4b473ab3d1c173509b2484ed894ccdcbd9447082aa9d2bfbf9745c532d6321fbbe05a0fe67be12556b14d2fdf9ddc11b4b175fe47741005abc9b3983f7fbea5998e5be5155a3baa096c7b7b268174fa8166e0c024c1edca4a32bcbc7daaf1f912ec090f0b3e20ba63262e815cca3335c05a77fd5cf5ce773a58a5fd1752cdeba9479096df67e32e99f87b906730354b075771e5706768ffff718c6925d39bf26f296a7c11dc5c89b88ce866982b247767a7a4a066028355ab3b493762ea5d39e39599e970aff5e59a5a53158cd32cdb957ef311d7fbca11ffa8fab7ff8a19f2218cd41950cace772070a52afc86ab5c258e83daa42d9d4e4674a00910899bddf413bb0c600c6018079134747c45879fe60f001997da12b4021dec92351d9491557b3a8f385ee98e61352de746dd0824c9a36deb1d9f5414bf2b684a62f5f41a69d6096135a60a678cd4b73889cca93bd53a158c064d9b79382015550e022c8095c77c50f72fe1257737570d3a21f8a98f7eb65577a6cef33fb654502d93e2a20a7c6202d9ba05278b58d89e1a05f7697ee86f7409caf6d65b76d21bb97d434c3476f8018e7dbbc1af3f962e055e15f6dcd68ebfaef2f51cd0538bb65af8152e573fa9433a156603e5f74eeb002456a8d2cbc9ae69d02dbdd04d4e568b659d4ccf75c854270ab9496e7845695f82b2202802fc66e7ebaa3879241e3c4bb3e5b3e2b28fd85f98d4545817435e1f0d00de1c100152fc78036038c29f33062e8560ecbf810cff07e9d57d710ca28797d2b8827be48f992d77189c75e70db352d9ea51afe3faa52d9a3212476054b11681fb5dcb1e7d16ce8dca46558fd5fc08153076031313fddba1737bd5bb145dd721ae6ad07d79c83332d30c3c00e473c2f5d37f3b99559e51de4061f877a4f0350749cfb595c949e6fcb8370b2415b894444e910d9dcd9d4d92dd80a477aa7b60be31c310e771e38da6bb26b16b91cbcff809d8e923468bd70c2ff2fa6a661b3ca733e90baf9171a6eafe5f5375f1ee95ce3c7f209f94fd95d69b84ce2043f0451f2eff9fa9c28fe72575dd68b0b08045ea4272fee397529e1249c55a956e6bf503dd951d4586af45f83d46aa122520dea66be049308424f3c3ccff6cc681a1b5fbfa4afb9a04ecc5c0516d1035c235ea4332dc884d67ab4d73cb90fdac35b44c2cce2ec5254ac1cfda4a83b163d804301e60bd30a3940da8ae773fbf97a1a09adfb94aefff9db9e9a598b660762d127305a19edb0c0bad4e2ace4423a2d47b851197b06dd9c36918889dca78c6421e98bb865a9a5d319dd49cb3bcc39cb8a6b6104811783dd31b6359a54e51f0eb3790f5022d112441004d44f63e7a7f50aec427c9c2f328d3890eb40e9f44a11494d7b1bdcc7ce187186805f779bddbced57f83291d4c092d7a6aa63ff3382f55699b2274c06da0ca4bd479ad1186b09d004b8640308a4d8fc542d0e65f1c0bf043c8f23d0831ed8a96b43ab60ae9e5e5593606d57bd2c8290d5e7e53795c05b998d0508b4f19f9827b2084d4e14b2ecfb180e1a95ff1fb2a43940e929c57de047b25930cb9b3877e7b4e9a99adbc69fc6c1db9beff018c7994d96afbb019ab6bfb94768047ebb916c70002ec2387d5c6d987ce3f4495831402baec87abc1815af6b4df8646a1e8087637f3d8aff4d8730ff275e9f498c32dfac0e1d1b6ff41f85f11f9686dea2778824ff83a34660a7f972e9da06efcdf06b27298a9b1c75480bf2519af5eab970811d953fe60e1d399c5f5e2495aea463af3a663805410c010a71376cdab2e674831c36dfeb39519ee9c825d3d94178dfdf2d31ae6a754d3db3639a06a7a73b56800f71694f6c78aa47dcd285851d47933012e7fb931f1880e1c3d194ae15a57c5f328dbec8767600436d2da131214f8b5bbbe78075083ea2359351f676a59eb764c4a5b5b6dee3ec0372d90dd90be75faa83aceecb69e4a882f4529552ab4c76b04b3031dbc13c99af8b2a59faee1bc26b47d20febe5f3765dbffdd21e412be2112b28d29bb6a503ea07e4d9e828011489a908e6e704917355f3c2ba502c53df38056f13431365fd86afd92758a4a6b4eea52cc61437459384626025334afcab43e856878631139acad5875431cc5d159dd7b3169d303aeac483cb4b419da67d0006efb03788418d5c44a7fab4f498e8ed7a49e8c37e0a7efd843d0d6ddc6c42aa3181070d6838a7942b94bff29611439ecaae5bd5d7932a50a2b70026e4ff8096b40d2ba9d510cee7184615b4f89a7f61e387ec0cffbc0acc3b52e55be50129a4504ca4ddb6729a5a1f31458e3fc8e091030633f2bc252a792c8ce9e2109da3922a52dbd9fe153334b3cb45fb44bd34beb0f8420b91b6c3d4fe0811d68db5ef9fb35e6238caeb53bb0e214f81e0fc5fcbe5d6dc9620e2877df3e5f53c8e027eaddd7fe5708b35bb9ef53e2bd2ce385dfada1bcd514903d5a61fa6be26bd64a253b8f3d098a8471c97d22a4ac0f01cb2f8ba4a9c70141257562e34e3de2a5b2671a5815238855961f89421627b2825fb43e41788051da2fdd766b004a3491f0a666dea8ca7cfe20985e59daec3426257cbeed9f205de5475d2856c8abfca7e9f44b515cff34e76b2e2ac091d71082a9cb6c96a0ce3fdedadb7677e01cd4ba8a733b6d0695ff4539f487418960e758c4054e93e82c47f9ea061be90e4adbacb5f119b735780baa66af4f2d1d3b47501d702fc9c6264365599b068c10fa52db2de7e6aabd59ed3beae5eee77033eb8934ace9201f7366584123bf00f3b34527cd65dbab776df71c1a05cb56234bc4925d777092560589e9c6eadf7f788704a968b2327fa7c591f89e5842aff9b745c76b84dfcd65d97c301c7b2ba4c51a16da25836d16039fdc904f8a97bcee6987ded861aba2b01c213ccadfe8a3be722184d91841cf07f53ef7feca34348512078bdd4a104659100e80b22eb78a741b15f5a82ba59c0911bb45f896851a0d6aa68e53283917b1a4346c071b005eb7f46d0ff1b064730d941f9a63258f8f01fde4c5a99dfa1cf193238a3d19f901a54a35f5190c05857678223fd3a2b247bb6ce84e2e64c4a297498352678754696d57acdd17d5a7ec73ee341486f640032b981d7c7c92907dbeaf426de72d0fadea653459b2a49ea70f6da0815154c03a2fc9af53199491c741034b4a1732b7b7f6bbf891c06f4850ae29fa4e4bf6138900bd3af1278df7744d153fad813b6042bec1e8677449726c40e9843708ce46804e168a991c4240f4f304929abb3d4b6f9b5e6f1e717bd65abd24f48549ac37333a98eafdfea3d32bfacc5b935408b944b74aebe773fd983f7a8f3a90999d996d6841b819dda8b6428e71c21cd7a343107a6d3f5940550d888c9d606260aff90c2f6e876fb0deec5cee150b87b75b35f93a07a35a602de3a107ffb385b8f168994274ba761ea6de9493af8fe771ae15d95b24793947b9f9eb14f358782a32c240eed5995115d1ab8cbddfbcb0934f55b405df6d8ff846501478b1305ad5381c277f3d1149c5985d7eae3eaf6ef7353624c433b011ba71faba0b8b8d6a7d03b177ea82c0e14312c9cf0f7fdb9bbf8e88fca274cdf8207003279b1ac90010003182b40377f039084d594786cf376b56566f8d65bd9035a3ccdefb1b46192e2a87d58830bfd7364b335251ecd966fb174938f5e30cde256fc541f273dac481479028ba83d8b40cb923fd826bc922d5ffadf27697bf101c1d0dd8e9ea26183b6a86e5dcdda0f017df050453827b7908724ee1ea202ae9f12b681ff2e8bc37e77cda6e1d143690c279f0b2b373f9bf50539410cf89930fa41d98e20e528cc1ec14eb85dfc16d33121aa6e2255445bfe7b9b8e940e433df3b751e131935e001e99f2449719979d3b8641ef7e95295057c6b4ac5de3b50e258ebbc2cb2db36fc27fe0fa58d707bacc884580a9f48bfc5135380dc1106d4cc39144b47f0b5e9134dd4f6fc4c6f01d7d7cdc982fc3291fea05b62ba832958c44113ced0c6ce510328a908a49ebe6ca0ae63d2b9b55cee57fbd1626b03ef15b21661267322a860e2993cad8ff2d1ead0d6edb376a07afb69c241275d1b69e19569edc8153778233b90ed84bb5af73efd347a89c1332e0038838d9ae3cc823ab3eeae7ec6f5cb768b41c9b2758ab3e2b3da2dae09e97a3e39ad826b340e66eab55bf23c6665fcbec6517e71ad0ee0df784a030f6fbedfe3d7d8a1f70b6964785a9c71ced587d87a99f4d10ae626f513e6a859fc98ec635ef17eba2e5d7a213a114ee56b636f792920894ee0291178023fc60643070d0fe7a7746866f9f67f6ed4e0e1898776b7b585f20085974e51e9d520e4d0b2a7a4df3f1a8dedd200eca4aac1177b48ae4fe1b3c6424cdf2d7b49fe71d24f75ba8e0867340989339c3958fc08e7f7b58613686ffb737f88ff8a25746404914c89d6436c98090b38c95771e5334386c84a4a0027619feb08f67d93b708fb2856fbb4d11abefeeab62ca8432e1ea1dcbe041c3b6dc0a4a9e6a9111b76fb2904ffea01f7ca42785bbe4bd65a33970ac7d2d726f197075eb75afec7ae2e6b864b7c523fddfd7a9f2ffb7364b47f35ec1a1ce42daa82ac19f3f47b3d4d9a05c49a741428b630dd809e415613ec1b8c9ac225029a90b9380fa6bde4bfa34cfe61364545a8f514cf85197cf24507c0c56380b6d7042f1c25f43ab475f9d0beecdeffa267ad48c1505f18f578120334597c7ead4f193c61ae94912a07db6dbf169ccd5ec0ffb9e29b3ccb33d36fbbcce5d3fe40722d316abb42668c35bc0f1e7d730ed1f7ec61a468c33b5132ebb39b60ffeff556a83f044c21331deee849e0cf008fc52b2f2b052cbd54beb4d9d850fe244ee951bb3e5894cd43a4a83712a3e733a7c959e536831f0f8db80235188a38314ab873a151768f1ecfb11fd83b6e4ce3e2b276226670912b8d7945f9bc031d4ae55cbc148cc233972a1a71052459482cb45d7fe9fe2e9105e66db3c6818b34fe87f77650e6ec12634ffb0b8cc5edbf5486526785a7d4ed387a428fe605b86136a5da6c02eda51d67febee1c9501732699289c2ff66af8b0e3f806e9c74050b2249beeb238cb6841b95dcc33bca5cb36abf0fe3ecd9b14244ca827d931dd2f482e7583cec2b9d20b09785359f585555af4c380caa6962cf4c99a14f941a62bff722cf5324f6cc037f2aa4cf31f094898687fbb2e4b3443c0f003c49f0c476d4e2b5ee3c47715d1ae9864b1045f50aa7026173772337d76958ad5ed9994197fc53e30a9338ee5094c47d0bfa8c0485e76e293c3b6fc5b547ed208e3c542a1abadc83815a45f70bf29578482a55765a6b856eecd91c7e406a1d541ba16c409a555c9e6b542a260505e96a9a13f8277e80341da7b49dfe86e186ad2e1576f73a4d72c127a1265f64df4c05c5c69074f770485eff111a5b4082a5067be1cd2623f53f4abebe12720900b06e88e2fddbfb82409f50b3c36e6666e5d5b869b2293431bd9b32ecb9d348f5ff2c6f3bddd73c2e2f70cfd8ab82a63e73380ad0ad6ec32948f2def8997e8b6c2f034c00a4051024133644a0f17e4e8c716f4f25e22bb4563cb223691498b5876b4a22e0c3d4a86b5e8bd607a962920c041566f4bc281f985947e3aa9b9d5b86d603f7ccbcaa62b124b6e075b6bd420b17ba806c43c1881f807c485c8afaa70d9bd3e555d69e2e6413c9487d2618c77ba60d77af515b68d7476b7b8bc8d810cec9599773fd0b11af252cc2d00e8e238127460ef964dd31345a73812925aecc777c4973fe68dc72cb1598983d5397b2251df4be7481055243700000f3b52ee7ef1a1d27f034442702bd062d5fad23907e3bdac2a7cc38a6eba8239964b3d09ca81e7208ef7fec03f1cb03ca03abd769d3e753aeaf976f5d25def60ad6999607a00282d2f999f8cf705edb2312dd749a5dd886ae1ba35b43e2758382acd226ba7c3320d78a9648f61b8703ad49eb370bd6176b4e4ce4bf0745161a8fb1d0c995a5629cddb99567c3014436a14a5db1e5370d8a3bd1167001470d3834fc635d651e3df7cdc97415e6fcbb1a5e15f95112f6cc0cf362568b58541761d6f2886d4829b86f6ba120ee2e3797e6e3014876b2d003ec2535841377ae1ab6d810cfded4ef1af4431f05e808a92a7659a5b56ee240c60158b0f53a40687958d55489ddf0192d3cf64f2de0f38f2ca324d5ddb7d41c5455a8dc65c95407046860773f366645ebf6d3db27490b75f93e1ad7ca058f527e39504b5398d9245af0705f9075c48589aee3b1169e822c709286e896768eb6d6e3535a33c8df78bd32f4e8f7678165f60347b69239066aff988a833be86cd9229a93747cc2ca245250dffca87d7eb400d0b982fc3c4c1fec74e3b39c36b0f77c0e4faf364e0bd7898b5e906ec006ba9fcc4c8dcd116173806963597fa6116e41aff0dfbfdfea1658ba9a62be7e6a86826d93a5068850b930a41cae03a0e5eb18f0f4d66b7840bf7b2657366f389288a4bacd98b5ec8faeaae7de738db4eed632ff2e285e631edd7ce05f82e15e0d5ebfb6fa3e9c2bfec8e60a561dae0ea598a84d5506d038522579b87065415909c19f2c57e8d382704df2d9200d5cc70c79bc1c10c45f53aa27ff62c0291e43f36358cc36dc58e3dcd8270fe0c781e67c82c285f2205a7d5c16ac6610272a614b05a0a8c91213b7ec97fbad2f3163062bbc0b1c4b49df4c8b41f652bad53dc1493f669f5ec1dd3e15ace3ff5b12b65f0460033c0e76420d4287d2982dda1f1d67af4f8dbb81b90ce2a01bc05ef216f6512c7ef852c822acd9a5fde0bbf8234738b66213f3900b8184eec5180ba9a8d8125ce894b415708bd465a3b730dba9a651f9f8cac52a79fb2510d352065ef35a0f6e7a0b9998f2931b4b772983accf648234e02575e44fd31c423a32401f438457ab299d6be4ad3ee7133784753563850297c09079e7cffda0ef54a02ed58c9a8ae68b09562f959a4b7c56a502674a9702da1b765fe30fc32d80a6aab6d2827920e3421e18bc63ae4e1061e865ed400e20db86fd260a988f33e31949d3bcd0735f15c2be00c5c6dfb2785ea204ae213b806f4d9d93cefb9eb2f9d8f1c8fb9f225c8ba5a9428ec40b26933357ced56c80ed2e36b3fa081736b8b432f6f83c1c65f6b1481317f746b78f0c7ea3685c150dc6db7026ba74d895e069b8cfff2625ba74a6000c184c2493379e33690b98a3a593a10cff8cd216987e16e846a574029f32740824f28b97abea8b863918c616a3b1cb2cc32b2d9af99bd45717acb08e07884e16ae57a91081c5e638bfbe18a4ade777e34bc8b9e33cc5a5503ee98a2a6cc3cdf4c7929da928e19d957789a34250947d551fb745e5d38a993ae94487f9567ecc5c194b39cf2382109c2560c076b838fcd9a050e59f6eade1af3e933f6789fc7f6f00de9aca5acfdafb98aa2c63abd918292d7dfcecf4808b21922e4926096fa8ccd0e0980f9d31726e05e848407e7642f83e0777701375a5babdee73089913a54e01b61377724e90c67a60b5d19cb4fd81f528e592a8464896e4c3bc27f9e98d831bbce7f1085069613789d5d04a0f06ad0edb5e406f9c1e6cbc4a1de1cab89ddbfbeb730db0b48d5c20b827e5a17c75d6a58eeb1de0a19d78fab86a040bf291c31ca1cdddd3e3df8b12a0a7ed114f079be6aa63cee3a580cc54834cd83ec2cedcc1ad9a6288fa77785e24a964e19280ae00b48b318dbd0ae58cc93883452a21d0e5f3644af511f54039f7d30d2a017dc2b6085977ba856bb5b74d57e25bebf2b2c2bdea384479db14e8bfbfec4f615c87fafd4fdf9b9093261a2bc49f0f68b898d79eeaddff5bfb58274d57362c06b0512c5f81bc502b131f2ca33c54017d561a82997727f1e62906231a9b93bf510e470dcf2af4d6b3f8446fa34082af62e3232041c134cd307cc2d13254f43b8fa5cd0391748c7fe332fcb4cbcc596b51b9ccacf39a1ac9e5800c72d86b124afc184175f3862593934ec9c568644115b39c6ed8d51c8b56a097c032d60b57b9250213cd3fb38072080eca31ccfe55c6321c150142d0693806a2056e6ce3ca6c86d957d71b126dad0b36f8fa1aaa96ba5b3469364cc7e61a41b8e24b2f619cccf08bcc5a7cb7375ec5631e037c432c1d6086a2ca29fbf556957248027afd9a81be36ac71bb12edbc4251dadbb4cb36bab6a8c5225bc7e4371e2b4b041ab7b2765772d01e66fba6ca6c5475232cd19e0e68560ccf887eda5e6e06d2985ae4e3043b7b63ae021e24585281de41be25fbd8f9372bd48b43ed1417771f84e246e2a41aa03dfb1ec4576e624ec0c9d1fde23a723fc402cb9a432f1ee060b637265caad0cb53eb909d6d453f0a984fc7191dab391bbf8fccf2686f53c0557eb34d5df955a10b17b18ca36969f597b7c5b765f8c6f09c9e8bc6fb6b73af107a5360d068abf6c5e92a757e76d4946ae03f0214d86e35092ed2b108c8dc97a45dec9131c791ecc0503a69226c7b0b9f77627ef85aad7f9e0ad8eb1d1a91be11bee6372b072065a0b6b76d8e0e540fd85e8d751b6f629847579e9e96367d0edca72aa13668957520ba7cd599d382d7211c0e595a68090e8b0d477ada0c6034d39bea7c6ca804595a45883dae8dc0cfbb3d8c2573dcf1368f244472e72c5f79fad7c6eadd2180889c19bbb69a003fc26a1b42d5e8b34a2a1c335b06f15ddad91b691f9e4f1baae74ae6548ebae9aab8ce8fcd5f8bfd3e8ad6dd43f372b154adff8d129343502c9c438c11eb030d49b19544b8f5bd40622500d31cfbee64d40421adf60342495487449110902b2e3fecd61749b79091562a567c1aa70f604a3d4e3ac1ffc855c256c18f5ce8d0791fd842087b6a428c24257337276152273fe0941d4601ff3057cedbea534f85848feaa16741983ee5a76a7d1b777fe356b27dbe05d18e78614f02553ae6f26c85566baa216697b68b33b653250a1ab9102b0dc3e66a49a99e157f63214c1d4fd84f7c6756991baf502c37782957fca58e54e53d7dbec8e34ccd971e99f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
