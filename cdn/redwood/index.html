<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"508687c135c93e20b7202fbb1b88de034c52bdca1447408c88177f4644ced8a5f6f8c1a6be05e370dee97753010dc41b56d5769dcb69c4d0dd142fb80d72ba9b80de3bab2e900ba8dc244cf6e51fceb6880666f543394ebe819ddbce68903c47da5fa5a37c7e371383303f1af1f98df27386106b0605f801a472445367fffab4035b97434166eea28dde50d54c9cd953d6672ab0dbcbb6af45b3816e2987f03351ff8b72822b763b5d56cccbee98d1eed64f742d831f9476c7c700a7245c2b66274e5254f81d0aada7e1767dbbbd92652fb5105470e09b55d57688dba43b087d7585e07bfba08c8ceb123f4bbe722aa43d57ef98ad1e8beb519254790aeb9f2372bd594fa4f520f8f6245f65baebb481f8a3d818fd342e0a353f313a294e8c44a308642a913e67cb0f8bfcde0bedd3193f89259432fdf3cf35192a6f582a1b7bb5f5ee683dd45d1f516c4ea852444dc8444a09c17ca6e00f12f97b4793cf21182c5f8a48ddfd47c021d0812397362aeb9b800ab8404227f3c826f041c85c4efe5cc23df46fe18d1e0bd2c8b486e48c632cab1a759b6d08724d2453bc82bfb5669a6574cd0d4787716bddd2d826de009dccd3005bb3db131d286da041ca3c347b8d2f9dd87baec20254ffdb1d9990648c579b40a4ed4e1b02136dc3a16be27968bd8f6048add180d001bbecd1870a495ad6a5735973760793d6add34ec3c052dabdb270eba92936f6e8d9f87ede6c6ca2dd9f381d1b21f7b1865a7ed950c4296a47381d764b133b439f349835e4811afef7e486f4ceffcc49b9f6bc0deb26fd29d07c1afe08171bc24c9df78c5b412cfade2459c7ee539e3f1069cbbcca13e6859548ebb10a59f2d3652c7d4358d6753635dfef663cc77f7aa3d732ccda122f523e68ef14418cc6d3c7841eab13356a7bc799554ed5c50c46206bca92ec3ada7a4a1cdd1cfb67cba6da6959b4d206067fdf7fec904bfee46aafdc1d80dad80b2eb54a059a65f436fffae9009a31fa0cb2198ffc8c1b6dd83a875bbd24d7ff41da3513db27331b7715ea4a8c7b90cca31122be6fe4ebd1fa7cabd88e65ab26956d0935afb1c0e4e409325d29a7c2ded14ebe6d82bb9887e9af054ff838fc1979ac7d0e534a4c0a86c52d4c999854a3838fd884de38e290cc5fd9713746052ee582e9b96688760bc6f04f85bbe32ab9f86d9a1706ff435e472adb1a08cd6906b50f0f05a2001186ae9edd9b12946e6744382e3124be7538cfe0ee847a67c5c4f82083970a1bde3b407868f7896df03d3bf22fd6a04db1b71a6abc29db8c08035e29466b9b95cd1298301f5a6935c7ea237e069f497ed635ec876687b33e9700acd246d58512f4ccb810c9df3b7018bd26155acaead34dd46d62997de535fe40509b0b843f9d6dbd9d59a9891c210064acb8ca2294061ac3d147ce55233e76fcde2c5ce37cfa4897fa0b54f5810102af13a824764b62760554c4c2526a07da59bd2c4c5f8f7a04a56ad7d726483c6e18dc0a90413f9b23778e249fb7a50e83d36ded4fa787ac9e87047ae495723787221a90b9763b36f7be41e5dd51ae30ae8c0040689823ef1c54dd1acbfbb9027a3e279f77c62adef9c2f4e3ef88fa556923cf71b16b1054ae63dec28fb3197e709f8a6f8e9c52dc10873f821c8ad1ecdaf25bed875498c018b9d8a1ff6c274721ead2c547e9de86ddf78d69144729ad295c368ab26c94867e2d6e9ea4761066629081e7787bd7d50406c7ddd62d1532384277ca7e74c4b4c52d7c0dd32508cd76ffd237185128e509f28c6b20932e73b3a5d0c74282e9be782bfd6f4f44d4e09a819a42849da7e7afb50aca744ecbbd29d03f33ba9988b36ee5603da5a533fd08205ede3c5b1e382ce5909723edb13caa7a26d5a9b1d422bcca5b9707321d97d5c4b86307ddd35d867fe31238e2cff3608714bb93eb1626dbb8661f55b2e26558947ba49ec770a6573ca8ddcd7cc33ff1301a30149305c5b5a6ea942dc970981fa9ae90bc6911ff26ed5c9850cf206d9c076119adca9059fdef43f9bdbd89dbbf340836d84b640be4d00db0454831b84461ed80ed754d6fd6bc08b1dc029ab597c56db60540685d70f9ea3751c270b37921dd9223e35d6b2340e2904e905103a0e5accbd694b656d17b825ad30e2db5e092d247c6316e41ae7a6ccd4e54eee94a18b1a607efe7c033988b78d76b28a574d7c9b6496faccaa9a66bf41c4c80b8b976af524c0c93429287ffee71dbb7c16427747f95a10658ed99f56cc4561fb47c1d3ff9dc0b65dd16ac1000a01ace46ae6832b89c88ad8b9dcd21450f66c1ca2f5a7971490d58ac56886375b7754bf1b9bcbdf550b8e4eece840428182c44a26cb392d817cc71aa38429d2a5f43372dc508b9d35d13d8e073bd65100607014a22079fbb64804ec27b0d95840ae79c9aa266d1551ef029408014e35460da9d95bf456700361b963584336fca3c5ff6c7db75d056fee13bb8397b9ef295e9b710949240d52b99d5eb0926a42815638a0a1d79fd7803fc4bbc581a80476d00407299c16a11d89b563b3291d98b766c299dc7d9cbe6c8ec829af7aea4206e4d875fede860a7be0db8f5c2a9fcfe902186761dac7550042be7f06afb0f303ed6f124131ff7d452039c745f66a9b7e45674b45efcf1e11dcf7cfed775af9106d62a60650df2a28df0fddc006cc97d995763ddf47810739a24b8399efd156ed3cf81a8124d0de4e093e5ad5fcd5c2a612210887d4a9416b9933700f0b1c41e3000a221f1e5c1c9fbae80d52718ab143a3e244ad65b09275a997ed5fc927c2b7439f458f2131ac312860b3512281e1f8b6956e19c68e945bf7ec4b89eb0b165b3edb782faecedf3323a87cd19377ab18b2ec88a84cfef34eaac6b39c5ed26e962137a1d5e5a03369abfd746ec8db3f3bf183f9628e28326425ac86c9d398f1991208c04b2db0e746b3858906262222c12d193f6a15c1dbef4f0bc5ff46090233b4995b8333dfad6f47cebe828a424bec1470db1f7898716480c0218052d14c23dd369e1ad84897ac79c6f6dbce5cb8131425b86c96125929ed4646aae1f92fc3e24468f3196b96365d23bbc2d7a8bd5a5c72b9ac9cbc8fb6c5383cc4e78593c5146897e914be11c6c508d23dd309f0591f8ea6cb4c73fc11338c6ab4c4d519c995534681e5c58b92ff1062d37840fe7551b0147a3c97aa3e499270c7743730f17343035ce038baa54aa1119d599eaa0473f2c1d9a6d21afc253fdd5948860c8c88082421a420101d0bcc305cc511e26436c5e1b1283d16620f9fc510018868511677a8b2cee7de6834a11fa3227475df0d1649b685c4428bba7087e73b6356384c67cc351911eda170ee5958eba0f2f579e116c1917871f8b81266a97bf0e56cc5a9b704b5f7a214942f5c45ea7aa543ed5f3a2002368d249cad50796e218c4347ab51c26f01c72b73a40d312cd3469aedd6d58048db970427b815546ed7b2bf64f6d9c13011eac3fe2107210fd45acfc296b74b8a9e143b8d513f81344f1ed1d399dd381d87cb0510376e965ce3b7b38ec187367a08ddec2a73b8c1a7b70a9e3857cdb1a7906d4d95bfaaa1beb82b9153c4dcfb2a0beb608011c795269119400f9e103070c089a2dd1f74136f4e06becfe7b3f8d170107f6efa9a7297e7d973465b4c4acde88e22c6c30fc90517d8d4fa3211c200dc9ea2af1694a4a1df3ec002434a490d85525b65f88f1ffeb8be81bc1a4fd56ce4cb5adec57198eb0bd31c7531f103551140b547ac957c0d6faf21492fe22b625ed3a15a09b3491fe01cd953a5737c9a69a625b5c2f00d73c139a5dcde875f09be1e3026a7032d1c854a4610a6798b2ae379293023d903c2aa0355e484c06bae04d66e13194fe0fb934619163b19c760afba4cf0107bc2347d1676a25c7222c8ad97eeb4cd9a1a87e4c1b04f8498ddee29094f6342083430078889224da3c4d44fc426a15eb1924e0964edf46f1c778b4c4da9f22ec12fccb492175ad1eac2d9771a0f4739c1205c9d831fc6830e81394bb7a2ec82c1b766eaf5b4299ee18537a3c56e2d3aa6ca8ceed5c4ec8fc25340cc44f5649a8400158c0d8b911d84af1a833fc33d8dfc28f0ea0c87d78e132564b1cf28a265bac0bb4bdb01416ae9da8ed39002d759d2645858cbf5c857f57d23f913b3cd3eab0b008d047ccad681de277e792669d8f7b5c818deac197f7afcfd57de5b430fb75e8652cfcdc44ab5eeb7126dc17236ca76300d72f4212ef44b3b9387669ce5a7ac16daf6eac5f25301973eac0326973625aa603f4dc9c34c3a8da3269856c9bf20591276a8ae0983e474608fa025236c4ba5fa54c280dc6ec1db6233b3ad97b9d2e8df135d862f1f926f91a65c7eae99ac7aaca7aa2f864083939e3ae11385b3cbd16e8f2dd14ec53536d5cd44cefa8138c5fa76e9b3da298ca192e3203dd2e1e98c7dfea349c42d4142e37b67696be04de2886b3141928dd08cb3c0fce798cd5466689325aa228e1f0f380c10ff82faed402546f4a714d618424710c9d1562424d66282405e2ee3fc2241d1fc636d0a28ed522758802ff804075eff827eebfab4d70897797938b14dca94e688daf622f13a5890e2665535c053694e04a44dc77e92522243f197beda434775e6439b88bb16bcbb4c35d33eb41daebc5698430d46ca8aecee089127d7492ffbe863204bd8dce99d097a1dbf541bb1be021ad62316774c7088261f4711518faa8ac1d94a6a1a3522486d88296e059935f26272181608fb305b9a30cf314ed6d9afead4ac1dc18e0263879d27d650e8b399e319f4687eef3ce849df4c492af40e0fd44d3f896604926f36f20232164436b9d458dd02225e32350e8d50952c8f823449c544737f24b2b081405e2332f0676f4f9ff33db2f486dfda999002752d220e20c346fa648033e3b34040e7cf981c16ee9f12215b8be930a6c22e28da78f36ba7093bca0e86bbde6262e8054c8df1777c2fe6ec2a53a785910b7e58f18f786a5ab1ef6b01071a6af8286306811254d81f405ca3529637353c7ac0ee7f825a5371f7d4852290370942da9458e636f700420b341330f3e22ef807875eeca80d074b2109c08af4fc9777ecea21002e024ef9439744b15330dd909f968410289f84eca0e18f918296087c8df510a00a7976075b5e5940f305462623b63bb661157c3c6f5840782795096af8770eabc0042163c4770b419aabe68287f83ca4ed460f5012679f7e78d9a5a9111d4ffa772d9bfb72b8da8132c14544b52f7b5f238b9b4610e0cb5774616c7a01ed7e561dc6e1a00ba464466deddcdd6ba86ff59c7c3ffc07b76ae6b63c2570de6e84a9f266f3063bec5c4b491808f4896acd0854d83360e107dbe3668861bd8a6b6b76a91e382a6212898929aabaec50667e51d717b6ba0c794e3f5369b9fee116e91d7abd1a15effb0dc0862c4d6a2ddb72ec713d6a1f7486bf5eb64fd451a74a3e2b360b5dbe538cb35d7bca081ecce43cbf1efa6dcefb7356e97b9d97ad6d5f240d6db6204248f8eea0435b53a1bb9749f85ff7a391f8cd352a1c3b5280e25206998bb511b894aa845471d07adc80a7ed1964504d8989fe4e6dafb0b5121aa56d77f1763530911f89cc727bad21cedc072c025e22d116c49b852bbcae1e745853687d5e33bdf7207247a93edc615e1b80ade74be0a2b1075805c640df5f9180cba173193b09d3e3df538285ee3304277a5511bf5796547ec51ceb062ac8e83df78fa86ba90e3f56ac056ac47c9b9e893a67ba94782c188a634c9ae9e4bf03a67f5e6307e18fa836cdb3db6e2825e417ca04e3eef2487888ca9ec1c70b903c749713343a76acc2439d8dd966bba02cb2c183d9420f25c9005688c123870fabb3abc25e335807eda0ee579bb28aae7726f3195070394b30c6f608b812b001855e4f8e244c4bde43dfd3ef6705606e717b4b52d721c23b7117c6b92a8111de830798c63fee9e556c80413faa939bc32a6b1dccb8aa22cd63771c77fdf1c8bf4874cdbe25a30fa7095a6e64c7087a3bc22b18cd5d5660b867b641b34956b45b3ec6ad8e4e1c37f716e92179696a1e997dd0a102a80b1d94faa745e308af3f6a973582c4accec5e3ed83d485bc3cb55f6a2ae9f0fac997e7731c14545f6315761b31c8f2a87891d0a9bf601c8471f5e8ea13f798b8e0d8098fd17c094e4e1a99f56d2bf54beffd8db43713ec8b685d7dcfd59573598999b2cff3aae5a5cb78129d0acf1f72a8c0ab18342605ea0b32bc1fce0e0b307fb121a21d6cc8768800e6e8b2d5a0eecf771f785072d90c58502e7097d223c03812ce3f0f3fde6a5bf9ee4becf6c64769efeb20a081bd9e18b161211edcae608074d999e96402e9cdf096e10f510815f68471828359a2e5844a90c53c2b2a909d808e665ed1caf7a97074d5f5445a3675a60fe0c402025a4323df1d53f44edd97a669aeecbff0b96034116ff222806451ebdcb951506ac8b067a1ce3bfd1874372a6da6792061f23fa940ed59ba33d88fb71757cc4427e888ca833f1a673a775872b79aab98325aecfb6e7f1a46aaa7a07f5f116e5ab6ec0bdc62e601e08359378d3dfc8eb2dd18b1c916f913f87890496c64b319e772ed168aaec65297b0cfca460aedc438a9ef31a0b0d7e24bb15fa0414180d3164de9ec757078ce8c0451e52e8452d0dca9ce05c247e436b86c1e86ca563db3eb32dc99369bcf0092b50581c814d667c65660f0c510b5114c530d3f724c2420bf2ab86c9dc6efdafcb6765b980d123555f14d371a357ed59b366cb63b6b975b19eb75388ad7f66b7331caf9ae7da2abb444b2ddf04cf6d2cfc91de99f1ae3da56fc0a287b21338546f6e7850e217cf1b2a6914b592353293ec424728cf56a3938f048419bd967fbbcb5d2dd9a4627b48f5504f95e56ea86510f12aa6038c598e379a0b35f7a9d1eb8714b52b14624c18152add77cd1f362a16b77bdeb27392780b15c153ba5b90290acd3a46ca9bac3d0be8c068eaa7188ede3eb2a8ad31283138664dd10c43a01a017ea95ee4e02b39c8c49c8a968c669e23788e6072cbd711345b7b80f62fd0592edae53053e4bf03518338483606038f121c78d495ceb52cdd370b399054abbab518a0657a4701a64a102780c5ad9b101d4ff6102fa75ea58f409e71d019baab52cdf54dea4960b75930f61db3dd79fa15c40b254032adf05a34ad60d837adefff804fc51f3509e162cf241635da3757766394c2b88eebf4c4dafc10564e581ec1ae4df6e98d84211d72a33163fbd8b56d274ce742e474ce17f3e8a962896f558af0e1416eec3250a88b8a38562b9fe8c112a0d534cb2faf32bb04ee130bb6fc4d73d709d6c16c5a00f142119d692399b526c0b4a85dbb00da38183e05105b43b5667a88ae07eb4f53810a5169c114c28d574b244c9b3d1f86d331e282e0c18800e08488732ee59a8d60463580b0f0bb8b243515ae6ec1fda4d0d3ccbd5fbd35e8b1457ee8531361517b05979afee909709ad2120dc8c21721024217b817400d7fdf13faddd3febc59b6d5eff2f903aa181b7077378a5d4d907c93319487742ee7502719081f707427c65f12b690deca5bcf6c0099ca50bcd02769cde2957f054f665b711e2f7e06688052293ff37003fefaa72c90fffa9866aef1c5845f6c2e57319f5a42a000f3b5fc02b6a01aa778381201f3655fc32de1c15b36b4fdf22fbb2919eaa801f84192580af098013a99a0590c7bd0d8d2d122095695258db779e3cc43a31c53ab47ac2d10f270d2723d8f3416330512b6b6a5c58592ed51396dc94e8cc3042e5fcde3fe2c444e1c503e22e4b3fb5491792919b9e516b46c441ca6cfead666dbfb5397c707efe9355858b6cce9ea1282e9c552ce4e6f82568d01272ef53791e0a4be1aebe2a52eb5465400719f49a80e0ed35da7486e446266f737471303f6178bfd8f2c16e4b133be9ef982fd083e247328347909c13fb3181e83fe566e2d10bd4c12663ff738792421fa2c2990bf7a27acc769f5fe2aec686f36f42aa618e24414493c8b62a71524b8654de98c85d39efbec8976bf086b05b9ad9b178da1fe9e2f23950d307e0a3102b180c2e5d30046e3afdf3d5a5acf798cd3cb5eaf4d72f254dfb879474b99ec999f268c6069e0e0ed5f188d3810f89ccd5621cc6904e2b69a75484ea217599a409d9b555624c31d7de70db942633d51a62e53eb91635faaccc28ab234d3c9d7af5b77580d49acbd08f449f4318f4c4b4ab021a2e298f8fdb5b0d37575dc2594d3e590471a00d59210245483db1ea98771d4a925116a0b904a2b1dcdaa7213b9445c0d163e96116c256e74705d6a7f5bb515f6d145e5e05a51853f8d890d5e825c2a4addd760288b393a104cf889d69fb1150ac0d183401de5544a321f3026a7e8f8a9024d71c1a3e261112f2e4ab4255641008442fbc9c58eb1a08616bc73e522000ff0672331c4f03078b80b05035b48d5c4cfe4d7e950a65b9ab3dbdcea195b39618b2e057b97860ebf1747b751b30e02f6068b2dd8b146360ae93a6cb41f131dde49297e2214f262950f5b5f63f1bd47c3e5cb1e3815672dbc418c923218e635ed1c26041092464ab845338f025163e25ddf42aab0dae505a1bf616ca66959f5672aed5dcea8bc3b79977c3df343acfdbf9794d9a23f9b5d214d3dd0a2dce991a3047787b2d96e7903d976bbffddf7a332cf3ebbddbec8815ea7c60fa49b488731d7a973cf9a00892c6b1589e9df5559da175b8b4734e5244b32e7b0caa943bae673c6f9fdcfb1f0753e2b6df348001d036ea8f5e8ab98951600f7af475a615973911b67267a683cc61f9586399ef52d22e1c9f7f00db3abeae804629c4732388854e16546f12e316bbff80773f171f5f20dcbdce1109648e3256b76c36b976099db861cd67788b147e9ec821327a5218052dcf8b031c08dcf6735b443d43c957c971225577c65f4ea12e3bfb941d6caa318ed751554ff15feaa965b0add12d864655ffb0522f20c7fcf60546faa1ef036f8e2921d5a997491a318a645295b4fecf5f82d8c048928c7d9ed3f4ed87ec5b41eba7c45bfd419cb825ed5864d6c68eca0c4b2ac57e6e741423b692ec3529b43776a215f578c3f2b9cf022112f5b4665802eee75e38389dc448382c1c5b57ed868bb167eda40ece8f2235aeb284696516b63a03b5b9941371f02fa4c52b391797450ad268d4f8a4a273708789d66469e1c201d6aaa2feda5be0f7ac10aa728cc051d27fecc36bf7e3087ef06dcd45d9da85a53599c1b69f582ab4b73dc2647e33f4a06ec9cdaaa9e341a53cc5f45376f4260cf26b52c13652238c9adc25d44a794e891ce9d6420707317d8abaf8b98d17ceb6342d1f8953687087c857e24ca777d1abd13f89ba5bbd80c84da06d57c2c9a75421dea2f20027eb4f1c0d79d81215b7e186546aa69a2c73577a7d082fd9a92125a60631e260318ee869b051d7f13cd4864561cc232ed1e23e39317ba09dbe73d81ece6d2646b01d63d28c293d03952474700a37c9be8f6f58949d969934170797ad2cd0d6c7859655555668be10adc5e7810444f4617bd1e9077bad9b3b2483ec63bcd7dbd80e695be3d6144d14d9f3351ba24f5e9959e3dd7e39b527aba056b4c4bc489b0c6f9b554c881f03de28fc6aad56a2f4798efec017298f54d3e57324fc3a7b2f1209eff521cfb2c2ebcf706a046b609fa1bd423b05759f633776a5811e0e61634f7a3a7e188adb923ee543935f382238b9407772cb86d089cd2fb797710b30470ed54625e7e6ddbb425a0667ac805c5d146026fa81fb6afe286c295afd1b60288b84d6258899c19b788d0b695b0809ef16d57c39ba3911a81997dc8808b92ab2f7151abfcfad67c42a5755fa44f42852c135589c7a4810bc7530a90058ec3885dc802fecf16ed065f51595fc5331936869c4c8f26c1069982291e8c5717f286953c107cf3fa44c4343a4d189d1d5692790b4bc5e5b80ea1e0f0d130d0f9f93cdf26a7e4d68b9d3bcbbe928944aa1e3632b90e970df0ce16bef850bf694391da85ef7438f5da332d11e67c76da5f820e4091b2a4d11bf16b1936b7ab232d56ad02481c399004865ad57873c011cc1abf1a45ef135712bf675b7d898593fb90281d0a86dcd7f697540d9434be7b9af3c7402dda4969bdf4439ee49b7c0452d4a61f0c82d08f07a4f58928bbd3821c882bb86fa1e5c1cd5e09b4ab3f7bfe8cb0c2a98db0338e80ef6e69dc2bab2c34fad14dbdcad2ac0ef95812c6469858bc39412aaac61fbf8dfd0b7125cf2eb673f64699147a5392f14b6a1fc88ebb902fa925779fc90ab209bd41a098022493d888b211e07fbbb6bf0d9980ec639d6161d4de03b41249187db50fc163a9e762130cf749e36c10ca326fd0629e8b2865bcaef6c1222f1980a2a78392e5cefe7a531c9096a39a836800b60f716b21378530115ab2666535c56e99ea6b5cc2c76999d384078695ccb82cb75f8ddbcfa02a806578ab63e1e24369f77ed1267a1a1c3f87e31857054fde4e503882164686de4bcac61b45235ddb5cf75327007d7afeaf5dbe00456c91c113ff445117d3414d1415d022214a866641d1ab283e49ce81004083f8ac6385233794108472f66d4f671c873fc224c80116db804aa6fdfbab206aefaf60ef9ede071c4bc8067e68cf2ac76eaf096fa04bc580fd7a2ee4ed287c52c8596c2372de07cb31a5fc433e6fb38fa6f54f44b744732b5fe3732f336836c7d35c60be0681444279edad7843c909dea0cf91e66f95044d2139bf377b37678029bcb2dba2868952e19277ecf6300a87f463c5f3d2f019770511479fe3217f22305062ff2644242eb5f6ef7582c617b80fa9e147a7e7b3c8a7cbb40b1a16e0ddf78764e6dc61652ac6558d62ae3b8bb00a4a08724cb0804617fc3e20e801f6ca3a3ef86156b8b87b89da4aa89b4c71b46fb8282a665c30495f3851ea69c90b6aae40a16699f881e7efa5adf08ebe684550bbf7b794bfb7864ca81db5584f908217a674fa5cc3f1f934bbf5c5d2244dcab6a715ffb41e5a484fc2fd2a17edd7793caae7b5d06c6eb9ed4abd5d63993e489a2b3b5d4b59af50bf9c0058c91339ac4c7ccb757e782e547dd529c070c5a93ae8003a443510f4ee96cd285796927c0a25a4ee232a2e9e53f0892d16f18a4b35836deeb0ac361056becb2002468b0a169a860522e22c875867db6913c10204f3083ecd5a1575b1a23a392b3a1b94e1539992b8609dc429d8383b26d902ebd17c9c6d071ca4445a8eb955e94f637251b2b549fdccc3591e78fe6900d0607c0fc12252072df0898a03cb238aae9ae119bfeed53c073e38021d34a1dc91cb446bfacf4098116d3fd8aa4a2561aebcd2973aa2d3414f91836a249d543f402b33c9d8729c99e06f839733f16d07b1781ecf8ad8496f9ddd5ab149a236c037f282e72667f231cd9fa811becfd57a842f6e0aa3d8bca9bdd8e86f31945401877bb7c2543650fa9d49a5ebfaeaf425ba11927e7f61e1643b43b4e2bbf8f4c3a9776981ec1b4653c233132c7f986ec084246b8031682374d858e722bda965001ba6cbdf4ce0fc15374107580685c83949ddde89c2b8e27f4f9b9b3ffa2ff709f00de07fae4c3acfe6e375d476d168797da79a1ebd8f78d8e2c7c707dbbbece7f89c81542feed1adb0a415da848d482457a838ce9fe45fbc85221b62a118aa6fa4c9fa26e057c6861eb86196ab9cee858f86a50ac629cc2041a540d62e271b61b41b8110ae75987be21bd1ca52278096c58f37891dd46b693782e0b1711bc6002e42508dba94fdf4b41ce29dd3e34f99f24c898ad599cca9050088e3f1a8258cc4840f4691037d85b107cbb13c9ed8fc31c17f492bd707936c7a6de7a8d9f2f2291b197302fffe1f737924d98cda603fecc7f9b0389ca82b4b90db9dbb2fccfa96475a5c422f2c3d43e99e67378267ab02e809348d0f3088ef7957c9d7281dc3187b5c671c097040741099ca46d7e293b51a463cb0c84dcb559b9e51e5f6130c0d7a38c075b993845923678850939a296ae442fa4e55fa9865fa2c88e186b105130965763a04412a217edaf0e785fb5100f292101701f82bfb2a5c35fe5de8d8670d634b7986846e9d100ea41a46edfaeae0e06b9f2c1c7433b4996c741f32f5fcfc767c7305f4e6a550e62cf10a6d5cdee92afe2d9fe19a4193a0c316dadeff943ecccf4bb1981df7662b7bdac3e7af00e8b0abcdd3cf94ab782486b81c88a16682dfd65e1e16f35e577e4bf9299ce4bd19311746f7e220c0de783ba9c50d22c30957813f7a8acb69d82c700f72c2aaed1b49add39acb6a3ae091a9810af0085a8099a70745e98117909f5708ac3b5b151672963fd6b456fe548b635784dacaa006b11bc141af8b7489f42e039f9bc25d2d47cc515a4c616fe2c285bb1adf64377284a1a3a9ea6ace53115985ea652aece6f5f5d7fe0d8c027e6d5e56d24c6ba9b92168d33067e2dab977daeb99d4c0b70380d649483331062679c07119e284e4db97c69d981295aebab804a984e5103c19b257f9aff45e3a6fd8789917ecd106ed157b9d9b4c46ff3b5ce866d28832f749e102e716904751fae022a96cbdd036427dae3c62092d0edb68a4a184d1c3e8d1c4f4124ce60760b0d0f3f5afe4451e305757c1784f96497afd13fe604ed840fb1e47b86e1345b4e79fd8259c3663690d766cb7706a297d6a199ee787de94cf86363cc7ecf364252f01e5735726f1cf3ec21140055399a530773dea83557480da8e90ceb1141343f1994776c22483f5515781f555b6b29275667394468e7262e477f38192ebeb4d1c762569fe23322d3215d6e373c4312f3fadbf8148a8e8915fac0fd30848967165d252bad039ac62f865d21a38c9cbe6541afc192c1bb1b8359f2e4192c72000934823ce611e3b0468f6820e75ec3421d48a4b4174769c83d9716e517acfb0e5891fc9c81550405385af2458965f838fa0e98e308a929af4cfbace94cf001bed918771306731bf3275ed98bcf53ac742aa6459761f41f04d12eef78e899b9c5d90c01ac4a57e01521a0c6e1f94f722712ce89ad89b82d397315d28c1298ea7198641ab3404d484b4a1a1bd3c9a23f14545d2159d94c7c74a70bcc1f98dba551a53eb27d5a531da5c281358db1d36a2b3a5de841267c0928eb0159b61f46ca1bddb2569c1ce86182bd20dd69d1b7b04c4c1f7d13b032dc7a10defabebbcfabc8f180a54a92a9fe65ab16be07af35ddf48088fc5ed8cc23e1bc88d33a0054b785c192df0ad5a3e0c6124b024dd659dc7980b767b8433764cb73eb247f8758ef615d21592784e664c4cca2ddd3f2dd2b92b939def3acfb51ae7a8a570557c10814961f062ff4e16f359260c2b49db993332a2db3eb8b55c42f83ad69c3844b95d3fa8da6d3c0a939db5dddd6df4c159e41d401fc4228d6c08a12263d2a495e3fcbbf464fcdd823640dde7c5c335903d1c850b91cdd22d4ab7dcd5b094571d3ae51d58e3ef6aad4a044130745c7043a6067bfcf2543fa5435c67ef8e78be61058989b351d8a6d0cefae313f9bacec11ceacf6e492c71a3e3550319b6a12bf6e787deec3435f825db4c7a0099f32d25b9a118f954a5f00d0cf4b6e7a1710ee2d8f702347abbafb48317ce55f28395f5490079fcbbab20d4ca3ac76f77d6d26d205d723af2ed84ea6634c43ac0679ffc9ad83b42bf2a6e82345e98a8408cf6b40b7442af364253a70b0c180f20943fa2034f48d09d8ab7f9d82c2c98b7a8f8b36539fbec5e910cac00fb8214779f16f96d4273f899cee03fe6e329ee494286e29146ed7b8ab5ee39c756f1d569239c0afd6b8ce8e47af6699b9611cafd9c6aa5b6e9d477f33365e015d243892f4702b621479b5b96d097b68bf62a8a1fc587d4ddf49b4829a5715d25130eff7537b347fc7a202654f3cba617c884f5ea66915316d1de10f8cb0d28d405525406f1412e0b6134f35a1386dd93a33410ffdc9d0934ca232aa1d5e9b7aee40a4cfab307a3312cd9912d0f10aa1378cb162137a645b8f52ed1becdf05a05a66ce0f012db31dd695e0dc5bc5b20f44974c7b3cf48cee11ab327d93d33e8a6b3195bf76edbfe6e36a1d1c580541be56935cc0d9e779fa836619de7720db2bfc3a34b3a374074cac3be5b62c5488e1217c08e06e402925fd84ec6fe5b66a1e4ecc7c3e180357e8e3c839d00432a1b561e1f5820dcc1179382365f900fbb3c10c8a5889557c64f3fa64f7117915391e29059a2612ed3972f17e798c5a0e4fe040341bbde98d850f5fe5a1b14aee9a279ccc0859f0821c65e39b49a7caeb1dcddc55c328af827a4a197ec581d226e5957a99d5f684418c3eda5bd04f88be7edf937a0e4b42b3f9ea286a575fe4ac4ad1a54f9750722e2ebb03cc365cfa296ff4ceff620003b5f5a45be36109ee7109f3e8c5a20755953f5c4843bd1c01056ccf008fcd8981568fdf8d4a4aaea40384e01dd5e7b4b650d2f061b9d3565baa07f388979f51140ee484173fd7dc181d973f6461d27b2c2000b4fe4d1fe99ac0c58477fbe3f6114614453aed4e9f3eb546e83e3e4ee6d1b977807c0b3d86841985b9bb1e4cd60bc3a9e1d07c6a9335f8bdf4aebce9148f656384af6f6d5e032c59f0fbb710cd2f76e98b02e8f32fd69efd48610c3e44e64ceeed5520e7c4e1fc5bfd1af9802076840e79052ed22300762b66b636ebea9ba714aaa7cf5fc3ae5e375d88e724ac67bf4a518e3b1e131d9c580a3ffbe49f5305a52627b21340b4eab79f130ebdd5e6fc86596345bdb6c6a13f42cc755da4c7f2ea3825d688f459a3e4cfae9f617e53e6193491c9029ceef8c1ce3e96a4d9f0a590302d990f1ecf5e15943f56ad6ebf8f5e8ed8b4baab6420046754f2638753a41977f515661452663bd78be0d262eb7e8fd33cb5f649138542c5038a26076eb7ecd5a8689c73f42a5e73164d8fd24c17b12bc19030018d8d2ffbd72a8e8365c5ef97fc4e56045f2aa19ab4c72f2083e1fccc0473ccc2604bf05a63e7559122c19af5d45969531e8ce5a59e33e7c9c37863f2f4c6a6c2a986692b7c9a1f5ec9f8810dbb18b749cf7bfc03527cecef128d8d1f9b11b6b47979c882ae3b64758c077bf847f936ea480dd3f6f335a01702dff2c7cece3fea3c595360212f6ff89dde842dee4d2845874fc9437f5b560c473c2b35e226c40ad26ea29888c15d6b1942fb3d7fd0ec29a248578115b6767f60854de24d0ddbddece7d287b47096f7bde3a24af6297bf77b177e4ff40ee643f580ea202b085f5985ac1c86563d1366bc164390fc0627f0b4f1d47c7f2f4365ff9816e2934cd29f739e3f0708b51d32025cb9a6d494643418e574de5e3db809815690e272ff94e59396e50a792d206759f4c3760944cedac71da2eb4ef4d1176cbe1a3e84533e4f59b73213aec77d9f7e6fca9bfe4c6ba7169736e6f12385c40d33cada4c58ac1a96bfd3ee1653f30783c8d5a1eb8d4adc260e88747bdd739efe8c5fc3cbdf9a20c953a8ca21b7845431b37fc9946f5804be403f5b615be6e8b4fcec2442d2fa1e6325d5e92b7284e7d36215816dc5dd0263351078f64cc36e196b70a0286c509e3505d963df7fa7ab8e6c817cd36109753c1fee672dc921e0f51cdf35c39b37ca408762ba806d1585c1bb06e70568a858befb38f4ab97e60a4f225d97825e177b276df752131ac2ab6f1aa1d9e5802cdab9e87caf77ce3886a68a8ada01edc7e6b514d83e99db937ff11370ec5a145f20abb7f46143f23d107bcf86fd54372be4be955e721088bdff89a7e68a34b8e3c549291416af15ab60fc48866bd238a2872af52817818be807903f66b337211f3c46aeaff2e7f1bfb158be98980497c6d330f34100665ad18754edd310a6cc4d9e91d0e45508e2757cebff63568e3ccf9bf77dc8858a488a3109d8e60291ef0d90fea0c143b14a9d23c9df773802917ac5f019ed79d33ba4e797b84e6c520e7734097e1eecb4a010e344629bbcda70efe2981347325116ec4c9aba347b877ad5ac20b5e186b9bd3a8951974fa2a8ffe08823c65e6659d08ba8ee43745ec07e8e5acd3b62454d2567de1b7800f228127d2d15e9dd15e0374dde006e074c7d11d8d173b304fef7d826f293217f214315a5bafef8c6edd6f347206141327ff04d3e4df393f0452927b767104a08306f2990df07242e0e75ca696d04b4dc09bf5abfde3ec1fd452e11375d7676dbe5ca626f964a12a29010d0c40d7de355cde352a886eb65cecc48ad93943e7e2f264a0cd9c4af8b9b805fac1c64587628c3a96943eb0e0c9efc06a4d5cf8d955bbe39ec66d93565561811183b9ca13c494261069c63e216d41ed52ef852eadaa9b6fe979196661a15b1eeaf860d1aab52a97e8532feffc9cf759246796254ecda832079dbb541ca0430847790a2c0a0ebefc070c2fda60f47080e757eaa9d0543cb5c0e59440bd006cb9d5aa71ec6bb38d48cfb4c27c3d4e9cc29662a70689825aa95e3106b6d3f2757fb60683a5a627c9b56455a570dc63a20b263632a067277adecb46d5aa8908abdaa84e5194e434d620f30e57dc7266b21b7f720a99732a70a966affe635d9e1cd9b609a32d83228ce855d8fa30fcdfa88cc71d2f48d32d7eaee88e650833d697f628d71f5b3d7762482bd066cb461a4099935b0dab8ba7764593168487e08420fe3c24e57266fd45ace9775e1a5155496e434cbb5bc12e3f80b18f8000dbd01edc241c453f9e0356e5c62223795d7c62645ebcadbd08d27e25467fb3155b63b80216535bd0b991cc308f2e802f4f756b0ed725ceb8cba81dd1beaaac2f1b588006fec765416da475d9f6e40ec09a44191d4f23f65f2122fe1c3c06732c42a64826235da5498c75f76598133916fc6993310b723b712e2a7ff359c9f95d283d18d250e05630ccfaddf95818b40d09b9507f6da0eb5a696d6e63db905f66d5a07cb78c81cee1b11c49763f91e5bed13695b7d97e853e67633504f93faf342adaeaf49beab45cc682f2a4fdc40f490e6b7eb0455753d7db4ad412f6ff4e04759a0f290f29a481383b65b226d61140eaf960b1fddb127aa50811544646238d446a686b689ebeebad9d7da1625f593e4c986669248be274d6df9daffe7919f6a815c4dbdfec570e9fdedbbc4045c2f992038da606a04ba39605a7ccc225c3dfee816cf1f3b61828ef22c1a96ccdbe146c0748d835452ea4617a35408080afd01519eb2d7d848d52a5bff79524457e047c79e6783ba17b508bca65d40ea76f4acc6cc924f6b0ad6c8d673a5adf220267036b83388ca1b94731a66b258118c40e38428efcc1e01497b9cbf580d8cfef6e379d1b102f78b70a0a1ded9a09da3c143476831f8f364e53b5d9b7e59e4e3daf18079598770c4ef857daf439f7b49216cc507664f55b5e32c5790937347c1bceffabfb6ff71a4079b6f435fb4d636785e5079cefbd1120b5cde1b39e9517824f20cc5ee85fa17333345c050036451c58f26f9c1468ae156cadf5fb1f54459ac9ccebc0f6eeea80a38117292831b79aadd74e6547eafa54f9864c49bd689b22b7cfce766250763d493f93d7c30ab687326c19e00d68a7f41c8d655bd268a11e5ce98f6be444cc3fcca584187c24041f0a7c68d07060c7c78ec3d5182974c4b13d6064fa361f0e67f7a4e9bab43debeefc9d58a7428729449bf572aeae39daddb174f293d96fd5f4b25895d425194b0ae4930a49d82c5f95fc53261bfc04cfb8011a0f108c62b62102764e23b064bf6fe8fbb669490a3d36a1220b15ae9e6512550031bfafe06ad73d0c4f877b70e599a5a3b6eb9413678d4541d801803004b0aeeb8b2012e1b0cbaff072fac18acaf4799b7ad78e97d7619883e675ff1fd960f1862f97c5771b467e8ef4e395eb017b098aaa9ffaf678c85437a3a7b5cd040bb069613d130383dc2a19f4533b1bd666cb98ea8d34d5c74a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
