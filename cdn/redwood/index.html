<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68a6c76219145c57595643d6f6f41f6fee3e165910704249504c91a47e794cd2ac18218717a99c80003c637e129bab0d40c1cb55b5a6911a94bdbf0eda341b9af30d454bd136175acb407b5c9f786e7b7654da51af84cbd3596707f3c5c29a0e97b12b72aff4c5ea677739911bbd0131716bf5a7a5a002115f71f54a1180fab8c3eb1eaf83294c14b1704948c06bf28f789254637022fbb4d81de223db0194684ee00ec040b6ed523df264b1a509487fa537b5c5b180e7887b748c2f2f148ca88624ee32b18d50aa4b17c620756c841654a602fd91b385a0389539b5718bb5fe9a5d3ecd8851e33527cbb75dd27a422e360bb59feb5a409eaf1ce2b00a661a343e26352d732265e46258e96b8ecac8f97873f415ca3558c350f3bcd9740aedb631d9c14aa01e7d4fbe4361185b4291f441780c3494ea3a7348fea7a92f7cc3e18c34504c6d0f4d4519a4eea8d6e79e1893460611d22cdb2df786b96650cc1c69c53b0716d54609cdcd429c7715c161d9ccf7c4cba9801e10426073a031db2616bd4defeed37bda402a5b04d454822af2f8ed621c00f7fab234b0fd61864e1ee83d3d0400fcf3cc92107605996549c07b34ac4096d9fce3b23a76d81c863e7d4621996f686ecfa2d224a37e7e1eff024184e7acf36a9a28d716966f920696c3ea7f7c3cdb438d5841c0d27605e198d648ee9b36df6dc557b522ef64ed46367287ab8e5155f46649148dd6cb9907b2436412fbf05d903faa8b0b7c3ec51c34d98691254c494fbe81999f35672555279775914e58b3d6d34978fde28360b53e1ac72dfe960d4ceb9340d5d5496eea7665424410e7235147a0815aaa0260df26c64d2dcfc5d3dd7999e3bc914b0b8847eb4c05ab0184a516cec92637fd947075ca4265bc003849b18b455bbdeffb208adad91d78f11e746f61d8dc54ef7561afb1286d47fc6a3799420058d601e1cc97a26eeac3915a7a76561eae7b6559e4424861a409bbd146218d23838b199a93e9f875590c168da09d851e8718f34158b5ae22ec74df64dfc9a96857afa8b576f5e1e68f8914dab71bf01e93f216c390abe8085427ee506f5bae834859983efd7fbef6da00ca2bda5cf79e977201f7cba6da7f6aca4d4033d024bd3d8658bfcecaae04e9f1fd0e0838267b9941fd0abc66de83cf1477464895172a39a57b60b347150cca9e74a96eedc8d7b5526dab7e40e621c83c50034607512709ce1d2771d242455744988d9d7c7f5309b18a6c20d6def8f28db124a9222f4bc8db50c4e4eff9349f917829a02fc71982e36b19cb7165d6de24f8e5e6b5c9af2cb5c11e32b58826faae1f63b5fa682ae0685a1797a433de4c23fbb3cec6260a49f38b7ba2df42db1a19e891bc193823033aedc0b900aa8d32e56bcdcc7d02637567d2891b1f6d260def4ce142b1847872509c86c52f9c3098bccec149e18adab08386955ab73a357f56171c48dabbf68be1ea3dfbc6d4b2803b8fff430068d75916c368d5dc05f795ce007eeb6e5d1623b3cf8e82c3655d120aeca55b8f794997ac2905cd642c050f37e6270fc542eef43311b96f266a0efa0b80c8430dbd59c80542d60551e07a3e347883124acdb2128bb8da0b50a6102d7e8f2a7c888db60bf9fb5ac5b7b92d51b17bd961b7842bde84e1270b4f409e5f6d9c4ed518ae6f1db9920e311b6c1d988a23bbca474b0ebe5bc82efba972238a39d62f1f1afc8468c7e2425d1c90a00f7ba43e19c37479d90048282486312e2772c69b307e8db61d6ef8a22f09b90e198c41a1bb3bef718ccb82885f73ec96725f184500b36a56c86f3770f165e560f4f87bda170421a1d56c1ee43a5a80cc106dd61171228c687f17db373f61045efd7a89313ac1b92d3c2ade7f353cd610724ef7fa03672cfe8bf3d276452ede2ba3cba4dcd98b9f7c9869470414c48dadc82676e7dbe6f7479c066b86b2d9bb18962b56ad21e243874ac4b1f4e6172bb836a344aefe40cbf7a1c8ad679bae639f3b9f5d387caa346b997e9051a25fb4528c3c81d065db88600b82a3f6bdad693b8b78bbd21c32a7cf40842b46e65f7103bcf01eafb563f6e3f2d8218b1ca9e3efb7238433bb907ce55aeb9c1e8e9c9d88b2879b5fc50cfae44b7630db8e92a55e95dd939ef8574c754ae733124835932cbc16b06f9952cb41bda690da74eba191eb247c068fa2cce5ed4313fb1856c81182e19260ea65624fc8809bf4446e098ebb627c033c900949e4e193595e9870acda54cd3769ee1e485e6635c1e828352edb4739575726eabe4bcc08e396074171a89ef8b05eb88273628bc60706ad689f4814dd7289249e3b4406b4fbfd6e19b9fb0146d01efaa2d2c8c463b18d9b0b1a2604f426eca2133a1623f4dd183eede874fda19e2bcbe13b63442ec74613100e40c0fc4eba6c0d4e60e68e7a50a311c8b4bcfed4d2a660e3d54e97477f9bd81fa1e76ad637699887d98248ba788b302029d116be76587019adcdd167ecff5d4d4853cc56901fb2fc437b5641739a0874ddeda0ec38020744abb77e3375bbcf5c19eec571763d0679327f5d8e51a31c7bd07da49f08bd7976fb2191bb7b973653f88e56c183e4a51dc22334ca0ac16b89b1e975283d8124de211ffc63b440a66cab5455ebc009f3ba8ea7e6a2af6872f74474888763e2090eb9d356bf1356c855583d0ec110df8b91c53813b16e5f89c9915838ae3618639e522b7a92880b60b541f08c08fd5239898838f3f9a63f47c477886e40fd4aecff496e3bcc65199081f0b9a58dfc21f4262b87c36c2561e63bad73e2e8722dd7a27d095d23a4ca10c5b8bb60efede5b21efc55115ea081c6bee0a62aee8ab06c3cb0c4de269c8bf461675d51f114da605fe94763ba0103a4e5b0e2cdb18dd1a784e6d4ce425770178c659b09a50899ed974b9b90ae984270424e13a2d4a265681781c3b31c25281c407017a6c5d0f996636d7085763298495ff72ae1a51ec69db4174fa1e05765844a32c119db5190866925122a64bf738d55f6167d437051c485e8afd61f46fea8fdc03296c51941e247f7b5e0000e1a6f687d17e62086308f68e910317cbd099c9073e949a4c7b9874368b7e3e9ad9f39a2e25dc8595ff30e9d354662d187ec799a9f67ec79260d2021e441c270986dfa8e9f40ad68c7f4d370c1238c74b2a03de1cbbadcba94bf3d9cddbb07c7a022b9f964e9f1a8a3395169ebd48dbc701fedb09c0544070197fe17cc43ecbc5d2046b0d122d453baad5ff3ad77e6f0725cc1954d145ddac23ba4958912e068a36f67e4601336dcf3946912c0a9f9bcc548c620fa86fda7b0f15f85a81cbe7addc5f5e7070795a84e9e902c46cb3e2a6381a7dca0f4726bd37574f85838d7f2bf328ba06c58868a490a65c9ccf3187ce8ec25dc652d2afd09bfca22bdf4fa4f1cb0619ef32563e7539b68d9a8f8ee035f434d522aac2dbfdd83815757c8907c5ff6665f9aa84f0f0ee7667e31f95ecbb3e1668b2e083e37b24384ba1483867441a24bff7b830b09a1011aa59bf84810e16970d173878bb92348ad005f6d7004d465465753f5429bbd9d383a787b7500b8de7fac9afba981bc7120f2ded54bfcd81d7338b7e79fdd4cd737927929307bc1f2b4bf549deaf5a13acfe651c955428c0ea2ad344c1a40a6f4ab16acdce41e57ab1e213b970ba6658fe4ebad5277f372fe57ed99139a579ac0133f3bd32edeb417c82f3b4de857214e1dccbab880a5d6bd6306ddb49c6ba4c8030ec69a3042af987f8974904c92da5eb04b9d94647e222dddcabe7536595a14c9448a0a905de984717976c26778389475c3852daafd75f93f44871a1efe45cd34ce99aeae0e93ec4e2f6ae35d4322a3d0e6776efc271115bbbce0e20348a6fa72c99290b3615c9db1a4c72620c4a4785d45abec5fdd69edabe59fd44c3868415139fd907ae2e5ac4f7a916799b756be4356893b4a3340c5ef7560027e1e7613fb05d501b88b291618f0a864f0992a8e549e64c8e4ba98da8b23c1f60b8ad2e5c94d28d32be7e31d3adef5e23d9420a116aed8831a5e29a009a7a7aea40a305519ece375b5546669b1559fcc206c5bcc1fa031d237dd01d36b2e43a26d99f947bee9654fa86f295a31986075800d4007d77006361040a3ae929ef02bc97ef917a010cb0177560152fb170893188d73dd6cfe925e7b56738b8596662d18242073ae87db0cb65c0775d966e8dbb3fa425367aa58ac0dfd67c2e58ea410d46772553174c6b4f0f629dfc83db79ea55a9d686078b16c62c45a27fe50a405f9521152bee635fe5b5716e0e646851634ad2163c8c5947f5e56b717c123b36afd36c44adc636618da9dc38fd683dc8090f98fe3e619491861c872d11670fad505f53493e737e66a96ca5a17cd09b49fa347753fa5836addd86251aa148b40c6559dcfa665c74c359d4e755677f62e137c066cb0e2b04bd5fcf83214ca3721233fddfea6f0216ec1bfaa09fa02f83b5b8b90a2c8a548197dfa25f0b3ef070ab74bbde25027886fab3399ad60fe37a252a50395295f57d52dedac6cf0c9f91dc66739d3e2431ebe647b42f6c18ad5902e4a8e6b0c008843c32c00929935812f3cd55393a44b775b4e305150f6fc33399e0a15e69cac791a17b8ab1353026b19fc33c8e93032e3dae51a2728d1f404799f53638b0cd24d102fff7d940faddec4e86852980b66545c3a77d142b068d7b33342ea1391711dbca9ffb4e8102edc4237c8cf2463ff220327018a6b8a762a7419ebf119dbdf91160074882429485697cdd324f4824116aee5e96f40b1a50c675f6ac5349d3cd7a0a5106dda4618ae87af10d2a1212597ccdb390744a62a68093da6368c6fe5ff00377016f8cc6b0886340c549b3ee3d85a6ea566aba5d0fbc45642754a2da08639572b1a49f3f8fecf4776b69de954b89b8a01680afa825ccbcfde594ad282c65289a495020f49d02a8fdf34be454fbfedaae20c0403ce1cdd10a91feffd4aa0624ff65e4756727ee57cfacc6297494864f759d8a9c0ca27be16f41d8745acd322bc93b71a5383a08ad63c80b02163c12155f6e8e401218cd0d9752567636c232876f558fb50d5c3e999c47e8aef7d75cb6581ec6486060ac53323c959210d11156f8fa305802e5a4c89f7b4e39c4fc09d2bb87cc637d0def67a99cbe5d8ac64edabca3464b327c6dc1ec7d5651735e412ac3660f3dea7f89fe93553284a6351443196d68afcacfb3f28dd42c1f54fa980d225438d19ef209ca88b233ee7868cb375c983b51398acf6bf7d35de299d9382baec9cf2f25eef047e0c45ef216aa9962da718c68bf9bc951690417d0b6c5ebf55f24c52e5fffe0f9afb188189a307289b70dfa5b0bb165eaaffb40a4916b3ec75dc12d1c9ae7d337c6f59a91b88aeb089f6079b7dc4a0d1727dbd2df7d56746e8ad574b96b0007c646c7e6deed844c9594bc12259c88e608cc286e712889fac8f064a6845d9e8f872d260280a131126557e79bfb76aaf722dc9a191dce2b1b44cf894c6340397e56a09a44b9bcec538779f7bbafaa7d57735b711b47478ae5bb1ba540c1141884d5b0e90d78d7a4232f6128111dc9e08c7029506826b7db4d93b777619525eb4244a2890ca52c5e3f05b55847a44fb3ebf3de55abd7daaf76e546638702d2c804e849e1d6e52208c2d00ba6fd8d4eab1b04c3d8ec3c40c65bab94f7d17e899f00bc4da0694f1b6db3634024513876c442b4bbf2ac3f5b1f089c8824aabfe496ba1fd8aad93bbe650bd6529d64d42713d56e3b37d0ee31127163765269c8394c3f1365f4335e8e82cd6fb2f352673d40f3d687a4c62aa0147dd7008e4217002e70fe5adf3efdc2aaddff12ae2fb6980ddeb09fad28e499c14b86f0b3ed94875c95e24fb8513541015c74f1962e81e2b7a8c9807b27afd90c43c6a3131ff8daa71155f511fc50b24f8323a34a4d21eaf7fd9f8a9cf3e959f7bc9ee9aec5436dd8acc59ca2091e933142f79cc91f6aacc9e70656f508299eca7dadd080929cfa5c9e4dc42d8ef946fa851e913956fa2ddc8d1590ee1491b8ccfdbf9cbb1f312de4862e807e98b28ea3f98fe2fb337db69d246cd2db676c102da7e9ce2e7b6a6d79204fb2f4955a42e37ac30b7880b9abe1fb1ffbc61c7a093d605eac29a0ae453799147cfa74e2298dc7131fc3ac54ad8ef379ddbb5dc848cc365870c8da3bab38e8f4a3e77cea84c823bd4d1c8f04b78ae0c40711c90e1f653e115e71a5dc082cef50050130dce9996f14b711b60e241631c1b3119e84fc770dd49aa13a9e3c7e68a7d3abf12803b1d04f74b579856ec1cdbf9d92fa92d597c70cb641cb1bbc96f4ce94fcc627abeeb675c0649fc37923d336f949f2fe14ea2ccd9e0bc8a3edc76109f87d2bec962db928c1b6cb2b6c7504dd772508035b45f3ce666cddd4e31e44a5ba22dae29c71146ba2d46d137092d72963129c69ba5451d9e29aea52f2058b08c261992460c9e76935da1e2edac0c15ad20100905ea7edec6f46c59d90e535d27637c3d705d013be162d3a0e1eae16c6c654b8f4a757f4cf77ca6d4bc19242535d23fd48d333fd914e8ab550156d0fa25447fa92d1475b6f967beed2c123fae4e490d39685c0340a8e9e6583d8ce996f0b24191da8ea86bb99d3760447800fc62382a5cbbb0a8809abf4456e6076e6234527174420b7e01edd2a0e21fc84f9af4dbd424d0dafd11f1019a2b60089fda8e39eff98666f1970008d7adf00c65e215174e5cb61364166c62051176d9954ddf603747581324f1f1880d0fbcfec354db2ddba28124137713db5ed56ea949f54f65619eefb36083475544755e91beba73c6dc20b919df8193afb215ec416b2794bd712927e8123767aeebaddd990d07c918a62d5521474dbc95a9244d0d16132ce56eb6a0b180ae6a0d1a836766c61da7a2445ab5e7b9e556f5d36014e644822152c794b5e805e5269ee010a2e5786a559999fa38354eb60c2660008aa8a7e0ed85486ed8e1a8f9bb36e3ffeaa9985e0480cba002d51f71eaa513f4d36f8d5e4f8bd96c8e709492b166da135977d53b5aa18f71fb989da092a85737c47d0b04f3ca04376495620470d805755fc20ae4dad3d2d0ff3c5ba89ed2c2db12e04c1b2f49d5ab474a4311319eefc0fad8596b2a65831a6cceff03fc3d5e741c1f05509ae5363a6e92ff2a9aa5e5dbe59aec5fae9e7c61c75a72352a7a43c8a7ecc08c7a948ba4abdf275d553692b5cc744fc72417e57dba8569bc5b2d60e5557ec3e05b2c5c5ed2b3d631f7a482856da9402adbbb2af22fd01938b28eb45054189040b920e9fcd5c2417ec9eb175c2f036922988433c1598a2a934f0ffb6d1d665b5d17885cf5ed22e2851996bd0661708766ba28b1f83e2d4a4918295eb661790a1ca83e971d9e076a48b1c78f407bfbc13a42b9777877272197b435e44071af6089097fa6d6fc4f16f27da567a637eba15a6398fdf54690e49a0ae92bd9bc797ae45ce48944bf1116a4cd537ec05966ea972e5674c3240d4b4284fd01a9444f91a1d8aa5eda70c7312c38c9fcd86b1d08b814305e2af262cf397de92824b16ced26c0c6c73ddc5fe32f2a88bc641ea32d3beedd9c10eca91a6f93156af0264bd64da22613386de35804439788c23d9ad88de415e6afda88958b894226ba83eb2b9b716ddbff2f3b21a6393dd69fc2e85c3a117d4cd0d1ff8e7104de9dc4d44c2bad481726924b5057d7c7c7becd908feaf8927bed24cc86798b0663393bb0362453f89c2071df358bd3393270f4f515c02899a65739c1ccd03eda5c6e816135e20955b35ba20341705c9148adb2567061e901e6e3503416f56dabc4a5f5dae1212c426497585100cb4ddc36cccd67e8fe879478eb9afc68dac6dcd77ac84819ad56746b5da6df1037e0f60d04db5012786ccbe75f781869cd321f45964ea7420e6e352e48ffdc5785f7b8b3f4834631ca6ce01406f3318a2885c9d30faee38afbf6885c5dfaecf7d960c0120ff3a6b6601bcb8a0215f58eb15576521c2ff7ab2f0e7a879682d8c110c9356b7484d8567e8512d78cecd4f1f8553c2a2b8d5023b07879365bc35e9f2c20c58cd2ad1660cbe33f9f130e5332e0067a3d33927e2b0bd24dbb0c3f3a11ff5d16169852ab2a1f91320e13640201fcec2dba2569ddbd13bd9bd9a046cd858f57470e3aea8385c580b755a0be21047df9f72e01652815a712ba54307f63aed42321b10571e6f73946d2d3cfe64a2dcc7b572a44e0ceb45b975efdcef8e7e6c739d7b01682d6ef805961035c4ebb33ace7fb0decd8574133ddd1c0f12067139512499dbdb6203f9f6ea690391f6038102fd2000ec2cf557390342b62a9f97a81c0da330f2a29567f3e9871f5bb8b2896ab5e9b59b442c1c8d7dcd4066e31d04f82b14b326698fa1d646b38686116135af024105c113d53007c6a90505a6e636e11591a5a6deb9b102f2656c144d718f726b8e15e88d58fbbb063beff312c6c8aac954ac3bad672f13796b28f6ce430a329304a054cc32e70cf1c132c0eaddff0b5015c0cc4334eb9d7ad37c6cc10b6576af503611776913e49e007b9b883d1758c2a57031817cff7f919cdaa491c74abe3129de9f8ea454611ae6b8b58daec45357c5efcae6d1adfe1b2889370a8f433973923358430e7e622cc41f2331a8220337e7b024eb6a942e3da41651f3b725d6929ed74b9e554df4425b126812813d62af222d96fe346baa9ab1687e4e67a7f289c07be4d2672c78aa0a3831554a3f40a7b90aab8dbb32eb0e7a1ea9c0493bf9194f35f36c4b97cf76323615d698133442a92fc9a6616ef1df68b63fcba36e1a02e998bdeecdf1edc393d70485c58cdd0f6a5bccaf988405133dd0cc7286272b63beec10d158ca97d12c631e279062460593afbbad8e04987112933c1d4dcb67cc93ef51c9a3a1a05a151937a824e7701ad6e361912a1f17da265beeadcd17dff7fca7d8e8d0ff5d1f2a66e08fcc978656b7249ca8a62f0f001589513ba24df3c159ea3ed765f1ff3d50eee546332016ce9098c065f3bbc5e33a066a6baaff20026c569c997f4b3e27668d0000dc11d7ce5766e89d4e3817d16bf5a29e932c2b82fce1ac4611d00f33fb02a74130905b14bb3be99e1852618dd7d80bfdc9797ce64a3766061465edb96b464baad45f5515939f71ae87ed428fbb9c63236adee9b1d57305d9877e2712228efe3511025ae0464ca152f0b3c8e403a55b9690f24298d70bcaf195387c03dbe50d2b26cd92e0c85fca93923732d415c5d79b30734c5c6e1c6f2eb92de176af9b81acb0a6989b88bfaf3d3e966637b923f9a7ce07b50e54463b6960c9c93e26c137c52c2203829047b72d7c3920b57a24ec6e1952d249ef3330aa0892d7ae8747af691aaea4450430407330da496c11e6d58fd9f7084346dd9673573f9591ef130cc23c9434249810e855c55a83505975440893e60f7558a5da64284240bd6dfcd17cb8b501a31185e61c21c9fa3e5489d97c61826da9444fb53b8516e83296f9b6f51e43bd10faf079316fbd23cc5cd411e8e172a853e668362404d1d882610329e6fa6a0aba4b54112f68beb6ee0c36df51a60b78be23f0f4831ea9838efb19df86ff38f31506de39007b58ecb684c88eeeb538493282d4f10c2242647f7e89121f6abd59ac44738def19356fd0cd53a1b09a1e17e5664e17d38b38ade79006ed9b05d295ef26641b637588276d63dfe590350e579b07bdb86446940664cab2fee752afb6fe1398a20666882ee163bc4498439e22c12eaf9047b1b486499a69e2b79684808ff2ae598999a45460327dbcc9806a97a5b6c6754aede18642eaf3f7d68607a7e761efcc973c094b049758724df587031e9107de268d82af91062187197fd87302cc58c161ceda24fed3c0ff14369fe7b65063798c0588721bf54b5f28f6b03499255216ca8b8afadeef092427349859c513abbcb5b2143703635ab40e3991b45d9355850ac2c08a4f4ab7e2ab8cbcfa977f72ccf8c4bc377abf388a38d08474af7c651e51ef567f3938ac25a082d310616d5c2b0149107d7d16387b6f0235d009b93b310b9e570ae8c9b81110c73cd8419f38ba635fa90541d53a8a986b3cbdfaacd5e7982c952e7cb23e92f4650fb5720609be6902337934ab9cae8a63df7c71d47412d5ea276b69b8c8f3cf1a4f9aad433170e0357b2e47b0685126ad34465bc10ca1fcf7d38274127f604c74c94aef59bd695ad5c9447a84ee9dbc4a274a730399545683e7da759b43bb5ad791e9c84ce254e0336c343893a8c0d3f54773d9f48e59f6afe8179d2cca3578c1a0b523736a71c2b58ac2078074fe546f638a156d4f0ce851b9b82cbded125255896004bfffa870b6187c1d4f14d82d62b3a6e9b88cec37ec85cd055398427fb9660b8716eb0e7277e824c4fdc996ea0b447cd6d0895185812d870eef82ee557c82b62cbc3973bec57b0f6025998498b64ba6b0fb82cd3b06d16642c08dd50c688ed7fb3479b4ca76e1106f2f75bb1ff00318016411eed904e05627f81240f7d23ad62d5ad7c9f43b4480104076983c2799562b62503901b519e308cd6a79aa839a2d51b1fbdbef605f405e3b4e0ece631109e875c2d9d8a6cba7bfd58f05bf6fd73b49cc50b5b5d73ffb277f78d57319e1cc97e058d28d793473ae513702f409bc0350b884857766b266b3c0d5a49ed9e9dbfcc482e72adb308170312346819181ebdb219bd65318c3a774e3a164a2e111cb2a791b76c7cfee124864aaff5293599560f9f04105571a635b65bf944150c00cbb291a0de71f2adf573d733bd8f7f255a1e7b91373e35acf5ee7115df929b30f3ed5eb08946088b8da85d458a5471eaf52b7335148ed9b9b2a4287d29300ee62831de368e6b60f0b0a43b3e31df54972ebdf8a62fb2fc0cb92f263c2ca9a349a3ecbb8b37b3f7df4d36dd250cc3502d76117a7e3be89e97137a13104b510da7b1bfa5897db2fc5d71ea2c796a68d9d1276c465355a527e9ab7b1987b8ddc943ad8e39d0272afbc9ec3a1874ec5ac7f229ec3a510b8bb3cbb25e20a5ac18dd61f8c507570988ae3f99ebbc0ced64a779d0707a04b9335d89e675ac831fd108e90d231e0a5b17c9a2ab7ef7d588d253a510c1318169b16ae465598e5afb88e65447e9151632fa4f5f34380e6a48d85b9fb0c834413c50f3e117017bebc547ae78cea1b18f77894f3bacd2e2f0388a2d66a3a8b5522233249db344b0a90e366ab859b5edafd3284485af2da47e659109bea002682278dbacde4b943470b0b2caa2de2266efed1c3dee19d46f074f73f1f61ff1bf768cdfa64d005ead14ac2a8007dad9658b66d9229abda6c7ea4af57bc18e6cebc22899b569f4129ea715a4a5a43637c1d1f36f226f99754991dec624aacc02a559dc84abc7b0615dc8dafbf7bd605444f353f7bd3f6d17e01ac3cc9c600a37fb27b2bca3143420a1941b4af824f09c81b2b9c5cdcc6462a2b3691f1c763002f8d0290de10c6f97d33b337a92a2888d52289b3ff208edfbb3f18633d82d5d05ecc2569bea6775838cdfcf9b0574dc5b5762b4430f956f524c81b0281cafc93b1a794d949be29fc57f4d3da245fa1b61d3d1d2317c8c8ff95c9b329b9364934197d54a1ee8f74e32e9ed779c6b9ab0399b8de1aced34dba31d5bb63556cfeaf8913750ad9d503907f2090830e61cc19ad0dd3f33e722667684ee3e160397111c5f44ab71a7ae645ce1aa118a2cd48d48da426c0f677b6dcf2b8c60d7deb13ca7c553b58196abb1c59d3eb2e00004bae1673ccaf3868105651d129f2b6f739bb3c75a363e279873bfdd614968c89d10ba235b2937c16227baa229b94f9f935aac3a587034ed0dac7184832cdce3974037e4d66cf73e974ecd8ca169fc6dd5a46fc002a9b5a411f6a033a7b63db69a97f82f43eb1c66d76610f4b754e29d687266b74f03592697d91f0b1030eb8d5e7a06cb65e7c51d676b6f54824c3fd096856a37fab0d848abf3720f894f9f1bfc00bc87a35cbe8d2c461a9eda505b92f47e07faf71784323f23bcd54d9c20adbd6dfb4739cc62e0c8aab8ed257a4ec16cc125d62f554ede1ee456a5d6f02250d0abebd92cac9e866cf7956b534fa0c2f2f5fa97a45e22ece113735baf42cfa308a80d5d771d55708a41c2472fccc5bc501014123ba3e948f85d4cf25691cbda7f5ccf8ded90e3eb1e1332e9b302cb765a2f7e08cb3f4d24ef1b2729f5c214f1cc250e763304d6f637a5a7d3688f3f6c445fa1804d78ae8bafafb3846c58d8327e4624983e5c55ccfa6948c15a5373a81a5368018c2db12eb7af837280d98ef1304b5911c62e1a5f95baa056d9567b4873f732206df17083187bdacf933aaea1cd8563d3f2380c6442ddaae6e873f6aaf1cfd463b1dc77d0cc2e98824f5993e0806b5913083b7b961ee127688697ae72c18ebe6dc618a761d6f6dae03da24dece15f725e433d7cbcf1ad0ccdfeb19d8d7572106ef10359d02f37a7702f42f5b1e00ce6d4b4f553524c06d2fa97b45eb13c3ae50a26b1ce8bd05c05019c705450534a82209ffbdd063411bcf41118c0337b5c9727c2edd6ba15fb4d89ff5db2bb0a123d557b02895804d036d3944223bee762671453baa5b0ea04e6fb3c167ccbda1608c7f607689a57be36690b90ac01ae1a27e999178fb8029338e06079cc043dc5ff931ac79fd972dac19795f831ee664fecdf113dd60242daa9a4a3e3e7a332b5f5b6afe7f98cfa29f47029ef984c2e20a9c69f6fb77345c40da9bfdfcecff983ff69e1a3bb369dd73ab8adc0d21531bf676b2e4fea4fe560b873e551689a56f298e8a472cc9150610b81d3b26e57bb6ffc55d3edc9377d7f89bc1ee0dba41e311145dc826f116ef15050902be705d457e6cc68dafa85055d7d678d34d729e998d4c1f93308721012a00f27416bda428145971e811aaf019cdd5657d7f9d667d6777ee9b4c6bf2dd3f3ef252d55bc33e9c2c283ec2a49c1f75f09fa8ae0da3d2ec48caed8583168f26f05e586df8830aa91b1cba85036d0e66d7f5ee4a4db38959868c3e0d4deccfd8d6cac2b5b95827c483bf79fb3898825953a78ed3f91ed8bc9aedf64db0959cef24ef0978ab09107b4420f20ff86af270bd30a5edf2f80e7adbcc7f8f266d91c37b79dc924786a06f682d51253756292f0ca217499d42d104fb04095ad36e8f301010381b5d1b9051685f84f0792d96ed59138bd6e98267f0996596627c020d4a2dd4299019afe8200adc5f75a3323c6032d4289f1d144e749f91a14ac82eab366880c1d9ffee874fa34c093a372906194d93dceb1c2ec2cb909ff30a38f2c0c8c7875d6c4800c63dba48633bda39eee5bf50c9bdd823d6822191fcb102981a1c7094066feabf0d157b714d0ba0bec5a8d7a698e2919b70d85cd4165f41508d1c51f4884bcc9c84bd510acc9120ed7d136a6c55e24612e87f58e1b5657d82d3536326342094791f7a790bc0d8837669f9e3caec563493451c88b5cb72e91a79e8fb823923c4ce6ae38a2ff858a854cdf36237cd0e8dc3e74eaa146be954a92cced1db93ad51f026a34edebb44e5c22d553b18caf01d98bca6d920a236a0df16952527e7b92f09043453a72e7fdf3880c216758a43743b5c002b4470fcce134f32fcec73a4ff7ff2a9974dec318212cbf36bac7f41921d7817513ecf1923b8d2bc6350e53b48bab847f9f834f74833acd4e2bd2e2d4b16a8d7bdda16c9ecef8534b06dcb34cf9a08a1a6a6324249c113aa30cfc76e8b888d5a8f11fa16041455a1fce96a3fcbf4ea729eb5e8613cffc20debb758363f62d3a6370c32f356c86310a740cd49442c22d6d340f478c163f233af3eb2d4eccf837db7d6eb46c1270b6005922be0a797210a8cf6804e85494073bc48c3ee19208ee745adcc0bc7e9253204a2c88ee119406a063749300c6dfc64eff22adeef81a8a87a85f1b97e845ef89b39aa490ed830989478af60ad0ceb7d75f7c581e8578bdd8905572603241cda62cd6fa71226d050f4580d45b625cc2d67ce258a21016817d41418aa38354440fce607fba36cdd05023a0449edbd0ed98c56a41e90ad05d577c79ef2151b7bd473c7e6017af2f1a4da6e61b34e56b3f797772303ef05923986932afb724115010428cf48f3d81133d704fc878adfa62902ff90d4e357b8cbfb142d99cb2c1e176cef7450a87f37043b559a498e1bae49824d55c2e94228b7e597a74c1c29123eabce80d10acf13e625a033d2bc72a4227f6152fc9018172475028387de534071d08539026cc1c82c1a62de92f9bc45c75ebb05b2e6f571724c600b99ebebcafbd4222cff724ee958d096c9ca2758866a557f4ce92bf751a91059f6f11bbb5a5843431efff20ea85db37759637185bf10c6245663140ec39a3c933556c6844bc4a2a7946b1bebf45a623b778ecd985a103cbdd043c2ac81a289725306b56f1de71598fab9c61237780f71fde18c444309823c05195fb2b289d42551acea72202fd33a2ec05018ed8a8646246d4720d3e9755942beae72d9bc4c8df033646b036c09cbf4867cc4f346254131c81601eed7a030ac226eea0832db35c022d0fa89522c8fe2a44fe563a7aab5778b2cfa990b47a50fd40b04a9fa1a0159d2179ac737a4a406e033f9e2b91bf87ff7415a0e6001f1827f896b9cc704999e780678648eceac569e9983d0d5d1e05add747741c1f017fe7756eaba7b3ca15636ef5229dc763cfa8cd0e0f5d7f5fe922f0c477266716c55fe61c68a8dc355ffe2301daf02985fe0da6a8e972fa6f19498476c473d62f02857e463caae78488013f89b9cf036a3585871f805cb827d049245232ab0475b66aa147b2799cb5b4aa513553acf63990fdee42ae8c3f75444955e28558d04b0af3b07042861823b5ddc135f12605f02330712c4c216a6260e7e42ec946af1051937110d5bc0db65515c717da973fabef24a198d02780797911ba2b5b38366363d31f8df7bda9a8c3e0c2fc96a9f53962fa7ae1171c7cec8b31a41754dbbe1b42b6e94c1064e8244e984dca73","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
