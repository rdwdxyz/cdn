<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c2687f4f06c70e25bf377a225006a72bd97799500b2684343e715bdd2fd8d9046e45859b66fb28808696ab08213439b6347c0150e9ed0fb676f08d368081836fbdd3efa05d29e247489e7efb378925c1458c44c0594d7d9c5b0d823dec863607d24157dfc665aeeff157aa3e97187528217b7577d4f63f94869f3f3df56a39ffa7c1c9e7c9b0bfe557118eff7a436d557b47586afd977316e626251f4b2acecb5adf1140759b33c2b2224290db31f4505d5478abe59fbaaa2e85dd0f76d8f4b0e0e394bbc7089c645938924b56764328f0c7a89912ee310717626dc7e489361b8042530d3f8714fa8d6129e8ecee672cdb696f8b5109922b2e5c462c9aa22b86c24bc1776b518560f69e64edd5e262cdfcca5514e968216b72cc9abc6c2fea9dfb2e5cebcf916c5a2aac0801a4e2a9789df193756c8e7e9b55c3fe8cb2f4ec055c9926b0c9fa2951b7ffe791f01705aa2f4eddb61337da2c7d777fe51cbe7797c2395fa1f1bc74e1b7cdb1b2635c8cf15eadab9274cfe9d3ae91a952857e90b81d8959bb33815786614741580d44ef974b4629a1957c090e70f24ce6d1b08e6b5ba1374c0721ff37bb25f165908f813af202e7c77e07712513dde975e36c4fed0bd05b85e7be616330d4c9c0b1510ed2c1e563440066d9c45f2d03545830cad79a491d6537fc2ee4ed4ac8ea31a0625f7d5366c54cce054a568683e30f6ce9d5ed278b2ba8ed8e8749a4faeddcf65c63e52c282ef1aac59b081cca07bc02b555096872d63af5915720a9e47cbd36cd8520522d282f3c82c37159ab3445f12087de2f566df0348aedf57291678a634a559a0bd87724109de18a4b1bfd82a668b280f8948fb3b4ee43e60e88c8dc39ad670b63eaa32773e4e3a7b46e635470e28d3caae4a9e7b0281f0786a88ba769afd9cc1b698d97f69b0cd109c209195325fe1f2d375f4628b2bae0e664bc38e1a7db2b10f203639cac3d8e3a73f0973ac0258b400bb9fb61e1f2d5cf74fd236efa6eb11bb23195cc9602bb6f72ac180dd1b226b79cba3688c8c3cdd33f8977abfe18b2385d6432ad075009bb057e6e83554e324f5d71fe2ec5d19f3228b2ff765885dcbbe38b0558ad17101ca89f8c9d02bee72eb7eca9f5cecc6b39ffa08db976aeaa0248be6dde8f834fe0d250722536edb996621ee0878c3e8e1fd399cb33cf530b1dbbc518ba91d8803c2541cf57c838a71fd697ba6a91cea7ebc82116947e7c40bfd09e2c6c8bc277549b55d01bb52780fdfe88700d90e95bf0fe651ffbf732f0ea1376ee7298a9b1a622ff4b9b202d59094a1ba17281e082b5d893ae41514c9637bd575824f7922fa7c662c7fed831d87c487e5581f417505d2654654464db1f5839101006205d38f79b8756aa6849f83092d4fff8817feb082cb79aa299f71d463bd3554a6eb55e1315d8b280d71e0111a1ec7f6beffc3cb7c4fdf71d71abbe27fb7b2c2f773d55746dd99eb31eb0180a5d05fead61cd1b791f274ca690aa8bf7f95d6f6ea37c056a1d167b067081012a123272541eece68323f69408d58b3cc52b73a6c8cfc5e369012d4b1b5e0b1c879c4567610b44417118518ad5a042b022cbac5a4a17b3401ee963f23952c6a2cb019b1021d476ecc9b796415d03cce14b1745af417a333684660bc03d734e700f2b50ec39ebeaa0635498e179fa9fa8f509fd1f77c3ddfce65017b1f1215c7ff7b6ac28cca2a18016032f20c21be6fbe4da451a8c75038da3b948b7c6080dce61cd145d60ead4da704b2d87390b3628c618a6e4e4ddf7831ba34a30fa3bee0e790ec72a4f415070a493e086f38c006edf26b0eb45948c9941a0837a05e31ecd4e1408991341457360aed57dfb4b70726f127297c4b2e6df19c8076606032ff1ff414e138d85aaeb16d0246b8eaeb684848959b284dec65c9e50d426cee8c7805b0656307d41e611a2028e21ffa379076d047351c215a02215d3cb1699d63af82f5adbc5aa4e644ef9393c1784528e0670979b13fa654ad8041dd14886f5140961ec839b0d28530ab100772476ffdd82e0976df740e9485566ee53d785982271609066ea29e1b67f6a222c13d5b075e66ec87b6c6e3623ede91b48557d0d697ccf07fd1d7ced1e613d02d53acc0c3394b8bfd4bcee3cc928c65d01d0ad067b260a25761d935093c42f1957d14ea2294123a7049052bf9b0e6a592ecb15679bcfe973f2c69d7ac630a41364692a3f0fb117d3a8e28c10805c2410bf906ee059754ee291994c14e0a4725e6de4de5d8f992dca410229d529ac94dd66314d00ceb288a9f1209c9388fed008ef5e06d48f79e59eb109f7c92ccb177f3ac3e1616903f457ded5503c63828fab67ba68de4da71e51bc7e1a309f33c1d8110e5b9f0ab8e281e2704f2ff9d2499864c7e5051277cc08a0be0ef4fd68d45e82963b3e3158b3af9fe91aac24e3fa4e8e4c0929a9699c22c6b0c706f6c47384688c82c57011e3e2a04c6a7c01a1e0fab70130931a11653d2f98719ee0290ddc9a57db2caf115a4b10f20463ee99043a7324d9fbcfde3673fe13f660c91ffc7088e5056ba0879ea701ccf9f8e1fea15b3e7718b9d0d799445051346021090c64015e62a9fed2f089767f0498f46ed0c67c65f4f135ab79ec7bc254db369ea9ed79513b52d055118ecc5ee41eb8b324c5d59362bd7eba4e6e1ae3f4e5ba8ae6b5cc58f527452532a0251d0d5c780212c30e5a2851f46b9ddcdad09980f9853c3ecf9a53f6b496ff5ed59072c641f14be32bed9c67c3ac255648f6bf58c2cb03fa59547fe8c5c89cb3ef3bf1c2e0896c85f182363f57a157882e990aa89e0fd41afd5c1c0208357060cb17c07d004a9087839e50eb24ec6b3fb9dc1b36d392153e4d5c33b0406100f308432c17db1bff8e3f0f3425b9b419a6fb6b90d3943680f6857efdb916e241f2fb216a5eed9ff09f2fdb4c9519accfe6c87f3ed8d88d1e4cdb7650526d1dcc44ca0ab25ea3562831ec2288050b123cb2878c8e1cd9c81e3572eec05905c1b94dd13bdd9e5ddcdd99141a782e80a721d84aabc5eef6506b13a955de35cfd189c80a3b96e8d576ad2a5b92123ee5a1ccd2cf5e68b4fa45115ac79d0addd383e18c8fe52bc0ade8dc0810de26fcf77a0ca056637a2a6ffaf62b45ea3a717404248dc1084a243af2f073896efbe2f57a27c67ad736ebac69e9271b359066792d67b60ce13b754c048e5b205850f753f3ed0c00491597f6d1f1797747bcfee698e31d3c07c2f4c464762001dde5c4b3240e5034da54af293c0174c666b557a6240a356cc5f97a0af3c9b1cfcd4d08f3dc4930ed89bffe082bee4766d6ef55c94ea916efd46cf09ff69a2bdad303a88910bdd3d5576d485f6d864cf859edd86f5048a95d1c26e8fb76d20dc3be230f566b033490dac275e32fb56974668d1ca5476b1606347f069b8ba50e7eb425c5414e0d4407790eb674e2e8928b20bb21dac34b8e6ff61677f5d7cc0f6ea1efa9b306c7bf12d7372d20dc7761f31f4fb09d34f9a14ec24409537c9cb1ccc35b22846c442a58026945a9d7253bec4b352796afe894fe4592e4f65b5c0b4b7ed94a3ba0858781023b1ff07ecf5fa18f4f8cf8e2d72c7e879f76f10e58501612035cfc806229fbdeb3597c8f0005d76296e2b39040edc7debf1d78019046b28b3957475fb439766c5c3886869fd6adaf6ac6038675e62b832b9aa0284adcb5b44f636cfff8599a2c8d4f2503f4b4b2affcb621c10b4a1a959adca51cdf136183d4c86754d78149f8e67de404eba7cbb186200cf194f2c8aad22d05a8840f6ab4ae70f230aefd19d63bdace9bfe7f9f5286dd17b3fd25421860479f3bacdc44666d447ce46c1fab3200244c411c41a4d34c53eebe3c386e80373a23c9811d62862b79675daf17298bc5496a9a3d65634843dcd7252e8304284bf3809e7b737e6fec04d16c70d26c77bda969a7f7c56c1ea627c471154d7bc079bffd845947acac0ad5858e6e1e342ea6996db965f03f818ff7dadabb0c9862bd88c73e2cbfb70ddb66dfa08b11eb99f408238f33aa87226f9972e80589cfbd9b7bf9574517d08a6019b58ab5cab774d62bd30aa995c3d4096dee06a083e4d4076916377e7b117f15849c5b3a231ce8913a9fcbf7e2f1bcd30ef8826ea8cf2a4b5b1da86a1a05768b71ef7370a120c86823e9f2ffef3354341b5cad8713c2ad39e9b2544ac177de58edb22270793faa93662aa106adf6622f49dc7ed9ca3f36fee17afce621e1c5bacd682a377160821337bc9f5f75b12b47900f65081c6a39757f4a9ed9d015e64f87da3172c7e01ccc25f33a8b3b120bb5c2efd48b49d93a0b1db332ab1426f7ed84f0523035bc4a6b2e1fb2c6388f26ee6494d30e573bbd543e7d7511cef7e2bd816e561965f79093890892df19446e36d240a8ccc2c5f38a582711b31a0ff5c838fed34b4b037012aee0de66f6c718c7ef80d3551497584110de85e992d6503f1e0695a59852665b11c54ae2d43d37550192e4d82452bb7e940409aef4efdcb358514971362a70e13d319936effbde5d71063ae4b157e08119e823e5322461c0e930ebce23bfc8469ee2a6a7066169925ca1212f7c6adeac8a4b1540fbbe2e205de1face1257c30fe6c3138f9ee65966c0371c7259d69def29604c1381bbcd6728844d2007927609a81f07e3606f9725eaa6714e3a05c724199235d231d75a0bf608872a2ba1a06563e4942a42634cae2c0942feddf98067d1d2837df86d32de64f736943898fc45ced9ec2723c9a5d962cea1ae50bc978b44af4d7f34b2711728f324458e04e805d1a4bb255165b5ef12fe69afac93898ee11f0e730ffd3287433923375a848c864b60e3a5a5e25424069ea2e7e12e0dc035037cc76b7b1c9dc2d6a2d382de2f4decd7649b81ce72234ddcf74d4e279595fdab54f3fbc9942150039058400572eb9737ac8294edef82ebd3e748da74ef48def2361a2c1f11bdb5b70c40d782320ba53343fe7e43cc52546c155d87caedda075d1eca47803f868c8c60dbeb56f8bacd7e17a32c748fea89f2b8f18b15742fea96bcbc62a3d72982f32c89f28ee57b18b47241e7a4e07c58eb4fde9da99eae5c497161307a74b1f1ee70c54c7352814fab815ddc185c266208e24bae619c1d2bea24131ec5c133fc1565bc29f19d309770bb89bcb7ff5368cacd85754405692237509360d7c97b38f7a2256cdefa61e8afd4858184642a06a985b65e8aba342fee84ef1979ee7ba44e38d0f113769be34a17bebf26df94c6638e36bc451161eefdfd64e5a94c6951dd316834fd5712f849c1db20cc057427c37356f6cebb17bd082e7340ff36fd77c7b6620e505c09e3ac3c46490421aa37f82d91ea11097a016b2a42cc86e0fe6e81e046953fa9367fcc888bd1a409e023c240804516ec9fff427bc2621e250e11ae415964f91ae8a2050be8dee2db2c0a28a5feae5315cc6e1d15997367ec647d285bec50da860dcf36ee9cac4b2b8c18316f2194a97f49c256a37650aa59f5f3312e8f58ef4d4f6eb57e8d2759101aa2d2e54f49f291fec4c312631db904f32b64ddc9efd58c1653f41c4bbea2bc7145ef52237e0e609815f0bc3ced01206f701f6005a62dfffeacb54138e7a1bcdfec34155347ce32965c5257f752a205dacd35500da583b820aa13d3941de75365e4fab4747e9d838fbaecb6398884a117ebba3a20c58b5ee6e3d504c7e4a0962b37fceb1d72fc429cd49a85d03c2eeed97837626e320d1e07b67ef49d13fc0240e4a332585305a2e992ae6dc2781f92fd24b073bf0c5beae9f80006d54e228cd3f574afecbc59e191088598465bcc73d912d45f83475f90c5ee7e578865b4225326f5b68f7bf6f5e021aa808606f2545923b5e365a8ee1f7bd200f56535b83805e1c51cb835529aafa4adbd7bb33c8e80ee41681e5c076d6e3d1f5ae7e5d7d759a7a467458d1ed10ed506095869e7a561d2711d616c107a7e701ae1ecae9a35ad58804aad17ab627d03248167b73ef56e6c9f564259cd6847d95d06a17efded4c7596fa4d8f78225914b89867296bb7b7b6c457d38782a7a8a60c10cb8829c1ba59cc5aade6a9873dd1a985fa4bb48a3d8fc2ec9ebf6b4b1ad989f065b0832b0b2b0692eaa06a78801b55689d415eab8313d5da3ea50313bdbc0a7f84fcc9f708ba22007bc8dc75fbfbaa0b3c07977684f78392952adac604c92fd8b5bd739860bc64acdb6c0eb6557d2affa28bdac45471fe8516e9e0043cc16101cf1db59b74b1b24fadb34df51e4be8c4146f1fdde715b52b7804ddd639c3017a9efb8aa5953254430f8184b718ac05ae135c5b52670bfe2e4dc4f051198fddb8a9c52e2ce5b294230b3be4acbafe2fa3ec6a9e5a56c161af5625712269e2108a2af69969d0e84a326f8d3e576b0ba562e0c86c7b262d0623e8f3ad928495b7d02159efa724f1d872d3f32c0740e6e6207df6d8044d13702cb073f3a765e3a9ca8da72d3bf4b7d3d773f1a1e02527d90c71c956ae657236a2ccacbbf91879e0a84a7cbf0863b6855a17f05c6ee57549da262662ad906a53c1394819871c2c61286aeef0594c1c98a93aad772327d561bee1a92db8f0124bb9d408fd5b05491a272423f8add63b6b0caadf200b1818356693bf9506a56b921cb5b2b32bc96c981f497b3e0560025648f28edcd150e702903e89831e094c392ea004b50fb466ca13ee7505f793e7f39eb8186bca16b6455a49c0bee7f6667075abfc8bab67d1cf0e7f714c21f6b6a957918fe550b9682f507875fa7dfb9443143b02e9680ed8d8c3086f5d73e1b7a20375ccf9c91e85c25b2391dfad5030448940cd59a899098a0644de55aa1905aa000c7bc3bc0680ccb87436ad1e329d4ae9cfcef5a98060e3b7546aae25530f09bbac43500f6e981861b191554fc71e315c1129d520f4be831947c09c4ea0eac42793e761b7650f5a77f23da457eb5563eb9cfb673a83a1c94dc472a94b0a45dd5529d38a948e76d11339a05a08eadd1b2016c7a9a026bb1ab6d97ae50d418c320c3ffa707da79d5127d4b12309fd98be59520c63c9376687e5dc89dd7ff0a033acba8dd6bca7573e2eb510e0eb58e2e43155e8dc9a17ac1d9e6fd090e247b45d3d0efe0e9647cdd15eb0b67d48e70d7707f20cff7dcad28142047f260dfb04c24f18294f160fd37ea9529f1b8739c659ab643b59d46cb32747f3726c0c3c968c1d944f6ea9568ab0170587e5ccc1a402378dd5d02cde90fa7c14dcd8fbedcbe3bb83b5d36924812063791b0390d1f7ab11e35070ff96c0262bc74f07b4953dc8da9cc616dbdc51b2fbf90d78ff9e23d7627c2c1e65e1f4e8de75f61e36521aca3c6c25cd7578f7252b4a720e2bc56aab6332c72343c29813f875cbc77b27b6d229f223c7cf53602a23bd287fc1591f666c4d5b304643d4473c899868338a0cb3e0d8d6068f21bb791b0351d64dcf6b840e7b58853bd58c15c04ac9395dde2251da08eee5c356888ebd0e345398c0272c37ff6c3599b3d49f4f05acbf04696464c327290ebbba5ce9729a511fed1506e7bb751198068b8d00c8d29aad2979601023f3910cd8cebdc830e52d57c3512ee59fbdc1b41ef7324469aba1b8a38b0e97c1450e913a8b1faee40a4d547057b4d83eba2a6131501f7511b9df6a47ca2d688c2c0253891c15675f37f96ce4b436311cee989a34a2f86c2f606132e939dddce4eeb5a32edc317ebf40db25423ec5cc151525bac13e155e6e1ac7a8405030986d9373a7a29aa6e6edc04441e6d4a381d78d662341c62056142bd8a99dd2f31d8bc1c16b62aae8e638c2739860e0847a7dfe5a725f89d64aa8c50385bbf7cc2cc1914f41515144060f2f185f2751b4940765b66d6a0131d01914c800273ebbec0471798a7e7bfcf7768671712ba80bcf8174fc9bb5a103e524d9df449dc37c80f11133d1421a258a80a35ab95861cc0eff842827fa659267d8fa6942390fb82ab8801e5fc334a7beb9e13efe61037da28cd30694af7a33646d7d8bb0832cc6118feb1bc7c537c7a0865b920ad990c859d5506fad41b5f99781674134a275698d4225ce50fa8b067ff081a8f670a15be05f7d1a63f306209a5ae91fb84be4739d910e08d5cff5ec4947583fc5c5b8a5f6aa012054efb6184976b486465f1fa8c3592ff723920a9bce49d39be36131390dc649ebc5e906679f58810376485d195d7a5239a095545ecdec013383be39888481b20a8e8bb640277349341bdb6c751d4009e847cd89149d50377bf7cfb40fb4a1bdc5f0051f67907187d076f152479776ef2caca41ae15b1cda04704df40ba8c61f5a70a0f47d740cc256a00eebca56420cecb3de651e68323bb4f25561a0aae8131600efba8743d3921d320614eb2a8388ff9f1659b7f310704bcce151b4a0d72bacbab3c3e951ac2ea8be76fac85a0c851ca42f76d26d0163ce6f019200aebf7416eada8eff1cbb41ed85a7a66d1d0728046bb0393f42ad97a84560ce2181219a58d7048a7858a646054ab9c87a3654a2105c795a204ca2cb508d5be54f296f461548689239fca9a181bc26a4cf964348452e3079a8277aec8333e71e75d1e343ebea22f0f8d55076218323bc4a73b8580da6380d37d849ce3ee1f26bde4cd494ea610299d5b6049ba3dea03ae9ba4acef5af79a30b7460f4ca6cd02525462f69a7e92ee948db246d67373a31f5d3cc391cece8ad3d321dabfe9680fb16a3443ef0bcbc02f7a8bab8657816a5b1a0aad5a5057082931a86c09d4abe8960d713359f9202b5f5b4c2bcdfd2f610baaf915645ad8dd4ebb0554caa084cc0ac87c845de20cf89ac2c43a0fbb632c75689e4f45794443d646657e042ddce3d775822c5054b26295c90d9a92f69d0c6513c9708714aa944048c386b9f6fc81298a488e2e83c26215b1e129a386c4f269c6f4057f33a602d2fb8f55ca0a0b445ad96d092ea46905efc7296672b633ddccdf3ae0f236590dd8ec96a743b1699122df930dfc2bd5874c609f043bb70f3f669f684398d8aef7637e0b5145316c17df192e592c69f7388f03491d3ba93d74d3ed32ef890abb233c6526a5cb290330083be3fc30ccdde3f5294f05e5667f2edc372ea646e0c09f98fc313d78a8ed41278f8b63b3057b607810ed3d8799b05763beecc18e0999175ab1ff786c71e61e1351aaf6531965951b1fd3d2de1c11522addec27e73ca9fec1cdd22ac77bb7d249beed17925806bf79f48d3f2cf22931d0bc01f638cbeece3a2ca94d66f067f9fb265c215bf2b98ee797499c74c25c9d2661769c3338901297918c8a069890d7d6c602887f99d60124f0a8fd692b690ffed7fa0cd0ac7ee34e7d240b3d4ff5a7d36e9a23b2cc8e7bdc8db0bf66fc28960974b6e5c556d151e8c1bf56b86b1a8d81ffc5d0bddd2edd3424eb94da273964a5a850ec69278f7226ef07e4bffe2a7b4750a71dc5f0d46886b6384788bad135976f5175d284eb2c1cd28d50c545e7343125de9810b582f68dc5eb57e38fa3a454834121ba1a331a736ada0aef0cea950bf43a848ef0983fcec42ebcdb4f76490baaed4f0be432327a174e8ae91f96ab1f459ce4ed16f971d188d0d9551dfeee428a6893b73d47dd1773f2bbbc4a4e789c0bc1cf128646e9afd8b975ad81512e5bea86238ad37efb5ddcaa6faf379029d51f626027d6ced8ce04e9967d1730f8a9bc5679b99b20fea1d0afa24acb0f535a5f8837e830d24d3c69951493d607baa56274df7f0ff502043f63a2379c7cf9a66a0c43896f5d21c75e5da3aef8420d8f5095a953bb2c25fcbf5fcc3fa3db165c69a20b10e17298e1ffdd8ebd1209a57aa97011ac12d45159569d57efe507280f9ec99dc4c3abbaa5b23d05b8cff50158956ee9ef047eccfdfb212fa46f16a713d398ab73bfdc9b8565f2adba5504e4e9ded0c7b6e145f0326bae83c875df09d5dd61502065c39889ccd1aa1530c028bef7a95ecb2b0997733b0a8804f7399ac4ac5ad44088326f3920daf5d0e27ad187b3e6108ac1207d269a04b9c44618fc1a8b5fc610a320fb2892b3f157bba981bfbcebde5abdea88bae27237408e29adfebd7ccdd4d08ff8508fa89c45375ab1612164fe082eaefea0c06cc8875d08f51f72132f780da59ad89141f5cf8658d6824df1a7cb52ced5d95bed8e129be5c08b805e6fff6a72c37da5698dc1323f8028075fc55834a7e45e9408b70b3571b10031a5d7407b8d44784e0ef8c508fc2ab72c56db71205c2cad11fda249d88691d34ebf173054d4cc12b6fdaab32a3314d4c377be07e18b699a6722c1be40b5a9e0724c52d2ed6f48aa5a24afe731e6f7e0bbe4f4ce60ce00b4d51ef97beba61987c57d57fa9748dab94986ea5dc50f820a03d1018fa606956286a5f2770710211cd863bc173afe2dec427bac8b04274dfab2848ce4ed0979c31630a1b7ddcacb6f2c491cea05e1780c537710e1518e0b36f3ec599aa5b64a455eced36c085ac46f7dbe965feac270ee02e1d54d39877208cff6592691c07ba8c0fcfa04560af964ad83637357c370af912768bd9f77fc21c141927c41321473b933c995e885849f05193b682d77776f8b04d3bb453fd4e24dd31c9192c7f92300c58ba5cd5168a38767dc785980d93d8c4482cc7efec777dbc11c40c5a6ae722961a1216569a8d370a0432c504e04c855bdada67276afa69d0bcd4bfd5eb935325d3f96652bf638360476f6541f34b176ddabddb96227a2ae53e63fb60ad2cf5c701497ef4c49500e387f81ac427f4ca5fb4c4f0b67a1b084d782ac9263e2ab52f45571c45902a17ed36fb326fc5244b5c69406b1c8b3a55641a0cd2c4d71dcf4b8bcc649dac3045f3d32d256b18ae2c3a9a828e7ade5917063c811fe2d81ad218397a28e35a3f3d7d65dc40b776ad25bf4958b2b0e712505c6fe79e059b282410d91080f5610bc875967bc435936bb55f71854a8d1c530d391a6848efa354a0f42af571ae818a3852de6259bd4685b370583b5b7ddbe321bbd823a61cdf3b66720961b0f75ae03ed36786783fcdbe39f0a51583ae295439cd7cadf77c6b748f03d9b074979387b6efcb9d6ded7847a7e0dd82cc6029c3c1280400526d537d8a309ea4ba4c40dbc2121dcfbf144aaf2220e9997917cb504362ffbf6821270db7e1d4fe705033aebf93abf3d874a82ebb3bb369d80be35b53ef531aa8f51c5688c3b2aa8d228129b4a623412261ad8f89e845c63d423677054e0361ed9e8f357c62f761179db0c5d3017c3bc24744083138fccff9479726edf9c328b338946618c9b15818e2a56a281784d39c6a857292de9d937448cc37514015a62796375dd253eee132533531e98d2d6f46ad9fbeabcde0e9cea0df7d91de152db685f3e24ed4d6a3a73047106b9805a1ae80cc3c46c001dc72aeb024206baa6f11b6f0a7ee24c14c9f675067dc5f41ad5a0c19cd200fd483f1b12e5aa37aa0edd771f4fe4bafdad75326fbb58ca39cbae691934f4e336e1e91e0013717c4e535c1ff45990d1198724f26741486104586c4b6fc7e16b91f7849480d6b039e058052a3d90b2ff6f64ea0eb6d4a880ae16ffdbc30c0abbe6b73af5c1ba76d48a880f9657dcdc7aa17b0cc0e4d96b2e3f7fe602c8ebc703db65931a812d75d6c85c6c337b87404cf569c5d6544d8ec7e7b9fda4d137268eb56c6119c8f157de7c0cda53d2e95a0f1075f90630d6a5c0f99dfe698c11720ad239e3b411fddf63fb008623576ca0763fa1bf0b6474c3f9a945e9f5dd95d14f5ea45c1e2f757c45f46a429b6361197c2c46e61223ea03548fc543e93c0cdea54816e2ab66e5d5b1fe167da75ea587cd0ad70b0693a36fd6f69fcaa770f57cc7663ca8fbc3d560f581a7899c7a1709be8392f9138e94b5813c97efe6e596fd547814ecd46440debe500c30e5d84890634bd19185f82bedad2273d9cfc13668ee543a533c09849e4a86356ea6b57a1201774297fd101fd9925eb1f2c8a269ab84cdb2ff9ba8b50c60a8082e24ac72b92f79e25aa2ba161938855270c7fdca982890d82f67c99b9bf58f7c18cab933367866e095786744e3b83293bdf35004aa7e75802f151270a85c0d874d27c9f18035a8e4fc90ffd4d70627d5ebc3a2f067ea0e2fecfbb392a447059a1377283c91568fd7c22d6172ee0f7520f8e3b9fae20eeb878ea23a170ac0f346d225562371776ce4c819769c7c559f2a5fff382cc834834cee915f80e9536a64f9b062cda43d883d2f0bf40686d0d8dd0b6b5226c0ea3947037236b8b2fe32134a84c89e6c36beed237f60e643f1a3e9ba193bdb5b890d9dd0ca5a7d8269a93cc8b819ff3b47225bad3741c0b3b491cb1f1da9e94d82586a1f1bc48b31ed464c20c35f61690a405e4edf8fef0d82e6fa2d73298933a3bdba018ebe0856ae0455555307f0133ceba0af130f99a7010fffd4bfd24e5b399bb9648e03b247439a9e340e9f3726e503704833ad029bf92622447f8fb444b03ff58ac5feb4feb5496aecf7d871c9d073f041d2d636ef7e857ac901de46fb58305f8e4ed23015f63d7fc3d8104aa39dd2663e1d72762e92b388da9904640585637f88d2d5644e655a587b60a324dde355f790401a11cd54141055216b901f79d48c74a1f1c771ddf2b1d3b8872cb5ed0e46ccaafc7b2aa3be2bca297d3842c77f6cf273cd292e23f9e843d138c21b801313aea2992490fd3189f6352794de6a992bb97ace7baeb3866c0120b35ac90b1688bc6f58a5528fabe1931ba721f4b2c435e89ffe95d12cd02cee06fe9d5b8913c6ea6fa608d132af3b31c15e129af601d20101cc4de2151bc94d244a191bb30765765e4deb74e39b650b316221231c26794477255fe08a069c8db68c49a606969926d3b1e42f6d3a17f5322d52d1138befdd3948bacb33305e1d33628f4a628fdd7e98f5f2014edfe98db321cdc048d882a36d5519820625f8d8df77cdd6c820b5b77d135048f3ba204ca6f2739b06e064ad4471ebaafe46cf3390f45a81d474e75d242f1feb825f4076683f1f3ae81e2e5e65b99b34dae35e3d823f10417d2317c767f4f6b2c2fecc7773aba735f2e14583e297ee073f1e1c02e79a95f2f95027c9eb532b744174866e2e209964bcb9f70f3aff0308e1a268276457e4a98138ac05191ae319ff3c23f67d1c60192b7626d73dc845a67945ea9e10965d11322c0787c9bbe0821942b4733aeeaefa23b501f72a7e02652756fd31f27913ee1244402b6a40cb5385746906367dc824c627eb7a007f442c83878a05c3f0bff6f60862846a907a737a9eef59a0945248c53799653539810cb7256e22fc1172530a3ddc5b4894f23d3bd02c2bc800a267156ae57651931fb2128103fc881efe7916471805b15cf7b52dd49a18b2bfee4f97ea5e0b81f2beca2948bfec62e491a412e2cf3fe1d6c4d4e1aaa8499f43b9f7d6ba3ccc4d91738c3983cc252062647d477d645d4322588f8784f91b28b72bd06f81b7ee916ce122d38e3c153afbd557f33df0870993ed58506c84a586a7aa8991590006e32ba883dfdb15dd35efcfce8ba0e5ddc831cca95579d405af4e8c613b2c23c9e9ed256683c29ca0ced94a4ceffacaf32aa34f7acc28c4efdc4d4a1b25e38a902f9c504bc3003889a11d3ed7cc4985a1c09ab8a0eccb4e2099de99f55276866b6baeeb9e9bfa30ad70ca57319c73ed175db2dd90b1127b6216fc730dca6b077a95a25c3c52cce262bde3b47b6e17dfabf417ee6e87b6f07fb9fe3360d474d26a59639cbbe1a6513b62fa6213f12b6a88f52dd588fd7de6d1372bd6de74b03d881532838072aab11069e0488dd96a4435fafcbacb8892bd8c93563f1d4e0e45d73799045362352884fbe7dea2a292ed9c724b598a8ccbc8e41ce71dfe4a505704f4421b680feba94da2420b5d512ad6f6d89a7a2fe2e4a9e8a71c8e34272cd7ee0be8450aa7aa7ae2f1ead9fbd5df74ce1043eb68d6e26fa30365646592b37200eae18c87e319f4227f8636e8dfc999aecbc37de85c0a704df00c51819e1c56532a65e5ea551102b838e8f84be6f00c9dd9b7c1be1cda52321ef8b53b0d0fe644cf2dee15dfcafe4886a7e27a6b8477a96b78f3ccca60ca025c6a339e068761663f48fd719fd87c594e01e4dba0c245392cc2d3aa197c8832f890ae1d71537505d0406d3160489b169328885508227e3b831bfed4bea66d6452f73222503d4fc11fdfd0a9f69b19ac466e9f38a87c43f9eee288ce1d89db95e0b16ceee0dcaf43732db691362a17d363222d42bb0b6edd40a6d34dbad1768a09aa26f3974fbfc6699313f596cc72ba7c946b90c1f43fdf01e7542ae4fe6182603f2aa731791e2712b1ba8b1877f2230cb4655766cfa06e6682e9e590cba6a55e9eb5e45f479ea177a599f4fb8ea318c38dd69284fd803dec13bdec79f987bd73a526638e356865c26741605c67bdbac5f79375509e1f49ea6e5c2dbf98ee23d4fc9053e494a89e49f6767986c72657e2a281a422cccbe5655253a696db2f4e202a79abd50f1c6de9e8e3ba533e1d642799099fa6aefb9755e5d47e5e67acbe3a6e56c5e38d92f081a26771f95ce581dad269b9ec6794e23c1ea5b9d395252a7de5dd9e69f5808adfcb116c32ba25bed5ccbfc1e60e8c4f492538fbe33534aa64a15666d0349250e304bce16197a4f0d962ad6cfb62b1332d40400b39a2560b8362e9f8269505163c4bcc3682fe7ad53a1a876c2b7311403cdf4e5f61ffd080ea295db012bba23f1cd7ffa13b0abe7e33407f1fb58284437570d9e7fb9339e5331186b517ef35da42e08c419561f714ca1e744b0db6087ceff743e62aaf36121a6b1a5d3d165842e23ac59facbff85799d591acd9d862016e1f12df87d22c3b30899d2d5dcbb6ecc7d668e764af8472a2065dd6022cc0c70c8511a80683640c5d873560d656b504cfe32f27eac78bd43de6fccfaa0e177cb552096be76c2a616997781c27f6a116ba82e875f8e543b63970181bc61edd07a1908f413afb300f6e49da981128531478a3254af2609c4a4f7935e267bf62358e5cab010732a0f37d65d07e5b2a6198db9935ba4a55a49864b4ef333ebcff96145995e1b4f42c2e9a0e2d3225262d230c4ec142c5bd96a7dadf1948e92ce4a58281cdf178356b335469e7f817dd69c9993d0d00b34cd881cf0d21178d137ff97603f0421ab8fc4796c1dc65b8935d19037c1c39e02f46ec79e787a9b60eb14082bc3426d852519969261ab41ed3251010afc851f7f065d817430852dbdf6bc96da48eb8cdb67979fb50c4956fdc4e0cd62691e4c378baf1a07e2300c31fe83a6e82b85c03cc202fb5aa3ad2ee8cec108cb2b1d8371e5aaf9058e26c0dea52b901e7e673bd99265ab1344be731dc48f69cef5dcb9e673e879bede0fcabf0fee5179f44dd7dd4335079a4c5bd17d552a96b7ed9a92ba3d73bcae73e267aae73479b823701f688f99a67624f1f85d8189e14953c7f8e310cfe25c01901e4155c65e7729c5aa346e7f2cc29b52976f0d259b971f723fd14c1b2ed3f4d6d4105c021016ab083266a4be90b898ffda79ae71e27c11ade90fd90d212f558518ad5aa42899150b82709abd4fbba5029b6e0db42a661a1e56cee97db1ef1719153600e81e2a36d3bbfa0a778189222174d21dc6bfec02690bafdf7783cb1aec0bf12d32fb31b45a4fb1982649db3e34cb6eac60df5c3b7f0420b572945880ba22696f6d5cc9cfc1d969b5a595d7c7caffcf13f9d58a2455e7fccc0a2f4804393da8203009a5146f2d7b98e41cb3d1bb82d05ffb454115487b1df4d63c617b411f2a21a25ad4e6823eeab20ab3d75b4d10c6acabbfc1f8ecb377388ed335eb8d36d88d62e8ad8601ef0ef9bf95a6714966e8e4034e577094dff5d9612fadcf05953b6cfb9b19b779c823cdcedaadbe85a20ac3ae3d1608d91ae87b8d5ed38e3536263871ce5b798fc0665e8950b4ec3a833fb07b2085de856babf8d23f4a52b45876c5897eb13c829b2f31617b4488199d958decbb72ed6f668f0653e4f8b2f7c78c0619439bb7bfaa669e2de1ac4c57b4cbc2338097fae7b870144768c22af043e631d41775096b2d7cdb4794a35b9bae6562af2a4fae3049fd9daa3e8e3e8cb1d2d919abb7349503b34b677c1b70f91ba64b980f79f8fd8c265d65756e6aa62affad543ca0a869828b38eaf21846119ba10f8bd6e17e1e110cf93787b1296257120404bb23dba8e97f995b311f8dfe8e759e6abad978936cf8f2f7fb30992cb8d58a0df84eadd71107393407aa77d371bebd23b6aeea6d54f28c409043afdfca7a337ac9a5b1082e8f3891b5584ae88a7a681e4ba8d7c5318b5825cc41129db32236df62bd6a7365df3379d5153fe76b1e35b35d5f5e59dd695dd79c076ff63ac26cccf3d2d8404337850c4d02686bf47dcd8d3447e0af179c13b0defc85b792401b9974631d5fadfd611d2ca7d2e313c687b5faad166f31e19081c973108d63009706713dbf5ea33c2ed4b583304fe13b01bd78831fc0f4810b8b62743db03e6c85bae768c43b0d3dadb1fc726fab7055d771d9274414caf76dd2be46a37bf727e557d80f8338586c612255732aba7a4015d46bf3e811cdc26ba9b706c10bbf0b986d9abe2b5a89fac840bed7dd2883211c9277a2718900b147cc92c70a65722a1d78cb087a72521b1e343e73ca7668c41e5db7ff9a6f0d97ec3c3e31a76c198fd08144ed2fe534245b9b5f6c22090a329a3bb35492863601e919fb70c69ca2ce47193b66256f6a28d382aae5474fa1e9bef29d09f41b7fd63f68a1d23e559d22cb3ace0ead8159febbf16c21bee6c961fd8d921ac1da2c5b25304a81784c88070c58d180f53f327978a8a40326cf8ac08a66e790e2db593173bb4eb8285825647be3737f5ca90a29c141e29ebf5c8ae759b3df56e72927c2803d508a50e1f8343a791d1a0bf9972b329b0946d78429cfddfc984bad0a7f28ca2b31df709abd696d4b940dd312e685fe645d76b65dad23aa8fd5c2363189c05cc54e497ea26e1ba1298b6e1da938b7af17c70d24aa78da8c1273af665843369ed058ed795b52c5effef430a8914efc940b9549c630b20bfda3daf2e9d5cde966004655d86fceb60fa585248b083b76b0d1df062cd81093700cb5a8edec09c56604a2467bbb293c0652bd9ff0e9c24dc9033413be5b462fad7f5bfdc413e84bb1292fdda3c01d49ad6458233275f81a4392f694aeba571e730e6819a8b5b69d10cdf5bc9b9568c7d8fec02c8298be4d9376723e75e19d122d86b0faae047f8eb3a7da75bcd3af3e9eabf4e539451d5761ddc2b06d8a319e1efa598e5594b66fdef1eefc5a6c4934d96a3aa1f4fdbc9732b10ada804547d090ad109e614a7d070395e909b13631c5415a6d163aab786bb5426213a965e352d8feefce7a7eb3a2f13536d990c0d0e91cb4fb728c5b15f86860f7b2fc95761a323f180aeed439e0cec78e97322b1a45b20a9aaf53afc8c02ed7cf8e5b8380d9f73c1c2bd4b6fb750126801f49deef015dd5f00650b72b1e18010d6d7c99d4d0d8a0585f7cbe16cdd3ea4c3d721d91332f2fe3ce4f648b3f27ea18b7d2b9d79fe7e5d6fee9388595d74523af7b1a45fa595156d6cea7830e67d65407ec53d6f6f789e228a58e370c20912baf01265a4770f8d097921fcdf46e3986632763c325d55fe03922c3171d01f9a9a7bd5b552a230b74520b808916dff36e4cba61dea950084fbe5cebac0e788d1a25ffa5334262d529d7caccad82a80ed643709d41da20fa64324b6c86c70c86fb82e3e0a2e59c43bf0ae1d44be08f11131a68148ae68b42133ec0b59907b48677f680de7b460f629520a3c82761078c7d28cc0892938bbf35fde63f1c6ea03bd808bec96998213e8a645ef2c9019f761104bb470766404e6242b1d80aadbe52a8af5d3ff8426c559ffb48a3979dc89472e49a82294128ccedc4318db8b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
