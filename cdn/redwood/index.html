<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bb547ba077179beb16fd474087a119e2fab02e23952a6e64ae8a581565a48690c9f313cc0f541db03d00589fadb258ecde3fe5d9554c06ae5c1cda7af95c0598ecc58562e6b86584986dac02e3b01fe72c2d6d1974880a1be6078e43886e4d13c075502738fb661badd0360c709a7a0fcff7f31cb5945a7a027465442a1f9aad7c6411c1c7e434d0f1ac6fc9ed8a351763724e42f2a5b4a7690205160a842a68a68ef4dbc62051f0bfc44ee06badadc3e8ae01263c33fee6a47eb32436e6e8e5bdcc399b28eee4cbe5b347c8a7cbdcbbf264c0cae789ec949430925ca67a0d5eddc55e5e164d92ca35df94aa64f8dabc48d7b245aeeefe23465885e476a884f6a5f53fa0e5a57b0d61ab57ec5d55bdb6ac73646d087bba8fe7fda25f361da58bcdb3f4df0ffe9aad1d31fcddbc1c9de07b4641eb71d0c5a2c7e051d6c58555b2054bfbf7638281b1ee6d89633aa53fb4225b51edebdba77ec33b41ad27be8ac25e206e32b33165cfa68ee7fd292271fb7dfa37dbd85633f1894bdd6f3f2e066282977f61dd0c5c3b361becaedd489ac9c09a2332cbe5b60a04750cd901fbe1606fc398ab95e974e7ca5d465320bea8a5c57d1287aef5c8d2fb7feabe96d2d4e62b1f4c4a2160e66d8629d7cdbca9936b1de9e995760f1d3033aff3e0db72638dc39012777bb3988a46efbb016a73b3e9b785c7b3a56c6f3085f2c495ab762cc6241a96d1a67cdfff3af08150eb59bbc2584f028dc6aee6f5e572f5d46c8c87d3a0072bae72fb50d3c3da4e74492cd64ac737fb555339ea0b31e0245de67ca6f9c946494a64f9e1f70616723d9bf966df9c9fcfd58a8fb54f7c195b79f24f0f71bc60584979f61066b34aaa98b13d4336ee8f362c01c413d80f9140031619c17ce8fab01d1b3db4b41f9a93bb3fe57a11bedac9b2df7e0acd35f1e73da46179e3a2d962aaa7e62b0ab5d4a8b45c15f2a133e031908b072161b5ecf4d1c9e47ff9a718b0139426df3b0ceece2771039cfee25c333957d4b44b9492815a914d0fadc1a5069501ee491d8a142a6ecfd89dd288e6c09af6d6019249a9d0264ff03e3dd226bcbb11549d5a3f1b5b2a1dc49140df416442c226b67a7cbaee490d660f57952c600c32d0c82b60ec0e260ffce088f350f27f27e84b9a954606848c83aca84eee5379bdaa976189a840007a91746e34cc3540ec5fa0a2bfe56fd9de9ba5a6c1f7bf0c338d55c77af92bfaf45fd96e2b7dfad338a19bbd6427b80e1078c97097c1113dc3891b8a0030ccd994aa3f651e397ab1612c52f740b7d97b136af5cc389ad4346bac2248178611424c6ec5ac5bfe483ebca12670ed77b56e44f8fa4a231a372320d1050f62ae49b1c5fcdeaea59d2d61b4dab7b8a7bdba6e29a5d1e965fa3fb40c776840bae6af90cc641e5a61337b2c31e0feb992fb88d8e401703a3f6064be96c4f08306b22e33bca57b2985e6c78dc07071a6030164f626a98a587a4a9924f964d04e10080b8012c6c3b6add9336fd0e0ad001d38cac81213592fe8fecd15c7a50577067a862ba57ec2b6bde15af9a630f3cd0eaabb81f8ea48deb2ef14ab47d36523ff9e81dbe3ae6d35656da83f93df0422012e71a5b1a14b45e6af9265584c2040e54836f7ed7a0c8c9e50cb859cd7ee150e9f620f61f4853d4e41a0efd9639b5b1b4de69a68db633925fd67711486fd551011f0f7bb4d37f224a964eafb0c5d973e78075b86f9c7489ef471296798cd1a9c5bb8263190caf0b9c62bfe794122aeb5ad657118bf3570e1c37a2546219c6ba578d9711832d7e0dfcbb95b2d14c95a63599803992a517d806f98dc515c25857c6250a82e008a69049c9cd219a3d0ce10219ebbd498b6f27b0ba2b9532f03c5dd85f5c2afbbbd4b45f12eab5293b8309525805d3cfd8c5348645fad4d57f26f29ccae9f9e92c9d216b8e5f95f3fe16106d48045c85132cdd7f15b0b8799b21ebd1bfa2e4802855572047efa17f2bc33ff768f52c22793dbc1b2283e492fb170df4fa694a3138a0d93ebf2a84a95f465772bd25859ad717a06adc0c329b12f97c42c0b2bfdd786560776d1aa6bae04eda12bc2866d3a4fff64662d699e8949b08fa0fc5e9b185550e426c7a8ede5324cc3dc2bc6843813372a3f0ba97ee4b5bf39c0b69716bf678dd94e76948e1783985de3f707ec829d527c1ba1d1958e405c455ef1d5f9c92b201c5e098cfd40d648db10170c7da35905f82f78703d1f25f1c04ef977138e86b56624ddf3a4d65b5d26b441e232213e09f9d5e4bfdb7e76d34b7c17cb72acbf524edb970db3c172eda23e68bdeed7d1782669073d59f2358cdd77b2cd1bed2cf1f9480373908d30d51727962c9483cca326ee597a433a84359fa1c5e65530c8837d5bb36dcc2a2c1a4a5bf7500d338479af66f0e27d39d22819fbd8db3154324f719191afc898fe9b8d5e6de9f3b930cf1959d4cca6d09d1bce5a639e095ef4af2a01900b3b6e80433925ede84a1776f1a048cd27e58c8994f0e6dd8b860b7cf684e572cc8a3f614d3866d1e1936c8acca0fbce6354eb6f9cc30501251a982fb8dc4965b822e29eb3c3ae3b6815359313fe108349318c52c327f6043ca6622a60074613bd8ad75d40dd83d4c6d474db20c60e66b2e0961bf9a97f8af1b06114b28fabfbbf238de7622373feff61b1cd43ef1fc9f1b79c4a751030fcd8d9176eb97e164e2c53d5b4082bf8827dd83d5768d6295f37f0b2918c96185385581d4089f47f6417e6e89defb83b8e28ff521e2e2cd460166eb71e739f63ee03eae214b7b7a5a4ac24d1926d625e05ef19e0ceb96ea4ab201c337005706f82337371dc0d8c1ddafe0cfce1af92b6595a48e1a86bbe15371fe102771f02553aad1077868105a819b32bdbb3b29bc628288c2dfbb19ef4148b4357925538f4c44405a5cd28eca930af23f4db007a679792aceeed94dff45acecce0ea239e4762a60aaa82cd34d141a67221021e0c78a2162430ae7133b079d81f44338a7592c6a6eecb6d4804419763628e19f43a35bbe79bc432a9de60d461526f201ad6b77f039b7f5ac04957102f721701e2ecd6976cdf2dfa30a4bafa1475bebd56bd64a4f1e3bfc8808a69d19b7b1980613c5a444763583d3b53774c3c6908ac177a39df22f8a6381ab678638fe4b1ae9bd77dc493f9b868b8c1d41818cd6e59774e6e12d1c61b8ab1d35f95db693f3118794738f05f66ff377747112fbf7714b2ce07a033046409dbb6fdc04a0bfb79a6f2670637eeeceeb3fa29b45164e930f2a43fea07db31a71a39424e9adb0f9a059ca0148e5a3fe5ffb203d9b390f72ce66db2ce710044e47bddbcf59a8ad695d1b57312b66f527c2ca829b2701ab285f7ec009b1a9c6ef3fd14e505dde84b8546ec4b0e1eaaf4b58a06d666e6a261f246a856f2ba96f9e5254a4f011ccd2e29df692ed9af9b7deca02863d42e061aeae2537c117a8e9f7b3e33ffc9c3b74da65a4d5c097e8c83bf24a8e1313966b5a15bcae6b6adf8adaaba0423e641dbe4bfd7ea2ad06901f93622a122749a09970ba38dd9c9bf0a9268e20061bc1ec814efe37f96d1050f37f10d149306c82aa2e5cb9b05f83cbae7489214135aa17a3fd333035ca86bc6d60783ffeffdf235e11f939f2533a36c31b224097957192ba8b832345381a94d4d7cb80ab25e76b0981ae89333ba9c7dcf56cd97ca37494f64c726be1bde5ec83255c12c0cc4ba42c2e56ba00df987eb8d280fd8214d4019cf4d9d4788e405ec9992f7c6c361b0309a80c19b7676f9b41a03f151c51d8db31256163a8eaade7f691100427a69df50ee19f6d77008cc3515307d512b4ed4ecec809e5792dc99e762bdb296ec3545c5db8be1e62a1f3ba0daa6cf4d56eabb10fb378da919dd09cbacc22d5492821246276d1128a9855cfa69caf0582a467a50f7074f2f4c2739d25294caa5c1840cb40a394dfc0f5989aafed91945704585a13982a27024364ec59d3b0c6b4e9fb8e0a40f7b4a6620bf583b021238804c8b219829ec1bc348eda08c4329cea69fd269bcd93a9b47c3e5ed8f82ceb7102607379b058c67ad29eb18a0264bc54ae62efc2a1588e07f95e0ab117baafc544a38884de287e00528ac813a773707f0fcbe38060278de1aa35c038d7c1bd6c5c4302024b6b23b51279f844bf5c08de5edf4bdddbb0f2559cef93cee06327ca74e22aea546803d94401bec3fd663120ab94f729edefaa325d6e2b27555327b5ce4e36e192e61c419455c5cc7181f3a73b0a7211b698436dfcba514e20b70f34295343d49ab9848d6d4d4651bf38ce39f068961820104d0c9180a4f29ac0091001c562914cd0212b91563556e1d512e88cf32952b2c055510330457bfac21cbc768bc379a8a565ea4a90c3f3c33f7d1aba2ebe57b6a18fd2066268f2d3c1f059443fc117c3ad3d1110e10f459b9947085a529290430d2203cccce34d4ac113e0cd84708b40c2e1f78e99f82c5da5a1a0c365728f519d55b7fe57b4fd7c9e91fd0a26691d8d735895c7c287b9cf5b4470143737ddff46c89bc0fc4183c6d0bb6e9ff9f6904d60983bd140af7d546be7121571b715826ed015cc31044353c88ba5bbe9ee659eddc74ff315533113ec236b5c0b9eed1eb647fbdf420ebc6d478b56f9f81d84f103038d07dfd17d88b884adb7d5b27c50c3cb98068b3d5600e16e76be0b1d18780e9856487da5cf99c66b0abf8368b681f6f280e0be6e57b2625a7fe10927d56ef092a6191769198f6e04c22ad775d9e7fb49635bb6beb51447367a1954b6e56532c24eb31df19512cf2c8fc5089a1502df30aac63746366e5353df3d1b53f6033e6c3042db3d0af78ffce4ea5fe6607b6568f1f69af5d80c00bf1e157c00271269f6df9c2bafa8a150fd6a42c4575efd08f7efcf899170a93ece7c076bcf732d1c0a96aef2f617a4d3d7615b1f0cb435e8c654ed94b0c5f79efe89ed158128b95b959bdb3267cb20a981a25e0df95b4aa065bad77c06e70bf1cdd875fb70ababc759c1db45fd78ea8a8aec94c8e1924c2bc5e6aca8b9f5b07250b54ba94c3405f2fdc4415677cf21980878f6e2ff0952cb919d4d15d9da9881e8df7dc1e1c121c4b26f5859dd4e1eee9ffb298753fa80267bcb0ec2f25be5c1b94df0fd18ea75b5b2d7a4f09029d395bedb54ac26e18347704034b97b8b7092eff739502899230a09403a6a77012110b38218ec1cf5fe80f266def35e58952b59873efc0e87a9fc026ae47f3791b7e260ba70a38904e872f548c3c5d7339112b58f2d72b0e7ca5780cb5a7663de930e514d5e2757632aba8ca5eaea9af58c004472d2f27585787c00b8654dac23b0cc8130128e5801e3106a705ec681c4ef46d0a6f0a47518d15ececa20afa8b81a80fe174a65124613cf6beeeb96055809ac5d00d19a549746b7483f605bb65db3f3e50c9487836e38af3cd9399929aa353dfd127b111cfe5dfdd720891e1d6d07c29a282bde359a4d6aa3b82c61dc1d2aa00720a0835783694e5d3a14440f8c4b8fb2194d6d3eb3017ed5055352a9f8f2e2638cd6f8a3462d9053b6e404850e42194141ed80789af12e787cf1cc235dceafcbea4ce5639c7e2c41dce241d78a2b49cea5998283bb164cf1eda6d1f990c00d8bbbb487ffc55ce64f0e45610515801b4212df3d69482dc9b3cea8547a22b9c0b3b4603d4d7b8eb4399cc3413735edcdef9bba8923faffa304237b4eb716193308f55eae02627ef763f37edfee4737a7082319d7b288eebb76471654e295e8e9a37e18e187072280898a310a39e746fdf0daf65720219764cca5be58a431186c00172fca96bc8219d052b2a69f83d8b972f02955a61ea4da5e4a80b6e276a7f3e0dcfdd411132be13870624786496425d96fe8d397d9f438a55f81a49f7dc0424b79555e244b453b986d9bdc6a1a4c2bcc0e0b957c9cf7bbf7ed9aa5d9b629169ad53d36d697187efb84c4c980548439a757153066ba80b337f7e853767709b430772286e6adbf50f5a7fff72cd0798bfdc1e8c070ddbcb1dbccdb764b0f7c4f4aedb160fd2d9ab7f9ba8f8de973ad78332090a248d910c2b0e5bb6a2798fd7fd0de425d1d3f3782abbf15e237e831c55401558ab7dd7a26d6001bc0c5ddbbea211ccb08b8f6b9e2b8b7de35a49b07a14399b5fd865bc905d57bfffe5f50fed8efb0ff9e23c6d5df0b088d28c70fde99ba0a331dac02a265fb117f6eb53214a12780f48709d7cf16a36d4bbf637192ae63c09d9c28209aea98115bead07a0996bfc097fb9fa34ff54e0b5160c640da36786af02888b6391ca033044cdb4f00ef1dc7b6cb435c9864c3d7f7210278b0a5514ac769415a7dda7c5e7aa4907d901488296429243c3cf376770415548aae9e5067f836bd72cdc5cf6b667cae9a8b5f44cedfb329f8843f3537afd55727608bf3776b6c4df61c563133d6ee435fe78bf005f41b2ebd77728aaa34d7fe7589d09986c8ea79d9eb7fae1524f471ef8e9ca42507d651672a75b2ec642ce5fa43f541ee7678d6a7b6f8c917efdb05776e06b4897aa68a2c78029c5cace6d5eebbe07413427cf6fe74d939aa4cb3194fba7a4ac00b61f48a612dc4e7a024e3038d3e91610d893b8c03dc12285a252ba70a692031aae31ce97d7c6048def808ccd0a13a0d8930ae143cac32c7530b476346ff9ce4936b20ca6f39fe93dd3b9239eaf863585707768752f1bd9db62f6cd56e685aaaf6dd3ece217215b526d004a1c2c3c1cee9d87b4fae79b4bc5827b8850b209430b3f771257559ec844315b29e213bcba4957cc5e707110bc6375358e94272b5ad8287000991a238184d89bfd716dd4fe25bac29608f1d19c5dc4ff9cd02a6731ff4b91f36b8a36dd081b60291848199ddd1e384b986ca996cf40fff738f14a3427cc8496f0ae24b493536b54443fcf1fb32262b5a6e03cc0734032ec56cf128cdb56ca677b921b68bb409e57184f98cca0e8cf92bf91b806fa6bd6e5467b8cc3d577f8f8baccd6dfcc15bdc039568051782902d6eb757b9629fe1c3fc6d2cbec02df9bce39f794fae42b85b30f1da7a176d06ad6c804b918ae4ba60ed72f4012c6407ed5b0f3492dffee0b8e7d90e71b6102a4bf6bcd46a75f779c45450d798eaadc01e7ffe539495623aa5512bb82c29476999dae430d7971bc99273c54069a1557a1586834cd24e0f5c7feac3c51cb5398827e9a02be0c8ccaace0c80b5d9dbc5026936c71ec3e21ff95358ebde969e27bf726e46da6f82570a132469f8ae1f7ef76dec225351f4c1e794ec64db725768807c4dd2df78ec18e432095e86b5c9b5c4f6dd1d417910c53c622ff4dd535bfc7fef20d67d15222292e07a6486be49c2ef2d77ff8669dd448cf992258700fe88c53bc94df9579196daa69b995774002ccc426025428deee5cc215dcaa65635f46e5d89f092cefbd1fe127376b7790353f560048b05a3a0bd7799aab99364f4147f0c6beff23553d698978d30d3ddde9c98b6b1207456b16254a3312274efdc7f302897b03dfb19fb483e30cde5b1b926b1f1202faa9fd0b78f4f74a46b8fdcdee30bb1302bfa8c8d6113c9178af2dacec11efd3eab5d9accce5ec9e215af26d2b9c909febf20847652810d543defa5c56b356bf219eb16b5604010f990936db737d238ccaf5f79563e779fa1af0a46db735890d88e4ef635b879814e985264e25abd76fdde189754318434e24284827ba7048881ba7b19f1be559243f7ebbdb6f72344a402e9f2789644460399582db914872d31a39181604a3d9a3369a032d7fc291081b9f758fd880aa3f41bffc8627dfe6e12c31573605345430b0c7130ae166b97a86fe422f86ecb60c76a8a487dcd7d5d68e7f51d4f492ef47f4263cd05ba7cba4c3d62afe4c265463cee05a97125b816d460ea3a42b07678583cb377f9941ae03e5835c78338570e388fb26c8ccc394a13e9b7e4bd929e87a447423e2308eaa8bf5fd61b66c3a9a3b68631d64bf7cb6b8fbb20b1d78fd77b4b0b2854c4e2a891a0789b9b020f0101bc998fdcfe650ac8663889b4160283aaa415cf2413653252d4d95e8aeeadea5b50b3f3967ce4903f30807f4652ad7659feb2adfe53b41df4765bf73b454dfdf8cb57318d51ee4ee9343ae678063db3befd41bef024b70dc0cd4545a8c83f1f071adc991637aba2141e46fc6375f47b7c39d5b8084123affb1e87befbb7000ce8abdee29cd46b94d924bced46743eccb2a165514bf46539511e1c353fa12e092ecd8dc50768863e4e0028241ef92a7a4f97372b607ce9f3d6eb413f762c2c145feeeab718d452e49ad2a391689e499631f95456784db04443fbcacd5b9079afb1c722c5cb005e37e7826a0dfeefc0dc68c8f0e66d4a7187104904032fb8c72ad9fbc9127c38d2446d087270ea8d1717881037fdb7267c92de163ee8ced80af3d0596aa1a78679de848d817b25e6a441049f856207dfca91612b0dbfb88c7ae1ffca45d374dec7544f13f9aa4234e0099e3f18889cb5cfe3351551044f97cd5666203ba3d4f63d600d8516b12ff92748f7030849bf60ed7fc4fb14600165213db632c6bc131d58e0798c31178b7c95001073d274d9b90652f513453d59e56e8f3e32b3eccdbb2db4c870cdf879f14a0fd07830953f7243d26f4c9a2cdb295c84f823c92aecdd634775be99a4b2378d6c3ff5589b6bf2fcadd116dc92ef9b80311cabcb3ba7b9870de7d1381cd5cdf055304f6f60553aa3ff5608146dfa8943d3708ecc141615e9fa5af57371879b02086c30d911379bc96abef143345932016ecbbb8b13f7228fab328ccc40d5683ec1a32cb73440b705ed209a57688d368f507b391b59b5aa8144557346384c081063535278188c0c881cea480d5e6a158c696871c9a5524cdd9a0d36487bb0f7d2ee142f4b1535f3ef5d33510210016596fa7c8f57ca894048989f106d5cff1d5cfb0d5e34274075d5a21f316bb25c8cde7782d499b135770b76d33d83f2586daa119d7ffff8f4f0ef7c7c97cbb46ff2dbb1cf6333d4860562e54f46db302794f592607fc8c664a40289f03c5ea130f7f74a3f1821b5d9009c7efd8eff4a50836b582e7a1cf49e3dbc2f0e0fa8634454ebc827b634774df37e00544809e1149e5aa853dc77f6e8f4c062ce55c84ec34c35fc846e4983b2a93ef18082a855d2221fe3f9cc5ca6b62b128449ce816ef7402e2d200bc9a449f51cd1c2dc972e7aae5b71cf0789247b5a47f941cb3d9bd79e6b6b9ddd19f8bc65bcb1b6407f316f6603f0dc43ce19abb6df4314f5584c551dcef0a53f42906c63122a63c2110ee98bb8c3d533376cf6e228c1fe2f1a2971159f785cd8028bb0c6427bbe487b1b25f5e61a45dba9f99616515fc7c268470650dc672b5d3c0ba9e93d3ae4c12b3f4c362b0d68178155e37d482fb6f197a72788bc8234de020a9026e4bbd9c987e996e9a210e83bd47aff465e8dac97f2936ce7fecb9e5cd66c4352bec5bdecdc01716b3cf38497cfbf254f3ed6aa27410390abb145234b949a6f6eecba8caea2b2415b1f6116084c72a423918d6fb6560f50fac58ad415b6be27fefe30e35df012b4826cd0cf63480912bc452fb0ee94bbcb65822f705a4b541001192ed5fc975ab6767b1ff703d3632e8db0495fe4e972330bf5d3ebc678d2bbcce28938fbe2f8c484f779a2ac5293036dd2114d86d7e081cb89a3894a63356588d045633e435a4b9e75a19f2c723e538806a9072c3940d324ecf29717cbe858f5ab7d184a0bae29683c2d2689a1880222603cbe730d3b356eb49cab48d35b8f23b4ad2e886b902c3aa12ce86053db20c2698246d2895971a45146ea5cd431d46e23ac55abebddc6427bdfa40839b5ec97aed80e89f745c690373c11bd0bf49aa8ff2f6c188f93c451a83fbb6ca9d7d51060067f38cd99fad85ad34e98524a183dc970e10e3b0165de05978e698509ea4eea364ffe29ea55bc3f0fbefdbbd8e4115a7142e0eef8451413664a6e12ee95f3210df468c6ef383aa36801e40db9ecd68113733ef54ec295439871613acdb102235cb33b16017d43904b86e4105f00c9614220e20ee90b96ffa83e897afdef2664767ccd4395dbe2ffadf273fbf0ec1a8c75456f050c6bf1f723b778a152a692cd8dcd1ac1d5c30f5c1d2c6f52fa4596c47a73c8bd62e3687269850f8094ddf886925cec9cc3471774b0cca806c0f0f4810cbbeee340469ba59e1ca93ab929e8cbbc1d29f779bfeccf4f4924a4b8eb04a93186fe71a3dbd7f946087dfa0bf34f8b5aefc49b2f7a1db615bf1814a6fbd2e37437ec5805cf3a6af2658813a54662378a7732d8637f723233934e0f7194be60d67ee75c3d53ce66656a184976588acf5361abbe22d0067df6d84fcbf906a0de6ede6e8f542704e5f3e303bf1fccfe18c03c8078125feb99a7050adbcfc1f4b4dcd330dccd73531914baed6bf10e4f7c1ca30b463d0ebe1c1a73191c2de9a0e09be20704737b4a09918a31f9ff74819f0689a6c08af78fecd8e79b571fdf5ff0f4c515dc9ec1877473d9f920645c9b818e47ef82b295f4a7708934f1222626b012ef83e7554e337a99c391cc980064e029234e8bca899f18e1339c9df7d90d3c7d050388aecb5096c54d03abbe3e5b5005e1e6f10bb626e0e71dfbdd3b83ad56772d861969b6c2040565f4958685b02b8eaa74bb1605d813cb0503cfbaf8f94dc0da06cd672aa2aee71a67c5ca466fdb5309f4f9b790e7a3b074a08fe3a5e73029ab2b3d888ecd4e2ada8edea10ae9e9f9182fe3e1e9047e0857845f3ee319302a1aaacf125ac93955ac2c13723df352c672f4ffe3281c1ab806558c08d5f0cf07c6c3d356f9adbe2dd409685501422d34f68d116141af7771484ccd45cb2f0c1bbb604d805975bcc2150b9d158374fd272987adf6266fc750608e740ea1b0d74a5eab428ce3009ecf97b61e0a06153f8c84b421dfe1ff4af63548ea46dfb57bcef17daa4cd53ed73e42f163c3d8557479cd9ab08f4cf7741cd4d51a90fc50aec70121550838987d3d545d7b2abc39f4c836339940928f330671026c65ae8c43a679e4b0585115ef8b3c838a7b3112c33b67d3adb38d54ccfc91d0b8f043c0fec918b68a32b9f75cbe1186050955ac48db1afa0fe6b944f4a76b358c3309dc7d9dcdb58de90d4451b48d40d444e8da96bc07f4319445b6c09df7ab419eba835c24e26f28d83d2005a8e4c33c5b52c9d37e700cb7ff2592cc6aac0f657d7e04d92db46edfbb1985ef71e810e8c3acb2547666276fc1208637abe32a3e8340fb9fd80ee552daed6fa37aa3dab5eacee32093a7f530f4456b5c18d4cf66fb15540f38b67d9600d6ab98379103fd4ea0b76b736a1a9a12d567faa9bf8b2c50ba9d396b86cecf8a827de22da0f34e5676f9f57996ce5fd792e4352c8a1f934615ee76c7f3f36e9f97c225b5bbeb9eb93d569c3360551afbfee78223885eee381c3b047914dfea63efa7fa2db2ca491a69d4bf5b8b56218058054600b1a9a13f3d08ab7ed87e160c4bc06642c283ae2c68fb6ae1ac87a1082af232b9314ea0b483d33efb0ab5da4c3e82173299ae87abbe45e892fe2b4a64e3696a19f7516e18449f3f5bf00af4e7af92163b2966525451d657c42865916c7b8209ee2d355cf768e28224770c9536ec1bc50d67b777b601cc4f5a9d4dbeaaf814158e011b125702857ffc22643818c847c9be9dd3b01c53d509e0d3d7b7bd1dfe6d78903540f9d9381a8b4991e6e90d44b3335eb926af0b9443478bf23ba4cbbd48db7caaab37c3802420110e08e378d8f365a6f5d8d886f29d16ce2c0b39d6d49968b1492bcd6dec4618a392fdea0c6be846087f784142fa82dfcf08a361a019d064319ad152e60989f133c22ce52633254bace0d975d52062ced18b6990dc2e76b7b9c7215d302f2bc0ffba3398042d579459daf5e3a3dae845d6bf85648326a8436ed281f5807673a40c9b2643bce29b3af0fadb3110350806ee42314b0937b393a4690315f07436a9c4e2e38f9f52c933423199900235c756725351b39392ab627b4c2f83edaedaaf9466df9a54d3a0273570f212758541bac10e57c16ef2147b5b9bdbe03f498afde663c7d2ee9711d82ec091026cfd50b92445a51ec65aa401baf4678d95b3dd030cf0014b2c3ca61909cea9838925d9e0a81a3cdc252df435665bf59780124026e86dbf12ad4fb70f3c6e9f3f9c9fb3e03b0faa5feb8429808f3e572fbe991dd2b0788a0a6d86339a74e14f0cf48ca3b2d9352ba39144ac73762b5934827711c985a8211444421db1d023c9a7fbe3a3e1c446a2f6ab980cffa6e69f50693b76d38fddb2360ec2ddf1353a685370b76391c2f93600708e51c7174749fd70af5be3cad7c5014356985fa9cc740cd1d49e9be40e8ac0a7c3657779907fd5f99c4f6558cdd93f94ff54dfb65cb2cc301f7d4e676fbe9d36391489b26f6be44568bf157f29c1ccd843add34a6895b85d17681c3fa5b898fc5b1a4e9c1c25347cc02de74c07f794164f7db41818741308fa2431ec26dad4c07acbe5be908d89226fe36f64d4a3bcf1512fb13f497a5c176f11611e132b54e6bcb4b63385d0742cd209f2851d90b7d61269311ad0ba4dc9429b826af5c05234d7e8993330997351bb2d20b418c2924591dff5fbf3fe3d25d7e0c2b964776f470a5ca1e28e300ecf357195b987ab829d491e1fbee837ee8036cf69ee2613b82d40b2f2a27705e3b2afbdd7e45a05e033a0901ed9b827648f422db7d561e6a675f044231e351f97691ac7830722c6aeff8c94c54a5c843fea0fe1f1f9f8ef09136942f8eaf7031c4d2a68113e9830b7f11715a8dac0fa7d5e244d3a4f0cc43f12e84e9587fddf168e3153ea4187fb7e3afe48a0c21d8b2d672deb28e18c1e752c2c5bbf4096244868b2f6eedbac91348b8e7d37b53dc62d12685b27cc40cab5c0ad93c1e5f3a9e05728c95a0b915ebf47908afe4f0513fc7fdc49ad7f464be3c7c4bd8c60244ddd9105e1886b2e9057de7c1094502f945fa1be8af7e6554511df3d60e69d3b248f6e7011b3d15d0671bf50480fe174684e7f8610dc4b246d4159ec0c776caf8d8cf9a34f0a499a1f0b74ec2caaa32bbcda03cc3fc0d5a37a3a96db775d825fdee69be5d555fb3ea5a9c219c9ea0a908d57f3229d0947199dea8c17adbb4cbd59c61844746dd8b33872f1be65ff9a9f3b8e8141f44a6937a8848c5307d3fe45f6bd7010dccb1703fd83fe56077925e8b3d582cfb8b30e27838eb3ede178da9c100827b5b5501d06a0bd963abf56fbafaa81faf1233fd410c366935593c3e368e962b3242d10821b5b44f1b9d5080f633b8823f1815833de56dfe741b07d2249e75bf4723f24803e876dcff85734f835211c18c0c40a5602d15dc94f0c7d417d53c1715687c3a0535902c483615ba29f60511fe49be1cbe1ff16094a608798fb71bbe302a467607ec80bc055283610ca0ddf51be14b952c7fa67eb05aefe631f7d2f1e0ad67f3c8e50a561538e374eadbb36d3489f0c8e0c108a53073bbc9a8bc9536e3bd57372ef75388891a5f20fa2883fc8f06cbbb993d0a809597ac1496c722801e2f5923107f9ce1f5000f5a238f0539cb6eb6449b781a3f9e265e75216604f4e8d3b6b03e4a300c807df2368414719033184a265898f5b88253b80313a30babea269c32b504ab21a159ef8e5150cf27faf109485c62b23422041ca805d303ff7698af23d41aadf8bcfc7f996de6e7d9a51b8c568aeb374615802da75be9d91097226d662aaef3e815592f5f1aec3d74a1580747d808f8aec96fb814a26a720fdd011c3ea2b3f2b69368de8fe44a1d9f866cfc82a8ad9fca3b45b0a7e11480f404f689855b8a8bc5a3870882ef5b46ff57716384777b3fb806c48b9cc9e335e142456dd5767de48b97d28077881e49fd1943d4e1534edb9da405349df81776dc621d87c598d93653547014c7fc01d89a9b0f710e7b6c07104ab3d7caab905996b553361f81915bafbcf1d59e167b77ed230de018d3fa994f1044a2976afefc6487c626aceb5eab121a99573e52ded2032020ef03b8c3db731665913b0da522de73a30bbe1e3d0e8badc885bd320c91b48e5afdf849ccffc5584608b50a0c55a73ec66f444bacaaa004318f54d23f30c852da0128d7e89de0e04c2c517a2a2195346104ea519ed1a8a006a66bb3f4a3f390fa16888e10cdd42aec1c20590c19b266ca4e14c9e5dac381233f8c1d6e24a3b691ccba6e3737f0990a38e733cf4d6d5a6336272abf38799c151bcc4cced006a253fc9f14f4a7cf30402eb7c019a8ac3980baf5644b0727e6cf148e6ea2e3136f420afa59261f9a3ab38c23c493135261060ba72ad19a0aae5e3a907137c76204317ebf63870254481625598f92f8c789fa4328ced9fba630d98b813ca9cb32e335fa8e60a0fca3a9420266725f80a1fc85abe9c0bf9151ddc71bba6a9ebc3c9ce9c0110f783de39d90e85a9e882b62d15e74aaecf229d116398e440d05d75a2deeac59e32afd6cdaff8091aaa4109de05936de62f1b26ffac6498d76ab31a65d970002907129f58ed3b4d8e2b290fbf5fe0f85295767321b35e6b20808a1ad4d94a865f7d6e0d0b691f6a78727d146897823db2ce69e053679d3833d755add9f38438f6b3a102597c17b1405167d215d1b76d5162e849575a4971fa6a0101b8bd56445ea6dd3082f3abc078df46e1fa2b9021e62d08908139b791841c183aeed81ee8a179713fb2e2f46b26a8b451df653842454615b27cc4943e0253069d68e1d3a39ae972fa364fa4d21e1bfec64541e19ec491dae9f48df8685c878daab91f4df39a65e8a680a42bd5b8a8133c72c1e77ddcd58c0a1db376cdce34ed60c4c62df329c72a242fddd222b3ccb5608229e6d583d34cf3654e3b3d252813616de4fa3a4668fb99fdcaacc333afb8964ed94cde5231644ba5717aa87bc023a42226a607678ecca232fb56167058624d78ce81a06ff8578b788b2e538176d779d95dbd93ecbd2ccdb399fd0d7445add7c703769b93172cebe63765a69c61c7a63008559d5e6f38497cefbe19466d797233c070d7e77c142cc10c5c2f19f5c5550caf3e58d4e998e7509d32cb781499173a7b81a51d94ed98053f33f126d51ac8f9690abaca91124f1cee076dbb4fd2812f9fd1bde62c4e20f3412ccae0b7f2ced027ae5408cb68471f8bd917aab9ab69aeb0609373e317ccaec2eeae23b7b333b75556bed5f6d7906cb031ecc1ea3cbb5c03b74fc5ac7d8e5b35bfa34903d08309d4e9692d2372fc245333d80c897ac708ac1bcf6dce18dfc6a5160958047f2edbeb299ac95b5db8819b1a8692ae3326ffb97784f981a2173239652585ac57337d6708afc0fe8cd6caef4689992c0c1f48588380b94bb786082dbc53462012de045dcd83c30f441f549b3433ab946044b62c81e08784ad0d0c1acab969dfa309d0b22c2fa4d282a3d4659bfc8398d700461e5afa52c727f357d47f16b058fa6b46ea677d6ca7d456add9b0806d9f1c6f4f1fa2d3bb6c9ad8814ccf371d3d16b79bd77c8c86762c43ae49df2bcfb447e43ada6dcd2f64e2718e4db9ce34744af75e3a88e13f3c0cdb0098f57235218243eb7a6651f484ef7410c90ebc716345d1e03446b1fe4495cdd6031196d10f4a5d5e78c496a6cf78ccf2492a7738c23500fa343bcd225864e3c89dc80313f6328cf21562f39a424e229d46a83f71c68c365c026638fa1af88977085eeefba3fc99415601d9c193ce4fe0476a2979ebe1be836ce371b7283ddc4438096021b4a1022de913152c3e89475ab9100d0d14787c1ffa666def52826e1c89a99311d7f5d8c83479cf707091605ad56a728fd368b2063cf69e84441f98730c4a1ad91ad957a4dc0fd765e767882e8d41270351fdbef3e4d6f43491e902a4f785c22372d20745d1f5508120980e30bb25e005f9e7eea4e0944041f6b947e528c2a08f8492f75f6a221f13c1835d941b4b9cf4aebca864324f47c85cf5a5f41a2fef5705457226f9b0b457a921ad02fe92980f8a06ee73d55f60a026d5eb42c2a3b5d2797164165cde96a21c1b77243425875557fc212b5fa1f779a28f0ad665f72a1b7ada759d88931935b6f2075a516b1e919382392f3533c2601e1aaf6e3124dd2ea3c8541cbdeaff4516c963b3a12f9da831ef06a11add25b5813c83621978b71377fe8bcdab0412a1a486696a9eb323d3adbce110afed2db1e8936affcd43c555a5ceda0eb7b3203204ca9d4e132b18b7603f89a7e34b0be207fd46f8bc38955f2f6a6a21922943b59d12ddc487ca827f21ecbd306e4eac4c53dc5903e83221e6bdb71a76ebfa177fc4375d826c0a620c09ec024481675854c65135e86f497c7929c3cc793c00e56b53efea83878559e3699bc33b0d1edd73a590634dabe5f1927ef8ae685db69e4c8040e538a0cc7bca08267d9dce018df3bb927e52f6c2749750232e21ffe39513ba34755198d1c8b3a18eb126ea28b56a2ee5acb6f7b05f37974b7db009e9ebadbc2770f836537d6baa0150b02b04520882974db2c764663891d91a2db801dd6cf9871c910e7f8fa1e0b60da9aade81eb5646dac4d68ea5a62313bef97c74e76ca30c08f2fb058578696ca47b95e4a0f7babe81471b9188d9e81b10be880eb1bf9739f3399b16d0c5c1900834478792e196eed6b4a8911886bb824e883c11dd831926d5d01bed5416e35b9186e01ac266d7ef6f27c398f6fd44ced6481b22be89633c565aaceec3a8db1ef690856cdb5dd3eabae56ef0256ef0bf0cf54186ec8174665949f6574bc7507fb7c7c993c580fc43de180835edef64d8d8f8ea2362b9bd2807457e9773bb8b7c7c6200068c548a97b2946d96f689f7d2c0ec4fa29e8c703dd87ca5e3e31b567b7168a19b492a5ff502e204746d0fe7a00933dde96728be37002fdd47c12699ea2701c3b1fed81a448cb4d0cf7f57a2a9cdf0b1796afec9d1f2c5155ea8d0abc215b6a47951146b5c3b0328d9a334d5786a92a4be22210ba552847f3d1698004ced183c3438064eecd6ed3dd32148274d7e3a0819b9960eaf22c33810f054a9b169b998dbff8acaa670dfc341cf5bb7cd97e505768e996a89f7ecd99a542c6bbdd0712fb4d0dcb45f2ffaafb51191a24406a2b704bcbe42accade5162c3dbae57abc83a34b5f04e1b2318ca50a17a9652debe6f2faba1ed439e0a4be0de0ff7334ce29d06e04d2aaed6eb5f6df01d07c53cac937a2299bd66066324bb7eea66961424fe3cba965baf243c3756e6a382c764072e3e44a6a0e42de1a2a65ff77c031cd04d09d2478d56a9f308402a88281e041fb6664003b94376d8632fd36ced495e1fb4f86dd92ea336c723af113a7cad470dffae7eba36ea3429763a7c6460fc65731e3cfb2fa453921d10f359db261b10b175a1d01d7a9b6aeb2ac2ee3cc8976d7a67dbda820645e346877b706cb726e61c5e86d2501cdd8dfdeae1f824e5ceae8f63303fa315ac54a0561b193c83c5cd526226e8ece976ef3c4cf2365d7e6a98a1fbf830cc246e989fb796e7791b7ac63d809767e9ee0c648cfefd700a0390135db2a1f93012b37132d48bbacf5661f9b4aa1e4b5c32b2c4eef8d2e6ad977233d6e3a8cb57b31d386456b6e2fb36a7fbefeed69e3c967a6a4e2cb6370b271c2e0977c4c771de617e84eba86e7cd50ea08a6019e04271cf3f52192e9e4c90cfd819feb3d5f36bc1d03bd973f45739222a17d3192faadd4d175bfae28c0fac7bc0ee4b4584dc74443ea490027bc0e462ca7b2676113e8bf13db5c1af5fbdae628724798e31fe731c9c67cffaedb7b28bc034200c48c53189c6eb4f34ad8e2ce1b24e8a4c41f61f006e1cfb04985a5a2f167312f54ee30bdc0d2665522a786f4ac4bfc3214bac8aef7206d59898f4333f57782054ea6b216eae46c4509d8643f5b3d33c9b8e1bb59f958ae6d68b3c9b85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
