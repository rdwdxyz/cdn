<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d06ee2d70897168597b65fd4d9a6599bda9496f3e25306aae001a351aaa986bd0525a9a88722cb8e942f1b7f6b98309ca0fb7fd5eb88362cb1f965935803f8261e411c251f3f0a52f343d3c1f44dcbf7db939f3fddb32eeb358019e1212510458f458ff22d8e425b5238c37592499a10675f80e8c71e8c856fecfc971a275a128b875f486d1fefe1d9615a4539573a5cb3e1759a09bffbdfb91c125387022b0661cc173d0974693fac23834b0c9b3b90225ed302bcb486b8ef5c77e0aabc1fddaf7cad7a1ecd55c8109bd2b4807a9646afd358696591ef3f275150873a7400a2ae4f15c7e973c033f301f476858c86adc896213036687db63d77c7fb1868ba82cb5e75a45cd2e49157b48c4944025b2f2ec361b778265aeb12b75a8f4a13b6f3a3dc5618734c7efce155a6ee8081db2b2b84f7cce39e6ffead58989a6b1497406cca6be472844e18ac8d457916620bc7410cbd22d2148346597f20149f6ef9c2e49cdb3f8045c7702fe4de0860cf1d8504f4623e2ff3a71ac8dec9fc65310c4c3fe6866987a8af1f4344845354b441fa9bcd2afc0ca682437aec8d0abe15b7ca4e22dcc5f1f530b1eb5b987054f07f5ac4e242ceea21767796f6916f495acd26b3c102d5d6c20b594423c370aefbdf4e8f7a532133e9ad277b9d29b96770a7ecd9fc01d3c00ebcdfa5f318eeb2afa8b4ab3bf39458b0af6fbd5dd804b601c99a2d04ca27f35cbbf4296046806ea75d6d5d19f6a24ed6aa7bcce9ffaa2c43f5dd10af5a5764b681d169a2ae6abe62d0ddfcbe1aff8cdc3ff74e8fd8ba97c19881e4be7e50d26afe7b142cf626823d634e191728c108e5b3f519395e47e14cdcc400f8847b39d2681ae8c596c44e1beacf4344211d6cb97bf6d55749697713a383ee1c19fdadc67a67ff4ea527560c3a6cc932ca97a39664f6be31db5268687a6f10c1dd2dbf539a9a2e70745305cef9883326860869550401997433b096399fc96db9f5515f03c1ef99f79f39dc3a557041d7b39caad5f1bee86a4d1bf95b0a4925be1e9572cad309ca8bf236f8b9fb5f003883fd90b03bd4b93c222faab0fcfc57d0b9b0f1d527b4d714ea7f31ab02a3e94d9a2a819f0a474e9597bcc43c1188f7435ac7d2f6536d5fac7e3f6a62e3d6865ed6ac8473b0786c00f7536c3f09a7613d16285f5686332903e2ea68a32b4547f68feac73c946570c18579858a51fd239bcdccd3371a6224234ca4db8c1f5fcb8580f404ed17bc12457f418b86db6c680a37dc7a2c8ba93fde38783964b2b6b877939607bb69b2f9582b0085e7486129af04c2ae3bfd632815809e97aa9856ddaee7c084ad65d8d8db66005ccf2dabbee26662026ed0cbfadb1bc0656b925308b4f437cfedf6a037f24c4176ef90e0bf458d1e6daa8280413f1633f994bd1649635b56f6832e6c2ce006b5553166b3c6da38553342af09b72f571acbe794722f62cc8a469079a1898700ef4f4886a69203540e280f5e15bf58250f203ffe9668744b45abc475ff7bf3a74135069a0bafa11d8525a8cea661c98f1228a8bbad94ad1802a68dddfe84755eb1bc31c99a5d85ce510df7303cbbc06a2601c454d33221a7614a86644bbba005bfae72d63d4b52c6417fe7f756801a40999b037d42d11883faeba8950a5d5f87dae3763ac4ff94b02b46c8914d6b96f769ccc014eaf8e5dd841170549bddb1a0fe16dbcd9696f86fc7a14eef55afdf0da7d37e78cd561381594d5829049f1c214f8e051355abe786c2add646b820ab1294a31b28b2c83ae638e652788754a7f143a7c47219135e2ea6a94b09b26bdc4907d04dfbe422bd260ef62c218735f1eb426d0c78b45827957862106bcad2a30df73c912cab28664ef3582cd2301e4a60cc45d601daae61d59f5854cee9c42b016fa4da28ea311ad2c4193fb51ed6e80cced02d52422956661ed2e9bba0f3273804cf28a1ca1dee2dd6e8975f07a65ede0e75155b8f93046282d992ecec2bb88d7f991ea70b1f1891ff4e8909028eaed4abbe3d67159abf58a4657ec31d57c156fcd474e5fde2690ee18d613e546a1ef7296eeda52a037438bf9e6595194631dd8bd467e4ee3925d26e6c7003af3a88d2346c46d7f7be9f1ae44751fe40806eb403dbdb8933d4d0fcd8cfb97aea168d67f2294e9fac8832c76f669b306e3348b9f41bd97f73f497b46015d06c6851e50192bee69f7c4f276610ef46c014fa372a5443af97e8717c0767e169b6f57e9f4f29851dbfe2507fd1e70819cee9b01e955110db879edc1ac6eea1f33af9bd57acd161627d820deb2c38ca5efa257609672006a11ed5bec2c837a035e49b800f924b2653398e187e21273b110fa4a40fe47b99b26f39ec60aed9bd5acb8e6be68491bb0fef90d83a8e7e1ce24b10d36a10a2a6185ece1292fd4740a54874b2896821473ed33c735b7f85dd7de9396ea1d46adadc2ef0d9476e307cd523940772dcbaae2b07c667a112be73455416fbe82848b5e8efad0a9f881f6f403d3de0b7c0fcdca9ac56ee9e35f96a3f085e2c0b25e4717cd0547de645e06f5db70c5a8974a893cdc784080c46d74e23be10d66c5cb10ce5fb6cdb29f92c3525ce97dae497b749c3cec4b94a31d0252ca979e683cef5bb4fbc6697eff736949a906805f2a948ea118721a2f26793d52c9e34f9bbff4fb2dd6e5c67d71a939f9ceda397bb8c85f13c31d12691e7326c90c60743de37bf08b44a70916b365ab2bcc3d6a776b990aa6171961720cfa5dbf1903ab99a6daae4305d8a681f650cb41d186376d3cc542054aa16224e8ec507d8eb923fec5caa263dbca2e82c9b258c574e5408e48e6b7a28de775e951114f2f2b81315008c40ce21501990b91206362f08858f71a6c18cfa1fc53a881d59e996691d0580faf66548e1fc95193e721cdf77abdf4626ba1e9451393b30e8bb2af5e297e7355a9e93ed96d9857c91575257cc6e7cf1ccb110726c9ac3073409db05b279bbddd616b67f61bf982b5583a3939bb25f60f809d0397888eddf9bc86eb975d70e2acae6b64c281761b070156a72f448c37fc2ffdcebf63cbd8f9af1e3cb7cc32037c24b5723f1b683d00a7392ada6602cf7940fe11f0edbe2fefbf67954dcbaa95f46419bd4f9616871ef376758fd3cbb5f697728f952f9f1d493c9cf00ab0c287c855634bb5c39108a96683b530d7211cfb4064fc1805e3cdc8920352ff63aa3f85b2adb819ee47b4fa6e10ec86cb18127690e59146d44c48457d31d672d2fff1eb35ec8697a241275ca59b34544eed244682b4ca9ea96f1083472025c5ce1635ef10a8bf86a65547c4b685ee0408ded90530f8be9975f2dc003fb989c8bfb501d9a07acf9cc72269134ecf0d713d1f25c2d5488b7245f8e1b49bf2878afa307610be3eb7d817b67146c3be4ec391539f294ed827d1abb27fa5a50b9ee5afa98d230b053a90f47f230b8054f062ec62212ebc9da686f96e76c8c921e1ca880be39dffd68ea45b9561a476f250aaf1123de69db8cbad054a21a7cfe4420ef769561db37e64eae3fb398b9f84e1454b11d32d0fbac5bd861fcc0b36bba19e5a44449ec3d0c0e87f766a865a1c0686dcaa939b4f73c4ea6aaa1ab7bdd4298b7b14668364188ea5cfb87fa390bf0e24c3f473ca85dfd3eb863781a234e77f8bf91ba39b20608b801f638d2f92dee3e1086a83eb702d41284100e9a43c7b141b54eda377c89070fde39accc833de200ea51c14ef5b57c67186995af6a8e88cbb168ad118307faf6538c3a5da93af1439785ae2b33e3f06b72df45f1e1b6deed9f1db9c364a0c1fefd31ef1e7bd556d1ea64ee32b5ed63edaf54a600869f03bf412e57138d5a637efcff7b9e952c91ff8cf02696892edf281385c8f0886d33201b4b3cbe4ac455e68f9446d436a783bf0f6fdbf55cc9d966f4754108c3055ced9c9f01175d120baf6e2e4c199ed318f56bc750613f0b0020917110bbb2e6f8b0b0f185cf9300e26b5cda9a73e51c2d4fb0e1bd48f19f0126d4a4e538320e10e36598be38ac3490337f8db5881be986e32fd6a9752ba2e0f6c9059d714edd2a27ec5c3a6dd387e7e334933bad03dc3a8ca27954c878ae0d3f1d322410d529a1f8abfe9c51d310ec897088fac2e9ad5552275aa0c2bd6b67b1e3bfbaace158d9f7a4bfc359a60370d763fd17ae66321882cfa9793d31bc8ec598dc75db267c5d8ea2fdff6fd8d0725dd385baf5bb3e99a19c369f854fc4fa6e7f3c78cfbb2a46a4150b360b541ca2216dcdcdafeaf10e345e0512cbf0dea2565626778792861ad3e1cceb8d626b27670d0b5db802a87ff5fb43312d2bc66d1ce3fd297e54a34e83d425dcd783bee60d526d01df786e63f0f2324e54e0e55cb879d5ebd8b27ae3a04745ea8fbec2371cad08b1ea0d7d04f972681784a4d76215a61a5db0d35b3ebbf9a886b3034708e5b9d2d34850977b33a3e149e82005028ecbad9ad604ef4b353c5829308892157297d9afcfa6fe22e5738b2e11cd979271bec35cfd537524db6a87ff0381bb433c65db83cc03da9db81207fd0a0189e1cb88c65bb6cff387aba87f2d738c7af959c3dc2961ece954cee740f2549935d3d8ca5a38bd6616957580201be9c0ccda02a47e9ad537f8836c5a8b2c4b6ea1acf18635cd7cec1ce10bb1e0a6236865a803c9b3f3b3b29a41efc453a5ec3110f06341981aaf721873e8be8b977f898651e8b097239e04947efefa4d38a0f28a0353ead93109bf3470d388994b4a0b59fbc2294f94d1c1a222547fad4c29a7575f8d1f82970907056a1d8fdae8fce995b9c4ed9662f10f07fb60e8e84c365716cde18f36dac145b4dcad3472f1da417ad9e5e200d722da2d5911fbc3ca35b7ff9eaf37b0b1977253b56b786ad677f0045ee8063e06b31b6172e29b9cb313b4f9f8bfd15746556b996794a1011dced66319c48e0d3a870049a6c334b18b10a353312b043184a4d2615d00b2f3fcc7b257a63a99305d189b8e57fbdb99b42cb168667f4dafed66ab9072d28e4350ba0f6c316a68fccd9ce3ade30034285f214b3435dee4db458b42f21786a70af323a80ea97684c8ec1c92cff277d1fb1f089e4a8ab8844a03c4b2e7bb3416f7d7c953ef72bcaca59064e3dc9d2613898594e2d0204784b449f89fde320f7bed7e82dd0bb6e1d4e6abe8b8195fc7ad1f8fc98220916329afc2dd1e811de14205ad4cd918f9a9c24a77f4069cb0e00c2c85a5caa6ccb88cc779e367c8fe2821f3796b99bfbcc183e5d18d1e629298c595f536dd7a7900b481cd2b3ebdd1b69da0f50504b037d3f7e7fbaafc0de9bdbea50cf50231b872554ce6effde1969170c17363767e790af75d14ddf38d2dcef2bc36556d3ac5e20ca69076f4fd6f0f7c0701e3349e6c51f153e77dc107f924ba0bd6e44803dbca89c81d5a29ef8a4635394aca8850d68f62f5a63f6db4af48a49f00971531f0e6ad89f8715cff1f38fc89c32740789a05eb280be7d48d888374655b985497571c2ba4b38e79a5e0d79b4afd234455f35db374bcf53e06f4934f4d43262b93e910104b07010d997090516808e56212eae34a87e9e67dfa0710eeafacb70533c2b964abcef710bc1f5937a2ee2ee615d1b4a81ebd74e126c3205f87ce79420b85deeaf2b0663591114dfc2e65e4d4f7a695b23923124ec02e508fabc6cd417b566fba49806d2febf613f6191941dbf273d6d2da4b3431582e2ce9b895511b5e64319c90402b53595a9a2b0fb46e3bd20ef5eefca0fde4314689333db2ac1d8bde57cf905ce8a67f6c0819c8aa3d9cab889704ce7a22e4f432cd6ef3645372813fd67a4c4a5d5975426f745b27d25dd7c2fb3cbc1ae444bd9fd12849ee679680c5a524e40415cd6deb1e0eab2a15123d96bd7ad20dc3357befc75c5d1d1c71001c90ce3702c30b7c3c7bc5e1811551881e079cdd9c7581d2011f324bf4a1dbc11cc074c607956ccb2bde0357f89891702663600cd2bc0888a8944f7da6a0b92cc59fbe04fb68c714b8c5b7be7a96f7a9eceb29fa01fe8b13f2186a84a4f775f6fb0601977988b670d62043e15276acb6f5fd1ba020c5c144969a3449c5790fda1dc353eed4377d07143b9f3ab2506dc1112493795e40cc9ee5d5ef99f521c55f6164bc89236e0ec296e3ab35beb41a29029c082eb6c997d46ff3d9802d59a744d51730c2a18c3104427c71146904ea47fb2c64522ba463b3382e8cd2833cc42d58d381fa146ec438ce1005c4124a5a72ec34012b15851765d4007acaed1f520484374acf5a19b5b3158ca4bec2a90da49548b59201abb8af933c2c4604fc13b743783bccc2d1e15b2bba09fbe1081f5af08d2ad1b63115408d69144ffd7b74b9f327ec2dd855d0b5e2898c31fda0bbc0d70851085da1e302c828bb180f6943b791b61db33930959df0f6cd4d336708a6fc00e2001dfb356dcee8468d98454f84cb1e690e63361ec784a05eeebd522b14846e5335ba7d11f3a1ad0149c9ff711cc4e164e5412b09a8ebd81836add8c2d2736980166309d15cb6e15948f715b95c7ba623166016f01a3dddc42218afed059631228312370878e45a132327384b1927c1c1b2918229bd3082c5ff800508298a2f6317181eff43fd1e4ca039e0704eef010628696b34700d38cadc764dc874febc3c8628fbe893bb723e521252116d04aedf64722c42d73532622d402cf56543b048117f3b7f2c8efdc392d661994905cfc1a728b150215859397d4db174ea6a52d7733e66ae7b197d06bde5f7deded5b3e11047b04f95b9220ac0bd593307e990526fab8aa7b15faaec3cce060d7e7027db08a38afe89a8200f2e99d0d697f8ec8842bef7be0d0d334123f8f55fb8dc3a21e68ca797c57213c2c3142752d14ae789182e8d952dbac808270c9a3a0cc99e48cfbd8ee1850a96044d735b9c289f1db837149289dd92e9e88b203800cc388a65572e6532fe1f0a6dbf79517b51aadd2048657df34fa0a705f1b17ad0ccafa4f9d85cc58f24a31d391344c3dcea51888a7a0612e500931fdbd42906475469073a5181ffc2718a574ee627038adc6a8152287978b91e1271a9ccc02f652c4f4894eef03da5bbb29fc5f1572eacfaf7784ccafc7858e5d4052bfba0d6e2f99a5588d0688fa49d895a0eebe4420e73c1c7c8d46a12c0167d2daac563cc5b426881338593691d583a92e71eb443987a9b31202692ca22f498bd5c3d805d8b4caca3793b0f2775a6bd5abfa946852693006d6d08d5a7d4b8b174fee7eddca41766e2c048435ec888095c7705a3ea71cd801069765051355b4eda4eaf2238f41a4325e420564193bc61e48cfa1658fc609640fa3c76a9bdce2014022aad502b116418e6b93b15d6f7546d092fd480a2820797eaea3ca1a4f0047f1f51801343fa24e3693fbb4f78ec4b21767b8fe233f560caad11cd7595b6dd58097467c251261a1bca1fd0f19614fd99ad497a683a6adbff8ad34808cefbd6b95ee3e335a8a7159c06b70f0f40ddf90822debc0ac9ceb19d12b14a2312bede5f169cea78cadccc3b7c9d4994c19c9e454c6c9b4b2effa2dc2d1bb1bf3df4de0369524283c9d9115cb45c513f5564bbf56e42001cb7beebd254c781b9d619abbde2b393d79bc7567a00f357e791e10223253f10b166d95a55739a9346cbde6b21a61ebc320a34f90b3d5999cc37f47bc943aa838f7c4807760a0867d1095ec1c2c2afa481c915ed76820d5787fe3964e82270fe0994fd759385a2c3c416b25f6d8d45b57387b277241b54df150bcc16a3dd2e28438df7f85e0a8d03a501f546f27441cc279eaac2af7543149a082797bbbaffccc7f153c21f5fea9778a6fd04fa7d96e77d718d809f45e2d9d85dddf90801ab039a4a5ac48f713599cb58bd07c89840159441a2435fee1f787c5227ce9ff7864e187954248082201c51a0ff16a727f8e0b40c420d02ec64e8e8a92857a1601482014d6f51a9decc848a3019ed620c4c87657ffd7390691a3fa334d95e3a1ed9b50eb55cbee43b69d75cbb23d0497bb543254939eb42025cad395a0b16bcc267eae50bb1dff84963adbe328cea35a62e7938398c741c5686f9896a28583c90271adee9645af843ac3f1faac1abce271836eabf6ebdbd954ba4661c8bcb58c599347308e6435d859e55f1a8bc39cb52e151a4b786e613db3f1953f18b09df074d06c43170784a34698f5805067e4c63aa833835c06abc2132d6c37adf8895e038a4f9819dc3852a1cf5f349c3a4edd14bfcb51a3d0ab70c879630bff49830b1663f61972735f313f3b29c1edc18f097bff0fcec81cb789b012991c3661eb90d538ffde20071b7559686c6d689eed9fe74c00eaad36847bcaed275213d419b6be665011da9aba187772d18c49a01320a2fb2550f7b02b5426ec77ded3274cc0f79e0c81a9b000b291ed620fb30e9af061d3ae7f8c759ee6c02b48702960478610cb058f4e056f37d54d705c2f2d850636d309e068ee97877aea923e736d9285598743a530fcac51122214fa86b0967872d09692c7a5574a1c0d401ec74368a24545659183cf3d0b3c3454e6cb1cf08e363fcba6dafd1f1b84c1608dd19f5ea3e09993c3858172208251f0e5842995e33aa942c996f99200653a86dd0028ed830b614f518ef366c179efc16bd3fbf35debec5a8d3146099650bfde971919eddc698f866cfeb99c26dec4546b2ee216ba95f5643ce7502987d98dcf0147d55efbb69bcc5d6c4012784bbc852a552de96a6c6a44cc4aea4dad6c04fc41f58dfcc64e61076537a31b287abdaef94601c39bcd9c6d5461cd8cce56f3d3a5f292850b71807f5951fe2d80d9cc598fb6c3c31f9182fc9d5bce929215ccd3187137d24085b1a606ccb706aa4f15e1b54781159b2f91ccc6bf1ae0ad8a279b734914c7f27687cafb1cbcc107aeecef8309a90041fffd0afaacc8f8881ca04e8c96efb3f48b8e80f33f72b5ac78f5dacf712b09b82ce0c6660cd283093b847f0f63c47359cd80ae37a6c5c60da89d56d5f697f7cf8f1e7875d74ba82a6fe4b4a92738e90948ee8e0f862f63eef4a2acc38fe00724d60787520d9540d7686ff2b720274288a50bcb9bc7a08525d76617c0705383414519f3f9e735d2312054db34371195d6122d0cfb97941f3482d81c92fa10ef2cf510cb3ce06b85e54136b0d01abe1ba862cb7d368c8ede4b0e0fafd2aa7ed67b43673bb2eebae80068e361aadb56d6564692cb0fb1ff88d573706628841012647847660513b6354c493ba18d06b93701ecd88086458812bcefcf7ea84c946c4110455f0d628b1c51f2fb32a17b040d57d00d78f8395f746126112c380b75d901a45e2c9d419c30bf39a950472260483bc069de11225c733479e933dfb5b357457881bf09b45a533e6d8245d3bc6bebed943ffc6a575baad82219c726a97f86f29d5d4059ada88d07860bdc8712d7f1c51e479e46b63336ec8bc55a642073c944a5bde7b39821af747493278888a87255217d91e500431cae96f6e13e1a122dc156cb5ec6d1d76c3cf67930d8c147f146fe35c1f61001a30ba655922d4669a2216a7b5cd68b7a0eadf6f5826bb9fa314a093d84739f5df953a13421c5867ded0b6371e15a6ce742ed5191d4375e6bf223b3ff7bc547d53e9f968084d866c582d66c4418c006c0541e073d803f214e67f97d5db1ee5e6d6308819ce1cfc859e0fd4832524d0b58d457e26da37df1998649012787afc37e272f969fe3eaed5a89956eaabc8c2165db8063acf3c33dfece817d959f610382323532cf916519caf37379e0397cec800bf17979dfe001e1c8da2162e68bc63f227f77e3b6626402f90718f0ea87a591bf16fe982e339e73749787997cb1f69319e414e3c9e032b284936e29c3f89c30e5ceedd2f77e2c5b8e536e3b08f5a89fe2c364fda8faf08cbbe407224821cedde3d51a9def01d8524c8f4d2361e6841218e8f5c9b8b2caac6891fadc0e8cce103bdf118d3c588500ae510b37e1fc828b05c2c3dbb4543bdcafb44d0e5a2bd1146ab3345e071692776a67a5d421b3e5a6ff04214509d0e061dfd0ea9d22cf25f1d16a9827d91cf4714ec993e2697d442f7c315595e1b220759140c5677adc085065b77807163667348a4b43fc22d7a0e939fad96fe8baca89285e1601991b86de427a9de2e1fd29ee43f774d26eeb2f3f77e1682671a762d1f8a2212e8b56c2e5144a369441c1e2fa1d6588d6e7645127bc314602e063fa120eee43b0d91bf02d796724ddf8dc17ec9ea7025269873ab4e2f8f5d1807e59d5dcbf62e0916faa163fb8b2e59d609123a4ca9c5da05047177d359ec7a74f8443e38c38cfc5535156702cc40e48dc7aafa84a43cd5ebba6def42968993a370e57b8d9d9ac916c3fe6abdc7ef7cfc8eacbfd62a6ce34d78c5caaaace3908ab5f42eba250c7bdf0909d767931231421647dd67ab96ffff30742113c4ca2a78400d3bee673e33f37e203e38f89c6a867a8d418be2fa318b624450b6d5bec19525add815975a560dac89bfe5612804c48a2a3e1021209accc7f580c01f814304878770072fe10078433f8154d43de20e8831a5b9c7f1f28201038562b2bfc6cc8c3c685c601ffa73d0650425f28ca1192f87b956e357ee2fb216126e8b96838aa70ac467892ce93975556bf54f923584c47044d6676e4bc632649d660748db2e88a2dc7d264fc122a5618ec69c7f18c0fdfbad1979a1e649347d26d68a74a02ae5d30305e310275cf695bf2c1f72476b6cc58b97b8430b25b6c577d012488abe2743c50181e558ff15ab3b123f4cdd3ac693f6cfd7fea900f933da908a4dca9f9e0615f857f90846e6c94936114f7c7f75c7e7e1ea33605f302cea0f5426add82f80f523e094e4352c9432449ed37867cf46f184f90c9746aea590a154bc999fb2cf301be06b2b56e05ed0dcdd29d6d27ae2e84ba14a95c28ff7d85e01272456802aee641ded477350b2988b6ed9f1d4714fdf0031222038235895b6613fefa92fc76a5d51474bde84b069fa012324d4558305b6836fd32a3e9b434017be19c59720636d6338bf72c71e605504a994c8d7ca981f952841b95ddf0573a1ee128034f789008260ffaf33b82dc32a8ade1fcc31106d3cedeb13c2fb48a5a142bd4d170ae0209b3c8337033dac7184ed5c464c4a65fd2c8b648e24792418da046d4a680387f89b516c6efb219efb097ac29aa27dfd28143b8056bfe14e2e165f977893af3f2aecb9a47e50cfa4d16346a68dfc08c444af363ea85cc8977818b10415fc7e60d95c1a113f62daf4e61af2f54d41a7806ff4744246f6406f26ebe5a0824619b2dc2bdab484293a1f2b995507c582c00f1c5ffa6002fb5ecb43864b0bf71189bc0f0e77359315870deb8f14bda0a4adc436060a0b98286c2ad4c8d1fe94f417f36d2b9d5b8444a5dd7b916006da239c50ae45e36ca7e9264125db3a03c22d983963de3c6b2964e32958d3506545dcf2781af35a24f852bbee93e29e0fdbf1f152f87f8020e1948839e603e0441e60c59f98a15cb0124dbc65c4b47d6ed2df1d930cd208315230ccc182b9d64455b5ef9650b7528748e052a280dbbf9f949e8e810c4ff9f197b87eadbde2e4561307e3bd20988f002962df76ffe2a16428b2ef7fec5a469f36b27a0b7d7f1a3565c8906b3214b3ca9a44975ac957a7f01547beea9dcd8cd812775791aa725a16e08c1d13f75ee2ccd64a723e34795034099ddf1ec8d714fbeeafcc0d024151820f869f3e02fe3ef818e7ce7fb0c7adf9d38b03bd23458fa4ebd200577361159ac397736aa693b4346c314191acafb497634147b6afbf5e973a4cf6a69e7bad1f33356cba09b1ceee5ca405953e188fc775b2228b5dea07fe5d759d722ad82ffc1bad83f4c541f76b0711b71da14600c18b1393646191b781fcb2c9f63c46f4356fede079fe6180536dd81edfe3d95264fc2ece5ed7096171d7f93c8bba2b6acaec066ee5a7af0b6ac9575821e48d4f6aa9b5e31820cc4a22aea424b9c5b3e086b92fe3b9a1c8fce64082ea39e8366cec4ba1a8b736f9929e1bbb893c5807bb5c308f9ee147de7bfdf17a023be010e45848a8a7a4c75bca1df9e85ef4de4d842cf8ddeeb728662632f7a01c61c9d3badb0182ea9b1a4dc07edadee2a89dd81ff0f4be90698b1f31ccdcbc7cb03fbfe9dbf931996787abd28a99f196005e7e3ebe5532818b1a757d051c55a0563505942b2166fc966d31d2c449bf82b02c542f83278c8ed16251d389cd79af0b453d03894febc9ac268719494b804b02dc8684f11789f3f051819d517fde0907328504ba5b4de431aea6bb8283517572ce3d5180e0cddc4be60d88321754ea65f9f807b399a3ea9841ed8427c7d85d329575c015c25e6c481ab1a88546a2263433e9f44c990c93f9ad5ff685460c25d1f083c41e76f15cff57e68ddde25cdcf7bdb42d394fb33609bc65d1a19756ece5cbdbb6f8fa04881522e6d770d7b8e23e38d736f6bc529e7b66c94b59f246d6ac113c20442f84ab8f8bf27a87d13a2f50ad62f7f9a2660eb295ed8c282c1af189ea114a4e3a4e7b8fda8ed047aa16f766d4ec804a1bb804f449ead16aa73ac2d2aa9f1a29f3b52e041fb78b8eecd1b135d2eaec52c4d63e9068d9bf6973578967909c02b7b91d2ccf2508e6bbe94b8db75e3be74ff677054186b4b7d71909b9e378df1d93b50d2b75aa177fa47415a26285dd847b5dcbb1ae57061d184b1495902db5b9b386f8f262ae3e907e0947487d98719d23e7df7d6e715e1019b946e41d9b3814a218add8104120307e8383b7b6d889a9a4b0112d228cf39478d424dd9d75f4941e9a1056f86ecb3396707344a845977cfd08af7773ebe128122b164d557e74343d02cf43c43c4d5e36cc3d9825b02479450085807b9d3f8b8fc754d616918b58d3c4112b79124b8f43b5f67bf04a6cde4680247f4a4b38af73be72bd7a165d245951e96c8adf6359cfb36596dabaa7410bbb395394c4dbc241b0ee32d17742af7fe9a29bde11caa8dde0c19b3aee230f28d52e740bcbd2842adbd1b31e1ba6be2703aac59e3fd14490bfe83bb90a380ce3eb45e0e961252d37719eebc76218ac40af5fc63e0eb1834ac52ebad276e3b9b397a4be4a8d4b801108166eca6b331ca18fb5340bed2c999f508cb4335c299b7890b0b6e6c55eb05754ca3b093c32e23ba7175fb15e7706700d245af2b6ddf26155f4ed6a2ceef540d7eaaa0bf53fbe5cc41fed4f1ee03610664067accfc64560675c05a7ecb89de00cb1fc29df17571b0413b54ef7ec9889b46cf3cf418a0792a3e4ec9f922b855dd136148b24745681d1bd6c1a654ddc7cb61ae61b039d5801088f34e5dead1bd04b4cd849ac7025fc2a91d7902f8318ae6e455e8f9b97d7b16555305bdbad02f899701fa6cedcf9b08d3d26080a58e180ead2b92a9f15daea1112c7da044a89c5d4de26e20503c62a04c71172c09f1b6fe44ee7c0b905eeeb1e2d71d18d4d3500e59bd418bafbb8f1a99132067387a951df707cab0c6aed4a28ef3afaf2e9a821d95cf5b312f03da80eb30a96cca24676bf63bd34f86c81a03190a1130a502fe658f8595b59c0a98222c2d802459d875f3ad9b3bf2712171c07b4915b5d587ffedb503c3154934fd5ee6d4c8c031e2d766c3d3b601d5f59907f9ac68f2ad60d5cdd7b981862eb8c97e4c755bac3a443df1238032bac1f6128edcabacf7f3a573d598252923fa45386a30a1716ec556ce34300c29109ce3c6d321256911051b3312190f062031d9e7f523e45e01e2299ce1c21a6bd6b5893c39a6c0d801523a1db8bf7cbd22357a1d8bcb7c3783cfad0d0f2d708bf7d6de163177facbc8b892f0a1ffae072db2862b3721d7b35b929b7a68a3e0e6043448cf5f0730ea456cccbe19eb6ce09a38d52130a7a016f61f19ce966e05bd5576089a63e639402ea1914d4c08799a89c2d951d9a276ad89eff3c4a23e5138e43f9f6cc7e9d91aa1a7e97998f369a7f72c8a13deba926788c8b89404226b8e60ead3cad4f576c5d4e97628cb10ebae75d79ff81a280ec764e3804bc945d4f22e54d1536db95aab58f236e7acd7ddb2fe4f97438ebb8844b54f74be7b54ed7ea2a891fb7f7abc9cffc6eb08e916215f5e7a6594532c6a31cce2e3759b772c5da6882fe4fdd2292ecd8f90a5f36a7663075339510ca1c289b32ee51b731d72e62d83f36384e1db159eb061db23dce6889e3f89cc7b8c292232eb5d4d1b1b35019609e4d8835ec88580f40ca5ea118477979e73f650b81551496aedd42a6c8fd665317c14143600904b8e31523e390ae36a475e0e61f1a61b7789306fff0c5e5fbed542e5c2253c3d43a36bf8e6a0c1749beaed3ed19580986d1922c54cacf88a082a84c8c0d43d7b866a1755e1eda8ba84d834ad1e14827405c1db7d4ebd80947728bea6282277598057d3458920af7794d3d72b405bb12cf44513c22443d2ed2104a9e1b09c8c77ed0b719f66ffa4135298dde466fece77182cbe485e35a822c8be751f6c57067822e642c140fe6a6bd99ffd881997116fc08f51504908b1567044755489279a2b37e6c537a4aa1803132b723b5b46f78becd58a7facce43a5043d42f9f781dfca178d7b187ec47908e37c69b2a4ae257a331e421f9c647eea41c5bebc3cb567788c25461a50120cd010fdd9fe6580771e9fb941a8d9ba7f2b8a4b0fe37f59c6fb9bf2fc8667b22e9353cb6c7b7b6d3d863454e8a057aba4d5bed52661d07fc24ba9809df8814f20e043ddc9ea693701ecdbc48f67b3983e4aeaa058c47b6ce4f6f10551ecf55f88ae399c8f5352a23e5800b790c0f379788e6dcd9480cb941c5f0fd9c58f46c8cf8755b0cfa221edbbab6e2a5dfed96f35329736196375317d7150b23ff739ba24ed72827120bf65dce03b31bdc27dbcb0243410e829e423a81765d19e2089c33f9acce8762012f69e5bc3fbad957bc61662094cd5f75cddcdd2c88442f1f96b352a8704f232ce0fca40b80a77d0c6d9829d791cbbd2fb5ab005b3cd638779ede4e75b2522a5aefb846866528e4cbc19ba0cbe05d96224690a180823820fd2934e31203b1aa535186d016367c212b6cea29b0438443963312fbbcbe8f7229896302ec5ce0656dd82d8f1da76731e04bb73704e4f12c7055eb625e65618fa850ef6f46f3c0d70ddde7a6b2d9690c6bef2d33adf1e3f0c2f9b16d23552371546716c4e66857dd3a09beca9c5d43e6a4d12ce269ddd4a42b4dba102ebf4f196dbc047ed0d3e9507feeee938653ec6bbc0f271722be13a7d7dbcaeeb08cebe722bb0d624e4c06d91fc70fd1511db9a9c468f004a04ac38f7c1f5cd2ae8cebb80c9a21d3a0f190b49ef7942ede9ee729236f6f12ac06852446cd246d309f1d17d620ad8f05491b9828eec073c52d6c69206f9c0f8032a44b23ed67e6fa04f82519a325d90c9385eb1fa22881cabacfeef8ca7eadaa7452552d7d453de58c5835819b6d28e1e754aa2f5432d477df70ae7c4c26193e0ff0a4c921d466e55c0d70fe2d48d9fbbcfce2d5dedc049d6ebed9cecc627c5ccebe550c717ab382d2830daf6ed2d102a97272a2858be5138b517c62ba9983452a96bbf54ce7d32d4ef019a84c7462b89f0b1d5d67766d8a25366787b83fd49a0f76ba98d06130ebd37c2eb870157136398c352bf379a5154a0d9169ab46218a6968a81338ad4015f372a11c72142c6391ffb6e57fc8a26706b7922d08339c98c7293a9185df8f1f68bbfa4d0b94d27befb226a69bba1897c3e70fe24f279deeaef476fc93f659de32ecf6377d2f184ccc2157d3d15e31463ca82e7a9fb840e9038b19c45558c74f9d573f41535277db1d6b966686f4e9954cd5d6a6d1a2d1cebc81c005dc9615837de6b2320669fc89f52863359c51dac4191ebe7e063c81cf0ffa3811f3234dc80e04825de92535622dadab21ebd86976725bb9d17d136e17cd3d9066e13123ea030fb321276670af3d3a71b9f4f02bb82be705cf64e1cfc720ec17125235c808fea3ce8f44120bf2952087a3ebf3ddc8b9038ff7b858f3eb09a1701f93f7a2e2a96ce1a4e202ebbaeb4efb602f214ef2a39d186fff050ab967792e634f91fde49a37abcf1f9b71bae35e90f65981b0970186c10456fd9e5e6e364300bc53d20f098821b5d723df57c40e8cd6498be44a0b6484677b98d9d74c4298de2c7e52b3013ab839b01bd58af799687ffaeaf41cca6f7c464dab52bd61220f81c07d712c39be99d45a2589003a007890eeb3cdce3ed70160677b697a5f74fac2d5919550708c03a768d55dc04b104bb2384dec8688020a15692198ba1cd2713a246d16e551b17fd8aa4b0dae56e2f37f1c771333bd9d0189993e685d92f3fc7ceb7a44ba4fa74b0d7885b38b4e9644a68c764c0f77756e85bab1c602f937471ab9fc6233b63043d424aa13a1739fb57f3b5073cbadfc1d18d6d78a23854fed6a1ff2713c3c2859d816a5f9ce84fd8827eb20b8ee8858db57bda4061cabce0ebdcea19797c0621f3cd9720138dc25691e2dccd4ee27767dd03c945c05d612a8eb991dabb419cf211459dcc2d68a5429e9957210f4237cd2fa9041c95dd0eb51645cae1ba3061ac7d5c7a05cb3469e076d42e209c3a362186aea60b18556a0577c24eb3677f95ac37345170618aa99af39ebc95328f85322849d7b062bbffe90544bed92be1fe4db9c94930aa0219e0f2d4bc173f0591fecd4997033281cc14e89bdd48d717a1bcda3594e75bf1dcc8286d96b7c959794c700f69bcb6c43c287ecc5b6dc65c232247e9af0a418b50020b9dc9ee2350d20066ba38009f4055008218f02a887777b4b25f70f3d6989e8093de6a13021f4b4585dc96fade93565dff971cb9d9a97e1b9f026e5aa75f897fb5c6b41a5021c0aa46532d0af7ab98cf44993a6758f3a120031ef1c49abd03c592d9c8eac0d3139c55fd155edac8d3379b3bf4bcb801abed190dfa2e26b4de6051c44a00bbb10d44dfd9357ef3c4f388bf4e540f226e185c71765056c961072eca20231600a98bb5018ff3973002f29f30bb2b8d7179c0a51dede0657eef20ca9d7d10646fa6c2404b00f9e1992f35e0ff2bf354aeb8cdce71dfc0379321c06ad69dbf94f1c684664e8adaf5ff96185298f0617b877acb2981cd4720a3e4e04df09ad466b8cae96da084e1c642d06194a27f94d83237f02cbdec7dcf64544a6f662cbba44bab3ff8ca0465e15fc1b41ead8cc6648ab146ecff159d54c66aa8a8874e00e65da38fcc9be280e118c2caf79479702b0e0d214a39c86dc83ed483630afcc2f3b490d6730cb0d8b1f0dc259ff4813f7e9b87dea7b795bb798bc7b742246f42a890fd357e098dd91966a02f4ccb5d149b1d662cf31e9d1e8b16fd8e6f113c82f411164ad0de5f3deb4e88de048ed4dfb7fccd1bd4d78f51a3c222a775f5f6bce9be41f68785f9771c7e7aa696005c61bffd734638e85490806f3e77f74c4324d544828cb98ff3325b4e1d6290a9acbac5e922f35663231f76540933f1b033bdf973f7a8fa65157cad27d3d715ffe8c158d5a2954875316ec91b836d968303266f6a0724f809412553ff3935c55eecfc517154d0b3ac60baac1bd7c3b90069dfd75882d0c673cfe45d8811684a6bffdc2cffb7c7e501c9711286e8123aaf02fc742a9e5afd0db54f632cd16fd793082af2a5fc437f41e9d9d222019f5de8c393e61a88cac81b2cb443bfd3ff44fd067bb1763aa552b95aa0c79cc166078b884be051e717224bca0294885ea8dc76b86dab12b22da27feae7ecde306737dd2478ee8c824e9d34333778c2e824f2d2820e53deb28dd47ff95525380253dd58e2cc2147f13e9af63839079f8e58af6cdc57cc30f7b05cda38c740d32e2b614cc5b153373d71a5fd9215b4762b29f260f99157f4281f1ff6fc7f28d98b08f27226949c5ea8f3d0676f4106d692f1b2040cec39bf71854e2495a72d7e0788dbb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
