<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f90e70546c6c1980974d91609afdc15a6942a1b90b2517a7132740b943a0f69d75efb16ad068b19bce0986b4a5aac882ee67faed91134eda9c4f11dc9a744ffe4de8b367820a12690e22841eac033f69aedfee36404b4e9a9f7f82b191a1d7cab37c13cb780c901e090145b00973a7b452575bd0906d34b13225df74df7838c9481b75f9fc7cdafbc7c7712984c619cbc00b72776be77a713ef18125cd1be1689eacccfc00e9e295d84b931d99213dd2efa973aaf42c932917ae16fae9a77700a4b826c478323d49f669109ad0d6f7d5c0f3c6b3292234555a2d5fc3cc4b77d17681a12414c9088c42b5f0f124f9f59e7060c876fb7967feed972f39de3613a23df42f51f094de4046c61b0cd1e886118e8f1b7a741057a018686fd1025ea2e3ce0b3496a97721243fa3fc4e927037d9f7d7d801a10d1c5d5e32a9b52377bb435c82e4deffb302ac533280ae988ffb0e3e92b18db4c5f89cf5dd6a76278e2bafa40b3d98105cb0d118825b26f3322c0daaafb0a78d26a74d87ca0969e4e7be116dd25fac8f4c647db9a866adb5ccea8f2bc497d3166172a903f5ec58ff46985593be088652fcba060ba84cc30949173bed5c48fe141913a677143c3711323d18362493acfb39683db3e2f61905d206b7d1fa2559264b3cf92c97a49a268632557721abdfd96eab1247bb1440d6fe07f0d0840871a2a0b08cf68d4bae79a828d1551a4f90d166232d51454c0eb3463e8141330a0066a30ada91654a02df53a248a4910db674c52c495a40c92e44d495e92542c4df97928ff34396c254b9afeb7df15c509a58cf91c196b51d2e02b33f01372d1100e62d25e620f51b43d179e8f66c3a12de07f8f5ab25d42df72d3eeb37d63e9c569422b5d1c7f39ea9389dd7a68c325efdbf27f749a44b4e23dddae31f2ba25cd86a8f66e2931b4871dba4e64095ed2c32342ffb69c65d1ef86f90aa3fc1239fd67d853fb6dedca12b5ce1fcc188a05cc4630b3805714539baa5f591515937188fc927c45e03f82e58d07845ef99cdfc271b901e6dbed8ccd06d75b1cfec967bb5c23ce320b1667461d502b9595754b94648e9bdd4e78d0f3796fac912f6ac2ad0d00e1cbb782e5edbf8aa3db98da67ed267e8117f24c4d897d2a51e5a67e97586d52322b5de589cff8b257248a7f26c5130d23956cc71c71935155d237ac408c23c57566d9f36d916fb81790704880b4218d9429b70f7c2eb30014a3646981f9a9c46e11b92dbe47f3f29d0b2ab7afe89ecf4a6422616777d2a0874254c0f14890320c58c125106c490e01ed3351f9ed94aceb335af50b78cf4040ffddbc4578551c78ec13e08937f9919142e3a1e54e55957196b7df24180e2f2d1585934993be160f61c98307404c59441bcc72de9823d812b882b2cdffe6200061c4a2a8a21d17c2ec7f5a9e8d2c534596896d3ffd616f49e172743a808a42c06a216f811f84009aa5f271a606690fea9ea99e51bc263a0b6d822be406e9463e8b674002b9087c679738e612413bb275a31a5fb29da94e71f487a8b4dbf5de0b6d92569bef5ed3be40a93b80270267741509c7431238966a47d8250c013274ac60a127284820ab701e21fdf5c769954f0e7b69899d0d0ee84e1e84de04d4442cc6e960b1053a96600be605008354cc2927aa9b955ec9def98cdee4c759ee0435c1fb995a87f12a1972d951370f133737618a36c7a9260699edcc2cdd2358b4447f0b4ba956c99d0c79bca8321cc4db7aacb12ef5a008f831aada70b11b5cd3c7a666123be51a10522692be7fe9edfd570716eb2fc0b6e6ccbbdb83d3dd5641cafc454788f3b0a23bf960460cd131e7126961d0e710366fb84c11363ba04f7d59ff8250ff5c78c2195ccc3af2f619e2a0874bded27c7a9da89f18347c0b6f3f71eb2ad8311cbcc214d9fcd4aa065b6f031ca68a6bead5646079405806167d443534ba15d17b34b569fca70cd6923a4152638c85b69191837a45bf40e1cc8a61826d97fa7e388ec7fc3260a68099f41b8a25f598b858ea870b36c78d29b607cc5d1c2b8762e2e432f7df1f1e9fe3c43cbacf2fcbe2e7857c8114d4a9366b76a4de4965becd1f2ae9f0e94998a8d075c1391e56d8f1d3d4461598a2cdbdbd8c1abe9c80fc8381bad5df9f4eff3da2ab3976973ae575a07bf3cce8a6e3b8afe98f08d45f275fcf2f98ce0f836ac6c3ab0ce65d23318404f2a6c70e8ba474e23dcbf7ec86f257a4cf5acfaedb7aeaeae866f3accc9dbaf0dca2fe801e4caf5a3c21b040ca8bab36ed9debdf43099fd1993206a4389d0294cec52c56b4a1ceb5b616e8dd20f09883b4e6880b1808a4a7de2237f6a91bd4fe9de39c3ac22ad649f0e570f70104ea1d5447c70251bc3cbe5cf0be5464c76f2b02ee1b2b07227080f48076ed96a99ffdc8fa270572cc81483fe216332508e8eb1bfb47d47b240f336a8220d754fa58d8d8d25f200097061ddf7174855e04d50ee45a4cfc1998384f2d77ed8867a6944269d5e29d32c1de7caf2912f34bcb4bf6b093b18f498fb53d9db441b17d8a12a1348d1daa7af1a94b57c16f456b7d402d014df350a40cc6297efc79396904747b2e41d7eb4395fd7bfa7504b597f7544b99b4f352cb6f215589357dbfbd9526b986a2f378409bf4e196515d262133400a3d972cb784be73c7f6c0cccb0c6a255e31bcd15a5ca132a6cbf6462be767273ff526496c8ff02ca8e62927f3b0981c8bf8b1d9186693837cba1268911d2c8674cd3cd677d9476ebb9fb796b43797bd931fb745031020bdeea1d275317593f3bc537ce9f80797b8d79ac929ac1a7b828480983171a9f623c38bc2146525ad3b84bddce180f7de437b6f53db38ba74c359cfd9204d68b4461a1478bc3b1ac89e41247cb1887be4ec94b67837f8ed253e13dfd570ff87a0d73bd6e8e26b9852bc13a3be26b641847275447b928273327b65f79f4d6f79665b9b70846a76805dc73ea11a90638be6783e8d239471ebf3722ff0fb60c47af11f17d44d8f9a540695d120fb488206c2f60e357760580962ec6b51b2ebd871c01f95c6cab230a119f1f49f2f2719ede0a0e6e514f47ee62de45ee2f789bcc6bdfe28296f5e3cdde661c796626da76b497b819cb2bb500d4f045a7d696cddada7be2e46cd828d3c903c1be3bc128b11bbddc1e23709779db4c329de5073ddb3bf27a182de470afc70a5a938920108c4909aedbcfa707fb937a32eb9778f5ba055d20049e2fd69eedf2a85b3fe226eed5179da0874dde3f1338ca29e37345c6007600aa5859f5b587f42c1974f3617adc38b563617c03402b6041270a9b12c13f405256c1aadc208ddca6abf23a517dbc563e568531639b0cc911d3a79952fbe97b3d10f9670f5513510e79a245f7588cdd41c68d1c6da0e17a244d4c33a3126a2ca5c0690ee9b11be58fa4e8af2dbf4dd6088d22850fa444dc4bed769e6072f6212c6068b66396aacba59524507be3a8fbc1e8ba5d46b9738387ad0671cdad740dbde319f0f358d7ee4d70077f876d73f553151a57b59b631277256bf00156c094064d16a4c5f9c8479eb44d45b309963e8e275e89735bb8ef69d46beabd9281abbc5cfbb2035f0cd0bb89827510cc21868cf7f86af54b0cfa5e5090b041666dd767a7620e64e636ab9892c42e688329a9bc2ff635740913847f732160fd271af822dcea51781bc1bcdd430f640b42369be8eda5831127cad7e881f8822bc371484c8216843476e6c1230a800b38e784ff6410a92d173d156a12c8e7e7c385badfe2635fa942ba572311120f86d9b0d82ac0ed93f039ba77a82409ecc883322298f6a38d41ad5c8520b88a3a3a3bec8c80c212aa2674489e0226e865484d23d435c3217a271ea60e32e0313b95b0819aa142c494080d7443b647225edc3c73623947b86aee48c963912aadfdd3e3120f5b71390fe6219ff4d8bfc0f6167105a0029c940146617c3dff91cec81822c9d38c4293e97ffe7f7015c13e391c19a4d5593b4f8f9a9dd63d6e0cfcc18c55c4c06d52ea91bdd89a66fc78cf6a4131a02a1265c7198dcb1c588c72645784a46e8ba148d7c142d733b671d0e69dd9349ac9b191c53b0823b1a2d05e489b081120aef582774d8668d512ac1fe54977afa50868e078e8e567925fab07943f2effcec0fd959279f4421c4c6c658816a82e5475a578c7f7799df1cce4d4681acc4a7ec14167205b0564fd231b2c802fa8a62cdab17571ce1367087d4e6ae1aa4b27afdfd758868728fd4537300d5b552dd4a3ce0e0651394ade2509c7d1ae5c312ed9dae5f2dabd393a82841f8809acb15e1583de79594f3dd10a158db2d69464f6b0d9c080ccd32d379f8bb9e9de141206a4a708ae7ae3fff8405ad416936aecb4b62e707a31bfc2999aaafdb63df46e2c981602ea4e81bbd706ce10c1d5b98a96a7bc002cbf043b34d2a5494c35550f1408dbd548a2ec3190a11ad47c84400ac9df72d5906fb00e7c627507276b0ed3a6d95ad53c5f64b3d7086f8190d79ec930c70bb77c957cf3bc5fa98742fb52351590a8e794f64623dc66b00bea317428f3edfe63fca1b819ffd2f9923c1f87ff09a9ab5291ff4a84fa4a62a7b7e4ec0493fa124af4215416e8ac652f87fc3f59a024d7d440545d8c5c4337ca7bb3cf24464de0938f255b0b9c3d14d45240d49e5772e5855a8dcccf4d72d8c9ce743d0ee85b625b24ad2837b4325fb42b3992ea8f9ff16e6b27e86edd6eb1c73af811ccfd901a37867763f4bf23586711153a2083eb28528db47d893968be925def98896ceaefd47aafe3671e8ef22fe13dd9c2c07e95a8de1283b5a6744ce3bb15e5818e247331ae674c0f47eb694069ca14b6abffdea8c6d89d6c8e8744c9b7d8da6a7e8450ae52af421646085786f0bfdd77c69c9c9efa2068e266dc06209a7a447322ae9ab1fc12235df1557582a3a44be971458537e46233dc3e99501de5785023667dde0bc929a2738b0e58724a3cee01cc51a23579da0e6dd3237d283e317a15c1abd9036cfb1ed0a26d773a2501c88c13870a81ad4597c605ae5b3880bcc9221a91c91ced03f1a53f77d1a10a17645e162cc4bb9e0333dd9ed8f28e5f91b044376dfe9e4449e5479c3c5dc23054883f62d9244126a43c31f67fc108eb98d9733860f62c4786f0d3c0b0728cdf48716dcbb169272adf59f5dbb592216168d8dfef2808033b1834e592239bd8bae5012e8c6187851c08320f8c1b08f5790b764d6f4a5b2739fcebb5b2f053c75f4df7ce4005a27a7c2463da9b353ac369e2a84841ca135b82c045d1ade04f9a9c692cffb3924816df18305cbb320e17fafdd7a97d08aae280173749f7b3cd1cf1eb377ac4b43a8accb252bc1d8eab5eb8911bbd2819b218dd7d743ab50eaf0fda3bf4e641ccb92930fc8d9126c0cdc77081b207fbf8d0d29ec662e5be5f63a1335f842da6e48405c072c06eb131006c579068bd4ed38f2983a0e243b246ea07233e2b73853004214de0107dd1dc6d62ade61cb6d2d41d332c0d2c97f89126cb2fc50c248fc80a5d54b303e521477828f978e155c39adbbb9ac2c8a357f96c4173afda112d4a9a53e19c51aaf8a9830ad1345bbdcb9615a32fb52e959053d0ea8a1a820205d61c9e498127f58467e187fdedf504ce5f01dcfb0b97f05767f21920f51b704887cfe9868ca4c3fdd4707a837aaff988565cd4c8a173b44c2575d1c270d3fec24600580d8812e179ba1b10a50d2fdc8e1dd24778555fb187e7a7b61e7680eb0735803ca4aa59d42b5938ffe5f76c74900d3826e9dd5a06923d345693d6ade5d90f707152dca8170c98bc1ae942e2bd1b0aca25e9cda8a8deb7a2d5d188a141c36c7edf578b6eb69619853a0935027526a96aaa2eebeeae6151010836c5d00c3e4b28e5c747423913741a2eec13f6680a8495040d8c2e963ea00807d61eacefab7835647a9cdc53d5d8564e53cfa8c59b142125f1d437669cde073ac66ffdf9014dd5135a6deee0f3c6d2b96a5182c115899bab4275cf9295c8c5cb0a93b953646cc38d4c798492f73ea3e484f8208341de3653358ce8b4fd7176eb0c22462ca3aabcb5f6708fe2ea365e1eed00c2c5ae291a75da84736b721ea4dff017080a87a2926982deb11e227f120cfc4bf0eb0c932588af19e800a7b51985971d5b8f280ec1acda2d5e0b292ef514394bc3d36447157c945499989325ec39d56b11a774d5e2f04d816d73ad81fe6034f7b1737b1995599219d56480ad9bf4dcf9511b779708cdecb22d33b76855a6f02db8db362f95067375af5697e104c12e0a46564d9b58183356caaabfa209ac8b6b4d35f7fdd71a8f388f82305f7dbe2d19db997ee37d7829c7fc8bd29bf18d6aaa7289903b63351d4e5fac17a89af163e2938695df6c382b4b28e3d88ac7d1c9f60fb12ebc2070ecfa8f03b589d82c0a7663851eb8c13ba26d32592628618930fa12ce37b8318d4456ea517f1d0a3b36943bb2e051947f61fb22385dfced40b69ab1c279b00c99bc43289ac70f413da99587567fe9163ce9786d909086402d4ba9958a0c906d939be1598aba8929a86746e0a6afb039b6cb089e12234ed658e8c52ebf26a3f073d4f9e4c1ea180cef2a7e258fa4de40e635e02bba05d6391b75258f7383818ce9b6935c65986cd58662aeea812303189c3bfcbd2a802f43f0c8646eb90af9b3becb6de3dff917148bc5d922207c5fb31551d3892302a0489096d3b851b3e26ef3f1c5035f7f2fb3c7b0983a7088e74cd4cf42ed1713c45ca57f825f7c3398e0a008a8bd6b7ca834305eb936a875c497d648f9e7002e71b876fa45ef5b02cdc1d8f38dc4e3d8587e3a43771a25cd4d7ce25291ab43ac6011d7bb1991019d78c9d044a1ac30e3e1d63b8f42dbf26d325af2392c05dfe0f5f0a8414d2acfbb51da43f2a5c895752d1aa111fc75a4e1b23a18255a51a93201a6ffc93db88e4da4359eaf93b7a007e6b6213ee3c3ff01e0d5d4182309964a5fd337ca6608f79a4337c01b61f0ee6b2cf83b1a487ca29cefaa2bf03a8cf0a6b69e729d1f9aab934f20162a7b94c3519f472a24c8524ec969a0a4e3ebc4427ea9ad3656ac1f10ea8d8e9523c9e43318f6ae60ff4d9b49005e31547fd5b62b2d64b3684a95400f7ba135b2ced8b45c52f2b4198551272975aee5e633cfd602c6f2935d6e7966a6f40fd5016ba7f439a77a30b704caa1e15dd90f48c65d5f97d318ad85fb2386885cccb37c9dbb4176a5fbe6da03f9a2108616f8ed6aa3934bcdb723381e6113323d2cc7ff25fb532b90795fd5f72eb3d19f628a04aaf9fea4687611655c9b948f0f610e06a4b7c3a8f30741c5b6b5a345ae27eadbd45fafdca52c26d71a951c70ce1a67cafed446a77df4319fe945250e02bb48a32ecb83d597b90210b94ad9241ee574fbb08f7c71a98619928f4c66801399d7841c9dac14d92f10a8f51c7abd6e2437d22767da744fa365541144a951ffe75438f282ef58a222dfa949a87624df8160b48c314c32582bac603cda9fd20b1abdd85526267b02353024db60f17b8e544343bc859ea00bd08ee1930c15ad458557438d9936abb03ac19023854e77cf2ca01f14dd2fadcd8b041714c0f4fa06020eecdfb9a9d515b345dec1285e1fdd511d4c6fbaa1d9ce1e763af1102b799aa7739d12bb834cae7a8f475bdfcb1354f5053bf95d932d9d646f2c4688f7163e33b5e4df0c170dcd79974bcc113cd9cecd7102b3bcf16943c33a140f5dc4a28ac353c2ee6992742176b2de3c1362632bb7c95be7651cfcf825f4108fa34bd5d0309b158686944bddc8d49ecb51728962685ea119c6502d09ff95bb2b7581abbb68ad347bbe19a479a6e0042f3b0393c08b07c8066f7e86d1dead6f451e1b80968f12e861c2a46e17c40daf7890642b737bc0b457f2839f09ac3ef204f80a47bbbd7bc3109eb5a890cc9d1d7ac13d3ac79498947973342194e0618eb6ff1e124f35f42e34007dc0aeca0c9e1ffb7f0272904f3031da7f98c1e396c21432995116060f50aa1566e3dd8e48a24f0c30a3c18dae17718116702fe186fe65b13421f6f53ac6aa6a70361f5568043f797b592e70035e378068258ee7caa462df11ea074ce7429e9b3d9ef9e24fb8c918574e33338ff91acaaa1ce1dedcbd5ec7d0b5cc6c02af26a1a702fc0785f1e82e87c180dfdc95872ecba59dc6a2d0fc45e003e61040b8356b8a6d55a4d732584f1fbffea2a2492242865b1e4f485f250c3992275fe11533c237b3ca6e21df6f061f9a36802ceb5e2d30a288d980043a6e550b138f98e95739f9389ae2f66570c45f6ab8fee6722faf989e1cd777e4d0f870160dd83132357a2e4ba0e662f503dc431b4594dcf68e0c3bb72809bf74f9be1d7d62eb83f1aa67f0d60d351d25050c6135205d98bc74ea44c0f108fb39ffb189394de8da469f07e50fd22ddf9cb135f2ce2c4c0851c4a5ef7b111d43b69de1db35d67854d4844d9f1241738491a4cf02a86bd9231ce0eb6a7441dfad3428d84ae1acea182fedba5680a7446d63090d10f2e8c40d37deed88480efa5485821717cd008a212528f9136eb15cc5c61b50b479a452181e448ce8653c58ad3d4d0f52e65589c4721f3660097493cdeeed3a9ffba7e65822fe933c5f4d4607b0f3676b1ffba6883f43d9021ba9edf48fe56b087f6443b9ad91b76b1032c711cf8be2fecb3c93c9fce2f958eca8b206123afd1c23f2baf2e8add17efdeb0b6cbb7242ddaf7e156af66b1a7b524a593d44e1c04e78c7d38218ebf7b7365ffbce6f223158c9ce4e665ff319a38a613152dff61f85173fb429a494be6e389d63b015981db344dfadd14c67653a88e8c48377a4262d80e8aa9c5182418e70f7acecc1980ecf8cd6e220a30db0efe6a1d50fa78f9d1f33d1d1f9990c4c8e9c2d9d487577229eb3e0370f1d0299050b014670e50ae17621ce9372fcaa8efbebb6b29b562ae920a976d7b847ec27f8f601013758b8feff36ed658fcf8737737a2d4dc0d8644bd2be5bc22c912308b7fa3eca6c1cc6519b8339230a2387c982963bd31368f631c507bd9b687f2dd0903705db9ff276cfe4638635fc3f281af44df7d1d46bb99cbf443828e49c1bab44a5d28e3d45962c5dca2643060b5d68ee3dc1bdea7d17d1d5ef1d75fc7c4a5176e820836fbb80dad42b7355980cd2441bb5f40295fb13df32cd5f2031cbaef321293d37bd1d67c2657c1783d8aeabf1fb15c8f6de7a83020ea26b5996a6abdf6d95c7dc1decad3dff7c7a3e6bfb9d4df9fafd10a98a22a3eb16da54c87faa1205e176fb384e017dd83142f7f649bf01ba083fa4cc6b20362fb73578a9cb7a2eac530773225b06d3543363f7f40ad2096286c43bb7b7f6cf06144be733a2da451e338487a656294f55354e969eb75d673ca1c5a927a9c7f14b706bc2545bdb3ec240ce034d8234477225d87e8a8a90817c685e4236146dcdcc2fd8ef4b565960005b12c28db1e02db9d91e53d9ba4c43684eb941c4a3b76875e4d9fdfa2d4568ef589a1250b06d796215c6fe3736eadfc20dd621cb8c17ec4469f28c42df203e2caeb226f4b625c9aac6c0961279efaceb2e227077898b36c6b78667c692d5871e220b7b576f082f05fbcbec2e228e77671b178f63eb1b57b056063ccc4536ce406ddd95e07c16cd8f045b2580c8c59dadd061979fd94f4309d9e5c28eca53db0ae5b95dc75a7daafe25055177e3fb60f8bf52578283c17382cb3ed39fad416a281343f11a2db2ad501693cd4a80d46e04d93a83376dffda02c31c833d9c5de64bf3b216efaec136c0b6c80013e320676807b08e161b82ed3335a70affddeca5d464111039c47ed98b446acceb28f6c654dbcf05b402ac431c8048c97efa7ac6a96594914cb366d1e239932f3889326e2793e665af88bec5f0f12f0c3efd52dd390a130625806b2f94a9dcf7e5a1082d79c5839fb371b7baaa4db49b658bc31d66a6570edcb52f8958886af407b8f603ef4e6a3fd829a94aad6823402c6df6ae9ff53945fb0938cf1012a55bf731a0fc31eb0b6952adaf057af1d22a386f3bd5043065281fcd7c36cda4701f8d0291dba89d70bcff2399de3333e19c933fe488b51c1ca2bc5950255d7eda5cd2e01ffc0376b95f3a9d69a5ea14666d0bd3790b7bc442f208354778e0fd4fac682266d56a15e6ca6477deccad3dca527453caff0543893cafd0cf548100490c20fede249748f77c5815e37e3fc447ba3efe9078e9b361f4a191b33a8b0d8291faea5a3f4b16c7106032fbd0a86331b242c4579bdf28eba98e04b0a6cef5baf4eb41332ee8cf14ae1d134b40b9f117db58f1a7abd047bd35faeb929a1b680c93c87782ae97963e2ccfa9bf856d6dfce40a44646ee23b763892c94ea0984be5ae05be82d84a309e85711563bec999972433a75fe097b351ebc201709dd0e3e880f31f9d822519d11e889d0dc434353c2afd5f81867e8dc7d5b54454fcfcfac1957b543e1642c8a5b2ddf37aa7fd38b956182dce15d114da92d9a6411cf501b94cadbfdbc5054ee8b79e0334f1d9629a4e033776f81922713f2caaaeee7eb0217fa58faae24b55dcbc60477b059c7e51d6d1f990e3e963f564a634de8454466ec0af68762de65b1d66f9ebe5fdbefcb905d32e182eee8fcb12ce8c2e16e5c1c1ed6278dc1d79cb7829b70a8c26cad5ab3e576adefe21dccd666bb07c14c12ef933a4c4b3e1200854ccb27349f450f9dd60e2b41a8648ba4a71647312f9fd47b6cc332e882a369a8a4a23518f17303e8b2506de6aa7209a8104aef7a3137b072d7396e57bf75b5d9d585afd18730b221069ba8c850541bb368ed0d74880fce5df8bf1a6a48cd4db5818912cdeecefeac25c2f519de3b2d2905f5b13a13391faced1e637761515b3ce77f1a536ad523a0ff37390c2d2c062eae0c21e6a55dd360029b2189e3a983eb2bdcb29f55473d3b82085a5c85768f9365cc1c89c6c9d469463e07daf8f2fdade7c5610a88b9a7f8019a58e7af638ef01a665bfe01fbbe696474ab22bf35e8d1985bcdf9ee1b24a1100823b8054edc92869c65ec7d68b333925277ba11b75d330afd317d2818570988cce1b611fedc5f2d14572b24a32772462e69eaf9f1ba52a29b92880fa3a04cf18128973f19718248d43c6d95177544bb827261690279190fa47fdb41aade60ec97ba8e5b3188171fdc249da4c38f598973a4fd9761f72c2ce214c661dda840cfe3112ec058b4d1539c91d66c6083b2c4b6099d1057387521b553ecdb3550bca8976334c146941dbbd23641581affc94a53637770254e6987911196f048656fd0c4ddd384201e37b4ac4490abf46cfe749447cd6e42e51863e96e319800bb418d1f1e170a6c42a00d26c5cbd5c083534a78389b9c4fc4acedbe4123deafdd83af9962ee5293bc8b783c4806927ec8f3a068125d1eb2870c89e5f59503669411171ee5b062a359295b0efebc486aa3edfda6d4259eee767c4e4a535707dd1ff3c18496ce7dc08d5627cbebab1c22cdb34460715ea09ea3a99c53492be8f82a894b6db73ed1f20089b5d969bfd0be7df14774de2cd8fde50bb1a367ca39558c39c4f05ef98c447954bf1a96ca0f9d578df09d44a456225a2fe9172e161a529704f2e75c7ed920ed5c0b9797035406c2cd4196a1c1f6ff51dbf5c345f008464f706394668767b5b039211ee803c50cc4fdc8f8ea2d4d262420c23c0303f8ef358b75780a080de1267e38b05e317422245e083c4e3764cee5014874e256cbd40c0b27b71db8fd771352ae5486c3ff852a79aeef85d7ce672a3ec7f469a6f445924455aa1a1558b194fc3027ea784efd5bf4c27350dae38e187c0aadac8d14c96f2c60299d9ed1a186eb88508f5ebe6108963b1eda09b05955513fa4463cfc3c91ee68ff0f9f307030207538fe95c8201d3ed342a4400f7fce17b08991ece9eb7cb1c6e4c6c87dfc0a7934b302da628ce14b406fc6dd9704a95a5f490d78518e02ca1812dd934908a8deeded77c080aac264de1a495ecf7a140d54f735b8b46f6b134bb4ecbbfaf1159d43e2639bb3e7b1440bab015a59ad42d38199a2d2bc13de55ca6818fe2d462feb05b384806569940153260f74722fd0216739a8f978c22a1e65254b7b25d747505f3db03f46f6eda5d0d9d14755d80e31d503aced48e6d59339227e023e8cb65f2ccda4819393edccdbf120e405677e0e71f15f6cc15134d9feffa7bb867bcd29a8d5bcd6c181ffdd9d6f81b37a01441d3f7b3ff3a246a83c2ce3139842fc0313d53bbdb4b850d98225e6dc947af184773d8dfb0afdf7f677fbe21e2ac3b27cd68a50575880d53f1158859e8c3a97aac84bba9007b0a620c42fcffbd4ddd41a3a4b9500767c0aa6406f608296ac61fe39f7f806f11547bcf30927b4c37e086a67d530c990b7f94d42447723e773d743f6a6a1a71f4607695d9cd7f70a283293342f2e2416a2fb9b9156a8fc24249b846279733fbc57b61e15023fded0538c5421f759500475a651885d8a0ae3df57f59bef626a81f567ac3d3675d12d9911ebe4179d0d858b18bc67222832c395d09ad4328bbf43db22a252f00420cd692c4bfc03e0847434ec79b1c14498f4141548c7c050784ec3fdee8cdb53d7a7c6cdacffc55028e811ea4f774a6099daed04ea64a35132b06f5bb3ac9da7e4a2dfad3e2903839b12a787634f1cc7e881341c93e007abeda88b91059e0ecfe5f2398abf0711828168e7edcdc399230018089118cc73ef3398d6d9bb8a6c9b731abbb64de15a8b5aaf9ac427b9143347c5e311957a5d6a90cb35a3ea27be74e2a6fe301a062b9be2a13cf5671238782cc9dbd4ca32c13674c9931f5e67e50f97156a55f0df814fe28c91dea26d69e8c75ade93099882f774ae27368e27b7982c2ca43c5f1c6ab60da09346a1ba510f1e71ee39299fa8d617df1ccf00efa9e7a3c3669ad6a29abafadff445b566b7fb788ae5369f28dc18867c60d337a1bcace4cd68a76ca0f389fa9323a7de32dd72baf938f5281e832332e80cedcac91acdc6f6d907c79cb42fbdcb903f739a955d0218a47ec2370a93c036b52cc1ded5fb27a5d90f0cadd715df3d00c2ccb4a66b980dcd06ca65f361d52a5a68f18992dd878efd6eef9559a5e23ad6af25a331b9500fe127f97fa935869fad6db5544c7a0c5a419cd38b9d61f7e819ad7f5e4e42bffd03966de5e399f81169264a7bf775ed32d24a77dcca3dc744be4b5c3b8f1a1eebe82db1f4e9dfc577767184127e504dd6ba604c3cb76c70e51a228fd9810f1fdc831a01233acc01202a72df8197279f11bd9ef9210cc7563b799c9741d7c16835825e68a23f6a2eb3d346068c1285b3f8b9b8db2ee9229d2840d2542f5da1f14ed0d1d1408bf55d26798db9d0aef3c49174ce92b7d1e12694cc26f157d60c3ec874f4529fbeeee5fca51f97f45ab5e9d21ec740668d985e18ed32b55a19604f30245f2cfc4d6d4f6d521ff1648a25562241071fa0c515fb1620b62b61f7d2f15481bfb2b0a0a76cfa069c9c53ec3b77371055fc3231284708f8992cca69cbad50c3be8c8bae43c063875351c6e672e777cdb0a35d74ccdd88e47701568c300131822d7525cd8de437a41f4ea6a6868ee7f7f30ed10908981c309154c7568abb57068e729b0f8d213f2452c1456883da3c36d2204227bc66dbcbc1c233a74e71e3864d41d1f7414f25bf0181846ee908a3a4edfe1353d57d88732c64cd203b22f0fca2ae33ce05e97a3f599d1c0426b66c6927758fc36ddb78e63b820452cbf1d9a964419ca8c05469677b487e7bb663c1edfe414c2237fb608c6d87745318c29cd1235d4f6b857be60d4ee55ddb70253c587bcf6050540f5362b74eab4940649d0c94132e42710e563abb0077217063a9f5bbbb0c6ef5671511355fe399a825fbd22c7ff7d924b0694f11b53f08bbaecc73be5c4f5cee506635abd8bcf6d13d761a121647b4696c5b503a675cc41caf5373d34226f397d5819d599f1036cac24b1c1fa9b67a3918a260fc85ae9a145142eeb02be0d3532ce9698fe90291c086d1c885ca273375b77a96bf30d8290e7e60c81b96ffacd0781e1af7d6341b799d780185e1b2cf78fb022759216217f0ee7b20b622d2c22ad8794a3daa6c46c702689b5da0d987e105f3daee061e590883bfc4d4182e17540826d0d8d5206fe1e36ca2c2d3a5a96804f760608043de24f8805dd907c9a4852b57bf6b97a3aa0f7a23fafa81b3b0e767d5cf17040c4fc552885ad865730c82edb5a6d2aa57daf71e5227a01c107ac99c2e7400f38bd2ad6674c1ffabfde0aa62e8669519c1559bbd661c2c5b9efa82abe25f50c8a6be58acd3e2f3a76cef996a0e90ced1f4e690ca2341d2474bd6147eacea770681f1e39915236dc6878c6843411b86c25a632e85eb4ef28853e2dac8caa2cb3030b66cc420f43963c2101184c98e9e63198e9bd6c53110c0c47b7d4aacf03c3490b67ffbdf2a144183f372a84f67ded44c3882087b658ba46cae2c4e76b2be9eeeea3bedca12ef1f1d9d65280e5c080840791aaddb450a3d6390eb9359706c408ba030541382e1e6331afef810f37b1fc1b4756114969720784c3ff1437d63a65c81ad25923cd9c7b2516dd6d06ae91f27da827864acf691172f547beefd0b93b1a11fd66e69e0afc9124c87f8e562212e4eb5cf46e88574e9a61a8efe986f0707724ec0811b973657d73fb7a3373eea837c2009a3194c68d5e32c208a0b503f212c949a0e8b8f5d05804353bb2d69b1f92438fd20190a84da0e007e684596fb8f48a85bdd124fd25c8ff5b90fc193ed5b76d1276213138cd09c19b2dde2dcdc6d405babec1c4692d787b573173c58ef0ecefe6821f32a7b92d32f8ea67eeb995dbe0a455ffda3effb06e26dd90ed8212bd4a96a74809e69e1ff7617877e8996877550b782dd7bcb84e7d9dbf3955eb5dcb627c3e0fb28bce884ac4422f2466b212709f30b280e1113289a6f50af0d482c1e18ef70f65a0bb678e52c3318a2b8ccae3925f23e114f1cd6e9a6dc8ed41ced34a41548fe531663a25fb3efa891d1d0527724fba0ce779a446","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
