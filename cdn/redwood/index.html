<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"167926d5494e4b272a5edcd14b7e3f1cca12d3b4b1c921aa3304a1dc5ccb8d9ea7eba9e49903872904e198f1dd3c8693f8fefe53b87fa4e9879c569b9c6bd072f1b9218fa0b7b1e89e7c99aa7a2174f09ea67f9ff12bb924f2b63e699e0445a53643245f4e2d33d34c1ecc42a0b7cbc471aded1ac95bf924ce9307349efed2970c3e2ccc8c03fdedebdb21ad3a6196bc8d0551303c0ed94bae6334131da41b491eeea611bf7dcf9789d8e444f37d3e4b93123077eb089b6ac241369b41ad8409e3ac97bf8305bb13bf5acef6bb34902092f46cd2e8c5e089e1eab83c86ca681f8c6daa0a7b3343eac5c1307cd440ff8b54f9bc58eac21cd8a87e82f23033a3ce6f87ba22ddf8947bfadb759549aec515b45c9f96b0a09bbb93571a3b94f7ca6426a7590422132ecb0105f92665b3e521a8abe4f35ac9a0146cba08b3194ca591d6adf5d38ec9e1a87d5a8e018340cb372fb609c08a2b0d94d27d5fb7f7d14e0b6565edea02da07f7673529e7f94828e51d9e443e531424d36ba0f8561e256363a66e2f396e3735708f2910a18697679918e82285a1d5b761f68fdd95971da03ecab6998b446c697955ce0e47f7f8086da2dd4aa70cf58dd9e971e4f39c617782056374ff7ab0d42dcdf633f2609f050c3d0412ec01bd214d63241aa63d130aead445da30f2c92dd62856e49a7f4bae72721f1dde0c3a2cdf2cf774c246fc93c0cc150ff858f5489c60bf6350e9b374d33e9958528935fc456edf84296b1180507914724fd7a94131cbde048f73f71ac767137bfaad7cd0fd87a8332c2fdb6337a00c53c4cdf45b30ec57146367f5919d3b192c9d0a62d2cf36cea2c658264fa9b8751c09f378bcac32464c6c6e5b7e8d473f98bce79f8317db904b888d8d83c564bc059c7105c4c178e6b8b4b0f7ce4132a283f28ce59fdfe413ad4c0554c8fcb8d29c40022798227b5b8a00d8f2e4b53662b1d289b634608b8a6764d24cfdf424d1564893b1973da3fdf486fb92c28c59213262d07a4364b20d0484b2fe4465de6ea773062e2bab0532fb77b1a69be8af216744484d9a335fe211e0bc48b2bd1dfdb1503879d2ed5924413d1afa4af2d3c0a8ef10f14ce80a2c9c7a835d89fb7862667a5c90a56ee202d673ce6fe50542aed31126a8e16c093d355bef3e4d6dc1a5685b8399a29e7272d7f02872582e34cfa8299570e66a9ade74c39f21f151723232761d830e399f91f92a1b8b2b31aac6969158e9afc7dfe83af6e9f649c5583e485af1e169d5abec7f65b91364593d3777a6ee0f3497a24469e10782c122c7b8e0ef84ad8318edd4dd2afb3366d72d5e3748c6176d167dfab476905cb1767bdfc7f7d2d2f4a163db02875a3871231a07ff70a6aa38d430473b633977acfeb3d165298539206eb8a61388aec419d35e79fd0c51d436e0784e5866aa832ba2676add36a3f7ef797b05f9c6d3def609fb1a1ea9eef9c4e7849e9d9c13e0de2be65b65e748e06e241519f631e5e228747c5bce434191813722a0e875c9b3893fe8ba4dda38a9447bcec40255e4156fc09db9b59762daef93ba67d113db4497f63ea6c10e5d9e289086cb357348aeb7896bec9465378c6c7742ff612d8e1c94f17be5a42d6a119f53faa4b870fbc52704d87cdbe27bf3dc52f46ff20ca18ec8ca309d1740bb89f6bb366e28952fce7f79d47f310264932222c61a414997e0f74661b403275dbfd50462ec9bd6d32f42020dfc4dbdfe5a03b1cfdf7c37049f0e9f8f9b5f3a5d2e8045e6d91ca949e9c029b09a3181f822a2fd0a25a17a0ce031f530cfb7eca939eacb2efcd97f9f2c7839735c1998ca928d5584beaa6e5e2383db183db927012dc727dcd663adadc31ab8615ef0251c178770ca1d3d72132117001da7fac56fcb76504ac99d77e1e6d3355ae6c468ffe113f82af2e96439b6fdae7dbd52998e25f7ee1ad3c1f136fcd9075b2fbb3bfd28d7dc54750d1616560388743045eba1f35c25212ba2a39dd343708d590479484caeb2f19ceb7f9dfa20b126f40df9bf4a360450c3dde45f903c533b05feb74c7139d4148b121859baea0bd793143017d3e81d95d91b130de8004cc2d356083b3503725a9361c9f0e27f7f3effd0258d90e65392290811d1cfe5879b138ebe4d18051e4089b9678088308403c22e4955a86d58e55b375d197e4cbd2ab7abf52366bfdce03faa5f37b360895c22d38ec9e1bff63dafab126cce559dd0fda0a7c58f142a6b4339e6449534aa3c02807cc1a9d4edbd148ef33958759c90c172513fc9429056955d005318e24cea698d879357e791233b440ae3237d51e12f210841b137044f7bce5befbad7305fb0d67ff62e1bff65415522e864f4e6cc64bc4bcfbebb6814ddad73264974cffc6d28f634b6415c4003f0cc48ba051a22324c590ec39ff19728ba5b89c726826ffa7ae98dc0b5ffdd3bc74214919b06730d27b1c28ebfcfc94fabe955fd0f384c9017652dfcf303c8d5af6bd1cc74bd32f9df80beae8122029465435458d16c7d17f368746bfd436f54d7616306b0bec47e2657ce682b881102369daa2420f959cfb49d42ee910c6fa327303b2249db93a5d816a9921e0cf33c9c3192bd0956392b8d313b0407e384ba1e77c34098cf74e1f8e3d1a5f580a6102535b3e54ec8f8beddccf3799de6b8dac60935762b82564992ebce35d359e82b0ce52fde5c20a0a2245d04fbc985b9f9f1166fcf2d1e532506951b6e2219e85af244ccf0d42d15a8cf647a80e19640d9aa637784aa1266e476e0d84b7a25dff7b11408b705561f2e81d8770b51ed64e20124048357faf677eba02558dd23bda2d7cdb9b64f86c5cddf87f5e5da886fb7b87b728fac8e67928ceb3e9a41b4ab61fc79d1074fd0ec9f4f782f4338c0573586e7efac86da07ff873fa495edf64fc4b986e96c7fca3501177955135d70259907ab1a1cbb6f545756b9e8f15c1b097fe58e1ac1392efa6ee481a2c4e0e3757ad005fb5ea06fe61fa0341c6314acfd1c7191981a18f2db314d41fd317b8e312a7776e80ca5c1f5129ad3e50bde479f75a0c97b40e2348041dd46a22bc7789e1a417128d0ff62912a50a22186767c2b275d726774e1932fd8930192ca4a60d54fdcecbea92941b7833d1064f61518815c71706ce98650ab0341f400b86f5817f39bdc9bffe9a785085191ec90ebb9ca10d90a886394fc7ed15a207ebf96e5dc49c1413f7394a2b1b89b2ca9d2c6a3be273afad01ad2a6fce3d6e1beb2d207e7d435c2c096736084ccebbd5f7b172dd303e83247d1353b94993a6befbafc3d020195c2e6056956f695500f9cd9fc8acd7df7fb0bb600daf31ceb160996ddfe67d877c83621fb7dde092cd90cf74804e92b3fb4b5af2c2a64147b9b1b599f0983c51e00f3d36ac6e37b6437560afa38fedfa9e090d3b517e89143b52cd4b0ece01a9d1fad9c34ca9a4f406f5e9dbcb2c8cf80a679bf080d722245d1d0a6ac7851f71c3fb3da51794d10f00e68f17d2e3320fc683a709065fd34a886b0111396fb6d001574e6d2dc20b3c41fee23ab7206caeb2d0c28014b3ceca424b90c39cd4cc6af31e2d881d9e12c95620406348226aead0d47111a863b619ef514104423a7c7f1aba651cfa029ede38da10719abcbd63dd61e2a7ec5211276c331768500f09182dec9796550240ec2f7d0fd6ea6bb4c01d5e6c24173998d584a4edc1951e4a780215102780345f87118d448c61ce21d4ead33669de580e0ce50681f08e5991c41d5d571fa13181ab5c883b1867945f94e336addf0b0b4890a6fb7a92a339045c5865eeb7c7f33425231a71164d68ce041cb1b77c7e2dfd1588166afc0727aa84f9ae7afed360675b5bf49d88a8a098d4918f10b6e27cea347fc647205533a64f68d74350b226bd7d4c9846cb5b0e95bddcc3e3cd7811b194213656902a69563fdc4e55d6e98962c1c098d5fabaec05af570313c81c0fe92b81a5b7f2cf8c764ebfeb5ad77ebdfa1527bbabc506b5b2cd4749a0465a6390430532739e7becb939c68555b3f0962da006400cdc95df388741cce2b91b1e400df73c56be787f9c8890eb938ce7e26b5f97cd375f6b729ec35951750776bcebafca0e0da4f0aacbb576ed3336981a057b272db3bf8c6e6f150633ef05b560b6a712cb9af49b9573a64e89ae3cf88d3df047f6071adbafd2bc57d4a576e3e123cf563ce69bc63a32da10a01d14fc1e04341395b94e9f05e839f30c800a2c04c3ef9b4fdfedc0bd5eb0ea78801be56588ca1f32dc06623feb8516fd711e537e2648727ae948d05f40420c2f39e1c89d806aeab8e1a4f7a1f630a1e275904aeb2820be1d04360d385c609c1d81d8edbab949421b22718bffbb2b5b9f0d588e45d5afe14102540b0f955f3e7b5ed5100ec8411019fd18fa50102525e69bbc0139379014b667cf6859749fa4ff14d0e47d9228c3d37af07259c3a133b64b061112a140ed1f2688ef6f1f638816c0ffc28dbad6e989909870e152fde0a5603881a4fe57a940d922b14eb63edc1d59b726a276409d203805bb6d497da4d31695a7430795c258f4d8e84d2ef59778295ef64230ccabdbebb038cdbfefc121ce7f1e2d8ed1eca829e7402c198a8dc481c670b48bb788f916e41f717299387f4281a3692bcd99455f47d6cd7617083ebda742b29a730284d97124b692d4f480536263b2bae6d7b7aa4512786cceb07508092b9833fb1d24826cc85d5bf8daeea0052e7023f83f17410d7c3dbf322ddb59c6c8ba7c76d5f6faf0e94da533e043727c2ad71b875f71f32faba633baf34af2c3ec79e231a41d0f1cd49441d93841eab554e0c3dda78b6e51f6bac511442cd30484da7f753c9902f9cd413d06be07639172b0bcfd17f0f1bb152962b6bab66efd15385e5b04c8d530d28f2065251a7b2d8acf793b8013acdcf7a2f28db8a6e6a046452d5ac754238c54643dd5c251d041073364dfd1b60ca16da897039f3a84ceed0cd61b035df66fa0d49ecb0e7e0d4bbf5efddbed13e186880be92d4073407330fdaeb4bbbed72fb52a1f9bf1110e9198434d7a4eaef91c40723605e9b0f34659e49c48a23c1129f51d16d19d69a59e810503c0a2de4a41e7c003cf31e68644a44d48d58816fb8da505d794f8b55ca0986ae0837d986dc5910ea22fa8ff58631f8a035423fe2471d5a5930ec361cce535a811daafd789b7d4b4e5d74465a6d486f0f0db1a171228150e2ddd6e19de99f511c2fcc642a4a9a19a20a91241d0f46422ea637aa72a50d967cc5f6d81bf65e65829ce0c6f4e73db935f3cf727aa4b03a7a06dd1a1833a18a2bb7f332e95bb1713c6d06153fd4c0dc50314f89001ca3ec5528bec3553741a5e6b0985728e0ae2d5daf82e63eb3cf73362801f4604b3c740a4cbec4c528cc0eaab504f09cf818d5978c5fd7c4b052db8a654b112c1f48625b70dfd754c1c16d4409f35c9c83518a13f4ab943e21086475026a39a92157418e30225eb51952ec5bb17c493bd95de4f49ca370d8e5c8de9e49e6db7f419ecaa28a7a0ef89fb076bef8c59131ef2b214d5119dab5aea586f88438b37fde368569852e2ae6577dda9a762c2b29cfd8ff5a9395277e55e55d756d02c62026ed1c388b079846e7f04112419f850e76d1eeb0892c4cfe9d4afacd0571f996eae4bbea20f0918472349402b0667e5a49a7928de270b550d0a07b777a584d706238a1c44de63056616a1db6a88ad584f044fb4096da026dc1dadbee781eebea83020ad0115d319d45983b25d9d58c432a4b875ada31fcc793dce1a2a9b04c40c7beb0ef36397e37f169fd6849ea9850e4ff44d981246afb2ae081e49e3f746652e4cd1dee944c6f29023815e4f1dfa9d578c3ac4980d10c10911d4751e99f145d57ea7c18bf19fea60671e4335c5d998fc4cc8f1fbacb018aa04a769653763507e1336786b4e61751c3054f2936b54dbeaf5e26dae7f20ca74c75dd77f22d9b899ffef2466165a6c0d7b64fe2b9fbc55fa658fe04ff1f7ad9f961afca94dd9a5284dba71b202151fb05a879e7cbd27baea27897543e398f5aa4a8dc6bef1293f9ad7f9db3c2c603485655a9f8e8c3337066ca83dbb408de829c12823b5b745ee7642417c4ea3566d46a14ce38c797de01859cee4685a111cd3ea32b10954375ae8bfb9c3d0e78ce5c94dee3213e15ebf612d1a008fad4a8207b9e225abb7523a0535109a3e7652e1ac6880379caf4684986c3b5618a91792b6524e5cb54f1c96238b37a3f3d15b57b62dc9aef9155b8827ffd0fefd954454794770f264b3ee255d8beda7597a17406d8885796edc1037d2f708ea18ce406cb8273c86dd472494552d2eaea34d5550351126f64e5f0a03518cd42f674d030bd72193278eda2ac7f436acf7ae61a00af74ea68518b18ae2495c52526662f8e5d647eba2f7ccc079b71418ef0cbc09185a32bcc4287a7761138257e1cadeb6e1c47c1a769d54d972565340baeb2fd709aeab4120d4db6c5c7e1489cbe034bd78c400011603d25a52c0e0e6ea7bbd5ecbfb6e646f252e476eaf3f6387495b6618cbbdd28c67c63c286062d4de7ff6d34939749b6c023fba011ccf8d72746c745a0627b3f83a8f39987e44544b0f7e606b00ba946c6744533e39e0a25c9b785eabc98657d864d1c024f7c24c88bde98a1eff29dcdc6e017b9dd7a029590e88136178048a9c75f98388cf2aee072c1b173d1eff80716b4ee546bc0aaef7db85a7f33576101eac4d02611754bfb7db3b7601c71bd4638f63a590b2c40b7c141654a641ce8d585a62df4b9f959ef361362ed1cc3a072f0c72d601a8f1d3d0f9fad4a5d80e590a6761d9039d25cae262e6c0bdd21996b35e0ac14e2944bb63a3561d2a58d807de20d71ee114a17efa23265787c2f41a2368cd513aa9a7d9bb3ce9e05ed08f6384ed1ca0cae1f0baaa544144bd4846793a31eacf32346d0e9dce59ee4444b519bf93f3d02b88f4efb796dfeacf1ef5527ac0c268f63bd029f46c4b10a969b55a9ae5de2b5d659c12a5ef5d7ae417bb0953738db96038bf99bda48c517255e1e15045cc2bd12d9a379103e0853045b9fd1f115eac7166d692553bd7592c069e6f2d7eed04912759a7c9fe50738de673105e041f7a11a02e86b625136fd2adff9607ccf5d899d2c7c56364cb83c81c7c23e3a51c3634d4460f180b4ad9c7394dafa4ee613062591007f9a7fe675075ae65bd1f4834c6e546be86903f2b2b411c52cb32416bb37d5fee30df1c1d5c437c210163825fa6762c65bb6e24bc21fe2cd54cdf412a7ac3a534098e00679f3c8cc2a485bff819d8637326179917b7a12f901f6607645d4dfe9885d520984558733a3d6eaced7867a9af33285e45d2c4f9559496c32ba578d652a0aa40407e77ad880e0648d8ba9b3f6ba7310e0b16cb470e137a4ead888dcedd477417661eb7f6dbda71e003c0c2ff533abd4840d542a44148823236c6a681ad7b88db41b59625463fe41e76ae910f0e3f0033a597c25b750e0947fef8d49768d3c1d19b46856f0127652c0fc323d23d9f8e97611615f48b57c9af2207be420dfdc073dac85b151f07791ba17422142cfe377956140f5805c6c03eede1e518ce15ea667b95c5177465c083d2676cf38ad0d167c208873b0e72b4d2a30ac605ecf8d477c74d939a5d8cca1b0104191ab212ab36527d49c9f36f10b9e55c389ee31ef0aed0c6b4562ee2d106f54f8ba0a9f6e4ed244de5565261eab23779b9b16641e7db2c27e127053259a0431371f383f49e1577dd0f1abf792f239ae013ed6e5f87e0a1edae84136e5128ac8a5beeef1266d09098326a61d0598bdc10a5eac700de2e0eb3e5525e54a1c234951eafd568e8bf486e482f326dd1310040711c89ec91e009263e82f180256e54df32d943094197065e9e7172772b3abf36d2fc9a0ec3228c4c1aaf8cfdde821b01adf7ebaf1af196be5bbc760180a8464e02167b0c7da032e0c50492a79e516d984d5c0487cc4ccb783e140a0c897cb7ffbd3f8af7617c658fb399c102676a99249c1d41e74013d20fa51618bef0a73fa3abc6d0df88bdd756ce6b051a67aea278b0b2c9657afbab4c9fbdd07a86da6d40d237f6cda081aec3a2eba51e1507542ba7e2dfef708efd3f597b3d235feb225c625a9453d7d10d724358d44a6810d4c699b0f3b78d0a20e1cced35c7e6c013727d6bb91eaadb8680e1083953a682e2b697f47f27804713df685f6f1d92d5b474cb513d42e2cace0fe38af05862114e9836bcf494a470aa04447793a12c4a70fdad18a3d0444e61e26d903ff88b9c62dbe491ac04a0e63bd379e52c2a6ae08bdfb6071b7d3c36398b0c34c130e2292de8cffad5f5a324c79d9f4f8fab4c58073bc069821a6d1fa5841e3f4f61aec069168c66e891b04bdc17caa8e95957f854a4955582076d039f469410d9c4b7c516f7590cffe363399f6cefb8a99264092289d6872cbcfa4a05439693a7ccb0734b5b2930770384743be736354b39c7aa4648fdaab44334a58eb640c2f228feac3a24997d549a3705423a3cc15a0c995bfe19e765b67574424b2d77bb18dbe4bde373d26a4a1c147aeaad188b1b28f9d4cb8bdccf7b083d4f76aec50e59d82a97f57ce16fd68546e5ce80f46fcf2ccb2ec79f7b47c2e94c3a82b95152afcc8ece41495aa3ba557d2a0fe510ef8ea5a08422a9a92ffa7a7a0167a47067919b2bb6cf70c514223de3b568592e602ed08a398cb149d0b09521920744754d87fdc9b59ca5318b4ad0c7915ef190b7c7c5f5ec8c5b5c41cd113645b6c7e5df37eb9370875416e39b130861c8a1e4e39d28f8ed5359ac99d5ab1f83ee571c3e21c3a522982fe19b319f054ba109e51a98d51e81655b6de30ec2bc2b48ff6f84c4ac030e6edf6a1445037318b8cbca3a06eebdb70648599e073f9a5ff49a53b6c20e8bea3f6350d2890a1a765b0a51f9501fbb67cdb56d2bfb60da291fc99a5ed79c6c6464fa8323ceadf4cb94291ed9ce3e40fbe210584ebfe48c7b1823e10e2c637980ddbd85bb82f1f52d9ac303e5cf88a165ae05421275f1cdfe715f1215daf776a169a853d568779195195a59b441a73df3a70c6e6d5cc33aea38896aa384d265cda8364bd22cbf78bcf9797ddc0f256bd3dd7a5ec42e72359398fce3637fa09d72efbc605f97436b48c8b9ae636ac9a3db9487729fbfdd91a7db9cce0a966ba40ce8ea605ff145fdb5bd6db5f5ead986d4fb366730eed028b9b2c7dcfbdd7dd41fc06f91255e2bc961c21b0bae7fed509f74c2c9c9e67834c60bb54d9f2e5a8879fda7b98f584b822f340f1a51377a4746fec36611bdca94cc954ae4ae33fbcaf85f3f269bcc97dc8d49524ec56eb7f69fc218e494c4084a58b6a2baf1c3b49a4ecec3054437213e4019c85d0dbad95bdf60a12cc06aa95cd7d13b4da084fa94a9941c7217e63cbf4a5f939822eb40f0f0f8bf3b108e5ef3ac81392be3fec870fd93f8c14fc5285b9ea9bdf2615e574fc271a7f43f68fa949379e982603afc9c8191d849b10d12c556cd74b8cd442a6545f20d9f59252245a63336756d522eff65adb464d81f31273af4e1747ff06af9c394fdfc311067d5e55267207fbaba2abeed1dfc95729dce6ecbb3c9b1ad6cca3b896098c947af0fccd3209c00aac54899f33d37987dad59132e31afa31ae4b7d1897e060bd72414327a98592ae19c421f77cbfa72450a91d9f82ed1f63d99f6cd497fa490ce7556e489aa90dd9dcd7e6f11389ebaf29cdd792ef7fd4b72ff04f8174580240ca719498f8351fa25ee83ccd7fd890d4a93e04bfaf66e143b028d68f74dfb7c14b76855697145e1ddca789d8aaf8611d342ea54d98591219802d72f4a2081489a32948fbbabaa2a1a202c93b441ecd385bd98c21333d370f416c44e5405908625a1b08099c06cc2c9d4745f775612410b4e4d5dd56ab92e6ce4b37a45b1fedc526beab846d9d221218ce5dff7f7ded77c982598fc538317c7af79d961042f97087a69a79407bc8c302ed93cda2a4c4bdf2e7c506f462f37963b7f47b7e779bd7ccd652831db4900a07ad04d99abb60598d0713451ab973d659e0dedaa69afb2e00935fb8afe171fe4e31233bc50209a6a386d0524eb15398a1b7c8e56da57ffead88e202dc8c1aa6be706cda0c904e3d0198dab66862ea31af72f30c7472c07c7bcdcfeafc7b044dc15ef282a5d4cb0a6ad3230e7dd76c02db8b1f821b85d9e85db3ddeeeaeed65efc75126d26207bfb267c43c0caf3d5b97ba7b501c90c3eac69f933e091dd16b242cead6993c27ee967df15141eee91c01735cb678c6a6da2c7a333e772000f0c34dfaf67d933987344591aa8fd720ad034774ae0f7e793e8dae3bde22c8f1e309f5a26f88441fbd9a8aa4dd2148586e103c6825ef670b44dc154c3e87e622db764fccc169b41ce2b40d4d4649e502a31a99d5131591e76712a31cc67d8b6621c238fbe70bb74c1a27e74864caa2dfeb6d5e63bfd70b091d2920328175f633cb8c37c97cf5e6480e45dda6189b27a39987f116dfcb90c18998da159814688fbf1eb28a6d341df7a1ede6543fceae5619b14b5ab51ad6c03a15ff2a200f9d70a0d77f5e7567a9176cf364dd90377af73e07c652e56beaba3d3ba23d418ce5a023331ce4339d5de9e2fc42954d95b12d5acc37a54ccbb2aef94194a358727fe5799d784a6a48b311671ba087e9a594afb5eccb2cfad29b9170408598aaa8ad7697f5bc6b12b2523c06a2837b5d4b57b3adbb6cdf106a3d99fbd15b4821b247d60046015f62f73145b1ac41796db29aa9d5e49dc2de56d2b2724590e7396c236dd364baac234139d6194dc133ae892958da25f5a5b5eb5b43d89682cc45044659e2a33dae110e88b439ac239ccfd7ef89002fa7702c5f45d71bbdaa199328323155dcb493b80947a94b4f3079cb1a875900c383fd5722b92307b47cd0b2e65721a683a616286fb68000760217d939d786f4e1cf90d1c96fb2e45c8d5d0a1f80b19ab443888c8b3a17e9308a5b2334c54c46cd8468193dc6b85cbd81cb44c43bbd20f270fcc90cc565a74bf9ed157f30779f4421e0fa9368dafda2481acfcbe698420a71051eb072f5da9047af476486375717027cf5daabe0a82ac724209c39da05471726366ce8a462a6cc4314bcb05b88f25eb0473edfacabe133a0cca8e59fe83717286ab319ba4d24d4772d43fc9fd4d8e6929a3ba7e44983c78d9c74a3cc677d87036dd628ce83569adcf58bfa3b968b9850cfc44ac3508febae3e91a7cc1689ef199be970d6367fa598ebcdc489030caf3c21b420f3d5ce85c5c36d1c03ca1c172e81221b5b3abc812a449dc587af958646c647985095dc5ac7466990b26136fd88653374ff0208d07afb08da9b14aed6b5f212b011a916d03c6359000cec0d8f3af787a461324032bac0d9d612056b9410204e8fb3eb64144545d8a338bf958e2fe5020b0d3a40e08a5013f9f806fc30887fd1bfab4606fcfbd82fddd8aad3526a6b605237ad424f3066ff4f41becce24d00a21807ea1b70aed9f58816d24da5dbafd57e16e51e9c14a1a610d56ef766adb0fba1abf06ea0aebf243c73ae7258b8badfa548dd08361bf89838e48b25ce557a8b16fa400749be59d5a38687431dd36a4cc1b4b2b493d1e7f16ccbc4915415fbf91af9a38d01e95780b1248acc976af4938589350c7c04afb1645577d7e2efdf2b842307dc1d169643f93f7308abe61c96ffa7fe39220cf9695116bf548e3292e6de8a2d776355d4bad968ef9e8156bece3b474a719d309c1bceb6d1fc4bbcf60b368053e5817dc0ad7da21b0c6272770c6139528d0bd232b66561a073b5aa5f6b4d9ee56fe528b17669ef456fcbc9a69a0cfc0094cc67a1188396570fdc45972b90e2f8f567a6fe6956880670f2d444f58e11ab0460cca7f24c35f964133245eaffc036033e8e1823a2cb4fe303db1306eebac879e233524b76c6ea8d5e77b5daa8d71e5fd0ba265d8a1c5b5ee832dbe1e44f2d39ff169dd8d6fda1eea0d0dd579052f8ec6aa4ee69198a4284a3fffd82dc63b0c49af9d49dc5ba727a2805721e111faf6cb15474c866a3c2de3b797fc7db90386317436855f95e5e9b24750cd93c5d88c3cfff379b350903fc0cc9fc644bab54bc63da9c83d56de905310b71874d809fb53b5fa34496a502d9e161656d37763ccae2074f7c2639e90029af9b916ddc6c131a40234d3e3200a03798d17e0b60730855df573203d331d48a6af69a9b67d9887e6610760088a0f5bc3668d64f075036f702c83ac489e25c577e4357e8ca0aa331dc7a454a312d514734b5dacc7e1d9edac9cc3506e2ea995f786eab4e84e0d731d12368c19838d4ad711f86728ca1414d7f5c0a6557be802fc7544d76a005c55378329fb341f979533d9c5c706033a856368bf908317660d50764bc5cc4efafabfc175d29330f41b189feab1dfe7cf515c95abcf128864e8e279c0fa8b65a217b938495b5e6e02c77d76930a6957a228958d0396c304fa21a67b69ff67ddb5832e8805549eb7c7f3adb9072ab2dd8dc24d127aab2af7590f84b52599f2968f04f721955d434b1bc2e43c7d7dcef8777fd0f841ebd6794df1e81ef31aeb6372c215b0ba7e249b6799693fa6152c3fe8c08791fa3e0cec5142b1b4c815f9341a3b9d1ae3f3473519122e3c2e99f1b1053b717e537452ef020b9e5f54aa9ab951036a478aad3500db45081e9dcef849fb64b2a4baf368a7d8d4f940ce7d47ccbd0257d686d0b1039a4145cb787d90e670f6d70b2f09ea68aa41e2f782c263394f324894a260022f468e3666b15ebbe0188f41f2fda52af2e4ddb30edb4047c2c58c8e86ebe305cf6157553bbfc3b5469d14a53af4c1aa87fc5e2328417c25cb6d2b48c56e2d6f9c3420df14ed53ca9fe34e864781b840ff0d069f42c530f5a5f399bee850e7c8829068e6d52ef5460752322cfafaa77ceed766a10d08fe618749d6cd148b8478d9e14829d4014f1b5900669d4294920be1ac14f6bba52831cf2fd267866e91605e190abb160f2c54d279408bb2a59f89cfd39bf42f5ee63439b3409689535ea31604d24672223aeb787400897924ecb9e995aeeab1f9a39134d3d4e5627bea6476a5ea3a8ac7e402ddfcdcac1d2be0b9b79cc6bffc61db9a97bd3caf6bdffb397cc4fad8371f50b0fca7b49cccbdfef9a51e4d9b88b6127ba6257a1130713adbd5b9a0474adb60e0c4bfc016c41c2a45b0fadd4eb0dce9bf5323ff4c632ebcfc8f92fcfb66c33482981d3601d39d787e032f1a63f7d629c6d82b1fe1e7782b3cb631af0f746e8f8363a2d4069f2ec7ae7130a08989db3bdfbede46da4a88bcbed1005d3aa77ac16a24b6e91dce57ca994adaaf812e7d7182147732779c2051c893fa6a1b333517228f03d1dd1bfd7d8c2a0632f2799da7c0fada830375c9b0ad082c03225c91ff581e0638bb011f15b1c1903cec832709863391bcaee75bd882c66bc36d4f9de4152c13170a3b0f092f07dca76e1d1ed8ba227e967e7acdeca9f7413230b774ccb4ac6b74ce41edd706fab659efee845949d8e0280f2a370e6138cb47e2da16510f3cf790c371037c3c7a6c5585ca7b0a78958432283102935d2dfbe80b9e44a40ed72f35aa9d51d620dfc933c06962c515b5ed2098bc21c28902d5ec74395927da510b300559046ea3f5e341850f8e1b6432add5d41be1316bc7f5b753bfaf069f57df51bcb1e88d6dde04dcdfc0d75a6237aec7f892d9ab4de94bc2a802e2ef028931a7595b199d82dddc6cd53f64ed6a92831225d943f1f3adf0ed5923a227dd1f9986ecb4d80ad00fd3612b58cd92e25de7f42e6098ea2d16959acfe9f542d90d1578fbaaa1729058cf982ba3faccd461720f58a198b307230dd991defd065fa63dd82bcfb0a2cd8a60a99aae7c42ff83fdaabcc7a936d880b74103c708aede46104fec5732cef3c13009f4395b210b0d168d32767ed19d39d8a54cf3935a8dee0f35447cea44200b0abf9bed56717f8bb181c4d782229997c35e87db3f3b912272af7bdf6363474d9504ab20193c2e72862e5fd1e5690469ea27b46d20d3df65109adb5c28d8f4086112b324f0cd9139118fb1f15037fbdd62c39ec5a9fbb8f3118441aa0659f37b62a1e61e0eaad87148a78dd9e921c0f2d857c2438a7988dd619497f614d04cee90f43eeb58654d12ae8d82415de74e75d4d4ab2901b4ce9f4dcc7c5e0d7eb8708710ece22da348f17f379ffbac60cac06f018711755c9c436ac1ccafab9299c997c2ab37da45dfc4b770bc53ab6c6a6fc12d9ecce6277f1a2c74e40f8035aff82549a004ce51cd7de90074be277fd3c741956ca6d850f675df9eba738aec003edb8f45e1e076797eccb129bf2a6f8cedc1d1ed3c000e1b610476a8615c777221082965051cc56002908e16cf33ef0c9437a4de5c69aec377e3f73c9c760ffbb5352c0ef4ffdb073a561ca0f5e4e7f0e47a96652dd16d90943a8263f5c2e17164b35f5af86eb84848b21056c9ddcc869523a439fe0357dae41c3f3476f09f82dab67ba94a82d270f13c253d8bd6d6e8d189f31ea6c35f630f8e0583f895d3324a7240c28f611cf2fad504899c85407da9349c592c6d1630b2bf941a733313093b5bde941d727e278f373a50c1ad6413ad5912c4d515f1c190a9899ab8ba7a9100d89650131c6f72461e348be43d0b7dd0c10740d8e35b2edbb83ff73485f64c092079027234cf864f335c5aa9a9a57bcfa2a7571cb95fb63bc9d98b92797c9a8c282b1ec78d09db543c70aebfee3cc715e9dc3251674a3e9f1a4acc4c137f1b40471313e82d6fbd93f913055ecbaea87ef00869b98aa2728f0691617de4fce8e39f0b0d623dfed2d2ef93484be1a28b0eec0d136b5b445bd8c1b5b2c03d759bf23719d8f7817ae7c9b3dd8f7e68eb72f758b33564d577c60e4590c6cd15d203003a31681e26a0c4df63437b4f53d2b04b7431c8dc90ae1a10d195d95928e6f298dea60bf113089251035d9ac91844216cd2f24f1f414a4b5e90d001922d2adc26c813091360572fe64554043cbff23549751dabf318e0d0f80ecb0aafe2dede8509a259a78fee75303ed8ac567a37b9162f91c56c6e3b6d5e2d1af57370b6aa93bbb4b77fa4216f1b5c242a21212b4c8248966c1fbac91c33db8864b4731f58b8abd0b9c15a7465d0a66c5709bea43fb43125a226d31702ad68fbe0061a4f9e075368f53332683d60f6483d07d97155f4dc565ca2c3a8afb48f749f4078118eedd888d05f2fc305097b78a4fc5a91808f92be9b926c6aad8c1072bef2f606314a443d16014a8ba7f6c75ab954947d9042be1f8d284511364dd447873c2e416e3a658d6a052140fbe8034fcebe0453941a0afceeeb5a109da39b9388fe99b196fed514af2792a1fb9a1c880f4ae03230a2bf679025891c563f3af9cdb87eebc96bd2e15f7ffb6f71d94e95f29755de227b6697f31608a0417ef4c0613d98cad19560d4272579639e364d46c939f2c5caf043065b80def0b560cd3d5e2ec42a5a2035dcd274cd9794fbe4bd938070a98c4b1e34dc96265c9c42fd05743b3bad2a9c53abdaf194dcfe4738c994421d35cc1273260b82aff047e868fc79b8caa1ddc4481744aab94beed8a18f30a0856148146b592dad926075c3538db811bb48e47363d9812ef3bf27bdbabedd836375fcbe6946208e422a3e2c98b13e795e64d9c0d33753a7cf562eb133d2100c7266fa83538b80222dcd3b3a69225c3a838001ba2718dafe0143d2bc6c6d04721970cc028adda5cebe28b9d781064c77264eda428fb558bb3b6528796a32af8029cb1e60890a70a618a53356aa9124dbdb1d02d8f7e594cd68684a731ce70c09c6a6a82cc608540d44ea1cfaa188737d1d536a50b74f44b951388db27f1278af5c8b20950a4eb55a7d489a366673cd0138b3c4f2fdd70ca9521e040698e6fa5767229674693b9465c35c9803d61ac1aa2ea1273b3198e56a774f3d399c395469c897d0d1cf5a26d4f8930db43201ce4eb21d2c0e73e9648f5cb767996e1864d2060734e8f10a19f246767e7de17966cb433db1d71c1b255f0b463fb6d74745fe2e0487a2bc13f0a723e761bd4dd5fa70c8ec94b5fda30427bc8ed7dbac61a0aa6413e0edee0db8e22bd32cbbc777333cee6929c660003df913622018517b09ed0830a6cc799908cd81e23bdc9fcc72d6e3e3c8d603e8d78bcae4a3fe4f294c8608a204132273d8f05965bdc6edc88238d855682b71abf35bd2dfec08875b2dd3f6a005b7e28bd56494df1bf1a4fbd6b4435485c6d3fc7827327a71342e472fdc36683542b566f85adbe10b30b2208f6c3ddb0a676a7e4ceb3f3d1dc0e0768d1b88161433b4cf4c75d8ed3edccaec866742427b9099ede2bf04da6e1e831c041df0c6a5a6ed5a3169ce59df24eab02627d62d7bb32eee569b1a65d16ffe94ab3f6c27ff0ab6ebeb8ed3101d9865a1878ca280325301933fa38c350ffe351ade531e4bb711f66afea8e683275b329137b65a5b7511aadff74126a109ff6b2b6021ea21c56ac51607f37cc477c2f5595ae6b6dbd6c194f570c24160a5fd597d0140e0166cb7923ce2a5a55369ed1018cfffab9621172c57a08bee904d60a5897cedf7a733c2b003c450d9bc944457f371168f043906638cc64d362b4f1779e5043a3b4a3c007936620ec94c058b72a55edcbdc696df3f6dd587793718e9773f9ce53cd771aedc6f82540f6b665313e50858772586fb32565e0253a9b1864a0817e89a9ff0bf740f54600b04a80b2509d4090c441acf4119eba92a7f3cd317874f0dee4a31eb1ec77424b16308a9dd803201cbe7ed02522b7a790a922784c40cf964e73b15340b628a2547fe80c3c9da0b750106437a6e1dbe355fde86eddb94a383d08e35e398eee1090aa4028f864123d95934d28e096c9a82bda7f3d84530f968006831433a8ac70231e2c7f7c28ddf9785535fac9634288a9a7ee9d8d53a8376a105359cd1af7a0160e079b6f800eb0243fa940849b32799639c028e8ab4541d62d3732f661415e6f1ec88e4e2e6b4a289f3757e5486bdb24c163fc59506473cdec0b35bc2a086ed37ceb47b734bf62060e5e65f28d8c4d8c53f92a63fdc828c58a6f41c6a74c1ce047143a022376afe4658cb6b1dc860b9fae7f0c4a1c7a6767ce02bfe555f023df7c6fd3f06e820c6294f81bb67efd9e548604478df08611c99230c8a11a18a09e8fc81f938c93c17b012df33216d01cf2591afe0a6668815e15c74a7741479655709d000da8bd05ead95a7bc92910efffeb1f678a6d78b5740869e4a9a6518e1b30597dcbf7e6d7dbd91d2481086084cebe2fae98da9bff7e8603ad5a0f6af479588f659621866b395b46ddc9c74d7f83dade91fb1c9eabeffb8f604a7acaa5e90bbb0b325874c2fd9cb5c4545efb7fddba46f10b3b195568062c399f4a8262936eeaa4a77e5c3f875a30f544c47f4b8c68bc202fa892ccba1e4abcac29f97b79cabcac681b679baedf127f0de75435844442f88dbe3cecbc8a562386aa15c5287c22aa5794e6115c6be6d854a2d16476f4ad7da439e0ac2e747acf4bab3de813a2c84811c519d5627d9f8bca897e05561d11e36e21e2166007d5de4a34267cca5dee82c6a5ac3bf643a66c14318bc928bbea3609885a8d919ed9a5acd99ee9006fb37bd422084bdf5884c2acfdb32fcba7c6d075056a758080be1b5d42408c52e71cf75aa1a6cbec4c499da52b569bb29101a3761259ce6002cad9fcfcf38f9b029b4d804551639f48463d35355a5f02bf9a44e0ecd6d3f4411892fcb15c8d8e2896c513e1d56754fbb1d0a2234acaf481892486b63805f8fbce627a38a35088c2712174e8d06b20175a4d4cc51a42508445ed957f4fa779085fe2ddebab8de41a6841e93bae315acdc8cee1e6b8c6ceb8757182543ece8d0b7469135825d0ccf9e78c20f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
