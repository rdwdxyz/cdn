<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d4d7c530c0f2f6db1162e86977086eec8a7f8f44cd469ef481b1bedf1a513df4ab128f4f52d01464b7b9756fc11a21ba0bda35d0d9546809b85cd55936f85cc7246206cfffd2412dfbef95294dbc4e6dcecb81e7b6d06b2f7836e2ccc2730abe6aa63bd5a932e652089a5c1062e706d321ea4b1ee8b0e8d579d5f77842f99e0c6ed105a7f696a6fa72c76fca6efa7bd9f5920d23cc61da78090a8e773a1bda2ff3d3d3956e63b070328dc44f9954cb85518b0eb9a3c749ef05e9f59f589d192df83f2a224a6d3d2ebac45faa86be0ca158c19237c4c86c769e8f1a303a52b0bddb36bf604a8db50c76d6f2b05d31cd8017e8aedea738ac9398922d312d692c1d32903c0cb199ceb6e3d64ceb61996ae96d7bdd073f62f2ce0453db01758f210e649cbe393bf44670523c848c62e91756578ecffe0f42330e40288449f551c6e7604a85dfd710d0a8a3b30231e22e85b87f562181b7e4264857778acaf7d92dc4c6aca33fb126bfc5561aa4428eaf4e788ff1deb9bca19469f5203a1e4502436a874b479a52cac0bead228eb686772558a751f4ad0131cfbe7d66315f6445f2aff444bce4382e82b1ec5c482b4ee1c0635de673b7e2065419173992cf4f9b35ec0a984627dd37edbff5836626024d4596c34ec39ec3c82e8711f8e8d0b36fc07efe8a6651c0f31f31bc871af1a19451449807f11f983c79191a1d04f1329e31b08c746477e80b63993e8b4fba1ef05e8b3f5e5f0cc1c2aaee73540f91b2ec0e223704455d1a9da61b68e6f8b61fb1bf087f5a11b7a6a5344a1f9eaa54d6cd22aa806eaa9fb84b800deeb9215640c3b769e28de6a7c8dcae74cfd2ffa37d2602c25dfb14abe157fdfcbb388908177a50f89080d3d616c01e67869a4ad5a6afed07d1b37cc2f07346fe25b885492cd1280d457a2d9f00a3a795967eea0f1ad3ca4f6585d34fc7492048a2156e12d26b28f7c617bc35be90526d7cece645d5a1d7a47611d0b5b6a67193465bf1e568b2b4e474ad38ee663f1f12dc3fdd402d846fa6634f844482e1968d5c18a236cdc747f1304497e5398277a45127a640e45b3a097085085d53a8b5c422f894d3c5b3bbb4c57a43147b719ceef664618898ff6f8002dd17666ce24e18ab06b7360a8725623d9124aa0a299170fcece3101d60015109f16668cc350cf8737489ffac33db43acaf3e6a9d64d5ce2218221e0eff9135cee2cf629e018fbfb7b311f8109998066f0b962a85b34be4b8525caf8174f34540f0bb41aa09ef2d68dbd8130a1cca451f0ae114fb28398f1189d9812264c5b766499c603581c3a8bd46d7c817eb76e133ab957c600b32ebe5014391e629da4ee5de3cc18209810027f75c793110d6f38934be05be792268d44b8ead14ebb298abdbe1f8a19f2a4598988b9d306f1e822c7d689b287e702e813752dc3fee4987363c760e8493ff38b9ef31b8883c6de2270ce3ef644888bc2c4408b4ef754e1ad0a146e02097e5b860c1eade95b287655c5470fd835e213357757bba2d725276f8c4b4bae1f701bf68303e00d8de03263388a2acf68da77f1d2c8bcb0ac5c78f6c398c378de475f6ed59670005a73eb3f9302eeeefd8b766ae35edc793ebb4c27ad127bc6b78682ab5cd20de4f48cd075fd984ec4bf94e080956fa18d249da1c87d57cc87e44ddbde9701b3fc23a3eb686e99123c34c64ab6594e70c7e4ec3621e486dbc09c84b3ad6e80914e91a39c11b268ca86515f1a59cea1ec8032cf6dc75e78b418d530058fe1571703d07699f66456bdfe9f713af7fc8438d864d0f9f35c7ef5624ec6dccac1eba2be695ff85042416d1a80c9b109a01de26622bf8f39e146cbfa6ca9f49efb5692883b96a86c5a14e89a0f01d3d9979ccf4f2fb776a200541276a322ad63b89233419ff4d52467a4de16f17d8b9650a0be66709e435c5998c21b95b4de53ad60300f9d1d4950e5087b2aa7b506cffe02c72886f0498c7c537ae15f198adad49ccf65ac829da2f81a3394172cd6690c15940e952e1dd42069f9d42e2339665cc50f1d6cb881231b701a4f47f3d3134223b2364d9f93cb379d94d5295345af57d2021c1e592d3718b98bc5e879d6fecbe85942a3ff42f91769cff711640da0f7e1ed89b73cad085b4366f5b417513c92a553de35ea0546cd7e4899d922d7ece4d9801b65f77c394a7852f74a903b41755898ce58196b223049d75960eda0d51edbd6b0ba1bffc5b7e94d6cb215cc8278aeda0cb0ebe1a9c7145e054385b724a229c5140cd4adc626090560faed179dbd3443b2bbe460e7980d2e616c6cdb5c1740c3247729b7b627eb4d8f9b0ce37883b6d9b4266402102db83c36f380cedbe6fbc9169b64b2ded14747ede2a2fbf76efb6cdf46496831443048dc6f4fa3673b31cb3ee3ecac2035cdec912c7ec5c805416966ba07f611f80f09d8b66679b2b36599f1fc7741b104c0a6e6bd2604f7d22899495fa89cc6eef909ca16123863ccfbb2b2d1609ee8fb578890570fcc34e01ae696911e66d5f442ffb9c1c57d93ac49ce5ebfd3f71347985b1cd27aa0d949f22151e0190a6e674b3ae588cae24b0c5106f08821c66388d581402b39b83bee725b037c1a236a30b4e45948d344582188a3baea648be0e3a0209bc487686b1b13e96e1902f8377e509abe84d0d814c1c8676ad46618991e292cd976b0fa635f8bca82a647f2ef0efb918c5fc9fdf78dbcdf51c1b8abf8cd30f038a5d3de05f49c9730af0f02214039f78bd5725f15a991485841fa11593664243cd2d919609b584a3440e897fbf0532a8ae2f68282099fcabed959213a44565e65cf897a4ccd70f41bdc6af86cd0b6cb86e44617afb6965b079787ea1ceca67a3c13b7eb9a7847efb7a90bc0ed9dfb4421c85c94de02c13fb2260f12398dbe30d2f72f0154605d94a290a27565e2d43115ae0b6154f632cb8343b05b8aeb432b875897fc03a4e6da5530b6ec692d1c497758b099bdf8ddfe104a71ef30b31ce9a0d750ab552b8a7e935025c45a5d934d1a705deebe993a75513be8dfecf25ac61ec9d545d918b164a9d99ad5b44e70f5e3d9db48bf222af1a522387df3f46821a10f6501d990a1cc447e3faa26deba009d65a41a427f84cb44b617f1af4ed7478f957b6489ade5aed06bf90c96d5a8914dc1bd235a0a38658c87395c26b76cf80d2f0e7a3eec72872a25117b5129e992f02264b671e0c5b3756934a98019861ea84cd0fcdaebcd4c72a0af592c9b071f8dac99a443f08ab72b7738fd730c86467668156bfe32f1161559ef9142bcd39cbf5e3c3d2ab31ba8b188cc81a2205857f04c98c5194f69fb83014ccaff8c1bf9f44651f76f590b2007224e37e56f87aa91db5b18a9576ee088e2d4efd82ee2862192014d48d280ef87aabdf10943e5dc79497ff7473deec0deaba9c746f3a02501bdde9e24a0f49c84ff67d94bfc2b87a5558f132a04d5ad58789e1c998758da9d576daa88b60425b0b155440a98940f2f6c95c2cdf3819e44ea2de4f8323dae9ca7adc2e051b67811587673dc902e0fc24d7d3bd779330d806a0e4e24ee54e74c8987b14b83791f601e64c04d600468769c32395b6c9e41f32d0077dcaa8eb50c953c229d78c1d3aaae352777be521bcc9253fa4225c83d5a7789ce49b0501ed4a4d5b92102b46ad569854a17a147de422dba93b49d088f91cd12d2f4dc5c3c2b6fc666b44b1bbbac11ce82386b2c2865b250c24bfb761708d862bd6d35c03bbd44dbf2323f99171d2b57036beb71d54ab5e9c94c24e84f704a18e44efd69a45359ff814bcbb08101b19b8070525a3697c8a7f37e3ca4e234ad577a1ee87bad801e512fc551cf827b54df600109a1525effef2d911f800d2eafb97af0d06df48927e8ef6e6725b7fc8811d1b649c1b20cf84aa99642f09b2bc3a03a4ba76573da9521431c478d402b54511a2dedd4b41fac616d570e7ee3de6e37d860dc78bd4522c1bb47591dfb09c3a276da5e20532753db613f8249b3b36b024421996fb93150c4725ba41f7b5e7ae820664e3bb097324b72e0d8a359a5a028c32afd97475e9242dd656827013301cc42f5aa48cf4fd30cc384cb58e51dcc4517355278e5277a49286b83a232256ce4837b8fcac964043354297b86b62b8a0ce68cb089b63f5380b828144a75b752796fcc0a8a0fd3736e5a451b8dccb83cbc9cb501535a972fc99cd148470809eeac86e2b04e3e55603526ef0804e20c9a891b86b361739bd9351df52f580f5f99176f923228f256e026615e38c3a92da8a6e40ed6c1411bc2fa769a0c97d2f78c6a4dfd7b647c17d98d4d024d3f23ff5957cf9b605fc7d32835fb635bff1a41c79fb6fe0d0daac673f5a03e54e7c958728e9c9def1362cb7c8f651af6f5869a1e8e54cad3bb6b975039c2f1c8cd815c7f7e103432969ab8720a9cb2b68346f3c923f63bf80ed1fc80dc9811dba626801a9860f65ac56bcd204dbe9df6f6e5cc6123431e918702194e39aa33e45a2254fdbe60fd3b3fd7513ef4d8e66810dd20a8b82348ec70adf2a97715dabf03960c0d4f1b97649403b1d0345b4465f95d0523232e782edf19bd4ed8c31409ec099cd04640415c85adad8fb1ac6558893578cbd7a1176f12d7d3a58bf30d447244f735b03c71da3d54e79c2d44d7293687a43540f7f80286f7e8fd7cfb2d3f7030de6e850dbc692356b6e6cc5c7cfbad6d66d22553206d5bf1d7e80af60f6e8d427b33a5c5192851e2b75823267cd65eba3c4a91d7d70131f7e3db1611e62658961c177dad07f1da0e835299165ae5289a4c0a8d0ddfa05524fc746c4582795543b24278844517edcb86b4bfa6ba3a63538aed6df8e8d3c6db19ab20ff2d3a94a5edab5071660037e949279c7ca2da7fb537186cd19e23e6d51b175c071a009d5a28cb38c4eae09352c1def60a250b9aee59269ae2822393ded30f4f94eecaf01dfb3abd5e175183e16e185e1e512807f76b24961b74aa945eb5b3c11905114fbe3c497cf0c459657196093fa6dfcb847b58a6bf08c4716c3078fcbba710b51f40044f585c18235184c9fc50db830678bbd177746b3fb723b037d06dab8c09da2a4e13539f79d9c98028831ed3b4af162e11abe34573a0d7a117ae26bb5bdd7d9c54667d1ce414165769158274650a8fe3caa19ac1003f3fb2a1b73f474aad29a71313c4b4db51c3a396cebd6c24a54ab106954258644d00d605b08f0b0c6926dfe04057972b8548285e51c4ee645df17ca9b9f98d1584c57b19f3d19d5b03c8f305457c4d62a1f9529ba83e8c1046306e66df449b576fc6eda3c4b3a9454b75904feafed042326d9cdd7c88ba41a19fbffb52dcd36f04eb4559039d5fed5173c1de4b106d6cd7968bd330be496069857f1ad546ded88836b7b3ec2350767aaf9b4635e42ee71fad344ea4d65c1e16b141b8bfac3525f01a7582bea4410239d964a47121fa27d5ec69f1e65d8f210431eaeac14ff668d065b2cac0cac930a42fa187ad6e8da9b083eb0259c583ad08698b5f7442054fdaae206bdac16f8223fc32a323dc2f53b6c3512f32cfb93f842c508edb8e1f81d7b3b52d8d6a8e0494e870141a1f346471e232ccae0d2b6f62a7de5be7728233b47fdcfb7115570ddce9aed72aa71cb804bc354cea68dca48fc5c0fe5f9c221c04ac278451b9a726ae7a146bee8f3fbe448b9a52a31a0618cffe4e840c49b293423fd930044e5291f054cfcd1bb76e7d3651546b7f22b590cd9291532e8f3ffecfa22fe181a8bcfbc8549aa0e8d23dc7a7e079537ea6f73a0fa0fc3d7dcba51e82fd85dd8d5335ea83d3076b7a2b89c00fd9a786ad1ed910455f04e2832fcf6144f0d0e6b8f9458d6d5f39aa0f05f477d5e2c12cd7419d3a866d2ce6619546028cb62e5839a17feb45266fadb6388b74b1198a113cf60ae0e3ac98b5e9763125971c40ad286fa22a25e343c61907cbca48ea4831df89e22d784295eaec173c064be6c1a428d84213f2f8112daa364d16fe791e2f11a7d13b3c908117eb1e0c4682b207dc861d650e88151eb04f46ee30be07470e30ba954127a1fd1942761f5b3c3cc403b4bc7924a63ae7479b9c1a0a8ae404ee617a2671eec0eae5ac7913f6975572651fd1acb0d970b47962af651ebb1a89c0a04f529133a8b57c5982e6df99736c9241239dffa84b02e5f09b7a3ec21f63adb51a2a87535af52880ff361149fdf853dc324354ee695fd0adf2d7eb80c6b285d7baec0b02fd412caed1a4afeca60fbe7ae9d2377d0846b052f95761e8129e596e479992bc120cbf519aedd1f0c8fd59fbc894daeba37aadc42338d1ac1a218cc8b75965bb4d5c38616733c8b6378282800f77f97c59c7173b23fb5dc8e90ae30832768b9b9b2c251b471ffbae7b11e7152756ba76728a062fbad929c72f390cd67c1e10c988c5b90812a4afa2e21ee00ace4361c305b88e9173eb1e27002d38b199f1fb439ca5c5be1b83f4d0eea93ac0f9ce2f333fb5fe53b71d8605828d5ea81adb6a6dbab42379b398863873002a5759efe5e948574db0d514322d562fad99215273010fb5bbd8086aa27e4022476849149137a62ac9e3bc9a28c190f9e065a1030fe185bbbf5fd7397028e6af9b623ae5fc740a72392e96026f03e596ca211457ab0b6a1b48b6b3a52af25cda370fc00b6e18044b5eaa109835c701b454a969edf265d6c772f41bea355d9ff27e0f676da0ab60f26a2de46f66cd3354522083dff30a1dc44e9dbaef3ed5c660d1271460def9b0c2be9f9452c88448ddc5d7876c3731121858e4dcfda668fdca824f819fedf1d3fd16de084eeab1b8be4cc89e66c9ddbc7fb7d0a3cec9ef91ded29cff95f528b8552ff6c385a804a1a7bd16516072978078e7320cb84e1614cdfca77f5bc1b056ce0c5a1dfe15ef39bab307098ade6e4696d9df8937b8b63fc42f0be28393e6eed5a0005ecaf4d60d0debd4acd63feae467e9a8c2b4a90cd60f2b3376cf1f62165789a92f9ee8122ff7c5d5c5202245c6b36e763e72db9d418a5e1670e99e245fc3befb64ab0d173ac9dfff0c337d32974dd668ca49ac13d08640cd60cfc709b8b523322db78718e1588cc741de1244bc6d7475146a959f0e6eb2cd41b855e935a1e3495059a2badac1aee15965f58a77048efebee240b6ddab71f5dfd492abbbf17d0a60a4c3c5f9f8249d33bbfd70da1e22af395bd18349cb3f3b72cecd839629bb8ef6109598d2c6f4d318a9592b9e926e0d86c0ef9d24d580ad300a4e7616d8ffefc4ac2b2d36333852ed6db56b006ddd7649b643b6e5da2cd97e83b4efb34badcbf59bd257e3cc4072c3535f4e9e5d160fd29b3a5d0444410b1809236ec5ebcbaf42e1ad4c7e06d79097e25cf7b5ab1b9fb4074cadab947f3925c396ba227506a2003a4a2fa5bf44c83535196fbeaeba239f847bf890f069b43dde64bf4cd263f79df1f5859c8ec1f37149bd2247444b122b9494962c615f5e0f70437b6075bba7914be70a4fa0cf10e29c21fbcd9d2891362b7cd77f76f03e731483d63f51ed335c2ca7e19a38876a1a3e3bff3b0455cd00bff9ac95af086a52e90d42050484a67cb928db6a0c32f2baaf3a048f48309ec3a110413959973a4aec60472f305477469d7268cc0e244a1e5a1db86b3c7d27dc8dfbb84d4aa5324306122be4d11a5f3918b773f64246a655973b49474a3363c25b20033afdc47cacada5ee29fbcc9b7d054248f792b7570ac8d889a85a363f4d14c63ba98b717296278b7745ac19a2b8116f8b646df2a5d60a3fb3a94e92c9d3716b57f0ea1f20da77c8a0af84f2fdb1e4cdcc1ca614e3ec9110565460888b6560913a76cb8b1046df4c2eef1ead9387c5b38c1a486941d03ac4ea158248fe5dca864908a2bcb7233465cf37a2ee5460bde081848e015acd6753a8f3a377b4c224e8172233b13d826a416024d4d96683a6d5f7b22627222cd5cc8732b8475a66640f88b8ef3dc0d0366db9daeabf4ae8241571e846362bb19a08a736f97a0b02f35efaf0a512508873b2007b78b422713583bcff2ae72bed556130bb40371c6108fd823b3b189b955fa3307515a3e00cd0cf6f79c75cb1885f29ec79f8872e11dab2f435d698e90ee0f837b9dedafc05d4bf415eb9ea4125a33790ebcb574545e92d42a3136fb2d62500de01b169f0aa1b1eda1ecdc74e56e87227b9e0901b9a55a17fc37701a0088e1a670792f437e089aa068264e8ad26db4375438736a7a553f7f086bb52c08f76c6acdfbf9fa21d48cfca8f54f94fc5c7897b62366531fa75029651b9b1e9a4946c8b484432d62ea839309766628b8270317bf9f23d0ccc6c37ba068631770028d5c25b3c040f6d9ce853be00a95e0d43fc279f3bca4199955e63ae3881304701152178ba8867475838f29ef90c2bb80f2b146a102a3d5fb004dd45b0917442cb72a889e2a6a7b0fcae70d3233a48dea2bf5e645d165f449e782090dfccbf9ec8d6e0abd40d2536456fc65d1221c2b97b5189a3e4ac654cd4a1c17ee222e3e8d86102fd12b6f4a3a8c52fbee6a520df97756b20125f06ae48d07242eb326873250b7bdb796f609d1a7372936a5b99911eec5516cfc69788a17d38e061f80838bb36ceeac845129b3485db6a4d3521819b2ec790c38f8edce30583f45212cf483cce5a9b81e9c796425f830126026e975a0693e0c98390336b9be3ddcce9149aad8aa60cf150b0f0914e3d0a8157282bac734b3fb45c7106d776138985c70ae9d3d2d8b7f86f271d5fa5460b835926c1e29729f8209004acfe20056befee5b022ad2711fbea9a0729d41ad790b3190cdfb4aa0984e5151c7b3daf799cad7a55d74bbf99d9a53e9b48c3b04711ecbd37c50dcd16b541e689ba51fa32d49e43eaba9c7677b9cad60b09964a694c387b81ce4ee2a9b777361bb8d7f21d58bb67638fc910bf1d11318f22eae08d6a9999b73a4b597ff5ff8a3a29e5977877409dd5ed8d8650a72d6dcf2698b09dc74cc23be27be59106db32aae76013edc4de4ff5bf10c0351080e15a43c89aa967281c35117d2fb475abb3edf805e23eb071bf0a29ddc275798a9766a44ddea6491211d295dba929c84353aebad7fcefa1d67fb1cf57d283c530f4e484b8d25495c74bb825a6675fd6af50e8c86c8f900b3232a39c10f6bd35d9712cd9c45f53b81a25f35e6cef5b43590e569c9ba6739fc4da50daf227e84f92f82ac2b678aed1e7c03bbe5772b9bef684673811b29ad0a2bea8f00eb31b0231f5e861f6c3b04ad1b25e7aee4056b4db7f88fb714fd843037e253d74fb55fbef75c2b41363eb6b2eafe111979a53a7fa197c7097d973dea0b8d7d45cede8bb978b9b264ab5e11d9f7cc1baa9331058cf58730af33cfcce211684fdd2240dfe53e8fb05ec12c55b31549d0e3b6a5e1435f3acb2df67173880abb1089762355bd4734274974150e2ec6465cfb3fedbb7fc0e17f4f68e9fb095fa1d669eb3fca872583a223512cab56e07e3b4726048afa16c7a2d333ec054599dea5a7af79991b7e1bd76e4f402a123031391c0c37c7df9442b091edb252679e5120d16d86b34ff4e7e5c88d6b874b1e92588a1a33bc4e4fb8d2474345bc3a24dfb54fc861adcc8560c59dab4c514a32f28735eb811c011cb9254756d0c96c4ef33049af4354280cb6d937344e0d47ebb39e1f006dfc9ebee1b42e7546a5c8ed951bd7f925cb4a933599fcc9eb383b0064eb442346b1b3657be9671f80f7f6e2c42af6f684ac9a5bc99e96cb7c8df0d777cefe6a7013ab1e45cf6e42ca8fa92192df10d8bb744defcafb99cbee0a0f9a8ca05b8422092845ce8295c3094d5c82437a1ac14e2990da948d2e017b1d26968f6cbde373ab9f9e03af0a2da5dac34f824d331a6a15df730b4e6b8789d451f0217b59140fda74aef2e75b63b03aed5c444ed00b3c71a3c8bcbd8e74a8d798e9ba9a1c728eac56b8b6d43e44b0845af656d5a170d886a4adc89d4ffde68272b39bf4fd371fdb2bfaf549066048f6c0a24619be2a9393333a351ac570d78cd4868ff9999d4d622af59aa5e94df4082802a07beb8c3b146b6d12f2d1883c81aafb5153f6a319edf9daa754e2c1f7580f2aca58f15b4d29d16a083d8f90633e21560c32b161ec166f15322b5f5ba1fbdc6d92101b66f1cf7c0f4ea0f564de883252ba19b84120436f5d608dccac5a13298157b38edc0a93c65f46ee3bd5d9a51b91768e2da27012f00a1c34797afaef517b5f76ca0a0c7ff8ab7ce6facf8bc2b6239b9574b806d092b0ec804531a940d9d2003dd87061773fb10c479c5fe3a892fefd166889eb4132b1197598cdc2cb1449de4506e3a10a8cda74348ff0177f20a9c5e9975cb42e203cbcfac82a2f0b21b1849c0c5da48b9bfaa963d50fd431ce1b2e868256bd3e204179c79b1ce755cad5c01cee619b1d28d0608601fa83324d6d21c792a0f5d008977c570b6bc432d833bf63933b6a7682b8499e9ff2c161dad60cdfc7b962061584e4de8b460c1e28beb7b4d948da0115164a6b741876a61b2f189e1b4c95637515a5b36d03b8eed5fa649f7e63c5dbdaa9329c8795f30e16b76d5a4cceb224b6144ce337ca581a8fc2435135946bcd5298d92d410a764f16d9d94d697d9bd600538eae92b7973ff68a4ea4a529a6e2f5587c696a0ca7ef305185b6a16a62ce8600f8a01a7b57fbe80844c503e0fa693668fd1dcb0d671bfa12b02e4d1f65c6dec806d2c6d905718c76c051389c0405985cfc343eda7923d66baae7b100b917956455a146f48c59664ec256efa26f722615008569dee57bf7adaff1da109534af1402ad99715a3190c245e840973f1fe5b1c74cdeb02a75697de3519054e7cad28c1a50db5d7d3cf6767844e8c0de0643a781d07aba3329fc175504d30c3df5147c357a056296c21de75c5e0577ad6a62336252ce02e7b27198d41b01066d0c1ca8d16dd7b66886691cfc7433133e5c53dfe079603eaa0f0fcff00fe6fc538502482b61016f12f8a938229bf5df4442070f3050c52b67b4d76118e8f742dec471816acc1fac493c16462c6ff8ea76c6e6ccc1543849c71cfe3bbc214ac46478beabdd290fa22d98eeac2c7c5ba9f53967912ac61de1b8d83f5d7daaf436fad028a4ea8ae654aea20d824e711754c41d35d5f0d6d5b2edbe973e9c1699b746c64a978f1c98d96007e6eebb9e572d57aa99c523e12486e4946714f2f60dea764807e4709bcc1198f56e5311f72af49d68b0e0dcbce77daabaddcc68df0fef4a6325b75db7b18abc2eeba344838aa5b10e6438513488f22cf762ad81268a53b429acd869ddc752530c516fb26f4ecd8a9dc97e926d2113356c1cac58eaf4c39961fdf7510a25320791a85740f2a2413b72a57581db1d562badf1700de1fcf57d9562644369b630382b079834e222bcf42f5058658fe4db3d7dc6632d4f1756c19682e297c7f14bd44be24436fa6056618ea0eccd18dfd50b6f0123fe4a0cfde80532997d6f8c46f79ebbe03a3bec724b758695382ab23a01294e1c466c452c9f05ca00015a995537ae517cf373c3eda4c0e1bd11afa805b066dd113e4221153002afdcfb5f4feb0fe3e64c23ec2fed91575b779dec0ba2db0371629e6dc7531c68009ab02043d62c61e9d9ff5a45bc29ace35d0e080a1f1941ba26a2a7a0571532d630eeca9d288986386814aaff5dcdf001899382d82ee392fd61d0d309312e6d60d7c2e7d9d1cc4c3efe8c189285bfec6a516dbf9489f97ab36e9fc62d428dc8708954a3bc4a8befea134f103c3f5b215204f30bd7f1e8ba42690d52196a294b9b7c537e49431c36dbe862dbbbc7d67bc427c6a29beef5e0b04f6785ff9b513d9a516d3713feafe62083972675ad3f86314845f260b1f27a462bbe60a23161165fb617e9a2baa5780736d0fe7a8462d6dd1bd051372afe6a144587a2d147edcaa39cdef78c66a26a3eb16537022d8eaee7b73d5922d243594b12ee8b1c02f5960fd895a6a676372ec868a5ce4e2910ffa8292110bf4db05a60f2643ed937b79137c4cc7064810d06c0795ff3684276f4258423eefaad16e611e690e619cf45eb34dd50618c4703da50a6e821dc6cc566226104a9c87c3098b5bfefc2406024e829888dea597b47524531d3f84e1ba41f6e832ac3fcaa454f1409385953a695b01837591b639680e121eea033bec9dcc6560bdd8f7bef972789a7d0b80f32716fb75628103dedca6ad0ec2f491f1e8deb3b7be1ebf0115b59ba7f197d4dfb1add7c865a5c0c6031fc4febbd60c4ae4a256fd9732a5489af6933b61182c474dfd3722496fa93ea9dfd4088d8b6ffa47f9433679dd9f2cf60e9ba3ece519b5e916877e6586734039343fedb57d52974561c922cdcb41fab053b46018bbea24efe6570e0b467847e31bdb627ca8d97abaa075f68789019a8366db2bc21e8ba915d5bfaa006d10ee3e6e605983683bff5da7b7cd85b31d21c5e4f05b1c1fe581813e0c76b2b3d911fed03019e9b37c55210a7ff7486f8ce1ccaa4a69c36e56e53f92aa31ccc13e0490922068920567e153c96e08b22f7db55e2f016c9576bdc1cc77bc492f84f15208d1cbbb533d98a8167dca388817b7fed3d55ecd43e3feb788e2a7bdd7f76105a2a1533e08d69cc208d3fc167cb2bdb50a70f580fc37bab9980737306f684fb3fff72b6afd472435c895eb54e79547afb0e6b0d836f25e51857970dcaede65a0ab500ace04fdc4b32a85cc1ce7327765714c1b9ed0114584d600aed5e20c23c053a03f272bc06cc1c20f4db02ae6a6abf2368848b4464956571d314d7dc159fb1d78a5afc5ccf3aafd647d27db4982a245735cc02c99cad9954ad980235e4d9fe078835f1496beb68a5fbfaf46d3767dbee1f1d1d430864f16f7bdc42085e5edb0f6cefdc505e12cf4d5d07c02b6d5e623cbccd292ea800c3fb7cd2691a5f6386332558aa4e928f44449b6f1785555d1bd42994bbcf04ddaac722d65980964e45b19708bc3d92716f50c9bcdbc64b0015a12f94876b33e8e38a85c3143b27da24d9608a363ca97aca7b8e0e553337d27555fea6414888fe1d0b99b4fb30d00aa8e4e961cd920213745ef9804003b835a2f5bc80666f74dbc86b30495c211c2fe11c8e1a9f011d13c0809667a22aa552f2597bc2349f65d1ec25ef6e678aba1cc7b793520da05b33a04fd436ae571053c496740f6fb07291fa045881b3f671a98306639ad103d91b66007eaf4551536d2a9d42163787ac55c04fb8891985aa02023a5f914d0faa54404735915349d629eeb0d3923ec956ffc238fef2e4776d912ef54f4e3cecfc4fc698c9b395c38b456d66b79c18674f1648293005784a7853f5f77c7a8140e58d769b1b84c4b814ed6452496e7ec95a414d5e8d69bd6392f8c347647972bef4becdb423c77390a84b1ed36aa7e9db4a922c2d465eaabe2565a56fb9f617d138ac909eb74bf18ac9c0002d77660b650d260317e4e6b1c9c4e06ad129693344f37fd9735ec1e6635fe0752423c294127e3610c650fd4fd6e62815b7be4af286a022011474432880cdda492c5e8c313d94f96be43fed7be52fb7efe0904999df58e5fbcfa821b86e8f07890e1e072a45e2464e50ac4f0d48f014e04aeb5a10351199600ac0a37b5cb804b86c5b175d06b0aa4065acc9a2bffc3e7971baef99a247e40648c03d3f335a7dcb81de7013dea9b4bb1c9417ec3bcd1996bef170ec5bbc049493d70fd60ecbbfdbebd8c1cd70a76e5cdf7f35aaf0e1f0bd0111b5a144956892cbc6e3b13ad653cf193430265222461edf01afd26ec0a23c37549b73917bf8474f3025710860087f01b39149335e91b5dab1a9008c87f267c3e7d71f7021977da9c59888313624f06fbdd686061feb14b17d6531acbc89a28d0a0cae4162e9a0973d1cc792b60e3aea8bcb6666105f35260925c1e2cc387bfbbc827a00808e329e37eca9831c6ff0825f1e5c6df6661b746352b37c1f9816ffbb44d86a332beda7b79d7db200bdf86258597314605f85174edea24b36d46eb6c3d8c4c457fb272216d533bddcb647cb635b7e869e9605450c3ab3cb6fb7dbb2af1afe63848a52c06228199a2e214a1273db9530230a184c33750c12a8084b2fcbaa8adffa4ce7cb3595c3d8c28f6626bf5d29dad4a239bc10dcc855f9511da292064a2758d21a3a091fdc89b7079be0f3874cff13aa82f4e2fc9979d547705561a51b71b6a8974f72c1024adf7ab3512f26cc7bc075d78dc72fc8d9062943688c65d240baa3c4fe65fd7e4bb24ff1d9c0eb9df4f0a57d0134ce4703b1a14b2089729d83b05839790593977895822aefaa76494fba9346dc8a1fdc232dc3b02e15673fddf003508951f2b66c650a2d8c9f0ab29408ee4380b4c98a71f4eec4410c2d23ec1315849f93d7e9f1002986851775c277a9f9f66aded332a418754718750ab1f62324373b16b744e4f86ab3b943f19784b722bd7d077f4a3d00696bca63c967eb6161aadb1268451e122333a1202465c4594625d50de4ce3891f2e81da0a95213f0aa8962f84fa793a33f20ceebaf1312fc3daf20d44d34d8009a12b0e73ae4e39d917626c152ebc025182ccfc687e6532e478ad840820fa61700df33f4752c4572834267650db3498ca547dc005ed87f4a859be99c8ddb9fb2401a29f14d37c56ad1154d554a4e48a6ac324fa3db4d4daadb23d192081c0fd437133d87cefed64ba9d0f235e3dfbb1630e89442c3cfd089b142ff15946d8d7cf6c1581e2d2a16ca6da9d1bea529b51d1a968898a2554b61e4ec6eb07a0e76a5f3264fccca08c6b8a6fffcd2ac1c14125fbb61fdc694741ec64a7428d97cc8034e14915802327902be5b01a5025fdcad3965a23cac4a8399621f2a76f3de6205bc480dd8ec6a5eeaf90113a48d8ad6287e1b7adfef53a84f45fc60c565eb6e646cfaf10ff3c3994434e043af7a148aa07eb177fa0cd81d863274b77ae57060cbdea4fa91b02e40533ad9ccf292e75adc1b72cc8ef25815a34d7224d27f40dde30c643151b83235688261bdd9733066b24cea8ee3cad44af4329dbeaa5e47489035992ce785f3aa421ba5e8a421ebfda123","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
