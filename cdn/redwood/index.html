<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c331850af6cc133d7783e1334fb168c377a10cc42056e5b106e1b6f5380aabc74130cd734412ddddbe1c6e667b4c87737012e57b12698a12be9d2f789f57e75e6193e5e845372cc6ba3e7d2c33a2ec78a682047f3fffe116f84fc3cc1ff3e109b7c2f1471160f02f9977f3193b866ee05a45804803fd03b64f04d772a280ea0b1905ff07eb392f523f947e3c35b335c4e67de38e024a7350a7783655d4fff19ec1e6f68940b3874db65111b4d4dbd66be4a14c18ac73554d142f32b34872442edd73299a2a3f7ae0e3940cda3c5644952f22ca456ecdae1d6f0eb2c177659523b180d4c04ed186dc40ddd4e01d91962b136be4069057ac88cd5c1163c137882dad12662c079cf8d59957b27d31f991d7b38fd46df10e369f9bc835aa4711850eaf3bf202330b7a1a0356fd0e225ab83c47477f5ea56f55bdd0851159f30dbc6318736c548c502f990d8838a60305065e1c0531c97a80ef9ad52754b67cfc735aa532bb402cd3cbebaee8f3d5a9391e8f4f4066b5032ba7a378099e5b7d734a744888893d3cb3217b12ecbfa21931fb2d20ad1ee4c71d70a52fba64f70220b2d14fd20fd14a0a5dff481d0f0f98015a378a14e23d804a48d7b470105e457973fb205ae50474f7039e6e83e19d6c133c8dde2a90332f33e2afa18a5a3c5ff0a5c6b0347aaf4a8d46a2c365cf66e34505ddd62bb04effde74314297555a6da5315ee8a11f374f00496afc87acb7a7363a63572845b692980f1799f0decbaea53d0a1530c0b456bf5f97c2e904bab21f5089b55629515f7328ce0ec16eedd5617256794c2232c345ebe13ae16c598ec5c52a7adef3da7627b466c57a8b9ce7dd4116f9252ea6a835ed61bd7da8f0bbb28c14da1d579372c4e05ed95362a05e5b53570af5e7c3536f29da313c21efad9c5e90d5709a95fc9bf5685aabc8fc077be72b09d82485c2efbbbf4e33da64ac34b3f98bfe87d62ecb27559549f02d87c3a3c747a80e791d35b9f6e04690078865de42160fd47132eae2d80b9235ad84989ace1d054add6832b91cecdba447e06ec16cb2bc7400e45083a39647da180842f570476426a2dc9a5e988a8eea68d7267dafbae5f9f7a56cfa9f1c8a79b30896b6751c07c8946b0dce4ead48770af76fdd5874e321a25aab053a7a51bd56d7ec2c5008836373655cd8d2392a34b42e80da178931bccb26bae539f9d0a5ca7ef7be3cdf87ebefda92a7e6c4acfa020174a11cd329fc2dac5f3b3c49b261efec6c091aa03dac2e5fbe1998c436113f3ea0b5f457c763cffe6849cec59128fe5d991105394c9208e324c1ad0c58d8367b95f302979f057ca84c2d7d49392ad5ccb90b60d445aefc5b13930014e91b0cc80dc6e2ed42dcf2f82ce16ba35f5fe9dc0d75bafc04f90ef0d5dd7a5d4df8329f5fae96d80747258f6f1f31e5536ce9a888a1755e9d27a6c439727de7ebd343f7561f508eef381c169da44e03dd3df73cf0b8e0b6f09369e678266a2303bb2e8ebe2ff9d5239c6ee7113400c93ec905eff2a8c2a60b1d90295b2c525da3c1ac0c4e4a44c45459678c8a4348ec193aa950334b084b826f5d196d735eeb7d9b281e96ec12307dacf4bf1cc193e3be44fc119fdc82d9b463106f6c8e9d5236b7e90b93b8c85749179d8c883a98944bc986258f42fdf148ada4d641cd69378ee75f3c587c02f933ec2a5a6352b9894567fc485d8d51f2032a512b7ef05506ebb3170c83afd52b36b70fb65a04717a7c2fea3b17860f432f0c7090fffdad008c8f8eecbf60107e85dead13e80ee698a61887521f99cdf28393da099efb96d2a5ce661038a53e10f2d842a8545e788d52d7b3c861e2794f100ef387415319044affbc216a5c5cef2d9fafba879028cc5c9177f17800d25fe33d097f2c9b1c660881b475150406ca6c423a4567ec9c498abe27b1ff0edef065062b6456209481fbf65a6f5552a8f4562e6a27b4bd63cc08d446d5eb3693fe01bb2f4863bc64f3b3bdaacf7e2a86522f29c6ed59f8ac14843886d39c1f0984bcc09d2d71cfb6a39a9dbbf7042c8fb1f35d8ef4f6f0cc8a5250f77e70e5653f9c95f52fe85143a3543a4d6a930467493690bb4ccdbc12165b92251694871accd96526aa5c1a456c20cedd14ac48ef9c59b367ad7b8b7cfec90d4b5ea7b99be306e5c1d374537ba7c32d1c28a41522de09a27c85202a42a3a2af5b3d1b7acf05a6a08d5ea7bcd7d9de661301236c1a7cc6a7b6ee57315841682fb9e958d74479a6740cb1eedc3bb4e3c506974d6e1a9084968308cb824b093bbcbcf866f67b290fbd3c9f691f3df6fe77cd8889daf85ff8368e4a1285427de8d072e667602413148dd6402adf016cf09a63957701e3353d6bc452b351a52e3905979d1515dbe526d68ea53ce8b4021b820afd0c5f8a63c527f91af46eabfca1c26b331cb7888f4ea756265a50e58c53f13ba041cdbb3e11ca9a1779383520443a88124fa37d492fffceb4df09596f54a77d56bd44b93210362f972e2f73bbe50248301078d67b094710014644662fe3c019bdf59f151d2093c032e6350bf18ee7f132520ddbd43d1f950bfe386e789cf51bb550253712ae297ee4eb6b31ef2df76a0db2838ccfa615336b1b1ec2c8eb6a86ae0dda8043f9f1f66da52bfc9c1deb9b5087439f5cd3e501a3315e552d0c6ca3db94b59e6ac8fc19e3b9dee56bd18f01025e8ed592a3ef5a85341dc1d6e23e0e2262cf4d73658920f2769adaf1669b515062a56118d8e79467bf64ba18c8167297f331b6db6ded84f6bf96133a29f99b723f1bdd6c17a278b30e3178071ebb8fd318454d6cb4a6dff159bdd5bffe0494472bfacd23e0c3a722e97df02ebb801fff186127a998990a4781ba273ea06c9bc2008e6451b61d1860f0fdfb37d0aa4160d53ee4f5a3797e4580b5631a773f6a05c5c086b46f8fb39f00d2079a7248717199790ae494cefdb86e73da68473db80279a504ff530ea99ea45d3aac9208d3be11d705e7e2f6433273ca4460731cd044e1f6d05287c390296c33bd15fd6d005421d8ea02ed0b9336fac6bc0c9e8de192042eb4a71c998d82ea12060e9dd1e43f7671c3162289962fe0bf1d157210f5ea7c647ae7301a6c0d9928a16466673a595bc07e6a691708aab82b68307eed062d1c4d8761af114f3a974ea137de48f6d9b76dd2a1e7847d73293d2a062df17dc0aa74df87829dc28a7b10dc34ad0b41353cc6e302954d096a2ebec0c9441352bc980c61d20c5a5b086037c785fdf5dbe8eff801b54621aa52c8bbc900faca5a1b765fbe23dea6943a95ce2d105ba5533982539b1b9fcf0f39facdfdb77a6a98b41c4e9a45261f61c1b35d021696e5984c08957af09812e354d61e8dd20639ece745d8242a4dfa8551f18060fa65866c415d8fdc65707d201efeecc20b4d27738854bf8a99b81c3dec963a4253c1e270ddf1b1a757ae66c002af779a0d6fd1bed589da000a8962d531899fcd10c7803b695539a504a8413eeef123587af9f3ba61026a8b2551e3cedcff495bca8ded65d6616e5a5c12a5464806047a37665d621b53b3b266ce6aa4d88e1c85dab7d489f667914bc8b4f67a3b0c56fd27cfa29336dfea9709cf4a15beca7b995ccaa76a29eec7de2b08ffff29f36b99e1f71cefacc8382195682f605f8b8f45bc9a6bc19176a86b2e7b723800da9f493d78bf035e7a764888034e45647fddce5fdc7119b6df69bb8dace58baf80834b1bb44f0cd6528dc81d8bbde168c1ace90c4f29ab895e8b7a347bdf513acf3e34039ca88339fef8ad36a6f921134da22da05d94ca558a64abdde6b6876306cd276bebdbb94718ef32cb93460a35f08fbd5a434e936f7945779b76a0f82fbf1f2571fa7b713a11cd67255119a6c333bbf34544c7581c1947325bfa9aa06b5997ee7cacc78260d5c6edce7820af7b64b3963b725f234c9798bb6f2fc21c56f6e99620a34628bb8363249a6107dc61da91263aabc14c6f67b8a984833d49e6e5d5f2d6a46fb551ad3fce37c4c4954971df42830aa69fd579e080a448c31e3c8b1bcb7bf213a302fa0a0ddb074d6f46e86ec590ac1abe11aa53b5a05603529b1bb4f8ef9d2d3e4c31bc18c022ef0a6b34c5f613476c46b13c3d933ecce30a0266146dd8aeae73a20e4787c5e908743520731576c1e8d8feeb60f5e77e65dd00a99b75b207ad64fbe660ddac7a3b268577dcaae2aaf473fbab2c5c7a2cd4e2a11501a0b9ef9a94f6511089e045d229fca03b1e1a93fc1414cf90f1ccd6b181f19b9f9814a814a38bc86db38e0c18769ff18764d5a9c69a3112cc0f8e25ba4bcb8830833f3f1a21113eac545b25e0dab45196842daa107c2d46cd57b6e2f7836055845ee3a93617472d55109d27fbc63191384da2922e82accf6ff8c2952970de468a50332c83701d03ae53dc4d6620d1f2b476122271b48679b72a75a77083f1d03c0daf3c342fc65979215f0424a4c5730f81d977a2f73f0eab56d230b853e0f614fc1cbebedce0d2dc6d65707f389e9c782832be8471020e8965119d934bd4d97b3e01e640fff942d679afbab50d92bd97d21519278b2f09f28ecb55761cc6adbc342b500291bbdcc8144274990089301701cd8da5eb5f310b72fc2bd3fb54343e8422dd3db289a3f68912d37356b656e2a9cd309f24fc7c864d4d3f080da873c61c9fcf3c47e4b053cf29ee018e464a12fa5437667796258a6131e69fd67b3d369019eac4860583e5927d3741165dd8b4dfcb191af97449c6ddd8d5a37ec53c392de1e92e1c8e1cd0c3f20db4cc70c9b20d79ec4926234e91d426876e64b3e1ffd5d0ebceb6dc7c4aabd32d18beb2033b28dbd2bee70e3aba9a32ffa18dab4376612828b190769029b224949629b51d1893ce6c7b081f5e69a81c5c8accc1d3471c35c40a80b056d54241889d05f767d40749f9b12a3ecf1399e232d10c0871e49fbbd4748a43cafa39af2dd3c04957f97571b7fdd842d30b9b52be9ffc5ef50d360bed5aa106d262c7d9d04e7fca475fa90eaba639a1c62c4e82f406e349664d8f2fff6ed3090d72ea70ee22ea8bc4b05c1c8455637c4620c8a8d5e110a7edb3ed3679b76d7ea95707afcf1cad704f76d0ce2d721c1296a70a3c416af48d62e86b26b027732f21cb706eaeea804547712699a28f6801fcefadc64287603572c6774929bf7d71c635508be46b8bbfbc987824089184f34fdfcaa97616b0b736c489d0676245ff17f8353e75cbb05a3667388e9b0a7b8a7e069c87d2de95ff935ca60cbbdcaf41ae17e06da57d1032d25a2991d806ace61bcd7917c89831f606f75d5dd9f6874269c5e7fe2e149a650141b2109dd057596b6737b750e34e32e91135bf62f14b5b2b16087fdda9e7205405d4b030186819c739c29b2e19fbc0eb720d14fe9d168d7777020d43043639b174d0ded46012131021b0528d8da0298aced78a70e419f175ff02317cc7f9734504e7edb907b9127417e5cc67065b0da17ca4a6923b3d4fc83951898e0cb3a44969bec4c2878426ac04be96d2c276907552e37b9caf47b60a8a847c1c7a05be65b1cf4f0f431838d39c376764c0a39091ecb64aca6985e2a944e46c807a949d1892faeb94742fdf7c5c7ba5c2635921123486a5e1678ff8c14e142dabf06935684b1ccc1efbc2287c4a3b5bed3838e437d620e1d02a5e6b3461be3f0794005e90704e6da9ac1a97ecfb56a19f7980d6e085ad427ca54563e4904d19ab20136be804b417dcc5f483ffc32f6298eccea2aa06a7a14784ff20fae09c4ef3ebbd974f27ab90288136a18d7d8d28b6206a008a7fdbf74d41b2463d8f698417d957bef56513723612b143949d1ea872c87bb582d9584a549afb63f3898dfcf91c01b472ecae4728f642bbac9edde539a5611cfafeaf6b51154bc3fc31fad0895c76b02bcae95cac248f2996b7bd7cd3e6ab3336745688ef015759ad9b0813ad78357940e259306483e8388d57859ded33325a3d325921ae6b0f88e96594fcaecf8b47d0f98743d474bccfcd68875d36435dec5dfac45b64a32f305e2f3a82775adb91b29219714766a2f7824ddbf2d8967d0faddb601290c9523e706822186051bda43d11782fa82373fff1708f39ee4e79d13eaf0d96e59cf56503c2aff5a723579a58367ab10ab70e6267fa9eb81465e5edf435babbe6dec9bafd51058a89b8231cd430d3a0af2b7e9bf28d9188dde7bbdaf6b4b375fe139d16c0cf589aabc9f55fe539336aa79540506af318d60a3077f5062b6002fd1852b6a1f8cec78258620057dfafdd00aac759035b2de9a871b7da8b61df2cfbc5610f5245c56a5c44767138aedbc5a15921fa79d574cdb2ce41f93b32de537fab313c2530a930763493f0263050fcfad2fa2ea2906bdc0a9f24f1747192747644529ea5f55fd50f05708ae9a819d131f0f6d558bd3c76028f859e9ace6615ad2100f05a5c356868e1006394b647d5b1d574d4c44954d5881e032f67b1d08b313d0074ab5fb57da1fc984c67569c6cf806b70d8559c01e126824a2c264cb74aa0734fcc018c337a0a7bd14611a787050e65d7bc7965e4360945c8efb64ab5923206fcb6907bb4b5ccc46d3c716efb89f56173e4c4c0af787896c341035d398eb0ec02687f9ac06c9e21495d1b866ca200474157005697b5a23ce5455170ec4f1905bdbd74228f2ef960892c62d37d4dc8358c56a74d220a539ef013bc0aa73c7c731db5a37556e6de3586e189060b984b8a2edd14f351726d26edf7ba3c0cfba2e0e35a8587477cb4b9b4aef015f53f82b02986d1f378088f9af36de3e8ca50d5a600a6bab72a553f7239fcd50a28ff4c6202c529c3f28a60a6de5ca9b17193e6ec49ce567a635ebd581ded1f020b26abb757e930336e58e856aa50bec7308e805fa1b84e7ac3e7410f71693830cd784208e0a8d35d65ba409dec1fe297c257f6b3c01f01c5ada662facbca9467561e97957ec85ca47cff69bb8ab3fca8af0dbb62501d7525e5d1e4cd4be5ef22b27e5513c5cceb70d5e31dc748b68d6267362db4052487685129e06459334368ce31d74920246eed2685567614f1b93b3da7733fe182ac05705ae37c13b187f3c2554a86fa141f012c670e4c7709e556450d0ad1f8a6983ea652b0f14dbc047f8df0896ede03bb1ccb986d067f676310518ddf9ac9d56696669d03a4f63546f69c04f215bec85159516c5e09e74c279dbf8715ac2b5a145e01cabfe584f8509751636d8f4720355e9f8072c65d0932575c57f6cf4ba228c4c222470b2183f62919a21f83ae98309b427e8b4acf4ea46093b14b9188c31c1e6d5c73b65487c1bae2b2714516b79617e8e628ac03708290e6e6f6eff5020f3c9a217c5caeffd496e7e32e8f62b1086ae98475cc03c2f4dc4c2f3e6b7316288b81678c977d8732e36e83e8a45e0aa2b172c4c2096497091473bb2f9da0517f5e43d167bdd7d6236ab29caa58e10ae0e15a6e141564629c3b3a36ad69751ece4c18c2f220b0fac8f1cc3e0c25bb46592795045683b870cba19f5c1d4c5b4a60a0daffe9bdce92fc1ff0196db9c356a538fe0c36d6da2421951ee1daf25d97297dc91c12a6b635143bcba08ebe82917b7e48acd6deaa0d2217445879d6e39c8c37bef5eccbff76bc6e35c8cdecb7f373ff62b2abfe69993a6983461b2102dc66f0a00cd4f152d2ce88131153717f04e597cd6b67d253605d31495792b4c94ce9fb7688cca88b6f80c2f161d50226eaa8c334a05dc681780a1354250a7263bbeea75e1b4cedcc3578c4e54bc6d6ca0ff71ab037dbced4eb66c03999c5cae63436e7a3f51657c492b160b5b13d8f637546ace06e667ac96baf72019a17dffaa93b50350e09137039648b11b1b8e74a88e6a1e1e7f5f77f0b9d12594cfd8e56805ef229c2f0b5112e944e431a5ed84b639923c03bb73c9bf2458c4dae7cf619ef47bf84196bbdfbd22b91d8511eb147fba0c0bfdb03a946802b68f66499669608eee18ba86d6c1675781b4959ae033cf2f8cd6a66b5c781d059f109e244b06a72a249b387bcb840018374bd5fb9993895c22af6d45ae07bc12ba56250f18ebd1bba6d4151591aacc71d0c0e95372688f64ba43462eb8fa3aa907a8c746fa7d545dde73ce265c44f2709efa0a272b42598a5087a1e5f9e122fdc9369e995ae1aea21cf689e1c73316740c9e7e7a0af14ce5f61a01ca4e06c7fc93c308840733f4690ea752375e085968867ef1010683250266382a28a777f68db3d64adede0cbc146d3896ce4b6f91f6569955579da4f5c587adc5eca2c4d1a27382a3ed98fe13e4f785d177840cade6a2aeeddb98953b12fb56f450843921afe2894f85b4b9ab384590f6546b539aab92801c698cf6158d6a759b8c8893b1abf8f333e5d32445ad2d097cf6f7e2038eb52be579bec5c42cfab97a287f2c6d1f1e99bdce70bb380a0c4c4c675629db72adbbc6f05d371083579f6152d3068951fdd44926ce626b6b792fea6d08daf8010e23f7d8c8b35ebde28aed650180bd1684e2862f618e585066a9d4a8c4e5801ed1fcabfab860735cb06ff76b10f1baaa040cb197391e5057bf99778504293101a79c5200cb78703cd97505798c8e67f54c20d2ef7322363311024d5a1d965318fd37a4e4b822aec8bece32825791f3bfdb57f30ddfdc33849ec679aa146ddee1777eb7f37ba29de4a79b7337a197865f0d5240ff57464ec5e4877359e195a5c22358e91a9cde3649a543b8e490b2051bab1417a6f66dd7acb8273f9275f8a2c7302eda0dfa7ec479d963e1bb51a46af64e8d1a6f9cc7a779815c910aff333c7759fe39a408fb23d16efd504cd57bfd506463db4e4695551d31a95707e3f6cb8b7451456140342ac662b7aee45d31e820dd2f5b078a40754fc0226d134b1dc19680feb52eca2ea3b8ef5bd701ca7dde4cb6d5a336077396309284d7ea0c4d1f70309baa037f76b800444abdad9852bfc6846edcbe9b0dbc15f66775fed8375637e0841e3b8cae8adb359eb381a93bd80336d1f025d0f74799c979702bd3621bef184326e128f113f2aba4e0236018faecc5f10c9c787e005baa6bffa8e12cd48129aaa503af03e48e30d93fd8e1897180cab91ffa2cce7d46032f0d5acb529285b7b3965952507a4c9fea1f55ed113089252ab7368846581d13462a3f246b3da51294f8852f55e2b5df543e3f3f8aadadb516d396125f76f4b50a11606ca7fb9a9ca0366e4433b51d3337ba22fb620c6372cf1739d1af22d9636ba51307f965619ae6d5c36808c626ecb815c553c9d419b6ded18c48bca655a510bf7df4f6fc23b833a6cb81e10c1515ed5388f1f8f5453b390354eea2fb966329d66b318dc5f3e71d7eb487d3c9e54a5ca0afd7a1463faf638f22f071b6b6f04828e93da395f7d1bea5ddef0148fe4233905d9648587fea3f263132da23d76040be0a755f7ea694890837d98ea287a42976aa99a9f5b550a2193faa61deb1842238dd737d292a814b523750ae2a5965caa13f9c2b17f2eebe16c6f891be8f3a529cfac385580d7c222aea3742a73af5e38d3f23cd6f90db84e3d34a7c6a5aef6ea17acb3e1e2e6247ed714de995980f4de19618aa3c5d10e4cbca15ff0766a369d9285849c1988d0fb8d53acacc295803d36655a1f21f48f84092d603f6774cb0d65bd7323e3d82493e21b7c4d7c0a4ba912b6b3b93ba309948af6d0600de46a98b4fb31f9f63fb45946eff4962f4730bce5bfeb81f310b705d7a63204798259df0b9c55b944d877f870e07f0331658c171d08e467b7c177f2854f34461244e04723d834aa3e28010b0e76b4d764a94472c902a7e0578ff8eaca99c80e4dedfc469eab4628bc6a8f508ba60a579e4b0029f0964bb7e903502fb88a03671b4f8cb9aeeef2d2f0014da244fbbeddb32d846fec56b9751f18752a5078a8f80b03d58b6c67eb18da58979f898e9ad4c77ebf81ed15558e1d36e97ebbc5bb99e6307cd5fbd1f778cfbd261b7e42be690ac3d7d0342359048f0db5a791ceb565e7a2276e12a0400a48060aa20156e2afa9f470ae777d0638a0f5c35b7231fd8240444774b30e22661ef7405cccdf05f672867382cb2f3e449b712315078c254c59873cb8e0b43caa5da775b65b39f2c831a6377b007f098e22e54afebc3809556ca15af0913b59ea4f303594b6e141306f0f9e0d122f9efdf9e3536ca70bff6b1f6f77b8f8db3bf71721d620918dd8f9c3f753453a75ba504e5259e4ea8cd611b4f6b4961d85300e8550e6ecae60bd655a77ea68a231bc9fbce19a8dfb29abb5b1fb3148084db7b30cbe8fd5c91fa367692f1e432cceb7a3b5bc57b48ae4b837e73d1b24af34cf8b090e6e5681515c130ce3f5a50c392a76712ac41f7bc48096b4e0e0a50099bc6000ffa51188a71448fdf37e8c6fb11782c85e805bf623ab41435920481cf1bfc34099fdc62261bfea66182b8e5c410e7428d0e954c3ce6ceb841fec512a5e5655432656ac43201dcf92a826054e25ad3efb58285bbb52dfb24f654799c2d89bc76818f32768a3e1e6dea726965bfaecbc03ee8d9a946d1ef1e401566e9324a0e44ae2412bc32d02293c2e560b3743e83f6f05ca4980a5f6461ff3c966b67d5b2b150e3ee8595ee4eb91c797a8cacc774145c7d230d757346bf7202783b2ce103758cc31bdd810c7a837b0bf55409d2f669789024a3a03f31d3d5b49ab27895b415da88073c509f141b0e9d9bd3a491d490e2b89e4223d8795439bd7f29b0b8bc7bdea834fe3cfc0755626e0329ce796e7f56484f926ec383dce1128ab4c291d494cf9b798fc2a99be4dbe080cad69baf1549a520a44aa889c769aeea0f25d3bde709587faefe4f34bd4868f7efa9dfe8a61e5ffc9452d95fe271e28b41add9af0c89a74f9d58c757055af90e745a2f0ff7f449b65ba94e880a9870d7b9fd44b921f88d78b3ea50b500995806fe291093169e30f99bf75c3a2393be3b2e52352231375c91929a92eff37d4cf31923e1fce8dc3a33a4850692ea11b5dd78c7e9deb37e6557867b20606918f58f3caf454038339d33fa221f2c7982c859c0b5e741c6108970f2a1bcc16a6a8cc9bf34ed9881fa1ad31c48cd29c454b9f88cf28caef2099f1bdb96bf7490059f19727a6c6616ff94198ed1f4723f3c2cb3e435127277393b99cd27569517d51d5eb0c3f4a5084caceb667af8a91f5899c9351405f874b88e334f629aeb84bb6625b2480199e85e51e21505f58b36d726ee035137a20ba6167d1e0b3649f959a3c8c4bc595d68262cb88242cb33ef3ec395a23c37938b67144719456cbcfbbbb16f4e334474b3d2ca8885e858ba42d2f98af4484a470c5106d005c51d2c9bd62306a1d4fb67c47ff2485b87d8a443bac6eb79d76d440eb37b6677391c71f09fcd7c1388ae7cf745c7653ed76736224a954972935285173ccd0acd8bee9e80ceeaf7712c3f50c995596b604fbce86b6a3f009ba42f2211921ca2deb1caab0be3cbd38cc218282326d80b1dad914a97f403979546bd422f1a9401ad213b49fed82912fc4a3d413f98f3f18a387644a306f30c8c47b4a34d33aedcc0648d849f573d82110b5148ac0bdd457847693c3c971959840c5d97b4160c372d1de015d7f0d70e4e26b6199f5ff5499d61c466637c43e7acd264bc5daed04e1d37e829eb5dc7d6d0b2af5bb8087dea6933aed7a604ede435e3d43ccc2555cf5412f92eee93a97979b8b3b35f3d1e1faa915f883ecd82546d73af2292eebc5750a218a841961d358903dd5aca8144d595d40618cfb5c88dca9ef388385460cd1e83db38f1c81c4091034ac0333b8191a241555a4b4202a3d542663169c4ed268c113e4ccd94e8b7e1686e69b981ab9a22606962d1ec979da253785b646afa402f0531068cac23af75acc564d8981680e02102e02e5f42e9f94bf6d7a83522407d1c06a7b3f1b31f8ae4e7256b456ff88c280306e527a7b438f60f4a7d393d58f77228cc86cfaa9bd99dee3378453d728bf9a4d6c2fe93710b31a8fbd56c48716880e7e74a13f1869487068e0ce06fdde2fbaa70fd8f31d7ac9982cd6b0e6f8a47da5fb186f43fc1ff75f8446c729b242cabbc1b2db10a02621a7b653770c48ad6b69fc8320a559d43d2a12ec976e39519341ba4b46d74a97f307a6d67d43d3c12a3990606f2633efafd7ae3c52aeb61d5bca8a56d8b4568b2da00a7e0213d881f3190e9e90cad5397e44af6f43cdc760ef548189fe71648d7828445cbe8cfdc19bad74fe8bedaa2042a63b0140ee11a0a6a5fdd8dc29c2c59dfb3514f2e623c3237f8c99d6489b539c872831af77d2514c0349583c6b4f50447b66c55614434196ee8213315a11f4dea43ed288d6c7f6013bead31f4e16f70ddb4a04f05e84a6661bfa83e6de21b103feb8898b9f596fba7a4aba3b73fdaf9b3ba44586699aa54f85a66962a4887c8c60fc21c286189f730116a3d7ae2b31d152b0faa13a723489ef9f653b07cf52b008353963e9d26494c422d0bbf76b2d9ea050cb1f5c2f07cfc342cd9e2ac0c8af4eca37e1ed1ad98ab88aa69d9633a3cf20c9ed95ee4ca4de82846dce2dc06878d44181df95eb26e2dd6f7122039b78e8e164abfa68c47ef948d7391741acbcecd8fcb43f3d638a45ba219f4342845d8fd535a3363e3e90df28b0b38cb6d3f02cbd66d228e905e7a650d1baafe0f245d5b3e8fb862ebaab17f8176e0a221c22728fee96c9e7a9ec940a24b54c269e5da7b08ce0b070a8ac9bcda47b20c69fb3b8af589613111a50c291407ff872552bc5640a5ab1f6d2c7b8d43dc3e9826b58b55259adbd0a3333cb004bb630322b9db9b8278e18557823d627ce8aa69381c658ae8434f6ac2c20977364c23d5907f535f90fcb0891687f9952d9c34476979066da7c8e6cd5522f152a170e412756f98e83e7625dabd30b6e78ae06f4d27f8f95ad48885c544471bf045040178299e157db588845c6e81ee6d850c127d123f780b77d3f9c3f9e13ebe21bcfd19cfeefa123b0c7da2ce7e851539f86ab90784915301f43769c24372bf54e0b6342dd2551c4412a1629916aa89c9d8ea1740115cdb4a13f7067977b105cec91dec58f370d63a484c83f1778e5ccfad4d11e318fa31c46a8680d9d28772331965bb23fdf99278f450b9375b97a47a21ec5fbfe6e3d0321f429fc121a394a09737fbb42c6d619c422210921228ff49626c7dc15f494a381f1ebb95874c866b9568da4457ac716c33ad2f5ed93ccbef9da6a100775f056dae308be79d22f5b5d2ba586f2ba17486a96519727e062e7fd5b02b5aa730e11b109a5777940d2a967212303c7162b8ec7c68f0e618995ee397a5bb5cc32d22274d47f4796e85132a8612a9ce8619f777e841570e422966defb8a3f94d964cb0b220062eb5c0d60f848097da5018af2b431fbdc5a91b86ca1a7751bfaacb8f9039dc36ae919bdb73bb794ecdff8d59e14476b167bbecd31ca30f38cd1becd6d8edeb4e6ed7fb4071f0eed3d6de3092d33d6b342235dd8a33d2f59184cb58c480514e19c522563a8dfba8c1373b3307145f429fb9d4a55b261b73ff24af11a782fc3de89f6934b07c7c8b4730ebaf5d80c61751978b6f507ef45ec73b64a9a79cc55838b577883834bbe1302ddd988b5bc3e7bd08612c4d5a62d66ab47d3e9bfbe3358a42aae6dfdc1a330cb128d91b87d90f23a193c8d0692c7a0c034ae86b5884b500bcb8853f1eb84bf886b0e103adbdb647e0108c24da23cf42e9e70dda083c86c5d44f412ba217125795f1965e63c10a6abd6fd70584d063a79d59d99d945f7c5f7249ea7d55a409765c280c72f34c5645929c117456f34d71d94c88c9beb20c4811c89f2a0404871be20e71b6b9c42b6040bfb23faa567432274f14b05c10c5f367c4382f45d9ef6a5b13e69f499a7b71a756f3bcecc3a354f17c2952f11be5b85543221b784cc8d7f646e40e80e162a6e8bfeb37956a6b2b3f28b1e2e2e36e36fafee74de7fc6e3584043d29c5f193196221ba9c26565efd923b442e556d12e8091aef85a5bb2a148bb85114325b41e9ebd3a4605587945044d015051f736828f2c91aba1ec553fa9d27454c470fb50fb1a062bb725b4ddd1ff722305a3b4fcdba337150e338c0a891729536ec99f0e4bfd2e2bb1b8ce68278441eee5afcd722aee75233d368856d1eca8da9c2018c877f43e8cd6011db3e1797495b0b91d5a1b92328672354969b0cbe80e3229066eb0edfcda36010345d09cc517db94cc9a625670edbd98c510f25f30cbc380bc7a06d3dcd42307ad5fa57623b09fae2058a7e19a494b8a7af55f25ce343818d171f7fb2820392de9cf1a44e33a887a8a0cd7fc06f340d67f79a95c436fef48bfe07dd4573ff76cf98bfb6c087dc3ebc9509b6b94118fcba266bcb20ef20f0a5c62d4a440b185a2c17c0d0c67765300db49a5a63ef35823477fe57e353076c27fa4a79aa4b0e708dcb65dae4919733e7893fd053c8623f4d22fea785e3b036613a3bc9f92050d20c50e500fc94f9869d6c92d68bc1dbdde0075055bdd3b9d5fd73c6765dde94f1fbc68049c2166d3c629cffb4a110f3e9fb126c3f01a51e9ee27efc4a4d1f15c29f874dcf01664d27d81ab448403a40d026966802c6a2acd46af237c014c72e2e2cfe0fff37283c40e6734808c43dde4bb8f20a99a065d325db9eb2f46d753ad9bd28383697f261f420fe41d8e027a27a3610ad6e973bc4b7d7489b469680a85bd5e4e5393108fb9d95e203acd209f29fa11f34d8c7b62850118de5d49b16333cc248e6c004b056898fb4f4965eb9172f3dc4fc5694d37d292bd20ea09653318ece454066293cc4c2b4b1464f98e92d45048dc6d0c6e9510fb5494b42541d55bc2d077156b52faefb74405bb36440cb688fd25c6a808b3449380ffecee887b5759739610bab10dec31614ad2ac1f8197b33d8d63bd5efc020305d22ecdd103eb32496f1d20b3e7677c222c4989b7ca101239190c418dc5cf682065ee08ba7dec8f7e25c5455083812acf76e95e343712c9ecc6d4a0a116d896cf778410242c18474595456117f438899eff2de54a56c48150f52c72a4a6a8dc9f4b77dbc6a44c90b549632fa5d8ea21b00fd4f7cf46f6387af24c4a31580a5b4d3d4a78b4897e9ccb50585fef3c0e126a8a4c3171fc64180aa668eb63c1512fbc5ac9d0cf2f7d590bfffe37eb2bf36102bdc0bba97b9a8204b8a237a88d9efcc36e9d2329f67b151ace2832098d76b79a97d08d4b3b893e7430cb07a2ed8756f90097480eb68b01a2c4b692f0eb0f6117b74c338b4b9850bec76ecf52107fe889a291f9267e84e6ad065f2194f3769eb05215bec521acf6ebc4295755fcfa7ec31ab33db66fe7afd58f4fa2fefb5d48605c51a519ba63895bde7a5b8f6efc52abd191da98fd055bc81b9b63c5971a5015730cd458009b7db882a661fe7dfd0a6e7af7a2e82e324152d9dd47d472fb7c4dd6b245f5478de33ed4e8dd782c3fbaada9813cc2ba84b5795d154ea401ec0deac12a10644907e7af916504ab28f8248c40692584b7409a9bc6774f69830dd267b5d235695837570d122efafa7aa6017f537fcbf65637110db3c1bc7dbb691b771f2e378d04f75ba6c5ad53586ab2e3830738968705382fb65b0a1c37a55c7966c98e1f4cb3fb4a6584b82cdbc08718d0a93b3a2a046090e254f959160864007b29450d9d25f12aa9483b96d8812ecd3ff55e3e7a474d43299f941484a8231baf5d4b6a6865285c4a4c1015adc0b61e57f5fb913b04290f79bb31f85ad5d0c9c493423b6c79000b2ae4833aca13a90b7b12e9750d92826807a9f053bd8295600a51f3ba4369a2fd8a7fc5e3187a435094346a5e5076623b9c35808a0e2e0b10ebf47d963e5cd07e1f4d80338eb9a2f7fa6783462343449b8163b70de16818338fa60c037411b151787af23ddf8599f252589f4a00973fe0944f1857e121670e1ed10e3e4d9d35e1f97cd245e08478a22df307f24c5c60d257868e33e9dea7939e3a8bef975b438725238e07d679c42fa20ae893433dc36338ce50fd01881581aaa69acdd8eee90d6fcf918b6bb764ef30363fa3840c2cc42cf576df22350da64b2a17da754917b9b05b987682ba79199a8f138988a559e04adc270273b43647c48ca291a50f4f3e299d9b7899ae9e2f762604a30e8f0258341083a4c86f0b03ac1dc67a7544de244bd1d7b7c0e897cce0be1ef6e4000fcd1dccb23b14eebad3b182ba3a81b32f9b61c2dc14bf1df51d0a5cb800554c97434c4a214875acbaed5dcca448a147424716923a04280a0388feff0fe3468bc952d253dfc79fbf21dfa54ae3c55fcbd6baf89a2e8ded4efe84006af747d6d04adc2bb0b77508c8bf61fc91e9d3cb3c996b278622733ec9a18840799569e1e49c953295382c7cae9333daee06a7a5973d91d571e068d74a71f6291afa40d5e2b6f6f369c8aa0f131c8f01db00076f48b33910a806ce759368b890795cb16df630598a81bbb9ff16b031dee5a05fc8dec5b027a3bbf554cab9b5afe610f9f6209ce4e3ad0d09782ce8d71457a7819747b400ed516b54f1932b368b8c263b77d238cae871c27b3b680d12e26903961e4564446f9182bf833511f283d727bf5cffa40d46e9775fb850587e721635b21c9b8149247a28f3c0fd818fcfeab218a3a4e37b4cbe0c8343e03292a4c672b34eb93e1fd9b37070c6f1c4725e517ef06d714bd108d384c829289b609fa88aed9ba1645cea76aaa720bff507193e527fd97f5d0c6134af958aa960d67c43a66a783ccedb31caae49c6da6d0b9796aa6841678f25d317af52ed975bf5d6959821602cd90c0c9ecd3e62095a3971246967c98ae4e206de72d2e180f960cb96646d829c80b8b14943ec5bc5fb2186f5d91ec378e600f6c7ef570f5d911f3c6171b956a5278ddd40f60cca02d4cd81a25e55b315ce4c32aba7a7442ecf198294b242166ccb862e451c57422a2a2bc16aaf1e5dd812e9caf6815d9fa7aef0f9d706ec37ab620a26918569407ad054ac658912647bcc04dd9a1027776c39596910e562a1c0ae8acbb62fd9daad03827c5295121f0a2aca795213101a34d13a6c81595212109877be7e317800af540bd1fc7abe52093a94366047ab6feb8b937ac395d74f9b88117f9f093acbbdb94e3003e78dc239df8f732cd1f5c56ef6436744a4813857fbaea94064c90fbe9b2b84cdc616915edd7525ae661d98efced62fc3b1f55e8addf3265e2233a98064b52a4572222a113b1bf15e48812cb8281c0e77878e6742cf26aae6a3c44b5ab47a786f229bff735723f7b5ca822c32107bc4181946abebd3e44785a90bcb336e00c16f2212134a670e9070a13e7b9678dce1916e856078498adc5a70aceaef8b6a24b964bb51e2af5e527a0395b90c76c87cb0d156fcf6b2f5b1c4a64502b2951b28034e74f05b08ad050e5e625b9c4db00291bb79e19f601b298ae2c799e9cd7dff673dc94df6fe1f5b3522fd0088f557ff4f7fd868e7d8258c8a3738c964b6818201f33b8fc56c721e5f8231b92d2513bd5d05b7cc5c2bc17514a5c44b08a54c67b5f51e62db544e0e138e78f09e9c8df923ea3f021ecf221af27d758ff24da95a49361d43a3531c4fc1e02c95df05fd97de63432dad986267a3796ecd40102ea56b27eda63308cbd747964b6689e5e5566ba6c4d36c64655bd945ea5b9cf20303933e99bcaf1ffb83698b36401a55c64e9282a1f9e9e0ca5261e9e9ba3c087a26705c184c7a64be84a1e050542451701bbf768b8a852bdb147ac4e605e658e5a26a2aeb4cb1c589409e0864ced8bb7e11ba46afb99d50b52969e72df42ac59c13423700600b2a59a224dd8b469d27a23d7d42488895044cf558d36781939502b90c546c51a146137c02438a0cd0e04bec4e72f02ef2d053a08a56594d7ed5a0388ad087a7ba1fbd5f56fa1b3bf0a021eb703e098bd7794bf5fad422f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
