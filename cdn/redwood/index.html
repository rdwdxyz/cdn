<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e6bec888be1a0b5daeba919dfa510aff5f198fb5f7eee715e68ab2a71475525fd9b5a0f666693683ec442fc12e0d9b243d72672d1385bfc5d6492afc2e886a164e2902ff29460faaffad4e6c46c0ea608dd50305e5c84f1703c2f2a4ac61f408b849b88335730ba5f11f94cc196667036544a6136463f6d3b46a470caed6a51c8d26d29277fc3d70d017ece60f9bc496d8fa76a9e10f9da99d952df267a8bee540490ba5d2b3fafa19e944ef90a092fcbf61303ba1c134f83c881e844dd96003ea73068b2f4e1ca5bbb9400fb77445968bc30cf6c5da29c1f61dcc18f87e7216003dd1d093454a54103475ae46f6384dfaf8302e67c5b8a3c1505e612a8553b9546060498bdf73037da0d2b2d4312f160195856930f96777380ed1ccdb6bcfeadab373b0a5e7b45c1feb8fd30e230005412f1cdd7dac2deeec671e69b7c91c50c9eee6135fff01a1058d41e56e3a6e25a5d6a6dfffaeaff6cf3214e468cdba62fe93ef729f80af236e31c8ef6b75e5a6f49aa6373b9d11361cc447ddf642fe1f4d450c9e3adb8d0bdd6165b53bcccafbb412106db35af6ea2b843ceef034a8efee31c6e793524648586d8bc913777554b492f6e723fbbe1a194aa7a910b9d1cabc085368040f8be045377eed0bd8f5ec5631c46f1f4cc09cafe4116638c31de7ae6b779583703a3d080829285e2f0a065bfb62df09a575c5e390b5c890617229206234ecd05917dbb7271e42dbc7f0aff03f5ed1d0493ad0f3f5d43997cdf7255cea2f8584c245aff1c9e486506dab61f88bc3e9c0e8d9b0b26dc258499114d1fb740fc3ebb649eaab48428a133d57c7c44a58e271ed52159322c750dfcf0d5a159bcceaf1c2e4ee59c4ffcff61943f17d2ef4dc3772b3d460a4cafbad7571d3a69b07eee6b5a5442bdee774c1ef64da9de8ed3833747919d5ed7f707084825eb095220aa781e45de88e9f5a8e0924207c5180821e14241684b508b0b3116abeaef3fd9e34ffdab65bb51133371b58f63529a269989eedaf58bbc44f451baa3fc55c9ad23ee6fd57269a56e6897877cc56c8c06b6dd00e75ed22da1bc41a507152f9a08c810cfa342c96d41dcfaad49dc77665dceabfebd69c261beba87889e609df6aaf40bc6f28f2b3ac518c74119aeeb1ca72d08b3748cb734d55efe2b943b477fbe8529a380485038eff3678e8ad6dabe7fc267f45452de5be7a0e760947e7c8c623363b4a7c6c555d9911395cf35e4a90ca2116f4469955c6c046cf6f58b786baf48b765c9817b6bf95f16cdf29ff6271f47e7924034da9b7909a825bc5bc8428c98f1c390fb159a5e12a94a71654fbda35f016013e64a79b3c7b978e182ee49cd10e52627480f2d3091c837dc0bbce0085c7471c525c17b41aa9db2f232bb501886e71193a7cb727b67f2cc5c3d02627955e4e570631c135406bbf3dd006e6431eeede77708e6cd0f9513cba8cc9a6892603cc45450b11e411ebbb7a0f8da8b99d16c2e4061611bf4dc0046d0f20fb2d2ea0226cf11103616ccfa8815bbc5b01bfedbe3ffaa043cf96807bbaa20bf81c2c011a65c683583e4a67d2b45869dd8f5f37eb9fa14c45360b085e7a11ec08507afa9387724bbd94d5f7e71894c179349bfa616e32d517c3e9cc925b53493e5023b91a800f2263f5f53f7d94cbf0ed6bb9c333754f9d86aeeee95f9654439e808ae3e8940be6e7a93806d77cd3cda776b77ac846cf2bf0ec21352c0c2a43e2efe4d2550c0f87295e2a651895c4d914234301c248f5e517ce6cf65bdc55b6a8349f8991268fad6bcda9105b16170ed9d3baa5cb664e921eb7ac8b35fd7b877724fd18795d92e5a0fd2996deb711cf1eb6ded66e7214f1acb6422b7fa6c510050cf7f7d70d942fc84679114d9d2325d854a69094d60d230cd2c1b51004da0701dc3ce7972329f4cc2ed8d2d076df8d0feceaa2890b4ca7309e53bd36f04072c607f10d2ff99bd91cee31a26bbce209fcbf23061490da0815d395b010e224b1d18fdcdf3124df8a16b1f62b8edd945c7177f847c7749544568e91b6e0341845b9ffdb8470c06e27ec1ce53b787e1e9da3c177608419f63cf85bcaf85801d8342882f0b26d092eb9becbe23837d41574bcb92f27e1fcc01cbdc34c62a4294b295ef141d8b0236f2faac22bab886640c1c19089c96630f6b554cfd416927638b6b9efeae9ba4256c87fae8158c4ff2105f094af523a8c823479b98919127d31b35d72d0a0afc5c93ee4793aaaaf77312ba306cb4cf79eca7e6b8ee1ac44348319b5dd09f24e9107f4d7b69a83403ba418dccd38017be411173f2be5f18cd30614d657fdeb9ccc2726cbeacd358047b7b39ace1819fac2fa884cc1136a18a4540b46eb901892ccd9abf19f2930edb84f1fa3eea9376ae62ee60d2383f531671cb02bc0d9b8601fc7fbce5d617b76e286d026ae93bbe6324754600ff75e93ec076a38dca259d120a8ee7123098902db2ce098d69c8bd2a3f712be0a3619504902b5a3b469b2896b5f8bb0d78cf1bb7d8a153c10366b1dbe617073a8bd19b933f867f12dd6f65be6da2d14b3cc03ae8b856264aff7e4611dacac8cbcb71dd9245ae0c81fcf289873ef82b10bba376fbb48ec3fd134d80aa165b97df3edc300c6b9e3b6aa6fcfb4a9f80431c9a409e24e6ac998e32f64206e7016d7abaee57ef63a949a66e96992b0f3d6e2510ba926ec74b390abed7c6a67e77c8ef4c0489d3c9f388acb8b60e62b8cff3cb7db57269589b477d2efc265e8680e1846ba29f609da6a7f97123334d69b4c0f67f15abae556c05e73f8ec508e04991087db6a6f20d13a6133d1cb6431710b555d27ad894bacc8617ae46d0c36d1bde2d44bf51f380d1f1f4ac412b588ae38dd34344361efbf716dad1fd58e0fd961e935a0e6fad28a34957c6898a78e8b0290bbc59a4c0f96227abe5c743b959a1ee66bad9cfbfb264f1af6ca12129c872571b96e54cf39c647d97b301ecdcf8f702ec0572fe1e15efeca5aa3cc965abb5e2adade46382d2121aab25ac8be3263d2a852df00a122d3eaad3bc6ebdf1b295134f655efabef2d8d0f2b235bcd18e42ea3ee6d3098732627e087f88d628a4fb52437e3ede45913d0b1b465cbf918bf21b306152d3681ca09cf510455f41e5e3a77e04a2da948d03aea352722571eae350cbdf35468d89425491a36923285f239eb7367febffa84b82ed35739c8ff6eee4d6b02d61dade425f01c80f4e884912121b34f8280bd84df5955d2eec7558949f84921fc7a5e0f6f7a71ff7a0d8984a3e7098dd1390459ef0b98195c6a19e42f11e15e610456c09f1478a0c8367c051c1be27ad937a11c544b5398cc2df7fc0e39de5fca72f583469b295ce391031cf2470eacd7029fbff11f2f0d02487c453d7d257430703117ee832cb16f05fee05351d20ad4748f0dc1d68cf152ae93ef056182c77991048d0e139ea4a3126bb22209e65f67cf10aba6095bad0b97af35853a18499c62f83ffe82c9c157d97af132e0c47ddbd288386a0c455b4292af90d8918bb5a5e3a1c7006b57b985dfa588a271c878d2a0fde33233c5c624a66a53927a6f9233a389207213423e6fc8314d87cb8f7b7d022b06f6e7e201da27ba9527d4c2e95f9de9024944cfb1f8f2d81747f91aa2fe038535c1ffdbab5662a7fe67e1f5c88ae1846e1de7ec5d27fe635fb71b52f69e840e093138f2fea0502b58fc368a745abe1dd5274c31c05f384c20491539dd15b963e19df07446384e1765f71fc10a5bf28926e328f3c752ed133767051ead413cfcacce71af4f0533d73f97ac1db8d2cc02c7e3f20a5a7e56d95a9110191d5ac34d016ace96d977a90f53cd6a82ef216d4dc1ec684e454198226299f179a8900564abf7161c102d006dc85a5c0e48fce301e2c2025cd449f19497dd3612d5ef48a9cd2252473b8e9e1530b7972464fcc9706cf9be9d425873480247003ba40eebf544f8d49c0d8d35480086b2a5a9e601902dffd06084d024c3c0ad7ce226bbcf791ae2346eef6ab92d36ccb30af0d420d271875c6b31e2538412dab543ca18c8a9d7643f391dcf820088bb9b61b2f92a4b4212d1866d9ac5e5dba99eb397ee026ab3853bdd49975a318dc1995bbade5a42482490ce0726ff3415bf8423f348ad73e8ae139357464b5c4980f7a0f5bf27cf241889c666e39ff4864c3383cf63bf20b5909d150deda8048afa20b9e1b234299d087e64b597ccaf5e7c7d221f427b587930543d66230b03558d142da3c08fc7d6b6ca7bec4e2a7004a2950c63a4466d41c28161b427e8cfb9f5dd6661ce08844b89c868a20d2351b5972970e3df6f288e44c82c37a420a9d468a65146610bb2da28f8cf94081250739b82dcb04b783e3e7e718d60ec8c50f0741d2f016b14b8747d6076bde22a0c6121dcb11fe1ecf0b3513c28a89364f1431089211fb273527fadc023980740d9d223f6aff91fd316579b527ad3519b9ab2964b8d79fd8248d65d5eca3ad23858dc4d6770da707289484ce7bed58e1cfe844f2e47e2969b64e47138de7604e2b634f6583829684ab066be17c7d794ede51ee7006fb84523f4c606ad6e1bc181798a6d7c213cf66b25e59ff946abfb3118c1e9960c97a0f94c3dab98696edd4260efdae78e8bbad5da8f26f179c28e76d84a241d74ef01c26b3c79993bbfa2da27c2713493b669697b4105e4128a37692613e31401b504ef6579ad9f11ac041f69990c5deaec35c481c96a5d25ba9876fa149c50d5be4b195af54e82c53059c8ac68f868fd5eaf800b07cd925e4dd49b38783266efd161a2260885d2ebaa707bf3740df7f57b36a6ff3264b7077b1749cafcb57dec28272c28d8316f2610034faecd99431e354abd1e0f90bd1d3bea6286672cbe40a12ba2700eaf5b80160df0f247bf4e5b99977ecf610f61cf03982f623876fe38ba168620795556ca7b697f7f32d0b503fcaa1eaa6724a82983f71668f749edd322856904b8c83046ee911e991dab354e94f92389363068dd434a4c88252b5a388c20d5a9c6086e358a26a757c60982380aab9141c23144ce71bf7305e28af21446c9b267e5e7ce54c20c2737b8d32030d9e59b124490b402b590cc8b1e97c5ad3d0541ed90ab23bacdfbd5a0547a9bae5466a21c19f79e01ae5f91e98ddbe7615e4ef5b00904ab121fd4c60228284be344cd1f3a32fade8b7f1a969322696beef1cd4ae23e70c65f03f60e16a682c3f9b61f75df3f6d024ae305a9902da69d36831aeb4b03a62204ab9a3313d84e9022cf035855feb65db500cd57a91d51a1a4814122a7cdb482599ffdd7d3580f994425d350b75c44d1bba81d7077e224f10ad4ff53241693c45aaf3ea4e1491f10abd07c84b94e63f9425561dc6e4782b9174219861a0e61e5bdefc25403b1d52fc23532c87da0e4d50badfeb375895e72a163884cb466f4f24e78b49bcd24f6dde5b36983ce49448440903fe9df60c57ddafcda690de4a0796d2a63bf455764acdec588e38e96cb1fcd09fab84d2da185d31af9c272aa9cfa5ee63735f532d1d428dda68e0f9c016a7f5d621b2ccf4c47734258fbe2437aff25dd8e3118d02b764de4e98f1ba4f6e2c84c8f4e3b6c9e91bf8f3f13530487e22960ec7fe4cbec1dc5e2ab1a9d87734d1997b9dfbc75647aa0281901f0770346701679636c4097641fa0c1f3fbc6e49b8461c1a81578863a0b8ce2188476dedbb69267c4c9e5277f2ab81f076d4ab5d78a49d8e2806a6bec03d5020041f68ec05b1b1291852da6c5d7023669ee8f5abcb3fcb5379c44e8c39ca8d5f8796e96b88a4e7c9c42a6697c82ec80ebdbef18fb661c9900d215893a936f9ccdb61b9d0f605d044e7a89c7be0cc1f981a11342e7240b326475acdc1f5e92ff3ccd414edd826aa303168612c40022cbc6ec526085b03220f2f2b079b13d8054e81db97157a8ff1e00ffdc6dfa032ba64dc28e77e2cabfe4735f25d313fcd0b5f6a3477799be5885462fbf0213ef507eb9073b83e1cd988a843b8a0bebc7b21d807aa5936db505c7b39839d21dcd8d117a0683dd97809060f8198ab78269ff50e077c8351dde24898a69dc06d93c0a0be8aa5bba16ad8feb96bbe8d244890f25f3c7fe3c39b554459b57aca481383d51e936b59e53aed6d290586ef70e0485903baf370129c2f62cdf6e35b00c3e97b5ff7bb07cc88fb2aea3c0b19f32f2f920e02e8e3405137d3a6cef0805b69d32b43e9de10eef3a5747789c0c06cecf1f71aa8e09dc516cbd0eece770b5cd55e0e3f1d74c93b14a9dbaf4e22aa4b59880c1e68572270a3bb8d8dc50bf68b9f6fb17c9c3f976711f9489ecb2b19d77a6dc2b56aca310d0fcd038b56135d20d9833495aeae88482a0227ab009e569824c6d1eba516a1110468859ed9d29812c0ce21c66f47eadd631c2c15dd9b6e4d1cb78fe10e2f6c018e15017a7dcc0a9da1ec0472a93b01f9fe547205687aa4c2257c2cdf8da7f9d95d7b19db87e5a6864c6c9519e6f42ca8ceedd6b564912f99083432435c32c9c19983a1b71cd815093e80e6e1c0c8aafb7c7d48c1c4dcefe95329e86b78429aa7814a921f907192c7746a4ad763cd116795850b4a6c11a3d07be97541f7b8178d5e838549fbfb8501baebc901f12386fa66122d78a781b80ba7d03237f8eabca7af7cd030daa5355e6ddb3604a0ded73087421ebf331c5c260ab248dd2d746009a704ac8d058cae420d65a6c7e68fb1a52884b428a043723bbba9a54d46aae78bbe6d4b3f38e02a407b84e8128f54f6deb8293abd10c367833c3cd56f049da30d929da9676f6b204519159106961bffa9a3a79b64a1b46c45e2f7e9dfeb7347552b571585212239e6fdb10de24afe2f61ddcd50afc83a9a525e98682125594cb489e88521cf052947fcbf29c47c9a4dcb4826031dec5837b6335cd7220b7b53b43707061cd354e8f7c11e1c38b478e00990dba0947debe86d822c463a1b16feb2f4120f99413fb7cd19e1e115861135b5b71169b2904563e19a5490e1ff9d622c6bb38f2807caefe5b6e114a9e99ed66f9b66301ac2b24c07f924d02e56d2ff5372a358b7518b6fc0c6cf28a21afc880f8d68615fc63ccde5d07280d45557b8b2630b9f7abf49647494d17c5e998e6af035b5149e3abfa35abc5d1de0190ba56369128252abeb7c04005d4e4f0d9c47c987109b0ac0c9ac7c5e4cb18beec855fbec09291c926e570d7419101431a5146391e6403be9048c1dbbdba8143a270d96390968559c2404f75109c3023514e0f8f2cf3b364ec7e793c3f0d9f1e263de8f41ea93b2bd3ff1f0080b7acac2b265e328ed2ee56715592c3839c3092f502d646ce7af59bab20925b6329cc6f8a7ee51a98df2277929c5296530deeabbfd5015ea1494adf1517bc77908001dd76b31568a8ad0cf71108c31161d6109be994c2d51db8f3fa86a8895e253246da0b6640dda5677397ae360500e656e68b2d05ad24f102d23998055bb308299af6f3f2dc4be6324e62680aa3b1fd6d0a94372f59646e060aa233f799b686ab7368d6dbc5046755f7e7c8bc0cdee512f827fdd11e6639c3ab8bbba983ea942d674dd68111d2768f9acdbc03a645cebf7b4a9a173d7a4eacad85b988cab3115dbbe237661c7871599cb89cce1f3f28dcdb0726774cfce81d0f29dc5803846c206120ca1753974582b6e80c0bcfed6ea290c77bd4938528c85032f75c1b8439ce4a6aab53565317e90e070b67ab5b4f382fd4d3487f144bde3312aa269d8b1449505191c4ecb76bba0abd50a0418778499fd925e06524916835e83956aa51e2e9ae40812ab26cd21541810c5a9d0a626eb4f6b258248a6940ef14cafd6396d6700a6250d626087e22b305e84bef2d1c3c6f41fafdc7811e6fb428388561e998032237b027fca70f00ee80efddeb8c38ca71b1719365dfdca5f2c17ab6aa8fc5cd8d941284d873c3eadfe130de0ddf048d0faaca7c372a538334bdca8b9505c53b9b88d309db7b9e8384a07bfe4ec74a1cacfd263639d1b31dcdd8925e42907324b3ecbd06e82b61f9f7f2b5800f6fe8277a2791f963029f8fbf4e0e9cac822cea305d0c64c17d1d245d793c167a3f2c7820de2c0e3c78189155edb5683e92569fa9a65eaf99ab843e25e61d59437a99fc6b332831f1db27a6bb50d5c424f96f0e239ba9b89342b1419dbdce116a3ab4e368ce85e0c9150ec87c18cdd73583de9ff04a135064a8bb97229c42daf56ecd5212c85911c501b5f61fb0ca94874201ceb23713175c6cde4e4ae2c92aecf89b9610450d322a618867039365f14ee4450ab03580b9579cefe026dd4e074402aa7c9b8610792d89139db083547370fae4316138560c5ee94077b52203fe7a3354a3f2360578c9ff259ccaa81a70723459fab36b53073ddb6423754615e4d4f3bccbb71b1d53672c3906827a83d87b57d748eed3fe75e0d96659778a09c0bd161d9d5ad271d07dfacf9fed2b790befa54a8a688834c72327aa70d5c610dcb803d933f1b7e37c7c254e178e07d853233a6d0cc69fd76e7665ff5b64db522b313a2bfd6ba93a2528d95b0a5c5059f91fc8368ff5d1ca2d86d20cb55e69ee8ae5b7573e333063f935f64a728b976c9e19aeaf9a2d85d74c74d35241a9927801a739013647d69c5115a381de6c7a5f9dc9923e356fd36e8fd42c0a7e61bdec5a2031c693486d7cbbda42136977e5967a6d3dc87f3aab365b944613dd9c8aa170a1d66a29790468098fcb9ab94c6c40c6d4a6562197ef17d0f8a9d82b4f7d98ac1db367fbc293046881d8d8c70d7eefef91c4d8ccee3fe845d6e84cc416a4a7261186b82453f9f3347de94fd431cfcdf3e8f7e565aae01a7ac9f14ca2ababd53e5da941994f6f174a393d591583341ea38774bd743fd65a07cf4b680afe145439ad2b05794e24ec2050282d71a03e39c4202978b07236c59f9b229c00917bca7121c03620a5f05f83c1d335624725d4d5bb8b384f49da6293f6528d2932725ac8b9a1dd2a180525eb4fa0a700abb90306de2ff02abac4999e7c263a53701246fa9c4db6663060f8b478f624912ae18246517484d3553905b7eb065277772aa062c827752a12ff29069b22e0c6577d66f47b84fd6735c42ef58b694e7d3770aa724dbce6149603beb1520c9ddd874ad60fd7dda2e97d8d7753fe7c8ce86703ac9cabdba3dec9264e8ed91c943ae8214d0d3a86a792842d86360e9eccc4f1081bb37b4470c0629fda1fdba3c7b4be9c4068e5e175037b2e444e0d0bb33c8bfa67e2240a296204511f202585a6dcb60228768fc699516476b77e3f6d894ae8acdbcf1603efe484a6b6821034d8c0582f144407d9922ca5612545bd1d726afc15170dbf346b74d6dc3abfa36f7306bc180cecbcc69a935798adb87f9647704a4a1b64a0ae641e2688c01ecfb5d05a71665227198ff45c42434e3a5b75b43263583bb4bf55b2e09bef13ceeb0bed6ef0d78032aa583e4e9d930c8fd18b93a44c35d3e1608858eef74723fa819774895c61f1bcded467a526f2a262d87f78f8db240ca41561cf8c837dca83c89f54cd51e15193435f7d328b50d146dae11cbb590d2419f4bde9fba2d6f3eb12c94fce5d295eb97264233d0abbd9ccfb47c456e54b6e8d4b6a82421b29838fe433b32c14d2566d4510a2450142a9f9eaaedfca14b146021367b8819862ee829a4aac2acad0371770dadb3c7352ccd3c6a77469e9e3aeb177a7a510b6adfe36e0d911e4229317f31a9908dc86cff63c76094a5e6f5fef404b47c8540e30ddba0ca5bbf4ffa1dc9c749d9b4591e7f0049a0a4769b0227f592f4b42f7bbd224aa8ef2d51b89fdeff45caca8c1042a6071affa7fb733eada7e71b4ba8c37ea29562dd87d1df57d01eb2139694d417127137dd6301618e4b172f50e9ab451a5480d337d6027ae9e4cc283e3ae3831ba25779998009fd9049e9fe96f0177cae06bb25cefe1a800a4665d2561c5147dd10c120297d8019f403717a1d04acee467caf208fb1b6365cbc7b82d8b7ac8fa35d101c8639fc64496e744a82964a5d9dfebe5394adb198474ac373a2c38f3056be4562ae68bd0540cffc737a946ed057cc4702d70c715d08d295320a8ac9fe17eb60d2d1fae65a082137765887c767f039af873bafb35a9a8012269f7ef9a358dc2f2f76615ed01b9698d6460cac58c3f368433974b7a664fba2c4230e84f6805544c9156c746875bf99897747fc6408c0022b911a4a50fd43ffa203e2cf4e228c98c2f757842fddc68ce618d54db7ad55115a8541f7169c5e14f1eee1a15905a411686ba77d407bb12a62899e7c22362f39c9984ef22f8994eb86b43b8307a3b0bb6e4898ff1bddd229ad7a80b35135da27815e7ccc2bdb349962118e6f084d99c195b0598f98411f5670ff20785aac7e0f496b269037e33eb0ce11fa077d128a5e633551805e1d809f94f759260979392ae3358ca985f6d4069782b661fe84376098cf3295de630f11b9b538c96f922929170d93ef5b80d47376fada823728f5ed053659f38f60529d73f89d4f449aeda1b662422e585edc26ccb9eb001ff6808457387554e6171b60a1b383029098d5bbce0bc6aa99f0a6dc1294e9250b25ce09a63d20096ee96079c18eda8e02974094d199536a606d9120bdbdef2966aaf33f5d856d302854852a00d10d640a2a4d0ad521aea03ddaa967ce302f699731f8b6d455e3ad7548a39a1c251dc8e2141ca6f8feeb8fc7c679d83be164a9c219d47e7505f3c29c249d255bb5eb36da8dc2ab16432c2039a0ef6561eed65ddd3eed376fa5b9deda3374caeaea21441b466affd4c82a83b91059d8a1ca9f584890eab1c0de36530d030f6ac643ec2d715a8187749949bafcf77a99e87f65efb91a1f754a4091454d96c1a0275effef7a113106b644accb19e265c4ae6ffcd26d85ef681982ae1a69f9673f000f3c782fd8fe780d339d9c584651a77c571ee74f0d15a540e09efd6b2c22eddeb16c3382d060efec873ad7e3fb0d36a592fba58ef3ea6b9732ddf44328583536e0940f27b724fdde6ad72d136c9ea3ac601b29f32e7320e2547629f8ca6c0cd5190981ad004f68ceb73298fc6d0d456e676ddc7cbc604f5fd981267509298f35074bcb3c1cffae24a5cab721b74ba59274cf2a42e50fae47b29ebb4989d402965f1a5f165a8b8f3b044cd79addd84f82ca2941a5c97e692d54ceb3f5bcc9503c03d938e03b53a652ba6b9240e90f4c21c65ba6664916817a03654c78cd40620b0ab68b70be5a1f5666bb795dbe94a35f328fbbecfb7b31440f4ecaccaf424437897d34cd1b02b4abc925b2bcc9544f04ef4878e2363fcc3b36f2e0ade2871325fcc0f0b77469e7780245b2682aea1c79a3130895d67a2bda255ae5023ff8899a9aa059048e11b1c8d809177b2abfc4b64c0313fcf70311a97ed82e3e18ef2a7bdca777349af66b450efbc50a4aa29661d525d911e3d1644d9877ddc67860de10f9838958141f7911353e3ac5ef55a62c3cf5972b64c8833d97b4539c851e8c1214e308ecbd2811ad0ef856d6a81880229c42fea19fbc8db7690cbcf67a952097789f89c2bf2aab5eebff23b274c59e5aa8636105054388d86fd221d388c35f88abe07d9aaac0d8499c9c9556ba6bb4bcca2c52b98284464779bd921ae04e796a4d0ff62aaca55d738d2a96d046bf203d2b359191e639b144b306c11a941b7025e7962ba3cf706e7aa32c7a6c05924185d5c6579d0813b2814873e11fc5a7ac1353b048cfed8ec95471597df9ec23bef52830fdcf6f6ff66e4d86858695621c895ad5b5cae57dc9e498d572ecdac4c7a5bcb8370bba3efb50b0d67c325739cbd47c8c464c7b8236846249156b71524a55be8f6181d0bec670c5a19f86b838ae3cdd7177dda9ed94fa79efa120ee7d2d2b2c7d97b3928efb150a747df064d37a1ca467f67531e2ab47e2d9ce366346e26953b11f17fa71476158797bdb053a1f408c72acf31bb9d4a4da35d697e552c71648ce7d9a072b50c1a91084ec692d9f36b458973a95d9af2c7129d97180da5b7826ef946d64060cb2c7a1dd53e6081d892739fba1ce4415287fc8eecd211da489f79c5f6bc6e2c0a91c14af44e4714ea73587096364af13c3ba29e7b2f17b8979f83bdcfbc96b8d81393d39ff805e5d320fdf08fc6a9a2ef05b3d9eed97f728941c5dc9b3334ca4d11cfb0879a2ba589174e53175872400a1e15f35c06567d10e6fe4fbbb2eda10f09387ee89ed72848af2fecfd6a734c91cc287b00db51475adfd2e8ff616c022907738d79c4004625d393c52b2664c673b171590c9236bf72d4482cd6ef436d87c5f586186b25196464bea190d22222f6a6d079d8e9e7a54099d745ff619c0a199d8bb248feadc4d7c83edb8a231fee3fe3dede242c11e8ce00b0a97394d740ab8ab493e9bd5e3eb0b9b66c6e0755b6f06f8531e460266b73712d33c647b5a401b8e0c878a3a4f7e11593cf6a30efc76cfbc7da450ee15a671d738d5870f8e7e1d6ddcc44a4d4b16591625bbbed1c9d007580f060a3dc5b1489dd5b48dc5eb9ffaa91eda180b3cda01d6ebff783279175a3fbd87bab092bdf49a6a2112f7256d681d79df790800e059f620602a7457c493445371ac030084e0340f1be40ca93ca9878dca3fc413daa43e6123e7966bd09913afc5b096c2c0ba1c76cf3637ab1053c6e05efc0c8db1e95e540d25464d5511b2b1686c142ae01d6fb078c4cf3366ea5f44c6142250743e5c368eecd4f47bf4c0efe41213928d3522151c3193959501a7f06e16594ff23b116a88145bf504138c5dcada4d16fe48022790f7c6c966d5c3dabfcc3bd068046dad061dc147fa7428ed3a5f3458989b97f7d36a30d5c7878f6e1a0333fa4f13b8f6ad31ed85321d1c10ab71062fdd4e1d28339c501b418b8b66d67b2f616fa1558ed03d15877560bc2b21512ecb380e826df818b475fb2ecb11827d5ea3ea3084facffdb9768a97f8ca556e9be96d1d95d18089045d7ae196c0847943457e631cfac5816b2ae86ee6c3d86eacfb09ec9826a1431fa7d561844e065ae345f3bf3cbe81b71105fdb008404440b293a32ddfc108996db19821566e16d43a5222c18189c8af7789a6623d9e187ce5aea3a58a4fb550b73a34b75a862aad6232937b91cbec1816fefe9d0ea1da618d35770fa6daedf709fc1ec7229247818aef631c75d72e7dd2e046298a3a11bc91b795201581dcb656bc845a7d62c3889c220d3ccf574343174b8b84b9b604eeebe7bde701b23835e1d83925cca4ad448b738bc7e4ce0f914ae5d18ba4128d415d9b77c8aa264acba15a711654e5ee05bf5d375cfde1900f9835220ab8f613c01b193e3ea2921e926211e8317345232fbef47ad369fdc5bf3d56da5ab30615b4862d535aa6f255d62e0b6ad2045d0883c15e7858902386d83fc8dff37dfa1be21ecd76dfe64059e91bb0adf4f85259fbd17e159ab6ff2e7b24278335d2bb5b4d1b0cd543f13fee9a52a8aed4438801d0e734357cf548177ce3f34c87540f318b57582e1392f5062ef3691ab403f475c4558672397722861d067041d308a5993b07e4be2589e9feae0179669e0a69bfa677e8895b6a579c5d5cea53145f109c3ff5f7c47de16dc38a3aa0a8ac0431d637dbc0c60508ff40b898ed61c270bcbef81631ee726808d359c7d82b8ad92ee5854015f735dc4f43ff1456f5a9cd1034cc1bd40542b58aecc0dacf35827c33f384168b036d2680cf52ae1319001e4b2d00e079dfbacb3a11fe43d4986c61e8daba101c921c3744efe6e501758b97ccf22add17fc40c8cc46858ca8f5f99824985c2a91239e2dd754752ec9e0f52b1b6910b78308869aac400aaa2a0e584eae30af10b4a43e860c8e5c95cce227fcf8af58ff012c0a8592587a29d8e8b99a239d8036c0b8c470f122b345a141e0fe9047d815e52b95fc70341cc0bf74b2532259682ef55b080ef1e6cbb18d60e0447ada26c74d625b6d0711778bba0ef1f0f4a393de145f14b53eb0442551f0940769422f22099fa784c64de2b4d6067115eabc8be914bfa6c8896f9de595bbff2bfd71270006248b19dfc29d3ea39cbb3425a443f32444eac28a99733945bbaf98569d5a6530e1029b50af16d6a65d49c5156b7af7bbccac50948f30d0f76e001c8bc79ff23f83a8e35fd30f69a8467f09a8210be03ba68e536596a613d88d7359985e325f6e97d11374a684e5e03545d54390200429d21b0d4e9f1f9c25e7f20f322abd34e25b6cf48c67a62ca8b7121592ccdcc10dac699db425d5e42ad0b8675688f1eeabea650de30357e82a708b679b32851e6f56aeb74b4dedd7a3e2efa6a9892c05bb0ac0e9d9330fa3ab94f29a2040731ae39a1141305460536a7209d55a78828b8e1a4f339dc999741f962d53e4cce46ee9f5307a011d16a0983366111d60210d4a71a7101d752879a09f703d3a947d498b862a5600fd9474154c3515e6bde4831e0d85ebd199d4f62c08d9e71ccc1da93b77b4b4c1d8a242d35b0ad95c2c4e95edbf1866890b071d65ece6d5639999d6da792adc302a7445fb5a89e4f7138c58a8675a08d51c880e479b0839d92f7628fedc20020846361a52a21261e611ed4c0606edd9b00e6b294257715eace3e65442d97d378e76cfa446fce87e3f2b8df628ad6856c3af28c5d0c4aa57d7dd4ee60e9d15455d1a0071231c3cb5e39f88e37ffb358a1156a41471b1e990894c702a592adad7c558cb51f361c28e98c752f2036a5f51106acdab61c9c0bfef10f0af6f1cfc4a2d061eaceeb1f9849841b459f63881102cb39ebfbf43fde98b682917cf6821d8109052b5c5edc03dcd6acacb11759bcedcfaca91c3bc38eb74d740c62b226e118b0bd31deb07613efe2b2b9aacaa7070d1d20fee1a87c98919f8a312a8471d7f60659d8b53c054e8f63485ce31fc05234d5bc82c09b5bc4d485be9057bceccda2f80707b639a51148daf86d5de017968f809cb61d6d1ccaf735f28de14062118b4606a91357b24f763b5e11d8238002178cfa255ab8e4df6c99cc45e1710798353ed943166602885cf4d792997e9b70e0a83c1226031eca13f89abdac708449404e1a3c2b1ee17d7636ca79dabc3072a3b8084b0d129757be3036052f1490f612d9e10e3abfe2799ef976a140e27ae835afddd50f49de26d26aa5e5e73d626943bc75d4c4fd021690732bdc42a7a2b9786e997502cc706dd4529765be03e9f7ce45aac4e5c711100275619083e007e13fa6724dad1974374a8ed59d3d43642c644b19bf3c911d6f4c8f791f592866e812b4e1c709bf087e5744f29f337ff70b73367c2eaff5be410777a37cb191be22733f35e8d65bb6ef59134670ee9f724e70716a1e26efb3780e7d8d38ce556ae5ab533651cec651323d6122398495d263311b3b9691b389b78a4099637e4a9f39153c9dc4b8a3788d0186f1d0169d7949a6053c684184d223287f0c63508251e96d973bdb30b2b0a1a156adabe218941995fe864fc35012a5cf1a5c0876ec38d2a48108ce95587fb6ed88988efb9872071b734485e4f69e5bb6216a6629fc438e446c6a6cd41cce980d30e95bf0e2afd27b40c9fa9a5cab17126fbad2f9cb5d50870353fd2d414644c428d7d9f292efad24ae7ccfd76425c26cc1c3c8b652b879a73d31058e08120514a5b48096f8d71c09eb25d1e6dddb0074a4f5d6aa1627c3e6681dbe8206c23ca2599e4a076fd88c03eefd8bf9f34cabde251325aa5d700afb7a44470769375939f18029098958681c301be1fc05e64b33496c64ac9062d57b2ac438380ca2fd836072d9cb2cf8ca2a399a89117206a125e093369e2b26b1955ba229fefacc61e5a2baa7daa29d146beb984145cc84bf1876c3255babe3e5ca9a4bb7703b767fb787e18724d5f647145881832d8db58de2e50571c188195d6b8230480a26813693470e92e489d082d6e388b02b20b7162b8d0402ce94b94fd1d750794e26e6d6970f499b2da0882e69b1ed4a36be15483b7e0fc7bacbb7db00bb0cd020c8eed90e0cd5a43ee96242a7e9fc07b00fcc47d87811aaba4e4e43029c63ee9bf4f0205939322021b2b433439abef5788519f1fed2832c788880f451e7cef6f18fc6c9ee4c49499f1d02e28b2d0165ad2bfc4a4944ac9b3e3d0c8c362f38bf97da51745fe61a9e6b3ed62f80ea249c0c67b2825016ebc711f7218e22c10ebec90e558e54fcc87b62d72972f2ee75190bce8204aba748984455cf7bac32ee06a70c92fe8334e4ba4ee011df7848a157eb054984693c7b06dd09cdd16bd15a22d2f6d12c6a53b7aef0c50ecdf816d2d648e82a414005453037e9b1bd2680dc12444bde46757aabc610feebedd2384793430c9bfac73bca955f83d5f8024690a180c95f1b0dafe36068276d75f2693cffb6cd9af829a0c26090efd0374c15f861e05edafbd7bf2de5c6b7693ea44c2b11a975d026f0a3ee75edd64c5079463f100e17839f7f466b6e6850f916a57397525bf5b906fe9f36bd7f836a65778b1d3c47629dc89d6261fb4ee5ec00c77cb7f9a182e03a8b4f03950a43b70469f012dfb03b11868a73aec2aff7af1abba3cffc841c843751fad30d460a7e6157632e210fd475e10fd049abf437d8cb454d40ed59b9b355dccc83c20f79600363f68845253591235f416844e0d2968df656628b9b456f62753c341854a5ca63805e23aa29103017a719123a5abc5ad260aa9d06655317ebb84aa9597a978f5b0457852b60cbb3879b4b33f76c22198f1bdf3d09b6a5177c299628e45d8f9655c5e458aa4216e19c2839b4d6b293d11249c3371a2ddfe09ba8aacd945772f5a9017d7e49abf918ea669c45cc2afb7732b48d2cff3fba90962d76f5e2712e4f61154f23336b8ef6ace2ca43519a05350d76b4d54a0d7aa16ab48c65047193200abe465d240c8a050dcbb0c6897dce739da34721dfd235b86a791330cc88d0ff140e4ad4d8022be65f7ec95a559192a4b5ed9d9432789c724dd10fda5bf59b5d7b512fd09b62cefd11fa77298eec779416a21c5434da4a5d65718c290be4f0acbcd9326303bd90318733e15694c1d870932c77d512f0c421d80320e72cabe3a65730e8c0b4ad2d5b1826a0e9146c5a4cc2668e26a8be70d0137a96b62da20927d038a4dddd2ded520ab2b5a5e0a46f5846eea93eb53620b103a00e360c1ebbb5b63716d1c1dc7702d08c43eec6c3d39100e0c9d629b3105e25956be2e3ae866d387b62e17f93947a3585e7f2c6fe57d0f95cf82f8f1045538806c20562fd3cfce432ee51823e34b00c933ac7e89573e2171c2f60d79993c6ec7a31cbb2380f794a8c95c2c8e6044436f9861b1f8f0491d9da0d257a2970ae32afcc1f629dd693488c9013595e2d2d91a2bd3e5093d9f9dc14d3b31f632c3a5438b7ea2df141a5e295c10f794eae2960118c629b4d1249c4a035f22015f2425d2230d944596a473e5cc5ac1bda55bb36abe8ae2ebe298d7200bee1261c2f54901576595f72db58f6567d3c8eebb3c7a3e4553c51a27c9d3b9d431fec42262369e013075aedc4d001978ac8db4289cf575359ec32e1de705fa9c32636c1d81165ca1451b3ec2e2d388f748fc55114459fd4f36ec18ef358b479dc0642c20a98c8f564270622f152755c39ce330e73a257bc37bc5c57b8567703e314fe2401e8f92211bfddd200a305e9bdf22af0a5234fe1c1b21d499b6af68914789a4bcc0193989d2add6be0eb417de718cd7530c92e3a6dbb72007f2f7081f9469865b8be1cd46ac09afcb0d9a601180fb310c8a65994e369eed0b6bab26c6a67e9af0cb2bbc3709a43e0b85c07a3341fed356721feae108cb29a9d760278da503b5d563f188917752bef60ab73d2e76a01ddc93f96adb07cd3e9fbf6e3c977e2bcd856d6fcdfc9204a17d649b789569eedff6d81431a87409d4b4793241654060bc01e3c1e3f2b7f9311e181100129fc71693ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
