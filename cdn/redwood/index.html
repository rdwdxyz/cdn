<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2edf1fa422faee0b0b6ac3401b2b6ba8b1c04f0d6299e9323a9ed42d07bd4d59e154dde5d91af610414e88a139f83f94a53aa7e7f6f3fad068ff8c1ea89ed3687e24108ce1dc0f6252d3bd868ec834e6a265357636583f2bfd2af800b0dcc59e90bac9e05b460a474f808c52f91b157fef4c0d53d4c94a3469860a23da6664fa2e0997c5e2554cf8be88dc244839f8e7da0f961e8a8bc1d9cf1cb9d0d0d3adee72a70506c73ee50ebe77ebe232b5cccd7da42cbd58e56cc22b95bcbc50c6b971a62505d6c0a4dd8f0fe9726c91ff47b02bb2e2de998b4410337967d20a76133e9381bae9bcd9d57add472257161b3185ebbaba0cbecc22276d840b4597a03023e49c017addba35fc013c2a988f33e940f95d707cfada784e87bf2565e87bfed78468a9d68b964add827cd259b8360d2abe870dd23e080ba9bff27a6ed162db7a4cbee73286bc61fc75ce7eb5e1170c693b15e1b00736c82c9e64e5087752fdd0f210a68afc3431f4015bbb36c9c5b40bf3df9d51ec3936e2f9362c5b74e32ac006fb07655689befb5f0ac2d4c4fd3ba54044d76bd49b02bc2ded30e0e3716ebbc3fc5d2c0ed2c745436a78dd70b1b131346ad4a864b369f8a49e44376357f2e7c7dc31ba344ac410bb336b0d47faada52a0b83919c3be7c18fe215c56dc40d4530ba00273baf0b81a220e2575a16c6c817b6291aa3605ac836a5d629de4e718da5c6afbdbd03ed2e7441f6fdbf808c5c735471be3389079baa98df46cdedc81cfdd6b37e821eaa51a2a11f261e39ce99db717fdc852ce549be56962f1877cbfbe021f7b6d95360d9f20565f11ff6c3bd5e4536a9b90355847b0bb6b1a5003c607281cdb61cbdf4748ef7dfe5cccd36217cf9e8b17f7a422d99d46cc99d040fa80df645a754aa5f80bcc6f81ac713b6d0ee9833e7b9577c518f035d14e7f424e0da7b04fba12af3a7bc48187171edc9a7fae058401990d7bb489b9b60eddb99028fb476a89357808e78149c0dd9d08bdbbf39a566220263421b4d997ef3c0bcc275caf01de8462d7cd610a2439700d6840e15fe592d85ff962ceb423fba3481f7cc5a6422989776a516b8abba60db2ef3f186a5e11f8d89ecdedd96d8a8fd35b217a7621e032b02686d5b1027ec3bab499f4a0b87a7a5af3c44c1daba9fd85992ca446cdeaf8c950577ef48f6d51f4c67090a4c86a8245ee3d2bfac7abe555aadc8441c73d8f968f4e6fa49b58b036be7b2ffaf42ad18cab1d589d2b7075f6de185742426e577dd5039a334912c36e071d4ed551e70fea0d0a9be6d65a0adb40db625ffbc600b3050c496bc8f053bc6c85cc99c5b11e97627720f28e3377df0b3a20f2da57506d6189417be3680909de66060936c00b1d4ae9b1292736d359a8d42e690f56cc949005e31d61aa762c92c989bbca27431deacbbf017a7b14dee929e2c5b95d017cac8f8e106062a267ec2215453f58b30a65d8b60da9fba08af3d87859da5a9d6ebbf9dca01a4aa3f5cca487c4e7faab6c1e2a6cd20a2c429d60ad8fb434cd5e424845f011146e2c84e7e8a81b8a84451fe5947debc986a73a7c71d9cf0cb5f368c4f9d7d5230c565fdd3a3a4e0df5dc625b2d4d08ecaa40c02bbe6b597aa98b16f7e9a7da6fdaf4aee98cfcd11a179ed524215d76346d32fec5769f24f34f70fdf0513c35f301d08b2b098aed1cc170e2ca2068be36a73474946a24e4f80854d90bc396e18d81bf792c0f4e7de1807868f62aea415afbfd90294f18104eef0eac80e71bfad15bac9f78dc7bb78c5a31bc34391f10aa7e2991386acb7ae9d0a5061a551b8c9a01926ad33f1f726afaf90ad4ee1474e92a45b3bb4ab2d8e128b520d81c9d22f79a1502708222a8bcddc2e05d8771430aa52384118d40c905dc23ac77ffdd27341cb093d9d633e4e86b0b432c7db0d27995e1201255c893aed117a5416a67eb02e2304f5796b7710247c41c40e50ee51a0bec6fadd3151d8b9a559564a83194711f25d0816177ab0e6758c58b0a7682d270a6abd83e9af50633030bd8826852a6a93f5abbf6e142a97cdb4b1eb860ae6fbf241837200a81dcecb3b43eb84fe00eb201465780ab16ffe3c0099a2cd2763bb470667a20918bfd81fb64a0a4d19479e36654a9aa08ef0552d98ed0f214f6d266847bd74cc268b1f704737613fc076a1dde4a6897a19dfbada6ec43de085579c60a6056382b21a82ea13a7195d2a75b0eb50cfe74294d852e0a3b8b4c0304a2e1b417348c2704089c9152a5d6e8e9f77b8931a811c39029e67d8a42e2ad96305107da334ac23ac212e0da4ba36976964a2ba9bfb1e7b9e238f02d9620fc8d495188849963cfef20bb47ac23119a2b73434f7b239ecad48f30accd683270f436bba56796092c4a31369d65c29a1df7ae3a30e01a1e0f1288ff1f720a02e834bd88be53d9d8b9db43a2530126cae7f67f9064fe3a666af7b34bcee876f93ba67e4c118e005672589ddbfb64629b8e3a56b8cf6cbadc41f4b9f81d638c395d92f3c0d48c6325ec8d1bae602ef9c6104481de41c491e3fda4451eb5e0401f6df0044c2eec434452355cd8185bbb096786d57f0fc789a5143078d4ba7af1a100582527ff2d3c99e5ed4e55202175b15f252dd388a233ee3a178ee05d7ebbd6a23b2532b9e6acbe02082aaedc71afccf3da0393001a7c61eb37c61c2f3fb5ffdc56f7bfbc82a73e9d642e410218c43f1d7876530a535bea98872655817096c3f124c1e5812bbf5f07bc8eaeeed0d4a4dbfcfa7d8d26fe86412cec9b4847d52223edc2886062a99dc6c68f2208f7f24dce69ad6e8ddcdcec9467f8c6883d13d62d177afbfbfcc478e1b5be9e47535f4b224884a6006357a8c2352a3e1071454b2e718b3d1c51a6ccc9c345287b25302654c215fcea859e03086c40987f95661c0dbc279e5c14bd9e40c3e26c381a2f6d433fa30eea0b06c1e00aa73450558919059b952a20f63adb90169713d3655942b382eb286b8c59e0bc2c9fe0872d03e8ad3b2a36b55f733ac17d64830a4ee5419c83da7a7c0ac7432b4b1fadd2f8fa6701163f46e1f5cd7ae62b42264e1acc32490db0b755c2c11e1ae4bc192d89bc83ac2fda488c2bfdd0c0b2d35fd27ced2829f441362f7f65310594e3088928e1e63de9f1b78c37646842449587c084e0b93c1226050d950ed38995e3f617f3787295b8cc7d341dcfda27daea053900b20ed996eea992863583949a5f93201da71dae082a3bff68a29d79b52d12fc7e7b49297c5998ebd5e912eea998e10afe14319dbccc4600895a0d192d80d9bf279142c1585700aa8ce2038c0c234e2abc4a10ddec388a4354aabf97723db38313602d3e397ee030c5a0d1cf8526051dd263bf11eccf91a334d9b314675f80c2d50be751a945f65e989245a8342267d185bc7fc97b75e82ad921940b6257c159012c990795d4984f2e00e36208035c29d972b80e3be22bd0215fec48a7b6c254a2ff0581951ec923c0b2007ee9f1005361b4034a96cce954e761e561d3d278238a4c7c46d0bbfe3fc81bc93b89263d6c994587c3acabcf5162332ff7b93c52f5c541cfcfb75d91364ccd0dd3785ebc4912de1fd9be9344208346d0c892a4a9fac910251b24cc9ff3ef61d86f9d3647ba337f2fdc036224b2f94c99492670e69c10dce8da044151b119d1e164cfea231e9a2c357063ffca01ebf47486574e11be4253cba0d570af5f062b824b4f7cbafb9f0bd5ddceb4d6c3c879c74408a274e47dac0257563f00540973c44b497d7a3feef5381091326d5abf3005f7546df4570e3ae4adea1fc5f404fbf4f696cbf3ab013f47e1b5ff51349ae00333e77c44b3bb864f15fcdf883983e403bd3017eee6241f2483fd2c2900016c9cc2528b35ba19b7a2ddddb2aad194510eb8cbe3fbb73e76023ba85eb5ab79c7b2d1374d5f43525876daede3f4a987ab1e11e172b1d794e962f55e5e1945aa3d4e028319e40a3f95ff02ae9c890427a319ae350efe7d04bd0b2ee16e680e729648c8d50216620702362254ab48f174bbca6aba7b4eb3296e6b83c0e90daa8d19da2f4bdf51faf88b307391754214852e85e7922a5fc2058f3bd4bb61c8a93dea197d424ca1fd42a5b359d9d6e9db43d29451e2363f894205ae108715a250ee78e81efd470a9c9d471b1ec4fdc488ab90ef597fe71073f430a18d0e20a970e45b31ad49a3ec306a2c84d311fc91d97665c0a411f64937bbc6f0dda62c7a12842477c38e8d50d2d871f3e3e904ea0a6678a8409cf71fd794b2ff1ef69556fbacb70fe8a6653a47be080edb57feb1adbc867566a37e4f68ad0cb6f4af2a54b53c25bedeea024c6afd9f9c61b699c6905852ce76fd55b803de87ad554a3b3c10c9d73cc441b36c4d9b363189ae53be1c0a084b0597ff55de03ab78ef4b33529432cb65bb769d7405047dd9b81030861208d034c0738dd2490395f5be80c703e4f940b019bb1103cb596705a6f422265993dde03c23da6d19eb16cbcf8b7dbda45c887dfbcc279fa43c91816ded171afe9fcfe0c5be834deb6b12533a9bc346827df16fc3afd93aab1ce81a4214be38e657c2d8b0b6bed88a75a9cea645fd7d790118fb20fcd860319a311556ebf29ea23438b40ba42ab63a191b5107b8a1bc0d513e67874fb810758e8800cc328c8be5c152215c00dc71e015308597eef1dcca0db6b1f09ad9e2c34cfdef83d43a394811f116ff1dee3e79311feeb028be3a9449d5fe712fa953f1fe5d663d1b81f1ac982c1bcf60458c79bbd0dda36965d0cb4469c0cd5077dfb6d51b98e8bf2868b4e7a3c7b388d5254193775035e5eefdda441645a8b166c568342db70d1f3249646e8a4a2c350a9425765f72a075ad48e66e92e28c24c84654c2acfec4355acb7c637add0e4ea77782a0ce3cb316e95dc023c8c91acc7ac81a94eb573bbd4b72b1b573e5fd3532fe86e2c3f516aa64431843de701237e30713db3a388155c357892bbc3ee6d3f44c2dd312e3a90df70f15f38f6e4537a40c8cc185b6daaa00b997f41df16bd1ef5a71bb80336fef0cbdd36e9180e0d45270b9371967618b5083a7af321734a54ae1361856d71450f948b38de4044f6ab25814d1c0787706f89ecf106ec7acf6fb5a250b38cc42e0800cc897060f1b6646253d798c0416c535c26adb05c6673b378097e27f39517d090ddf284baa201c7ce035227ea713df8ab7677c33526c0f3423563d4415e3df319b41abc23b6b1b8a8df80825a957e0aee85f202a5ff3066535412abced2880cd64b66e50be5415f758401929ad7525d7b8cd83652c612b09c0db502169c3b6b3af0a13cca45f4863d70c9a50ca9e4ce3b38185bf13cee5deef82e55a3675c71d17cd04918691bbd84d18e6c65ee51d2e96ef9dd1c02efe9087e3ba5fa5dd6b1e050ff3be34259231e58bb1f285d01c40c472eff44f83d299a8ea6f7d2cf252d877f6de6a958063306088914065e0f92733b9b326980e6acecf40f45218f62fb777ad1cc6916c90deadc7f4f5794197bd7dddc470707baa82ba8768d9b1a420a3aef7709eb865b0f2e9ad9cc87d06037679d149093f83a9a018e80a5160109f036cc1617c8edc439b496c85dcda1187bbfe47ec01870369517ce3d39b02c3b130b97ed2f1de6f116054f38c959be263b175d5d466f0e52eb1922708c29d4c9f0c0c6959a7fd4c664afdb393356999f2d6fa9d5903229d6e9b28d0a980c87914d9d527259738b92157b2c1475ffc5be2c3b570179256bb96198d9070da02881fe9a7903f8bc3ed65722a120eac316556a4031c33c37388f37651de2a3d1201dd8e260854a92ed1970bc0a8bc43eae2a5851fe59905aa8a779c55f995852d4eaff666b53503acc8bc048747a5e2ca35be6212650dc386bbecd875f2c1321a3b868b32c768a3b055461644629a24f409a0a926313f83dc3c6c75d64d84461f3b0618d80f26f3256cbaf66ee77292a73924a4ebb2f52614448dfaefc12685696cad44246bc6284b2eec563dc06dba0ad2e0920646e0006a0ecb2b9dc2151a310c5db45b75f592002f039acfee72d5d60e0c13543352d8bc32cb8e999f086c55cfaa5aef12a77ad22fc7fe0f98c4c83b79e424cc9b785c84b54a76adfe9d4939694a3e5edc63668efb0ecb1d45ff4deca29959e969938fd0845b4527d0a5bd82943229f55c1f3026b7343c5bfdfba6bb06f515055cd6aa7668492804cf62c1a9c0a34262abf5ce032bbe2d2556bc2a2b37140d7f1a437ce43565e983d71d479c4ffc1adec7a67acd4ece769f9d8437a4359efb9ac259b056adadcbefeead12ce068bee7cd5480ff3dca420105e6e0e58cfd0ac6d2f0b01dca7b2c673e7d31272a600d39b7cd11f24c1ce733af483b2a4d0eec3f4eb9b71baee1248f3f9ce4de40f56ca56ed56bdef8d56b6e8258e9b98c9f944aa3823c6cb8863a9e61223bbbd4c7bfed7fb2461341b3aa9456a1a7444fe4a10098cbc7821252e8b4847793dcd5576dbfc7da18c2125a7055cda74b54a4b75894e7781fa2995863e600c608eb9ece3c43a0a039910d415aebe4acb81db86868b4d6f36f3a56abfb0c238c4bf688197d27e3dca8fd8844af3a481ee6540142b84bd979d904ce41ba1d271cb17b77c2a39e373381afbefedbc9fce7e33a8976e2c7f98be4f960a24c76f3551a8bd8db7d5850fb72cbd7489f4879bca83d86cada2bacae59346ccf34fa2e7a7ea548606871ae365cfea3b7c2da57e238f0e199c507cd9e62a4a70ce3cd20289b2ba73f850c286a289a52f2bf15355e228d9b294e830852e19dee165d1106ac35313c636d9bd07bfc01d49549a20048264778bb70693473cb37fc2f81289befc33fa0bbddb62a50c1561245421ffc8effe589c6176075ff0191fc42e767497b213dd03edc5dd514a68042cea7df1f10e47415cfd00fd4c0da9534eaed607249e9ece1a0737ac081189a1468f70c5eb8e224cf4c08491554118d3d4ae5494098d35102b9c1ceda9795abec2a2bfc27674b4b7336eaee70ec8295bbf9494f23ec818dd011b22161beb0c8f949e593ef4cd7344e6b7ec2c126ef6b9cbd19a93c24ef922d829b8fcf73352d168f667c25cad92b42541bda8556c3ef633725fc18a0a933b243d0b72ffea50f62c0fa00c519f397ac2e49cd67abd520048bcc93fb3f75fd7e788cd7b9c3d2ca21fa7dddabec987f7454d8b3e3a59eda13be3efb14fef222aa06173a5fe8c2863f22b3020059966a23c39bdafc259fba68e0a0793b2b8658afc9d9aa1edb300a96c8473808dade91a3c0cdd8cc2783ff28688f5cae04cecfdd0ab59bfb57a3476f9f235772da19677e69dac1ec7bc98c172e3b4ac580e002bc1171f5db53ad98946137ebb57f0d6a4029882e9da20ad997cb3de4a6471882fcc46781166b629c775a457af7e9ecd49945a0eb56de4e9bf028f16fb79176ae47b7adac63aae3b41314183d38af465d19d71465ca7ad510204b7171e1defd04fbc91859bb662423d701d013d09867f416e2dec47ca8e418a23785c7279077a13129d525db21334823d89bb246d01afea8b70caf0ae485dd2e026fdc5f2fb4f422e6a723ed75de7cb575a38c1fd98dbe0cf61b86a56c7d4ef959a97aed09ac5c0b2c70c1e2bda4e88b65977afae379794d5c93a90460f98ae4128b62f131a73ba72586341672d365f59854b7dca13bddcf9c45c36f5cb6e88938f8c050b01ef0a75ec96bc7329817aa948bc502c44eacaad7b8e460b098ffd79c4d3215d57fe6109098e477ab9fe430a6a497825d7db9f709143249095fc344beba2ef7e42119f86b66837c751e63b1719949dc7ebbc3a546aaaf2fa9dce26cf0b6b80e5f7b66e42a81e7d1a9c0c2945d324244259bdb531a1996e6988680892be7a17ff803a1250972f606ab68a7735b95f2c8b59093b9def597f8f848405c5fcc8657cdf0e62ebb1cef1de0dbdd962740a4d345ceae159bfc6f1952b4f3d16dcb5d693ecdc999413f4e3149acaee5b89d077f921b48274b2240a6b3b5b3bd2aba576f8104d8eee2f271b4bbf07a9b8fbddcf76151fd361a75ecd94c9df7741ef8d65c8ed3ef07f4fc6d9786326c8e2f6ef1dd89954ef848aa52737bc983c85425a50c8ec66fda2267ead8fb61ce403a4bcd5a9bfd5a2bfa193924078820a91b7816b7b0be04137dd3e53f6e94654b269addc537a4a8531840d99f217e46555d89c9b5494cbdd6442514797a2548aec744a7174c1f526a5bd0b45be811001f17fc6861759172a6c0abe440d8d8030ca074e4ba2ba650c2f21895814c9153425625dc9dc99ac211c08f331aa1c620997feb5fa21ea414c1c419d42458edf8151af3dcacfb84044b12acf6c7b8d7597a541a92b88ecc2cc29a0a8e9de7f83d5479e8bfcbc391cda976cca2a7e07cc072ac8e0603c0eae032280feb9ebd11fd3408bd66e0eb47e87847d872a539f0cb43e12d59efe30eaf0dc48d37eec1676130d1822b719b5fc2550123be1d8a3eb29094393be8c2671ab7245b9840b2999b832ae553eec1a44dfb35f5d315b482e2b808a3e86cdf05e7763f90f55e5e9b45951386c0a7723c85d0b1514dc52fcc8f8fa7e80dd9032ac9ae9111d2b20ad1c7dcd847c97abf0e1b43704b7210f353a0e0ac22da7b114a164cbf2d5f465ac6236ca1047518ae8bba4095739f6765d10f37af3f210e7e5a1d55e2d766e8745620bb2bc1b2d608832c6321ce795507478d1c51bb417b4573872326f97aa70f087512932b43c55073c585fb923761fcf3ef618f019a93d4c37f0c9b5311e089fb33eaa0ef1bffefa14e913d68f94bba4856e10eb3887600c0d2068c9bfa97d43d8a5636afc490f22befdcf9797903102262abf6b7aa36b29c9493cfc7b0a15276a419a992ac4cb469240aba7469dfa54a95aa8b26915803b17a96e24c2c326ff079909ee5ef05a618afcf4c519933417f0af77989353a22c4957c55eabb7b3018a3a0cdeae67faed2ee7a15843131b2218d935fb43027d00d3df8f82953b84f0f06f8fd5a96556b4cde819ee25555fc0c2221281ed231e9da8387c46dc27a45be7ba6c3ae2e6227192d6dd5979473b4a4f943db06a95e72445a7646e2a047029b1b80e24bae252901369de8d75acafc1edb2c38672f28219cc9b37ecf34e1245eb765f83a33b0dd1e63820ee80e551228fe10531dc70a90dd084b395b6e1a4d4d8cdd40c2aa6c01c026d67faf35c1f48886a5182275234df9e809a63f4fae014f78750208146e4b2044a5ee571dccc7c980b3578d8fbdfa714098031befcd70aa79e35edc88b4ca51e2780f752579c7f91b912dd9bffdb5442cf0385bf0cce001e55e230f300517bbdbf786b76e27b93056accf82b53ad212c84392fd9e27a15349f8f5f4097466eefbb6db5978073bfd9281f5548b2c347d61fbcf270d16b2d4072c44d25b2ca54e83e7e7e024914605095a1991d5c23d365701a69d0ae02a3dcf5caeb8914f2cc422808447fce0e0709c7d505b3852168bb0a882985721eed14c684d1bc68adce5755bb6ee279412e5cf2d37cd891c0d3c5b559e9770fbcaf442e50e64741b182d17c4ec0e307264ef76a3e3fa61b2ae9b8dc119dcf704a70bf6c6c27db855c615227ba52958727585b3c27246b2c62cd75047304bad282d1b207b71880a95b17f0146685dffc9437e5fc5652d7e5037b6b432a4f35550746327b50cae16e49f60ab1369f6138cba3ed1439382a7ad82b2d7df2ac7f83ddba53064137b0a4dfbbacafd1ff1096f40292bd828ee3e98ce780ea35568c3efd33406ff6204babca06cfe920ec060a10d74285c250c5216948df33897c246ac3a812b687002c3a35e6f3888bf0291b60ba450cf83bd2983905bab48da2616b303abfedbe99d21ea16ba5532cc3439510a65a6ab178193afdeaae0225f27b871da4e17b6fafcded2e682547427a1a581deeeda9531960fb2d4a51c2cd9e0ca7a266ea598c335a0c356a4f2c438141d56087f55b557842dd1fd4a36e2e61d51080273f33abd320f499dfedb7b4af905b3596b9d2983c7a12aecae2e0b74211bd2fab02dc459a9756ed562b2911ee2d852342eb808e5e9e87867bd1b164a1cb838bb46d1a61e3ccbafc819f3a4590627d8ed1535bce6bbab57b947ed9687fa947f6771758261b3daedee367217c459c315a40a7cc42e20cb77b4b78b01d5086265b60f4cfbdfcc93dce86bd030527c50ea881ff12780bc832bf073f44eb12047dfefe0a542cb0020366b2fb3cc2413b78799c2f72aa9a8439cd1eb388c58a756fd4b2870092099b83d9ab1441fc799c0ab7b814863bb2391ebcf56e1aaf5177de36165240fa5687da0ebb3598037fac967e909a24fa0e5c1a8b5efb29c00531ab91c5768bb5bca0dea5e9ec4746cec24b8c0e7ab0f460f309229cb5585e81e9e8cb9588bd7313ef43e2d350a0f1bcdaea4e90e7d613dbc249242aec4b087bb88f3ef8e86b6367c38720d843e8896e6a7bbe5e7d94f55621c6d1a48cc5694f23974adda426ca5d7a0eedec0b4dbe2937004d2ed3334ec6b38136dc275f7c6c056e0626d8cf09a05ef93d322978d4397b22dbe2c7cd1017ac161b2745221cb077c2384178117bf3dc77fa25cfa2cdfa8153400a0af5dbbad9e1a91f9bd1de0c2f3a9e835dd3907a8229b12e36a045a569bcac1c698d780714c56b65da5ef02602f1a879577a1fa24de948100445de7321a68aaaf19cc96a3d2b589050bf35fea6733a4441c96dea220e724b92195816060fc10de257adb06a3591d4bc86fbb2c7edc3ff1262527c19117e1fd1713814c8112f5dc882646dc9d020d26f24c6fc625f2de04ca0f3f4c94c5fadd51e572c0441d66120615b68cf7fec8cc9fe3b48a95da55aa103f80537973643c13706be0f70099b5df1919a47853673b8a20452da5c36f999d50c695aa0c818625017c6e78fbf2cf374832d0eb85b3f7eb9c20ebdc41069164309eeb8889c6ba82115a2eec05d3723cd1ad4c9a06e3193796a0653d8f6f13106cec50932b0004d62edd8a727d3ce0106aae119badfe111596994ba8d87b9a51b210643d350b3e84c55f30cca9d4324a08642d87e5b764bf51df4f1335c14d1a792f19c833836aa35f7c78e5489190928a3485406e9dd1b3a692249811074387dfb0862d9baa4b14b8468eb1eaab6319c5b67e340f150401a51267002969f9fd2e31bb273d464e1e3de0f1bf3769beef5898f9ca68939e3dac75473bc43417674c2f61a3a2f08e1a5bf20c2e3bd8c4d76cfd1c2825dc14c50ec102434a46285d55e92c4316a6483f942ba5d0b27c39cb1e08b88e30d88595dbafd3d6192ce589bc19c3414b60b9dc78b88af67997fe2c76987116035f479d90df4c70980075b3f8c9b6fa0872e5418c2159160967f8dd0da164fbb1972ab886e85f06600d3721cf04f47cf89e36ba96129122134e9e2d0b44bffe07c8dbf4dc2b5e4cecf53192f91b54eda3b2a1555c9b5b263a6a50a531627285c7aa331b68ed3df797c3e49cd6bee0f99273a6bef6a52de7729b5fd21bfb212053452bbeb3b2dc0d530ee7565202588fab7537215e3bd64dcdc571dacc5a5c6c2f3a8c373954f8f43f10fb23cd1e7919c1df555c39df25e44aae0ff4296ac0ed2ffa37c5c6468d30f80ee17155a254821738ac4c9312bbd4b63479f4d862aa835302e1544f44f6841f913a00285c54a210873ef96ffd44204c60fc4f4b6652e41b63e922fd7935bc589f49dc0616cc933870843186cee9aedb05878a4a2f3d1c96d8b19bf96034046dbdb5d36c53a2e2f17ae255dff396f4016e066ebfaf535b4de3a1af767d42adc1c706a9ad65797ac042b100f56d412ea6348c2d669c0c536f6faef88a03218045ff84eecc4288f46f78fcd8d3dfeb1c17a536567b28d86ac93d9c2bd1400e509abb90be8de77ee29c6a95bb7d6e4675e11fae6eb2490782c72b747fbf4602e5da4ae54c33796c3a8e8156d610fcbc8064296428a76c484b43039942126df575f4f73e5e778581ed42c6c9ba02c359ecdaf26614ca547afa3ce3c8ab5db1ebb6c2d97c97a21c5772156a909d0fae00977c7099f5194f98a9ab7cdf96c1b354194b4641b8cd124c90e02249825ac8f501fd70f5779c9311c3f5d0a9ae124876c4573f5063853e339971eef813888f24c286cb38282b753aaf4bdf113a93a3b95dd2d5e5fb18733c6b6764f125480e39375277cbbe8abe34aa1c0b08c877193d8983d4a5d8f3cd25beb71ad8fdee2be199066fd4e45553b685e3486be567e5a631aa5a225ca3069a60fd625ddcc845a2e1b580fd5374f1c431637ceba6a754d9381f88db9808df243980fa0257c15a0073faffb341b95b05079fb898fc405d362181be2a41e8165a8f1b200b4bef3743d682f10058b1c9cb7375e358428925cb38848460493171825eeaf98ce743f5d0eed8ec4eb54cf7c3d4bace14e8b58f2b4ecd8e7136fcf477088a0e046c9a9c992856106e186ea61b0641527434e72ab2432b7b3a931e0153436d23f4a431656dad3bc75beb68c9505c69c6c3320368722f3ab949e900efa4d2c05ed9715168506ebbc54a2ed3940482a9329487ab7a1496862cf73037035e79fbe726def7c5cf94a5d99d59719db73be2762c1b70e2548221453ed7a698ad7dced11424e5fcc1be86a7d1111ef033a87b06ef1baa8227274125ee142003033ef1907daf69557407db57a2771ad1b0f7a25997874212e6e0f5f5092efb19a9ab946bf2794916d3a363ff8620a0f55a65437eed116f77103367c4eec428a500b943c3c2898de544ae63e31ca87080e93a159008fd3a6d5f617bdce84c386676f01528955b5de789afba6e7d01bc55aaafc60abb32e9992e977603b4ce2811f9c637f71cb051adcb82907c3b79d987663c8307af7de2848af1e0d5344d0ff362a2864e228c4097f986de8125160c67e0830906e5471844c2b9f2c6af51526ffe493b769e7881db46332f9acfd2c93fa7029592e7e601b31a49f5e0dd680156df6628136afb00bf9508f728a7ee178e87f4c0875ded99354991a3a402a3d52dfa0fbad9e84340d32459943a4b4d1abf3eedc2c7e65515f9d78bd2cd927064ef4edb70fdca8ec27c03a952b5db165a49c8834861154ca349dac0965216b06de4cf63d982de49f39d67614524888626dc2e0e20a43ca7addce93600ccaa24bd657eda616d622a8d6b32d6affb28f5d7fcf6405881bf1fd271fc6172b1f182808b43e1dccefe5f3fa7f1ac35576671761b1c1be645fd5b4c9491df73cee3cfc5abae73be08aa6ea04c3184f609c4e0bfefe849716870e1a9f5a51729830a8a633befbf51e6ab6099e370c76d942fcd504a22c2783b10b30dddf34ecacc8722f771538fb9ac513231fc7827e1fca8d1d8325010c453df0ef4bd5522863f5c830f14da8483ce7127992a5046c7cce07cc9d1bcdac67efb24d27c9d58ab41c472b64f9fd34304f29c5beb06b3ab5be406e60dcc7638cc9fc5cf8be6302bad5896a6f7b151d05e3f08d719e2e33b2eb8ce090736cc75be4e26b2956f99b377abb77f2c9c6fbe906a40d315ff49df3d8511c42e59153fcd7e8b44279584887c6f8b24381c166ab6766242a52ace6c5f38580dde7c35b5d3bbcc836fa5fc1a1a0a1b8c0d60b919df13efb34a689538db3e52813e3055dcb38e13b7ddae628cc6bc3cc2d786e3ca9d8d8945930c01fbc051de41444dce45c6670e2e1715adf325083b8bfa07e7dcd8bf4fa9b92e479817d6b4eca8c838d3ba44307ba149afe9897a04407c59a7ab361340f2e69ad5cb9d68b3f48cfa46ee3437d07eafc2cf304bbb155711f225d7572ea8fea56675e4e7b686578c06403cad521a160b6c4bbd1ab7367aeb14634cb2bb69db1340498dc7dc62da67f426fd51cb0199e460d8a7bf01bb03b6377ab449bdd60941b3ae248a0b8b2dca72f01371c0cdac2b8db9048def1a0ad341a32fd1a3a1a295cc00c31b7c1ed77ae5fa8f56b16b05f4d9cb7cbf294ee0de991c2dd6fba8b05f1d02d0c8634dc9719fca90098c79f9dc2cbb7674460751a77b179d3b10fb2230887fba7baa670b40fb92ee9e4c74384104c7ee2095d01988d1e05685a99be1cbce5e0b120735f73fb7c6f66233b5f092cc32e57062fa6056be5cdfd7b519c37aa88168d5be0be7ecbc3923152861c3e81505d5de9709745f450cc22b472777808674fcdfabe55bb6d057ff64006269fd659f4d11b77da471ee35c88a2d90c301d5ddf3528c45e39ef0e845cc51320cb37e7f35fbd3ffad4b0c6e79e3ab62992676ab0b8b3cb05251a3cc028c7c3d69b5788d522e8767ba7a3f0ccec439a9622bdbab3d9dc1fb0fc16852d52a528bc8780a4e25d24ad25c29f5711c8e7d45f9cbe97c42e5455d1e4eacd70cfd7c6354c99b942430685a0b9c106b58e69137d9a4967149c1c6fd22fbafa8fc1d246ead23a1b2d6b8b5f9ea49c7a88fbfa8db9889ff089a001d3042bb22834c8ee46202e1a59ec1db96d78aa87d67ee176aea66811cda2b303b3f9244cf98e4e4814cb652503b92ea614d552b5af91a1ed5798ec4530003cc719995eb76572c97f1ca0e5544cbcb5e1cd0845fd8a89ce2b3b0641da3a44f6ad3f0ad1e0fcb024bc4d5e8797a59231b852dd18dbcf77f40f3d71709b753f9dc11bae017019feea4ebb33bb9b263a526cf6f374157effef7c2a8403b34617dc3c4c8446a4c67e9c56d0d5ba463439b8f202b35d19a42762f7b78c5b450c8be7eb01001dbd3539015c2e7122ef3578c9b8bf91dd34fb26b738f564b9ccfb292062cb56e1e751a16464e6eb844f28b288329e31a2fb0fe32d35b1db1c9adb067dde49857dce0f80dea1b8561832a2da2433613b27b26764bff42e2287d9dcbdfe33ad9466cab6685556c64e2b4225cab29b1442fd83ed0dd216e062bbb1e63bc8711c9dc73a4fe34e00595673c24f027a016ce04fa94146bccaec34285249e4897a21441519a655da0f9c90a5acb3d992526db14ff0dd8a570bf512de5ae9032900465d3fcfbbd4fcdee91044922cd729a9d551e89cca4ecfb924830b847285cae18ff0c992c517b1f2251398aa8d45331d34a95642074c3da29adeb1ba2cbd94a582ab9acf4cf605d862a51e3bb61ef30ca9f2a5297c7c9d9af5065480d73e46a361bec9e2a3c28b9dc3ce121b17ea937420024d7430c8c1a0e47ff85ba7489bc42ea06c7848be99ff3f08ff1961b8806f52f24274854b76fc06181e7568d163edcd726eb0d622412b98430872e1205734877c897edb4549c114981df6b8572888532f73d28a38626dbd4dedb5eb05e355ef41655c9b9de32bf93f08f37868ccc90cde819e2e1bf55bde7cd68caef2ba81a1f3b45d8a1e549753bd08672fa49a9e134ef9596cdb4c5115f44db4706f4ce394e55d2d5f9f7a4d7374b097e57a62e48f5148e423a534c7f9420e829bea224196ffd828ec9866a69e060484cef8fdb06d7bda2071031be1d8080f28c3a2a457031da40741267ec6a4b9a0f3caa5fbfc5133cd3bfabd8630b853073d27719c529008a8e5dd931d424bb90f682bf1f8b9f286a239383e7fea24b75a6300d011f75d8af63de3f0766ce1d95b1eb86caa4bfac0f468487117897a7bffe0f7176f1e7ae1275db61a91f1fb8904a61f7b2d8ab8ad54f4a8461c3a88a30117cb17b4fe5a3b4cad360ee8660b851d6581d300ca3621e67459a5c1448732082ea335c1c36cc7c02adb8b43c381dbc9cb73c56203ecd842ddf759305bc445f86bd6d149cc1e6f244dfb5b628639817e3ddedd4aca57482c73361ef79ee59704513802d799eb462466fc693f95a313e551368fe558c1045b77416cb31b7a3d46fcb261269e3a36c4e025d4bb4ae0eea50b4e3a291a23d474fce245462bb3de52665db98db0d0ad27f6e26c49d552d49876c327c019e873f5c0f13fdfcd132ee824704d8743add4ba1e7734d173213e371266a8a471cb4594cf50465a6b4947e6d0ed303f3387afab648c213e97d94e6e56c48366724b4668627ebcb2b7b26c1b7cddda7cd6959634df181d57ea511c1135161c97dc31f6ee297e6938196029b6b2baf0c6d090a3106a526a4e39d9a320131cf0a025c9bd91c0960d6ee33b1ada9471ac29a4b290fbf0f1f1279f4fa61dba8805db1197763d2449513ab49246b5005c9593862a4194e8a6c7bb263041f4655a60ca1448e10c5c93bd01eff29869dc3642d6659cebcbd07adf0541edcbbc3d0845ee80aa21e03ec7a9714638a19cf7b948697980a98e202e2ee5b0c77de4243ccb58099ac47233dde5cd5783527a8980df2ce6ffa363892ae2aaa1dcb2784b2d8c2fede60c3a3e0100cfa1b6c3b726cefaaf00c76e17bc15c8dd9b95e91b4eaf81f54bfa31ac549413ed72055f101a210f4c1826d4fff02a4b25e77212f3275010ade328959f016c9823352b9783fd2f1a8dcd7f4d7a41cab640f9c2ba6f89199dfb197b13e1b25ef6d1f71dd16458e7ed3848c5ed4674dcc9e97171087ae055c5e45f1676b8e11595fd8bdfca737edf2f36d6e477717aaff053412989548f918e27fc5228d205e84723b0e8c8210f4b30ff3931bff8b5b1864ea8c17f0ff17b52b2a95cbbc56e0aca339eeabbe2d0b47674cd069bd24d2cc08d45d99cd619aaa3228422b50e9b475ae69f71989a7a19cb0d9a0b782c5b5f56160eaba56fe7b1ab769249c5a2216d9dc0cc0bc2ce817cf7e3b7a58bf9bbb15b8d57cf81669cdebaca7d9da2baabcead0005ce3d170a44dba92bb46648498c5654d47ce01aeaa078ba81b3fce0cf1982bb9c4211572f5f05c8c5f9f3be3cbd659c95848442ccedd0c254ff86d053d664d22831f61bbea795eed7d29a57ac65e0ec128d82dcf49a707dfd6e263bdc1e934f353dc71de5961244460079ea6adaddc1eab3aae4b15f80fef53103a2478d16fe4adf61b9c3b2a12a7d7492d2b60f3b68d67f86c2ef4c2e81733d35a2f8a3f5f89a01e186b5f5d3a4b22f6d6bbbc6fa44d9314490edc3ff3870584908f6f89acb1ae7dbbafed7c4870170cfb273926e523b9f8a979f90b2ac02a06ea72b715e79153d15704d2dbe740566ca913fe55d450a10efa5eabfa82cd974b1a1f740ea96e6c3b4798afe685cf1196acf2f9c91152caf62e78283f26eb3ca8a3dbfb762fe3303394a5b4e6d53da419e22fff286ea4af2d919cab357ac301a7b9ca51ea7a8f9bfd6058d5b616a78ee1f903d6bc5f4c7003c8f9501e1adb69b40cb9d8399acc92e6215013a39750bcf9a96f53b33369aac0d52caca339b97d59cd5e9a89916132217705f965834fe3016506060ef0f60234e57328ffb91c43c799dde5f610537a5c1f4f10876481c20124d72cfcef44e39e5f45b2a6c6c3001f4b2be31865645fd091c9804871d32ba6bdcf53195b2b315fb81e31b1e696f4726fb74631bec0adfcb8a1e5e793fefed84f4712c0eeb9a19d466949ee651c59e0dba96c2df3a8553aac271fb00313fc17cac42e350a55b583fca570aed46dfbe1ace23b71c65eed66cf9b6dc9d33aa9f1146240370c281221942a0348909cb54675e0a6534c9baa72147c800c17aaef4c7df5c1fb587e5c63c1ed7830f37842445cb021db041a6334bd48fb883ebc0babce2708e22d8b5d6c695515e920c89d1239596f9980259eec40adf1e15e8fdb6e1a239848a9ee9266871615434327c78ebbc3eb92d3b59061adaab161cb0481ada9092723f6d13dc2ecee6445302e464b21eb4ac601c7a216e7e548040fac1df28dd4f00f22f47279d692d0d22062605abb66f829f1e1a9507adab3a3c5c40b6f03c68cbc4712c6f7ee2c0d220e81624b1990be1809b77a19ea53c0dd89d5098d10b4aebaf6eb3fdf3de52398c4094985816ff24eadf1c539afd7660b2e7d0895878576cce62394cd2089c6c3a85f9ab884b868d3fcfe29445224d4295384f7b20820fe7dc38441f67f91fa8979a29e8e82a32b2242ccf941b528bc637289a4368ba44022a872cd379967d3b7338f7477","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
