<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b132b1b2a7b7d395f4c804091d69b310c1ebb07aa631f8b7233686fbf5a5507b85ec6897f3bfabefac67bcfb67bc42bcd02afe150cacb86401c5a75429c1ab15566fa3df48828b06056e551a3a8194907a84b1724678d883e8a937f009a7b83ecf3ef482fa746a2b8f832a7a87f937efdbce6082173c92eebca699ebd941b50b0882c1d5fef5e5f6e8502da3d15285e5b7dd9d3266eae16f8761b7cd9ec92bdb0cc1eb54dcac1c3f06ff42da1e2ca1eff83ee25497a02ac6ad8b948c7a354fac1dc2ad7f556bf747d73d51cc9f82026830888ad91e01c8ade5428ade803206f7056eb587adf7b239476247cb607f5daa6bfd7ade40bbfdf53917c8da1e0a04cf9b2b50d0af0108fab8df7ac9f669f3f35ed951d5448bb40d08518822544ee0c8a8203524397034887f5c2aee81abd8de4da14b72a90336121f627d2160bd52395c31397d82339f845e834aac7cc653794f2734c0a67400c4c1ec0a60e48b660d59ac04eedbb65c43c51a090e7a0c85608db5dfc1082c3bdbeb79b78a642641c1fb0aaf74d775da754e95cce067269ed7dc6d811538559ae6899100636510543b44ec4290655ad3397cd380f6a6d5a8ae460a351a20eedd1062689f0b8fcec5ed61c643316eadfd60c49768207901d968b33d862cd4f2c2e6083c41fb54de39df88aa6c0530c50f7d23120954afcb5ce3cf2937accdc424245e104dfebbbb13743e3d8b192edd0dae3052f41a1b5061971b2acbef5c320f4e965a79970f969d654bf8b5328f529d401eafff5cf79958ab225829281d236d9018d4febbdd64f7f780523d3a8ed48586780a2bbc319e0a89d06dd235871b727204888e8e8fe32a5fae3e9d0d69259bb7753f8d9e2c92cf5ba75a579700ae9bb6f9058ebfa2d9d4d8028eafb4d06439f46d2ed8afc208c7d5cb378e1961edb142913a2ba58c87815366b413c9144b01eb8787eecf3b88223fcdb6f95dbe4fec9ab2983993c0032d82a09ff4a6d202a593cf703bed854cfb4b3de4b9303475ef4c022a2a4dd759bf4b7bd0262750860ca9d3b5b3d1b3c2f5d848ec9bc3d7dbc52fb49830af8ed1315d7f2cc4bec4e01aed8f3cc5a24f746d9a0b3d9c07312658f8ffd00486300524fabd9408f4485c4c91a1a0795bb4e9bd3bbf6d5a016565b87d2ccf34b62b96f4f714b566c3577b4562b95237c19ed1d8564e4772491ed257c4366c9668f31f66681b0dd028a57d56758132fc110ecc0244721c6b30a49898e04234a11cb9aa680d465c17e09167c4f2ea050ecad694a9abbd5db74abdec65a6a56258a29af62e4be1a918ffeb5a68f248218f043b6ea030c7e8a33a0100d800a5b30481b0b8f9256e76f8ef85593b3536d1413b799f8ffc4ebe51f071f058bff23f4cd2a553378e22c28aecb2760763d460fe719a9a12b8389d385531372600e1628935bbe79638e2c89cbb284841fc0855b347cb91acdaa3064edd70e23ecf73c772bb3acff373eb87be55c036b9785ad9378fe351e65cb387fc5ebc1d9eb07b40c1e42b3371c9da688512f63fc08057d489d4e63bed1c98292c85acd82b563b7a539c7867a6dc08aaa4097990ce26980b37eb8b4e316ae08c4c6e15262d6183115d2ff494e4e2a94deccd0173ce88f9707376259f556581c431f46cfa77c1b4350b312b2f7c9897652a4fb979a8ca7e2011e5e676cde7bc8e58c4424aefd462de0c6d9ce3b6adce5060a1b4bf22eb86537df12ea5658c6a9f28147e4cca10df6b5dda214fd96a019d3bb356e55c8faf1b772fe97232016c414019222e101fad16091fa8b768cace5b9ca7cb776d2dae4c3f61348a56a87c66a822bab9a2c4fc0dc9df7f81bd9b904b0343bf378ecc7068cad084816ee2fc0c794f00057f3c6e0ef81e92f1ef381b6fcabaf26f9eaf58e45f1130519dd7e94b5fe8883c804587473c727f7f12219ae206aa3051db5af1dbf277759f55f408922715da60bd0d45c22c46261caf51e0e2bdd1c5ea6be93182813be78f54c6de3c586b8c92bfb0f06eea7495d5e49d6b4870c02116ce0136ff3063ecd4718756618ac0e410255ff7ce968f51c1c849874e24d7b343565d8a70dff68996359f602fe68a251f0fea3874651ba953ca167016f379d5b54051b30a6fe540f393333fc402125430ae81e2ea43a7caf890c1f1e559d16769b69342cd2ff18207ee1d8bea7c23da83619372f0933c734e1e2ee7923c543b1f499e646df67462ddc25148122adaeb625df45d22e20e9828fd4ca42aa9cee02d519f0c5c47c087bd26f9dff8f881598b3455f7f97362a22a5ed8cc37fe7b277a95dbc1c6002e47fbaf7be6ee9aeb75a27621c36fe14394e62f61f883662488c060c2564a0dc54f56cd435c78890377abff73d77f28b78f4a4bd076f681ad74216d7781e8ed7ca6da280a1f67623bd4d9b3bff7ae6d5f69272410380e156be1db251b0ed25c90e86cf0c315e4e2883850651084305ab358b0bdeee9a199d5726991509c626c2d7c42dee0b4ee48407ba9f7b047e98b592cfa6e5d5ebaf45d52d4249019097e93b2a040d294ee1e40774e2d9a0c4fc1714d7ba03081980b62b678908353e4e18f7dbcb0511a73ec5d96ac7a0d906d9041a63e82635ec66a83216a93fad639cf78c74314ba4a1e3420fba903f777e1e8cca1f414f1bdeb5b85034bebfceda573a4793e5d0d7d214243bdc55a80ebfd1a334342625bc8684aa91ba82fd62418d1e554f2a2fb4170d22a0caa709cd8a388710d61c204858f3c9720fa10e0f94d53fc0bd04675baa3c7e7d115bf6ffcc62a3ca4c755999773f940afd7f78e444804737dfd5406083bfabb8265f236157e151d29202f762d8e6f188e73a64e04c8c0f6574ee5ab192949d8e7bc0b43a17d597d00f388da61860c9f6028303a478d8683742d44733d874019122e6f4d6f27a8883c7cfd3388c2d58acc71cc7a2796d97983c8522b4d7c58dd161ffc905d905f9361a16210bf79d5f9998a6683c4644547e49ef26f2b609e2a4852649ef215b6530cfb515b2559d8dfca73e09dd2597f1b730a762b973be5a1e6b579d4c5c5385a18903e9d475f8587abcc2398808a82b1437c2c88421f6c3080ae6353b0d669ed73d3ce168927b9c10f228015e1006f9e4dd235a67b15b843e4077aeb8d8039014cb5adffcfd38595c0a3c800906de56a845544d764a6c42fbe2b0dc344a4bec381b8b73fdb11ddc60b356b1dd1368f151478513dd0dac24954b48ef7dd530cdb184618c22de29c733bdbff731856d5a920ac844196434c6aa3cc749c05c4f417b973f41a488b744118c540c2f0ff2ce3da3ae1208032ae40a3e8af817c5d3e7d470781ba2521ce5cc81bfbbac446743309212f6030eadb4376e12805b8ec4c98b5616613ee9211f380c408f5c352cfeb9bdcd268cb5660d7c736e586eceb317ac9937d0b68c25f63c8cc5a96e059815e0db761dd3d023e846c7ff75cb8368ab86738d60fb484c12c2c15566ef6fff924b3793e160858f52be68f6f88cad7d114ceffc97984236632080bb06e3d8a4bf40ca8628bacc8b7001409a3e86e352057b4bfa081169269dec2e8bc29cbcba821419c7794f1e82b849f234849a951a33bda32f91209db0bfa6dae4ebc57e7635c81a982ca4c672d7ff51a2018d859ac70ddb9b97c1b833268e469e2cf9e5f2cb04d2fe9c38deafc0b39d05cfdd2404d6eaed7ce6569db5c9819b35254d3f7bea7d8312351b72aaed2782afbe486ab34e320312640895022c0560fedfbe0eea02963f116dc8b0ca019378173c7cffa778c2fce9180aa7ae099b03898330fade644b771668fb4eb2b11b1cd645d5d3e12670a6f5f80cf5ba65017eb79e0b7a62a7d9510824a528310f588348031a52e974c6be06c3b082724734e6fc5771e1162f10ae6c969c8c9ce94ae10ac3089a61246702236e09fac561c0da070798017d379489bd300cdb73000d75709d97890e095f0852a0a260727fd5b39fe3552695b20ee0975b44a65e1a08440f3263f5ecb4f1d145034d17a41c1dc099a2671d6a858e3dbf6ec04478ed7f069aa9e6e3fdc81dba51a67787334d99cb2d820712537d1695ff6df1d19ccc546d4366c6af81997b5a4aad93ed78cbf502b136db7e9c38bc5d50d8fe94e287124ae581ab501579d5231a074c18b10d7770ceb5d832a16d03b51af0baab1f64c900dc18c0c57e9c735d0bfcf9e5d47a15f35f3e117e18e0c046b67373996b2229c4a17c72d659161244c11dd0ab4d1cddc1c78e8a40928ae5fd1ceedd5720d7f30024e4fef104190038c07395cbd4aac1c789ddb89406e19137b5c91c7f4697fd56c790a543ed56b9e78e25aa78da90c9a9283eddb0ce23b25bbbf2f2d786a94e1b11f2906b504830943dbbe38c30dad4870a22b17986477aea844c148b94596df9b42a90bcc02f7190c4ad4f3bde796c74dde12844c349208ae4e21762c543b06f72af580ead57ec885a5bc3d57dbdd4e1bf81d350e0e736c353493628747cc1c988375b76eb3ff7f06dbae122eb9b29ed118ec89850372f08b5f210726a7d4ee009376e11f293808de38a5bb940fa465a747f5d2c8bd898cdbc1af8ac881aad9ea6f0a020c1c7036321028caa082febe63eb20b4630fa1c18c4f35f96e132c72538eac0f65ed509366e491e2b62c0b7e6e4fe72d9ac397c652f7833c665d4eab5284643e6f883614315431abe1555eea50e754dbdaa71dc981ca9f00c5976caacac5933412fe7a315027c9936ac0e6e95cfbaaf6fa649248407e6758675724fa17a8bc48e0d30b10f859089e32babc45ae5fe26a10d130b349827dc905c0367884051d807d035e627b4ad25f2faeb9a1dede0f94f49efc2b90c317bf0b94123a27c1aae9b97fe5d680f1458acfac3e949813eb7a729fcc1b05fa1fb25106f364709edf9ac6c9a46cf1ffa50ad9808ee79df36115a8e56b783103f6768ad67fbd34ef33890fae1ad8057dce05781bf40c467ee17885a235b40d215d77a89d3622c3e52e4533740f47c02c68dbfd59c5ae67404d3303a6ec65cb591ebb884ae04860c0a8f63c684a7bee3ad4239d081ecb94bd8885f9bcdebc38d1827681f9c09e693460c888ae2de11c15abacd91075e7cc8c6a64a22bc6df7c0d5bdf3e71a20e4862aaff948cd26a5bc139b69c9ab67e4c0a1c136adc661dcea21bb8b79fbf0e1b4b654daab4294d952b1b5dfa13680b211a49b17699f479d54038f83a6ce5c7af98f61132b61478acb0f555401b6a8671fafb8027b59383cf7906f3d183f5b90c5624ca459510dcdc8e0ab2687bedbaf4d1bbacce71435a1919c44b241112c4570ed09654ef9a4b8164dec2494c164d18d5b75e26487c9da722ba7ebf56f68b59f114e4e160b04a0dd4f537074224c6c90bf20c14bf2382fc44a0e310e654949861a078bb5b0e076984ee94e6e0e95be16ab1f3259a5080b5e405d5b37d36490b5844dea86ed469c99098d0e52f566bb4e0bcf425be28f0339c2ed235d44fad830a35fefcab9e329f75081a9c2da87d17910ec57c5f8e86d99133fe3c471527f1d475019ca56b1c891041abff6d99ff47383944545999ba2e5f0d4fdc1386e66a4f5c2bb1a04a6c5925c656dd2a394e65c94921d52702320b72f414ad29d55745bd351df0c496c8f3611341c3552583bed193ca3b64516725d51a5a780254743c30ad47ac4b7c01afc56ad9a8aa487c1297a51627454179401e912c4f4f85ee5e27307b8c2ceaf2272ca339308246314da003ace48f06cebe620805ff3b647555ed672439c55fea2bd58ba724569f780e5cd0087b12591dc70258ebbcf18099feb024a470ff2f3c2afcc6c49784ebcd956710aefce72fef96cfabaaee73ea0a59d6e3a239cd88853f5511fc8f54e6745eb4026e8c917254c08b2338f45910b9095c827217b92ecff167fe95967a2cff7de0bdb65105c6c984938e8b37e4117660df6be1a8fcc3d5d905156a42c9c3261e23f32daa2c93bdf1c3388ecb26fe642ec1ba69786f49f97ead7fc02ad9c385221ec5b8c40d8f0e3e4e40b1a96d840b883e251c18652bc84a86b924204123df9c43f9eb897c11ab2f2f91663097cad2058501a865acbc4e9bcfad444e3ab5928bc90e5f2a772ab7411ff81c147fb0601f03a09809b4442a95ab1844d703429c99b25897288121116fe1d980442ecd30191d9601febae0028e59bd7702e859a69837038bf5977e6c8822ddb6b3b49e39994afdeab15314a51a7373f1363b63b519910cabef66ef15697ea19b1a669f60499cb2c5f6a05ab16f7be28baa1efa20ff17a645379d9bae9612f9760199e941a78bcc3cf31946998b5986821471fe1a659ddddad535d461e33222683373957ba8b81092e54aa563a987cac545f0d019117dbb3e4235db7be827536cfc3cb98ffdc7f762afae30566cc3684bc70952cf24a1826d5ae67d6b8781d078f99202a9587ff82640e9171274eb888ef002b42b5cf5083e9906c4b912cf7a8c3c460cd0ffe53a45fa548c3f1177b0807f4c1a57a96361fdd190faff2c3413e40eb13216d2af2bd9ebfbb6e393f8b34834ce075ce0d20ddbf6405b7cfb2ca98435c873332c1bda86e2d44725be5350386d890ca907ff2ff1b1b0ec9457ecfe9c43dedc01390f67c7d33662a2da8094d2134d9289094e01b583a3c87bd6aebea7e9cf75557aeb4907d8bdacce484877a237fef171a4f3ca1a23cb4e35c236a068c4fc098254591e4ed9a2f728f6ccf787e0dd21fd126c4e6f0405dbbe92c7a7e2ad6052f8cd82cd2cb15b27e106814e7bd38298562995c11768073b566df0249560a24ccb9c10b3e675fecab1e90459d066de0f69d3ea8d333f9df16fe1959d2f32898177e97ac3e7c6f85e944a8617eb45c20bc3fa7260777220e67fa74f36d12296e54fe5cdc53c1873e4427494d6b7b66e126df7a2b282c49d31064b448460144ab40624cda1b6d7a870d730e701f3c6d500ed8c9fa905c609ca3137880f9661de5018cec868a019329047a9e61671ad278aba24ce919f988dcbc52908b0205bbfd3d7b77f4c40c8cb2a6c9ab202e4797931d219ecb7fa8ccd8e801109a18520fdc15a7e47728d516b428ecfa5690f07845b67e4c614c01699c85efad0153f406d8047b9e2bf08f301d8ea46bb72f08ecd86f031ec59688abbfbf585ab2b89aa060b46722beefd79347c4bf526b40e95e120555f12d632b2d9714bf5c423f81cf70474887cb0823de67d7d79edb8daa6dc75b5af60717d72d867fb6fe9afb28992ac1b5bcbf5409b97ce231b0a81579ff53a691e4947aa331b58639f595ad167325611bec0ff2e6c56b2098f5685e20a5e4033b2f26c52d6733d991db14c3082ec3cc3fc1b2fa6423419ac9b12e2ecdd3e8cb552d9924e116d8dff45155f75bc2fff36dbfb11eb27609ad64b15037b1c0d5198e343527e1477e7c28582a320e631d3c105e11cee4698e4113de77ad6e908252a83515fb6bc6db8835f82ffdb7b495388e135cb4e88139ced4b05e8a4cf6f0fcf3ec59570063a21aa1c6b0fc7e25d330b8031b0baf8931b5df9cad4154d184db9c29785b9be00db4e8eca67cddd11221f5cf329017f200e60d1a416298f4f5495cd4c20594fba4ddf76a9b06b2f4cc7a8e060dfd1503cfe6899bde157405e6764f521e2380f14c9ef5fc0edf5c0622293af66d58a3a6edaa692ab419e0dd8280bf5309027301ff3a5cd9258f25a63a38d9da9d6dfc9c1a0a07f7095099dc7ad50218c6e40356a75b659135e51a2161f88b1826852e85816ea09751caffc361d4882fdc8f34c9d8e22677ac003d41e13dc39016bd2be017753fd252a3f8f4757eb17b2be397e85611bb503713c42c0a48b200cc3677808bd91a0197fd24a17fbcc5b8fddd83cb3e2cdfd0272235d52574e0d2b9a81c118ab9868ae5fc363cd1251f0f7a3e75e35cb2d8ae2d49e8d1327874698fefa8c74c295b0984f2386e959a61a52707592d3e12b462ee171ff2636dbb72ce6cb1b4b4c329ca374894dca48ce2a9f3d7640bfc8385e1661b41347f31ed08e674bca8458258bc1647d69ed71b24637811381ea151e5567cafc61199fc64070d213051225085bed7294e22d7b2ea4b00d9bdef250f62c81014c250fc6e2048da3876becb48f04bf0a71ad14957113b16abdb2c41cfc9a55154b931f9818389e58cf43fc7ab19d69c5aed0f64f048225767178790576b8b38aa4a23a4ffc9f64fc9750d33cfc0cb63a52e1f388f68f89e60214340f52634e4217bce0fb2f23f43fee12eef043fccdbdbbba2a0df0b765e1f08050fa740c64040e0ce87be868a7fc7183dc9098491ef1ee5e2a780a82d3b901392f265084fd02352616a47815dae260c41fa0ceeb80a7898cfb81cf894847e8fa235a21d612ba0dfd96fc2cd1934e1c15c0f193ed6d65e99936ed1394642966ece86c96c316592dfd08624dd03a02608433225ba31374493e0f7efb3a9646e908280a0a4d4325e50f5b6a91f5609836b7606909ce6bc10437335a570875c6956a8d702c97a8260727fd60adcb62d69489ed482b4859cfdd60518df19a5b70a3f17d25f03ac1bb571db8bffd1aa7dd3d26ba0dac763d6db57f2f756cec9ac32c099670da2ce9bc7fe87f23444a217b3b9fcb557496634b219f6d4f26a744484c826567ea9e94d1bccfc4ad082da9897d940e442cd52884cfd95dae0386f65b0fb4c9c3bc1ff6e15e133becadd11f534c64b67a1e55d20c084dc9c2c64fa2b7d35c0fc207bb8a69cbb643fd3d9976589ab9bdf6d21342c2ae35e8216f1f78b1c3c349b1a2212b0b253f105f96c5efd4824a34ec88349ca69fc33a896284994a5ef8959462f57ec32dd1cde02a49a0f63591fbaaee98e2946d7a7085c0abad2af2f5bc86ffb1e8349e10c5f9a749f7389753fee002717ff58a394b7bac147f1b64cc46c3d29ef28dbe72d87cb1935d75fc22b4799f2bb87ee3a476207abe7d9b5cecff4bff5dc7f5d7c7e09ff35fbb484ce15371aed94569b4a3afcaf95c78465418b26375e936b441a2d24e09428b4f8eb112b974a2cd5fb4c029c5868727c942065b95e3d2e99188678049091949912b9e2e3e44b16da0d32aa6a62945d8918630a65a29216fb86ca29e7c7e0dd07fe751b7d7f0815023ad0de8c077ac5b807e9f4700d86635fb93890ab480bc7e00b2a20fe9cc13234c49a7306f9c687fb4d0d2b96700e9d5567da079f4079053f81aa374648db591f76260acb54cb3b9b2e307d1eae8ee5b50fd2d13845ee204b70664862c3336f27457626f80a67c8cb426a6f952b66f7c0ad305ec80b813073d018b68c3da7558a92898fa2ffdd0bdfe084307c66776b983842e3a3c76629b261ed318c58fb534d23c467f78329d25ed4568e7e904a68ec1412579f592b04ad294f0852db5ba962ae1f5c64faa6ee0eeeae4dc4864c9066fa9d4448feb699b87d01e02bce5dfdbc05bcecd1982bdaefbbd3e21f4b18b76ecc1ba4e8a88d756485919f3cf5bfa211e49edfdec287318e69c4e7c62f14bd5795cae60473b2227d88b01725aba612b06309f2765a3738068fbd247740a7579352149f260df2c358f3c2a8d2ba612534cc3791c8f81480f395c5d5ce05267c6866904de3f2fb8f50326e1a066463847c0b36bd46d8140be38567ca4d22b7723d8d254d61711412dc8e0727ede9319b8a5beac6160cd29e524fd3e0a45296205575c24d213c38fad6fca5d40ab6c009baf301193ccca91ff5c2ba4a4fea0afa2e4b2cc5312c20aa59e9a1df688de4f46ebe24e7185177e19bc49db9245b7ec62206de4ee91cedaa41bf15f433a1f7a3ae8560f2f96249d52143d8926deabff47993ddf472fdc3372d0dafd476dd5a7c2bbd330989571c5914a849ec75a7bcde4781183ac9ee675c64b9d1aff06cf097b2662a15583aff8ae6178f5a8f020dd5f2213d50717a88be58869ee5b695d6922e136e5ef3eb1a1572b92b1545f07b33d71d31cdfb8d34c7621c52babfbf041f71960a7eb866a389766c76793d867517359caf58bea03ce3553a175d079475f504e9c3d58926aed0394e9c36d72c2397a033d92f562cc5d66f86c00facc48ddb3e1b810ee69eb1d13c1ca345264a30b20c96df89f2d9fa553b36961f1a91dec01b51cb4943c36b3bb8ad42b7cbd349d1c50def7793d8a8399942540a535def5c4c30bdba8def191a6838d597796b1050a170eb54f475bba5b9f7edaac1151d033a86b7846176d509e2e6d74b5b549f86a1a2699123e5788a325e57bb4feff35b80b55401ebbe7791ac7cea147c8b85d605d0f3d3a1d55700e7219bff97cceb0b35415997407f85fdb9c9c5b5c48462b204d75a84a1149251c358b02d13c6c4caeb9517e79d7231047aeb7e5ba9d6079b67308307d11a0a91302974361ae0745f8174b3c22baf605345e9468530906c2a27099a98061786f0312bec353bd80f03fa73f727c8995beaa77c027c72b772c91202554aa92ce7b5949c86d8cbb8472f4fda46aa3b0b2fefd36d560852aa152affe81c656b0d3095c451377a6b359a972447ecf885e453a7f44e0579c231c0ad1d5f6d36fe0bcdeae1509946b50455553618c1c1613e1763ac4655e2b165894911eba5bad5e3003d7367c9350cb04966ac647e3fa6aa0ba613b29f87f250c7a5dc6f674aed84d23b61ac6e673884290979475a9ba0952151c6300708e900171fc4f41bbb707808b2c4f26cfd96abba3f176cf3d575c61ac247b798e65372565148487163a4faa7f0430afcf9212b13941386dcf0d382a1f00ab2afb7d10d48dd5ab162116c119e16497fb1cfa252e238ba472941e5c23742e71030a0399e3a3006961b5e874108d2790b1c63fc995dd63f800d7ff67930d37c769fd18da83f0a25fd9066117ab3762bc9c69db871d90d40b33d2238247d87cce2354e07e7830b532281c7a7f1e8a38af3d54bed480a2ac3901a6e8ad7b827f532618327c2ae222fddee9e1a4d0795d619d89647fe48233daa9c3d0a2bcfc80bf2f9736fd4be70996076969c81a8d316356b941179095cabc0eea8b3a9066b68d6898b16b69124387dd2936dbf05707d37d99a7e2ed237ffe54744ccf661710dc2830ea8e44231dd36ee807ca4f3aed61983743bf43abb97ba01b969ccf148ed4fc9de818159c11c6f173e5a6d6d34596d22a270964bc42dd495cd781e28bd701dbf704595c0d470a77232c64def390df7941ce82a0109a6f0a64b92256affeb5f6dc8621a26136aa9063fb277e5d30f2575ec8472c68c3913b0c01f599187dc6c450d0ec26f026710c4dd2c844e416a52e0a29727245a7028fd009c642b3d57d97c2f2e1a3a30fd3f8499718d2f77bfad2cc70d1a99da1ec053e7185bc062d513c06370e727ed34ecefb37850b04f4b1c7bc77b1f6a10885ec7ffe9684026301bda80e9c57627237c4440c77c7d78f99bf85c6d2f5e09e447b2f6c1728c23072e3452b5e0e4085b406bb59b752e811c2487ccd9621f1264704bffbba4b690daaf69752ca1962e91843ee584c01c0d6dd0814efe547a0c12c141cb5e81dd221900e00e01c4d47dc836ff10a09be4a3d0850075ceced07c538e00a86eeaaec69e2a8b9255e11cad3eeb07d07afeaae67d14849e032c63c580ebbc5468e5ffb92d27b149151fb61751ac092bbceca31f0e04e1852594e8e08a9fffe4368bcdaf43660518dc698e214248f5e1e628ac82dc76d30fd9dd6ecc1df8cdadf2668ebb9e39bbe794915302c24835624ac44afb9d58a3c36b300927cbb65bf9c92a7fd036640170e5ec9f33fa93aea1b3515aaf6c11e26a4d1a6b1d6990397c1a7efc3c2c35badb63de3edddac5f4e8a2671b693ad43b5f8896f646efe1c16507b5cb6689747768061a240fb54e8be6cd45ea25698b904d187d939f58e734c235c93514c263b33f1553072416dfd74e419e225b76c0b3d4db658f8d04d39b2163d5fad25a35954f1c33887ec0ca137a2a4cc30a3857e71a673d9a0404fca3e56dbb18d289872997502d0b9277467ce02d508e96318f71e1ec35103780e38fe80359b004752db9ad81e4233a9e4a9d76677d23e77097fea848f5ff14203abec9f2f213863ee30e73769802dc5df00c7b388e692e2e83ed3aa704adc0243f98c57a8f614dc77942b112ef82567dcfe7caeb1a48cbf3ab0ada8f969c0ff2211c1219356e97f682fda4af611aa3e052eca023282ea4c6fd3e21e9593a06219e8a59a82f1916293139282b9c978dd030f3c5fe06d3f7aaf9df85cf854dd9014fc1b6be28f188d365cc2c281d6f8b3f4fc8bf26b744a1592384f19334ffc46356b2dd4fffe030de94b5f1645fb98ad2e48613205e7921c725cc493ed968c93c12f5b048c90a3dfbfaa7e2a1a0b56fbc61d09407e17cb790f59d4ef4132ad909cda1d5462824d4e2b47f5a40fa93ac767597b62bea7c020c38767b2c6de44efd017415d472c512246256f5fa42ff4cbe449247d8f36ad0ade1bb9e38014d838b8075937b8218cb3f21e700d1bb71df1e2afc843d2ffe8109801da8f17ac3f3a6eb5cd63176e4581d3939b49146768745d69d267ade11c235fe053a3d5c68d81d0baff7bca3aee21d235268c9fd79c60ab37e6c4512a56e2d41a6010d59c0be6f93bd41d0960dd3affa42cf18b2fb68ab5c3875f3e693c22970ff9711848a389226edae0d3c364120df16a133050599be1db76cc5f7dcb6ec2a711f55c2bd802b6410baa557dcec70c31c01aa21aca0e79e331dfa29d52454f05e9b39c665b6ab4f9985927dfe776f60021cc5b199a4b0096ffb96e592e36d819ae8d4811174d05fefb1deb9268e8f19e2eb070248634c63d1e02a14888f2d6bc42bc5f3b7e2a10b8f858655337d68ede170d8080c36877a912592001682368ccc605c869184df0b702215bad6523abed0ad038e4108dcdda2acdaced94b8b524547b89a5c9d19c55a16d3befa631c5d3367bffac9aa621bdc45a3f14a37ac0512a4173c50338d4302010e61def4ec09081af803c8a3459e84de4d8112272dd6d5b2254a7b2a81576b86626443362c775016c69ea67b9c08d346243d40868616457ba520f52422ff2290b69e0e164ecc9ffa7b2a850ccb761e6068b15cf9a5e7e5bc2543b8f121e5f7b116b975950c30be6379ddd17111768fd0144c6aa4867121810569ca1961b555ac179462cbeb760e3fd6f81477f38e9e266e2c2b05017ffdbdba3bd2be23996b8e69bc0a316b3a9c7bd12adb519e38edc67ebb19b88d79e15c9aeab855dd28a06d28f35aabc0f05fe6fc6d318928a6e97abef1d6223cadf52cef9471d413fa9f8615789b138c06138a29a9de7c1c87c8360d61451633b2d60944dead5ae476d359f689a292a5f99aa30397bb04bc8e29c0f429b2ebb3772910d8df6bd08939384e0eef731e5bff501c5f03bac6962d7deb9a179c12222d8a516e764c40ef9eaa3408a522d80ffd8a86c69df607bf777be19e350694f68d62f83338bf6d70a63e3e316b3681229fd073606cec54dedbad5e68654e36f6e6da555045e5086d21765db5984680dfa6f7b343cc88348d1eefd69bad9f5c8d6c5d208547a24020ed7ca3afd176c895f5c4e63c3baefa0aac6e23b79ce1e4272084416113e2bbea84250927b8e56887eac9d705952e7fa6f04d0f83d7377656d85f8c0281c9423452222a991caee77899cd6ccbff043f1bc166fa6e029f6b324427cc0d259de6bf86bc537d718261b68f768078a7eb433b5cc3a981d345bb9aa68ade8a11592defc30529ed4d865cdf27d8cc5270395c5498c7246602c22de70585f904e565af13bc6db6b8de157b0b44afdc79d5b664a761c236b7cd63376660954c0a5b50699a78ff1dd52ff7745a74d5ce165ec84be742d11d688dfb9481aa8fe59d65ec7a96df1199911ecdc0e06a021982c4015ca2131200d8b5d280d7a39a33662f587473998c37f9c88d38815bb0389dd3a10ca6ee38a272177cae5a8dda73d83b1e2527f411cec578a6d5469f4e00e39141c19143ca9724bc884470378c19409eae0febb78bc897d75823e01e975e6e0f2b115a5d83c31e2538dde1c6fe29210cdba2b7278a786d68e312671f4c3d514447b0105dfb5d6a711fbb121bee7ba82026e5c66f863b2d4b8e2b96288f8863bd3d91fa138e90d07af7c2fde55a99c0de45f86af85ede9253354e0735c191f7b0f8b2b0534557fcf04d62c6371f95e965c1501652d36ec75cb429b0fd7620c88f12170955800aafb57cde6d80e271b1da884b261d6e9dd89567623402e78cf158202ecfc0c9cc32f8a59259ff6f1449a9e7e34b1645a21a90e2c84ee21a38f117b89afc2efa7ae61388888a8e6bec7e5f915fa61cd8c6b29b6db9281155fe3470836989d83698bd34fb222356135ae86e61130bcf1fc83b251bb699447bc8bab80c179226e110bb40d0439d4440cab139f97f0af30afc84b8fa0d40c49f8c3823c945c80dc29f9b50dc77efd90b9ec291127331573dd72a834aa7e8a45b6c624cc97a2b69b362deaf86eb171f51432f9040db1daf0ef7ad3ffb598a1366f6030c037999223ad4149618e85a376360b244a3011ac2904db1c3605810204b9252a6d055da8ca2fd956bd55084da56d4cb5309266b15cc8e588f55c029f1c730d9367df2e605c15f1d7506556e40f3eb949141f231f7fc496ace2dfd3b4117ecdd07d768827c8ba5e6d0fa5bd040a488000ca8106a3d04c81761b279c4d3b9c1482d4b3d3b179fd5f5c536be7e1df1ace37970c2792e81b26c28849f4340ef8cec8dd69105dcbb8cc32b7855763680487329e414171cda19be5fd6a73c48eee46faaa0da256f31e975d5939efd6197e0a168ea8eb850e1b10656c33cd532afa5961eb098b23025850c1df8d074b4528b47c64e8a6b99dbfd00842cae4117633d40a79cbc87c71f66dd1aeced7fc1002c811e78a9fe03bffe39a5c95701503a1eb075d98bcc61fb03f9890e69f50134f70f053d100e0e53aa06b7e1f0b296365bab69175918251e962e63abb085f20517eae0c87ff3ddbbbf051653ab6a8a399f8a2cb3a91bec3b739119bc5461a1d2233d4c44b01e4277b598d5ba7590df031d86964948c1cb60acdd62ece1d3e87cbb853998a34de059dab0aec24ed257f2a6e728e588a9e9c9aef82af9603feb609a634f7da5cfed6f26c794a5bad51b1957fd895159b16cf59c8826b3cee7695ed55a19cb9925e1680dcd4d52ebd71d6a87b29f2d3ba5bf11a0114b227a468d60f59c8ebebda05cb835b3d4acfcf3b363ad97cc5911863ae2fc45c6086c5e8cdda5db79483f826478b355fe54ab8920ec76f4a115755999f6ea53f43d6c4635c270274e1b846ef3ba9dc0b59d2c423d2039a9376497de94a3fcd1249fd4038bd2c0da17fb199e1b13f0f9cfd55d8e12760d8dffde1566d9114300787587727f999a2191b942cfbdbd840ff255829de535fe7a7f38a679d12f26dfe7ff5fa1704bfdaee4ce48145c475fde658ea088a8f5379c6dc5d6d9799c3d23011b34a14f4e17d550c9924742b8d2133f957204b98619b9cdb0d6a3b34196635bea65efa7d05a25a68fc9b8fd1b518198753f30534c75886a4840d4a182fcf66a2cf2be79ccb331acb3d2d80ad2360316fb89fce3554c3df531e007f1a870a3923461a0d72da8d12ebded18567db1d63319d1d03b39480008912be1ece4574b424ec55b39cf6f546bdabd5e7f02e8f131ce6b0956ed11569cc392044e895a70a412de60197a62ece8791a64cfa769002a46dc3493c86032715ffbc16a94cb890a6a0e4566e4b9b2baefc321691e40d43364e6a57895e0169ff80e658e563be285a3154f3926d7c6845d81ecb7faa72141d6af7f0279b9cc1927fe5609d1e969998af4af310b97c79dde2bd9a1c23b51ec03950a21e11a903fb0fd06ebf554f13360960ca8826e55e006a5c356f39c4d9414a732c896f4073c3b663f82e52934776f29ca8adc060f6a0e0bd6d208978a18109e9ea4997576e6f8409207c2ad0a8a7059ad6579cf1594d41e11a28fb72eede2073570a2cd4407f8f791f60a40e902774cb2d9e7e69eaee7aaa13748a32348c16eb9ce598c03532ce8989140b170d702cbbca7ad3d147c9325b7f9403a98cf30d86c75ddfeecc0c93c849125e57e54e48c2f43880c1b7790361c9de065dd20b603cde2275f7a76e2c13136488de99101348d5a2f45485e1837eef9f4dede65c9b05ce7211cbbd3980e7dc3255ddb93db1f85b7a9e6340959de903bfe23d70ce9c9d58cefb43f90ebab5f5958cab730c484d959d5cececdc207827f8a15715618f96e5f9abcae94ac368ed13d29279679bc8bf4021a0cd5c7a68a1984855608f419bf9ae520006052bf71ec1b348e577f87ca98406f781db5892fd6933e53533876a071e0d0168c7c76a97300abdea6224a993a651702fc6e641fc33e50c0fed8fba45d6779c4cedd515e23dec72fd79d9bc7ce4fc85e422c0263f2d6950980b2a5b9aabd8fb70fc107056b453fd1a0f7c34f8e85a0210a8cbedca982c2451a6b9e00d145448fc8b588374c860a5af9564c0da24f507c144bc33c2b486ab34933a56e01d275bb20e8c9b71dbc52e08bbb695fc5edc3d7091e957fb2593606bb5b61d84f8ca07bdc8973c31d2319820c5a5f530bc5ba2f79ade50f3f7e5d203d4bb76387aff9b12da0abacaa2e4d819859c52f2461b3b0f82e7c2e884cc8f7a811ed92a3d76355dc8700bd6e4f791974c1a2425ecb3e2ef0287c633026e4ac7e7778ea2ed033449c25d1b7e00a317c396821ea9bf2e1bc76e3d6073d8374084fca6278accf78603cedd912b877234ba28dfa75195b0cfcf4c58c873a5d5b6b0c7eb3a74b25a7dfc202618ee3ac3027ac80895840d7a0b18f4d36558ab6e67e292cc0dcce762b3350ab909adef25fc48c80a7ff4026924b5b5b5c358c8f31348d27d24973eb31e3e648fbbd2089b68ebaf433e43b2e688a2b1b0019e214e8cc4bf185b72c25bb143ce55a9d2aa288aaf3aad260abebcee9996c9e1bc264cebaf1deee2b6413f4ab62156677e40292a5f4377b309cffcb738809a80a6d52960c28655646e9193b38a74a5479b9164243621d114eea8e318b350d597081aa68f16c92e27246fb83f063a76031b3e1b3a48c0b13fb4fcbd7b997c17e7c54c6fceb6a1821660e0bdeee1042e67a0975a6b40f1ad7acc7763c49237d2fde2f5f10a53799e66ad4e33aa8855111cbbb2191ebc540d1565085b683b7b393453027cee63218c6f53aee3d09ba09dcc8d903035f52507a88bc8daf63c201a607c2daeb0b25a0a9fb08020521dc57ea57f95b1c6c727d35da118bae589182645a0ef9a1c8993769662e9c6c6d300454f49ff05d3c36882fd30e016bd03fc6b285d526c451643cea1a17a6672bc456751d5e412151180082aabdf4a0bc5608f1e4c3bcfde4e6a4dd0a248895f92dc2925ff71ba8558f9e4016bce9a76ec5075c2a8d97fa29373f30354349d3ef59edcd0f7be6ad87ad43018c731b60a2d43bfd89111482bda42793049d6dc74776db1e274d2fb6b90ebf64eb2788a77c4a2e803a57eda8ac4a19259de3c8712ec417cd69d42f39bf544cc236c605c6578d60f8d81850fb4ccd40f21bb58ab2daf6dc13479a0b0f57c3b6d400ddf29f5ebc30db21e8ceb2b9f906f10c5ea906b1c21ceb651ddfb1e23190f924c235de800e42244670c02fd22a8d6b185dbddb7260126656ca8361711b42f01cba70311c7ae08e83ea44538732e5302e5fe6e29e417576788fa4f9608f6f09838d357052c049370a661fd2d18f75f45a2cda32fbb269c79913f4da4dadf948916a8d633ef10baac20395f1f6abb6c8d2c7761483d1a42e7111a2e4e1130689b039aa719563da91aec54bec74efcb02927830aaba128dff0f8c11a6905e8385bfd5581b3ab1a0328ab6235c0facaca27fd8811339e37d16dbea24568035931e89e88de9fd1bdc652922a5a96ac87ba96c16880ba983b5cb31e63ec2d4980f762855a3fb4526a7c061","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
