<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4b08b5982099f1f39f9f9fc79afe95a07c84c140c50dc1f85fcab328af5807260a5ce5adfd8f54ac8ef44594326f53ddd3b06713c49170078fa0dc3c7bbe974a17fa6d357dee81edfa5737614d49933583976c0b94494961dd6b106e26cc8e8d67a85b0c7f48920c59bc961a898087c99fa5ff93617dd75398a3b35f6a64251db15d0fe397cbec2b7534fabba1cec1bf9c9d407bc4b85d6d911162b187bde1ef4f2c4b1af5b6e967f0d629e2b05b7cabc5e08f15edcb020abd59b023e8fc345d735d89c654dd3065319254df41d7f70e5824fcc39839f450dcf46eb0ed17448edb7daf29aa8ffa747b324dd99d4441619c14f5caf1cb275b15ccd81c754f0da9407efc74f42f36e80f60f718b5412a3feaa6afec175ed4d2fdbe400deca4a78f201b9c55a55ea21166903534097cdab62f581788561f8b6814a38c9b4708461a1c084e12f1bca9e5cc7cb99903124d3192a339a5682f32d0dde27cf3290880fe816a6e69fff6013bb7ac4bff7e0ff1b78921b33d7e7fa78e722ee0f6fd853cb327d4dd78a4a6533040ccbff4d862d25d8cc958e35f9ab555a59a2f2183768e97e56b00f53b79144eaa721872c2c7e70b4c533b25fceb30550e4bd60d22c99329601dbd3d851f1854c6f53a97b23ed34bcbf0874e923ceda7e793ba0ad5779ce446e3580649365e9dfcbd996deb50adee15174633eae1e25bdab5b97120497f3887ecb87260d7dabc46bc972ad05305e870b09fba8622df0407bf8b853b71d3c917938f833821443601fb3282d1c1fbb9fb16233c3b492155c83f3b9df9eec08b36debd14cded09af0e7bad756135c54d3706b8ab12e100abfcea1e1e34b1e87cfb8b97fa632e6130019e700d9ad8a03966216141d7a9b2b57c5dad41a70a2ed94c4142ce3dd79beb99de1974ab4bcaeb3c8fcc20ccd11fd4b4cb54ba9113984938260799001cf2edaf2820edfb9cc59f39acdddd1f0f633a90e09c92e7e87ea6097f7a70c3b300fd66df1334a108baa4fcf2b4d808e8b23750b0121256acf356a6a35d5409f7c9ab5c90b9ff161ff9fac76077fa0bd2bbd33dce7ea9eadeb05fa56d3038515a6472b83f5d75fb11d29e7d4cd853521562c31239a3e912c110297911b3ac61b24ddb811a9a2b81c72232cfefd6d064d191f97b973f241b7ea918c6a4f21f67bf89c9cf8b312ffc00a5ed58af7b797bcf056ebc7768de69dbe59a4e6bbd700742e35370c9f4151e97a8ff056a7167a5cf25fa18f08d383daaf5b0445e9ba317694ad348444e07d886926639969bcbbdc21ca0d10ead32c6bb86bb912bdd6e7d36501b2922daee18e2d440a01f95666d971d1b0e19add3fa4e3f05aa3bd3f02137049dd3394e4ef804de7bb516c16a8d43687df024085e180e55c85d7b8f80d2e0799fed979dd12c09465ede952382da449435d00e4b3722a0d4e5c9c07239a817e5176297ffe57559a550fa681a28d7d94561c22537ec128fdb9dd024156260e36fcd011ec5f442322f276c7872a388550bbcb21921878c7e5639c2ea8426f3788a1c89886c7ac92116b297623caa3cf396a7e2be8f67e169422e6e2a1fe66f41a13feed9cc31cdda7c7636cce055ee884422212e218edfc6df963fdfb9b8e1d43cad6bd0e91eec438d2949e12cf1fcfa72075dd55e5041db19c0d61625029f4cef170e5518bbb7b5f6d7fc53a15ec6599d5f3b0497282c37de4c61e62f210053697dfa53cb2f1ccdc36765e57ebe794a234eeded0291d91f920cdd93a79e6032590cbe443357fffab770c131e63149c581e27bb4c74b08582bdcabb54ec5384a7a5a17f3ace149d993f3fa635889275bf0a1a839cbcc5ad8d096216362982ec224b71451b51296b065801ae10e435c7293e625068d73920a93493d1934d683953ca1b8c5a8ec58eebdee1ff68af2e2f80c77fa6eaaa881c38fbaa6c47cc6706831d81ed58ff386f577adf67e0ca6c5354d0f87b0f08c398bbfae6e2ad6ef887a53d7ae76e7de1e55ca5a821a8b3c6c11803589933466713146db0a61fd2a4a0bd8216bddf8ac62c406cc39aae3e28f5fe41f51d3d9b52bbaa747f9d046625693ea7625440302a05535752a48ce99ddf9c67fd965b277a5653fa7e8b71a2b5bdfd4d547348355b1b68389d3abce5e39fa2f4a30d26a42a47f310be543897d4f21862f53316c798d9ebc9c8cc1dc7bbf6291499dcbc00c93aa692de8848abee20208c4c41bfa9206677d938c2627d8dc1f4ca286946093ded3105ae0af587fc966ecc7a7518d527f5a6bb834f610f6691a63df33c7e14b70e13d4ebf9d832024e015101e2c9428a639832c3230e192d897db05b1c94715005efff901ed70b5f8b5cad0a84425355259c54598d1966c6260a267bbb97e736515112bb1c35e67601103ee8dc6f39283ba27043bcc47a2da9132fddc8707c741cc96eba1adafa918fad0d6cd1af09440d8668af91050088e24791292e02ab796bb68891bf690be61160ce95b48b55f2e95e5eb4d6874e3c2f39e9255ce735d986376b83df049bed00fd4249ffc957cc4730104c093c0f550f2fa517ff4c670ab369119a3ec3d8306b4cce0c867649dd7df7da765752f6459d4ec07fb00a1e44388ca3b99b0cdec5e60d006be8421a689f10f35194c0df970788c946c175c1a38d432f4da583a7f2ee810d456cce3dce55fd3cea4817fd59122b6e3e5fc0d78fe2b0c4c96e21ea827cb7b72bffb987e5fdf425ee167b3eaeaa61ec45033a8ffa4cb303f248817b140964048c7b7c1c17d58cd90ac7b4bc1f77bb884c613e3c90d4589cb32a000f5fb7ade8a3d0ba00aaae8b9e910838b6aa0af5ae4adbc519895ae073c95506a52f84c4863a6f7399f4b24de7946e97ba912214038f10f2309b5a9bd58cbc952553c6e6a60b4638b77793642f3b9b6477f72660d044d80d0081ed0d37b945dc551667e6fbd841bbd3037bfd522c0ae18fc4c453d3aebdc3c5b5c5f060f11d56c97d408a449ff9dd4e6303087dff4539228e54b2adb0fb22ff2fe0adea07a40c6e4d1d433148d436d26be98ee4f148fea899fc0f5f4499712ee477ab562bdb5bb704ddb8c6757796cafbabdcdf4d86e89998b7a4fd1b451906900888399f3be437930aa2de4d3b9c86cc41fa02c5fbebced7bc3bf86be8213f4d05cc44d7288a1cb08d125cd9990cda517e47c86e8f6f7b0e1cee43187394ee7173008fba8c162208ef059c0d687636d391da3680b43b1d7c07eba77bd7c862cce00ba0a8d64ed4cb2c4ba18046354403df9f7623dddf71f1c52d171af11a6e4ca79cea018b7778c36922612636495f8a82a751d85f8171605d951014ea5994ce4d6b881397b670c12877068d3cc0ff48df421e9c4e0e725caac56d242b4c8ffd14f419508e7162826bc1840b63f0dd177ae89ec19ca3845264cb6be5b2fb61ad73ccb6583c0e521d0c0eff14d704af344260bbd7948e10341c20b320221195b2db55de439229abe73b39fa60a4404d12ffd9cf7c87f650de973cc9a509d9c6fb7fcdd6dcd49e2871154fa2643fa1327d4efbd2e52a6714efe4f2e601b057ac513a4302d9e74209e03623f9a6204440026e881d475cb4e9f290f6039b27750fe175158c9de6c960043b242b85bb469c53a6d320fd99acaab71ab69ae6ff560f6a0006cd4b3f9cb102384648fbf5bc94b6986e4a5e450a4026b63b8d3d8997bd64b8d75c7c82a5cef13744c66401f97bfc89ff8300017971112c60c3f7108d05b6619cda08e49a61b616123392fea3ed9a2bbf3d0c9cd6fe803922c36ec41cda261d9907e99ebf8791a7e60218e7fcd523f5e30bc02e654380fe39fb54fd23156fc0fdd09837f44271526fc5e2a4bc7ac86aa35d449e76fcc672da61431776e3e75f62213779aed91705ceb9c3cac344f033fe285b829190ec17621259661d3ed3665d7cf3943bfe5cedecbb674a1b8e4c23ea0d99a37cf99e6079ef3cdf85f8769547d67f3a0bc6b233efda5b9efd97dadf30641d7f433d0862c5a8356f3553c66ad7ff23252e9d4951ca797ae2a675405ecb09e795c82228b573898577c03760a3b5329737e147c8fdc84437056234d79a1a4dc878aabed75645701c3599178ff3ea2e3ccd821b9498ec86b068b652e9c07d3fbc14598302d8475ecffdc3597b197b5425eed21d3c5af50dc3f7cfbff35adf97f14de8e8bfdc72fb15cebef82c0515a48ddf459a22a9059d7570c6081a4f3bae9bf2d3073a4dc8eaab159632ece52a0a41a766bcc74eaff6df7fad876d13fb67396b84c4f75f626f436ad37acf980d084a84bc4e3f733adddd319aedafee601095367c12a83f0ce56c4f251b5858def9ff7d3441eb2fb9cde786d03174c4fa64e452c9e581ef0f49c8522314a73361781eb1b886f45d02fce1d21d5c9186952d74d2a95f20a4fbcdc759566a347c8e7b69ab232845fc5b5a398cb389a6f831d1442446231e2b7e1b87fd8cb7ad1953dc7cf3c8edcaee686c1952893e0f7e7029bd48022dd7b3135c20eb168449c5d8def41fd55158cbbebb50007ca6f183030f61248aae8ebd97bbb270fbfef3dff8fffe15104f3442c05f465dfa24113bfa0fda67ce10f53b475de7fff544d250ab654ce5052206eb12335e75388755de2b02158d28bcc7c7bc8d1f2d29a8d97ac5379077d331089e4c8b1e601fa6cae81e97c2ce275a653a2a91566c3dafc464cebaecc0a3dd94abd3c169b1bc915c216ef81768a0d0eccc849109e4217c775d39a5e9b97282cb7ddaa788355ca1513d908140f7b613e6d6a5249df408e8ee4b975233ff97f35f0444f2e82c95cd117e62bea2576aa3f727c533166f905b8ba324a16755856cc02a68fb2f8b711eceff0570d0c684a8e752ea67f24bd663066581f37b73b3f2720d1ab435539d8b272ff2ff10cc4b5fbd31742bea8548a591be90def73967ef5d74f05122a3c404c33069e094824a15d0230fd57027ed4decd96e9c8eb0d40b0c27b3106d5b9e5221a6c5cb0a1615e124208844ab88740f75b8d91f2873c869327c3b98cdcf2d7a61c14a3d34afb6abbbd9636969becd2063704a0543ead5933caefe4481c825d954a260e0003e82948123fa7dce74a90c47c5bf3fb476a67a8e96874174e966f65a3dbec24887b167aec573fad60a450912faebd1aee1624dd1617468ffdb0da74f21eda1c10fc56f7ebb7b7dadbb59d0abade268d510beeda2ef259dfc27f6ffe0c6403688f47279e013eb3e4beb4b85aec641dc9fd48df96b340e120145b1c81b537b74be218a3d852ed22534346df424a09dca95a9bce2f77c2ccf556238bed2aa0cfecae711ca99a3cf8b1d02147c84edff0527ceb9f1cfcd3b2413c3a20e7bb2d85b0ddf46d806a7ac90370c812503b32cf36ccc6495ff85f210b1529fcfa32ffab750264da17943fbfd4f91da3718d4630ca10658a3dc986dc3978ba0c3167a17dadb30dcc90aafd3233b44dba49c7d7912ea5ccd4ee2c0e473c9f559ceb4cded73c0468c210845edbdee4e1437861ebffbb85cfd7f8ed388590c7f7f01491bb2976002b99b31bf924ec3a9f8486af5dcb0994b7bba46aecec2c833f0661e23048e390e055bdb6747946ae98fae2ad46f0b3adaca39b6d00b04af27f140b593fa83fa1aad91376b43ce573125b0fe937344f93b514852dfc8f350cd840c36b92741b7b3f7823830adc521f9b5089f628edf3c6ae3920f8e561d7ffb5f8b5297337ce7428ebe59d7076fedab9de12780239552b0be628104fd737cb523d14ceff9f6393d48734759a51e58cb0a9f4f7e35ee5544afaae5dfe955097f13c824f75e17f1107c7d5625b5552cb9ad8a3a2c16307562f0b5dddaae0c16894c0ca1cca9d2945e35166472884636faf3f55c73e99d5cde073486d6c5cd05aeb3f7f5f54e239bb27e8484f217c42f8688f37771851d0eafb4bca35013c1ad7d326557a40c5e69e83350cc32ad301a0cea3db4979c530d1ada852f0d1b20d942460a4bcad3ccad45b6a42f34d5a5cab23ed23704b619f5da239cc10137fc6297c53ae64b5aadaa4f24d37e3ad36703dd0ff1dbc08c51ec345296129f8e602d53780e5fac8d879ffd6d48620ef277cc4c4d7f85ce217e0cd34cf553296dc4024d9b0b8ea59363761d282491bce52c543f5ffdc9923647f2478df52a7fb39753c42467607e2be10bc7d863ca654fdcbd954fac69ee68741fa61c74a1bb27cab454aa0b6d25dfcc2e00add3d4843ce3787199341e4eee35337e3fcb0e4c08ac830e80a28881f641aed84472c327f99da28b416be8997a41baa030babcd5a471dd8dd4da28614d72eee4cf3129c2a3626bdd30e9885ad41e2f7961692ac66d66b973707b6aaf203d6b065b0aa6d76b8714b4b753055966a10846e63f03ef165686112975d1ea4d5eec673a4a4baeba61205991ef3ea83ff5e9fe4bf006d2a7a7f27c6754fff09526936be172e31958456c522387a18e44b990c4d8c207fbaaa7d5b7e57ffd6e686e9fff1883102617aad226fe452a22426220691132d7580356f60710c25bd6883ae6fe65bc340126d8248d49cc82f3201345a30c673e4e1feb73a21cc49ba342424cefb3f95690fa105686434187fe26070b0ad3b78aa60c974b07375334833e1ad6eb1eb8d707df5152ea05d3eb1a8ec04742cad42eebafe00b7a5aea397859f46aa3474a5f69d3295b60f105068dbac46f106472347d2c6be49f1d149c134975c51f8adaa490261f00715dd2c04f8a974d42a6d096a635534de9fd841395cbeec92e21f7db014be6ca47102f259088d0347e742b6d23f0c1f84c06193fdf04f2641e8e9d41990b4461cd4000a66d5845ad4d82f180611c1f19e5f27ccdefacac4765c9e0d3fe33492f6543505c54aeed5c9157f77963a702c74609327b1e9d032abcbe69f2489c76dfeb8b7b4a5d29dc5b9e90aff20b2aab7c74f24a5954e1c7ee58316242d5ca9a30cee803af092f089aa878ac12e46ee52a6221bcfe006ede6b9caacf53ba2d4c2ab0ad43d179c4caa1040ba3c2e1b4b429d1cfc29e9f15a124a8f6b1eaa9e417bdb18670f3587c7cf5c2dd0c224d5e6345e78720847fdb62fccb79047b0c7f05acaba08b8a91fb48845499109792803ac54775b35d38dc538a85ada9239f381abc3d47b4b540ef09021514b175e51efd2c1669f640aa75e7cc23573ad03ad588fd043716d167e5cf574d0a662ff946ccda0c9e05a90a7adfe3c34c3988b9f54c4d40f8d0c9d29f5348aed8662f27aca265dedbc2f346f8e68ee8c7ee8e247f3f54a5728d56da6564546da0d3f03eb9779b66609fc18af791d11da79d25497994f8508c12738388e6011627be0d54c628291f85d2cea46f6b212c295412b1d761f43165a428bcf6af0d0913bbecd719a78cc91156e6f6b21720ccc383d58566d905ca8ba2ec71196cc5f54bf3d120e5fdbb6c13206b2fb8ab5cb061f6fe44e41a13e79d504a581d93da14f2efb0b4f2ed53150df62f1e0d7ad7ea9f7ec6d667217b7d3c2b91896703d8d5ccf6b39c9eb7554b2140821ad0d104068f1fd3a1de7348c91d98c3a9a38781cde72a1bfe785cde60c680669e9cc920ba9c5d5f3febaad8d5d9371cca53b1712b289a93844d592f46924bb6ce8c86d5267501584e56940063b6799c35890d145778de7e299720bc489779818fe16a5b9c077b1afae1103d4263f991af571b0b969ec500a0a2ddd046a85a4cefdc4b1412358f896fe9b5e6c52c813f21894a3bb032843ca36c86dafe4f62d0b78f47961ca9f786794fafa54b7785efc5b6eeaf5be8908e957df41575e534bc6c044c448354702ea30a0bd14ff83ed72af3ba8addc85a15133d164408e4aab48f4ff143cab8d6d069275a7b2e9ac9b7c20f70b17e9669d54e78d8b5aa577f058d947b66426b0d9881a92cd337825df9bbadd9fd4d056f5895699189dbbd1eb49bc4a39fa1d6ec7fe262520617a2364056573dc85ebaf95a6b9c586ec7b7ea95780daaa1d5f4d4d9e16bc968f615fbffb3d9fa2a536d4db9bcbfe849dac34674b196e07a0a956886fe290519496e3a9abaf0acf89da1f6716ce14ee983bdf75578592ff9d2208a15af189c66cecb95d463fa8a8c55c3a757dc45e7732cf7e20d358a6e5e746d1ee97b83dbcd29079691a81cc52acc9f6494156ba3eb6711c9091f7b18f53e717ba17aaa3ce9a29de7139bf31742f731ed45d7dac04970570e60d925b6dbc53da1ec432752965b190bf727e19a7a2a9b392a2bacc00b64ce7b300f6ad80034c73a84575cd7a2c9858f7876763acce55134d7428c4727471f83c335651612aa87f01d178c9d65fe50c0ae8e7489db7ba008e2eafd7870c3acf2201b42fa7540ae33bcdf998d70f9c88373c82e49a1a522edeb969e74a5f199955afff000ad53bc5c59331b82a363146a68ac35d68cc0ebf5b976fb195883355cc5ea1098edf3423e623aacd6a0c7b71cd6168676d5a9774e0fb0b9585efe0d89796795ff88645757837cde080d144b39089ad7334dab97606cc27fa41348547272f3f24fcb094042317a85ca07da6a0f16817aa0f060d53397cf398bb472a870836b0ada100b9c01284f267fb5a0274f00e66ac76ab4b1a83e0b1d5cbc75cb0611b7883bfb1b83be2436662a929dd1964d3ad0edf664019ac13ff7ac4c7fec4f22600748686983bf5f410831b7d1dc1d883b17e34e71f180280590b0b2d89fd2e88cc35c1813b2ca805b72cb4a2b49e8b07d8115426cf4d4d7a89c7db15d2ef660865b855259e05ffb8a16e82ed02b3ff38a2871fd80441450a82f138518495eecf06592c977db7563bf789ccbd1efa8b4179f7432a33b51974a2a29ad5d1bea1db9122fdc5856b49961089dd76677b6b69c8a12e992542f40b70aba5b5051a940305d4200205b27e590cc49298c7b63b83cfe6b8076eddeee1d66d83828ccda7443f902c6d79e25fd2b4e524204d62896843770578fc5f17a0c3c89a0cc36052450ce6a2ca704e30c3b7af384a5d56c69e2aee48f2767600449bbc082e713b92ed0b9269937828a49bd221fdb528ee01312c13126e766df214d841dffbd6cb971cc9db970f874dcaa17f23a751a10d563802794ed5bbbe9ec81f53b00dc2bcc5b7ca9dea93c4cf5b415a51bd4eeefa8f6521e4887737c13c59b6232a2eeae5055e0e53cdb69c4aafe9547a35876df3035dec981b6fb1fac64e8825e0672b30a9fe8bfb26e1d0406c174b53ba537c7c340cdbc48cb875da77c6e697f12f390242c02eb9e7dc0b40ceb58f9846703dae5d82a4ee7f7d45bfe9c4c2b4872f7f1dcb8be034404db21eabac2315619cc280f369444091f48073876d3be7fcdfedb110cdb0091cbc369be047c243de2a86f9a1724b926067f5223767d656df14fce6d68741e31686f29fccd7cacf59615a543898e35e25b7140feb4d1e2f15dfb9551c5f797814db9f2b17571afb1ac42138787181493da1265e853c7f29e2c6b6322e85653ffa18cb7abf25f944cc69aa7f227ac4198d2f7244e8097ef260af7cb59f191d448ae4a30c44acd21cde0c52438142016850637e1ec9afee5d42e75fca493c1a860406f4e5dcb4488c8557fd0f8b62108a151bf9ad57d97646d498d350aa336ed33d41e8aedfa5e72f48e081a58f26f0dbf3c7fa54a777f9b94dfad2f0046e6f425488426409208904ccb6dc24577ee2b5d6d9844071900d48646f2b1ea36d13b6c78722faa1c397606a45db4d15eaf66532c019dc460ef416acf9b5879e67efc912e2f33ee43ac9fe1554ca0207f93377793975562586f7c979575d663a51f40573970181009e2b8b29b64057b14267fecb9a95788ef1bce6f4711a743b653fd2207e90def4ca0493f0095ee8f1fedd743574bcae636da09817e5ff7e071453d08104232040e60bf4edede26106893f8b7f101da859c7bd99d77942a8cc66fc3834d80476445b72378c64bb93c5e42028faaf83bae6b6ace2521897bb32710c4af64641f4828fce4b8d031105e9a59fad1c05801cb1ee4795aa1b14a7707c0c57086170b5836130829b3773d3069652d4c789dec553e74c5a62a1811f9dfb9f2505d63822024a3e2112527f557d3da2541479ffd5400951d70aa8821e3fe73efbf64f570ae7874bc1e67811f5d48acdc996a2690cfb9f51597dafca6a78fdf9aee38ab0f8859ae1584fb9c65922059d8dc6d1e34410ecbfecabbc2e0dcc6d0eb0052eeb31655f520e1fd62aadc1519369cedbcaa857e87a795ae3229d72be913497375748821807b4119d39128b5733f152d3ecf5c12aa47d7c327b795355e86d51875cac1025081b7b76dcd80e2621600e80c49c7186f60ff78e1f1d59af85a9091b2bae02fc6a20e494281499fdea5d4d3a3d79558a944ea3c30ea7a23c2ac31326d15de905905bd8cb9d9470e12b43cdb9357ca32ad4ae3cd64dd052e39916cbe177a91598056c6643f9646ad85a18cd7ae00cc189fbcb2b19f481cb91cadc2a88d58960b2ba3e69e1e120cf7afab5a61493bd3c825cc25f6790175c35312b94870acfe9497cc519334b5fa076fbfa8027aff355f4beff46d5dde0af0d450bd70b71193a938bfa36f0d9926f85e7f6d5afaaa52bf3c5c4e96c96d9e980082d5ebbdf9bfde422cb43710f6fc929c1e7824d596d835a6d3bdc431982bd9bfa5507d18e0ce5d3f2d3f9dd8e8ce3aae90bdbf16f3670aa43c4238c1871bd54245734fbc77c538708a758b807b3d398087e227e274dfe81a25862af23a777fae417a96407fda0f17808dafde2720d4d778709caa168504bd80793acf5d1fe1715224fa6850fd94da6201b648adc76d1e10be41847d6a599710b3b7970a76de00a26e320ed3b09712b748a3ec60a99c1d7bdf2e9a03de4ebf842749f70fe31d3a294e395d9af783ff27fc6e10498d097e748d1cdd62860147cc0cf62250ca699c1aaad046ecd321cb84c10e97ce1eecfd03407f4fef5b3b7b8870d26398002777e1efe728f70cea5066065f0254146cce6b3d8bdf948a99e4dc070cb8964ef034c8f4b22b54e19307ee51cd3049cbec19d2046c38889f649751a149d3e14ec20410da54cc65221019e682190003f40739b7ea8c5defbd9722ffbe98d83500a311e92e7643682c1fd4a166febef38497ee43126f61d7ec7668e4d53729eb97e9a412fe860f9d180cbd44f9f635f674c1e7ffedaa34f39308758764e341d1fc7c0558588a474b9cda5112877c34e21bcd0f4c26645eb0423fdeea4ae1992e7b6110569831d2d60ff2ac239bc461a9b70253f9646209445be64c717e8d8fa7fa4d3aad2f2b135dd3e121a73628e83dad02fb49759d9ca9b5d4eecc3e56feff0fa89abcf7ded53ef488ea377b712c1c35802f1af9db5f24356f39eb7abe7a3ee24a83d7157dc02d0fc2dca7e00ccb63b9e80ae5d49d9e6bfbc75301e038b7382d14998f1a69ef4c8f7b9b3d128d2ce7454242786bc1ffdb2b6b2a588f25c5129d935146e7e06e988d2d00666d79165105a9115653ca08ba172d4b4d04ec6293c32f7d6cef7a3af8686800870b7b4c950d1311f558346b28863cbf85943d768accaa89eb9c801ae31de6b08b999a902b39f0bfd3c23a6bb4167acd4f59ab917abdf8ba40fc4ccc219270889539345d89a5df286dca48e32956773d4dc1b22318812dba0fdf576218bbec40f10c518bd92164968b54a9fe7ba5f663b46df0f7333cb2611f8b703377f65ba364a9c129ce2c338cf478149c0ac3716ad3bb58943cb77d3fb57c855e28d84ae0ae139ebc4672d7c3ca0ef4eb9e892123060da3d8af920f7ba35b0f99df39760e3e48287a59234c77f6369de277da07cf60d1b7b6049476468231efa358bbab6886a86a5338554f03d48059b3d34d913386b13545931addf0072c3f3adcad69c59dcbc487f0ac8f231431c81e8eda2d7fea20d933b6cb28d9eef3f12d20f35f6f3c694cf3e1c9cf583bc4335f48007bc58507a1a38bac303483ea37bfd802630ab9160d668e27cdd6ac0091b77263a1a5ca38565bb373cd56caab28a8e82c8ed9f504f97fe3e6b055071ecab4688d1a5821b594d9be8ebf2ba8b5de8c9301f699a7ba5c875bf174cc0f41d4b061cc623aadddac9bbb1d864ece6558ec5aac45c120825b4a005b0e0c7e24548614477bd21a4008632e4117685dee9f8493d8c666f5c5793754f1808726281096abf4f8bd0724e49dcf7be20e25decea2749af85ad587c9bd7b0ceb61c7e2b1381258aa14e6953f51e2bfacd83bcb78b288687d4e977ff15f444d02e2de81e479d12cdc993b95ac007ccc51710799ad4ead1595c22ba51a827bc9fc0613988677f66e33de8db7c1e6fb59ca1cb1ecec88537cbbbab1526274a4586eea17c8be39f14288e1d074a84dc8d32e290ef4e627e396c622b96d8528fdc0eaf114df9f7cabc75d9a87ba99466a4b91f15693639660800d22456ad4cbb086b93391ff132263329536398cd0368cd433193953a31e316da96fe4aca741c4a6d0e68b1bce61513bf706571744584ecb485132cc4f2ec720351efa8e0b7a61671387ff75fa8e8cdcd42a9bbecca32e704eb62fe6f64657045622b1f38233b664688b503847e8d9cdd6bf74f699f83947de400fa8b07b9a20f549f509cad7893c42919f898faa1c54da0bacb7f53ac2b3247f012e4a46775c70e4f164e8d64f81e9d335f2a2028d6bd9f25e51c9ea7555ec4a94b375d303083e5bd48cab3249435c728bc519222b63133b000ebf93d588cd925ad9e7e7e4c0e726efa1d356dbbfc2f51e96ed45f5ec7578fc81073253ba10d93ba642484b6a04295434eaa70f3a2b988e465579f3ee147cec2fc233576502299322104d9683bc7b417fc6d9d6f7bd248ebc669d8ea7f104181493d56bb937ed805b6faa41d1edfaca4afda5d6e1e0dda70dff3e1d0a21f1a302ba073945a45f63a5d97fca13c8a9959caf504c20d3fb62568fe7e0cbf93c5b88336901fab6fde4b3b2f16ca2675c0db27e0e56bdb8f0f6f3a3f64a85fc40e7adb789311460894124f6813715fb78bbb0262777f2f72011816bcf92efbc201df58673c13f1f89c7af046fe08bf0fa26fa2c490425a5f52c1ddebf133fdcfa1e54ebee426a85b70e950d8d7914012c5c00ff5bb5f186e63ac3ecd4776b02b50ba92878e82dc850e364a43b4f1e349d8b0e4c15e83e517d8cf3ed1195e4228fd48e0badfd96f09652cf7cf6df2d4710bda1d10ecf70def20d0cd69104f95868826c717394cfb3c5c5ba4a6404453f47b418c5627b6e1069a310f6afd6605039122fd1b6cbfb46b01fc250ccbbe2d519aa6648f946b44920fc21fe844feb15ed9851c335d5714b4819df157cd8f43bf6753b586c8f5a722b6e5520650761b3a623b5ab65e0e5cbb439b0ed37eef2582800aba967c40560ba1e371bf9bae0242c8957fa30e12fef174a7288769c55e53eccc608f0d304861554f317e87aa2d372884640fee3de8d4a302c08f3bc7104d4077c0df77b071e3935961553dc0d2306d52a0d9e328098193bfa36e22600e78e01972a331c9976b52c3fcda4eb38daa6bae0719abaa31957d95be757acdec1499f98247e75cc014ff24b210fac3523f4c6ce46d5ec4030fe83f58c9ec2105a40e2f32eb1c06257f12ce883ca9669ed421b150cf8f605f003fa13e960ff1d9ad5a6728dd842b701e1e1c0a977ed74d24ad9308b0f7c8a75959a0fc7abcfb30c121515fa16cb1d1a82a8ca46e2b71790e32d2cc686b0055aee20b50bb16842785b0a2a10ecf11006308ecb6cca3055483203916cfe2c8fcfc2f1b6bcc67cacc76fd59a16869165aa996ad5821c8767fa46ee0eb7478182b7c1ba3ecdc8c8c7c7988cbc57017587c090fadc2e1f2fceaed63d57bafbeced23c6cc09542297a5fcf3487f8e7a44664c9efccabb47bca6077b603531dfbe81463f6c61e5c85732c135c6ae5b53243404a20d987f9ebf31b868c553e66fcd704de16325b17b21dd0f120aa04becb530a02d537d0b72f070f878e9137c9cf23b6349c0881c5897353cb634aae07aeb108c968f97f041b243a866d72d78274260628b08767c1f57ac54a26089a4c6542c2a4f919cb6648e3c5ed6521843ead1c358a1bf2ddb854b9efc4c1ec5d43a2e45ca2e84fa3ec1dfa3548c82c7786984dc3439b47ec9ca3995098fc6a966e3af6973f0e6f4b15e368f4b3166f40877e22336914159ad3c097ab22d0c689337251f29aa152d3d6eaef89c473d0758b2e542384bebce110a2709b438ac41a559a7d264caf8b1fcb2a951ece457d8a42b82473565bd70c6de31629a0cdd6d4156bcaadcd3cc6993479782d490e16a0af82bc4527c59814dad08b13c0cc0363579689a72ca9e010fe59f183627defe380649f760547feae0ae25b9fbe58bae1991a3689e969c58f3016dad75a4da3a809ca8848848dfeeee94c0549acb5dc0f5052fe69325af4bfe3f8e816f4e065823c2a72d2c0f2599e1eb68be4f8bd52b59544f9be95abd5e68fddc8567b4aba27fd5643e401f7b99917fe068ba9b14e5487c5ee70103c2e5c3e79a59e2ddd5be0ad84636d787f7a438af9a1fc618cb1886e2c1618e215a6aa2de64e95f2e181bf8861f8eeeae46daa91f2f8e6ec7d0fd0635d2c2fb73503438abb6a8abf4277cc1eb2d30faafcd4e1080f942bfe7a2caff76925dc562eb471bc62ac969721b2a6a97578ca7973a68661b4c628cab621a5e54b253f2f5ea4c8e9a6cf9d38f71305038393a598db4ffe4c3d1da102c91e8db6ded0d18115ce256991f6c7dd37b362292d984f4322d0baa2bd135d0adba13d999bc0b9f884c163c9c04ac8cbe4d25d46d56376726acf75a51fea93cfbb2c2d9681a23fcc1e854b4fe488b177e12ffd4c86d9a19ae7ccfeadfa4881d292df3d2b5771557326f8cf3c6cd5388ec1657cf9c24988821420d7f6518bc31db5e1cfa66766f1bf973bd4d3083ebdba4edf975fa51ab32ed91aa12bc69ffb39a385d495ef17fd7801ae8e59f7217f032eafc149a2c90725aa59f887de93a7a41132bb967a34071260f7d6ea22d49e2df34c00914d7db055beb669af597428a5312f6569a45e909b4edb8956444f66fa97131bea824a59507d6936852f9239ad0df5be071bb53a61baa4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
