<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5324722ff7d2fe1f9f07d86af3e455fdac0f022077b0d1f934d25523ab10146133d0f11b5d79696eccbd72f26df057775e8d3b90ca1b08d65ed31074fb29a8a241256ca8120d504a384c1ea31c0256c72c0f57856b0156b5bfae912ce50e2b46162fb28934b1e00150c73046e993a74e644d13233636ceb33e22a737383e23441fd6fb013cbe120c90e33b26455f44eda62fde172a499a1525421bd698a201ab98898ba6442c91cde7fa079a31490ee4cac0413f3a5ad023698a6d5e270ae3ee08bfedc826f05c9f2418c89a8ab716e6fc7dbc5d235b836673cc44a3994f9aff6a439adc3df1663d90068ddfd7f55277b95b59c1096c3726e67ba7687ed4d74c174ba43901bbba0918dd47b8b6467fbb6d4d9c5c1dc3fd5763250c1ac078a8b9cb0f6e9c1538a1b50cf385b299f15c4293a3c11e8dc528c71191c03847509bc8c9e3f4ef7c60df97f72bd68abad988d7aa3995cd8109dde4a3d6703dcef7ac8233d469c59675a6c6eef07e51bf592bf3bdce8bd7505d2e4a8f3b78712013f0cad2c0cfbf05adae90de5bfe7cf343bead2b63cbbc570557e2194d0533a9a0e7017face6e65f2460188acb5b97db06aab3d73decb263d37cc3c71448477b90c29a587eefdff624cacbaf5ec8c7e2c7d5f9f3ae48e8113cff63a13aef796ca3344f935cded74e4fe7c01546d247fae2dac7ec1d6afa10dddbd8c0982696f8348267b7fa219071c84174561ea21cb40b4c9e9cdf63939e0d94a212efd2e3c4cd82214d1c8273adba3de860eefdf4f0242e1bd9484261a3b3ab8dc352be2ac2948600a4c9db49c52839ec84163009baed28810b6fb50b7ab9dd088678b58c3d054e11b8777526abdab1f7556cb0be815f5b42b4c9132abf6d0c2c92af4d6286f3e0b30ce1205832016650501f5bce207d10b562f743bb7be02dafb4462967993e0889167589c2ba4a296f46ac9467b726fe86c93720ff010a73b7a7fa6294482a96cd5994642065bec6042df0f49b2f7c5088e5e5ed62c7b3e4155e2557b0ef2ba6cd8e3ef0883bf06ee2f2c2b400c697fae57b70476cec023acf37613d22f9af9696c4ff06523ec2f7d9036ff1d80aa23f64b0dacaee5702f9a593585de4cce7749ae5744c8239885f41d75b78f07010e25128b116c5ee3d7a0bf9d9647ed309733c0dced2e7a38733d17e3885de03b76891b83fa1b24fa7e0e4b79f116865698660b9e5e83d2b102e7a01c798fb0f15b92bc79a015dd40bf9710711b7b041ceaf5aefe1646942e487ee68476efbb6c60e7fc656bc4c3d3075281fd1537837fe0c619d670a230109522390e04c0adfd22bd5ca24c6d5f3eef1753c740e7698e8c381ed772fe35854e2f105de2d283f94c6d619d24a97714c26c23f263c58dabe2f6890947d03cdb58c2435dd14e13524837f3f72da73186d5cb412fa763c35f1db6201bbb1f189864b839f9168286a7beafec7bf17c9b2c631a078646926c91c90188e1c18598a2ac8c72e9b502a80c851d936998c3fa86fd15f2ef22ad78120aedd1b5ae8731385f1ac9476811bcc1bbf80f502b7c4886d6ee6be2f45520db5a4924b2b7e65ae6f6a7e2bfae8f9bfdc5a5a0b24efec82ddc2dbdd061889e4cfe92a672753eb0e4851ad303dd25d3beb37e509e77355f69938cc04dadcd095d0793338c2834c555f5cde0091ce01bdfbc163668e7ccb40565bd9c30129e2f17e7113af625d5c7715a883dbe067d6ff5732e2c8927b197604a1f68df61bb1b6e787943498f3dd74248fdd48eac7128e0576ccfa005b7d4da50668e7bfdea6595bb2674dbca2470ad42c0f7fb8b13e11410dd0e70ac78c58929e85e564f69a2ffd9f349e9a79122e3697283ad7838fa8a99594aae1cf28805b84f3f89a01f121e1b64dec5c166a7af9e424df4681d7e0b070bf9cb9cfdb75d68897109bc6d958e330a4d03aba0afe92d82b4b0ab9f3538340b82cb72e4391bbb9c4530f0aaf3bc3ecfff0b52fefc480479ecc485c3e880ea5963aea287d271586d1f853ebd5d56835a6f47d0a79b7a03d7539a08fc9f97426c891b37047acfa39ede0c6518b91f3e3b2b0f37035bfbbe75bf96e72a94da64e2972513f86a1902be40b4d9e078f0ff6af14817ca261104d243c3cd636ddcc0918babdf98bfced3dc9668d764308ff4add950e3ba60222e52d680a86d01d6f15caf914cdcffa57a5e9997d1cbe25423ac7228c1cdf7026e957c3d091b89ff787034747c46a045a1e0ae19c4328a2c302b07e528520438b9b01da3dc576e6fc8760893f1102765ee99c354212c3858fd90876a1a94e78cd2f96d381289ae186de30efe71f660693fa4a9fd88015fcdfd27d0f3f2af788dadb496f6112eb425e9ce1e748d86111aef4fcc852879afaa5f124ba7024ccab4da07cb5671bad34b2c145b4b7af854f6d0e893ab7fc485c77300802e70aea850ad36d7917162cc348021a1fd45921644ac74f119a9a5b31c2f8969bd448cdb2448519132185e39cbba2b79f7d60b7c5069cb728c5554a16424be0251032abbe9740a7d768ebabdd1c824760e37532163bd8da05acc67115a98d39a13042c8468cadaac95aa21e2021d4354c27610195c25b04e609e32c55b21880e761d48006c17e1992286500ca75ba75e3abf4bd8d0db2e6deac95e989868ee2b3c0b11373746a4a6a71e273816ef2918f51cfbe59a60fce832f7dee8557edbf554e898c846d90b18b7946b06264ec6846eb2be25754fc8c8d9d6094fbfbb794a15b698e9af8aae4b973435f607e08e4bc8a8fd12ea4c7ccabeaa410a2e304561b489707fa215e17e3edce0edb6eec3dc23598d07c9caf4b91dca205a5f8a8b1a9bf3f38684924d7360555f812578ec858a96abedf92f5e4c9d67d135878de2c66724134c24394e6da8896dc0b5d4bad62a7c576a6920b6b631f7cc7a8e3b7cfdfe235c8259c98b8b14933db3b12847a7c358c71e42184fc985188b8211e43c145fd78678da75b91bee4a9bcf7cdb1c9a224bc7ffe211e336eb49c1f23a104188002e63e003628d01843fca1fd7a09b900be1d281ddedb5fac0c80e99c5b2fca790173ab8c8b228a09b7ba3f4701570b969d1971a471a71f5045acf53eddef68340e8fb150c4ecfaa046b98d5f4731cc379eb82158ff08a8bc14bcb6cdc99299e387f5d19e4c50426d7eaa20796afeab53a51821ccf17c18a5ccdeb51fb06f87cfbff51710f2620743c9e00965bbf212793a66a6468e51399942f3973f06170ddbc9433af7affe8e585015bf5824169f6f0724a9fdb7aff4b445f6bbdb0aac11523dc648e161730cbdb12ae3aae36ac8ccaffb772c78760897b1927b5f8b90ba81a1767611e21676b61d429f351656d7162bb52b6cd20b16a2eb9ed74e4347ffdab338f2cf89e94c186e4dbf98ee6e99ba91b24d4f9d0e0c617e40eefaf5915ddb9e54bc0628a42f5281c973141ec2ea88eb96d9eb58255b3bfc7fcf0279c52bb3e209934053c8053423b74695dcf747e0d57db002c712cb858d34dfddbc4fb0cf68a9bd05ec56f3f149f9062af599bc48b1e9075733a8a57c420a751aa21f5d1213f5624930ca56cbf3316d89d26b5d56793a8ae3bd9160ea9e8ef6c8eafa653a13a77210f88bee90b2596c06363452b7a92af8451d988d2ec65aa72192ed0ace3f4f645500be8d26b4f9bd3a3684bd549ed7bd37510ef1f49a52ed008b63bd27017af232e108f97f6a4fb81696f9e7d92b9511d686839dd5e12e37858187688c577ed53bac88e3300e9c5bcaee721d282b1d3b0a7e564f9c3d00ce1ef40b634a12e0ffa709ee4dea6a3f003e192577099e9fd2799e8855ec345820fd1acbddf7260c04c6bd3f15df0cc181d9e7077de5079bf6a1a938c534a3e537e29a2f9a985b7076dc7bc0a8eb97a57ac21918c485c61c7718fcb81d284c719a0e642eec8779ffcaab065780be4bdcb34809a5b887eda533ae2baff8f4e4abaeab29879550bc2e461cf7d3907aeec6e2bbdf5a62eb482ac5d8297a62828f0cb7fcd94c4f88e076be4cc88a879b2280ed726c33ed5635355f85da8ddf9167821b88fa435e3c6977d36789ae9a751b082427051a8783a8741340eb9ea777288f00f59402b4a58c69bae756fc429ae34472e47c1a9e47723a338f76be5896bab8d316748a7f601e7241e46013b63c7a2a6d970e3fc110fd8ef75c619bb309c8c2420379d120be98d9b84818fe4ea6a6df068798116183dbc53ef9e1ac9b2358b4d11d0bad20acbcd1b72d8245c8b92d0bdf5bdfa426161a47ae97e1aebf4ccde4305ea0befbb92fe38e50225a7e281aeaba8cebe5ed1a4bd6d3fe3b31162b45a229678cf54832aebd8edce1fd383dc600029669d7e852bfada6d6b96ccf11ec9c93b222312cd60ad2f6da2a1645483660cbd2beae6569f29bb589e393e3f117791072265d1d4b4694cab9e1db62f703634cb648193d574c967524cfd76acbc16112eeaf5189420b28d49306636ad0f6b9e38e246c115f293a17746b7598a5b79fbb86dc10a3315561509066f37654a0489c96339a4ee394dcc29ce4f17d997d32c5e21880972362a0f966b7b4f1fda02747478c3f71af7438299459e98b717b3a9c4ed5c09234cee9eb1964653307e5b8644281fc95643c6c44abbb22dfa89b268c5cc718845f770264c4756c5a816a618b96db567fd15b95d16faf05fe9398b197416f0a1ebe36403a0b4076dfafc4e4e0a318e7351025ee194e6ad81c203394f6ec648c353ff932167efb643962038909d42592297d7d70358397e8cf3c8b6eb918304f8c4049d7719be5c28d655d0c512939c7b10bdea3d77704e2d89a10277b2844ceef7bb7fd5e911fc85d3601a6773f95b77b1aaab1ce96857173626951f146f2ed3b4890f8d5fb398836de513dc6791f2baf0f3699ccfda924b9c1944794ae103d56d0218b01bab737af82478cceae3f2c2504bd43ad5f9d15cad2e841e73e97760913666c45f231e1c7e0e53329bd72291bbfdddb7af93cfa2c0b9a17b23cad959aab315d74064c42941060c6aadfae1029718b37cf9f9c922c1d594ef37b4584ffd76eb76beafd7766e077dfa112211ee93996cbd8b65f3c8f1f9861399a2fe8fbb7c4e93e6880ccdea4dca958721ef6396b0e6348d8a53f8ca6a3c2514d2deddcc598efe48c2478282a3d814c5e7701c1f821ba36d8fad91681494343aaaf0ccac25def0447374846dc664c54e039c472d34f63ef8813e905f09d0409597ccfb591bfbe5a07ea0429a8500f3779b079e445e7ff050b6de67c9e73b82603166aa4dc72d23b9120be5e96857ba46d83bf79105b8b38bd6fa5ca54d741c1a89ffdea2c7e89e6b7ea292d1e0199bbd1591973b904aec2b1bc3ff1fd29c311b4e21fc5bf1de35050c63a798c276f660428257fc5ec755c3fc30980b729b4e62d4f73b39ecfdd130f86fb7bd49e185de0f9b68cdb289458934738079c6f59080c63839163a1180533dfee76aa52a54576a467428610510bba4c34a02bcfbbcb7bf09abc950e88c63d12db70c42812d03f4605717890e3d8987a3253df260301a6e1ef06a83f4bab456f9584e4e7faf88cf7836d39792128477ff2a3aa4a3865b8e53eece04536885d0c3a2e741f0b10af1fd27815322e4d1ea127ae443316553c8c9ac26a817ddeedae7a7c11fae98c7f22d8b6f6af6169806ebe1b8ddd74f541d19b76c1d1c68190bc7db72f31f2da032d8d5ee14e9b80db3fe50a711c21e0e07d333c44d0ff8ab874c7172a501908fd5f22954e4919b4673d7ceb31d027646574ae37056348c3494f2f00c92a81a811d6ba5cc691117d6e6c5bb26e9c0e3debe8f7e1dc05f3c549b9932568fe07c733061fd3fac65568a8f87b729e302a08dda0bf4b655b16b5ecd3210f4ff9ac64330e20af72ba835081da433a06e6322fc5b456b063278af9edfd050dd3a31f730ccf0e128b4fbdd171ec8679c3c6ec0e66313559fcc00fbca1f0a24280b1d2c4e18394f849e656d3cc14b41cb3fac7885bef52def83219ba73696b469640b3cb6029b58b9ae8d3b4621714b64d659e710e564f6c30e23134b3de972e8f599ac61f679ba0286787cced5369e3eb2d7c4906071ffbb8633b298622d04509332367ddfdf3fc4adcd70d7fb2e94aee3f517f1913fed949cd1aaf7e4a2832e8611101babe33a5fa44403de144d54e1f5f4989336c63d0039ebac933e31eb607c0da8420828bf24259469fd694f5e2fcc372d0fd8c054505531c865bd7eff7a97274edcda8dc5dd256c77bee974866e154cd85de63e32d95fa5c6c871e2aff16e89b2b755bef3a86b9817dc7cb6f2f204d4c5100419d001bad9d7fb882fdd55c0076510de378eac007e36dd19cabc350d5609f2ba16884ad01b74c326c934d662141a9a48d271446b833fe4a2788fa19133b22934b78934315875c789b2e10aa71d7e79a7ac3223edbba0a880170e7124047d3dec0ebb8618978c24f665fe78ed47f1d0ed3cead079a8b95aad24738eb5a896402aa78cbc2afc7682a060acd6bf5e40b7ea4303b1622795f25a6903a2c71a79b99a19c576636361e7854ed53f6c3983a6f0a889f68ae737b37a62bcdc26114b8625958f7460b7f93a80060d8f009ac57dcd51e3391e6dbeda1aa6a0c31fa0bc1abf5d6731ecc556500a4e067bdfb471e4a84984644725948ce9ca6e188b56dd448e5bc98b500110f304f9b56c5001cf85d00bb8e3c95943e3bbfbc9a2f1db1b239656fa8c33aca59c293837636c4bc1e3c3ac8dd4f71577cc9d7920a66cdcd42732ba5ff669fa960635954b95ef0bc373737751c2935a0cd5354118e0490cdc777b1fd2749c881b018cc9eff194950a81d860c7ab2d0e6321eab593c0bde8bc31dafa74784aeb0040c166f91e3162165b9a7d47b4e80e449635026d0620d787c2d755d99b14f1a88f85352108d0013fb1b1f26420838c113c60b763ce6a4a5a090240835f16a5582f6c3cd76de4015b9b632fdd64a549b639e2bdd92d5a7f178daee87401aab888826a3e01dbcc6e42cd9cc2431b133454c0faaf0546661dbac2031f27a4e1283d26a98705c67620a6592d3e86e0542d6644bb33d7b7848f5ce16b9cf5c8e87bf54101d78b8bf4c2cab584dccf9d87d6d9363e9fec311f872e43e4ae6b277a8f238ae21b6e7e8b23c4779cb2c33882888debb648e40763b528184394b45f0268d45c9c094955c394beca0be1165d4919b6322fad35d0f003b21056e5386a8a3b0d5f1817c45b32fba0cef55ebbd29e2e5fffe28711b5c19dc240ff761cf7344a1dfb6c1f1762e0dbf1ce974db99c0004624373b8e9e7498fbac1f640c072b9de475c784c318a1dee48bb8eaf0a83db7cfd8cb556ba8361bc40c80993749566268f0ffeb8442155b01e3afd7cebf762ba99b515063d9020475febbd82c11390a7f2e9dfce3bfd26dccd24ef0600f3b6358d7d1fca47917dcf9d423dc01f9596da15ab03807c202f57a2df7510e2b295ab2eac0a94c3d695cb23acf9279e73048e848748bf5fbf540244a147f354cd4a72d70cd6221a7c65d58e25483171c72d6f4ec629aa0af5a35ae3c4fd1a3113908ebaffd40026f5394a5a159f4b7e50ecda4c32e6e060a133cab74125e2896a8fd5ced858d324a2e3079ec13be47c9b645fe1115b7732e39887e6134b033bbbc70abc417e38e826e2ef5658319b33a9f6e6c8a9025cdcd9dec4c0e9d54090f86dfdff21f65f9ef1392712940e700da1ee6a2a85c147be2934a55f87db2f1466ced11a2b25d00650be40c51a38f7eff21037d0014498d2ba6520bc92f35d0b001335c48670798c81600f441a5331279099d665347035d7c091fb273523b1803c14c2c213d309aadcc70426a0b4628dc2d6d610a8b33418b0dc696168cbefa992ec1740428b69f352dbe6ed2d5935e5e3cf48ffcef0725419b9507781a534317f14c2e8ab7375bd736e1affe049199992148c242043dd0de686a2f4a32329102d731d65926062d1750125de9c6951f513d36144e53fd71b9fb6b21800d457b3b25cda269880b3177aebcbf60571ce6d28e80920290f19d8faa349c51db14ff03c6882823cc797f590617b8d84f01d10eeeb18b73ce0483ac48958d3c60d5a9b528055950b39dc83beb0598627256dab950b22e9bab42598875fa66d0c26875219c29050d1e9c2104002577fc79637896aeaa5d239a59383b8cc81a90bca209e0c8d235ce4140c422c3f08fb4ec2185c5058fa65bd4c4f2386c0d8b32ae002a74a718e4a364368c0b573283265e5718c56bad8f6404c72af593efab8ba1343764229a02cd2595e7e85204a0e3b09bbf89c7ec6fff8631950063fcd9502c5c795c923f399eba7ca2f207549492f98e9fc7220bfe7c920521a3d75c7fdb3a333e82755ff6fa411f9bfa4af3563b57c8b9b306011ebc4f88d36d55482708914e7743282b98fc6f8fd6283ef1ddf46f5a91e52876e8cf0e9cd11d7fe399dbb09f83b40b3775b172e21121954a20478dd58cd0094afa4109f366d4f46170b620c7de40c0b081dd69e4acca256d532d8c92978f8246a1cc1e2f4e4c6cb56e11e6be781de7d8902d90149d75130be868960341369bb7a3e3a38c2a390ea21032d4d44eea3f9f70ac93adc7e40f524be41bbe6582678be0a060c20fc06f8903fccdbb53968733c31de88b7a1ac6eb688eb2d1b042bfb9d6c9fabcbba8f2b90724d984be34c7b4fefdf013ac02ef9d0bb03914df3d35b04a49b1c0effe12d88e923dccf46d6278658eae6a03299505a56851d9d7dc258b191ddf946856e071976dcd1e1d5445388d132ef27825549eb81fb8569ec0db060eb3d0f5bf7975da9738d6e916d8fb3660ab3fe4c601014d99c6b11106b03d348217b118299c5a4ecf1fbb1f0f565712ed9b5fd5f867f9b82155ed3b83629d3ca4791dc883719fe7c21cf890b03ee819fe5f1e52d8b5a306658bc5308af9b20f1ac65d0cd3e439a4ba08dcfac134a7eb193f89b9f809fc87da9d6add0c0bb982aa57f63a47bfac8ee554d148d85ca7bf1fc7a19d4089f818f5e88d1f45845c3b81fa4d8c1b84f76d5c72f780109ec20a85cdc2f01aaad0937eccfea056637c6550a7ccf59bae897dfa894c25b8955d1c7fb7dc10b0e8f592535f486bc40e386ff5caa48572faa142c9e25e8246642089fa4bd234db041b08fcd9a7dc548d6fc9edda67d8aee53aba3a2db13815f9a42bbe5995b38dc2f9795f46f72ed34e0c096e7234db83efcb3eb1d67f1e92da5c1d98d44a414418b8ad8b4a2f36eced9e5e617b4f0d4e54bc68b7a29dc4a6f2cb3c9281d263c5f04fe78abecfd5cc58f04d874bb2e9d7d71e0876fafbcbca38b838f027c32a8be2cd5cbbea3ca8b37dceb1a193919f27450e2331c95f535ba24a487aec0420025a5d1876cb44cd03317938f1d27d28b233f2e43e63af02bd75178a9f7f141ae096ef4781e993ce460f509d7b1fbad7a680f40b52a4836f74632a21da8ef65b1f97ae8f9bef48e2451444eeab863184ee256622d92982c01c6d669263ef8e59e9e08d50d1826839f05f14a5a108facfb6d0a62587527ec031d92ac20500f761043a4ab328c1522b255899c5295eee86a3926135c6a7edcfe0e04c5e995a33332daed03d7767308a9ad716084514d467483cd95e203bc8ad5541f8168c2f1c2a8dd7df876f4945f1d6ce9fe89a463bf05dd8a7d902fd9b4c3f07257c3a18ac8f7927f223e859a8c3eb41874be0f72825ed0a13d6ae263ecf0e6c5878e3be95c9a47aeb94c119fd56175845229d2a0c94412ca8097d7478e0d3fc7252cb9c1dd1d1e807b94bd49564525b569991543b94f81419fd8a507f216a99890652f4b2f6c40ebf2c88bbe093a13735feb190cb93482450aa754f54c4517683e4e20d1a3720927976fdbd5be63795581a82b7e56ce53a83081f7fd2e64fbd46fc4d17e16f75fffddc38726c52773daa9c4e80b81dc8253efb2c53cb7c83b73c09b4e70234f345795ae1d7bb32361e64848a28c3bd44f0100be108b57ea54b33237d4295c0c2c3a7814e7163792b6fd3d1eedc0b440733b56a833e0472c0ac3734c67a4534bd01c1302fc556b1a9fd4fdd8135fb521c97e22595ad1ea76dce998cc7d3adbc61fa7f1f1c19f609228cc6c43c18e82c2fa44cf585ce9900d689e562842e0c2d454c6b7f31153ff8d7e283fa9edf1f88b9d831adb073425b074be12a5218dc829551ce3330730f6a96ce5aa0e052d584b54db3c2917130a7eac097a42284d6ed3232e838c2fd7a9d80f0a1048744749ace593717c547c174abd04be3398876ab45ed9fefc4afaa7493a2f20fd06c3d85c560d32c8501309a1551966bc64a722a8bb6fa8bd9b6ccd6a9c26ebd3160b62e46489541de147538a77bde41691c81774bf579f73ac80056728025ca51ffa2c7630eb3297117a507ae340599439ce07683737401da8fbcf3df7fe23779d1132a79d69ebef06c8bc8414545e059ce451f99c75ec23c6ecbc3a5fe400c7f0803665fa201a7e6ae66b6a791d46182211c1136b6888af0d9db76f327b64f90015a801971d56b1b903b725c374a7f90cccf72043657fe7c55f70c1b305fd8d823f34804b9b68dd5841bf7a428ca0d22d9916d5044478957681040a2df9a21681caa38078011d58d7be0f0545eb6b5ec4f9806ac51f15bc5a2240306c1726347473e69af8f6a190356a874e09873c933b228adf9d0a5aae3952000ffa1484865eee02a2b3c23e6a88693a95e16968d0dcc1a99956472d6b3f8146b10c69911e939551e7fff9b8334a854037a1cb8f95219515956df44ccc65b810f2d8d0fb42e2da69b5dd40231a34ab8678b7c71f9676013ea8ea56becb5429f19100a124ac7c86f17244cef1bc23cff493ac087e722f216e984adea49b288518924166a1e5b902c39dbccd90b0b2f0a213bc2b9a7e93a919b6b63a341431ee278129147ddb243973f9799de0ffda0753d67dbb8e155e7b4a2a50b8a594d32df6bbbb46e78b0a6111fbc9a2369e26b7bea3f6a7246bf9ed5a5907e581d0dc3491d613098c17d78d4fbf70847c89c48eb4d4d31a48a71769b7b087233e88329e06906de28d5c697858f2c0502c5b04a53f9726b388d8be219a64d733e46ab621a7ab97ef67173fcc88e3ffb578b8b19a7bc0e9c869c4ece83876f4f52c5af5affaa6ec93706e083b6a0c8096e47efee9ff397d88a366ae4dad2f61ef3d307e17bc94fccaac829b00e3d8371dd541e39105199205e25a1d96558fa90ef657975fe367f689ef3f9846713ed46e7c222fe4fe8d116eac3e2b636801d449d1d3d94813bef2cda87e779910fcc8a8c0be15578452eb3db11191c36fd949700782400a7e49490fee1689fa59e3c4542ee4dbecdcac942be2c26934ae15c2e1c5df307d971498993c2e87bfea50c95c538cbaaa4be75f17d32d5840f610f318b583efe86f3ad631264edf663902843e84e51911e858b55368710b8f0bc951b67cdb1d3809b6df2eac735ec52903168e14a8fcebd7e4b3215cb1e9a6159b4908b01b160fe6d5a1f53a75e86ab56f70ac40d6405185c950dc470387d55f0c6e5135d8055c198b76c48aea8ba0a02335b58e9625fdd2bda5b8ad2d8836ef2f23de313819a921c95dd34b28da53d67f779a1f1972ef740b6739162470434adfc9fcf908478a203a692809a85aa981756839c8c118383dbd35f00e0c6ed3e0bcd8a51b238ca3e94bd2d9c9b26c564e6d07f656bee8194806f1ea3ee4f41e23d4d2545513d70dd7864a1bebc3c10d69b5cdd2d47feb79fa7e21408fcae89763754560205a6072e9496372334048ed046330c4c4a812c144d3e245439c2ed13bdb1873d423f25c94e6cb09b5b4f22f2d28bf53ee41e601f45ea3dcd3a5a84dc6a32dc36cd56df920f2cfdc3836c290305c60aa6903e8291249cf035fe2ad4cf5d3caf98e986cf0269d46bacf48c46cb00f04ba78ca9685e99aba729c6972541636d9a62f97b3ac314fa9fa62a85e4c628e9ad3a6f1cd9b3047ba24f20f1fc56a8a51366360028ff062322164ff3bec44cb89813ec9d8219811fdc73823b9c6d2859b300840de8ce02e0597ea543375c2ad957b086af0a8ac59c10ec0543c24c98f843aaded5489398d322d0d20fd6a7a03ff1b4d7a24285c026f766506af259873803369bfd13f389e90beffbb496dd482c8e05e238a9e137f28df41f4276c0cf59c66f1661557aa367614bd9663e21ac2590be0d42bd460e49b906e3259ac69fd03b5204ee1e16725efb31fc909c2dfcaac06965899d697d1ddb26ca752c105dfc3774338b0ad0e3e9f5c0ebd0739c4f028785937c0a9d053c15d99175df46972af0fa5295dee6917d9b94836b4eb55c315e7988612b06e97b9f84ae7c272bc393bafec3a929d4e297e0b4a6b3a75920f6adc0c2f870f9c46c844fe2bce1314fe3215894f7464c6881db7ab2ff4863e8fd666c9251ccf0c060ac5735d6cbe1eb9075c342651ebfed6d8d79f7bb35d585fdbaf703187030b1f38334a9ebdd7781c0287f95c4fbf101cf599a6a85f526c17c46909dc4bc785ee31e42911ac96e0a9caf79e97d0b5680c7534795ec42ec0a9f40d4eff00a4daa9452808aad4c349ca7d2f6a90411dc2e7cfd4f7b0099416fcc9d4927954be87ea323f0ad745dd188189e68596036097dee55abd1b1b61b630a87fa41e689294d2cd9940f1870ae0eef7a68d6be78bbd359c999b21ef4203ef68b330b23110634c441d6d1c53d2d1d2472a2f6be88a8359d277568f9e6a24584f5f62dfc982f5d5d4530f268ebc6900eb3f1cf0ee798d8806749b6ae6faaca9ca533fe3b297aa5fba997490936ecacb33928a8cd28be391c3a9dab6790fcd390cc399fe9e6fd33c1ab97cc5ff84ac7b5747837af9608a039ae109aaf7678cab4024dee6f83a2c656a424166e1b7ff898ae96efa6be63228c4e4095e8f452239a2587147c2dfdbd523f315426af8e2021bfecd4b8827c53f9a3ee8375fb56beabc0b996095275a37437aa1688a4753a1ad77d9cd6fbf1d6b448279a6e9298dd61cd5f1bd24bd5cd0121fd8e0aad7722476857469356c02a39045583cffe71451140ac5d5162fb6f36dd266f2d7005e7fdfd819403e3a1c6c2415046ad21a35b1f81a989de9b32fcc0ae0e249190033e25bb4f84142f9982f2a9fd408ef192db1a9483b8bf8247246f1cf7aec0f44b3c0c9cf296ed96a2b6074cc5367895e27218240fabf92bf1a5c976f03e424ec70f0a0d84d8af7685aaa2a2a108b219199b5397526eaf6556780a3564381dfcce2d94fc4cb74bc7e48aafaaf72749760d72bb8d1177d0af6f4e0ed2782b0462dc584252fc4665831e9c4d74a2d7212acb618b929613900dd043db4a7d22993c26be44b4fa983adbc0c66a968e073fac169fdbb4b86cdc82e10182e0d34a3dd20cca3363bfdb687bb0f738e83aa2d67b8072509474a61db8cf0a2f5cd9d02896fc413ba6a61df5decd2ac522ff6b418a343acee4300d1677b9777dc329c90a5325a1d139dc0b8791e25b25026000a523ec9571a41709d3de2abe976a340d76ab3795aaf0347e67b23aeca6d6483cd6dfa9f6c61c8352bd7b7b9e33ac14a9ca20441d6a7dbae6de96d6eb41d1b40004c0d3b2db3760d4a7cc738b73a27138e5a178bea99ef525d040d6813f933099ac63adbf63d7225db0ef7045856fdbf57708405caaec65caee20ee80229c19f5c7ab22d827ee588fb62938e4f8b24910330e256e443ee27affe71015deada2d029223fd376a421b108b002cfa18e261b9836fa242e36176a09f2bb5ef817597af35d4d06089e9e31b292a600f51c6dbd78fea09f5b4d38b976288ef896360c521724c2d14d3ce002ad20c71c1bc88be3404f857beb1f1075585a61bb4ad77969676585c59ac081fca96c081d28e21ec8492b22283b35fb83e6f57d26dd41c93e455169df110920eb571b9ab74a2dbbbb34d3baadad20c58d52d9efab426cd45f2564fe3dc49b16a4d45e6dedfa0d42809243dcc336e22cc286ff3aacc389b919e4d916b08ac2e178d1c09f44e4bc3f7bcc4938766b33119b3f8830447246c60df36b8ba2f000e8c24f8b8626efdaad8522b4c011788e79e4c4f0bf21fa1ef1baa1348fc1f569321832456e1fee5b638e3b908514f765c73e292950ccd8a696b2e880f048ea850bd87dabe0ab7809893d38636d92b4a6153bde239273b3f296a8bd0ee0fb71d4f4c532669634184ac5489ddcd1e407a89dccbec0687ec46945e9db08313380eced1afcfb868c915bc138ca04d7de121bacad01efb4c7256e0fe6f9678968e98d50a41ca09f3e4977ad64284a0565afafa53ff21b64f5f5c60d916aa3595fd386c884a62d434e109476ace769b2e4afc07bd7be07b270675794d6c1c0d19e82cdae3beb02e09f45c975f2c2d66b0281d8de5fe491de647f0ef57627cb6f1f4dec1d8b9647e7692d6ac3ed2fe82afd4802e9bef3fb40ee63dd426c2a40b042647f6f0842e80bd4ae03a149db975dfb5ec83f45c6494aeda96aa83e3b2c9c9e835584da12c1c5dcf6c43fe102c0ec813254d2058e114510474cf11fa718c44c3de978a1925643ae71354eabdba6241dfd1a82edb956d85e456e7823e6ae9b3195d01921c7ba711dc410671e6087deefc712f18a9ad4530edd848fd9b28e8d2352055aa9cb21888f42cb0b0cc418d9f9e3ae06009f4678c5266e715bc77a7c23536bc51427a27ab1491a06afea906c790740da14cad8a0dd45fda11148f591a95ec69c15224a234150c6345db11359a00c34c86d79c365ce3f240702a8b2ac71f4e711b18a8ff7b9349e96c8934404e43b7344949b8c13f50569a6747ff1f990bfcff06868551183c7fa2dd39f4d274c7d2ff0ae164ef9fcf879e0e725cd91a45a11f948cf0845711b61c403e9b4ad77eece43ef487f90a5d48d5e41c49f3aa1b68e0871a8c82292671a284de5ea365622ac6ee8843ad45ebf6767555ebc3fc595f11e280aafa934b752dbf6d899d2e18282a8624fbd5f6af922f64b54bac100301c079d3ee1ff5a96adef3b7be4b373cd916491fb250dc55f80cd72c647913703f7a6ee79569df173985e9afc465d0fc817425de0c69439973769f47e6f886289d98d12438092282abaf4f96633bf5dd15f61ac69730d7c462c5089859b1da7c23967516f71c4bf23eebcbfd2d5ff08926fceaa3bf2b04277d8f7c565de58b08248c0c1bf09486ef5e44b45475d7a7b13b3c3f02a3025f191d454f44585c2cca9a88cda1957ea1250706dc59e90c0403cfa5ad655614e8485be26d1c3995f1b2102f559dd564a84c444293a21d2fe50f9d55f85a2209f3ae24d23e102daed604170c1cb177088de3dacbe13c75d666f680c6d265b5e4916df32da4c4f5c8627a6ab2fd91376efc5b2d0d80d6004274cf26f64af4126b7af8c10bc1bd4b09d36e73c0feaa6bfb0b143583458e124cb896b82777c0ec8b6204cf50800690fdcaa8bd33dc6a56d60ac178f018cf5493307ebf4faf7ca07eea09306de6b21a9e04e79de8db25ded69e72fd86fe178925f5462f1a01a99d3fec31f1e3a5991a00ee7a52ecaa30dd694be3905884735db3738003b1f877af11962d66301b3e78641720129f76576e473cc28c0ed9a803efdfb08bc62bf4afbc44837d058e5506a7c50bfe98de142871e32700b944a6ff8f42242a7eb5749a5850a253fba0a750a20c1c12176bad913fe1a8cba84a98057f028a8d31fdc3eea83a119c222cb63b4dfdc2c69f8790beed19e556f4233bb7aa202175c77260b4f9c8dc3db24f6f86afc8460e2be6bab016d4af7d597ffa4eb6643d9536d3a40e23b520aab792b6d58b39277302fdb684c8dac24853da953f7cfd1f684c9a9a8add92465515af1a3ad302bd61cb6661aa01bab91e9ca878677225d29376534d513c36b4c27569b12dd83ab3cba247418d048c13df01efbc6da037d49076f8ef4215184b2280f22110cbaaf1783d132ae52acab66b353bcbefac6c55dd3876763a082ec7fc27308787b1c7c1c4cb70d8a04dee381c9c325f4a19fdfeb3ebb8e31d88ca55a959be5f29698e82c787d0f132ee3727ef24a0acaff99d92323f857f0f0513cb25c03a5597bc3e2108d41cbf973fb9a0dbea0376452dfd683804fed4a31b4e3d7f36c422e41b172205f68ef746a0250f62dd921dd7dd542d642ec40f7f854e030285b87f10851813f2a08aba84f7f1efcd853ca96516740a1fb1632e3486b68d98fc97950a1fbe359f719066d029d03561ad5155ebe610f2e1ee71e9b1f7675f8acfb00da012edd8e06ae15cf908f5aca67f0b0c1ac90992b6188680b853ed0778caa4ebfe2981bda19fbb9713023d6f0037bbb00f77fe7939a7028238b4dc7adce50beecef416a8e986afa26874a15620ef33c8c45b208612a90244204942753d8596181fdb17a3bbf8ede26408bfe46cc6bcfb64b75246f00e9385d7d21445dbc01629b1be36215e0fe9e86d0d4f7b3c408dc43db7b0a7baa06dd2fb409560a4af728d5384da51cdc45352551c77c1f8b45e78600e9c065762ad0c0c11141cc9d983a6f1eb1c088fa38a55862b995d6e247facec126cc2bfe9a4a2a28aa1d14981cd3ad29ae991666674077909bd077c8eb069c7b5593487c20b9c2cdd0f5536f2d1e6d09984b2863d6bb23b87c2d23c4d916f1038fb4683d3967e5be68f425679b0bc71508985dad9d822939588fddb77c4748f01a3673539316734d916e1090b9351e9e05c5d917bd8f51c20d4e5d8e55fa9835501999ccd351380daefa0c15739d9a202aec48c1ac2b399208724158592e5c5298efa1c1254eea478e333f8ef00d607ddefee29d9671b55180c6f6cc1d6515df08cc0574381ae8253c5bfa7b27198915b4c837c8f39e1e1fa27f249bba05d3cce74c6a4c51780aaedbee77705d4f5bd8c347eb75356926137059519b6913e40f78a3c557c87cb19a9911d29f5a6dbac8070d6c0aac6aa69063782d7ebdef8228d791c9d7532735b3f0696ea2238b02167a1c0d80bd227c7549b3a8a7d0a8830aa66c110532c9bbc8bda81ca77d831e17d89cd22e5fb5c77205eacf616de9f1c596f0b54664ef279e2418d4f301be0e08fb90e51c65cc96c840dd5aad9658e9e24323b7cb4aa5f2807898e650b2e6bbbde8353bc2adb8e3e75d044eee873656d2a0bec389a915e04830e5f2a99b534b9f8d5d51bffd0ac34b0bf613ce28cc2183efd05cd9889ae6c8b3e465577cc6092c6d41151efcb15b516da3256f3e410a69479275a035ea2a9022299d03ed39ac7de63e37f212149a17d4163bc632b85191cfdcf57565b0a2baad1bdd23ec185219d1ad3acaf82b195e9ba8434d1f6656d5a3cc21eb9ac2d987869fdfc07fbad7a8341c8739ce0c0cb2e2e58aa9ed91ab97b6ffbd145cb9d4eed03b9f2f5fb3f30f04850f9d6cbb35a99ecaa2e18506a3ef4c40f3df832aa0a9fa8acd3c93f9d9fb11ff966beb111f9c44c883a25e45341814c26085a4e81b9c946bb16ff53753e579ad06cbaf674b46110b2c310f8dd8657739973efdadf688ff994a95554b6bf0f233b16514d2b10ca60f1362ccf4660b0b649c12c73715f23f2719f364ac3ef98e3e27be87af00b54a6fdac2ecf25eaaece4d3c681a85242fef70a0f6f12067c19efdd31d23b870eb0de5507948b6fa60fc5a7ed0d8d0d729dd1986c7c260a1998270ce63eb50adcc9dbb65678c9616b4212c049e0624d58c324fd0d2b5a9e11019d70a862a68fb891a59a033afa5950bb03e98a76f6c04d661584e096945a18852cd85246740a7e91a7daae803baf6c465ab35ae05dcd814e658a38734b122a557589adb5012c0d9ca8c7e61a998794c9d67e1ad79dbc693f38b742841c541a00a86ca30b4059cd0d83b9017eaf6d0614cc5352279734e24a25c6c7347445aca5927e61fe1dda9984904d30363478351b45d19513b1054f906a63eb29e138eba2cdb9a5707adf4100e3a9d54b2d19120364544a2f1bb845a766851d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
