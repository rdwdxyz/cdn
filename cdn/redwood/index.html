<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e8c5a3a6504e1a8c24f51ac02d5840cc8066109d5414a6048bf8c36d0e54e31bf04fe17692e75a6516ea2d7651e22317f5ea2a6f9ab7ce7df5b4acd4b125807b7a6ccc3cb2644d5bb5175798845d54011b61065657f6cd61a38a729c6b6229613cbe66d3ca2ffe2e492c95ca20a410f2d74fb06b25df752f1b4b04cc83fcbdd296a12c24c01150980cb3b8b84622c53c282f1efceab8b3fac3c00ed51fa8f6aef3abb000cd02e84534843ee07aa8b1d6f7737a6f62335816133b760b59f348b685d99501ac762af98e151cf2b60bc4f265043fec31739ce4b4ee757005005a8dc7bb227b3b6a084c4df78ad1ee06d9c2138c33b265574d8607209c6249dbf971d1e333669c5180f3843961ca5cecd9261cfaaeb40f1fd734ef953081ce72aa407bb2c613777431b784c9825ec5d75bd8eb298712e13f091621d904a09cbe73adf421a632a8b7db4e62d9b8bb90921303c8907131275312aee9c593a0b5ae01a6bcf113f3de17893b39037ce37d62021289eafcfe84d45025510671dd99652a73fb8d23072a94b08ca800f76c99f0c824c2c1214fef7d42161971fa6ccbd9dd5bd93e2ecbbdb683997ce45a4fcbf43dc66255c6f798515c8a20e794f7afde482ab0d658f1b64656d4650c165a2d7b81f4f7e94aee1d048df9cf7813f9802e7ee210709dbd826ec3ecbc10e05783d55750222ddb671e7396deb7a137d1c47a95d1828e4616ef8c3c0e8197b2f0101792840fe6253808360d98bba1f8658974e855b4c3dfab9c72fcd97fd8a1949c00c877aed180b4d9c625a8e9e52e0dd1ddb636c2e311a182aca02a767963a8f7f199dac5248ad4b40e13530efe8c395b4d8e90f2e399614a9af16576286dbac0c9eea880ed5d89541f72a251a384fda90bdc7f08463bb39740b9de868095147e7c93124a0fcdbbc8481d3cae67c81353ac435f2f6ee94e1c4c8ac981565b0017f17b53b54751571e69d265f6dd6aa80a810a8b097a68a9a959f0a94fd46326bad0bc78c64f2fdd83cd780f150d093573e59f195befec7328eb751b5695c9bc3ce65836379923fcb588de0326e5e0dec2a199afa1828a1d05212ee8d508308c4f0592a2f88823eb5c312546a5c679f5c7962b39495bf22a060fde85f87f4965b6573ade6ec33eac4931b8d48f49f2937ff82f218eb299cdf1becc63e2335b071cb9b78583d5f8d37ac45b7a00bec58e75e468557ae67dff766299255ae3bd4292a91d95b3dceb10c10ce6ec5821725d3da61f5ccbea179f97a4cd970e49421e8938b609bb470bc50920b9cad40a59410012e9e9b6e13edf5f21f08acb98d287c7969907436667ac749c629521bf200686bde724f17b1a10fc619df53457c9fc320ac56fa2a47a1b8a9a73a274d39d5480f3414d69a7fdb467a9b06573c5751cfdf611af4a63ab8f96f2950e331a055e0135f1fae4a4335bc0ef076eb902dba29d52f21d943827c06771ada124fba18c17ab582dde6cce5004bbc0a2332a333b704363f63b130537dbd4b8fcbb8872ecbfb2583dd031ae0098cbcd30b3d5bcd98a748a11948378ccde850344221363c14e6c60ba89d116ff27724e1ecfac02a3196c8e8191a3f878b6609bd1acd2d60fb6af1704c1c383e68527bbaa5af10e76269afcb7bd80b6aa95b77027d0121f9419eff33966dd069cbdf6a1b3aa281d163a11aad52b1cd56844cd3a2d26aa1cb8040a3efc422d393530b052da11729593b16cc465232f906b323b53a9b8d38c2fbf5f24541d8e10b8d8dbed14e1f2c27c1d003551a607b916ac02e918e4d1e0b6118f8c2a2fead28e7ca60ba1073b982f83d3be7afc1ef973e7965694fd02f7050a4977c9563ee5e328d30be7b1b4941a0cb1dcdbe7a5dd9525b85c329548d6b5f47c1951c2f929123848114a0d2aa33f933f231411b66ac9b984569e930b4b6ed950246cde9e04f198c256052fb5bd820eacc5d2bba5de465dae13cc3c9e63566c8b20084943d74cace3a87073250cf7e7f838a95058d5049ef18608b4c6b059706f9dc6d0f881b967e417b3c81f0ad0e889e9d00f210005b3f0c73675f8e1b66afff6712003710e0716293301c1d9e7619daf532d1c3f99cfd71411b1ca0762c6dcebee3440cd1269e02b0884eeec0e886456b0962a5d575429a25c8c815e7e1f6fce5007c32f5cf32f8aa24c4ed8577f4e9185a0c321126cb76794565af8f7b41786064c4ee77c0142ae72464a169130ba1e0d0103a32d3bb83bc51d1a3f6c6f692506bcb3c2f11d660aca1ffc2936c3d47ae6e2c194b1b113d6b60e8731382a31cf87f23c11f8a4cf98af9ed9ff0a20b47ea8a202753b58e15ea9d785e00ad2927ab7760f94cb0603330257c4a36cb3b5e2d8dc72221cf1a5ba3f8e69457324f8e314dd84bca0343372de9bd8e152ccc2389d56060a78ef1fe24b752a3896d4834c1cfd69afcbf6fea65bdb595fad00cc57ad30bf1faae85309c3e1b5271cb525d4789704669a6977daf4c4211c1c4b2e69a0b7aaeb348205cbdbeee99431d77868f294312d5940d08a7bb83ba73262833818a5b0a35f468336829ad1442f90a46ffa48231e42d4c61cfb306d53d24c9cd7e7b99ff82333acca41b32bdb5b87fa3c1a0ca826d21d5bc7d63fef4ce6971bde351617a479d2a61e4672fca94ab26943b58012cca0265c0c5a660bf454feeb23dbe4344e279c4a80b4484a2fcab54b40a2b569e7b41d56536dbd4acd58cb1e92f13b20e4045cea924a518f2a63e2f7d9ff0cc474489e4b9a7c138578241436b1af2da075743f443d691adccda412468502cb506c44ba9370a2f48ed12ce12b3356b49c04418d3387e9a7601caf84f0a004ddf98fcdf6f543e8e92a3bbd190ab2fa9b8480ef71494c932f2ca9b5586415f2bfea2a9136d1c3bdf5554be1145d017324cf35abd08f864e7450dc742c4e190bfaf6973ba0fc430966201c12c8e4727748736aa42aea7b1646c7d6da9c50e3fc16a21c7f70af5d9feca99f335801ff3bd69d9a57e41637aede65a0ac4747dd27d5d4764b477a46d35876b15ae22a37c6c8abac50b9edd6e9f9faece2b679d4287e694c013377557ffa5d8a2d550c0cad51324e96c646b87f648d1dc13e74f0e7e366f044dba0add3e62e2fc92fd52b72b9ebb906bede3261304fef61d5831e5b45e6a07d0230ea128fdc56bcf9e4826e8ceb5bf6cf270399e53714e6440aa01ad78e3050db58372c29c517c700692bbd068ff9c6ba499da859ad1a76c631e06098c36dbe37809965390aca698393e53bfa9ce339f7896b86cc05da3286536946b78aa7847cb85860fb178c1a7e83fca518348c8b9d0c330aee72b6df499ef1aef74098541506cc68d8919d96932623f690ededd207124808b04fe81794d3700bf34a3ff5f9f4b5fd0207b5207ea8d7bf204dade50f0c2e4f121af8172a565878677db2ff6e2ad553446347681286c9052f2abea933eee8da1334892a9b8d370266b902482d730a652e9b6a41ea186c4e2820b0541a0f46af6b51fa10595776d3fb4dcd58417dca127ac833098b90a20c867875e7ac07cd62b93c5d59a7729c185c32e30c8d6626333c082dd8fd4ff2282c495d243ac7f70d4fe121b71685c1fe79fec55ba3f591ce37322ed5689cf9f0f044efc755cca53a868a79e9f747afc731046f7347605cd82ab21b489aa7f40b47d21c9ea9aee60f0fb8f9820f1609687de71b28e4ce74dab4349c2f2d2f37ea6c3e01b7b81a8ff31d9af2ca1ce29af6fd1e8c796efe463695c69a7d16cfc145b325b0c174c67f665a11066b0590ba318cfbb82a7a1d6815eae714243bff6658bd5160e799af0576de293fb8d5defa640ebf921834772d5956f0784ec1a992e0f121345f568ffe0e1396ac3f61ecdbd1adb30b18797be163481c98f8c2619df99bbbc292d32e500de16043e014e3f3191863f60eeeaaa13785f8d90698eb655d9d461c693834b23fcd4fcd68f06da38ad157ef017cc2dbd7a5a7dd2525d4fd117fe64232b4ea0ea2c3977a14f539cbc2abf6882b87c60dd92e1355b60b4167d33169eb35ac7b28bbb0a5b0752f0aaa5bcb94f2ec0fb52be041fa9333e795ba57ee5199b5e05be3c57beccaa87a0ce56f7caf675cef6264791745508e0a33cba3316ce05625766d7baea4f3c6b97ea057de2e982cf891755d76c1ee053cfd3dfc82fbe3a3bfef3b2f35b8edcf46c09f8081508d306ea73a07e27b0c8e84bf6bbb22f8371915f623eabbaf5446cb95b9de55c4fdf5693a8a7234879c419724973398515b194d07f9cea83ae7c0eb82d084c56bc083f86d53681c284b3b76390221de1d5e0c5571107265667cb3c75a41ca3cd5e9c1d26ac7444e920236a4c02e31bd78cca86d0a32476038f86f72265917182ca5c308d705980d7da73fce0db5fdf630223dece4fd93375ec0c6f88cbddbb21d9ed956bab08ab657ae12a24027699a7c6e85894c37ff1ab3e15f51cb793cfaceb56a36b5ae158f9a046857208ef65fb254a4489253fd8803024a7b30501a70e42f5fc214f9b7a175a144c3bbd6f2bad01f42ca0b95a6ed55e5374b1d495fc778c1fa1d14512ebe67e3e41f29611fb9dd29415d52579803ab96754dfcdeb86dc6bf3c140c02554a39d468e6d97733d6369368f1bba2c366060ed726178a86cc6f58d9ab481be2afd9190122f0dfd383c8f9be1f41f25ad553932a63c29f8b2d15f1ac3bb3fd0d3984f4cae06bfb42d345d99fb794e8cf0f823848c4f19a311ea068459b49f56104d40d0844e1a75690b078efc79a664e35dd5765250d71b4c793acb218a5904ca5ef77563775c73dd7c7c4d2f5a3d81fd899134ab10e2ccb6a9279d23a88f17200c1edd7035ec18f432fd47c639ce59d3f51bc74af7f8c0d2eafafc3dbf0fc6ce8532e185c824adc6620bf201a9f06a3a0c38f016e05c86d2a18c31aba180bae537d8ff6ab693213c3d92318e6f63c3ca0b4085eb3ff7dad86c8485d3c61522235bfc84743cce0ba36fe25743aef6ad30284bd1fbb9df629f83f6c475aa81147b39c56afcd14c484ca90833cdb7ca7161ed8a89fb98e5e4fbe40b0c322c3445c691700b1b18d1d67c0d3fd38c7b9f55a1e17cf956fa43b5af9ed5e9dc4ab5996099c1e775fb8eddddd3fe2058764f309d8b904b653e004027998a10f5105014e68f13bb6d2e587b7e9a944cf9f0d9f58a688393c6e0311887cf418cd4225383c8a44dd2a2b104f2f8f6e9d78e3e842bc049a8396a3aa767df82d6caf2d9d80c3d1a38df8c56edee39c2ec5a71428448a4f39b081acdb14d8345d6db71e57e191a77472d98181a069134459a0dd4c497434f67486f5ae9d8383cba478a95ace17911698128f73dc983022de8c40f58bc84214f392593103ec8aa42b9ddd34d6571b19c3deaf6bb7e1debcb3e1800329c3c3479af722834a0bbae56d622da87f2a0affe342b7e63121c446d41829770fd5b7a921fd3151c8ae4e08abf2a9dfbf75665d4062f33c3b96b633910be0469f1f530c1bcc8e26aa8c3de601c9ec743e24382b96f5847de6d4705c3aa675fe1a209e232518db906ac1755e989194d72e629d56be464b782f4477c2409e6ccc208c41a1764e07d2d65e5ce1cffe0cbd0f2b94a7cf144dbf083a25b61317771edae04074d249ee652dbb149b3dba84c0529680ffe7abc174d54332b31fae8961d88560182c8b17823c5ccd266c8c32dca92500532283066b2bfa59c102e264208e11ce5e2396ecbef076f3b4a5d9cabb05e18e3e6ff5ca5e05678a441cf7537871e54db5bb49a6ebde1799954edc2cb9207197a26c30e88a09f73ced46dc6232ae9ae5d4020bdb10f62cfd70bff5601ac49ab08d18f0b996c2a4341a4326f8be63f5da3962e14c1af772a157915e0975ebf3cc8b75497622cbe4e6d2d82229a267108b7d904041e0f950a67c031c397008522246917f99ce18378017601c78d4f00540314e89534b9ad2a9a90035050a68b517f7aaafeb9c07c36d8755a88b2247f2e8830aa4cdac0886f8476b505fc13156671a98804b976a5d17657f352f36076c77e837b92bb3549bea3943ab60a5d0684d44d502aa88d7e002a8f6620801e35a2624be9fcb209813db46b0d679f9ea269ca9973a4ac270b9956655ddc0968580fa4ef2d5ce68bc29fe7bd45d4d260f61f0a3c98461146e2d75be50064aefda738449961be332848a3175ed3a07c19c9cc6a7715a39b9abbbdcf6c3bb9162a9a87cafaf9128a91a3ccb72168e0bca2e5eb22160189493c6e84ab7dd9a6048f5c26331122e43a818b2ef9ab01e4103a5ca84025786b718c3f8e0a4111f384502f14d83bfdef4f67bcb04dd4fb7a3a6ef4f97628a8fa3adc85e3c3b8a15c1d1f1189475b0e27680b4ac41ec67d8132f8b946a28ad1616031175b10604a324bdc6faacab189ad0c9deab1f30a011ab525157cc2f3953468e8aad0e81eed4ade2a45153b0b512036f3adb03a5be3df227e2594f106f3b9718f50c48bd07adb783afdfd3eea07f7923fe9bd5ce721a05eb2432c7c53d64d8e27f2bdee2dd87c34c7e3d28329c433b95571740b2a4200db823e3e664bfa339a76fcc0e068252d12728aa390bc7a0d517ca018ecf31a5edc8acf7f61cc5dbb7f8684f05271b3033533e94e900a3508e4b8cbfc58a3fe905a885fc37318bc4e4ee4580538902298fc91309710b770820d11b238c4c05c788212abd964b3e38399fd9c0ffc1a4a0e9fb923c241cff442f1123191ae38df378aa94eb9fe659d2de91bd200f919309f0ecfb3a560ce14611454121de457f0ebe7a52dbc1c5b8ace8f900ff354959788d1dc500337bf66ffea10a72691ecb84215ed1c3b2a7d26212743cc8d55969a1ba000c0d6f5147d6bf5e31211433bb22da128f086b17018b7057919629ec833a655f40167d8b22fe96bedaa43b2818e8f69b20577afe15a62f691c7b5cb6976372645d45dbb05e88c0bc5ea026c94fa7ca384c2d7223431c3bd77f709b9b7fb64efb2d3fe67f4cfd2728c23170ae2e430578c6bfca7f58ae7002b7152a75514fdcfcf95c5ec60e18667feed6387df5e6975d8168cb4ed93769f65e7a13862882394a780eaaf625fe8ddb4db3155505e76252ce154be5070861a471ee646871aed1c1a0e0d3d60e00e01926202275b7243eeee34a0063f372cbff40a023e5693ef08516aac2a4c868470ca79194a0ab061e5ee257b3e99944466dddbd4bfe60b800ec977bcd2530f1762fd274a9dea137601ec1896cb34ab531cc60aa31725623f9c778ef6a37b6746b504a3ba386fc6571669110586c7227c6a9b88c7e7634da49d0a3c8640944016f795ba1c88ec1282285eb8cea660f1481520a74127e62a34c23fce2726de98dd52b86dfb37085782a1290141b63c6b4fbfa5f4eab0344f73a72e0710996e36dac6d515e9fddf99f6abff1c519a355c20699cc7a7a7d967575f9a2543f1878343d7c07291306a359b53f8e11483393bddb7d6b6959c1f5080d4b2a57a44b493bb1a71608b1f91bfc009733f0de75464e9f4ec1512da050e81c33e487549838fdec7ecb4d966b3242e3c50310bad6f56c530abd90758f87472cd89eb0189d1558b9abfde9d07ccfb73481b6cb12b779f8c14e2e9271c606e282dcec0edc7da11a530d07d64a0d4a8f86dc245213899c4f8a39a9fe17e358a497e207500fefd35f60256eb535ec1c8a4bbf62a630606b82eb79262469eb78d64ec06457aa2112aefc9422a4112b17a87b59490faee953a851e48abf67d93b64ca054b4185d7dc8c30f3245c48481aac8763d84c0d71ac143b130f7f40abf4c143e8da79dd0ceff237e34d6addada194d277daf1c3ce01a0dba40c541060f5213ae8f3c9084624e7dd84fcd57c93795e191190921c178ff59fe8cdeb2357eb07450e9a6613b468918775a00d74d9199aebb0e6e8205e1195d37ba6535e941d1c8166f8fbd77be75b3291524574f65ef9d29cb82ba64307341e9192fe1c5e0846caeb56d6ed93baada20dc862fa0bb6dc520ce1c7f447a4813385c36bf0df68e5b608fb797490191258a376e4e2410be16adfa09cc4e3e58318691b9ff2a710ace1a0c2df24ae2711259c07f1bdeef66194670a0a908c11c0590b07b23d539e7831626190ac550f23de4360e7fdab3ddf74ce43908e66653377e012637140455e20135b7e9a5d8184d6c16018952c7434d171d4c6e08c775e6625edec1263a6249ae5791fa15fd5400cfc7dd7368f805b15b045c4fbe79daf832db5e37180d99af537f76e951803f31deb4df71ec78dcdebcc08379346fa40beb52d1f2cb9e8834e7f37c4a2d20c13ee7d1f2bc4bcbd671f6615495cebb9abbfaf4b3ad384289f5019015f0c64ca6ee39651471d54c664a344f8ab9d5e6c65d8b6574263b08d09be542ae3a3fe6b2db6ea9ca29fe2c4d17073c94f5b6d0640153d13ec32b03c5671d00cad182774715ef3d1888701d481fcd537838805db8dc33f6334a717c1c5bb046f38fc46cd3c50eef06fc00c28badd67c8a5f326dc53975bb3db339298b516f83471047d52b17ae3d44e2a7ffd9a57be336f3cfb86d8c62c6d45f7ff866eb8a1d09d409396ac2fe0a6f894a6f7584b36ec9e2f3640cf2e292246ce9f0c11d2dce7bed514e82132446ec81717b0a3762e18b90f279e44934e48c5ec4fcc541abc696962a0f6bd2a450fe17f03bd2402c4f630f3d06c564f852a702b412c2136b45144c91d0fb7d6e70516680631750eb0430844e07b38dfc85317878819e93a354d20be85dfb6c738e909169fc9c3cd3ad4ab901a67c0434afe5bb3667f2fab27258e50c65c8702d01dd23a70aed7e3db35ce3bec5359bce3674870883bf2a0ab83e4be972ec0839c34eb67dbd7875539cdd323c6c29b8fca2ceaaee7e96a369d15b28da9e1d26c83a0632513c25a105e42722d183e99871e70c5cd933005dc223bcefb9ee928a75d7b17f58b75e8f1c811806336fac74319c361b34e37d8692e0dcac35525fa657d5f91c50e63610f0220a41f18ba33f1e5d1a7374a4db55f3609d0265e3694f0e0023012a57f84221d6f5f81488d8060fab0121f9037b7f96e44c69d5af5eab4fe67a6290d4248df89122101772b71de734a9965356ec045fe030f1b6ac8e6a9443b40e02e628553e52b61e2a52320829c2e4ecb00aff4d6e8b77dbd230ad37d9ccfb67225c574b685b13ffd5002bb3b1662ff94ea24253b35a6da039066a13d261dceb6c6a61d53e1fa46a7b327294117bb466429436fb69e456d943771878def5020f4435a0b7a221fa72fb486d6d745d50f9082c3f412d651effa4452494f03fb8fa4d590f6ff63f4827e0116ce2958daf8a438ae7313385fb82e8584ac21ed96f6df78dd2efdc7e60ab76c7204c2b84065580cd2dfd417fbc76c53ac7be56ae0f1737d002d351fb8a3b3318754b8b99eb40dcfc6e764c214e7866dc3ae5a148363073846e7e7859fa7b4fd1259b539a884b4e1c4f62336ea4b64522ab7f73b22a577eb010cb6b19248ef9e89e7211de3669a2bd7e506c366a83e5189113bc07a0fee30fbe8c2ef6e0024cdc511b04e4e797cc9d12628b7c2f38d9bd4319cd18b3727691bd88a1e2f10d1c243383c8c6d8f993875e2373a03feca896fba6dc1b6567a8f3a4d0c925ddaa47f23c35dcb0877889ddf8482638b38b8a8ad4b46204780955b4875fc1777190e0e96676d9c5fd84e9d9302465811557a15593e650a32969022d7a46b88a084788479942e3f0a9a96bd3dcae5cbb5c61de9eb9e18648ca235121e6be2615d2718c805841f98f45e100cdceb755970597748e0812d73e0e108b88c075c31340d66a649d2143af08be9054a93bb1aa9535e6c72a4866fb525d773f462c7a01d1d29e06a508d2cf95b4670f395b60ecaef83873d1aebd9b9d8a37d70d026946ea598ab95a98c108ca7ce213cdd99a1982266638fa6b82094c89358ff85cfb82e85853c0c69f8ab3b48d9d2f20a2d4f2ef551fd56fb4c5283653b4da74ea8875e2853edb92e3dd0617e94a2cba222eb26cc14dc78198b0d339039c0c19b8b5359134e78488500768dfcb506f051baea922ce90f9fdc0e2d77660e79528628f5ef2ddd574a66b5bae41bb350112f9eb94d0ac8dc093e3f5001fb4855bb17d6655173b7a51fa7e5cbb3931db63676b71cbe07e33e614763ce208f9f3f13108b9fa76bb1d9c7e2605ff9fd6f0ddf4030bfa0ef8f9d9e71ecb231db1cc4e1d6a78fbd4ba79758546c5d8d93d562848bb198c40d2546e1dbaa9530239afd6d098bd7bedb70cda837c11e7c1d585859ad4d9a6d888e7f12938f9019158ff35cba38a78bf82a4410c58baade9cfa865e8ca013ce7050d88f7b60c9d2b1e628372b3d5799c309d1c8f40d88a3eab3ab625657ab4a8c34c94ea8ac8d594addc295e0f72f7c8a95a92c49d2a8f674981f92e187341b41e4fbcbb35ebda19712fa9a9ec8737a8194fe6e5cbfc34dee03f40d33bd61f69e5c8fd3b8017c5d84bfe5c21848f52690fe87fc811d01f4cf01b83074adad8c14313f8fb709e75ada6728d4a5fffcc2da1587ea0e3bf5991d6627c216b86daadbd481cdeaa238332e002d68a19621ef8bfe4ff793bca9afb87d0844222b03d6f9744c4ecf76035ade76fd6c29e2fb6ecf06b028b2480d7d561cb9e69ed228cfbee710a32b0a35d01701b47896a66f3d8c4a0cd50173a5fe0f1c188dbe02defb898b15dc1ebb327eb29910a8e9bbca4e29f329cd4d0e684bb8d762aec270cd6916450c8933d499b00a17df78cefa50ce0049ba3d1395327baeba85a815a4bba75155335cd530eb8da63f136404878815df95dac398ad1eb4c4f7a0bd417024bcce3eceae007bc08000cdd11c9daaec36e45e621e7aca0159beb0c7a38635bdaaac2adc287240d7238f23f2c9322271047d6241955bab5bd1279f79b1ddfb6e31da1d3ba1639d54ec98e249a04ec5813774b1a303fea6cafac7dd89da308e5567935126c6acacedd499baef9acf59d6e8d42989e043b3a6e6703d0c4e779e992cf0b73cedc0df03851266c58fc6254d9c72bf710494949527ead37ab5531f2fe4338984bdc27d80848e77ca4eba2eab08a5603607ea52af0a6af4851528da9df391ea9dfe0c5087c50c1809ac8cc75ce6e426f5eeff7b4a38311cc4a024ce127fc1cd65e985fdc831e823ce1c25c9690e894ae28247076e786a5e8fff0cddc2dc07d869520f89be98293fa5e873199d9706239668b35afcf4120ac5e414abc17f12250a8a62e871be6f5838709daf755a1fb8446bb5842f664448980b65724009cf39d7f9a46408adfe31852600f901eb3f2a80fd210fe07202a2919521ed1566424589178e11a94430334fc4294bb49c03838225b58a9bae2933d1166462b5c26df1b10a54677bd0adf4227b91d4ae7d4108b26e7514360e91c6fea88dcacc7112d4824bdb53114b6e47b48ad6b5accf40195e292869bf68bcca3f37e776e21d60d3a279b9e9531b156ddf6169af4b17c6c71c8001a7d9a2097075bec66556b3c774307bcbddaba3cc8f6283b5ce4af8f3a7ebbc5fba210d2e9f02ff4ceded1e73b857db2e5ef8afaf09601efa3937eb2ad7ffb5cecafaf231e3443d3a002acf56a1dcd186d212a7e0edb80e8b84059e3b9fc5681e1dc74c006fb3404e3fe9cb293a377b63ce083ee272188f7e89d42274785fa4e4c7b8178fc7a48c49a51fa3243d8b17c0e00d8bb37f0a04af58bd75cefcd6921634867bad7f85e6efe2a3f26bcb2bbac638f51613554d89dd5068f40ffafb98592e1391eaf2c8738e9ce1dfd2dfe342e001de819ae487cabd08f0ebe43af37c4e4c52aaa7f30e013b189116f3a130594c26c27cbe30cbf9d1b183519e891d7dedf6c7bfc2f94c1a00d121001d86932ef74cf4fb657e4e78022d610e0c64611befcbaa9dac9daecbda51b82da8d1df690517356cdf4f6776bc82aeee2a78929e5916588c901b968ab25be9e264c999e18e5d9f9c068088130e665d376ea3123463cfd848e16fed4c94e1daa98665406a19e42f51cf5578747cd266d9e4d62fddceded192ec2887640d58c3d97961912b2f63125aaa165ccf25e9a46b9d97321e4531f0a4fac7e406e53e67717b56517a40440b1cc8dde9214b9a520d328d52375eb7fe147f8763c8368c514db0f316aa01e28df69f5faf9a5cd1e825f3378a15b54d4952a21ee8d2e2ae36c91bddd89cfaa33fca9f2c00cb530aebfacaf30a6119300faee71584ef9d9a015822610d7b8eeb02e353ae06b770f366ae29610f5d9826dec7d5017e0a7ab9cb98902c753c39cce426519a1aeb34900ac087ae599075b18c5f58da80d9da0dc1b556e63ac8c882a1e3981e9b01cda94da3ce782029b91b11f14f1931ed0b5e9740faee3e4d7e3e13ed212e3bf46650ab24e868cef00d17e70985ea020f129f38b855f5728c0a1e2a4918dd894eb8647ecc4ca2ec0f278f88969f13779e4332a8847307d63a98c1f63ca1e33a1da0e5d6ce68d85e883f762ed79a35515a14961e9b3811d5bda7d8ac1f6f3e611f654d346a2a270f8bb070b67089cc7830215c35610cf1639495b911af137d2963d68ee2f2d812e311ebdcacf9f20e47afe4ff457bceb9ae2aa703b1e4e6a48803bdebca6e472e10c60bd0e506c377c44480b0a3d078fa1ec3f1fe6e415bffafe2d553d2fc6430ed2f01d8ed7f1f06a7fe7c1b978c6985f46babfa050fe2e777fd1ab3adb290327305f66387b75de6128f5f1d064804c91cbb7350db435b9f46e94013c7e75df863f38e622e9f022eb08321b384df73ab6e8148bfe4aeaadae57c4a1c1acb755c9512ca5bc8aa5a540095a08aa19b6744f559adaba011329630e4ee7a4ac51a822177454906761524f6f80a6a291311292ebc10abe85b3d6f76f5ccaf4a50bedb8b15eb79ad8327be2a67ac8bcf5f01d209d016136edd2c21f7476a09108ed46e9162e9cf5408fd74e40ea94480c7fb41d496db5642a92eddf87d361345dbf537fd2c65e73fc7c8c5e7d32a7faec955e6c15ca3d8f87ac3e445aa6fdacda1480c9d9ea52c3380a07bf07d7955f3b0f642f83d2369e7f430d9b094dbecd7325d71f743a25b44acce6340896ce5f588710ab00c1c8bbe7f7c33786d71e3a477b81fd0d06ed7c75985077ab16641e3da6634428f16d28f9cbba0c252fd77e371c7c8cb5a751fafddfcb8ad3c3deddc22a476cb342694d295d731b080354cf6c66986d73ab1657b1e718a0cfee71a94ecaf87916a3838cc84f2fe9613b5802b8df396f4f45a8120204217b8f51e6eb4d0f9d88780258975508c6793bf7d579317be7af04b3959c5686cffb4b4a8dccb09746255cf9ae02cc79e0d619c3059328009c5672d9461e7972773f8b88b12f816b59df8ca6aa43726d88e69ef77fdb94afbed2200cc242347bfdd441ccb359775ec9b2f0e2f8d1c861bdc4096f3668c85b0dbc61a37773b25a5f35579b471b8c55cc3b65df1a8bdc56d25b68661ca8cbf70a3d1c56a04704d85b7a8c43401da654204fd1bbd89c466aaa8fbed3648a126fe03c65d13ccfd511b039d295a437e5e0dc9468858706e66c79840beec466f6d5dc108a43e277ce5cf7a4f9c9b0f3bdcc6abebf36d818c439e1196ebb090c5e3fa3d1dd4a589078d800b64e3acad56010d573a1a7c3368e4cbe698f83a4507401a60f2fdeb6bddb4e6e5db0709c9a12a2b4d23e74e6a0a2ff60113367d3b3ff6d7144731b32200ea8b2061c140e1643308df6230317a966c3478b9e8f2b6790fd9f4cba7bbf0ba54c94afa0e67c1c4a850356d46a5cc11ea6754148294d6198f62d3341c19d05c76ea93a05a7979d9a8ac156f336b82851970cef364d59418ac9d1fd8a2efb94dfba3f38e7eeffb66a4e42684c305c02a3ab1289ba6aaf4ecd2cec5cd0c11788ff603b0e671964113d7d799233805c3b923ae8e0126eddee30a5fd8a6d17fef0638f76f74fecc83948fbb172948428bd095489090beb0653663c0bcb3ba12e0d2c4a377e8b6bfed7507017f4a06b75ea8fa16e7cdcb2bce65b8c5866ecf2c26b39b739bda90b336976bc6b161aee454c9f81f797557df9e7f1617ec013e26068e6caeb4531fac03149b00058f25f9ea8e5286d61c4a2abf9d9a9e3e9d75d689b28ba2a685e22f9316e1825fcfdd65dc18aa1c8168cf8c768bd7fc8e9bc5eaf048e65901684d2a21cafc0754dfd6b424d9aa22b1a007a5a4c005981efdcfdf63c548c2e278444f5d374aa6eefdebac83d432ffcf889b2ca915b778831a228e8aefab2e290a703a1a520d712aed314b0fcea04ca1109e8ea658b8509edc2705331c6b08e00a6d7205b103b13dce0164616aced4855ae8a85b80b6ce8c0c578a2971575df46d74f97d84b73257d9cd7d86b40b8669100ae3c2e9f2d870b7ecaa97d6408cd7ea5247c7696690873b6a197f65e0be36d957876340031103bd7f1ac1ca16b03a830027118797dc21b857171b256196c4453b868748da954a3adfc567e1e0ba8af9b17e18d6efbfbade49f7abb1a750a3a95bbf3776c320fc72ef0a45404a62fad6256a6191ae962d3591a1fae137b131b96bd3b4408e569bb31b1c23afcb3310ab7dd54861c46203ded24ec2813367f2ae8ee49df398f458de1d2f54ce42845fb3b266cb157aef5e62dd01269dfad2b2bcfd996af4340247facab6be1c01fe3024ec2924e1ebdfb8da8379caad051e2001e496b057979b4d5cd7fb6c3f67c0e04fff2cc3264d31d00e61e76491941b76a6038ee0fe35b237911bcc7a72dfe1bfee31588ff3ef8a9ac6e4aaa057e4a5750aabc7817d42a9b6b055f5e2a11b90c15f4362d5912843249bb6ec66fd418982e8ef99054880f62f4939965326fad9473bf8906552935bcda7c84a6c8d6ed5ef6e35bd2a2ab58598432d1f89ab379db3a6fa6938a8d300a792b8b7c5e3efc6f249ac4d9a5f1183b6e73b5b1328324d8288bd64356d283d01d3b2874381f262b921d1ffd1311ed31233701e936aa0e4dfbd98966ba4a6bae6bd00d77635667162606ded1ce8c1fc59b51aa6c78a7af8006c62946cc9cf8e6f511ddd1c7a264e1067b97faa692948139bc0b64e3ca3728c4dd8965e4c71f4ffc2991bda2bf397fdd3acfa57c531214edee60d2737e41afc3f2ae2ae76b297cd6e458baf4571d7d5b9a4cc92187fb6082ec5e1b391aebba7aa1f2c468cbc17dbc50c3aaf30c5c2832364ba85603bf354065279d95f499f1a62e817b3df590f67820a434fdf933d2c51d07e2afca2adff1a79a58b25964e7b2a4cda22b4d4cd41e36fe5d7757dbec1bb4d61a12b009b822f645f2afa045a19f6d84793b6348bd334cd692e379092b47d873e8f825bd0ebeaef84d21c49243044845b815e1dc0cf22005973fc278a16f3549f2753d072d8928aaf0ada2d208d1237e79955e24569fedcc314b8b195d9648a4eac1e5cfc75e9d1b9fc95fb7490aa546d59ad2081f9898107d91b9a23070d5c581d880ce270851265411f3e68d570e5eee079e2142a77771cf9b83605fc5a927d1b7cc588fd5e3d19e4604b8e66c1314fba589f69688830d3b6100f5249ad77be426ddc2baafc38af2f7bba3ee961e006a0e650ca32f41a298e15811d50a792ee254d929249a1e82735d18d83bc8373ff08d689fc865c5d04923765ee0b24128f9d3ba0818f768a81c027c9b9b410224aeb1e80319d39c977766ec1474142b78c4abb2ce28fa43b0fd0b32de896660d675d2b96cf2872d639eb32780d93457e812b107b881886a6af0c33a026da59f3b2e865b77bfab91a8d0e5ea19811c0522b3a541432406bb1cc8581464878856fd2dfe4670bb87a65c69aa8ddfca22efa8ace1a7c2fb9ce38379d148ac01b4e6ca46901d05f2e223ed6c7379a6c5eee22955a1b2ec2c9355cf83119c3e134ff5d73c68f8a17ab1b4d7e3ce05c5e9013d46ecde87c147c26397db1860b469d26fc50194a0b9ac4201e182caa7cad8d368ca836bf0effec147d90b71e5c9ed792221a314a41ef2e2bc643aff590a72add06d7e2886cf33678b5397f06189592a2efe4a276e5189af03aade3860828e5b229a683ae790492c02f233f7114148c262d65f31013b03df1d26d551e503ed85e7ace152bcb9376d0f8ecd8d9998f18ca12defb2dd788d8625f150ed04928c5a0c60e70eec97a21eaf25854fb951d1ba048de67c010ed8c5238ba5a283098aca3cea9ba26f19d64f7dabd5b2d73fbc09a850eb151ed8bc2cce53e4c7412d3409b7054b0b1089bb7f4ee6e77295979afb4641eac2c8bcb5b1280ee4f3c4b444486b5e7cb1d7fecc4d85b4977ac36a048a2087fcb222cedc30ce4670fae359ffa73489333d14c19fdacacb6ddd354565c1c0838f083122de3ea3dd197ee6e73ed8b434d08cf1f02ba18caf8d7f5e5cb48781a62d7709302c008a9264c0f38cd4e8b13edbb309956a4359acb760e88a273a90e1005771fdb95faddcd0f5014ebe1d24ea10b496db9e47049c6b27515a83af9bfab7b5e3654c12e56cd6d980064ad451b9f15178ae58e33853d30b64b4570dd40c9917f221629f37ee74f2209e8113e2e26fbd4625560b6474400e6c32ff8d0d17ea3316aef39214dbb8bcb889af231deb24ff30d24bf5d0b82db539c3c119ee62b0ab73a556530a56f4b16282483d5398701b8f412ae1dbd26dd31bf7d5469ab1a921af36dc50d0aa7227dbeaaf98f20c07f6cd418f16a5b54b80f5a49f4030eb1b73e23d25bcc9b4e080599ca8a6715baae9a3bdaa5316400ae94dfb64ba208b7c89901443431d26482c53609ca0bfcda658a6cd2bef2e4e410f9f24bf72fbe8e7ca2c79d9060cc309c2183310bdfd865de372b42c1212b464149c010852a09e0293ac87ba3e5c0b1618c0eb28b26ac39fc113e15d96b00286390605c916f62d86a6aecb06f7c75fbc34c2ef37f487a477839308e5b17f3ed40ad067ede8f5b7b087eb51cc562d685ce5a0abc296585700ad72760936840dc06d5a08c6f29bf5854b6faf258d999543477640d3ed2d93c23742689ed77c3a4fcd610e532681a7265b84a1037bc0d1a3994a360fafbf762b398e28f6d814965fdfe149fecec53c931e53917367e4b8cc4a138841301fc6e7de10a88315740a037c93f0de017d25a825777e4a609686f83c27c5b12a72e06e7688457095807f85a48f7779c748f316b73aa7db4a809d668ba3e5a34373b17cc45c39be8ac017631851557f83cc6da7fd4391cfdb2e7b783e38454f7b7efb6582fc7c66d6d6d1b9c5f14c217c92298c88d9e723c2ab267500ad1e74843dca3164402f9148db5bc97dd12a7d8861a36e45410baee33addfb80c8c1474f86c6bd700570b8409c9f746c24e00877c27578b676421e1ac6de157ae16389ed64d54cd248f4e29e28d799fe5c1a53b1a31edaa70b2ec309eca189dee2cc1656352689446b466dc85c7e14fec59365f4dcaea83f4c0db1f107a4ed52ccc44cfb9485d16a53be8945a0df91370dd2bf42e0ff250c25277f4d95b41d854630558c113d1397cb6498ba9250924c7c730ed03b69496f7baf2619addc0caf4e94f15da03455604d34c94376d8ad797a65b043c607d7bbc4a678e2daf47cbe9581970e0d32c4179175bc298f30ba87643025f8847c81bc5461e024423d4a30af10722ed0d1c02084bc9348894fdfcd2fd3c23fc77609f5bad59f2bf393c016bebaeb1297656ef6396374cb80642d38a78cf6c3da32d0dcef53d177d314ae451e95457f3bcf6f99026ce2a148e3af64966992567fe11d3cba58908500ec1149d5be2e5e51fc8bf3b35aabc068cdc28035352cea3e80058ab78cf86cf795680c656b22542d484f9b834a769c60846ecf95be93604ecb43e77ca9b34b15dcef8f7f8cc9b123e06efa6a7e427e1b66d52c4d6ab9bb5cc59dc720fd9968ec602513ac49785e288576e13c77b0a85e983a9c4e3824a97e1d0ad9fe73f94ee5355f0281237bc8f8702b2097e6cbcb5d7fb280f6db572ee465884fe74d7e60971a5b9fa972","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
