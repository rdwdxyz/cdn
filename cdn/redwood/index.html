<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"952c112cb3d28a8c3ce8b6050831eaac31aa313d656134e65761d842e2ffc24204ac056c6aacb7ed6a01533aed8520404cba61f98d8f7cd331c46f3cf2dae570fd7028216607af92a5b9708bfab2886685d81200f4184b257d5f4273fb433733a34c2228e699037fc180d2f43f150795aada51f4204f431b5173ea35c5246d0e45b6c8c5035ad00077c274ac13f5cb459863c5ad0b7dcd8d671a3f6d286264115ceb760a6906a6e6864ed6c9b029fa14325cb7b0cf2a281607cdb492da7219cbda03b3780e1a40268fb221a591e93f12ce2fa50d1b752fc56d2fc67197863244ad82390af7f2de44f839684a277b00a590691057e3d99ab82a8f7d44753f390f28e61be20cc0974bcd22cbcf2d1b9d1c69e3bf4a1a7f06f20a79dd8db9c31c9e7b0c992ee6db8b3fb72ee6ee787827d8a4fe1c6852ed3cb4b532b244d4eabbc301df306505440133c31155fbf39984e93dca6cde3235b7979b95f4d2ff9c06e26061b4046a3abd44384369dc99b127e038ddacbac3e92239f04ddaacc521dffc5aaac2ac206f92492a1097cf24bb4a081aded5abbbd2918dd19777a9e9ad0c3e3248b9dc0712ffe151a8bb6159597f538dab70cc3cc1f12012825c099ed6145c2af0d06fafa1ef26c8697899a99236b6cb45e156a90620d410019828ba82117fcf668f0a31dfd516855ba54fb786d6a1a679d3b0d86c52d3b17ff01f27c52244e0d908fa5b5ce4d740a9a25bc120c43d36adafd4a4845c994f42a385e789592c889fa225495c0f657464135f3c2aa272c3bc840130347201c725968dc5a72adf70167f89dbca936a4e1f78a37215d309f76eaef90135369141ad2da70e605be791eb8dd9c06d48cfe9aa5b0da772fb00c7802385740e0f4f7995d3e0d151467a1e523eff52acf9813a58690ef6b08000fa53f29dd9fc9ae72c3b68646bd702634899d039968ed3477fb32a23037771f312a3af9f8defda0f34b702745001f6f9c3e12e48e6371b3377465097ad56c2771a9d80743375dd801aec354c4a4f2e4175f3e4e2e8a60314ffeb50fd91c4a8adbb00685eec2ca066bd31427bdc51c977de5971e0bd61d118c80010284e77e2fd83d2a9178737eafb8a47bcecf899ba4d381322c5137ee2ffb064c4f0a617630ef13962085b3fa18fd4f6b44e89e0b31272c9d012fcb4d35fc5887fadf09ee04e5c68a6ddaf48cc55171b4478f30191340c17061879944111284a0b497692aba26d5d2a8a888b4a82aa07fd774e1a37466281a9e3a65a08501d2523d7342ca51bec596da6d0de1e9680fe9478e0e243086f0f65ed99e5cbad21f0d4a76c40e1eb0e0a091ab4c8c4291d18201e4e6e25ed9fdaa3d59a524bb1b94d924a09d79778c01205d847a20086a501faf21e05bf998ed4fe368b21346ced13a2378eae45ed3534a1d9da167b14a2458269784bdedc04c9a1b3513fad67b0d7f0776958c510d7914c2a16755641021b5504b89bd9d9971090cd498c381b1beb2191666d1d5ddd9cd160633146b2c91fc85b5fff76a8eee9ac7240611d86a1d48ed51e75d866eb79d5aaba84236007378fc4b6961516bcd9d7a6d4e578bc63a5e5a0b1c35f2778d5945f3d37a6b23432901b6928830123a01e785e4a495916c3ebbd769eee98002f5c9da5020f9fbf3fce57107895ed9bc4f2fe28523b83400a9829fd54dad0bbd62a3d48f5aa3c3a69f0f8c48b83f9e4c979d14a809b15bb30674b52a3ecf22c70b5daeb584e8fefe635041406dfadb32ca02a05ae97ef363e4fe88e98d14e0872bec519db4c5f917d37e0512cda14d72135fb9258f8138fba3f0cd457104c8ad337f9815b15e080e8810a1bddb303daebc178f631dde1fca834e325946a34451d180f7276ecd5ffbf7a9f14cda57fa87d3189102601fa0f978a111b0bc5b643b796658b45eba50357aff22ccadccc8a4841069a346dca9d0729048e6e8203a5fb7b83e421a6552ca8ad4368b0df8826ff2d3700c65034543e9f70a0e70e5fe2ca740c7c4efe984c099eac3b7ccbe4df38991b01eeeeb501a59f836e3e1e5fef782e4dc8686143298bff6d0dc37cf6b17e731a01b3680cbc1e6c1e3532a7a7d2cab4e91e69567a5834fc3fdb9a203436e067dfbb9cceb48250b6a0b4fcabd687f61f37749769571d8b0c892bd57a0081ca47c168fe4581e8ccc3b4a5044cfd1e47f44fc2746dfbe97eb4f567357d64248e90f7271dba413cda28e0f81178bbafee442d0cfd0d551a8460c6e97d294e7722eeab21234b0c59c052ff7f12034112e2dd911ba1ebd518901cb5c0e1105887a2692d9c9f9545c6b87e0710181dac83033417eb72eb100f24b6157668ab8bb44e11453dcdca2586f89f7bfb8f8c39b448f0cabc6a5a30f7cfa6e5be672bcdcd648c6d9c914c15464bd6cc8bb02df3382aef69c3b083387702c1060bd1f7eb877d10f4544ad1dcbc665ce630f650e302da664aa8a590cb239af4d75fe29081c10518af72d18f91c55a4204faabfc6070d7c9eb742b111dc6538c396eb4facbddcf5beda57ca56a366de55f16eab7a25bbb3bc00beffb1649e0d9428b96113b66b2b62aca81c587fef69122ab6b6a150b615207a9a67ccc17c1c02799369722e08b55596469b1c43a60097f3510eb1e97a5f38c960739076fb8e5bb5bdf2f98cd2fdf69897e475df87f6ebffd3e8919f34520391ddae678bfa99de576a2ffca03033d2ce44eacfe3fcd3c983b2b1c388467f9824b30985b2d05b211ca07c0f0ed71ea097b6208bed191597b995edea83cc8de13d28325a7512693b3cfacadc110611f1940e7056c254d2c7ec764aa51d3910515a8a641ae6318d3063325725a51f196c82817ab3f72412ce6713c19c9ca8dfdc3b5ef7c103a46fe4efb87aa6ba2ea01043af32943fa026fe87d25fa4eb68676963d2e5c4314bf88697f953707ee61f1b95cc2dfa4bc23ab60245928ae81ba561992e5073f3215faff7ef97bf303650a6a4f38cea9dddce0392b5753f74ecb8d5819a8c79413bd09fd6e544a710664c5cf08d2073b971474f20be3fe47f06454ba623e9c637e6201049f1124bda69e22e207a1fc3137d8bd3ba68327e86e7e8b2d916c59c5600de51de2972ad50da9d9db0a281d8a99981bdc56ed7dcf69f4c4c1937032dfe73115a2cc42592e788f3c26c8aefc1eadb0e01b153a6ca31512a1b38405273b038738d4fd84dc63b0b249d878cbc2a682f5b2fb32c8f2b816c0c8353fedce57acb304f9236fb1d21376734f32044ff81c8c717311d7009a7c85e843d756af941adc4593965d9b5c7dfe8e9c956153558c45f4999139f040c3946bf666437850b52a9095f3bfa75fb33085c6ab7bb11a8247592e8244287aa88f91b57532d06c13533994fc72410f4bbb67be4cdd6d6a7989a095360bb18d8f354a05de2a0d92fcee86a1017e96e44dc4987d06ba10de9337655b239218f93b725608147e55f9b87e55b73f88b83c4fc39b123d422f45ad9904f22c8a49feadf5965a52969732e7acad58385399aa1615df3cb1e0629065bec37004840ccd0eb52af24984669a1069906ca82a9c73050ccc1796c3e3944bcca05e724a9ea62ff268d4bf87ab82fae8060fad3bb28a5a44a9fe7935488335ad3b71893925f5e0280785451b9c3aa6cac1e69913949e6715f4a539c13164e6ec7bb29a212d35777e43fa2495ecd180cb58c2da69351c9e0f30fae8900670489699a70a037bff3d5d1f20b25574c8a7e46b68cade281fb7081e4dca59cac70401a0e9ada1a5d4171605a15fc933d133216ac4ecb48edae9fb8bb1660bdcac9f8ac115f7b5051d892ad4e73358774b37a98cf8ed9ab29fbe73c36f042243b7beeb3f4b144d1f765a45c705881ce2aab264711f8c4d55e1933ed19897a32fc9946e067d1b1dced94f646d7ff30cb382ca018a125417df6d9e114b8e2e0f5cdcab255542a051b6b2c9b0fd8e5f0b0f5a5c23aa682061dfda2f110d2670274453659ca4142ceb27ba20ab12d7922d11382d9a5b22b6e09c826304a5f5fc8864ae6c1de7dd9e1f93c63d69b9e4745a5c5de84fcdea0e793aabf9ee1a09c7d2ab7e5893a8ed22cfdf33563c523723046e7e1e04c5a05bb7cb833a8af07ab7985f17f0b544ef83ba220bcf0bac8e3737dbbaa9bbe565d75b150d920410a5cfec91948ad6e4a9b5a5d66dc42450f4f3d2edffb9fa12e377cd4cab1e4fe9db681d2d191b1a19aa8125d31cfe1f4f2a062919a40ca1078eac33e27b48916cf269db8a837a22e7986f5ad3ddfc28e1b048dd95e5489a0e0b84a3abe2b2e418b15440755bf8f5d8b531748b10bf6328bf073148657598acaf8bb6c38e6a02a51be85db1ec2380b2ec9f6d09bc9fdbcc29d458f94991c3b8ee897a157a9e2fd5da154437a71c2be622c6fd3df8051c9cc279c928df2113a8e03c3255e20e5e586dfb2372a349c4e0e79d3710838ed356caddc6c233a3e0a0adad28513625f3cb27b885fa5913b1070ceee03bd0cd2969b2e30382cb419aea82dfd69737bcee1b1f2c1527f4de90f6071251664aae66e60f2a174ef6588acdfe9d41282fa35e64ad905d34abd6e20f40ed361d45309c96a8df8ece4e38c82073a247f6bb978a626c8c48240fa1f6a245e2604795b3df0ce195f5615eb485a300f23c6d96449a891812d92cf25ad9093d541668d973d7254af62244284fc8e9b66c04f487afa4ed44ddbd71cf3d62378bd3bd485a0d8f403173f3145cd7c043015da66cf023dfc81edac16ded88512789d5a1f7903f40277e4e849f8e72dba1a36b7fefcb6595a046eb8aad2b2e698f260dbbcf79f7b78ffb0b5c8e3b82c3441de98a824ca82900612b7716223160c1662332cbad08faad9cf9462615cae6c84a8f77d488dd120785cb9ff242b5d53c9af20dbbcb66d224701a5888fd7f677b59b525429cff1e0310d2795a9b6c1067a6925112b840b8995ecb809a470e66d13592eafcacd81fe6465c6fbe6a6e432eb1170b014f07b6aed477e52b0b2046986fd4e6db8d4191eb71168a97e578316725947823e42d6e722d5113bbcb54ef13d96a6e8dd8fecba56e3bcd6d1fe985d4ba0423ded89c90a4470736b4324d3df57d58a1f4110778c1ba9200a5d2ac0438644a3e261d05db8520297bb93abb9acd3dfe9ab752aa42f9ff1d7965fcb609c06fbb2bd43b52257ffd64873bee53ff163ffef94924f436da00b0b4231874e30a530365a34cec4019c137e4d5b4ff2ed408212a9d8c3bd3d4fa6d1badde256dfffbcdacefc1e02758f43272ce9128ae62f5651391ec259fdb2709b3187c37acd0668e14d3688cab7d06798e2a79fe6abadcaed202922ca97a1bc1e200ff6748539bc8a5029a7f7ca3ef46c98ef73005cec5da97b75827c461abc26cd60ccbfbb878368034029be01c263e8658b9386b084204f53ae7407116f9cb6d845ab3694fbc8e0ea3b4e606060cae32687936fbadc97647b99909a46135f26b1689258343f892d75b4c6aa754100c7633effbfb9f63216bf6fdb6dc38455931976f7a508cf1ed3318b98c0c2ead950e2a2db703b76fac1d07bee37645240425eb07cdd2743da78e5a751dd6b2806b8198ba0ea37bbaea464e35f794289d4ac4e3a5e1d7bfd70c6fe68fdbeb0e169a46175938e97b81cbe4914e0f415bbf2907548f8c6eb00828a7ecdff717d0c493c1477acf6ea435a5dddf2ab8b65be94e32e5416b595b1d048e02521abef10811f57a17856271b97c76eb2f0b0a699b9c284388028f5fab2d151cd3381ea01cf87cd98385a0bdcef569ad942f7f243ed4bbc4599fab301a7f2a27f877d5234c69532555c9653fdc1c925fa5f101352e1111ff70d51da0201381ca077e75ceec2c6532b8883d95f4f5c23381cea72f4075141a45277e128684302b5a807182b5c3e820bf069ecf33fc9af830071e5b8f6c28eaeda147366009b3a8e30c32f301ab5e399e9baa3ead48dc25fa4507beea276533ef5e0ff67a0b59c8da0f7bf7b8ad8e3c83456a18228d8a2a337240f3835e5295803509af31e5f28395bd74c85d62f1b8ec102801cffcbbb6f3cd1fde873a2dbfd3df88a2a4e19f05d2e30e319137d81d0f3d3a3f7133b97bea251bb30d8b63a2eaae30a028fb6f1682462a0a42be4ad063fd71640cc3d88403d81f1b3a558edfd4a115e0fb286fbfab6aa20ccf5344015808e11ede64a3819b7262e8b1a64fffc3706fa8a905909c95580239518cee9bd1a2ea269e612db6eaafd3196ce6777383264867b253eef4bd412cf9574322925aaf35ee8abe7d753aba986afb95f2485811336387efe93449a497debc5d081bbaf13ae74a4fed81f3baf6fc784de0eb155b2eefc3cdc0292c5d486f0690f54e57cdc7f4f2c7b2c00fbe9ae25a2884f2daa4ee8d9d441484ab6d78707d78fbd7dbdc85b5f41d5619a15ea25f5fe313e9882b47a547f87cae380f28fc51906cb2eeef33a42c77940ef504816d3fe9e6bd1d6803286722dff9946bc590df2f595f773483f7521a47af49d369569b200f7fa96d2e1f451724c9bf85e2208482fa0d9c40bc7b280d2966de9a5fafb425eba659c6c5f7b0d00fb61db6cd6a48f015ad671797e8284cbba68dbccb16dc8a157e9a0f16bff04da606abcfe2aae2dea76e4719318117ae74f14798d71f262bfff1a97bddd5998ce288f64ca728f4c92ef4750a803455ebedb4adf1dc276ee6b4f75a545aec5546db492c719c3471467dc484e94cd9fbd73c3b95cd77720e604b190c8d1ca6c0e919fcda48e23ec0d0c02f178ed4a8083a7ff80e775e030f62ee63cd9252ccd56f7ad660688c6dd960d404576edb0da8a9ba83368322650996bc6d3abe3c68be10a506d7c2ad8cf14a99e850d692f4eed1fe0ab8c608b902824090d20e3062c67f537dbe56cedc8601bec584c16ba20461a1771c27a7ce6564d7762336b6d60f69ea1bf89f03b3f59f30bff2e5115051bd263949495ed6bfd86817e75a3dc6a44b0826af38ef8df12cd296191c909fea46f03e1bb40c5c1436f0451fa368f5b0ca9e803c446f14bb8de5b27c17f892c49a46428c43f9e50cc2632ab50fb2a09d2955e3f07a3cd6fa35a1f12d6225ba94a5df4357ef485c5b44acd83e0570e8b3b4dcf8e4c79d4be67b33b8bf5c994383a3c011247c511fb8db307d16f67ad9108003cf2891c058b415188e2552046c73cbe656ce9259442152e926c15565767a5216d0ce34312e65977e6383e563ef0d6ac689676f08767c1ef08a0856fd4c38a704e4a73bac948630260f73e6a3c7963dadcb156450c8556564d6aa0ab56211a5d457574afffc637b7c6dac7f37a6cf86bea50e64dc50077f4579c08cfe79145f34f8a074501aadef34c487c4ae3fe047b9761405e6060692087cc0521a9e8374fbf526fb7138af021e53c06da6c60b7dc4faa4c7c68373983a6e90d3a2eb2c677bff7d9fd831c773a002f1205d1a7fa21949151beb04a365abb549c13ce4209c6314d082a96c3ded67132cecc5c9c8ae85a99a7e506e60c8293f1fbf83094a923e55488f1d9bbb037a776bfde16ea6da3fc31c556cfa93059d08baa90b09f24651a74114d6c5385afbd005522390abe2d9bd9cc2a90cfb74b86a4edbe53c75924a9a44af961883a490b4504d641d5a3a8df8c4a9a6cbd1090e43204e5a7168cba0176e43285d1240d0104d7af825c24ea91cc6839956ddff5d88674c14c31c275144f993b2ea3bba573dd729cf63b32f4edc1fe89416eca66277a656897604891aa3b1a34cc0620e6120b50cf0f584a988aa3e1eae77725868fe4d970acc9b0b19e875181dd8c70424f08b04c96468dd2ad317af029e2fcfaca8c3074f454a9e3e54efe7ee51611be0b8ad5b8f2067dce886a719fdf6e271498e4bec2beaa434503ad8b68a588bd69bc1b40faf9b67dfba352144875a87250c044cae15e79fea833b120ab2ce4a925ec8d62f8a1b9ae9576d613e145cb1bf3e4490a6fabc5cb1c0c32527b56cc0704a50aebf9abc6e10d985a07cff8c63582cf8c47f443198b581fbb8568f3f4f0885c6dc0ff3354c26f6ba7efda44beb550a8e75a52fce296d1d015bb296523e3f8907d9372567aea4a6cba31e171c856d0ca893cbdaede670fb62fc422c34706af0eb265226b68644b83eccd6ea25d2231f4488a8dba29ac6d7ada9861d764d8b6fc11f4a5e54986e9c0d3f52aec78ef3a005d8b5edc582653c88df75958a40cfa89982a926812d8f5ad1e8bc56d9169f7d0189bb018ebdbbee54aec81ea7a8dc486ecace401cfdb68bf913be3b24662b106f771b6c637c238038e9157bc356570f8e0ef52c6c2a54bc2915df9a0e5fd275bb6cf5333b8c7f24bb71831c9675fbf38d03dbcc5a6eda42d5653fd71843c46625ec927c13a5e7edd246bb51119b1fc26f002bfb1b739314f35a3522fe00d35006e0ca1d19f3e982785562e546146bb3c73b3ba595e25522dcc4282a8f8e9e0f09a0e11ce35f3e357d7f53e9b9ee69edea64f7340a64e7e000a77d88d86c0a336588b34906e2a87ad75b5d31960398f301e5f83c82b4048b0251d11726469153db3e46a8d6c4ced1384451f9e850695c845a0849bd409c4bb66cc215acb0a976d56ecc0791f9014e7692fc50cf31c55ef7e17275ce14aaa92fba040885f9aabcea09bb8ecf44837261a74ebe0bbf7da46a724148e08610496b4abb416e947816472e3ebfb182f0188d9d7d72781a55eadb0df56a84d1ee178c42b97b4e873e95199d52430f5630924b498e2c4f5c04baf0d66d6673653faf6c61eeb4501c9689dee223247bff977a03a1d360a2b32eeeb9f16aaeecae6567cc139b9bb5c9298ecbc05cbce087aa0a916b413a61cc5ec1ce83d3f8e2c74b26607ebea4b3bc2960a2bb39357e1298cd4817aecf10569200c6e8e4c7a9891a0d9098c180e584750148c2c536821655271f4c3f2909881f6ee7529920fb06f89701b23d5d1b6911b2ae08fdba4ecea1068d7d74c97e5762b77db3091a4f78bb52bbff804fcf31755befb4d34f784aaa91f9829a5872c35b94ef4bfe59ff5720c78b582f947b82d1eb176ec96065137a2ed1df633e9bbf75d4305a3169e7d04f48d9d3adf69959bb5534c48c6bc3d5754c8387016a1da993991859daf9f08608baed2c8f0d0e2078423ca1f469d66aad0575f5a8feb0385a1bf5d68db8088c317129dee4579a0b1486d1ebfd5a885e7f5adfd85c806a8672a58935ddf83b361e5d89fb66bc11ab4c0113150a658038d9441bf9f409a14d0e2480e5b4121e0a575aab2ba109c7a3254623af841e2d2108369f9164f6555332ff18f56e2d2e7df5998046f2d0d97b7c26ef9de548700f2dc9acab10da50fc798d1a4849f5195f6f95feb70a0ea67b9047859e8ea03a2dab29a93c0b25832690e769d0b00f27bba9b220a0d3e4c83a118277f0d0ca76e3be4045a0b2c44cfd67779e157e83e55f718cc88da4cf8d3128a8eb8f793c90210e52b5dffba337f28ddf8deefc106593247661bdec2608531f7d995dff2be2ca041b750fe973ed8f87fd86833fd84d6adc4d4fc678ef6106f6eeea7354bef257060d74114e344fe0d20323b9c947f2775981b03aa2cb035b8745d402e4ca7e37bfb68d922b7c6cb878f37a5b935654c608c344f7a5fb59e4b421e07c0092f51587654753308977108e4947af91abaa80e6aac04e19c527d5e384071c1ab99d16503d776e5bcef0178db9b3f2e49bc4a63f380498da84cdc069a2c410bc0008ff7b555dd1170ad2db24080528d7866ba9cc2ac14ae20a558831b993767fc1e428dcb9f5b0c086aa55cacadee675e35c305f724e2a5dfc1a702cf295480310391a17209daae4e330f0cf6e39fe8f2bb752f9859d056578973ef27703698afd23a6459d1a14c6ec1730be672249f069992d1e9bc4745d98428392ebb5bfec9aec594196aafbf54aa7b2ce750364e87f9413cf56f40c6ebaa28c74d968cc6d332a07af42ab306a94bdbdc4df5b86b48c72595fed5ee73acc4b7e0aa5d1653913e786de1ce4f73ce0b4277a693bf1aed607ce29ef6ed6c838be998e69303facae9516887495ad6afe8fe242ab294c3f6f3a07a8c861749eee4bc1fc40b9c044ed9126e7d522ed14778f062ccaad0dbab88cc3fee26e241bc700629f5acabb6795bb6e32817a638a278386d786c70ff7c93dd1c45fde19a4004f1a22eef26c0dddbbfc8cd44abb76f1360f27cfb36704ef091b4be98021f9a02b26edb7e446ecba7181c639e8dcf0623757a3464df9872d98898a22e16f683ef764e4d91be1c7485ceb31815d0ded17526781383b5035ba07e6382d8fbe08ead92a50c2ea2632af84c1d60ef133b20659677ca4c6722645daccf0d8330a40fe42677117a01ee4b7d103f1d1c482df59f00433efc57dac2c522d8ba35ed63240905e287b015aca400e8909ba6beacbeea580ddd98cb009276f3702f5608a642daa8be125937b3753f8dd68d39ce362a5167d38c47b4fc67f3134fdfe711b0d4f6d7912f999a9e0280076ba22e45723b1e310c8a8c54e3b1d2384a141a0d8826f967a4fa5c794262ffacd29aee3e8874810dc422aa5c634331b4f1a4627860848099e1ae2d3be50cd5104ac3f58468c110b28f1a36737f2519b681ae47bcd8531bbd41cab18edc544caa0ca723bdbfc2138bc522b2ef665e65da1e8d34f8821951232ba8882a8bf6bfe883fdfd1d046f71a17a63c6ce5f5a00c2417cb6fad6c449c5dc2b7f7b639de6ca6979637e3dad3c0bb1283de32e331884d72f67f86c29ca6e23138a2464a5b9bbe8afd425461b2bb110cbf68ddbf3b0e86eb99d2b34cbe54c9dc206fac969dbdeda5a1b2af1585b025cf5b1424f23b5ca3b00c019c9718a8e482a9be8cb928669678bd706e5519130ecce32c7660c945dbaa36af52ef3a18678b27094013d962c1dc89f65eb5afa194c8109d8bcc44dccd5197978388039f27247b977c996c03d2ba68753eecc04c8b22376697df504c0fc2de14ffac8186c97bc24a2b605cc768c315260ba296a5cd478976a8f5693ee4f5850067430ceed8a4571d2b549cf86e3fe8cfbce2ee3d44b5b3eee287956f965b702c1020458c0cfd9abf923f862f6fad94ccdafce55d6a8d311adc803ed9380a38281a769e393f4ed7bf05a4fb4df396a2d876259706619d6118f1e0532815134918c99f327bd3a880c39358c6d262ba7e8787c85ee186f8ea2a859088e4ca0c004e2c3e8d7adb4d8f0c49a6da5bd77ded7cfaf983729402a7bf3e53e7792f5d14b7a4a06af0cc534f69921845d2ad23a32b08889294c985a70703291ca38c79ec36689d9c462a61c58cbcbb8332c203e04142f99b6bc031f658a9c5d6bf41e62f099e43bd69859f13c051ee195a0dd7059082a7fc02a1b826285fdd927f01a2484318a9be891808ac640b22be0aa9da41f9c737d08db6245d3b3777c90aa0938d33236bcc7a3bfaa6c028c5937792540257f7781f171e721ee4bf1c37c8ae58210d5d4d316de41e79b8297ddd3f66225ff2872d53da2fd7a427a4cfd89c41639e6f6472190157168d9f5c68ccdb1047aa06709e3c493edea77f7cd1733938ef651d0859946eb33393fa15808338e35bb9f72788fae24fd9f38f2e9c3537ab684a427a1dd79982edc79591909eb22ec1d194ff123c65aff7113eaa05a7a12f042fffd2193c0430344baec71aeaac68eef236eb5393eaff95289a6b315a34905052f6df192866e66469d10595809e6bfcff65c6e4e6db86bb6564c201bf8372702d59706361fb3316f86662e4a2712979d3530dd47d2ec48f2725ccc286d2301924ad1b23d6f400e0dbab403894706bba40ac0a69ac80bb5b47b5bcf4a7eb48f4fb1b23b3c6184bcb0e77e10fc3c40e21d4f1047df99f95e25d79f54d05ec470e026c5bb793b9d7eb174243e1efe2ea50a48a64d45925fcd007d90126a5ae3d8f8871016404bacd7c304168e11b2bb5dc0a578c5c4b26710d0fa0344c52c3a9897cc1dad0627c81b3ca494b37265cdc8a4126799f91a95ed5a5f3123f98da4ace69e3f85646467d73c0bc2e44585680602ed72ef95a3a407f7dac407f8ea9bdf3500b675aa64684525eaa4e4ac46dce380606733655bbec6116649e519b2d8cbe26989d9777a4032326e0b6949bf5f9536b42ee7589a46ca6f51cb8e6b243ad5a730b02f74de3dd70877172af18fcbfee5383b7e1be6b4489ab38c8a94198c801988be996d4bb1c98f1b123de0677f0a2ae1abd9602d19efdc6fe393be1f53f9b004377e7aaa25e0eff778aa663c26ae7286f519c1d97ce899bbaa120c1310a963ffaeaa63369f8a896b6dd4e36e50f281ff43c2c5c82c69645e5515e70c239babd66c3ac5687d05be92c77a9ad2164a9bbae9408b1d812fa118079636ac7a23527efd7595f289284bbb73dfb4e250eb899e824067fed79d0751cfaefdf68f54f3151f66a5e6306e23ef6a61d6d3134481bb305b24d09072632051fde6c748dfb920df8324fb93b0f257126f774d22478c0fb3ca339516be627191557dd667070d449b3b9c6d49d66423a5dcffc1cf5d575548eecaf192f183772ecb2d579e83621b55fff20c1e81b202b24c43f3fd76d21f8e612d7f6140eccbb372e666a54f1a73b0f6983e383ebfc944a08bb0c4e9cbb18472f2c690f6ab0379b175028cd3a71f04f6e201141f71d7f4d2e9825f88656ba7306e862d86064fa8f98704fa348aae480a2ec41b9d98957ce9d0f10a2f14a0b835274028481f00d9ad88e157c37f09d2016e8551d71d4ae9005922e2c7bb92706ffaa2bf666227dc22f9194a4188117113057ce1a6a92277d4d1d46322bede70593193780e0285c44c401d2cdd8e2fc8cd7fbd979e4445a753cf1f1d1262ef9bee5f5fdfe4f18850575e121b8d59d585fe9019d906af4e7f466e10669f164e193c56d4408f4860002f6a7ebc35ec57e95db6ac675cc13423616c841c43695c7edf0e8e68564310fcc203b3ece00d16902f0d12bb9e7626d3416eac72284b4e72c4f4cc4d031976d2798729bdb799f9e0ee7790a5a39e7935beb5e7c2f23faf6db32d6d0f4e572e9f0fb5fe84c27f1de4d0cb11cc69cb0a17e62d988fa3ffeb5b0d19a380a47e733870a15e671ac698434a88f5900e405c9e4642c3336ffd4a72b47814c8a24e9436592b22e46ddeda3b0728a221af85ce31bad8ac573ffda2c1268e796fa2475eb1b48d40a693ad266e4e2a82ad78b7bad54f349605e8b03b065d4567c593f52a651c2e562bd21cc5c8b69694e5e6e76bd18ec4bec356eb1f064f0f04ad07d7b19d0b67eeb4fbeb3b0e34e6e59c5f80b04689e8321b88ce1468adb87aa2727e8c7364e382f38f8310bcc572ee671b67b12350fbb72002c74f0d2f50d51be8eeed287d2e2222d1742911ef6f31c248d12ef542ed3d4ab90b822cb702904750c7571b1f29ad5c20770e5337200b8c190965b7dd1498dfe2a146e7467ec7f4670933fadcb8fe484f3373739b75679013240ba7ee80073786d25c145c7a3f76d85ed20e22c4d79f3108030e4f92fe231e1030ce8046c808ab5ed64a370e69563e1f5e6261d9c92054e09c5eb6d8bff8cabae78b73ab1654f837e70a0d1823c5dc9ef63cf86c7b5e51750bd174fa1c5dfc19f9c3a03fffc5e3e3a63767fe742106f0ac10d28e306d27c0a0c7ff882bd77b8d21cd39350b75efebbf2c002d801986335dc1b373bdc74b0cf269d3bd63a50492ebea73c261e8e38a7621850c9962870348aaed96c6de800581f3581d5052b303b75f02fa29e796ad4124d3502b4008c159a58fefd51c5893d80aa4f6b2e71e785973d0cb50ea099277ccc87bbcfaa99a0a6110f3f267d926fc5297e8be9ad5633d2952e65ba907e41efd88d34d203c3dc7fb95fbfe0d4bf9c699c4d66e8ed6a27bb9391046fd3bb3bfdf982d159dcae8cda6f1d60c9ccd0b500ff21e5e0ac2ccb051fc6180f7ef06f993f2fbd68f68d0f321fb0baaec712084fda578e0d2d7a703370ca66169c2bc456ecd524df2f65f95b7e1c64675736b432bb9d2e7f68346209b7f8cb4b7ffea30086a56c977fe7b3a3480585744a049deeb43286aa95927c23924c769108a87b6ab12be7a07f0f87d9f600f9094619a3450beec468aa4360cbbc6dba8ab66f0352dc160b42525a7d571594c0cb76022c30fb89affdb343348acd95145089ade52fffcebcfabeea52893fda1b33a814d880d67811207485249009134ccda09ee829a0df1d286ad7cc39754086ec6a64974505a5f99b6788adecf4661c1b80af6cab0b06cb5f5279ddc332e4a7a5c7811985a3a567a840408fb338c21abccf19764e870b3822c701de2b27bb9e87564127b482f7742408645e1f75bc8cb1e7e683bfedd19778acd0df13bb524376d9a9f8b8dc93ed1d9100a0ef5a30173358636e15fdf70d93f687de206ed1bffbf5c33ecda350b21f8057654e6910149c84709c766b6d0e42a5921134c87179c5efac9d6fbf6f96976817b826b0925f18e26afa23254d8738362bee5faa8d342e8221983e4556073f13bce0be11e6c06a4ba6017fb7bb54918c62adf9857adbbcb1a71e3356a7d0cae69ee35ce2207a39e74f6f50743aa16d3a884964e568330b899144befe0de634cf14272f0950cd9864f2f705f6e711b0dcde2948910addb3ef324dff8baaa020bb15497091c6013e9e4e495fd98959d0d524db9763f64d4ca67167d6791ede2e4e444551865ca46175e37d2f98dbf98f2565d66a28bb35a260348cfcda4057844ac386c471ce51d788ae6301fe61c9d489d7e036fa0bfa9514f97f4206bd522360e9ccb744860a55ff329ae57a0eaa41479c7ba2ddf840ddfd0d6e94e91365cdd3d6fe3b47d2484dd4d78aa578be89b5886b5c42b4c1e1197a702761ccdfd556fb6e13b3af24a0376fca97e78036733256fb0b17c8364b39b4bef21bbf223cde9ab12c728a2949a03419ac98538b3a50aaba26975e76573dd761e6c8b90a1ee2bd7c148966f166437c3e89a3074febba38834a262440e130ef0bf06f1041668eb9ee99857656d8af5418fc91514bdda413882c41d2fd47e06f29b28374068fe034dd9b65059a98d8e505b01ab76136b6b0a9e10e8a2474e31e569524c5dc1d4dff8d649e4ee7d245154ef022281466d148bc8cbcbde5c44a0408d2aab982629989458b1047019ff652df76ab145104b43513c9287712a3201d2a072a1fd66b096799b0d92d5a9024744eadd586603d75352b6486b654d7f6c780eba4ee6d30373ab62aa31959838555bffa27dabf15e34517929345cd62458d2ebaacc6fe3bf79b28c9784a446e5d01c04245d6c1f5f72fe605acb15ea7b3dd6b94a0d9feb12a2a3190817e77dcf5aa3b05b864e6456c7b8346dbbb63a88da7c5e4cea86d5021a57e7ac6c7ab8ddf5ed37988fc6c352f498113346611f9ac47941fda177db24fba3950c6e566006a9135cba5caf1531e1575e78821a15b7f57f24e0a045f7370b93832a5de0a5f50d07d8e23d09442712253279bed3453e1a7a18a04afcb702a5fb55e7d23c90a183662d4e72355f226396ec1b8ebaddf8228fae1fed242915e03ad8063e9d415c589ab99a5978b498740c4a54fc6d9490fbd0e86b1f41c4ee284c217b746c3f5316fc80527364c0b738c77ce30ba888eaf38cfa3c5006320a54e92af4bf6e6b7671e53361c98c2e53d88bb946358db544684ae1ac98488b913c6d3466d6f6333178936165a5dc7ea2dce0d9ca4c83c592393d711349a3163b5f9b52622604c1bc2ea301f4fe087801a401fadc54871bf0e825d8c0384417f9eddc0eec792b7cf948e8338c45caf4238fe8450c9b8ae84ffde8dcc591e2cf46027422ce824ff38e50e9310cf8d479063adde37ce6558f1fa5ecdb6cd820c3e22f4b3e7074351340b978e69794327ebdba304206adf814f35775e943f9db8f6a2a31c08b63552e7e650ac9634aaed0092a8cf4ac316f2dad5e9f02000acd0546e0c2c9d7f1c423a3360177bc371917880245f47ffb6862399e5e9383380f276b7797672d6a06d9fa19d3059dadfc44f101a6ee3edb54cf03e721dbc14a055aad8b427ab7f8d689bf805aaa9650c3f6ce5ca81b900fb4f5f241c3686ee682a2daa4f9a0044a43db111a45c6f6270070a36bc0381b6ccf95d549d5ee9af5142844628b5ad301cf15b486f9b82790a689c3f09ce18778e3cf55180e30b0ff44831b24b0975902f1e3f2652a17563ed79ec53a5c13864905ef5c909d392b220fa45a27669a91aed5b08193a62425443f365d5534ab6fd72df382e8ea27aa8dc5b5410843dc77457fd973722de4c692173000c073f35d4e8d8c67c8a618248ec23ef5cee92be234082cdc84c372d3c47d4321fb786793cbc791fec3833480332cb4c053e7c3f7a80ff54b5ec0859d3b1e036689053f45b5a14ad482c0989cdc75140b33d3a40a0fd3d2cb1e9bca20fd7f67f7e6150dc2dd69141cab2675f4f40794ba432cd2142505b255d64e99ee2d1fa8fcc17764dc49e3798a89dbe2cbcd1a311748f2129b61a5dcde94df04f0141d481230451b97b8a72d3ff9ffba89704e84e38740bb29addbad36830b6d1e63f496fefb4a5b92b4f4e2b531f57940a5cc190a5f6b932d2185b0d4c6967a24fbd01c1a2c09982887605e3ce42034fe7efa26857940d475cebf173edbc53c9080837c5b970268a8e94866fa3c7e94f20c1eca5721b802a64010c411d5b27f1891beed730cf669e2910004978c354f8a603140b69728a3ebdb7859547e05bcd711230ef4e7804b2ccf79834bc50b525e1597e6fae5ad439c0006cb49906c1b42f4bb02b4166aa61dd79d44b5b92e7086492c964f053a9bef31f836e6f6eafafa228ec6991df5268a9553cedd387b23ca591bea15a6b9bfabbbd73c349cf8b8925d89a7162d759cfa17a2aed3b19dad1cd2ba1ee3c89a4f968afb6286819dd370ccfe54822f967ad8b9178bfbfc8f003c818c02661045940aa9d801d604f0767c22e6832eb7e3c03a9909e06ffb27da75bde83fee1bce3a99c61e65deb7f813c61ed1572b31e5dc0b2a44340f2ff062bb614a869178889c89263485eefb0074a4dcc476995ee7c8cac73b6c556f2c16667baf0356b27a9e96212001ca81c85027a3d11d7a645e0efdcb4f8054b17605a9bcd136c83d8fc245e8d1456bb4e70518d56cba02a799a9c31d4583408a6d88f2d0e67e0cec22557db36ef672250f7a37a1270d8d25eeebae53e66f70bf6fbede89957f9a7585d7d8224f2099e341b4e3ef15f4ece7481af312116a61f53e71315f6b33fcee0bc8292ffdbf528e98bedb67914de0d32da5b2f3649279dca01e3440e69069811c1f4f47ea5631e1f10fb232caab7166fc9a5a551a8e36e60342989a7af7d54613dfad8db89148d7f4d93158163b95a221e233b2d9912c219a11c23056776e4ee0ff976478b00ba603305fdaf8908bf9a59ee4ed5de38bb879004eacd7ebb64c5bb01b97d9b0c5a94561a6f02c27669e47673445a5bedee203fcc7411455f5ff44941504389813007a9e40f90fc0189aaea9f56b8ee3cf847acca640a4ed970a3dba35de75b88c7a54bcddadc4d0bc85e94db93e79c366a18a4d1c8dc2b5b6a34cabd69ae3e0f1ead8a0dfd59725e562baa6ba037120935963cb5539a0230db6b131e196655326fe6aa223536ca4451ce5038236125b2e514d1afb261c72ce10fcba9b37502ed599629ee0c89b4071e6e93a21d2657ac85581366b220676327d143e84f987802cc24217b1663c5247f1069912eaa786c33def429ef73d25ec96ea9a77936222812f1fa54d1cc3efc1afb0fee930505eae7c1f8871c93133a0fe11ab9e11d257bbae30c65ceedef5e3c6c1e39218c9d8067766c5359c4d899b18ecb30f9403b034aa39777e43339c25c7a469ff46d0bbd161627012c5c8acf66451574d3f9fe053f30211300d2ee1ffe9aac6996c7a454db8bdfd7c90b148f95604c52fcf84422f3499385d982b9c2e0aaf256bcb6741476feab61cfc4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
