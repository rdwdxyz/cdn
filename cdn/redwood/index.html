<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c3dbf67ad645ab8f00ab7137dd2790597f1e0ad401a1cbc1aab2778ebe7497c320ed543e90ef66bdb8ffb78d2a9a47af5750cd1b58a4af8716dc8abc158b3511e735bcd281a7516c20dc4b746328c23cb77970aa8638b5c82b702aba85583da35a4db4142ccffa7223583eee3d8be148a8cc7a14203aef488b05888e58e223d8d840a6efc7eaa29d851f806e9b62dd40945ba2ec4bc206f2db0e4f5dffdc08d254e95570653e475255dc909f30af2416e0adb6790a9b3a3821b87a77eb57586be8fba91d3875674f5c0bc530297384929922fbfd3f4c361923f7f9183b56988ec0012460f436ffcc453ed3aec9b3acc67a8e8cdd288a814282d6df0c7919e868b6a525488737f83a9a0315bf35b57ce7f0936df440f170bd23a9275015c2bdcaec1b5c92c81d35a9d27ba39ad8f84e858cbd7f35bad8018c682b6803159ca38a77925cb7fb7c67cb6c6714259b4247c1ad008d5fa01b06db60a98ceadd7f5a61b9eaa0390c2d5c9879156a47e2610a4f0737a99040c1f3f3262a98ff5ece74b90e6dd11e247a6afbfb8daa54ce46435c2d7d89d0925b5439644d2c79b0dcb72ea76514031e0d5007264b50d503b5e058c3affb3b0b451897bb663d6747fa3476fb6035c5c6ebf7f3f6a1c529fea64a46d188a491b17acabb3836f18ebd744cc3fcc919b4cadbad3a1cf09333e6fec6ca77bef7904d3fe0f28dd258538df8e229d98eb1d5f1acde5190c392013da890028d44fe6847c7cf869b8f647b9a3be601d1cf9c19ab91492b25e0e4c72c125ede8f70aa17b74b331617c7c991bd7f555ce8ec6f4ee801ea0d7cadf7cf5479925b43102aa69a3a9b2e75873b7d58edea011dee08d9cb276c2ae42fe69b228206f7c30c3b74e5ef83c2d35efe1e66b871cf5c6baf014d8fb1fc185125fb8a5e49a31671435bc4b263d141eb9f0cf6588e461e6d84d600512bd00de0e647e8975500e31ba75ba0819c858e0fc433e979a46733153f1e4ca8d462cb912c73b20669aaaf82a46d775d64855e35dd9b2c504deab0a690ef232b39336ed72484363d8518a537688ccc7a412fa076aa20bd166af83a930d1674e8db7fd9f0437fe297d5f3416747d9924830df8fb9cfefb91dcd31de4b7f2504f254590a24791b47ed3cbc2b36cdd760d4975888ab7ed57487892196714710f8f5eddbfa0f3facac395cde612dc7918467ec37d3676d983235ead33f736f4fa7d4f378ae208a549679d0c581d58c205e8adcce8376ccb1842a0d40e7ecbdebe47c8a5b25df1ebd544b4ccfae2ce4f1d07d634d008861d34c65edff47b105e6586b23fc362a9315d412ac272cf37f6d51c6914cfa66cf8b58b494b725d8cac94fc1944680ad42c7103f226528559ac4e5d6415047e73c85b201a3f0bcce3739128d5a5e567dd97547757b91d0e5a09b95d8cff05651d1a94762d277b3e6a7b525168c861c14b8e2992502acaf5db280faf60a494ca4f8ca084a5a8efbbf18c4571accb2c7d0f9fdc06a68f52d0424f41f7f80634db4c5cd55e7099cacd40d04a3a09a1f95bffd2c9f24a0ce518c35cc2eb018419b0e384b064406364bfa06f5deb40dc71e20de73d271d5092cc4e4f671c806672e70f8a938c209055d94b958cecbad4e03e8e0ef499a926857abd83a5714d980366a533ea0e00be206c5aa615b9943ccfd7abdc80cd83fb9c8dc4110bd107fbf214c5e5275262ad107ae24ba871e36d32607dae8e69558fb9643038d52726f070443779bd128e932cbf080dd43815101a747756ce42475f6a70aade1794df412a20478779fddfc3fc1bd45a54905be3aa48ad7d5850c053f1d2f5424cf3a70f43dc7d00420b800098519e62e7b1cc615c293977829d6ff63b737ca9f40812ff6a776a1b6b82fd531d0cd4c0ec087a7a8f0b236ff3ce40077c223513e346ac0b70e7c8e5e870648fdac5c6cece5df2e7f6f0592194e12fb514ba59811901caa92ad2c9dc1ba3253ac818d5d8a156e22a8613ca83c3a262613ff3c3e04d9adfaf59e5ed14f6e9567c6c4be03e04e74b35196f02c7bca0b212d6a590fca9116a3f6b408833a01ab396129da23e5cc179ed4d6b47673127736a5af3cece221a6b29c91e24cef00b2ac09387b8f80909106f51fc6fb42edd9915cdff9c9faa0e8377d98e18db572cae7690788fcba026dc147cc737dcbdb18095cbec67730ca1c190b9ddd147f6c95fe91b889297c9b366af5c7a455a3bf0bc028db11a2666a5adcdde778b5f08e8d0fc69c262f315ff9e14ae1ab7a2834d4c9afbd566817e47a1b997a9d309eae7edc1460baa57c1649c1e87b06db91c1373bc647b3d67746e83ef6f70664c3ac034feb3a4719283636c398e61b0e57de1809f257b55b61272f750195299e6ed3035c49449a0f9f487fe20b4b500e62f1ab237983b45447e420d234b27647f2d1d0f7c47ce7f1a311d4f2a0dc1758d80182b9a8957b28df7acac151ec6f69fa4819ae55dc314cf3c0bfd4c319869ac3644b3e3bbde8204b9bded361d6afdc8333724330573fbdac6422632954f95e420aa932a65886d17a53e0832948b01d1faaa28590fe1938c24fde07415790670f2939c255f7f6047cbe86b5ee4bcdcb55796949b9b7fe3bae9031830e4e4cfe3d90e79b3b15e8a7bd052458cbbf5784df664622be0192e50c0aa73fa8ff60737441d8d40183fdfa6238806985bfb323b0fad2279c81e662918826ae46606af59f4fab92b2f9e96cb0a11156fe2536976a98b60bee8d412101e7d9096a7831f36239be67a1fe7189ca61110a69590a584a96dc20fe7974071f67b85f99eece52a872ed60411cd57ee5f92d1bdd20735f6268e7197c8c03b0a8e8ad0efd355e4d7d0b978a6a7e1eb41aa5cf8997e6591f9606a74cc2786a1d41de30cf8689915112cd02142800a6d01bb7448e1f63d10220dff8d818f95aa8299b094e754fd3ed110903cb28d07ce73ecc80ac6051c5a232c3bb5a870d7832501ab4e81cbd1048d6fd562c9f8498b1cea76ef2812e6363901536229023f857a797a86c04369b362ca79738a8ed3d7777a68208a7e22ee86d49d6a3c8e823b9fcc6995385ffdc8661a388c07a705aabc2a989ff174dc1fbe9bbdc8a8220ddf81e10f1c6da9e7b4e7d37de15ed4a726a06ede02b741ea6e86ea55b33e89dd95c19198adc0d66da6e2d6d4e387c49cfe8004c503f2f3062b43138dc19752b01c4b335534aad8369c72831270ab9a40fb04d5d1e72c3f8c3b7dcfda57c852f93b733dd1a6935d1ec0d163500ff449a2c1347f5327ac82e66033e0f8730ddfaa9ef3a320540d758d19b0eb07093d8e355c0fd6aa68698986c7fdebf51673977d2d2fce9e981677f9f0092cf5f9fc0910093bab9d63b0d6637801c4e405880ee105ab89dc66c675789a8a735a69e18cd6c0ed9093f72fa5b2076b1156cb063b2b1d985332f677664675190292667599cc4bd148b8701c3a5136ac490759de91afe219c6016c917113151af03b6061432e5da13e5766ae2bbd644cee5dfcad14b6cd9feae92a80882f06e654b37376b12b5c03398a89871b53b8158bbd01afb1e871b61498af4bb52b690fc184057b46bf74c0a6cc4661481830e61c5df0266b784e1220f36de1bda26038c0b73a4474efc93c0db6f8b5babf311a90cbfc14f86e947e100c485de778728172892834615f25c7cc01b24e673d30d54e6bd40619ddb9fc7dc07ddb9e771eccce1d509db8001287c46b48c7e45ea488e107e0de59d53fd5bfc83a038a3e407a22356b450e5e5a630492bcdf7c65ae75735107fce6a595062210c93b8dc972138e869714edb617b297aa9089554e57d3b977c4958a86f74f33a503946170c4e3663d2dbdf72c24ed0a1b6fa2e724679f8ac15adb8f1d3d4bdd89322cb5de52c2b5491b139bfc82b6f404a03754e3ff3e554b2de2842f9e941276491d9b97f3f79e3c74deb54190bec9369ea022f31d6802a28b04bbfba12f3848ce6f3554e753db1b7a015300d1019435e4e7e470be45e9a7102895be711a0e42b10fcb4557dca80fe622602d7e18eaabc222ee04e33de3f793f59b916035be5e2c88147dfcb525474c513940e3448430a0b77a922583a181ad44a4876bfc6211f9acf6faea9a89123cc7b9d25f592c0856d3de1e6d0b12f17cf8f49acc95428a7c659262a5b751fd8ea3e53efa457dfc51e2608ff800986996e14f3710d3bb2ada1889f011979c137848f8fde3ee6a13c3c0e1e89b724389c7c48d3c301441a46827b8499e095c6640caea6a13a1b0a0d99e1b525ca2f751f7ed534d959d33c6f5eb6479975169c0ed5af7adc997aa99f50e86eac2701585e37fcd67996d76cc4172a7b9f3c8b63bc192aab1a6fc6db793160765ed1c4f965c2c679b307fb7d2fa9cac219748ec61485d8b6cf3a5348ada4ecfe15790b54ce20495bab17aafada1c5c44c4f4382755175bf29303149bc5e33ec94c1773df95fb76aa3f5bf44257f056ee6707e194aa19557c847c9b56f46ecffb12199896e5608a9a2031f28f92ba63f156ee12f38cae558483cbfc828b5e6ebad71e84e34327142c30c05c16a82790a71de72a2b2287be9b2e2d90c973715cc334734c4c446a2118aa253ebaafa34fdf80ff02309b0c78753d2cb096c4fde936dfd9e6214bfe3851f66f0ca43b03bd6521c5d631db20464defdb6a24546b1f4a760ab1884b6b5dfd5f3354a5a31d8480c46041e35f6e0556a7b7ece96a85c77f29cbff2b6c6983f7f7f7c183fc55ab35d5143aad1f5f31d758ae9af3ac7d1cdae740a3e363d78a61ab049bbe4d94488960f70e95095f07ca3daf4aaea6059110283e9c122783d5aad72757ee6dcbd7881d76b47a4c9a725676bb25a20195e0e29665cd740b92fe0cf3b50bec8d1d7752e3f08c33257c51b1ec9e62bc8af31c5a3a829033a7082e010e9ca18b93d99847a2516b48d7c5d811db14ada4980956e4c7403148337c60c06334009a6e7ac46af0839db000b480d9460de426d159219d55a365503895a0b575076824ec6c3224fbd86f7227012bcc85f3814c3b4dd61a3221c5e2b7620321a4be970a9c435fc21dc8fbb4eb3e05825fe3e87cf029b26e4157d8832aa56c21e8afe99781aee51ec91ec073e26ed6619d42535c0f8460699cc050a6ede0910d6c73943841d1600bc3e3b982ebb348b9caf991bfbf691de051bd6fcf89d91967c4d57db6186e124d1082e57af1bf49c075f8fb73893dbdf2d579d8fd8f311d39a1d64782d904912beef458d4988a05061891c821fde6f8127ec983dfd472fa999161deb0111baf64bf41ee4f4c67c23a5fdd1499a3b9cb8d0cb8fe1904028c74daa08e9746c9da471a89763f11e4274edba2977d6444e427be0ae6676e593399a13f8163d6d51dc4e5203bc95a4ec2af497a7921451b7a2d5a5272112477c414fc6057422c2d53a7a57f52bb5c35aef813bbae109a4f2c7448f0be7462f6a6a4562e6d59faf914927a627666eb5fc50239d9094a5f93a636a492509a5757abaae961e1353edd24bf0972c00d8ba4b19323c8628ef125e6b39aa805d8eea907467076a0bd2bf940b2b8dfd2c0bdd4cb677ecaa674291b260d838ac3e1bab9251a15eea590d1dbc681990003f0fa796f0bbe61b2415e46e155a504496700186637d126ce2a0ed0de959d0cda3ba4fa9ae1e1a0f8db717880f155eda00ab097b8a418b3d6970c19aa2e59875b97b5df6c3f759ee2d21e7f8cf73b28a17241684f5859f3e2afde0d8f8f4a5395e1d0a4bc4e8ea4586a9364ec8d37caefcb8da2094f23cca04718d5e9d3c4ba3a9b9f6a438cd88b517d022536b1f992ef04347de5fe15942ceb308ee286bd67ef6ca568124f682a50b0b29952e2295eee0e9a90d41c3fd426331eee58857d2b2aa83081546614b278898c900824085def0c8491fdf25eb66ee32d2175fa4fe7108961e13feffc87543e2a3a8d56fb7e7f53c6c101a78e0d66a309b92f409c9e5848e5d62337b8e776f4651dd9960dc3b1e2c187993351e6674dccda3578093adaf56b838e4c1bdb7f80dc3536a8f0e67809b935e4afa14f279773c349d04874423eb46e8199990a275b6f7f1ebdbff9f2a4afe68998f247e3bc4ed95b3c32bbb2a6c27bf5dc8f8e6d43d72322d81cd058aa572c9914a39c49272ccc80cd96ddc463caf5729ac3bfd39215d76109059c66583a63809155733624be659e34529ca055be4b85a21565a9de0b6143f1d70fcee16d3cad9ca209065c1199d29e35c607cab65e75559ba0f8bcad5b6d9d553e61d2c923e2b74fda47720174dd65501dff3c6b80b3a437b7d6c77b2a230a275e36194cf9780de02fc183a0356c88ea55bc235976225841fd556893a3a10025bad34567dc18888128fa0bf65da1a28c5815083be3774f455c3b7c6dd817fab6ca9e884de1974055e4c36acbcaa6f301c448a058c05d537f4f080e1b48f7b3718212957f955708c0c963f2d9a8ed64f9cc1109260e429d944cf23bdffca628ddc1100d262941efe1533455b237dacfc64dd48e749791bd84734414869d1aec0d862cfd8b3fc283e3c31f7475cc328c047c39b3d625d5f2381d3637bfd805b5d1b01a80c436041e1d07183d297c3e9fdf1a16a28810330a265e0511d8f4a5d5bee0f27ddcf7c7ed3837085b74b627164d736dd51ccdfcf95ba8980fc3091ea1bde4c4e34a658b3be94257f3c9ce27d4fb05894868a92d5747886637c8c35ffaf828ee4ce7a142e20ad0ed68742359832e6f2fd76d1097822759d4e37d1973d2001458e1fd70162446b64c2ef6a7b5ebb8698475bf91f0c770ff122ae799b9f8b39f1cacfee034df16ce63e0691f99e6086eb2deb5c494730344bcf6f82e533e5b221dfdab5aab65fac6a983fe5c770a7f0d9bfc5ecd91f14ef1138e65bf22dba24f8ebd2e7e5b7e2d648538ecba68c68d0e71129088ff0628ce6dafaea3f124c401acc2b0cd229420ec990c7e80df75c39178be65042ceeffe1b993535c761d3fa52de3157def58b841cb7315703467328d3d54f2e2f91f06e9e9ff2fc4257c8224b3ed408fafa1d2c6f9e9332060d7be52bde806e2f7fa324a3f1b4f77856fc3ab3d546358e07139a91b73e10722bd2b339fd5ae97f454850e2a3934b4b34b9ec7c8c748ddabdcde200428729b9e0e5c815c6ef9c89de99539561cabd51fc8b85c995f57d143c81fe6b6e13caa3db0c9c7df401a3ef57765329c11c0d89adfc89798a75e61938f4ac92deda1bd5bd3a18cbea7ac89674c14209e2cd6a38f2d7ba1d35b41fc33b60cf655359d7b55ff5af5f4e8e23a8c4b954c9597dd6fdc1b49747e565d08d889541d9b5b740282154dd336763655eac1be79258bbf0f330dc3b0c849ad0db5fd2c6fc7bab0c029ab3aacae452776c90280f00183ef4db4cfc30244b633e0d22804fe630c31973dc9e7be05f992eb6b0c4afd0906b7f33f161675f1b73cf72ae901dade6deaa8eed91f2863d0b5c79a2798f58222165dabecc6f6999202ff4ffe45711f1d6eae8c83d7b5e00e09641b76a96a1a54c172d8ffbc8a9a524ee85f6a4e222194cc72f4ee195f5963d7282efb6ed0814dd7915040f7aaf7f117bdd3d953e76710d74ee5452ac7dd212a9a22e70051545e809d8bf34f799adecf58cb4b10fcb8f2ce38195056af3d24a1d6fe8ea9bff5600c9721ca085f927b72bfa3599671c1b6e2659a6be233ee40c84425b69e282dc1bb0705aadcb4800198ef26ceadf13998e2b47226358d661cde09c3f0d817b82a36d7f536002408d662c15ba49a3992a1b999bfe7e3e1419c8e0c0aa310e98296942737b86f8f3a41256c0cd6109843e37bfe27eb1f73aeb73473921ba5e8d73cd215df04d8fc667a114d67cd65c565cdeb2f77ce745cda8642324c7ca0977e6d40bc5c0a174dd8d9f7735d019d44a6a4e3cc1342227ac52996dac3fad47f50650b9ac997803761ab6871345a3c624a8509da27806a185367bf5d2fdb9e91b0ed0febe275a3189d65686fa64db6d5207f58d4f73c947752fed86f24bda0a158a8eeff8420f49b38c6bbc061e3e013313fab489e0180cf3d095e81e7f9384084da480853a827eaa37f7e3d6970aff07645b7c46b57f0a01e885fdc93e57d507f9dc4d6d56ec3b1b8e9213f1556e4db1ea1562e784b5ce9517f2824beeeb3be2cb5b57a92f382a8221b9a70a03f8ee6a4a31a5f72a246607ea7107e6807af78c9fa7f45e569f912052c3273ba129d9335241d75a7435dc553e2019a5074ea2d39bcb7dd6b0a18facd33430d26b2cae52df94cc5ea72f0d9130a02a4fa4e24e0792d82aa4197a66b3bc1e6c94556c2e00dda0513bf44852780b87308cc37089c7c8be80ab1915616d46fe84fddda312fc23c39221190516370542b0471227a8da49c96c255a1fde2088817e76ca842ce5ed4e7244bd057ebfb54c2343a52cb0cf8d962f9532e69cd1e77e4eecd9f5dcbd50d90b094bcf499cbbb1aa5de8fc4769b915fb0dfee8c9eda6c66ab8505b29ee7d54c795b26121be58eaa534346960bcc84e74c4b710b6d37da55a4875110da140bf6df400549aa6240405ee141dd645724c3db9b4a5a7332e3f5d3afcac135065fb80e6cfe0dd9903cb9e60a4677c8737944680f2302639e0ea71c9b4a66e2935be2cc16e39fc7ecb6581fda38058a342434e179556cf86d3e2eff22de4646b3e1fdf1ecf912200893001f5b3c7021f5322103abd94d8526e593b31e1531264dacf65601de9e6d17008e060383bdaddf85e5ab0d74ce2ee6c121997114f206e4f7dd5e8574700dd6fd9ea9feb9f80bee353d8f7f0f27539adb5c80095c76a99c0c06b1a6cd7833d11254a03e44d0e71b8c0ac21aad0e90e2a3d2a86c47ad718afc8ec62da38020ea3dbf5249bdd97b0a9cad0f34c85866aded3e09736b706c7ec0abda0942ac780d03df91b2842f4543b8380918209a62df3e4b016bda5a0dbf9e6662fe9d2d507a116036bd2e13a4a37a16ab3a95c58bfd39cac0003cb8788b46e73eb984f867c05fe57e98ecd3c08f9d0bd7d92afa39b18faa20234008c195ce5264ea0cfcff83c17e1b290591d4e899915047416b4994dfea52379dc405bfa8ffd06f8dd4a631c0abffb0ba5d39e98af8d438ae44c74263f425be31d6344f83bb12ca628c0bb4a8921d0316d31416748d7399322e1189ce4f91990169c20fc0bc6a5c03c7ebaf2520822753fe335e432468fdc89ba5adebe0714e4ec35339a3fd2a08d127f2d82abdc42a7ed7d89def2dcc1472ee6bc29a22df2a57b3b0076f8db48d076c331c1fda153d6ce5f9f24ed71da1215005a9d1ca0d0712cc82a2143ae8b6365b6cc8e89830b6ddec91de10c12da43292a8dbb044def624a0a3d79bb99d23bd24c1d03e4389e072abbc50042b28b56fc98376f1587ababc7b3b3e76931e5be6afc89cdcbcb2a25bbd8c6eafbf82ee4e6388ff50548da4659aef1207e7019eb59f5fc6a27115bfb178c57253fe205f32971159945c91e869fc0e244f8dbfad4cff32aacf46175413d7480139a0c878c5b0fbd2e93c824db0fe74e53ecb582b2ae75d6fa5be09049843d86d085e3a74b20d096410ff6b3fb2e8812d52bb7b1bede4c76698bf134c803a621268347fc28dd3980be33cd4ed70f3f3536f0d765b4daf9ef8a28ad8d92a65ba4f737d670894871ce6b55e37c96b5513eacb2261461837758fb9b763842853b2682da2b09ee84453b6b68828703a2ea2b54955209b81cf68cd3f0ad4c682d1096fe62c64280e942a2a740142829b9501adf77750345106b3c8dc9c721426a251b3885dff0c62e1295566b42661116ba4a956af86fc49a418991e571aedd7502bfae06eea33dc30a2e3636ead0fb62ddb9834976496f6d9441b890d5660de08eaf8a5a987c757e153d2818581483dc3c4309491d568d2c0fbfa8e77535334dafe5636a01c7acded84c67cac1f89ab10b8bcf3de55d1abb6d548d2b0b3035afb356883bb3d3b49cf01431b87ecee6e2acf164f825237f7e67cd7b462d3531af7fc63076e0fbd73447fcd478d1c76c68c5fb32f9c4f314d99b0b4dd36a6249d4c1750c86dc8f2dac0147c72c16f5d87adaef941f1b5cabe2ae86115f1cc1efcc59da25d55f0db98357ae6611d23f539c3847a8bd5b075deea3bffb9d2f069028281ddcfa3a5ed94cac512cee8bba0d4059712722376800b6f91c2f0b76e515525a7ea03aec7ce33bf52544ca7c620a40af27bc3d70d845782cd540be32a07d63bc65fd0cb4fad96a541680cee759fcac0281685da130da72596484f2086f512813eb9668f7fd478d30d28a2187a771597efb69df22a6dd5a9779d98d74be37a20d719d851459cfedb3d8bf9a2178225202347fa11e00e050c07611c490e9ddfa3a59931323e3af9ed93289a2fd9990fb145b80b33d25e8f40ec5cf116c50e258429082eb82a769e45b6b85664ec2b85ce0beba8fa13054267924b9f85f3ad2a780164afd9aff19f9a35ca266b90a41319c3855477dacc11476ddb01d5518a72c00cafd7ec5f954267bb1f9fea936ceea96b859a97ad5f04e9d9c1ec8181f8af838c68f15b596698b1e2e1f646c130b178428ec77d927e850b42d7394daae10f322f8c4f734f0eab6b00d5e7f6c41c3fcfc12f31928f9e041f308e599b18c73200590d9a003e9d8cfe310d360867eb140137a84eeddcdae76a665267b946dbe99408f404f7659b0504becc30f946c1f9281e469fae36b11563ac71e3025705387a8fbd8151df16299caffb32138bb12b43057141ea65ee75db640b981901312da9b9169ba9e68b39e520d2aaa2b9b02d61be64bbe3d5ffa09070c477bd9609c9b30eba6cedecb382c479d3cafa39a70e7632d9eaa26698d851e1483fe3b8b3f8d963857cdedf30bb9f6cdd200ed268886d1106fb9573f0b33dcd8537a945637894f8b43b02a0a775abed182bfe2cbccb634a49a670ba17954d42497752e2e0cc7ec482f6af1ef5e80d159c2812e9c2e58611f12258e710e6ba9eab6e0639041e5afffc312ca12ee7b72c744d362f6ba5c1139272274138cf3a31409edd1699ab8cc2fdd439961a8d31dcba8041b5b265bf951ceae00ccf380d0156e7fc3d91b412720b862f1a409baf63c3375c668fdd6d03f05bdd31a2abdf204fdca3f131f257c33705c9c75b53aed09f3783f7082fcbe3cf42136afa33ad61439e459df26bdbc81769144807208c8d34b462b3aec4f03d1e535b8c977b6d8832205bdbbcd48a1a20377620c59321d2af4891d81cecbc24d928832f93a0f7b838a642554566f3b0549c84c65d499cf35eb31f5a9f11fc358a1b9e1fa74bb4ddc30fdc29d70e53ae0acb32f025fb63d031d20069036f4abe9c363f2fe5fe9e9e2c46069865609192f33d6c72094df32eb17bfcfff3831ef4ed8b4cac527a22a1e063bec1c9450ba9cc7128f6cc7f87980ee0240ce2b1050e95fb38814ff062c145bfa07af17409eb556ee27f700e2a9a7df38b3efea92ad877a95a97e475c3358e32bd33b3617e4fd5ac8d26214ebe81b05e09d0be83626833f0743e04db45eb6e0b71d90b383cb4cc7e2fa16c3b4f8a811c8d653d11a0f17265db276aa57f58634ab581e33771eb77859f17f998b5f09faa0d32e82a3d953b8efc48d6747a3a40023a9ffacef3ca982ca4164f2c36cdbb76f2d49d0de725ffbdc6c3c3dd20cec424d2212f111e33a1200df4b4493696f97386d0b89c22c1f3c32432f81ae8a6ea7f4b679bb3126f7da226135b6839aa0ac27c357ca7b5ec1fa4a525b564b0527895274edff25862aacad6dea6957c0130325a8e968e1b36d3e84d7b065602ab5c48fc8960878d56007c92afa2448ada9aec6c7706732e49c69580325b5090c500d23634bd9335c329dee6833fb6116ce2afd53c0c5a3ced565c7fd4b1717e4382b213bd8a383e010457d58d73cb17141ccde73fd3c45766af28256509a3d3fe254561458e0ee3c567a3725b1d4a45f6fa2eda80db62966e47843fcc68ca03b5c4b15aa88621441befc9bfce8996fa0271ba00787a724e86d5bd80d88469e54e52a2b2c0be1624bbaa8fd3293ab77877a765c744fd6e46a4530eb1a9618f2b60cfcd723aa1fc40c107a5e7af454b8f7a5423de19b7e7a23077666b83a14e7bdf553d37d69cf63d50cc86bb707749c734951dc5c6e375c8268c65a8816ec88cee6a1e5d33be9355120641638f368631e7b73591ad28e4ca4f907e996c841089f75abd38e76f229c273dbb79956c24b82e5d81785f2bbfeeb65050b66157e33bc4fb4a3c274f8611c4c21055e6068abfeccca971877b985caa61f5e9e55ad81644fb24dc05b7e28f5ca8bacf4d3d35a2045c70f7b913c2bf6f4da3c47e26346e0a1093ce9685cba0499e4f53cadf5afd2a933094a11ee13eb96d3345b590abb3dcc1467e6d47ed766528ddd9c936a573f511154e55ebb28f27351236aa929f3fd94e63c9cc984b3b79bd320f7303703c2d0e92699dd43409a8ed016f29997e7cf4c78d431f93c0aaefd7804872c3bc58c422157d4e73fdc9f5e3c277ef97efa6fcb253adfb4d6ef38c126b8af87f07f30f5ac781ae49be89e03bd8b5d479d9de8537f35af36f6dfbe194437630d7115ba4b314f4bd53d05fedab8b916ebbc5f6ad0bd75685432f2f11f7cd3b342184cd483ea84ec8b6d36c71b931542c27d6efbb0f0f6aa217acd4ec28134e2289f1e7647bfa1a1df33014fced108414be873590bb17d857feddc1b2d4f0e99c9dabcd23fa621d840d68a0934e98a415cb201cbf5eb7ff0828c7b7062cae915b32df56fc828d62e676ded326d16b1821b14e2ee9883dea178f21cd12e75905cc08423adaa341ac6510333a32374aecb80f81ff577a7ef7b4daf67afe457b9a2dba5fc10b124d2a1009299c36e962c5c22d475ae2561093170ac0ff81d90249cdbb1d54555143645d33bf0406ad4798324ffff28cd1f6f4985af5b3294f68f8aa17268465aac4465e1223967ad613ae450fb146751b4294b55dd6c4d2372f09166954be13f9a5f629c205604c0ee6e6e072de6711b2925446e9534fdea85e8a1e8ce1f67dfdc7853fc78ff1d87e21b8edd7d8bf1bf6e30f1740deb959664e35f3ec197f7176fbaf8188d5ca0c65ec51f4d52fe0f15c71eb3102a5c7758d09814dec0b897a035769b20c36cbeea770a6d1802f9497c3758fc1083f57b8b04ee743c5eeb07374daf185b670d3ca0d89ab72a31ffc0dc1f5a660a95ea22d3b10dcf7b5c58098ab3412d773147d1f49bc71c70abc6a84a63e0947bec9ab662996610157083c99d74982867bd05bb4a1a58e5f48409f85e4625de89fecc5390028e8ca5cb40fb1d31de0e1bdf4b951cf144ba831bc92c575b8394ece4de4b5d807200ec3e6940731a9183dace03fbad1559864fab29da4835d269cdeec40bdcc68c270dab2d3a0052de7916bf5d3d95cdaed137b11403aab5a7b5100e79da2e9c7caee3ca1926e8ba81f8cb88689f172dc355ad958122b7883e460af81c052d2b8446306f560f6db32fa6250315ffb7e5932bce0c2fdc49d0657d91c4cd2581ed4431b6f7073ae83d3fb206a8b73245b710bd016560732299589f8295398a482aed4c637a1a0e463fd232f650f1d6f354886467a394c7e4f9400aa5a0f19e3e8b13d28c9b49dbf05892b4ed98d2cc75a5680f47a132d966e8a91f8c80fbf81943c0b9accb80d37ccecdb43e608ba226d1cc406c336d9559edaa9e7c9a59d6ca112a036feee9a766b9f5499dc53e7891ef1d131182c338229d8f6146713f5ed4214e63492ea712adc80effefa48c8e29a99461dbcf8cccc8632ecec78931e7cfab318b9f13a39211d6263d6b23125b663e1c8805f5d92f14a7896376d19332665beca79e4368a130a4ab2a98d8b6e8c4a4eeaba1cecfaf2cc32fa32f1f93666fb99c056ce4e2259df4194b3d3a4dbc560052f8e155d38a0eac55f71e956219473645e644d3b6e6874582b24800781351b05d758deb67c1a7e0437aaae37bed3e17e25864b3783d644264709835ff8b83c113522556dcc43da34bd37631a588f3dff54c150cfef945a46ada022a12d8eab64e67c8b614e2b50da2b643cf05237ff38aa23edc04ea5ca1c5961141c8ac81a4fb4dc17d512089dbb3d6fd82f2925524f5672d667a4c0aa495f31a2b7b7d2cc8bcf0e7da99c41ff7e0cb42be1c5cb9a8c57597c61646fc767a9cc621f24e3ef2e3741dd78d014b12159e73463e63b90a93551b92524d6129a4d26caf0050042cd41239e5a05bfc277abfd8d14cc70b5b556897ada904b6fabd7c89128655c41e4f187e39518edce80154d6d9a01128cf7165d6486427c0bdc0fce77d6422e45d4b050ec641e43ab6dc007b79f5acfde565d6c72b326302a2ab751fe42cf2b0ec1d81407e761080bc8ef6d744a40b2f9feeee5c4d52332195c967dbeb03cbb24bcc3912e32db59792dd3dba09350c5d822e97e35b67cb391e1b85a924576a731accb6b65aafcfc002ed88012d8e17ce00b419d985a581f0d7186fa313a446eaaf636efbb1a851423c39829ec4ca6d1b25e73b771f82090dfb18c2b6ea0cf72a72e75c319ad91f27a48d41cbf03ce58b6a7a2c7cc88ddcf0ff0a7d4509bcdb20fabc7b226332e1ad22fc5e2ec9ca98d419b3036dd8dc1ab40bf2c264bbd268d6ccf0e26ebd6b4029c687b46402bb27e325d1475e265aeeb0f01de9ff6cb7b0a51f7c8ba60a4c6d94ba2dab45d338d8172abf82c3d848f6ef2d0531e1a5f4af1a6398a020486052d98d0fc9de7b7cb33d944679e95b89fe55ac5e123e864b5e5568fe1346003ca2f9b6ad74ebf9936f91f40ddd51a599bee9a20edd9d25f168670d86f81c0c51e0d5c87aa393a9b40165255bb43fd17cfdb3fee6cae62d9ceae304dc1228abee297462859af83140f9f59f71f415e8566942df3afc00bcb66ef28011ca2bf2ca877b52057462dfeb92a7386a794db251b4a468ac88b6205497642df46232ba8f42580f511b6da505df56949f892dd40193ffbd2c17c16646b3e73f683f32443c3f05526f484536f88d992ece53b197513519e776373cb60fa64c44c8c66322d0764c421cdd26058c52815d3bafcee56cf05a31b70b2972a4408a9c14cd7eea532198e2567ab8b66aa59ee421b945c52764ac03e55b2f4da43e203c691b2de9c1b7bb45dae9bbaaa5a1997f46ca107119ce43961a46b34cd49b6e6302950e15516da6d993ea7e024d10968a75bcb9c807afcd3600d018b3795b990b75adde0561ca006cf6acec68d92dd7bc7f93079d289c5b04cbea4e5fb49bcf8f334689407579ab425bd10fd7aaa9eea4a1c851a1aaf2102d960af9f1bfea7bbc6142d8f9f1911dfae8ea6928bd766ec9baa7409c385acb09ecfe957b232dc1542fa160f523ea4e771b9c136bbc2010c78df9c62a5bc80e850c9e835146b5580bed634d928bdc06c2428383c4692ebfc5fe69e24e0ba192fa479388029b46f4073c2e9b64a7926927712a2223391b4e030b3d2a09afbbab94b31c4c9e8fb5f1ac837e66ab5c5a79230150955186aa59f0e3e563454285d2979be354012325828bb87bc382dd9db76be0ee6df9cb0a6f3e23fa5a1b7eb8fadec8a22a9b09029b34e16ebabfd6be0770cae9c6550b4c84e76dc09e2207abb2aa9a7ccd8dfc5d2fc179933a03add9999be4503b7f695aead4f98ca4606d972d39df8193f5f624ee1496be8c589059fedd0c9b1c3de73f0dbf0b41f1b6e0e226c4ec3ab40bde4b64110ce2e3dc1d7db5325dd199d29de4f33a256b14732f1378bdd1e14b2a25abaa83eb11d110a9665ee908fd65399712e395fa0e20b009991002c1e005c44e8f3c51845763f73ee0300ff27b65185eb6c57a97ac2f38eda5274235034f38139a89626af7392b9475b81fa171cb75f7aa7d82f70900bd54819fe0de916dd9ae60a8601fb2d56765dbc7399884adeae06afeff9fe07f553714f1707fb3e525b1a9da9e0373250cb539bb4183d1e518f09113cc9aa12f90000bed1af5ef5bb44f17e4321c2e64f71db22fa1ccc053f7f761bbef164d3500ada8b4bab80521d565568fa7f95353aac43361787f391ff356c13bd144b274b7a25ff9832398fe8f20d1f28d25026527ff341d773acb8f955e8385d90d766017723c67f70dbf86fdd1ebf89b2a8bfb4dc6403e34779b0835803ee2a110ec2fdf3061d1902625787ce339e67d36f7fe59500529f72682b7d3080c76ea145b0c8b75c2ba5015541ee57c258f4b6cbb8740ffa2e83f0ceb7e71a2a71ba31f38b1b8a26af05f2b1b0c8c98e033dfcbdd7695fd9845846c390148edd25371b74b34d31fe28bf1deb627e150359b2d7a292f46e81c94eef513f7b0eee9d49aa6afc19656c9ef8914b9ddba10273ba6364ed590d5a72b48efda08f763979c38b57173a4d183711e8842342f25533224b1335f70ab01bfcc0461ba7aa9124c4bc8b948c53246100182271f43ba6f67282441823d9d08a6815bf2dea0a6ae3e5c55ae3d4588346f808fc829adc633c971549c382a4c66143e6c311329ef890191a18519a1fbb831da6c261f7b221ebdfa1deb8a0ee5a793f05cc807560f08d5552088549c17e0d2eaa61cb62b158493b5c89e89abfe16fe3a7566d7dbc081820e4c12fa390e16ce458535f6a0b16aa27a67ce583b41fe438214e9c51d433b973d7ff7f9f651b5635d84ed3428da7ef81fd8bd24a2d12e92747703bac65a07fa00714b60d2d7f7e26af8ff854d177bded7430c70c63ef200ae6ec83a02fcc6b682f0a84120861e96c61dc9cad1d3f2463a4ab35158cbd50a057f9283dde3ff070fefaca858d2527a6d06e922ef57ea2677166cb2f88d122388af89f106a9101b8e6e2bdf32a8db7b511f3690b9e8e0f2202ae75dd2d9be89c0727236f26f49a9241640a1f844d1c999f59ccd22a31def8f7a290e211e63a4e76bf790a1628e5140af26b9d1d201503ef45c446651cef585d82670991b44f76f326bcfa986c21fc6e1a903a47dd751b4a374d20d51635990563b516ea7cf6bac981594d3d488369a5f05972a28270130c9b9f85367027c258aeec5b8f1e905b8895f96b9a10286bfe99b16b31b20a7dd4361f6122891258835117b9da99ba6cc26e6d3b8b59405616a24106dba8cb24292e3216e8691a7be54593c4ab88e7744918ab71933f1a03f3761f41e7e5d4f2bec0206efb40715ffc3abd7ee5d961fb3884832f03fded470b08e6d9e50b7d560f84612cbf1b6955245b700fb5185733d9817cccfb3262e350ec345aab0ab1d0d9e9b4c7543f472cade084423d5cb0e208e53151611d0c92cea5a008394e8e4a786dc7a4c347591f4d6526521f916b2d1a887432b0df806bc724bc4621f2384d23664582dd9134117121699e513da3a318901a057ef39c46376693a4c33df7f2d3402a70a4fbc3c71504a05b411e22e7e802c867e06da634f800a3a8dd7b1a9c9d4b5c609d6016716898fdebd0d34408498f2bb654afb29efa29f21c577d1e28b208a491ec9473024ec7fd66ed2d6cc87e1af439e07c9c79acc1f09f22a59d6c60cd0c0db388f96464b52fbeafa7709c2556ef12b5e4eff1fd701eb1a5ac625181a3d81e0109063a135236477fbdb19cce62335773717318efe7f755f78ca5781bc343fde6286b4de1925a8be612edda25d586bbc9af9ab8827a2ad045574841acf57db1b96692a68ec180d4e93f60dbe723565bfa53b53317977cb071cd325b8b80162fa883ffe0e0549b7b6831fe14ac4b4b903dc3404a20c4e611aad6892b282c91adb1a0d738d526c0faf5f249a0aed290b4e235f821a6b787247905bf470beca6aa5a2c2a09deb9fb40be0564f4f4932f74c987781cc84b679eaa98c54c8cb1e1de0e299cb7e8583790d686b3551295725b9b968623e865816980fbca0e86eceb9888a3f1274f214bb14063e026808c8d1fd753a2c298983c563091b21006afe5a3a7f403ab2ca3fd69d84c16ef5ca59a64a035a54881225162948a14f89ad0ef3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
