<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb71cd8c2dc3f32e328104bf7f048ec188c4d339ee4edb07efd31f2fa52220557a91cf4a0f88b3f11853e4a0f331602d76856a995be3f90e5e9e990f810cb84298f94d667782b41392a5adcb2da62d0b7992bd81dd5f518498628c332c111d04968d2d8196918a1120e0bd06c248701abb7a602cf38d3049e51c6247b21d61b1ce2d81ea1f052b11de3e0bfcab9aa1b62d2948903c4e19dc18401dd7096b0c4119b5649243114427f26518361e4ddac3578ef6b3b72908abcade9c680ac131f1519b860e3299a30cdfd3c78724fde137cb9fb806e8c28243be81d947f36805b3d074190d01196912e9679ba37d907d6ee2d37e5164561e15f8f0ba0fbfafa6464f9afa10f99506e2d85307cb7cd9b2341b8305c095bbeb4c918fb5f621949bd77e4748ff5642198ca37222cb3f17834462127f6e4b12e04ab8cc0531b65b684f32d3fa8511e223d6727ff3711abd967598a0e263d2eff2491b242164b0b98ae17ae3f5adf11414c724464e97bbaa2084a5a6ddaef9e03c46e907d898b2c63720ee04e40735201e275b76fb066d7ed18c2d13b59272ee9c7e5bd91e703de337126f18a6e85412ccfc14f474e2b0a3f3096f0f6ce0a7bafbf0341039e2b7749ebf461cf0876bd09bdd007ce2a053db5b2f917a61f5405e8e590eebe29312adf503478b035e84acca899fe21f2749f2cd712d9175198b562b817de7b5bfc8186eab433b284b1a10e4369675294bd91dc85f54d0f7510405a8fc250423acd607da369175b3422f188878ff483006793628999b4cd4427d63b7b5445f59a1b653626f19e14eb14df5b71d32a81a21d2c1e1e61c0c4e6ac74ea90b11772e3fdd068687a8de0faaecd677c401ad236f1b3767faf9ddd06c3a82a9cb10ca93f87836b5007afe1fbf0494684ab5032a0c7afda6166e845bcf04a9b00505f696ba816303293cbf296080347a06eda028405c7a8e146e843e2054ab88f938ff1f2b1490b0f534847d8d95969890239dfb4904a597975ea6f092e266302c3f00e43b9ef41e11b91d81dd1dae3d284037a4b877cb20a71968e4691a398df80f02d880f1f25505189d1683844c692f6459499ff61486f27dd42b1b83dd4e137df3995aa77508af9a1d18e1fcf7f6f0367dfe6d6726ad3b6a12b1b7f8e88e412adcd6a3bbb3342d0af27c7c2030021f94a12ea0d218f3f33327cc328482a91785927cfd4457b47f9518f0d1183002f9e272d99f8e63a827000ed4807b236afab587d7a07d47f1f96d6138833a986a5cbf4079fdc2d018afd8ad209510ffbb14dec7f02d38159f67b0c6d794602a783de229693301b77e866abf0665bf7f5e1d514bab0f6e4da9577d1299d859c616971523b758f79a2a963cc81cc678096ac828a050b0fa018e55c53f4b1cf92dc3415326b771ea27b0af77117c79ce5f3b2877a18dd32692441067d892a893000b3b9f1a55eb366b2c0163af858346c57595c11a27e44c46797e866fa78604d8193162cf1c7ba3896db6b1f1922185c7612f1f16ba25044573acdf22b67eb066989668e5c8e169ba787bbdf3e83383e4edcf7b680da2a6c7d53f45dedbb197e5ee611a9047d351048fad1bc09c05f65d52a6fdc2279558d72d4d4e0bea00a72bb93589eef7566fb586a498319913b64d24103fa53c7c95ebf4124eba46863d19fec772051bb332116f67c8083d5a3c6790a90012692f685bda2b455813646603443ce48b395857a3dd81f147234a823a42e44da7a5e7ba5ec60ded0f7187532be25340c1d0e890bfdcf5b069f4af8ae7b03572e0d1824ab2f2e4750ef09b09b8cbeda95c6f431ab90202ad845e1029112ac2a7894e7970a8d5d28ed02d32c0ca1891f8cfe96136a0a95ec4060db622ec0625758f515b704fa3c3d3e433f3c049cdb0fc2fb36401fb7f8855430fc66e30231147bb6af5155067adec2d0bf1a99cc46c39e811ee82a552d34e3b3aa0b9b2b3dff7d7b8be317db2af8ab4812aa727f9c0a06f8930e276ae6613ba471c479b434dcf5edbd1aebbe0c6e40a23d4e865c2e787e310ff8f60d98f8181e53bedae269cf6b49eaec5eb319710d5f553ede28163ffa42f0b9fbe942484b9504ecd683ec55acb0ceaeb7bfe929adb50d0f5ba627a0381ee010c65c4bd19bf7b9e5bb111d54a76d10146f8b52f20da8d19646723f3260630e2995f32fb3c44ce22d07656913c971a6e015817bc600a3f38fa3935a36cc0f66697b75e6e458796b561fa388f6a0e1923bc2d2a1280d7dbda4185a02668bb766f9668d807485a28174e9ce6870a989e157553d5d59d3f82a20bac359e702939bb69c481e3d1397be52397a5432e2855f09478232a7dc44aa4ae118653a05c83aea04dce4b36926b634cab339ddf640efd43c44a0f49962b3c67b316373c0d50d753a1f61d1c05f71279abfed9f07fe1a893b2f09a08708c7a0c4d432589a12846630617fc35ab6489fea00bd21742124c53263a763167d3704fe48a572291a8c0b751ec19640a541ea11545f519774d78c986465b80ec03ec9dffcee6082ce588feeb70c0f9462758c3cd032f2a5e8fbc28a25cdeb450786412fe7dbaaef921b5b16005d890893681aa8e91e7ffd6f48832239b826d6bc2b18e362239496855c1a49001b69c651e56e1def41410c0cfcd5b9c0739eb72652042d908e5d2bdbed686f06c62c3fcf01c5514d87c19840de40d76bd2c994efdd799fb9136c8c15380a95386162c73efa3b29f3c425c01c209423d45c8e9f60ff45bcac314615e55032b49bf73dd62288ee632d4584ec124251a5d56a71c7c9053af22c5dbd1e30c316f4c976192caac5bead5bc453f82821f3bc922a0390522a8c7f231d5a333228c4f9213d353fe9f2f2cf0621487e36899f9218d99bd92f65002df20da4bc4c4d5b367d7798f8397e04c5c6a48d48cd12f2cf0d7085ebaeeccea89a1e62119b6b7c295951935ba093836780e913941a2b9b2920ec094f111b87b110784dc38bdb42559d760e91af0cb96abfa6519dfee9442cc8937cb5fd8011ee0f5095d735a1f01f4599169544db100bd80776d86002a3b4534dab1093afd8033ebe9c280ce9e0826ae8a8ea5a5397342a93417c701e21e6344a6e0bcf5e2caddfc37325d0c08fa5449e3fea37a2f2ec29084b69b65bf4a1fe8b4f341fd315168ca3a4561c5037d116bd59f235dbadf665848c4a1bf85f5dc037b395cdd7b394f379be880ffabbe036358d37e0c4a0c81e9bdf96aae900e820290b559bd7f82d886a4d5fc5ba6f69eab98db830aa7da3dda7059649ce0ee84ad66baaec8f1f4c943c6247430533c92b42a946c07aed950b8f91339785b2cacd8710d5264d40651d53229f8a9027fce2e70e6a6f96db944fe1181afa9c297bed930f4a2db12a7ad26d9fe567c836c753543775e53a75a9567e5775133a0547eafa731e99a542fc70f377fb653de61cc8a03f328bf1ee17e808e2bb84e390cadc0c9706b904f9d14d6644be62ec54c60eab00bf277804cfde547fc20810d08c66f22df3987a5db646d96435140fedfb2011902bcb5647161202d7b6f9a3dab5c880b8ac89dbaf30c7959c508d85db900ec2b55567a4ca97035739f09c05f92cb5f97f84f5b4e529f9ef53a63f5c90f6a7fe457844ebb847389a30f3559540262e511272cc3a482ad926030673fd503e19d4ee8db056d46c9fd8a958d5712f530c948b12ad70b452169d2c4bd8514db3b033e47354f2ea2294a881f8e2b0c7c94174bd55bccd51417f4b510e3b0f47fef7027853c3e5940a13027f56f9c2813bbd4061ac3b2bc1898de54f85b0041f5468378177ab3b04d15edc6dfea80cda4eb5fef1d5ac40e7fcbc8803cde9f02acb6c8a09e46e8dbee8af88b4e8581311bb22eaccd134ca3461e278c1f0e4656c3b8dfb54d85041fc15d7d02426510c9dda14ec57dbaa91175396e303d65d79f213e9d321c6be1d0c0ff480253061d464a12bfa44a5382abfe0576d2b85d4e4929d9c1ee77345c02705b3b11005b200c84c5359acc30580dbf577ca9b87c11742fdbfa621d450c0ed5dc3e6a1281c5ad2e9b428a8d142e441ed2fc68454447664ffa48c5c46b35a62975b89b65c738cfc55ce1b59037d6ca0697396501fb53607348baafecf73ce3ee38f1daae1aa9d862a86110b69ee6b3ea8cc0951d7f2883a84078fb55f4fcdefc92d73a6037a1cf12294a9fbf6a87037008de54d9b0813558ebafd71570857743880cc4a3e9386c488abf6df6ccf20f2d43e6224f68ed0949ff3b2b426ae8b03eb39e88d9fa21ff134e4eb59507a8e9ae8050fb62e074b68a281ad2c68636636c8fcd7a3f5f57ecfd5ec5b17c03ff7e868418f53ec54368bcf77612f2791460a35c3fa10256f82f3cd8613948529a419a752fc7a346f2d572ac391ee6733817c191b4616e669599b5051547df836a0760dd6f4bd4a2dd5d6bf93e8aa19ebbfbf09c22ad85fde029650f67d5af45bd8d5043552ec10d2b3bcfed5de084c4c2128a31544d09c075d6536e24c4bdcc46312ffadd21e0bbcaf109365100ab69c415767fd602fafd23d026c10009b46a41c88ff0821a65ae7ce81bf3abc1ca704a4b2f63e101cecc052296bbd1306e5e9022e1a1462a9e2f79e0e7a78baf81ca6ec049a9484fdc0696649c57026d0f14f1a9378e173a9c6e73daba1d55b852240e731034fb227eb63009da2550b1a5731b548b0c567e0ea33ed25328aa28fcc05ccd104201752bbadbfa24cfd688e72abf19806ec03bc1d43118413d72b32fb649b41ee1ebd7db49dc4de3d6dc28db0e1e8e9a8b1a856e27df9d1f1a263c642a03886a3c8c6ae27cdec136ceae9328c4a648c5550a05773cfb6aa9d92472854dd7e0f035a9292b606d7ead51309dbb6835621ec93c2998b4b0048eb73d702699a83a41890b85d55dc4fedbb100b341e3a90dea47771953d9a5417f539bb7008efa101a6c99c259317442b1abff33cbab49879a5db1097a52a58a473a50b2984e73acbe25951e67724bbba039032fb9774598b723189bc37db5a3522447b0d3fe1b824b8ffab9b3b408261cc12155039411e57866fcb1bddfe47a418e271cfdb139f846c5a86c6ff12d41d4a265a0dd2956f8c68492b3299779d4c5b2b5a6050bafc744c032bcba0da99431a085648b7b7fb9ac08f326f74f2a710edd012cfe1f785ed3c3ac8b23bc28bc5342178cce9ab4d265225327dba3ae2eff76f58f70389ff64622fbc16b989be92d6f70346c36a631b9a21b34d73f69a0e60a05da46dcb7827212c26d3609807708b8e6731bc120eb50acff46fe5b571730c66f50dc376df96401107bfd79858c86d363fcd223875ac5401f84619acfaa1a38b23744cff18a98e5b50a02649fbbfd07ef430257073c2aa271f1cbf22453900ea903048b778388ee43bc58a8576e4d9c245b130f06a4c475520510f8356d7d2ce9ab8a1da1c6c5eaabf02cb5dc9c8e85a25c734b7d0d35bb831a0cd9b6c37cc8c2922b4f0d35b163759249e19878e1f86a7f1fa83cab68e0f0ed3060627f4cdc640c20a9fa5460670c1adfa3f91eb6023952806eae322caa378d2f45d00b156a344aa8b5475ea7091bf4f8f68a453d4e2860e9cf63f0dbce456934b0d09e68b1f4f96ba8a3bda24f0007d8c51bb33af2c476bd2fc4907217dc87cdb0b1e51974f3394f8e8a824631bc1c6fd71ae70715cffcbddee572f5394798caa00c1d45c80bc774f873e97e03c431556f09bbd502111ed0b55c4bec2dadebe54851a61ecb60390b30b1a40d219f4060c52a15487cc1e5bea2a525cc67b9e926675ee6ebd947955b1f636a47731bd0f69ad874f6b13b0d501cd46956027d9ee08f7eecd7804601f4b7911152e42a0579c984327bcb007d9cb8a821011582a1513f62b65021d5ff5a13838f807e66286eb254e2e28f92ec5344855ff09648a2a3383afb3a28d19e5bd94047fc3c8ba187953de2db1bc176e4bccb7e6966edae03804ba96dfd49936ae8b8f72432159f78e61779a560e75ecab098e192bbb689765891b2735fcc31b40961833813be841f946307f6e5c8d9928d2f5a676aa60120fc7d27c279ea59adbcf95641f8a461c2a8c9bfc8f2ebd30fed467bc7917dda6426814dbaa8649ddb3759b23b40233064aa493d74f357c1644e6b6bce3f8c7fe8cf42abe0a2b679330088878b919270ff80dff0e06b56ee7d180a866bd7bb8d888e5c73412470cd7e79506d4d74a70811ad5a1ea210fa8191a616a00c360e1b1f06654865009bc571f3100079ef3edd2a473e92713e18bd53f937ebf13376c8a817dd5b3d4aeb5dc083d40319121916cc842e4ab6be56ae7c82be9f5dd2f0c8e3a12d4748e658dd338a74c1234f05d7412920adcdcd9dd4d17a7b6eda518d7ead6a0d3b0d52fa8ee28acc1b1c652eaf67cf0569e76b6464e8a99999be254aff377e45f49eef39a85430ffb0aa59843f3bd4e67da751e440ec5ae33775606892c10153c958edfd38eca525c3fd832d757c561bd61db942017bbd8dcfe9e916989188e381f79a55c880d196d447d6703d27ddf409cd3cfd0a40bcdf66f4934530df0ff41a3b6e0e7994e03e61a81585e4d2cb13011c93463fcb72921725fc2f14e61a7a9ed9dd6f1c126cd0b61f33e1a9a1c3e5206602ce45826de3c07527af4188e2a028b17da43e78ce15199ac278b14f6fae036452e2c12e500d00209d07519cf0a4e57b35b364216dacd08c065e26fc9dc02da6628f47282ed291a736672bf6b32601cf1f849fcbe5b1003789ecb843ebaf42b085e8a87e397cc5567a55d29709d050a4ab28a3c7e9445851ec750ab7ef21a017384aa68c8da3b0f79bd66fbac1773d3a8ebb1d60a7137feeb3369d1d5bdbf101a4acb4bc50859ced3b12cfeac39051b9bbb44f6f9e937fbd8c94a4e59094322cc6dd6402054bacd6fb9b8f00c36aab057eb8c8c6697a3b8e635c092f6b2b4742085391a920822a01d10e29cf3465ec0067de08bafb4a3ce16d0f59efd98a086a6cc4ec2c0b960506a8b5bbc8417bc1cc7612bc590c2a0105c6a2ad362aa03d2c93c1b3fbf645e527022903aad98be3bcea830c8be497db834ff1ab36ab258016b9da3337872bc5be47af49dca22fd9a8240427250bdea481c47ea727c65202d38d4bab4f09b700a18d359e869b753d6872c045567f490d6e06f04a9c052474b3b41ec94edf885e87029b5b2b35416fa932de819269033d560f0bc5fbddd26e0c9d22aa053a06b57a6eda1ba968b7aed9eae3f3d273c9489b46e17741a3584a36a925641cac7d9a95e38fba487c0b837f1c2edf6d0e0fdee519e27d7897d62df5d1c104de8bc493f42e0c9c547144458309c0ad7db86250714772248bce0d1ee3c49d87249db95f28de3e729ed0078582440ceceb6493793df2dde1189265606238d1b8daa93e1a73825e9c9090e1837119a2be1b030c73a7df4e293b6d7f4c44c1939ed76aa0a3d6a0933a5f215de7c7b2a344877ab8c37e11729a91b1d0d15d02d61761338e9709e0b764d75d22844478c54363d5d2556c4af94e1d7ecfb129495187b50753f8f13f685a0d27f03348719dd197495d09932b75548c8412c30f3ea5b4efe647f400ef4bdca4743db74baea1f914a3f34e49036137984394c486ad0554e64995bff913c898d6b9c6f09627fb40f15e90cc5798742b97d3d62a98d681d748fa89f9a7fc32c0e680b56be2e7c8fe8c561c3bbcd3e7a1cab21475eb4f8a2c509718fb75b7e50b992c770336f6a6103f1dc7587b8c8cecc2e41afc0940c6b93a84a306003491dfe1001373312771d3fd6dcf4356b98e66d186355b8238d531dd95cde8fb70cfe9a3d97375b8819a7154ce39277ecaabf3d9dc23e84ddaa08236061a4aee5cfebb3283d4473f66d276834ee2e14980ac3a4d44f926edd8f4463ff5f1af338e8ec5796612b6001e635d0ef7a0c4d69e3bd05155696ce7e5c012aaa626bdbc9d00196793e1cf6b94f63aa3e9313662f7d2a55bf59ea116f1a8cda6449f8d23edc34e12d0b5cd9779636d4167f85116d5650e7f014028b2f3b90ed1eb83b652f3f4982b7ba7eaae8f8c44866857b6cbc1182e37b465a95efb8d4fd874b1a50285b948c054cf7f3e9ecea24737e36e60631b0d6f58bfc35591a3bbafc864a3b2e2c76da8ad9c98f64e8e541c42467fb1cae494e20911a9cace9b4bf7c980355850cc5fe708fd79b6119096735a6a0c174ab35dc1ae9ab6e39ae11c607d8abb7992ef4f87d2dde1274bacb44a98d8bf70a2defa749a1e2650ca7c1998b8d39b7fe34cf9a0d2f2a5257f682082e237e5f8a99710bac9b1906899779b67779a7c545203c916f4587f736be0b85862a6ce29d73ba7cd4bd7e3b1c485b2606ad2e227dc1ce87e53d152308ba2d0fce73ee3031528a7605bec8300c88d63b9713aec8ff39d6d34c3155fdee9dc74e99fd6a94cc83fd48057fbef2d92d76a6b7acf6f5f6262b963248519d91bff2f25f5b4daa9674b14f890ef0142327597551e827bd12cf93ecb875c6afffeaa9c9f6306f9f265d812d3ed8ae63d80ffd997a75a4eabe6d67ebcdf7c2cae4bc3c1069117490378a8f65df0e2f3c457a6850c4241c459464babe92b0f4342f5fa7fe2fd7448e88685914328d8abb2999226db860789f71117bef1270819083b9560b594ff9bcb4d2625062803fc924160f59453318aac0b4091ab8ed6bfc7554ac48674fab6ac6f1b980db4ed5b867d879ecce720f6a5547ab416528e425c59e7f699d1b101275a49d6f2d720664fc4ce28034423f5b36e4eee4e45b2b64cbc5c93e2ccf4541ceedaac66cde5011fccb91e7120dc8083836693ba1167b059f4448164fcd38b74eaf4ae3276ca2b27bd5aea9802195fce16eb4a835b12de7959859eaa2a85328b0f289c37e96e509fa08434ee2c69a2ea7c974226b99259f38fb185f6d47215a7cfc949f08b97c0425a9a89068669a1b243133c92548ec0a5a2ffd6e1ef73e75e1877730d54690ce1b5ad0d5fdb431bca1d120f261ad97361689b2c0df50eb154f7f858f773cb287284a5af372cbcd4dc49ea24d4dc68bbb33e9c5574298699d69664a5840918a891d54caaf062bfddbb68e39e9b5315c36b97b227fabec2ce2115db97bd73735e2c243fafc3cf64917a7bf3e44d413e2c86cd8a39536dacd1d32d7a97a824fcd5d0575d3987d5e78016ff71acf060d72d65e0380384a27ca52bd5db8c719b6d8149a2a8ce18c4397b589b7a7827407e17ec7a9f14c907af73cee4e28c41f14fabb460d014738cadb67ce0034f1c253ceab3bb76077449942c5d7968678292fd2c16b80d4e39c052a3afe73bb345bbf21d02baeee324fca5b581afd2a57ec20ba600b164ff8fff250319b37bad832a4c7731f7fcc9460f2c777ed46f6596c5a1f074b6323fb51c3995ba3eb9d3cfd78313b3cd205b86cc7a095996e56b2c27412b3a692f39b2b86fe762b7da7be49a57562d6653236958433410b9af4c692ed4b3b4de4fb9268c3ac824335717cf691d54dcc3a83b2b061ce76eab6421a0f555dc4f4dcbbf0a4d38d580f4f2b48dd569f9422db7f3f057900349b2dc52083ea82f9a4d78f32ac492fa294670ecea60df4f7b6dc39c6f3d87a97cfce055ab7f4819dd11f6fc027969dfb90b6bf47849b899f662bae3f9544251b60d7bfdc608e9db71f4d10f6bf0f34c1abd5313f7e546cc86ec6826d9e95cfb4c66dfe734be52a01bcead1cbcb43203ed7251c8b450313e51da3ae145e5b1f29260f57ce99e75e6780bf27e28796c504205a10120cac85c51ee2692733c99ae3383f2f6cc9cc1947f6908c58ff4b602251367a74956fef3f541d6d7ab90fbbf11a92f3e8fbb844b7a410d69ddda73842d8d26e4040f5c0a3194f4293d18fefae8a0f009cd963e6ba0dc2b77c8a5535d37d218756e136adade87bb7ec686383f55cfd291556b4478dcf43c84db80f3e47f5816977b8b337c15ea1a99a9aea2ab2fb3c28b21f30aba529766e6a79839a61ff6d574d067fd4d146357c6b4f87cae18a1c276d9392559eb33c92f10adb7e407b0854d6584bfeafeddae58d42a427d22ac01686957302bd70c258f9db9b5508378825a2a1f339cbb5c80006bd9043ba5b0d104c9cdb9d933c61fd990745d1e1541602f6ef59648c87fd7ee4d9dcff85db39d289199d122f9a63039acc8e5c24a26dc270a025f6a3eb1c5e67d3871a503399a383b04c90e205695a24f826fd658ccafc81e5d5f4f6b2eabeed3c17bf3590b5adfa43045d2bf11f6a2218b03da31715979caf62c0a666d5284ad58fbde43e662bdd1d9909da956a6f3e4441076cc8fa9db74f5401e9e5efe284660c32a2d9469410fd8542e62e891b5afb384a92f58f884cf8aa8b7e0967bf02c1e2e3d6f4d9516ee8244d17c081cb775bc43c966924b3b5e15a084c68162d6dd6c239466219cd3070ab69ff4a385b5e0a1050c7785f625cd78a30be02383625da604ca99ae95279c48c761ebbaaa5a15103a99b9cdcd6269ddd896c35654d3587fbdf597de2d7823023fc62fcf9b9eaca9d1fe4c91b8816753ab613d4dd4ddcd9cf86c62f80d5b96d0a7ec1d28baed2d92450d15e5c03df58bdd073fb219377b66c62189e739bf92613273e27cb83b39ad0e67bfc92135bebd0e50945ea7e3853c4ab98385afc5d43b51c6675e80d600e09f415b93f03842b08d2367e094166ee91445b12f277af57f0e0473c7fbb086091cfecd9dde62fc59eff3f1c6aeef941f64b523bf3867f17e5f054639ee326ba89e868737983f0b30057514ddd993a7d57d4a7559f4e327e46ebab1ec99bca50bbb2cf91a26c2e3d7ec618777bac8e7675425211b25f087bd878a62b6f54f8e8add06aebeccd0d3fcee714e465b334afae8289cf755bb509a057ab44d47233c20be669efaa48e5fd42fd7f8d9c0b6d34dfddb44911098797cf3423f9e65b74640b8162b44194057035f9276809eb1a0e153117bcb5febc133fe597d220b0f6ba01ef5e2f65b466ffd6d77299c3a4e2b482f815d0a34e1f4ea7d8564b7b7948ffbff64e86f516e3b45e8219c6cd31c9373ae0d96c431ade8f40a3fa2e41f7e8547499d6d36e870510f8eab19756ebe42baa2e10825c48cf29e6ab2d60926a4c654fb4f83d367e13e18a82d242f75d428cd044e842a1525a840e6c38e5fc5f1b3a118f8259f2414c59894c78c5659219abe372652bcd45327ada257745557038dbb91996025d53718f8a7f07977ffc1fc1ad2759ad3314c36e50e58463467bf163666dcba1d29ae6b1e6a98671aff7354e32bdea54b172faf1548d175074c9df006ee53b2ed93e56a1c205413e230cec37243f1862f4a7a581fdd37f816b1244e844e49576a70beb8a4ca6ceb59b3f3816c50ed91aa5f7939815f2fae74e9d8acf2f80d6f90fbeb0552ab55c4da670a3b06cec882b2f1f9e5b74900aab3c9ce612a626bdf0060042f87a6e7e31328f3ba167b7f41f04155055690e8e62e2c82bfc97138d7ba9aab70d3972e6d021fc96fcbdddd9c8327989e1eeb56944a9a6396510333e63b530b4f367d53c6d9dd6bb93262f604de7881bae5a1916d17c12ef8f94bef0165c8f3174fd868eb13088cfed1a25ffc57ffbf53fde6f59188f2e220cc2bbfcb2976ae31a99e30d142dd82f22c3f6a42817b2fb595b637f613760a3bef155d7509f3c3c895b4b1d76734e2c8dc6d806d06adaf7fc8f74098edd7cd09cc3f3ea45fc02acde077eaec85bf71f792db73865a9205f88ecd6d9e7e9bfc5944599ddbc21960d10ade953a428c981360a50581f79f2cf4488a1ef27a8a0470c25fbaff43c9e3489aba3cc1c6184f127b5e0ab26838155b7dd53df3a7d9f7b8248edaf9e35482528b6f51f846373ffcd9cef4f9745737499b2731e93c1883fdaf9ad25e7db5fa74db915dbaeddfb7fa659deaecd5e88d98e89b578aa62b1619f2a9e813d2071d18b675c53bd29cd5e8da2c6927e9a2ae8cb3d1f56951dc47e4e60d0b67e88dae33e7d300f7a1c8d56262ff693d76f8ac3cdd7e1770606b4b2d488920e9627814d9ed39a365d9a62f3ec7bd559454c5c4883d697f2665fdce14069551fb87e8d7ef681dd856f521419039b7c711216c6e98841c219606e60ab793246248222f6a3296ffc1ee9ce33f6d1c9f0a8a1e52ae1f1a38bb4b1737c813e48509a973ca055f37f140195d19f5cb9102a1c2ed642f77003b93cfa164564395f5c040b51a2782ae748b9edd8b7ff37e44ec8da5d0a31499110033e1559044d7d5581cebc8c7e10a14541e3d5da4d1a2d9222607a0b5b875e7a33993f8207d2c2dddd3542cd4b6e32b8bd9eb48e1b490386c2b28e7d249511d4c31360a0643d9769c5b84d11d8bccdb790448e170f8757c2d97fbba0c490bc982549d78c96c785f23c0b88577ebd6b8ebc7eeef270605971e9fe676e35292ff57803fe5f5db02a68bb1f78c1e6840f2bcb8f7ac8dc9c83bcf465504ef6e9274206e9e79ddd60f6a2d7994ffcc0399ab7909d5e294eb2a855e929160964d60a6487494d210b101f76176a26dbb232c6fd072a9ca29f7d9da1dfcd908a16270d82bbb413da925b8d0c14e99c7413a146f3b0aa35c549d601a3b587166afaa65256c37cbe04834875abec4ce1a009fdc70719606c0cf23bd9b5878a8c55909565d0dad3315a1252d789c9b70db73b8923752fbc34f087aec5108eeb4c6a5d3744fabdaa0941789101624fc334b1aeed2f5490267be3e1539d4daddb266db652aa7a434e7c9890f21852ed6773e38c7d7a535517f704bc280365cc74060becd10c237ad2312bf719b08ddc3d8d9e570ae277e33ab8e6e7c25168d220f93c343272c6a8e975bf84676d5dd68a2ec57233e96621b6cebd033842acc283934778730ef4243542fcd21c4791f905bb96fc75b196408654b8dbba5dd5d83ca08024c4b41c34ccc5bb0631e3056431326c506b29131e13e1ecbb3937402d1ca534fbe7d10930c59bff528354480adbb9ccd11ca3bf9c1bfda20ae14e1f52922d284d9852ecb194953c01c83cbb0d38f627910b9ba78a0dedf23b6fcfc341fd738fc9e64ae69fffa3379aaa1d852f25abd93d1026c0444021535ec6b542909af00b94cbd80cd04d1b05c301c5491d3b490e48711bda7a86b492e8ceb511f5206480fecf66d2668f82825e1219ed4945628218f804ff059684b1f13b118787304a3e86dff1a34bf01d2bab5da76039a1acdf702cee68fff2c949b8bae477cdfc9712cd5aeef079882fa50f51b9e87b4804ba857cdaed012ed35350ac879cd05bb9e85bc7a2deb250dd25ce8d045ec0548593e87a527181b8ac6462075ff2afbea1eaddbd038dad6519da71d9b1378981fc955c0bfc8d178afdf52f525685fcb7d423ab23daf0441d3fa0da3bcf831b307d1fc834cbc148f4b77b9f46d0648ef04c04789035e3101ae5532c0377b8087c5568217ffa9d521d982bfe7ee5b5047d1edf0847bb375bc5393143446f1aa31e6aef2722f767d99f896614aefda491a72c853e9f6a2d627e183fdf6a336087f2c26e85ae4ffe0cdac17b8522706f6b9d781f881bd788e1d90b54dc7086a3343da734be3560f7819edad520170f44f78eab3d3aece8757610374163aa802c8c266b4dae634d05da9067b4906568a5e3107566e30bdf06bf8a2c5e4dea30140caab01fdbc211eb8f9ec53c6254a8bbfbdf0612d4441747f1cb03e9c18ebc86a58d684011c3f6985a659ad37ef5d25da373c7e56f69807703ee24991574f8dfb1f66514bfbe9a25e3f0d93894782338c72b97eb4b8c0a7a64fd1293db24e7ba55fdbc78ef46812fb6ae5d5b0864c9b322793a768d98767c40a471ca03740b7c88e4ea3bc23aedcc0141ca714ac630a7318a4627f9255152b57bc2aa0b21128fe2e63ca75ebe3582f395236a2c36f7161760a5ee90ef7530ed8f7c8c1c547330e10cb03eda14da12e6191e3cd0e38272bdfce8b42a9e95925f93491ca3f31635bda247de9af8a4f1c6e2d25bca0da8e4cda8b25d5343db02f7ad4c12a8a32a3efdcdc1a5033aee2da38a6397bd82ae5cbaa869ddc7134156baca2a17f9ed521f38d6015e4ed51948187a60bc08a669029c060d5c9db1c384c774f4f07a4723c96e0afb3d5a55a8ce8122e830e031498c2600325683bd01039cfd1c8f1540109c9cbd31b91fa50faceef80797825b9d5057e46650fd41122c2fadc6658fb08c9d8754aeef65c64a4c52019b33b6505fbf10c9319e291c6e0abf1cea71bba01ea03f1577216c2761f7ec06264fd05aff2f57c854d0fc0d207c0bd2075e29aeb0363499da9952a05ecf307ca762ccc1381a40ea2da34bb9629b453380be3379559ea56a4eda7353b950ddd3a1d3a662aeb71be75a7ecf3ee2affb4e6ab29725d1b2deb1542ff246d35a8de43a7ff25c33c286fa65cb98beb539af0de2795c1bc102da66a2fa22b26190df0f691086027095c795393ad59fef6b3e795f58d125c542b64a48443c999dbac5129eb6b10f5858e7f7ccbc28470c77d4e04e8148c820191d46b1ac26285bc835c723b3e0d63386b1e809ef979f255fc7b88f9dc41fe19f2bcc2729ba788a5a575744ffff1edf8186e886da44a46a39902211c357e38c4f4a803ad5f5671b28ef15b8f1f05ae2f1fe5085013724d9cda196e0a2f32445bbdda5b1dde82ba7f5ea355b1adf7dbca844363ac84c5f18e2a9576c7e457acbee7dd69a7f4f37734bfc213d4b178b9bd72006a0f87a8d2ab704afe15602bba054bfef13b6e2c31500ddf7035c962bc9102b96e78a7cb62bb227d6efcfc916e7c67cd293d3d9b862be6bfc91d7556a3401e67a7dcf5a65c2f073895840634bf0057148f8f4161f163bf6c14db94835f6b03c54de33bf8bb7ddeccb6794e9b6efc2a0a889edefaf45795ff0a9b2198fbf185df88a2367f93f6c37209b5364d1c17f8100d95943a0498ff9064751684f52c002483224bdd9c8c953889017f096897eedec2996252f69c3155a63de9523a633841ff327cbaac6c6789bc817ac48b84cfc682fe880070e1c4febfc919f9aa07ca4165cb0dbb1d4fcdf98b9b6eb558dd13f80b78d8926ba02cca0c0e7dea087491427978fd51ffe844fc6c6f5808876338b329bd78818407b78c28cce79a89d3395a9e977660900dae2a909f28b8838244ed1efa6eabfcb6820c8fa997b27d05793d3e4bec717569442c2653ab333ad870fd40414ef3c83a1c937ca06d3bb48b98e76310e11bb67aefed59da99e771252269e58f2a73591efdceec613fb6a97908d8f2282429242dc8a98cad1ca3db0316cade3c678e4ebb32385c97edf88b1f3bcd3815673f258069cc8581ba1d54b86a8c6f7920fdc1cbb2e4004f0594cf87f56933cc9078065fae83f2723bd43203721804457ce02a276566947621ac2544fc01e1f2f51ed8350d9da6ad696c77336b446db5a9830a1607c0ff7b73be6d74f6f0142f89b42a58ae62df02564b33f50497ea97c6080b1b71cedb1b7a20bbf485c026b85311d9bddf3c1f2b34dbfd708172e1c3d762c803aad1bfc7206a4fe334131dacc49f14e59c1ee5109de45ca23cd2dc1db0052b76a583281ad3129fd4de969532792a70ab511b4d02fc63aacbee7bcfdcc627603ecd777d56e9344df3b4e6df570b1d14cf71ecc129ce4b00c9f86bb90792677d00549ad9a5d7c3b32acfba5c731b58405a97238df967e2ce73dd710329c045943f3fb32d8dbcaede89d18e56ae4cf141ec746f57cd84877964d510d478510cbd6316aba7fc420b131a7d6cfff4feb81ca8b75d9a5844b763fe08d4eb49872e0c508504cc5be9fc125f3e88ce33d03fb5c4cddf45d315b620a2ca6c24874220bf42c8d3586759e66792140c8ddae407031a43e630bd760c37e34f68c4357b616e8b6360185daffcb56582678a3584b305b09a4b7277925ea302ecc9e9bec4e0ab422700081ad6a0de634f97c86acf4cdd5d7d069ed6acce44f36bc4962f3e582b4650d561289bbaa4f98b14d0d4df7811ecb18a6cef92ce9961989801e4dfd0d92a7c1b85db311544fee7ccf7165e9728f233a7b9dc11411bae119a098947edfe4c3d8111379d9a3c86d84826bc852b7c27ba96cef93835ceda389ff15867472bd8f7e26091119cf2db82b924bc1a33bac7d14cd645a693969b793676f69c598bec107aa450d801057b4f9fd12522e3558f214dec4bb0744107f3515414cb14ff85589e1bbed4fca4ebc3bd7806266a4233610ffeaf7dd210cba3afb7f73a99ad378f781e7178b77818d196ffa56929966ba69a35d9df15b0165d6b679f03b8b5755e4feaaa854e9aac37595b18b61fcb16efeb813e20922bd21a2a6665713f4c4f79115dfee63b68c8be12bcbefcd2a0008555ff05a052f7a4171a827d9db97b73187e97e270a6a52dac3e99d9328b3ef689b517de22d7eab58edb69fd77876a671c00ed3286e083bd33578df785edb2319b03c1c227beee95eae57ff58e8558e3ffd4c8d51b7bc7a390200bfe716b137735f3a52d5789c92671ec997f670ee19b7b3090e7411e1d02349347c324ced70cbd2b80dae04b2693cff5336bdae5fa410d706454e963d87f64745050e6f48cdf1e2ee61d8e012b56f4084983f803548f8da19ab3960b1fe002a7ec35be4f8e637964a812de4193afaae029fd2fb79f2f90fc875c3137335bd64d6fa9e6a3fff2c378212cc711b66d5e9bcdb77b73e71cd1da8013e9282dedba6c94a752ec27be25069b85fee8a4e886418063a7ef734ba695e005b151cb04db3250e6691ea5f17f56025ba858b2de99ce0f537428723bf9555940e144755fbd055f653182f8f75ac6f551a0ea75392a66167af1d8863c6a1d667ee7867affaebd31e90e3c45295fe113aadef411f92dca209a86359a880f687cbb9893c466df7e669bfd9ef518f421c0dda2fc3e77ce42ac4cf0f6957bfb751c1fa86fc85c4c21135510bd700995c084840806ef8e81a238c433f3213e0f3fa4ef73af57c3a2a763ad04018fd42a436140a93d4f7cca2888d0b9229e895d67d954b499ebb9746d05c30e5344f8f06b543acf30db9c39cdf554176707cee4ca0eb3e0d27b72d7feb85000b6dbc22389b6e9b347e7c485ce031cf7ad95ef3a8aa313e45e58012171d5a566ddc1e24dbc4dd67f1730b7327d3548452b40b49900e1f98916909ee4808ead319d4d52d30e814a74582d62dbfee190ca2402de0c1e550bec6d3202ee81ac746493b0803a80b01850f276c37c35930d862da07507184db3bae80de2ebaf1a5dee84b34a7c97ee5d93ddc95e1da3ba953da42eb5f705cb796b817476af5b40d2e6333408da7a0d810c934cc372a384bb3c18603ea8dc1354adfb0c65536efdc9444b20d81700ded9bbede6ab3b66a5a6316c8964b360adaea818aa124afa7a994ab5b1ff6ad45701912b13e9edb2d9039e6815a03fafeb4d4cbc158007f351adae8fa62956f857762f6fee6ce3c77d18dab52d0d715f2550bc1c1a31f02e8c6bb5e4ee1e5e40cadaa57621b04017a84e6f94203d8eb1da1d0e7306a3c31107bcedbdf8d7b8b33d9ecebe8c51b49a130f57f923dba2e98b68863ac2dac6960a310e8aac51127637228c7f3f3ea2f8f8556b7883f052d95204041850a2e240e19de27a96bbff072efbf05446ea587e9bbb30dae64f3f7976bfd43105cb3756926514a83bf57504ce4b8ae940e2bec87b7925a8ce2aeb9ed71acaf7c628bd388ccc633b7d76989eb171a718f0a0b30227617a9cee61f31c422305f9d238b2f41ea931d1c61ce3bd5411555512e516dd02d13924ae69d8324dc5e3bb78dd1ef515d2cdc79cadeeb0f47917241bd3f6c5d0418f3735a37f3553b00c5b05f987710beb31ad60dcdb2fb2d7547edd278c682ebffdfae1fcd0e5c88337cddf5edfcc56145574e047cbb27003c87d238a49cecf264b76ac44c4b89236db69cf3b852c1bea303ea5ecc3979da73db3237af786294b0304cae66c197b55c7b2864ced32ef7465b6f3b51413b87cb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
