<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d0b69572feb663ea3012c8d305ef6be2de1c19558c8709cd6b9eeadb53f5743c85a1ca713ef0d8f0bb5110c9eeafcb79e320b989a32da15ce05ab225ba86048bd38fcb355bb56466320f24d9f058affba8b60d63f19421c46d005cff0eaed5cb2424df4c77c6f7fa0038c2b93429c7a58b803bf2d8718a0357c109d004f2b3b39555ee04aff04938780a4c093446b94830876761bd324039f90a5677088c3327bdad7605596a55268a5bd228ae3fd8385cebedcbe92994c464753eb097ddff4192675c77d11528811a77717472308f7e41ececaf073a79eb7f97511ac2882859e9d0aa1dd49392ec88925e01f3f5bc350498f88638b8591f05cc90533fb0c328fbb69e63dc05123b7fb3c5aaae5ce525bc490da8d9cbfc9cf46885803596964f746355e89fbee70d4b458d07746a1932df4cd72c8de843b84a887e8270b8cb9542fd911acb2ec36c7fce5b337926f3ee603a8b91ad97cb43b4c4802057c900ecbda7bde94a098397762b780f55b963a54e6c1caf164bc31d11ddbe02cf322f003367772cde399e58a4fe52b8d09120b8fa3113d9ffda909868d36d5d62c475d26bd71f6a090d5c3c6fe99cb471cf6e48ad4cb430d1b580799303fdda6d84ea4744408c573467f8717d919336253b282eb77733645717456a6a03aac25714f29fe1620c02c25a1b9f9203eade6269675215d67073d014d4bb573dc3971461e54043ab9a3094eaf415e98acb738aedbd6794b7aee8bb1383df978b47a88ae4c3a6243daa8e37653373126a6e906a673808ef905ac6ef108bc33158efe75ee7db2186565de8f04f9b08af55b1e78389116a72537ccb20c17549a8d2a2d26062a0a08abc95e544618a8dcb167a81f9a07f6232dbb9946280bd077b051e46551a389d7a3f3b0e66d3d5125faeb6e7f2b720112c0f5a845ccdf2c424f86adb2e51668cd72c6295c2a66c36589aebfad9b1cbc122585d84f95c95fdef3a87effd110ce548aa06f9040b64ab1d9be4a74e6e49e5cb56db5c1244669ef4830c2516e147b0cee8120691665df0c6b2e35c6562b2169a812b828f3785cdb8bec3881d12eda4099edf534ac1db23bf7d9fbcfad816c4f3086db77e33d2a6dbb91cd568196979efbfd5f2d97074cdba44998f55bd463f03759b6e1323b8e0bbc08126816adda970cb68c25e1cc5ef758562c76103c33611438ed3f227400760fcb1a69cd19b84a5c20d9c5c1953a32f4e06b95c2dd3b020cedf8ff743756fdc9a7438bc82150547407e46b913fb955a3efbe08a4470ec043d458cc14bcefe2ec411dc701fef757e92b75b5bd8dbaec615d7ee95c466dc41fe416f23b4b9caf8f2c1f8776117b1cc52e3180f7d0c10d5fd724e0ca2ebcc888c26bb87878ed0b7f00226e63393d81659fdd9f18af86dac40fdae1123537a485b3d5d3fbab6ab9da7e78e095526a33a55e5aa609a935abfdbf0f67e3a1edd40414ef140b03b3be26211c3862b12ebc76635513e237b0ad957492ce847c4983fe67300048d6a543070d56573fdcf4e4fd89cbf425eb9770ac8eed3f9aa6573818c328a89199936a4be9ec4ba0090f3c6cb1d01efd6c03a0f6e364fd1a1697da35747413ff5aa1822778160863627398fbc8a879db15ac0e828958bc8562945e2dd15005eece636be450f1f234f05b6cf44cc7e50cedb96680a78809c1806c7824e2d1c5c6c1186de0fb176d5ce1ee0564e48ca7b85db2d8aa39c39d6454e8d62b8e84b156c98b5364957ab2b527068b3a8724381b24773daf44ac730ad688d5fe178f263201abdc6d28621ee3c9b8a2da78ef4b4f8fceed458261cde43e218b870f6229fc4f73f82de8922d19b98b60567ed7605fe65c3e900d752a580947d7a3272dc8d7b573d4fed24fe5677c0873c99ed940de908138342e3260f2dbf3d69dacbefe5fd117abb9e419946afd1cbf3a9a2a0c8f57c561966823c48e8775177cc2e316bb71dc0aa2b81cc1e01f22b1589f749f30e7f9e5cd0b476f4d7f19e409fb5de2112f8d950c4dc7f8a0b6e964115e2a0f3b1094203fc389b9e95ef86ede06e8c56514ac8eff1cb4bbbc13ec9bc42e8feb8e08c944f2ad93e623f43a9f8e76723b6eede07fe740bdc5a6793f952ffc62d50532cf8c4cf30667195a32abca3bf4ffb8370a3536675185c804d6e28fd523f68bb4f29b75211ac692b2a19bb57cb0ece973e3e6525af30656db6723d8239b9ba8dfeb6754207eac163e0ad9aa7c56e74a10d3fbf1409d8aa8f76d95814ea7feda8b5d1d3122f5c6d65cafa9db1bcef24d86914d2cec6f5972316a5bf7dc346cb2c801936563c3b265629707aebee74cef16ea0ff7095c19f414a3bf10516425772a86aab4e9053fb7e2172b1ebd0488c0c7181785e56da9183810b38066987b60530c001aa2d6a75e197ae3f6c7a74c5107a8c7b9974e8b067b8b6ded5538a4e44b3c661392824da41f5229d844afd15c3c0f297dfaf442b374c7bd28db2d5a121949aa867adb226f890635e6e6ccf110b6e58978aa68cf4e2c81835688221e5c3700efe1739bb79b4cd04484285252882db8c192c6d210503aa9557ac905b7ec42c764177fdfb808d82fc4f8faddb05ccc365120fc177ed0df26937e9c9904a6e0bf27efd6b8bbccd1bc552772f37b94a037695e3ad8bf2f7fc97749b88a9b7a23f85355b71f42a4590f35f4d4c09a5ea15fa45fcd9c387bcf915d60f71eb9965e076a8561c2ea42237b3ede6e9e4c7c54a0cea77235645782140ed60a5e5784fd2a1bc2ddbb49409a47965ea7c3863ea278a39ef9fa1ba54261c4abab05f8a48f632ed9617249e9fb09bea3c494d44f6d0fd3d5cd001740fd023d0e1d1173118402ed337bd6bd5b5478bef5faf000334efad10bad3018a457033228710850c307630c884173bb60363ab1afa9e1cbdb0d1d7ad5f33687a51bc415ea001401da236a35a6f459addb7122110b58c218bd42215ef8756fe6d1993a6952539213a16cbe5f755d2afc427d675de7a5cc265aa5f57c50db72ef51224dc12ee344670a10fc7bc6e1e0a494791d2c4962784fe84b4edcf260c33f2fde20a9add4c61aef80074987430ceba413823b3ba91a5d159686723c1ae7b99f5638e15f742ccc1c5f775d38589f523a928c52ddd95234a826a0be4a8588a5b419ab58c6f474a4ecb09d860e0f40235d066d4b6ea8befc690251531953e308fc63cb176717cf596fdd7c8ff28423c6f3d809fc2e8c0949da04e534c3cf01f1b23931438e10a66440225bb46702ebbc40393fa51b774db2ca2e0774126ccc0dc342915417148f75315842075de5cb5783f7ce33434589d299f695d4b1c93df004a0619d85b009b7c0ab79592a15d7b3adff0fbaf6e273e3a05384ebdfb98f8254b0ebb4e1673ff7bfac2185ee8310eebbcac80886a62a9815dc635eb860246f6ba85e4b11d67e3d4edcf339abc2347250b45bf112f45936157c51bf7b657d2521b4654baf8a7e6326a040e8369423900ed9e8d2d5fb4bad33541cba12e218d1ea05b5969b0a3356520d88485850d7d8c199d03b3ba30b085d78849afc5221c89b33a4b2910180015048c2e1aacb0f00f85ebc1ed7194d012b93d98cf7394a8762ff131a5c4787f1de81a43d5dc1d6998e15cad9f7184ba44d4d924d306771972e77c471006eefe1f822990bc3c8ee1afcbe6dd27bc9e3a0686f9f638288d23e8297492533e270c0fd06971d637833dcfd82bea1e5b00016a25f99fd56ffbae4096439c23e9d4b04a038ad20b794bedfc211eba5da56857f814004137db90aeac56be36e2451a0a988fb93c364c9c1aab82a8caa0496da58444e30c3523f9b193d13701e9c5c9a105964b9314162d33fe628aaa0b0309789d2364d7f705ef223767efaba09fcdb588f7083388af5db71083a712cac7fced8c63b9a5c6276400bf5fb6a39d070f19c320d554aa50f13d6bae2b7d1cc65162b396f60632b7cccc04ee84b01c387e2f653f9d82ea38c73f6102b1c0946972678b479d52f3f95e1aee3249c05e0defc9e3ab6e4e9b614e6f0c454551151e23e6ee66069cb9f5f287755045b3b664bf9278027ef1e6a9fe6ec01e9bcb8aee86dc7cfbc164003723573553b8add1425920b34486eb5d4b54abbe4b06c5630c46139710f15269307eb8fbcb802bcffcc9628d78181f48c9b28126d8030e4a825f7a3d87981f7c3d820f7673dcd95b6a3fcf39b6f16a41a71513551250d6297cb16f635592613533abf7faf1004096511ddceea2eb9ec5a5114c8faf5a06298b29ca15fa0f291ebc9d6016568148e94b850f5c9c004446c5167bc710fdea1021b8d1a46ad29028192e493ea163980fbcdfb8067d4cb15d503ac25c4e3c0bf6784d956266ab11f0cf9e17eaa0ae5122df8ff39100a331ed410a05c21bb22bad227f8b3f2694dabb09eed471cf80398efdcd2801186381bc0ddbbe4d4f2b3060f4844255fe907a18da96f354f75d2e371243a1a9f16cdcbf54aac4aae421a6cdd764a417ff3f376b0ff54a7221d339b33195c14f6bcd676aa3327997c3e81c3e07b52c099bffb7456e128893b16acdd933143f4f002bc7c4526e4c0785118fc772654c9180132c0c4e7ea93b380371c979ee06000f138072613534fee38c0b280e3d1563a70fb915a9f8900b8bddebc3012e328d2bf93b85dc84e0ffcf2e52b8cb39276e6ccef7f077092c43d07f544c6ee61c7f0f1ea451972ff75e436f80f292c9ec227f4436bac8dca5f34d3b48a97acfe5b9e6a01a614c9f00403da85d293fdb8ce79b6e39fc8075237f14ad270107b8fb98cd1ec35403cd1c5fc2294dbf28a7077c3c8afc2964a85d82b6bb6f9a579f518f1c5427c7fe05109630a99947d797772683fcba89edfc620c06350b45c55d055c44fda3a34d2b00c9e71741ca43bec82cd11236f653125b62f85433a0c511ee7f00c420bd7a1fac99fdf23c72e3abb36ba00a9bb5f860939355bb5143236f71619516c09a5cec95a2473ab0ab8e3da182517366ccb692bcdaf229de10610ee986563a076087a62a940cd297f5f999b25d7d2926638a5bc2cf9206413a0f0eb0311c80f836e061fe9b0d0b865958169f34e8d4b086e21b8d366c281ecc1d79b1778551a1e672bbb71f8cdb72bc468d9309fe7841eb21da3da1a32e8f5f404a0203822fbc25c9ba3acdb1f76283275e9a60c55deb7ce046ffb3e77652cb7c1618b44061063a7f42e7c21b7df492239a57f97e26232416325f24a777f78e7fec2250bedd690057b4a8404ac86efebe5f2b358b389d0af91b4744b6fadd9dc71cfdd27572b153d4e5468bbb395607da32d40d2617a37cc28104b60e23410be0fcd08312963829be214a661a6b002476e12cda2c48b3f5a99dda2fadc33dca41a9a27da43117a176e8df30c1d2bb1f758173da709f8cd4ab157340f1e4516f70bc5a4f19a600c3f451d1562f1c0bf3389273775dcf269a14dc06585e02cdd439d3b5b265b4ded9fbc989aba047cec3d98c36beb5eb5519c5c0b4ddc3e888f056045e984dac2a3ec006b82f333dfda0568ecd8124d18181c746a94611a4ab7e7ccdb278e55e6e5791b27a744a1bfff5fe0471a4cdfd34aba1724be79a2379835f62e6437848dbff7ef4301bc4beb829eb91f442721bf26d76ce0e6fb3b7afae4c59a236188b4b90de64161e6813657d137575f42ec3c07f87b294a6d999ddebf36750cd154828959dea9f527ceb6a9823aad2ed364026f3e4c6f60b1885d24e24e6f7c216268bb098eaf8190b78070da1ef80d2efee6ba5d472b300e77c949bb32c87d6d7fc3c205a1976b77b43078db61de2f5790a6efc225f293afc57f0052c231b56d10b1a3aa8cbd4eb2debb8336a425a036f03768353b9674409e347cae3570301c4cd41329c18ee51a61169e776bb3b510bac13cee5e8da4cf7cd4887177819e2607dcc34efb1c245854fad20202bd9df146563165455e5dbb58be88e6a34336e7764e1c05afb1674f4c60766d644652040c01c2b6a54a31295853daaf4babc10535e56093d7e83a2563c40ebc30d28a231f468f4b89cd9a7d15f8f506a1a050594f229db86c03cc4cf2919129921f968927aab241fdd573a33b02a1dbe8bcd01b694a6fb9270452d376ec48dcee7fc7c32e3ed075b0cc0fe709e69d63ce5a5bb0edbca54dae01e0b1e80e883cb051eb2c780958e913b75a736f2c9994cc33909b191f3dbab49f4759f6b1e67e3f6112fe5b580642973132ebe16ce42e942d75e0645c3dc8abc3f1021b7e1e01b3bb555d61c80d9077d8c8ddac6aa0546cbf0658648a6b92863452a2d415dbdf2854d9f38e4707da84726e592f4c3ad2dfba8f09dcec3419839401a008e1728e08422fd4f80e9ef0dc89cafe8bad2044c6065dbeaab7a17f923e774e05e5744d70ee763da14a8b3aa2bbe4fc026fdf8408f724c4ec6419f2aa654901360a2c3e85d00a3244a62c150e4c9e658c91057e14ec1544e65408d23ebf8f58b4a239d3f2037155b9b851234122174adbe9379f7cd1d943b84d4e8509739d9208a51f0cf4fbbd5e47c7055d48b73947f629fccf490be103e7f101d3ecc36a7b8359899669c04006925c568f21c1ad4f8a9e94182763baab780ecbeb650156e82784ecd8616e9f3fd4c4b5689fac733fa38ea51ce1395dcebeeb49ba68bd7212d41d79d01b079067fd1d589a2c0702338d057ba2fe919e2d0e6275d5430bfefec6b38745047f57bbadbf67591d8565b7e4acf57010e7530310402f2de8f0612eeae1cc5d5753a0614badb72f83bd1d4cf49b972ce167851dac4a4cb6ddc35c36b9760ba721a59ebc95c0e88483f44befb2501773f9f2491b007f71b05da013624390c5c2b53f2bc612a5f28f3c6fc02e7482730c559bde19b795116cbe382ece09d369144305e3ad0659e21d11eaf4a818d37a75189c5c99f4fcaa92a6785f6139a3f0e4ff2dcd50d2b874024b2e4747b5f2c3a883e20fad981efdb951d93fc14844dcf1fc5924987434f078cbed4081eeee7ddbbf8173e98265fc3000839b771a575a6db99a03808450d1c191faf082123100c5baf647ad562c7f14a976be63896c70c2918940485bf07b27ff9d4d2d8cebfad8023ada08dd48c098f5023906d85e8e41ed516fb33c0fbb447ff318dc929b8f4bfd198e052b9dc2a5748df3f7cb51979d4ec6fda469c98a61985e4f2d2436e9a4aee97bc5eaacdd4647aed41e73534e19e0598b428eb21aaf498e2173dcdaa7e3487c3f6212c00315b30e2432641dbeb56c90450e8c89e23bd554d035f016103449c93ee142e7cc8a5f220d114a54bed3312820a7cffdc456b7ac4026add1b45127a97b0559eb9a613a37c6eb1369cab37bc0929802b03f488cfb8daafb0cf77466e5e7a2b7f9622219adde85c525d8dea7fd35b402daf6fe57d53e8538e12474e119466162a2788b8712f00dbc6cf45152957826947f3d258cc462f3f0dc92f12c64ca95c68e0301a40dd19bca3ee898e91f963405dab17f093811e5e8667c44ec99e275fdb877430a5af3a940dc4df82532af51dd7d2ac7e560cc960dc42abb342e876719b2a2f5cd82cdb4be8e62299605e8a16b3cdba2073974800b6dc548dae5b1a2e6e57a5de0914a0661532e7dc3640c6031b41b434d7ce308ab38cd192766056b04f556bd4da5db55ba4ddf99c7d9ba32c0435912b5c7b683e52bbf95230a3a6d17a93a0d25d8711d3090982e15070a88f671d2856fb342b6327def61a4ea582d4c4722f38061e770792b64a80e80bb18b502c9617fbc8eea1ab5d07e835bd5399794303b08499e64b5e3af9457cbd1534b8334e97e5f372b5b2c7df56aab1980f168fd2706191f88c9b0cc4d568c355104c4cc33d733c44f8a1fbe00390e1a9032e9e64373f545743ffd87b1937663e29a372dac83a3abdead6a9a69f16a672a75580fcb88f6a15ffd13fc18fb3a6cb8d379798d82e9f5f14266fda2491e717d67adb0e400d9a564347c1f2a33b032ad78169539993685607e051f66eaf5153e908b0006bd10b26c04d456ece6fb0189b8ff9495b91c4daf25b9badaacaf73a1166bbf1350ee9b435c80decb61de5cb04475272fab49a7a89eb736000a50c20e9503115dc5ff5eb0320db99bf4d0d2fb27977ce92cb8d77b79002624759e1efd05010c75d28f7950b51b12eaaab23273d216f80414ec8a129bbf5ec0ab30a22b78b9b40a23eff1c5e8aad5db7b5a77f16545e1dfd1f0f98b06d99985c8ae4b6add425818f20c6f370f3734a6a1140115bcdff562df5a1d84cba4f4c36dbddf16e774de76985a39004feb4a63c739413ab34f0c0f1c5b385b6386252b4951348b3a8cd81a57213b891127b47c8880bb3336340bd5e79e1d171e5d7bb0e39316e9169632e10ae39373a92e7f6caad83c507fb2677a2cab5fb942b25677a11691d2d05fb2e7cbff3865b4f9a7b6f88e756574b551c782b11aa8371fc144cd012cbf5a8ec8cc55eee8451be4139e68ae5ba999fc46b2557873e15cabe2cd4b3510e89dc086fc29ab7ba285c3d7c5b74d0b958fd8f61d76acf8533e6d7dc6d3e52bed258c434c2bc1265b3d7310ddfb4853814eb7fbaec21d09fcea321c52d53e28ad284e8aea4b2d903e20c12c6ff6b67aa7c119f0aeec6f381cb065f9e9940f1c72fe358e7759ac8790b95040a6555131d7908143431e267593487cf6a35f6e9cea02424f21eaf92d7326c757083e68bad7fdc9f9f14e928190bed34edaf467cfe6d8f3079f884940f805e37734107a6c5a1c5e0ac911896ab405fba5f1173b0f485e71752acffb5cad460a6ffa49562f8b16550ff53250239266951e98620ed2859cdde291ecb170e01f9e77c9e065937e2f04984c11d2587563406c4d9883dfdd02e8e185df0f9172c22e085d551fd7f3f15b080cd4ba4ea8d96549052a8ab5b3c95724c5cf3a4b434362fee2ef018e350d100b018bc0b814f0d17c5bfc3b5793af588a9d11c0f39465a0a8e5af732b8b2cb4878e87a392e515eb4171c6f0ab79ce3af0ce2a248cd908222d40c1346e12bfc4b09426a3e8eac2840626db9637156978da1068dc3b244a614fbd61914009415bdaad3a4b36a59e42583c5a42388dd302d34421ad46fa1f88a32c40856691612d6f2eab874bd877890db1be5af98b2a2e704b5187ab77ce98218c5423d9c927feb6d00c4190541a16a5c70254b1a900aeb23e9057266a71411ad933d783ae2776a849594162ccdc13d1c53c665347e3a2a449eacaadae0362b839fa7022d3c46e9e446d697fcf2e9d0ad338deb25b745df8b51d23cbffa22d21b1e4218be3db98a0de3f7e45231c30c29ef2e55be95deb4326360e29a2e1f92eda69f2def8bde270846ea4cda5a810bc1813fe8c52f445f75d5330e1b70675b906f76c280f23a07aa07f201da664ca7c318a67348bd756ad6b51daaf4cd0bbdd2890be776dffd2b32e6d9c6f2d3a8ceb97d286d558add1e75f5eda5430f7512ace421cb9ca3d11dfbf345322dd1a411574bfe44a19247ac6992be386881afbba8f253382e839823986e29f20ac576a39b19fbe53b27c2b27069a23bde35f0ff283855c9eb731b73b2d25a06a722607224258d41aaa58dd7b80d717c7e4fadded5c84eeb0476b5c44a929563c67817c49d9e129a36d905f489c833e02265cf4ed7b17059dd415868406d4273b833ee1313e92573a9b1b115f9e4b8add72f10cfce9da852a5fe0c2d4ba84037f88d32412b8d22c0f87d328a435d4a33800f5957ee190e995935acc70251395b1238d25fae0455de43445be4884ff8a70c729eaa8085ff62c71c0d0b09fa20c3c1af63f4a04917a330274bb7553e2d0fa674998605b7c70a6b383d6f617d9072f37bd3106f2ff23d4877823183f4973ebf0dbc62fd7b37142973f5d34c1c0d9105680c8346a78eed041b04a0744606c0ba689dccb2edd384882f0421d85a44a6b594a8e61a2546eaf4d3bdb07ed93073ada9f0d570fdf5fc9af59384614374eb57304b6c58d1cad9896f0fdefd06d019a2969efffab8da79ea9e897977ebe807edf25ea05cbf8a554a8c3ae5347ba83c94d851590c5a1d81612aabbe635c555104912372cd0bc7e98309dcb37a8ce770a5faf59cbf965115998edff337604a6767a7d6b378603fe494c04d7091588373ebddfb92b8b56cce3df593e621dbb8a3d0b57246488c048af3c3bfb4a86f82357648cbb7fc30e7196313c4b90aaef50376bfaa4e392f27b0ef5dfb4283b82cdcb726c31a35dfcf7fa009e30d28a87bbfa151ab4aca4c1a70100403e4c83800bbb91a367bee3d7a9ba475d484ca854158be644bc26ebba33be917f8001f8c604f2ab7bf2ad71d777ab1c36a6f554f068225dd529f54cd1eaa84fee22e49b02a8f41f3dfc5c4bfc642d8086aba0be6cf098a6f7f47b4d872d0ab991c22afe9a35be008b3050976b5e3029bbe51357d5bd3d36d10a133cc7702e347cbde87cbea759dd834944234a3b2d09183faacb231a86cc649bf9d837802f9013fdd21f9b1c0a3e0a70e3af52f1bb3fd5f34696b529ff68480d067a12d2dbd4d407728bb476d039f893112a4ed0f34c4b46776a17ccf9175872f99c70fe11e3f8aa7248d214417f46417f782675083b35984d4093bf5e577b91e90aa0742a4900833b141d6c57467255181f2eee746cfbce362e76cbd3fc972d704d69f2125804e4d43d3256e7fb6f34fbbf095622228336e6b9591741d3975ff74460c90937f623fea9028007ab430d61fa57d0b65227f6f2e6d08e9a3e59d251a3d15d145b2211f885fb585b1af0a3087d06ebb9aa7d953ef41aa99ab7ea18392cdc620230b757421f7402a773cb7a549a40d42f78fe3370073999593bb631e2fcb0ee4b13a2e1dc396df6cac8b1addd0746e3fd0494b5a74cb6e460f05d2772f41fa6f1dc961efea356ae2a5385b805c554f3ff46f79eee2319b71ffca36aebe9977c993884a2578c48563dd0e662d2d0eaa43492dce63dfd467ebf13cfa91d02ed3e4b3d3213ef4e434ad525fb526d51df8d458e5378221d954cf13518f806dcc8037748c064f51d55f1b122feec42a37dcbf1cb15eae035f36609f0e594d58fafd312a049f5225d8f3434ac516aa0fc1511b2c575633c3bf49137a91d2b88c82587fdf344e9cb2207f7aac1df4bb6129bcba3023bcc59d5c4d824dc2fb852f7af44ad8f0497c74d7d0d5d4d33075eaadb7a4f432d44ae6ea5816ec83c1f85d7e9b25cb582f41f39cee825e2040630663c763d2e4932af841d8f3a5e4e44bf39750eaf9d489cdd06e4ae992e143d677980ec99ab12ec051e66500e38ac9e5c67843a718dc33fa6d2080fd893f2e5dbd52eb07059cf5fe28959969b39c32633bab2d9c1d8e07d5e5676db7a77f60870ec92a84668c3cdae608ec3425bb73b5d037fd163f6bb90c6d846936d8e15aa46ff6ce297c168c2fe5c7197208e558f7e67fb7ca95981870a21ce66a3b5f213bc21760fa22cffe330a56cd05541438c1a39d66a605ed73a02ca3ee0b4d38a430226776a2debfcf03edb2ed562f2d1eca9ae79b59e551061072c855d4bf5768734c17f8f5ea12b53f3165e0fb165facc2f4735c40f9d5ebc8f55910575916875a99e5084f21d6a3f11eec83932cf7e6b222bade1c80506d49b15f748bc6a1b3c17edd67734d9df55b244e5ee3dff6e485b7c3bdd4135c00b0a47889e877c578c51b0e6e777ee7db8db9de3272b90d1be0e66857c86f5cafe83b867834149ff3cf0b78c4101e58245fb6b093e6f1997f0511159f3bb100d1fc52157fd6b797ec8061ac9ba739f0c9c22e3709c0b77c3535d413327512e5165cd7fc2a912ba9e73f5747f08da62decebac58ec60d62c0361a5a8e4e1e7b4d7f43a4d8492df00cffdde616029115d34948b34a2c3b11ce4337c0af30aa1807788eafe884074455c861172b5b27c90b24595a1c24b3b70dc602f1e0d4f674d54889dc92a32dcb0d7ca832e0c93c09cc6f219d47cc2743656a88f54cc98c71e7ec7eb3e6952fefddd1ebd820c6b71df4ad2377dfa7f645a185dbbcd141ce2b805c1b3142c7ef99017802b18319ff51e6de0699653a2de8165ad3652d178d2c6355efffa2b11820f9def64c9c8d7b6a7aeec2a1eebdd5092575aa02887f277c3e693d2960cdc81f8272716779510bf6b89b8a0607dbb60670ecee19142c0fb9a4ce108236f8ecf5ac37d37079f7c5888e9bec9a1e5a3511fd1bc24d39058dd7998d1b71bdf33045ae0c68aaac0f692992b6d9c321064ee23953cf0b2b3dc01df10d580e7bf09c73580a78bd871dfe1a73d312d9503308459aeff9a2ec8975f7de7090b50d6cb0d7f41eabf6441d6ef27c94ad346f178b137b7bc273f4a31dcb1840272ce54e3b832ae2fec6706feec90304bba241c5d0faa38bc15e4c365ae3b4dc3fcfaa561b8c4c472664a09748b3ebeee379c5c3c5338d3a5b51a97a7b150349f438b6d7e29acd5bdab64ba0d8eaaa7bb114f189d2e533072bb32cc2ea58bbf9a6ad0bc2cc9a8993f4f4f30b140a0b40e8378a497dc852997da0906edda23f926a0d5942b8d002d92415d14abf241071f91503c31852594330f51fc4e3884aef428ed4754c672f72ea381192d242088463718da6d5f1175b86ada955028c56f1f207fe7b36d6420497d085b2b851b698b5bc767c35b1e5b87fa812ff774fcd74bd8fea172ff67dc7f3415fc86c06c23a6d750df1e70deda0654f31fd285bb19cc01992d88b9ac93f4103fb185b0bb02fd529f58e0b470a4a1910adb8a27d1985700f4cdd1ee944fd41a1bd308228cdb84a18c89a09da0c19a25aa6f58af6db61818bb5a61312ff0854f9f521285143fe4ec3edd86a8a5ff326e1ed2c2512a1198f439093c638967e93920718a945d941f343f85f958ccae1f35128f03b22d84c0bf516513060235a78a64c26fbdb404d8197701cf9d4764acf656b3eb4b60b8751636f56799566ebb2e398a27a3d4e353f1b75b5961508acb8c88ce3ba833ec3ad7bdddff3324c5377980d35cf83ffb9191c2bfbb654b8c57c07dbdaf01b155cbe8187175e4873b349d4bd952fb34ceab7947e607d6ff8d4835f045a691707a92c111fef93a1059023879be7a395ed6a1fd88f215dc2e04ebab01b0834b4752f08fff25d40834baee2a8aa297ed833d2f6a46f4895391c9c45e982dc2aa0205a4ec30881a0e07f54845a2b7f8193b47d7e5a46aacfca382e069bcc8f08e136fe3fe74a662f3cf6e983da021fbdcf8925251bbf687700a96595ae5431b05aa26bbc47162c03ee7a2c70d7627e575b324f56f99ab63e07e418101c56563debe87fdaafd3d8206d660b8289f9f1168a11541fa2413e4248c772a8f77b4c77af4620ce471b84a23f42f6834444edd9f8aea15c6e8c6cc5fd30d152979d9658943acdffd7a76d9c7023a1a537105089cd6657c4cd6f8678a8ebe3b7576d0839833926b52c24c0565d42b02f3f7bab8cc680ac955826a62ee1ee5452dd63c9f21f2647fbe0dccc8f28a6abd8f9b131046ea94ecbb400a388c8e99612a624c6130aac349c206fff1b92691374f34ff9dfce3e2addfe44df6588f68a12043d2ab2caae9fda3768a864fa0b8c1799221aa8200fb0379803214a4bbd0b4aabc4082ba84ca91b12d5e7ec208613d544eadeb73a08255cbd21e0e278ffa4f2b358b190bb28c8c1b0d31c3222bbcd67b82f067b2c8828afdc3f6ecbb934e603fc73f204a60a70b25b383acc2e9f3ed5346955dd7b24db81b526b784f2d9d56a5c04565d345dafce8b13043603562d4278365d822994ff5bc31dc87cf65ce7a1bcafda12584cf66c15afb38e4fefa27fe01c74033382e9b3a740af094434ff8233c549c9382cc1ee0a8028ec955dcf316a8df98a9ecffbce9d59b901672b3e3b984c1dd56aea1d21acecb397c13dfd19f5f32403e429c7e295f1cc828032152e7fb48b912253b0b5ca1a0f7f766bb4acffaa51b5e94ccd2596fccd006aea96c7adffc2f760c11bfbbc957bd9efd693e4b8c4d60b566a7b6044e18c7b441f5c1567a69acf089c9b0ed26bba365343cc48a5a18e87fbdccc006baa2633261ecefbe1767daa4b775733065c3969932985143a0227acd91eeca857951152376ec5482e60d5cd3abe67b595925da25bbf4746b95aea64da0be391556a7d09b5e1ae4c878ab695579e9c05ecfb053b5b0910f1650e8900e257379f7d4ef9001a8f83aa050c8c882ea1797bc1b81d248e88a2b666490957b853dc7fba431d4f11a6e526b1674ec68b1e9f118957c425050c113925b052ea8d8cecce21694fa511a48eac84b73ae6476808ce6d7a398de01abc1e0fe577557d3cc3ec9f46e1e934eadc2dc6dba4fe3f818c4ac999c5d9aacd3f14626ce8f57c5696ebcf46e24d8985fd5d1e1099ab36b80f3a9aa46a144c3d0d96f09455e2b212314d926fd117ae94a6bc1147e3fdbb4433ba013d6e4acfc3718277968ba36798f5635e817d632fdf07e8a2ff26d492dd6a3246036040ad1372a6fb46f5514fc77ba6ad61a50d9a8ee697e2919d3d01f2c91b508b724d93b2a8be0efb2696c517d03e1ac666a0d2ba56c46ff346e020d6e2b0c77d06d3d1e31b97f4231d80f13c41faf04ba218e9c209f663a2a8e8b4793f67bc109b01b1b8cdc36cdd266d0dbc90ba9fbdcf1e5090e7490b6fe352f7ce38a9e4694b5204ed348c4eeccc5b894ac8a7e1cfcbb7179d333c5aaf0f435640f2dd49cabd1136c55b09c274d16eb4448f26caf203a3694d7735f40a6bdc8d3a502fe5c193d1dde7a9699a157c8f3898249ae11af6c9ccccbfc7ce501ea2ed4620c95580d680de4626cfe7e7e3b22589b9c60f41ce6a62cba04d6b8dbfd495f9fd7bb315b5cbc6899b5c48b395d35e2c4ec6aa3bc1a9cf9d32391766f4e47f77f4af54e8de539afdda8badb9e1024de9392d861694b1598ae4ce488026489728e96645b51f76658b2754f791da206c005f08c0035d88f62a74d8439b1dc22eaec21d2b7dfea3064940d0a34b80c16e488916d2508915f06667df9fbd3f93ed1b2d360cbf9d23202b1199a21bb7dbc11fb6c19c33d942964560a16a1ad1a62957479b9fa4f96a4f1011b8480b14ac43699f95bd5cb15dc1bbb01a172f77b2bf532f201f95a7bc7396d7b8cd49e4637d35ce3626e4a58d18ae6fd2eb47dcdc0f7381ec07c6aaffc298cd680f8b705db339242447812b752c9a15e01a081da7eb27ef47e73ca361e448e2c4e2dc3983565ef44e59111257af8203b0cd1ac02bf6578f72aff24928fa22a8587ef019cea83a6395769dd8ca90eca513c37f7e006e9e80580b49e330847c2fd9ac61fd88f09f25aade3611c6e6539f49511ce8083f908dbb9d1f2cf02e705268b2d73ca7342cc01a04f6b889984307b81c350f3bd74b34609b8e3715577ba7241f385d95fb27b6b4f9f36cc715d303b0d6772f32f220b8179f36e646e73198f0a72c35d8d48fc4afd92d3767b7451c5d60c0ccd509474d8138c548f342731f440f8323e979db737f68271767f70bf2e8e37cae9ce13333bef9c6e00bc6b303fa093a7b3cca3a321a5cec8d21b63587b2e40e506acdd7b6807f772b84e0f090de0b0e93fb3962f376fde144ce3d1e60e6103f9545008e3f898250d765e32ae74792030d2162fbbe9b62d13dd587ee077ce307de4a730ab787211c63e8d7ad4455920564d9456825bb495068302daf9ba3e74aa352768de5fa344995a4934f1ac43af401d6e843b48b6e04a932fbac9c636cb45ccea3e2899b144578268b0664be9d6306f54941a36a66074deb0df8e0a286a029f8991be4ab340ed511147bfa9f8823bfdfb0d4455a2ca8b6a30537a997114b4041ae7f10196f8bba986d345d4955a2b9e7182bffa997ad9942457969e909013347f2a1563270a6ba045fdf46e54365b98647e262c8e36a7555eb298521f44ae47b8359ec8764c6d2b377fe9b7400537bb32aa00a439edd9872882fdf3187e62b96a54b350e620696464062d519ef6b9dc4b96109259ec2f1a7f23433816ba20143b114d3e49ec000e4445f196fb6cb3f2e96d2328da24ee949aaba38635667cd40c18a9e98016e8dd3b5e9684d010f4f6cee881d628c95964564fa22bbb9622e206ac222e0a407e626d5c6c7bf7ef9aeb714754fa222755579462488dfde5144603ee2ddbca896ac3cad50a66fa33415738bc40f86bd6a45ad7ed76ceda6b0b6913d6dd4267c0c0033968a9f0a055da5c3ef09c160253eed746a10d96b11e73bfaa85104842ac8d0d137125e877fe340b41ddc3ee6a9ae8f04f905568438de2fc72d12aeeea3f45059ec59cbb4f413b45851b588f13211cc98a4384fa643bef82f0679f0c037437f323a3bd4a1b993057350178fc889f38c1684aba24428fb0a7191018d0a4d1e0f00a1cb788d8404a2478367d6ffcc04b69151190816e1d1e966bedf3eb4b6f3e35a947ffa682ec9a7efffecc418c85148c3136cc765313171655c61e56e1b6c5b9421c98df01207bd60e302d88a135d23d50f95aff8446fc7b98adc283d37a3b7d69ce27dba4656f376d0e745f6e20399f87af74216804d052b1e38b9c5d44eb026b594f9f6e072db9965584b1903af947b7ae1e2cf43608b6ac6dc4dc0886d53b4e7cdfbef8c26da9f0ce304cc7267d26779ef36b9c22e380bc64908b5543296f7f571a44b441d976ab7fd51b4d721e7ef84fa515ae25bf4583f845450ca13ce5d62bd8ce725400d499ee0c1ce07f377222aa8586242258fbbef4087dd2fef4457517d32ccd7bae0bfdf927223db9fc0d553bb5f5efa78c70803dd4cbe3e167d2506ffe29ac5013182761ebabf8cd9779e45fdaae757249b205414dbf09baed86d74bf1e4e41586e9b99dae8a4b806746a43207afb85d1c41b726ff9ff2cf279adb362b6797fd87a81b7d9983944fb4fd432ad5ad11cbdee87be4f053702a92c4142141fc74054e462d623fc13dafad4b35c8a52ee15b2a3e513dd3b56b10ed56662e29a441d5c01a8fbc0f9ddc40702678fd04c2ff20918860aece373d3f1f89fd6fe4a8baf7ea965835a7063277fbf00440dd722cb4bdbc99d358312432fc1d549dc5ae5cc7ae1e1322e5e0c4faccfca06d916cd54871d8e1953f839002c6b194c8a049e3ec22dfe6ab574cb17a0d97c9b3f3016e70bd1a9cdd7f5ed48cd25800fc0e7945dbd9dce94a6d251525c8683b45662b7249ebcaa82b09e408556ea36db783109956a3e8677cee3be34709ee11d3e5c6ee0cc8546d4a7f11bddf4c4ee57c575963d97427d7ab010937e933be627ac123d3f9de7dc9b29344921071464367451294eb0cd31e31973c9f913c65db17408ffd1c3a2f10da23c6eb041026e3d9d52a56aaf9f5f48c06758e0a7ce5431f420abb8d7b5b4a9d45d0b34f885245fa40d00b76fa96d6f1dbf6694488df06d422a2a996a3f1f41fe09f78c95ea03250edb4c38f39c2cc910f8a6bfa9f7d9dd411567ea07fc2d7b1d5ff7c08e2c531e97988dbcac36a44adfa5aa84796b424921db005813f791b7785acc04a3da61efbd6ce3b019cbaf8aa8f1918e6c052f0a377c9f184b13b08c7a220efffdf0b476ac93546cee698452b157b1cad125447e9b2b81bf6379e253d643aeb7daf5c114f1de4302b4c02efabb6034a4accd6f5702a4b7f865617cfbf7e3d3c3d04d1956fd78383c58a2ccf427ab4a6d0bab22d5b7065cbeb5a7fd510728d4c1068df80e802ecc628207bd92f3dc32a4b9f4fb0dd06a51ec55e04d560185100a51a6c4b1186f33a1a20acb627477fbe835ea60f9a17406ebc56293808add8da2cafbca748b38b8b0a978453ee31f61746c421770aaedbaf7d5ecf23c4ea4b564532ccb8eded46f9a8213e6b03baa3d8639427f2e0c75a0ad5b563bd456df1c20b5eb8bd77ae57ed21391475c2f7166de0b77b295951146cd1ebdeb3a324d6ba337e0d83a0b656ddf856757ef6ad88ec1afe8aa6a1b40d38b828ff60e595a3267deadd50cbe34abd3c3b44ad9d65b406423c2f3bddc22","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
