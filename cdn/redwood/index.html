<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0af1e20b10ebc8c2e5dca6ac09c6e5a552e786782e39e350732364b717fc197a7f53eebfc04ad4cd61a2aee3e75487f48f7b0f42d281b75a6c57d50e6b8360bfe35aa590f340fbee583819f104af26c7c7e6ac516d49dab97aaa1005586186aeff5639c3387b495a88900e69b29cf481aa98ff25fd53e1beda8e3506bf5c9d7ce8797c4e97fc700219a2e9e8d71b88fd7f6ff6348c3db338dd103b937f3df8d41ff08d50ec3db61cc753905fdba95e5154d5b922f58f609f94cc5f0d1c3429a427049a774e45bd2a088db882bbb2e7c1501885252b7b6a02059e7becc99e169dac6e0f22e24202bb9976eb4c7cb5265d58b6a0651e04413bf02bdc132f7a654dad56981099805e8b1271a451962f6bcc138012f9bbf17c2e6ac4340045d082e884e8f51cb719dd7959bae0255eb7fa3f479ad3f44fcdb5167d2b99f11b0c791f132d8e0a63352fbaabd883daf03cba0738aa0b0f43b3ab1a3d63a58d6e250245290b245b7c13ba1ceaf43a672472a6e1f8137900efce4f5562deb0b2f30a705a8fd5021e01dfc76da3de6458a5dc182463fe6234637c7e4ebe77f453ebc4d7a70489b934c0585dba8f85f48d8013680fa0b44b1bb32afbbe955c9c74ef9347eea6d402f49758db3ac0ce8798f00e0a1db10700dc6b3554d6b43755b7c08bf0b7b18b51838cbc10ea318980fa7c1ea40a1b82af6371c61744202fbd7e5927bb9d32610275d78c15baaf9b9e1b68f78fae696664eeb8cb0acc232012ef923bea1669abbbc66d790010703119b81beafc55c76aadcacb17e88803c6a6b273218c9fc442ff4f0ab9217978ccb73571bac236a68f1ca6a7916448bf0983c859c804b868830646c620ddb2209acf1a9aac0e0ab79bd117a11d80bbf7434eca158836d6086b0e4bd5c008be5148493cb29335adf1131c6a34a5cabc1bc907b14b43ada47de428ff8f0c6fde922638049787594062ae8e1f87891a2a7635ea53846ebbeabfbdefd5ecbce253c029bf8600499bcbed178c071eae5f28f838bd4ea393d8b8ff4350eab271f1e74bb036da9005df3250beb291e6a93bd03da89ca998d5b75f94f81dfc38732302d5eabb90adf0c096abddd1436ae9bc9183e06875dcf080dad2719c877ee8d59ad9850791a67e90c521632d592901495644b0225491383b8fa1591786cec699f71e898062898981184793c5007ced766ddba785bcba669e4c67d7f0fc09de78b82664d6b8aa03a50d074685779ee63678385fb866e55377110ae58de55486207c4deb6d1b42e74e83c580a2c6e9640ded9e773205f0736156e0b46b95d941eceb4a6d663a0bc30ad993564feff185bc7660ea245c7bf74f4976e872127f1f6ce5ba350a68636cc2327b211fdebd2c48e868d84aed85c4a8d170bffa69c98fad54b433a958ad7b3ef728d1254841c35f517aa4ba46320628be3916b1d6d8828ece20bb2e33512db3e40e154b2be035d78e9679e39f9cfd55e2dc456e9718d805380a6a19441955a95803426c6b32ec9fa5bd1ea3ba2becf151f646065152f24079abc0af48de03ec9f2dfc3a3f0a43733bcdb5eb7c8d6563fc41b6439affac3506c04d064814a8112c84ef8cd7a302e638c6c93d2a39605078d0c26d14235ac22ad02c6a81ae9f9df2d24a73a0390c91980a3133010b9cebf5df328e8324e2deb8a2dc604abb952382793e2c3747b5f9a414b78d71e38173b070d04c6c8732d9f3d42c5ea493d87270d2d03b45fd8c75cd291d7335667cd397aa65301d4f2739027d8c00e08bd58017c03d84f7a3f624d646ed4f69c9a7791f7e8567295bc0911d6a615dd876bb34585f208fef3b6482190af47c0a3e4d03d6db247c0d30ed920c81b8b0d49da18bd22844b3c2b07255af2d1ee54cad79e91ed02b0ef82d37803466bf177d092fda05855ebf74a63d3c1e53fe725042240cf5348c7e5150dbb057bf954f21f82a19e7c157c4cece9059db7223021e4b6799f8dae6d81f4b8a3ce4e6250233b5d8afb529df4436fa5218d7720ef74af32f7e0ad9fdf6fa747be56a9832ba7ada5b147177728dceffd74d74cd4ac44ad5cb1b2fd9adc5cdf12862e5203e9a2bdfe9cddd54cf8c26203606def81b7337a9e94de433d8754705c0ba426f7affb56c7b4f43a89037c38eb10917169970cdb34233732f0fcc74bc7955dd3e258c04d6261d95ddcb2aece4eef7ba4902c93ea37022852e395a447b0ac974c040c67c9d841555e7689e658e2b4335e152be587cdc348ac89c0a96672ae824fcb2ed890d614590863986acd0e9f38d32ecff2c2b0bf8192a01587ff64777c1c088fe74e4ebac578212b245123d12ee9e1cfb1ac989364b2e19e3908edb6511e5d7a05dc5cc57392d4f9c66b468df00443c017b74cea3b234757caae543cfde338328cc8c88802a0dd1469b7c961956a2a8c2f5bf5b7acb42866a36bd30f7a51abd9d6f6485b4b267f33c585d7a9f35331664cf513d4bebff78f9acced269f63a7011eb68437e9130bf63585e26e42460cda5dc1ce64303be527a941f3f3f4e47ed2227ce96191586fd18906817a977fbc89a88c409d37bee37ce49b6b86c7566a0b6b7f8ae977fb64773647297a5070d57583cb3e6c7d7a8277239b919be0804db61b317b5c0ea3367fcb123a94ecd70ae47493d590afa8de07ef2af74d7cb0d562137b830a43056eb34b7e56a1781f76d0a976d34489ebe90331d71195fe12d8aed88935760caffa11be3688ee51c9f6c24527d3b4772ca79711ac03c16864dd618619383bb9b8591bd103b97216ea9be84b23c60b22cac2bf8f775eb97000cbb137704cfacbe952f9e10cf92e6927659c0a797bc8b6eed8174154c0322b146fec4aea065d4150504de3f8aa1553ee2ecdf657525326979f3342a28fc99e0e8de3498deebabdb83b4433ba8a56d6b267b828e8df6258070e548f2ab34f28bb34d02436e54f4d3440b81092f2a66e0afb37412f6b36a479e9eb4604e81dafb8e8052265bbae77010032775cd6793caefc99fbaea214822390457ed988fde9b2dc0f5b0fa4a1cafe0aa472f6646dee5f3f16a0915033577a6a4f924850e7e08526df103206e0509ce6b8346bf29a4ce55488ef2ca97c34b1f9694af3aaea278a1ff1ef600a18e850ad36d48e2638d38fa8830d1315fe806d41773f45c1ce9812cf40f7002a5db256c0f587b6940504e589f7d7a30b0f0ff8007406f6722ba5cb740ec1255b304ed30afaba37ff291b408c95bb0339ac1db7074f2bdee72f1b634e2f231168a96c07b735479b534f9a96d0fb7f56a5c73c4be8dc35afe65fa33051eb466bd88ab9413866bc31f4206a4d4d59f99a97b74d1e0fe48ca1e777e50ea1d33043fb21a04165e02db79b5a8cfdaea68f144a11db1de97e8e8de5ae591b1f0a1e01f6cf24538b45d79919eef63a852825bcc0f757a3488e19d245b957cde123f335aedc07920d13b4fef8b5228bb32c3fa84c8749f61116f2cf4bd2041430d9fc450968b3a027594ea1bd65311ebb91d10fdd7f0a917fff54989d2afe6bf651144ac1074126b6b6045f9e0cc93628ef95925a025b93357ce3ae3cf72f5f2c4493fb49ddc7f3ff75ed4c8a91dbd36d7e778719dadb20de2124005862aae80d97d5657218954b0b45c3a939d3608a63309b942af24de3415e06483e5b09d7fa2e0561cc9fe9f3089e7868bf42a320400361b75b789a12e3d14cad5fcea8e8de98ae92638773319def72c12eb73480481e7baa435159ca1a80fefc47cab6abc72fff025da2c62a2dfeb0ae69d8e120d2ffda7dd8db2c1a08dba8e970e10d636fc3002af2b9889028273616bcd53aec94ecd69c45dafe999a54daba847ee012ee96513b450d50d04769ab836795a7039de5f4df307f0146e2849f81f1aa19fa34487f42005753497a91d27e56ebb0055c914d14c4fd2d4926678831eccf59f26932164359824adf5f912ff6e2027f5164843111225b20b73bb6a9308e117d33530c3af5db9872a007e52407e52d4259a3fa16ec2a52f0797e367adaf2dcfddd71853a073d9fdb909e6c0343424d9be48c18b071962f41cf92921d9a69c7fbef7a8eac5c44d197b7e95882bb225a1ca79c7da8f377b2fa3c41448de140f273c89b7e41e5ca1d589ffca02c3671cf1b61798c89510ae113263b00831ee7ccfc3593fbb8a099f8fece91a1b3c4f5eb697ea9a9adb4fc10da0b3e37e92492603585f2800db28f985b6dc07e7b9b8b16dc246d631bbea2e2ba9df5bede5da1310dc4aff72c4eb5460b141a46503472506bf6c4ed06290c4615dde140f3e118987048c29127bf47904f9dc2e1dd7e91ca0050144205da87a6b889df9c6d49267ad3cdd0eb3a0b87d473e3003f1e000025f18fd4ba1fa3da5a33b36c7ecac7367e0665b1ec0c9a266829f69eb6e4152d20614097d8585744f047342222c4126e1e50d28bee3cfc3695f7761ed8a26a8bfda493b2e1fb5f65916ec96c75e186ca0e06696fbaefe1d22b028a1152727074952bbb3d6006ee771bf5149d9e91065bba5671e531ef933b6d5e8cd6bb059c7e5c9db39b2d20238a268fd76a73eab81ec8aabbd2913213be115777aadfec33c97f7108698fe2f21aea32d276180071e199ff46a336b8bff3e2103163a447cc934a70a6f30f8a1c8ef434246655a4082a08df1f8f058156bc2e811602c198894395816b894d44489571fed4b5b04b59c8c2e782162230e402e0968e97414fc11751fcc83da7fa2cadb648b29356574ab05d240f5f4a0aaa8fc68d521e4e6bac129ef42109f09bbd550287f952403da0cf068337cafe1050b74dfdf51b91217c4be76685efd9c0d631db4ea3e565455d32867f35b1c1e2575b6f1b72d8995001ebe56ba77efce25533eb1667b96f1341287945274657e023f3d92331cc156faeb7c21c7fa078b4dabd1852f010da94cba1b29528ac5a8e481608501c5b18a93c6d5cca7dc3078e24cf4272995cf3ee82d6a2cbb0c149a0ee07ab27a0aaa79d17ccc38101110191f2e541668ed248c2948cd968854b13ce59a0c241df12f7ccff16be7176be18e9be0d74e958f0b2f631e0c8de1c7f80cc5607baab97234d1e49fc8612622faf09f33e4874822edb57d3b27364fb4fbac6f3b42c53635852bc406d4c52803e5ee9d7a3405637713803970a758a0d3a0cf5135135ea2dfa0964a34627c8b979ffdaf3354fc85cbc626e8390885e18a8ccb8c026926a3b9340639a4daca14b798701dbd61e80f1116333148ba7f1ba31d75998f1fdfabf8bfdfee5a07879bbbe3a5bebf0fadf6d6563576cd2b7f45b28515c97f2ddd869c9836d93dbff9bfed65bbc3f12d3c9ea999b309dad9eb24a1d1e1edf58c4b890d603b03b3189e195a7b69cf44b4b1d8fb719586e83cedbf7ecac5fb10e53c0fafe1eb8906dc642f9e1a104b2adf07ca7d71f5fac5d50605ef132075f466a6575889d65a6803eee2963db783ab51c67f0369478d8315f1384cbf9b69b67009600a758fad9a42b796e83871fa9b28565564e777199b9d587fdaa8870d9eee3f8f7df8ecdc90d25621736fe59ff32934f6084c6627a85b8a213aede3ec3c91efb23d716c6b445af2fcf38aa2e89c5352d37a0d0c53fc5d5064fdc01e2e9476e330eb9783a8d2c8e0110085b77a1398096917cf02efe1510816c350df031311d72e49ad618949ed1ce319c59185301a7697dde200e9c390a33c266e7fd560fc8fcb33f63155a0181ec077aa6bcc9166b37fbddb046133190863dcfc8c75ae3ce0499ed6692e16b0e675aafe98e592db6f9eefeb5b52c8d6409dcab58c084d18641115f4b5f458f2455c86b18316aa100934f27a0b6d2f3a5bad209f1c460221764babf3bbb659edf2a09dc9e14af13a2de53b04cc75c2bd68fcfe357067b41fbd42013242c594b89a527c3226762023153549ca99cdfd599dc672dce1997c8cd9937d6dd66870ad7a65c03b0e49a5bf574bab86062bfcfb6616f37e1dab81440d5e7438423085a775b53f920bbbbf60f859393bb9f5fa51b6ff522770c9e1cb4a6459a84f1c589151df7a445bd6452f79c9ffcbf3aabffc63d0fefa87dc4e35c97a15adc57dfa771046ab74b91dec48f7a37af038044fb6ee82cf6a4d887ba607829efee743546bee8718b16169e783acccf9df9d27037133ceca9bcd90df6bbd7bcab5a650b40d64f751fe9f0ddd298cc74179e9fa4e01cdcdbc36e7b506d4a93be709142fcc13bd63067d9729d00ac6689012a15ecf1f25d2e4bc39e8a0d3e8a6b769f3e736f47f3c1e6b23a4e4b3a24016840d1cd3b046b86681e04332e8e887b3b2e4db27d7fe8b29234e82c5415c226a689062008f99148b35808ce18f37ba3772746831c234df88bf17a539e1642b951c7032a90069d5c8adc023a02711a51fd9039c45d1c37b4a17e8f7c27f2613fd3d9475df7ec3ce807f2201a9a503cb0b272c1e85bf555c514d0f3c57a8114f00a344a4f403d3c8ea5126175b50f1c16b68f1a65682675d51611a7eb9599ba152c9f6c3073a5fada0bead4939415f2b3e3716bdab2eb05f2ca0203af82f2f59839256a5e74ac7545577d8ee3bab56c71fe1db18e6ed91820231f21e5aaa2a1bfa986143fd2057be481477db2ab9938ab3ca5b5ffb11d5831ccb1726e9b2147b22da20dae74eab0fa2a92a76b618206edddfe56ffef8e4c99a790e6866685a8946e8641dd7aeeec42cdbceb1b02d9043cd5babc56b2d82707436f7228a5f798e811f897d1e584dd088726246cf01b2acf04f1170515ae0dcc703348b24bfd43fa555ec6fd8818f6b0c40a535f071050ac4ac7206c34e6d0c45ee40cbdcf7094fcc5427a9f0de08c247a7fd48c0435b35d792571be3f40510bd729342130081c23072786cd351407ff993883a2cad7f955924531b1b4af2db03ec393488e806f4fba4cd17d9bb4a98b40dc3a16ca84a8f33a2b5a52d229467b9765abd6f8e1a79908988c1b77c6f419b43b8dc383807a560356b223d1e08cfdcb3c31073f65c537af770d54951a5915cf3673acbea42ef4e33b5174f908e695aefc779908f897aee55db048f8bc4979a34ef0608dae2c53bd540ac34e15cd9b7aa2afd8a185f4ed0d84fe6abe82ec0cda250d668ef8722bac929dbefe74999036571c9a64df0e1bad52674ad692bfca8861d49e5433dcb635560a1d49caba46408e2ba842c5d652aa2818b63058eb6eb96638d9e754714649578247e5aee9e8bfd97fcf55e6b571dac5ee1506ecde5323af2ae20e8057b7c7deff08d9612faa7c102a52a427ce86ba0f166c9bae73206a833768bde6c3a1eaaf7b74c722794b02c380b4d23deeffdeb04ca1ea82c62c5d5dc99feddc156da18c9105d34b919a0cf5aa09e995483f286c7eaee0b8402f3d6bdc728f7b4b81013a512610a3d545df2de156b97c2411350b94752399841c5366138267e37c3f3b984a2ac86aba0823094d5b868b94da015fdbbdedbecbbd5a1b6981d2cd50bb9c093a66e9b7232e94b8e60ca66350c48c781f046415f83f0d403b102e14f4af7129b2754e3e524a15ec7ad0228c048825cd4cab85669bd95fc968d66770a2e2d6451865ed8de3de5bb1b54e3a1b1953099855180e2dd6523d1d9ff4b57d06a767d7fed7d1a856d5ab3669a20d31ef2231922983e5d2f627b7e06e5a464992db58ab7b770244cfd1ae2f9413042a2f7178434219ee149f48de6d7fd427cb053231eca7b6c541f5229e5d5e37f53719e45a497e71de124388ee3bf676ad1204b9f8afecc1c91a96bae1db61c58127508921cab202071d3a34223077e28ba881d77568162d1eb29b359652c4c074250d33f35b5418c369f47ebf9373bd0b62a5b5026333bba442cbd5bdf6e04ccd2242012e779c2ccd350a97dff9cef132f8962ca3c3b45d2e24e539e0d6075e5b7dd58ef262b72e84e4944a5c954bf106aa6c29e44d3322fd3f2af11ffc3bd33ab6be3f10dde171e6efd0842df6dc92bb98f33c7e70c4467e9285cb70a1f83019a11f442b8eb40731f5629bd4abb31d40bf9aac373b573617286c25e8d6476e12e89d4a68145d0a6e55c709fdde443203ee454901d1bd3babeff524fe47505ae3a74e703e44fa0e7a6f5895c65f52c15ba3ca585b852d997078239242446252c24de4ead2313797b5cdd80d075cbe588cbb5246d2eed8440a1d1f0fd3de611accea9aefdba334e4749a1570f21ff79d22a878c2b0753f4aaf86f3e1bef729dd05d33464b90a0e3a7abab48d8d986b2a0ce4750748cbd1ceed4c0ca87c4cdad25ce57e66c5de4fa755ef6f71ba8b5c918fb84d9dc5a4054f105d149b10e102a511022231acac02c41410506005aecae6bbdad1df426b8658f76e03587295c9ccc0855b8216884e961f91642e0e4b8b7849315dd379265527af4db83438027836246339486c8572ff228ed51cbd8e1e4eb4c3016f9dfdaf6fa2635ac8436a1f83659866a5a28d6482ad4ee36abd74f873c79a301e3716718faa162b6712e9012295a5fd0d4dd8129879d39c502576fe7562773003f8187b5c856165eb4ae225c24dd5f4642831d3e5d9874ef79d5d91dd2c974b00eed7544ca29b1750f87cecd44e7090ff5af02d79f04172179a88eed8fbd3efc48a2fe3edca1adc25f915b8a124160685de397de064381a4d69a7d62aa3da0a85edc36adc2298749956587ed5dc2952cc99d47780a97111bbf35f1e9bf852c723dbb60318eed6f5a62010fe728ee658bf8fc8f5e52138f478927304183445d64738012d144f6256f7a80e73d621d28c4ca8ded9e792fe928ef949feaa6df64f4a6ee7d2266b5cbda8d84f0e452763bd7c8880859c9a745ea95e61a24797a380e3d9c23a1eb41afc71e32db01f8c580880a13534ca3541db6dea800a592712f3425c9481a26dee6746fe9ad03ded29fedf8427fb7ec0d4c72867d9f093e4633cdb3ce6991687f59df988f8eb28ba676a51e754d6db9470f69a75f2bd36af3a59d5785d11ca0a88510ff68ecb577d9f902d815644fdd483379472c50e9b2135c38afd7f33c33e51a3186a95c5cfb6255d2957e1aa34da95f6c5b0992efa2554396bef8ea886a660883debf797bd8c8ff87466c125108395ed50d7d1461ade756d489667314bb08b0133b9c024a5be8fc980b81893cf442029abfa85421784b890b8133f9052208d382393b0963ad844f60f82ae025b4995ddfb6c78704c5fe87f32d909c3c879f602e6958c1df0ef111aa5c717051da55a7351935855e1ce9eb159269fe119d02e9454ebf56a7a5355703fd2132d7410d9dcefb2c5be849d2a7fe1c72d15f9d0688a24b902f9d6de49ad6688aff7c5c405e7122e0d86480324ed53bd6499b0410c648d873821e23bcb46f2fe6784bd5c7923fbe0e2c3ff83d2858d8d12cac38e77bd4ec5ba3223c7b46fecaa535d767912c70b0b98eac6f982bcfdc0492f6ff0f38b25e954d82c74ba521c5e39bac7212f1e6865435ecbf9d2c24f32ab1b3c80f9f1c3f860eb4c5bbd06799f912a97653608c378344a211dbdfd0c35aaff3ea1d615df3052772a82f762922554d5cfff9d6ec1b5ffa05f5e4afc5198ad978c1dff928062b42cab2087eaf78675113f33658f6f0f628d9651b52efa7869209b4f2b9af41d20b48bcd53be8f81eaaaeb27c9e72b2bbaa5ba35603df0f87bec7f3f6fea84b2b95a01ace642400a8492cd93bcfdd18fd73d0f74c9781249004d57811f8837ffe11377af74decc287e829ab16a24fdfe64e78fec96c60d8bd733253acf39c7ce8477ee5267ac8b63e4aa4e11da14304b1bdb13d0836c43ca0da311ba3fee484a3568314e53407414d9d176d76ffb56dd27e651fbbe035c91aadd48aeaaaa6c875a81466433219cf68114f127d7e04f57dcff9de71c80f064f80b4a62e336aa028596c497f8a354eb493e100986d7a501c2d65d8fdee53cfa5a4684bbe18d7692331685c1851d1b60f105823247ea5312719118c14be0825765b3eb02d6882e918056a1c53b414460679ef9179a59b3cd95a2f38f38a7d236ecad067fec9b3f6f54751553eaebea1528e2c39081288905cc8e4e8c044b37bf6ceb6db2886b15d7f4b39a9eb8cd16e23a28def188cadefcc0d83abfd8ea0dda077e8dd61c382b67361471dd6ece2c713949b993e3cc75af71fdf40d031ecdc7a1e9395fd60b363098d69468930b86ecfc489eb750b1a5f720a587dcff9ac2767a64f198444c0656171616485ce79c1212409dfef8e9dafbfa37c3dd2e0b51d7212bf97754edc38b21ecdd5021887001e44e77bcf1b09e6ee2b064c47f9c8348f6d99e8f30b3d338bf901465e64ac75e141c594ba15169956d82d7f7f9d3d7f43e41b111160ca847e52175b74e79944c7e5ad799c6446a694b205b8e515268ce0943258778ba27befda247042f2783c1adfc7fb154d0701a5b156d586626c74eb83c5b9cbcf605a24151a7f49b092d537241e3a604e5aa4b4cdb33c9d646d1e623dff83e33a75f5c065bebc6f049aeec126704564e2c843db91f7d2361e9064cd6acde89e14e6bb34f9810d022bc060c953c198674d39d9583d7ab7479983071d558322eb6c30053af2ebb8c4b43deebb84febc21909667a531942f017b2cc368373d77164a5f4c00daa8d7d66e4c2ff3c45372cc671608fd681b295c6dff58d50c0f357db08b3d2f1b6f6119e1586b371aecb801434b3626a248571ffabfb344b32873d5e0396ac60982b2fea246fd6933935c6b39b2e23a2888cc88b084f61689457a66e6e2aac547b75a2ab0db0d5e87d78b7b5aa44877ed86ca9e9d7028516a48e605d076f8bb5fc4254f17a3e2f2c7a86747a66a4ccaa8432fb284d288ae532dec651384b02cf0efc88aa71500c610af1074f4b02f9c2e6349c4f2a55da3b5fe2575d5ad911bbd5112645429f1d5c7a5e3dfa9b952765ba249d72dd6f0aad1ef895775809c041d68d18d1975a8f92f68f6d16b4696355ef8da721bc033be3b7a33fb716783f93bc221281ab9bd8bec1e9ba12ffc3ff81f8b4df2af214eaddeb19b871780c241c189a434d908162888fb785a1eed26094bf228891f9281d6fee79113cd37e4705cb626b45bc30d9513d405bfb88c8c09c6d42b41d700224ea3cb3501a9509407e1499375ebddb0f2e3d1acd9fc4e865b972f291f7ccd6c97ad960cf458fcd7c9444e41a6f6c945f8e9edb787fbb47242826764199670178483c3b09f39feda4813b2f6eea29d8952be27e639f63f0efa5bd5d3087b5b5d2eaf254b3a28a470d095c45461c6e7fa5d2bede97707fe01047c49a78ef975e592dd69e30049571f84d3fd329904f515b714eab12bd6a8e952b559bfdfb9b673b4f464eae256d6a345ea742ef66cb16f85218d866e358e9da9a688e6f586e44615fdcac5dac9d012d86c74f7d30b98828a62075114f49e8aafd920acd7445c1a04f8c0fc1b4bb6d0fcebc57d28ba605da76c7e7c9d2cdb1bd998cf80ceee064b5c9a120e0e91b3a39a5dbbe6e3c06483f420bb6770e27b4e4232c9e1db22ec7052bb832e7cd625c024440cc02c2f6fc1f0c8af2585ffa36ff18538ef761dcb9cf0968b60f4f0c9e4eb222ecc8c495af434677cf563f1b44c39bb3891e43c2f8cff6b6e649fc52f03b1c7f890bc52b87d4f6f3a324580ca46584908a467024694f1e9629b906082e78cc02edb72fa7f54ff321f14844f21d151f3b5a82f200fbd1ad65f0cb8499beb32c8ed7a59fe7a19e6218c397b7a95c7d45b3a1ef400728a4f1fd20aab838f79c01d645be2ac4093f64f91d2b7a17b5e148de89483d45a0edc6224c536264a83f05bce260b2c4dd2bde96812e4ee54358c55a2e4db7a061e7dbd9c1960bf0bf3ce2d43eda51ac6c7833a7fd2a162e82e8b1889a11f91085c59f4760debf4a623d8142f421cff8d4354c8e75c0c82d26258c803ac95552fe8facc916a1b62800ff4b268f52dd22f4237d1bf5e98a37e22c3c1c62adc26ce5e4d37cb3eb14ed39a91225070f17d760aebf30d8ca3244cf99af76871872cf4d162fa44f145c12efb239ccf8faef8c3255af65d90aa769ef6f1ab713060f529e1470da9fb8af88e4dadcc1e52cabf899ed7179a5043158f7ecc94b1c3c06ed421c219357840d0b4cead100f0a9c79529ad483f551206e1db37b6bb94a71fd6d5feeaa41bb6c646207d219c028b8ac33d71cc23a77f453b5f387fd384fb23834cf838bb8db23a955904cb2e53cb9a44fd3ef8b28f38bb4b5bea934a1d154565940e3668e94f635bd925a14bde64378db198594d6ea0820d09248551290e6edf82ca59c7941425b7e3011761eed54f81fcba85a94409a6c6aca0af50914e58283b32ab53e499f9e54321ea0ca2f5714c70dc703a2116664e3bd2d9aaa12efb2499e012243455196a94e4b7d65fd59c4963df71b5b906f5691c9edeae215947e5ae7eb5622478dfb4be7f8e6b3a8c76bebfeb66a19f289abcb1b2990dfc655ce45d47ebd314ebb9ac9528611394c060ad635f17f6e9de3354c49b3702b99ebf0442370893e9fdc46971aaab25aa708e52877908d58ced9f63eb72a6dd6b183170fa33ae262c2f8b80286a510ab7d77bee9c33c150635510a7d7c6eeba8a899562d1945c39663a6245d422e19aa3f20cb0d6d37a094ab15fcee7c01855a16d926946b7c2792f6c2b6206e2f5e74809c52dbc78cdaea2a32fea76a84588d9e1848a42e3cf9cfc6bb989a18f11dd25275758d9c5d0fb8a4c0880bf4c0385b1689175a70f2175071e4ab93c20ce9231a88900d39b437efcce87e83de677efe6b9b53432bcb1540134c860196d90fd97895a8e99171a8ea35b996c04c6e3c1377c736fa379257ab42c2b9d0d3a5420a5b132d6de5013041b44159b598d9f897fc098227529e461a1299c69378c56f662f27412d72a6d23c2dbbf879508b767cdfcf03eb07f345b7343f4873669ab8be8f3a74de275fe9683f16b90f9f1ddc8e9e83ddc64098073a12dcb46b8789b2e1d11deb70164e26553a2785ba6541a6c7fe15d713fd77c35a8ac4db34fd61109dc1eea40783517422e1c521d2444e630fb6bd9210fa5e061ae33ccd533191d922f1ee32d56223b42b68d51a986dd7410b6e95fb4d898b8c22c128d6f04f6a5d0af98542b54f09b547f4f352855eb3ef5f5f2f5cdb2b7c4415e06904757c36831275b9979c05c8250e966643f3a568e88a3830cbf2a9b27f2ad75de333cc90b4518b7cefdabebd70307a2cc125943197e1cc7bbe9046fd754c2d8b5202a443b15c7a2e74be996cafabb42cbf5cc49943c45b7d8e211fc20e2bb58c1637b63df9d00eeface2e1b7d742ba3fbb128b60efc242d16c717d515d7341bbc6f3dca56a4aad7ad13a5967406ce41a3d00ecefa30ad20f5af44a5a53af1b428119a2f65fab790b432bfe981d41a335f2d57a92b803d390cff7f8fd3231f4194e5d5b0dbc9f86a4cd0365c13107d0d206b6142baab8da94660c2fbf6d7a3edb2accaaaeed4f6c1e7d8072cb6bb9f30efa3517e757812505b963f9a529372eec15899556773fede23a753de8621cf98066f17a696912555f2b3478127a2ed2d96d711ad083710a38b76cdef6952940ff38ce0cb3bffe8a5d9784aa3c6b80e9cbde05b0a2f86df2d4f37f79d6837222ff74e334241e8ea49335516f41ff9b3e434d83a74083c36f9f0a969c4015fad8427461d3744ef8ac12286a5d494dea067a22158c7d263ac931a615fdc3277f64db7309e23c7270be5fd6ff43c93f70158054605411cfd7fcf3e429d5f5a739e08cb74901b8065cb85a0d1d9a80e12958c4b84e1717ce9699e2c4d03512385d7b8dbbe167335d9e659afaee83d3cedb75e2af0598f14c0db3ad437ebedc9cda5cbdc7fa91b874c7c0123292e4127b8dea1f45f684b35e37723f8ac04fa77e81f3e8335fe927b64d9ed4e8cc7d170448134603fc9b1f525ea1fd548f503e9c1f168f810f58ac6c43cc8ffd6bc774be782471b4e89393fe21f48b4ee166d74dcee9290fc6ac3205250865eb1b335b0f76ffce5af275440cc17c8c1f0ae7466c83265186de9d4add077c0f45023ccc56fa1a113f20d6798ec61f8c3c9fcd0cfe10e21159bb36368f8c972f79ac6af29766fdb01dea27316bc6b2f45355d9c4d87211a3876c276d46df2993591238f1cfd44f6e7dadd8621f10cae5be96a4414d6775e5b12cc468ba8992e533ba46e50d8ee46ff6f9d72fafa36ab4bb2230a82eeff6bd0d17cd13575be5d16b8e914dd5bf2b3ec9a23e123680fce90f78229a54f7d69cd0c7d1ff23ae1e472d86a67cdf2e44d75654c4217e48483d36f8d019f86c07ae750c76abac0fc7454e54a6f14f44fcdb01092a5ee85f48869487a2785c362b60cf65342f42ebc6e3cdc406957867382e276b7de4764896ee5bad7de1000ceff37f283cb6eaf821880bf4c9e0764baa957dc9ad176bf38475972b9f40e4c597822a6cb53fe20b07ebf86ff5c0931adfcb0e2bfaa946f3876b05ee2ae5e7b67e281587fe3e67ab144e6e7cbc0d21ee60d705387efcdf6b61a28608532d0b26bbc91cdb37423d39b1ef7d86a8c1fc96933279229798d2138e9a39472eef5f7a27c66427a99a294c70f0a453d1f4f0bfd4deaa46c2755d573b961b83e76ce6320ff31d712ea8284070ef0222a4cb3bdcbc2df3b8233f8db31f6beb18d45e2e29ee8c704718d65d5ef740f54ca3fda44573191c6ffa95fabbef30ea71f52c6dd7c83c62f61243b2e0ae084414e760b7fc6121cc7421c2cbd37e68d920675f988395fadd7dd9179a8b7fe79ef3d1560ba74755de3fb80d68f8745874fdf0ae3a99441adb6211476641aec66c6a818acb47b26b2f1939f21ed3144196b1faa52ee9001bfbe88642bc4d1e2a0c1f6fa4f00090ac03a8bfad55c7159eb65317958a83bc0a15d0843faddfd2398a29a2466f303349807170690666c2792303794b91d70721b236db6ae8dcf16cadd1221ddb9b6c061b8fd53c6e7c453ca727b41b02fca84ec04f869b21ec2c5e360ad7c7098337bb84b0515d62c3401a01259999b790e0773a5d6cd4b3f2edbce38d19afc3b248e3447781bd5e4e9000d31bfe98bbc082389215b9a2762ac62434760bd3f31dc4e8ee249cd485bd8d43c54ce2ad5c6ee64179083763d3e42ece1dfdf35be6c62ba111443053453d00a921212f3b42273c52bfdd0b234b9e74aca610c29f50cf8317f67ccc370d93b3154b2c1cb6f6488a778a62a84fc3288bfedbcd94097a1034c0ff735962835a715fbbc733a5e71d3cc08c6c044287e032d3afeec02efba967e1d14253ceb847a0f460b26153981f269746eedbe5e0578172158e7f793344d2d432b610b882cb1ef3c644cc8fef2056dc5917eb1ce6d82fa7f81619c9c218755c36a5e29bc4407768266201e05fb0b872df79fd6fdbd4638f3b84fcce5ec228e0a89249e346d7c529b087872f150735f4d97253915de7c974daf5d91d23aefc7194f5dc73fc5bf3a6687110f7190958b4bf39f8ec6b871b398bdfd855a7328e368b189e8b8d4b7e9857c05f416b15a47ef1a0fbbf73360683a67bbd8a59a9dc73cca0fb4ad99aff2fb5e12224aea1214ad53850b490c93068285a683036ec012dc6e0e7155c5c33a13e93e636aebc80f46614f850edaaa0f365a6a811a2978f18afef571515daa5430d89d91196a3fd373097c9daf5ab5b5927c54ba54c35a14c718d34092f190b57cabb28d62da35cd9b5245dbb9b073a8546c16a29857d1da6090d83be7175624e76c166fd3e644e0a8779efdb87f093940293382dfa4104547a3d01d6f33e5552dab739e9c03dbc770d32c2d816210ec8ab12745ac58ebdcc6666e530284945baeee23e2aea0c1c5c37fef5eaeb861978dd156d39053e417c63e07b7a613a027323434633c1573cff629a584e43fc83af19089c900fa6cc54271b7bdeb3d94b7c5cd149fd34e7cf7592565588a6c75c281c5f6a6780d7b04d126a25d2a629008641de95adb45c8157f4567b69d9b34dced6c49921337809f427094771b6f32a18476fec5a3c7d986cb2cac60588aa414ab7bd3d44aa725c617133aea71c8d4a4076516e5768c083a2ead0d4593db2faee06c697242ec08a607cfc9ff22ad05da30a4c6799a9e6624233ff1ff5745d28f5290b0d352d2f898b72215a266666e25a9943bd4ecee33f00c1a107484ea634d4ca277dec1df3cca6c4b0608fcd48ae64ac9f6af76b8ecc50aa840c4a3a70b3d936a4109dc95a3647b3eedf49f8f53ed7b2770af4788fd2b8acd8aaae107094ac5c27e117ac040a1127163e0abb01428db761e7a0e9a5286cfefaed58dd2d286f5286739254181e171e0ec7ce4cbfb8027c51f624b41ff8f9d41858ab234407601c07f0f211a9219a2c74e7c766ee883c58569fda4c1c42a9a22c4caa8acd73dc8d138f071c207c9d5c9038278e5d090c1d8abdcad3202ec91a07ea04621c5500ebf6646994ea63b2e31f2dbbad5f6d647a0d1abd36aee55446c7a63f2a522a87928cf2fc38a0441ff70f7917876826742d63213392296c9511e7ad2085e55c19ddfca72e20c7adf7bd9074070392d79264f8ed4aacc406d9735482a54a275f321bba59e7caac81a7eab4dfb70df31f94ccec9b9df766d036291dc1342a463bb8335a8952538d8890603ae973874b5cabc34691afb3b7d413af436696c80633c3f5cdfeaaa92f5757bd8cc34e4da064ae52619ae81c49603782af5bffbdc93c3156c1b24b32d602bcab0def855a0fda5921fb9a15cd6de5df86c54bc052ff7389be8b7491195405cf729af04f083e5c64f49daa59eb71b171ef5d606114501ddee27cd5fe751a28e7b58b66578e010246a61b7af7a0b8fa3c9c7664ae361a1d62a98b1c5c68d267f2115562ce28c3c7744a563e5e7e3d4ab2fd24dd44e35b99d6804709cfe40162a800df5e363a9b939d569abc915c0d4d05a585dfe54b9ba83cd504aa19173118f51a35b2cfbae6337ae45da05d7f5e3bd705e6a525d2fb447b25e9dfc0a7b42bfeb4578d1fe9d2f7917800fb908ebf722106a2d3e35289aa6ee094a09bb6489dc8f587b7ecc981f0310f8c971cd10dc9ba8968a4d69c6dec1d458f991e24a90e3ba0691be797fec921c6c8f56cb963abe3cff638d4e0673659b149b109332b123577cce708cf22dc2d8965789cf0c2e03cf0c6c7df1ee71730dc0ea3678661374e5835b913013a8ba64288474243ffda74532b9c4428a1179bb358d26e03d1f01ee54d2cfd76d559e349d609b9b0bc17598cf49f2df5c9be994aa1aba9a49d8cc2b9441cbaa8038ebc3c2047083cbf14255900a047ef66dfabdc1d118731639c7b65c58e4c87cf85846f5f8f1f60a6e15c9f99fd92d465094d73ff29f8325f1d3413d60cfc3675bb966a8007f108629e4b494275d812b957732bbf35dcab513c559c3d725f5baad8b4ea723ded247c7f33e5f828944346737cc45a340bce256dbed67a5e51476c69e68b654d87ba7669be05bce917f4c379e228e0c7af0901f736a37891f3a241596f7e654805c32a1295a1cbe2130b2a22f36d11717c99e18b1da12d9e53a5d616b58c0a700fa1fbc55b85f6ddc94c7735edcfffdc91677d355e8819ea3df8f9536282f7c3e845885618dc6cb676ed36ab3a0e6291bab51641442523aa2a82baffab709af837eff547459dbdd3ddd4eec4a523ebf2e279029286e7c1d1c2682214fe31ea950207897aa7eed3855644806ecf855ac3359711ec73c16be61a8b3f08e46b062fb1a32bf4859082bd6eae46221d6c638e875776b380f5bd134ab04daa951a12cf2e36927f891436230e13f15b1d7fdfa8c7e0e2d5839c91da84f406c531c4bf6e4051ff3a94fa650d16e4d2cfdd6d04b10580088d1483c3b8ca67b731e8fd1a356cde2d6c23a631a8b4cc58045275a34b5bce7e3b1a5db91657b6e2f9d640a7a7112c913cbf0f7ca63edaad2a32ac9a9e934158095264d7fdc016853f70da9c270e08491a3e2c1ce6a0bb3bed3b9f6283a919540d675c2e32aeeb52515fb445","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
