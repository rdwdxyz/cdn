<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e114d420665b4dfb792bc632fae16ff11b56a07012daca49b78878500f85db2b4999e68d54a5c1ad0080ef561e2e71831e6a2c60d5d6f7953dfe1842f26f3034b5ea69e9cbb6977c12041788ff68c222b988cb557ae58ec589a5d926e16419052ba065796cbc9890bb81b0e8e7a046bded71c3005e5cb4b85d96d2f477d979e1c8fb7370a7be3ebbc2a823309a5949a283ad06aa80d47768a0b25a4f81651fc864bd8aa05717d8fcf6aaf4d1d1e1fee66ffdb6f25688a8441a1a1388fe04f0ac3856113ad192128a5fa38d1c78be780213a0058df5a08fa3242512bd65bfcbeaea8ca68eb02b684034f60933b6e003a124c146bda109fb6bab484cf817b1f1d6412025c4e264105753488084c5ba966c17623b98db256b1259bb314bd73d5b41951ff915cab0158059a203e4be3ee5d6dd68a770744ff7473e7b952bb0aacdc3bf9ecf55e23d79eceb503c6b4add492f7ba6349bfb19612c11fab81957181e7efc7867a2d3a8b93dedc57bc5f39d3a1dec1e083db45696fe09e5a606802a48606d626f6b64bb06585eb5835dc96459f6b9e5be3c9f4e63c0990c10d80f4f22cd96a2999114f717e9edfd87a616619d3ba614142965063589fe25e979166218f4c22f365d6c35caead3d5f8a2627e812481a1bf02a9ae24effbe5253b3f2ed69b98f75451dd1c768e4ac33fb742cc818eb9844bcc03481c57d9d115d29d962e9cf40f270adcbf2f9a937fcca404a3d6a4e956c0899ea8bb7423670ada780133ecdf81e242929fa3ebae9f2ff35e5c3c2a69b581e550306c69ed42ab78cc6fc423ff9a0ae7f1ef2941d3ab38ebd4b9e473489cf8691f8d3d2e858a973376431a181c11e6e46f394d1c60074bd0acd97eeec342914bed59dabfe25544b25590d148d8c985e3ec15a431f48ef912c21518fef19d70751028149d0350661a5b98d3a53ac447e7b2e28a819edd040cc3fa70560a1d4bd9dc7fd2e294f8a4d11f424f371b78d7029fc2cb33689db0a66bd0fe17122d236bb53329dcf32d9df9ef118bc3c660a58624cc7c3ccda6109f74147647e16731d0e37b257f74eecd6562ce95669ee551563f203f350dc907602f38a32f1aeb296c036b7e47badcd3784b3b725e0a11d9d30147f31e0be1f00255d1e8778fd7a93985c1bceed8379e0b1a44fd93ddac15fd3180a30cc50d6aeeec351f2c390094906f20108beaf7e40e5b58ae9bb7f76d1a19eeb0b2d65aa5461df4812c4697645645beb783db3f6c7f1415c077940b87c43320ea9528bf9cb85876173be7b835b2a02e6124f04491a8191ebbb8f6e1439ab1c15e6a79aaac663c134098b8fb29377ea387fa94dc11ef948c83d5799e5001ff4ad29fb0a70528c368e599c5c43f6c788f62ed0852dff7d01ce14c94c0b45089c196fadbab4ec67e221aa0cb58d19b5d2c1974e64b15be99ad27cc0696c09dc128cbaa369081225d76f865913b546e25af1950c410077f274f807d90322b9fcd2b7fc4945fe777fe145f9acbc7d96f507a96c4f1428df177081c2b6ab3aaadd20de3df06d95e5f79adeb7146b1ca99d6317424550dfaa7b8f84a37549234edd4e6f5c726293f22efc4cb2653777304febd9b011dc0ce3d148ddcefcc519d33c08d14a6c352c116128edc8a314dbecc9b69b0f67aa93a4ad0e71e50e603496b46d4cd64264ebc2b2290438867289a2c93014e706def43eabdb9da431224c13d97d9de165c33610746ae231f736daf88f6d9d2e918548f1efb212348d13b1641d6303a66b8c5de240a9ed003f156f3ea3deeb5b0d6809fe34d6dce499d2ba51dc616c612e2105fa36a75e5cfd2ee50dba33b970cdf9c7f3dbbf589b32227bbeda28e8dd568c497352a0d037ac09becd7b61638a2aee9be637e2932e0507982e3013bedac9e16ad7c3db715a1f5b140cdde127e9a955848b6e49b9e6cca54854ecdc29525a09155c5254dddfe7f3caefed34f8913aa4ff6a8ba2e26a9892c579ceadf69dca7a62f263e67a462b926727ca3192bd7c035186ae5d998ebd86781608f04d8a536e1e875a5914b8afedab1cf6ba8d5e5739741304aeb26b4b9baa50bcf72dc8e18c717c910b8b88aee4fe2118597492585a6fcad6a521d4c6877bcefebb125b84b291d82db67ec00efe2da28595fda6c9b2902a0e9cecc0ddbacbc43a41087cbf311a5909cc75dc8cc176fa752f19c94314d731d93bebaef1a6116b85fdfb6a872f67ffcd2510c2324643f2322f1d0236fec69df38eea3addeb8057c1d8780854d871e97e54c2372c6ee3388ec2af55e9be46fe20838c3fd33ce55ef7fe315461e38906eb48dc767b85c88ea2dbdae2223b8a56a41f250d17a12e0adccc679b6858a12c0a859cfc350ad826564bc2e48c5fd5f7a04294bd9a3b42449c85a980b10783a81d63cc141bc5f784f453584fb276be595c722b16df7748fad6da332bb5d1353a1a41aa913be513a95c7ac819aa371ff95f5d366aeb812f87c3bdb9b19381cb2a5597d952290fa7a5708226acfa9dc09b84345814fa2161b3979a268b5b0e6d38fa37b7dfe15adaea96363dc3b8b3f8baeed3fd4130fd15c80fb1cb712a6421d7395d8d22b205dac5eacd307f11b01dac3983f8974a0e90edf2993e6db579d394b8234e96345fc93cf4806fc2d847a16aeb4af04d32f42729ac47ef937d4bf0164dd29bcf0df2728af1cc8e3b9a9483cc4032da2483f8731ee974346a425b0064a3ba460a2a829537ec0fcba78b2d1d83f2933a19e6666cc01862e285b25bd136ac81d3e2a2079043365aab56c1ac73ee67f906c25a324282231ff8981cda3cc841ef2da38ff13db8581d6c42a28b6afcb5a0b0b6405047cc75fe806c34168a0212c37d3b551180afa2806e4d1d24568f3b7cbffd665706d962c30ac9e06e5d4277eaac537a6f988df3f93cd8bc7eed261be7e21b0823f44c4d835a50ed808050d489cc156a422c77e81aafb31df1b37d078274aacb576064a5c3df755813e84e05b452dbb2543e1a43609217ead04fb2c02f95d954a90fde1eafef01a406d5aa327a291d6408b8af44c3311d451b1a0a5b40d4c41f17946500fca598ba392e201094ac0c0ce909a5292b8f76fa4da6ab04c8efddfafa809d85ff8145af2c041ff1db77e403cca5eb4186e30e32ef3658d20cd791b18840700f15b1e31322f0a384561e7c41cba0af3a2bc2d931d6a14b20b6ca79f27b52bb53365db642f084b65e697cab9f1565b8e654c850c9aefabca2379528a1f9a1eb5ed7b3ff4bfd294a96e0c768a50f3698646b110d2f821f322f3347a07ea365ea172464091695c0bbfdd123c5d9e6052136233e83fe1967611b4538661a0e4432ead062b9cd39e2d0643151e0d190fd86ce75cb863b47727e7e86928031b622f6ee5a475eee89026161e7c2f36fd2e712e9bd81d30b211237c8ae19663aeab12bdbf7710b4e1afe3796f7b019c4a64d1efacfdbc54ae10afc8797111a27f269d34292def34dc0d3d289a51f3803f8547788291eab0e6da582bed005de4f432202c5fc3a46c0687b206fba8b4a14a2a1846e89921831b2955380e6b1a13c366f974d806a1d729578b08a122fcc2fda12093e7198de0bf3bcc3d161a4a04f0ba3b9f61d68d26627c7d293dd0298f541c1f0a6e5df7588215cba2ac508c6b45792ec23d69ed6b74ac0796d7185c5627bb5258329d2196f1df88d85862ef0f656ebd64a3d936aaea19695eb9e08861697578bd122d26f375b9223440d7f7af27df8de5019058c7a44d82df0afaf4505f0ae9b857f4cfe3a00cfe0b6e9c7f3657f6a019311989b130caa37cc9bc163d629cba6696e6bced03c1fdb451a9bcf86bb0ebf5860ea00fcdee84ceec34471cc8af4124bf3e16256f071a7af30a09cfec56c1deb80daa7e5d37375d0c79fbd9e5386d995c2195a13b6958f289232538327881f92598b982b568e8a303341a22975f7e2961c652dd28daefb00d8cbf59200d4a1eee87ed1cac01ae53e762463f8141df4c5f53497daa6191136a51eff2d8bd972fedc4577817dbb40d868323ab094c37b9205922c929259e0958ea8454a9592c2c861bc3ca2c5b17bfa71df7e0cc72ad1776b0740ca5b571ffc8a0309d0905cb52a21ee2b337ddd40d3e859fcc00f35abff38a8a3736703adfe4ffa05a9644fa580f6491804278db2fdba335bda8ac98d3c837e2606153c22599767dd1e5a2c7d00e2ea6ae573188bf859055d597648e24d0e2038d0f805f3878faa85cae6e1ef870f38b2d86f53897c8c3f48317fab206180257602431a58fd83eeec1a080b5b8e1f4469bef1d896bd996ae368653736ad70e2970a5b0a35013455a5cb79f60173eb30f97d98eda0852ad8400690fb71a09fc545cc3e498ddac45a89395940fa831f511c3407df20d4bf0e8bee5eda3d9028c8f11ae362a90e61270926a56b60f966ff5b2e9ef159fc7967861858053abf0921e4726f2e45d8932b1886cfca0124483cbc5d991efb894b7a039a77a0f0f22fd40c6aa274a574f29cd8886fd81116014f319242f60cd9e698e53b98ec687a8d174ce20f4619d66af65abdc591bb73e29e196f99a198d4d985eafe2599653e87e7eb3349177e254b3bbbc1605b2394f3a06c9d2db2f2c870bdc271d330246e88d3f49e1ff8098578019ce07e5d2e0a49c8745c37c9d0155b557f1fbfde92e12ac1e291db2ca29873114dcde1a35bcdabce077809c89bbd1bc2795a57173de6c73774f84d8e6517303a77e75fff28afda27e24397bf1968172b64fd2b3632e93680c6f051cd76d48c490ce99015eff2d9ed8a9aa07e59debaa282d5b87d8405cbb2f511f4a03f9f8959e1ce6f714ada36e666d357fc26cfeb21a642e06da7dbb60092e3df8332ff96f0ec40e6ad9f586da332ba998a4cb3b58183f8466c7d0ddf724385a82c24309bcff221afb3b8f6ea3a3d3b4f4b819067fd879c756a9925864b8d3b0b847f6dcebaff626236be7a58d17bccd6be09d7fa28d00ebc74e58b6ad0dc533f7faf3ec7c4de79e9f65001ab8da9fb5515dd6dc287aac0e330e3e8e600805f965f482b12f89d4a08602e9bc90d7f1f0e8ad797530c4090b67f01b8ad0f4cf49667516ec5b77a26d1ab1ff00d10a332ed2d73e4b8e35eb2acfdd877c715ff40de8db3558ad43240ab5845169f1e6edc8e24e636b55a827d019ce6d88cad00e7dc9c99f722a222df4c0757bc9edeca8dd157dec108a719d84e7370f8237d56e9d632434db5a30aae0d2243d028155a81ba691bb7071f7ec7739c609f904a75b6595ef4d4b41b23ad4ab3e4d6bde36a1dbb452e4922bfc2f8480bd44881afe09d90fcc30a7e4225e7caf5a4c18224db0318300583f4577587a83290c25c171df009568a1a5de3beebdab052677c92c5967545e06b8d0e197b18e27e2db6f718109edc6b0d038391924935f25049e5b01f38f62e1b05218c4bed14c7430e7cbfd029de6bb40f007dcd50b9b41cb68d220766c5af2711d3a01ca82e737a982e294254eb6884858afc31b9f7664f1375a8e5ff6549cccbe8d71572640055ad87632fcefd5c79e73c9281651f71059019de8a46d57baf2a66d32e3c0daf8e703aaeb6385e891cb8880ebb7c97a58498c191d1572c0784b84a78d1c5fa41b17a8374cd47c216e1be9e9b314c3dabe6ea5ee5627bd913a1e18c95896bf5a3efbd98a78a629971438cfb1b3c70f1587337ae2bf7352a3026f67f95e01cd1a98cdecea8335d996b3f3d4fae68ba879a929d20a1668d7561eff95a4d980faab47c7bb34b6c4c20fb556b213d774b339c760e74d012a16417f9cfcda5e2a2a35893afe6cedd3147d63ab912ab548d6519867ca084f40b377675a582c42a749a73f32e3c3e87a862115c54e27c3eb65f329f014a10e0958d8d4ea985d8b885134bbdfc7876ae2d96a458e5846db82930f25c25ab54fc52e33033d8d76f753bfedfe1a31fec74c127d6e139836391abb7af9e59ee4f6be664ee201466b0970ad34b15b37d012c88cf535d2b7132730064d608406455c6ce0c004983376e1ada1c30cafaeb42e1a8d15c5b586fade32e921bd3d0b42b269442740c3f88ceafc55689d2e14f11f6e8e6f9e1fe54797511c07065b1c2bbc71316a5937d455a870f8b3bcf05cdaff00ac875f2441bf0193c16892ed0345e239709188ca1a776d733e74eefa1decb0ec69e36f7993f367a402092385fe9e5623e5dcd9724b1f92cf4b5c23de0d2788d3b02002e0be15a6a27f6e0d025fe70b46340bf43323145d7dc34bba435a6622de074666357492c7c573ea480ee2ba7e7b4b1e76e779989b9165add3caa075d71859e41a8e625e51a10a0f88c0d20f6682b57fecd2e7ad71074b8ae6870a064b2c9302f5b5e970da03434d989b535459faa1b9f30a02af4e6b69f7436e9e8d99d2c291bdb370c775e8df35a02b140a29f4fca9794e1093257efa1f0fff7045809da58cc2a2a7bf338af77d3bca6359211c88a8acb82a1f587a100210ffeb1b048b09cf5d0faabe54f20292af1a16177f16828dbd59c42278a599b41e38f6b973d7119c06e4a0027ffda84ff2f48c0af74e6738a544387ffb2c28e36a85cec8d56bad184c2a92b784a2597e72c315c607c72affeaa1bfd502fcd558418cfc00fc9acd9c7fe3aead3244a711ec3a9508e7032794d4ca7c46842848fbfaeaad3c8cad78031093f441c877c915199db7f10840394eaafcffd49af9dc79f8015bbdb1ef3b71f79470ac0cc48b149ad8ba448f736cace622a301fa970a2b8f4104a962fed0c987ebe5e790741a1b06a39518d597f4c441b5e1dd19b4e4a6712e2ac2e0654702954ddca132dfef536a2753f95618c25daf98a8420a7850756e67922bb0b0825e3d92f58d0374c6da5a3fbbec5a6c6c9c59940f20ecca96b9d8c41bc60f5615f680d5edc4ebb2d9055bb6aefed560e03351a3b7e2cfc1cf10a108727e4a55ccf94d52506ad4cc3cd3b6530a0edf3f576b297bdf2221f80554d1eea579c61da05cb2e1e7d0df8cda8341ee08d375e8d08fe793b75b5b4a43deb29873ca944b1036e632327d5c24dad191a83cfa041f2f7eb731c9f9dca5e394bf3c1245ac2e487c55676000da58f24f1a96c1a53d69da009be07fac0a3a83b1515d0614a2f1fac1fbfc781ed4ed3f1cf8224ae74e37bea62158722e11ce02b921d21091cae8e20ecd91ecb825b7d0f131181b5ac3ceafbfb32ccd1895c48d89517f91ff8ed1a28d23148c0de37ae9a6785622412bed751283c4f36635b5405ba24ce530b8ab22779a7ef93a7cf29fde3515030c6b2d5d306a8ab8faea1e3fd7fa43af1f4aec07fa26dfa3fbe3807c3df514a2347c3054fe39b025ae0b14bafd69e84ce9f60a12cd6df077811a23326bce7fac5e0b6965ff42bd8441c8cce3996a837253c82ce93cd4fbb03c81ee45958a7bb526549112da7bf7d6872fce9e7100057daeb462f537f39b3b3f518cade4cb9b1fa6df6cf62b8017fdc63cd854512f6cf99b3736e6aa76ddcfea2c6151ff30c31cc4f845cfdcab317008ed4d4dace92e9d14468c4bb5e69a59056585dffbc061bac1bb9e92e7aa928631ca0897e9026cda7918e6fc2963c79ebdd6373d2936c28e4a7d20f634002f37a5c28e6999e38ce1bb74f5b859128cbbf99286bf3caa0f773a2ccc01a3e440bf0cea9aae9e214e4fd697440fadfdcd8f98f5c144a68c39237c02c0a7f4366dc85d9dfb2e644dc8e7ebdf52820f61da3424a125b63b5aac68deb2a357d378c85df56f739e4ec70c0728978c9f73497c3e8d79b76109069a0ccbfbd07936da540e51701840f9490da408a502418eb257be07aea74e759711f6f21571bf65691a974ee08575ef90e354e334623a71dd1781831072e5ba86ff802968350fcb2510b0d8f570ef6167dbb1fdebb3cc7a4470b93ca494c8f670749faa6d1aea7fb6863270e32f0fa816455af6eb59f7dc87b05ee888aadaca2f732aaf7ad1ff3626208c703465c53732c2b01b695e7eb3f776555a0062f15bc8299e153a19d04adf2ae9ae0da7d5704e65d0a05975acbc8c3448a07566852edcc579e902ba1cf0c10684c7af63dcc229c99258c2904b390d6437816544fd1931f700e7c34685f29012cb08d77e1ebe02a917a249143a278c3822f95639776d9314c03e1843cdc15c6bdb1ebbf053ed1068a99fdf072f5bf8afd386b89fd4fd382e4f3d494e08b667b1358292a43fad011594ff45779702956ad176995967fa439dbd5368e5fe09f2011e6fcfc139b3bc08552f061eea5899967bcf40624709216df75759b434b33cbd083286cc6dadcdf606125c89ca5dc608da6d2fc3e0db008262778b6a561f1f5d1d003424a9dd42d990f8402ad1458d5ee6aa0b4a9755cfe5c523b36bf155f747bd40c09e245fa08635ee0370870ba19248b86d2e10ceed906f025b8adf00133c628379e8c1944b06020dd28c3619d3f108b0233e52442e8e8400313b64b8c7421096b49df733259c00b75fd5802414fde9789d304b584e98436dec54402ab72d8103009a4c28b264c7fdff6384e567007e5396334022668e7ba8eb17bef861145dece6cdd6c91d7c53c391ee64ecf250c63e94f7f0e9c473d46ac466f60f63c2e230024ad4f2e6d6b1c0f397d2f0529913031eaba63c9f244c6bd6c20f166689838fd9a1d6e72ae8751dcfc1d9f4b3fe5795d476d9454f86ce66a7ce913a9807296ac19835f2f8d40b977ab4cd2300e90f4b2834b9d544e30efd3ad7d5627fa15d60f9bc00010e3e66fa325f86f3bab043eb30f4cde453a970da617b92e82def51f3bf29f29da9e94b4caaac0c60af5fc808715deeb2617757095ff88b922e7347ddbb3cdc86d80bb3efaa48954a701c1fbb8417418e5d811691281360992d965b661f704246dacbec820fdd3251a68fcfdea18358edd65997e441ba06336dad259e4a55bee168e9bd49acb5bdc1db5ad0cb05f201d54cecd50c7b7545b6c22b8a19035f33385c1b72fb920236ca51cac3df4c696919d0119dc6a3da71f8286d1624662fabfef7dc1e9f9c2f0217e55bb664e7161469a48bc6d3fb930cdd90257de09f43e081b73195302388d8084068b4117f305d75ee5d6036a5489c90baef7d36a5f8ec5abce497881c6396a9656a68ae3f353c698882b7514efc58f413027973ca2548d979e424b298d700bb9650d239708293b8b74e09f995375121d8309c400031a1ce3ad2c1a0e238c0744d04a7adb9264759327573bcf8fa5f040c6c8b3298df944469cd9ce3b49e074d6457bf8be7edf431301abd615ecdbb45aed48aa31c554f650e99010e069ed8e188f275c9df202ed3724a9147021c6c2e10000d92b2210dc52fd9a42fc1efb6fc6017c58823d59318278e9c3a9b0cef2289260f07039f4f24873f490337cf05180806e98e5b8c904b81e1f96832f778279ff2144b5faa2d32444821b4c6824285927d2335d9894c4a7366d06d45dfcffbea9da82c1a7c0748f879e29a2003d131b403ee4b9281b2165d8b15f62a3ffb33f228c1cbc98fb875b6a0e206244c196053997b13f35d248840e6c67c6467d788f8b17933490cd89533de94566da53f1e6452dc443a660bfbf49adb980c601899c908fe6a5a7253c900a453eba783d1ab6aa839440dc8f0b28af4be512dc919de779d3af2da3f99b888adbd99227160701ee43ff4a9b776f2309fcb1c67d267367d50a422838d232989f123026ccc47a58e1ec13e062113e0a3f31a9b8ae4d9a717aa1bec6a285a138be1a30596a59901a8da72d570d8543ab04829ea448cb36d76c3a148fe608453a953e025e12eb61519f59fbe72d978e3d70159250a69b4fb734c723d8da3caa6b54410b38362ba6b508bcc659503337a43d763f1dd26d9ef055c7e45062544858560737defd2dee6065e52c332553f2ce040542a34884487918b10b9ddec18371de97350f395d2db3a71ed72b8e0eaa0e81fa65c517cd48fec0274ee6a987f4a47aaf4604ea51b6009d9f7915b47421fe6fa1ad17d87c0d4815ae21bb900ef1ad2c2399c246e98ae2acccdd925f08a00971a826a3fd96d8c6fc0e143e18c36cf61ae1027d6e7f08acf3f964f66b7fe7107062f3d93b6a9d80c16468901f4029905a69cc65568b95e46f36bcd5e550c8a698b99cd2835ee7a8f800d33eaba649b48a033ccae34284ecc03ae92d02c8d21fb336a4fbe830cabdce25e817c57ea16756c8110604f28245c18429e20226e0d6daa4a7fddede59eee6a05d11570d5255797ac7370259cc70771ba698ddb67c5d350411c3194c029425d07d9744c2249ccf9d404755565bf422647a7d21dd6c14a3a2716199fb1f2905c2a7a9785203e86f5088e0bc00aa037b0d171839bcb33b917eafc6f662db81adb2c98a0d293e9fd70f6c6e99ed6f7b2266b49c828bf8bde1fdf79f9ec37537b4bd8c487f53349277625b266cfffc584436774469ba4687693fe2ec149106b2e664a15297097d883f5a2bd140237910160c89cbceee0f48251527b4485daa17bdd836ee69f3d13286b6492cee58174e808c236f7b026a7d15f64242b6758164735cda1240f575c2804b686066630cb23b52b2cefe5736604e0fa68c43133fa7a6fe1d330ec7320b3119fad00c7b5af2c6f524d74c7abd3f74095eed2a55eaafb3fd5bc3a1c6c14718bf18ef2b34ae6dc116d6fd03aa60ceb184a4baaf101e0e5282d71636dea1641fecd70f342effef16b15b7f5394b57682f3f15fc304aba80e1b698772dd3fbff03b6d4bc2e625e54ea15aa20d9a3bba1c8cc751fdcded7265b19dd88ab4a2f8b490c6f7b063d3fffaaf4b0155044eb49589efc9d5dd92de69fe8a98bed8b1cd204d16f1b76c678809263e848d23538be67586ee5f7144844e29da43d4a975a14f4a2a25377039a3b5504c1794f889bbb61c69029e57345018ae15bda5c42c5fb2b956cc72d8f0f8c8ed6220ae164b4866bcf4fa029f02f68e6b9d6a565363391faa67fabf9473878f8a3b36baf6bc9731f542c0299ab5698b864b2e657fdb3152193b4596b1e183e181fb4e3eacc758e82c1ad19bed553952dffcbafad0f199eaefc8b935870ccb295e93025835e3605385156b1c05f6b13a56cdd1c34381662c5750a1e96e7ba0f84243ac8269cccf30f8cdb8465ec8ada8b389ccd3a56b5438de98048ef3bc2295939f1fa8455cf1c9eab48c35f027b1905d6ed682ed20f10768c87d660e9470ff8d11ec009adfcdc8fdf4d895220bdc2d2e5c0ef30581572f849ee5ad5996f83593cf63567146e78f60ce04935cbaeb718ad92515e14f291772c27857e124f485b4b3afdd2b57170d1174557dd9b56df7d231a286ac2228f4cc2f53b7d0588e8f9a20c6a88a16caa88c1ac25ebb55c0aab1fcb9b335634019358cd7f62c7c90e795cd6a01ca5324c9642f8677a31d0b5e82ebc252e84ee4a1d3c3bb84a9a653e3769e1d3680c4abf8a08acca9111a61938a866c2261b6a3c0f66c62091cc549501d300db69f6a651608e2089e1e5ed7f021c0ade765fa12f3c03ce42cd226d71fa93791ac637757c25604e2bbb7e7be855b8cc113794707084381113c5db11b52fd34de33bcb87e1a53b3324b5eeb60540f023ef1d91c8679d351b6e706d5937216340b270db5571d3ce2dfdbd393c9f004e379c1884dfdd756323d27fb247858aa61724a7d82c1772ab4fd1c01bb86b49ee46177f2f2df68c3fb91287f5af7fa99ff40cfd46ad089029106a6d144e14fb33e8ab0e8f6715ded528ab58d087da97b52601573b69d58987dc344cf99afabc61e8751a66e435aa51953ea3b46008611d0846027f7c38e9eb924c983e671e03f4cce3c0bcf70513eaa41fe0c186f051a3b927412f7d1d01b87017e878509657e76ef76fe34a9813b721f5e45897b57cc020035da7b6ab124b02e6d593b6ad1408bbf545e37fa51227237ae1f5a318b561aa4c7deaa6ebcd94d212d185d612f7703564ba6844944f24375fff56eedd35e34533ffb53cb3e1695d5ca4d52ea2a519acd082c1b37dd8afcf69b99760157b9dc73d3df3be27c6673eaae6e8f26f0ac0e7051bd2134518f0a0b988f79fa868934d2affa751b7ddc078a8501e59a7e88089c182ff8dcfb0a70001018e8f03c0d40e9e8070c9a840473eee5a4208e408495446f7097f9311389a9cc8a079f8ea6b429cd7449d50477f29555822e0c43a0d54c64ed66d2c40af86b1da8ba0d362c514c84384d7807f908ad81615e339ed2187a739b727216ae57d19bed18694721756ce70b0fd85ffd2d73483221181793fd7ac3733c27bad1c22f778409125b35bafe57309d5d92a56a858f6fefc0f374c0064b3d0b439c26407f53d4dd2b7c2cc0bafdaeac4c7a092f1cd272632fa5a658e6fbde31035cf19bd7d18875fef6b47e1a12eafaef8537ef15b8285a0c57b65662c4736755bbe3d1c4cdd4c59eedd72249e90ae4969c700ec3e8187aa926407f7f7c06c343b64972eb72be1df4685a263fd4b12e5e235a9f96673e7c6d93e015589b2bdafa550381aae354940f64f3fdc3e97f6f46cb79f4019b122fb7ec864751adf9e4d903060400cb952444a8c0cea05e894e9fb2d087b49e8aedb110db6a6dbcad7db51e6784b284fe1d78eb04061ef7f5f12d3e79ba4c4a897a3cd52cecc2b7854b0590b68499f76a693f81afddd8a9405ce07467a08ed16d66214601d148411d0f1b251582de9e076e9e1c61905ce5473e629d858c1fa089032b8b4111efcaac047476bad042960c96ccffbf97537a046aee3c99b56f4c3d9b0f7b8de1c6daeb3294d6eac127d7384ae005f8153acde4a9c894d86c794ccd170531460791b7a97802129ae106742d948f7d59b9835ffb593e88a31c6117855e266d2ad922fc5403f8208c62a7088c7b570214d160b5d2e95cd93cfc866c4ef8380b4f3c7021bd71ff0aa6803388e4406ded131bb65f82c2e2863e00cbbaf2619752366119972019b74ba896eba7a714b459dcd65364598e1137cc3306e41a41a79d3fe4e0c0c232c7f31344c1645a0b0b7c6fef681e55c70801408a84078255e16e5ce1b300c48f37f6176b22efa9fce24af9a6876b508b41c97d2a76b273a5be5edb1f1a97084babcb4a717160ec26cae9b8cc1f7849bb23fa3ea4752510c89a15bec6f8479c0e741f1219e007f929b8e8cf4ade4d648695de9739aa7e9bce406a8a469865c7485b99a151b8dec665fc63e69ff38170048f6b8058d3b8592a92d4ec5144bc89455b5b15996f133f8af011a48613ea568356150396c525b2e1c1255a89fa403275528d48aa104cbc0e43626c10e28ae39b5d0cb98716c819aecd1c31cc162e9fb6d82d0ea319c5b8fd751d96db073b4490cb3fd24900d0d04139afebb384b79e0022f154e1e4b82e7b216da0978e98b83bea0c04d182600e4c9617fc5c5efde0b5eee9dda3c6b0a3d6d85f903359533cc8c2cfd70d49de6c0534bb2497c9640764247acbd7de51836731a1e878ef3f6f35579537036e5c4510e49f3a2867f468a594481035cdc2833bf915e00a67c00b852d8de6728425e0dba117f32805d0470abaccc8e41134641643b419852728b36279eddc3818722e5ada3b54395b35094a05d1ed23cb7b15d56bc1f61b6548d044e4d1807193344998a9dcce612d33192c6d57293e9e34c89d75e55c45386f5dc65e64f832a55c8e4e6ad15871b6b0b2fea91b507bb52f0fa25ef2be48c7d23bdc20a247f83b47dedbb252f911ca8cd6668a644580334d6515437e89519fd682a38f7e8a988e9e18229d6c84fe90fcb959a94fd2623028e08a8b120d52ec35863a255d44f80ff7b1b36e7e5ecd7b93b1f4329949306f568a7fccb786f48db793fdcc0197af5388eae61ca7a4093c7dedf4f4d81a3f2279182a03a9f228f8ef8df790d6a3b3e946db0e3171378b241532eb3c8439b8de28fd4435a4381895f2cf9cb988462d376d9e9b3953a9a88dab0d7bbaad08e9dea222a67316a7f4f4d1cfd8fb4ace121b06a8a336aabc9388e703a8950cc5b48da4cb0746ad75f3c58d054ab731bd5ecb95971ae7607113b83fb3f0edf5936140394e5c2844675b8dfa2f4b71911ce7281a82e611f32110ec7cbf44bf813f2e71e9cd2bcab1b61c400201bee7197dbb6b64f93255a729cb5533986c0d14fc9f7e29a47538f8b3ddb8464a6f76abbaceeb44db2a6b6d548d8ca5049910352944539cdb75f38858a23b1a8fea6a982ca57f170836defc640958c0323abbdbcd27fb2a2422b806564e0a4d6474ac4a4350a9020c3a3ae111989326c5902e259cfae28e8406bf7fdc03ec9a675910faa80b9cfae94f9dfbc1d2dac12a6ced142290bdf01490c3b101c1e3bcf6ea49d2031154694f2573cfb0ba6264fcd85ed0a5bbdf1432319e6a8914aa73bf60324bcb1fdc497249e29f762364308ead143c73a18b4c93e749c9e5b0afde14d223702ec751ba347ac6b11513e492385cf367d16a8348526782a376f36d2a087d9feb39506834b2402e69f14f96796b6508262c3d0c704e892b7c8d53728ae13cafb5e26e938a207da67486a3a405a0940c2d33d457a9610e355666ad49ac208c7f3e6573d6d9fd1a17bb52509b65532c5b640af194f1903ff5e8b03d52cc8dca968827b9f398512c186231fcbc4dce257c3850b5520f6ce773b65cfb5ffe9c5906cd329e8588ecc0db4c1aefd1c75b3d572f2334c17107898c4e6eec696fb35d95e8ffe58ba0027b3494c2205357b21771bbf779b08952f9cc686aece8df93756499bd9b91e976af28efeb188bedb08038aaf7997dfcf01f7e530d53d9b9d75efd50e131aeca7cceab27cea217f324c399a11738923ae789ea40fef3db1de4f243af0626b7b02bdd4a207cfbb979a792f1158914adfa2b3066bc957cec737a0fb6b2546cab8e6f3d482d3a96e22fd021100819a5ed55011e419096e31446c247ccdb9c60d02d0f1db3fb6720b4e4850091a3ed76934124d0bfa1048c351126fe43e02beecd68de18bec359cc6fa57cb1795285709cc0ec4fdb42dafac56d86c3c0754c70961a0a969cca805a825ee7659970b27a7e6fbdddec920b2cbbfdbd27a0c372e5d3961467e10240484f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
