<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"981e41fc97cfbf183bf77dbf2676f13d5c8c841a5b7fcf36e3ff961b0212a2eb010c3d1da238384a73e96a41ae28750ec5cef2b178e916562040c9668011b381670e9edca14c66b93c5abc72273ec62cfd211c3e87725eeb492f03577b5d74d2fb056a5575ff04de5560d51b4bd9dc424243504d06506ecd572f19f9ff1c68c369e3f85544e16029fd7b995137fd2f194ea44aae7d03b1f2d2a5873bdb323aecc51f00d9cc277f5d42ad9eb592e38aece0447324e24c5dfdcd44449eed15d890b883d6dc800e30670e066587b8ed64fea3d071d546eda86bfe3fd5b92199a58d1f17b3a661112ef78e9c17d1bafe406e8a5349c189e2c262cd22e1cf44d456689fe75d9d508393b0452783c1c6b79db38444a5006d821da2bc796af22d3a0bc35e1c4a4b11c1e2a95655f9bd9f9ed76b90b2b4af5f317cc4b2b19d74d8146df1d4c255ac0c4fdaccd1b0fd72b155ed3408ddbc16a4775733a037b0fea02fa0fa2a01593d3e734c6cb2bfb03f5532a5f55bc10a47ed2cc5a3e2d33699cca877bf043832cbaf3917872e1a3cac41e758ec3cea140a4a1bc6c598a4726d8e9e2128a1a4c2ad42d57a4b71008fa403f8eb53e0d83a8347f703e3cd3661fbeb14085927c846e5a4f737de9ff52444ffeb8c05ccdf50c41968d7bd7b6353ea382a4b2efbf32d4abe72f9bcc9318dfedd0f8258329dde5a5ace25293aee03f2fe009b5742d1533f198775cf770984fec84e2f0f9b40458db1b5aa54bd819ed2b30630e816d8c66ca80a3f37a2c5398181665c4a01620dd8fdbb302d6a10a93d5309ec4cfdc7f3e44f23d20061e9d6a0ea0bc9da99159cbc2dafd03ba7f289d7d30b20a8b3a8ead3266bf6e489652b1fec55fd216cbc6a2998821ca53cea8e27533b77f5ed13043d627ca22726588207d8615c9093e258541ab484ec3c905cdec7c13a45f471e1fbb84055350c14d2ada41631e30efb2bc4a270c7543e8004f872010d4a62beea3133b4b72cf375ea36bc8b7b9010696dce93bbafae97ca412a1b42fbc58b10d33df4bfa2a3e3cfce774c085e52c1cfb88818052c69ff32367f70503a04977f163985e5465e1146f6ddab9bbd548976169625aea0065e12b24c8fc3b7c3c08c0d524b71792b0931e50b345205b52ecb15ad0249c6fc1b85d43d7dd1ad8b9ecc1b5f8a3c444daf7d0ad2e0ddadd1f6ddad40c4b42a047e40e1ccaffef43ddacbb528a899f3cc3e10ad10f7b300a9dfd4d0fa8e071eeda062081fde8c29f9ff12e843850d48bd9997870450c31928bb1e9c1e2953dee4927f33746f4e09ff147a442183cee7b7d9a2821e441f62a8ba395eb1bc08b2dd4eef978612bd6f7753b07fd7cbd72938c595c0251141a1796d2faba5fd8c021f98dae394abd3159149dc88a028d9a5142a2b52185e217c3e6832d784d515887a5a59d56f395e28f021c347a1f1c69c585b52dc118dd3920a6b176ab93aface31f9bcf75aee9e0e17e4c4fc67e1289c4b6a3beabb796abeb8c737b8442d097ec67c8433e7824990328b3ccf03390fac38fd4c431ab6ae1d8e8bd74c4db7b6efa9b81e98ce8aef070ab5341fc6a521b2d865c0a152f001d49018b9eeb18fdafbba7b662d672a7ce0fb722caff20cf3d292008d2bef983d04dfa74080f2c27455c1e3bf9a6c86495253433a9575b061068fb512c7d82b29eacbd55f6e57195f7f404f2e2772b8b6a46965105e946fc84dc4dda24c7cf171ac94495ec4240415897dc52fed79143cfbfc93ab49250bcbec3a6ded937cd1473382ae8a81c745371ac13f6edc2eaa1179509385132e11cff8c7bc4721434d0b0982d11be6ed32bdd6716f82204868f1840bd135211e9c8afe7d225ee3e1aed25ac4fc1aa4b63af159bd99fe928fa0c0700077d9a811be220e8dd7efb6d49e40c58d537415ab8dcd65426a1a1ca4e902e8e96764dec32ffbc246ceb02ca164bab9198a85e537e175cbd3b28f51775155514e20cd492fbb56c5784e862e531014b7dfd9069b33e7089cde9cb2c001e66545a4871c3c15998755cbeecdcb4d8f15822e31ea6f9e9f7e12fe85d4a417b4823f1eb4e6b578b2512957a0deb72a10783d35482c1b2922e20047d3c8359269e9940bce710154777146ed28bbe3deaa7cf6976db033e280058c37129d241229fc5db4e325eec7c3343d57c955fee0e57a711c69b8cf8aafff06c8f433c2c352e97f507a4d643fdcb3f31639a94ff5f5b5ed0c85aeb25a84a990d53695153d76add6d77fd600ff57b8d888b4b0ea54917d0d61e10e8f04975166d3ab8c08a6ebcbfe1ef9867b9efe160eb17c3dd0b1993b7231ba2ce065b8b67a13ecfa11fc7227b3c61ba3260b1ba98997779d5c14ec08325399b258333ae0bae700615e6b1c605fa97f4284012156a520c9047693fc7bcbb3eedf649093785960e430daef9bbf849be7cc31aae81973b2cf42131dd845d73b48d1a5e1cc474924c65e7063caebacae840b5ea66119709ad301898399521d7b17152b924d9a5217f70fa5882265d0432f3014c4f3e0b9cfc6d511b13ec595871641c75d07bb09438ff26f17f5112192473f448ce19e787389ce60a986e4413e34baea7acd1794e0846e2213564d6312a47f76ce4319fa3f1de95843431cb4bfcbd9e306d60cc1be4aea7e06649c98100fc9cfa6eec736c00beeb06daf325db45ba2d398138ccf29a1c2806aa4dd46ef28282f9bce46ad1abb0c0eb995284f89c53742e1c2f7af32e382a6f6b2139e489b64e94295a7dfad1bf1b6e9e2866048fd1df0ef29ce7d5d912f20c2168f58a98d9765a6c709911a89093097f2526c276c71d121b48339e97799077c3efa7e9567c9deb9aabcb27a9f63988e54573032db097133f0add2885baada33b2bfe530039a0c0848d19aa15a25f8b1e2f052c9294e440c277a42947a1d3d8e3f2be31ddd72d09bee7fa69193e86486733a68a5c5b77fd0f7c9dd826bcbcd028cd51c710d134252d2f137b8a9d972e3863ec15355057031e655a798b31fc960f4f00cefa9cc24969ad4a2ad9541f8bd7867fee2dd56a159f3461e8aa707c613cba9725409533cb7ed2746f18b637b218f1836532f7bb590f8db4c2ee3dfdce7ba371a386114e2486d2877924de17138fbcd06a2476007829fe4d2b6a08e399a0752a515db9b9ac98ae8a97074b4cf130b2b8c207a43601d6e9395a45e9985d8753ee4e4d92b97f466f60202da996ef4cf678daf9bc445d250c31fc148951e12229fa3c3229f2db3e38e3c5b5470aeec14af1c1c0b908b03968cd3827f09d8c4597a2b09694c26195962aade07b750ff72e2ecdc6b715e014dc2f688a202861eb2f80fb0ebf47c3b387e35db2a4b2f42bf804d348d5602b8c195cafba264f6bfa6c06a0d750e695cc67e6bd7f76743f18ba8e0a6a9ad90c87ff30ddcb8a60fd801fd2a1ad82415c3d31d0b181a2cef89959590848aa7fdfdb649ecafd9e3d6f2b89fa25e32b4a964a8668a43bb56dc500d6b316f2c76b8b486442435bfabc45ce09e535b8422d0edaf8837bb1c5267c359ffddc2a25926b8b4ef9985ec4e666e695a039609181aa91c2f2efa9706a0f6ffcbadf83b379cb8acf144f3389d500a99c92a6b9752a679944694ed3384fe3976c6fc11f1c68168860f0832a8e6129d38f6c5694d34c5e84a19fa535512cd66894df257f02e22dd99deab5595a25661007a79a2bca064e67ff8862f66bab56ded61822ca0f94448c19439d00fc3840dc4c0c075e50e7d146e9b4918ef2643c3389336cecf84da2ea4273b3c01b7152d81d53dd04718a8c5964db5102ef1f46af657acd348b5807ab56638c9390586a15d9636512d82ad9c391e779b35d591d4824551a40bb118007cdced4bc765b24450869bcdcf85e27d5993261e6ddcc948ea41851687013ac5d2fe5536b0973d6f2cc8436c8f3ca4c64e88773c4969eb9fa49293c58bdccdd7566313f40d1d336d14b2d6e51d2bd69ad259b9452eb59aaf2719a5e8e3da7fe37d47b34a12a90ca118e2ac3412829e2df1c48aa8db9cd9cf3b556be38279dd7d7fd4cd3b89632c3af34dec822b07eed6b675b98a797fda999106fa0c11b58ed83ecbc918127a876b72c30373683bded3fc9bd1852ab2c61b15975901315e48729cc599504c4ed7953f3010826907d5d573435b09cad9719a037e2739d3d8dfffe1bf1e54134177dfa4b478a0c2fad73b3668ac578a9f07b536839b58db5703ed1b2db1d60e760e18391ab710bfaa17009f50583ddaef3a33c726c745dfd4b3c3742a97b1972710e75bcdbc41f1825f9eb3aec00e72e4e51294c034fbe202ce71fa15740653299f393b08ce56ce7dd1f2b3d2240c6de423230e18075687b0be2b3f0e37598db4b6c72ba56a96480f187b6d0c8183b60eaf5ee1598bb98b3cbfd64af85bb61878a887dd048be7a0a9bcc8f07274324490c1a21f8ae7bdf3e67e70c884ab0713bbbb36615645d5aeaf852135b3f8b734025ec9aacdee6e4411f022d3453c0c517b3a08bc514158e45a917d1819595a598005e94b9d8c023cb033bf4c01ec177807122d001f434c7dee19cd15c4ce1dd5998d4bb8bb81b2b402646eccfec8ace498c9113c2062b183850d89b847af11f5dedc402fa953d67f0ee03e250c81af71a7286ff5777b8270995584747d7356c52c612c599babbf930b6ae6f17fc2c524d5267144fe33852027f058c9a9f9027373e5845cfbb3d008489ad54f282dd61bc818aa5b31c16e2ec5f8763da5eb5469cad0e1dfe5372d8b613f27efb6c4068009728b14ea6e5b581a79f8c98ded5aec2860a74373edd617734e7cac260bde9006590841e8c570a14474709bb3bd675ba19c5cf869d7fd2315cb45b03fa0d2fbae27795750a298c83bae5fa58bbaca7bd610c662e6e045975f77115980f6ff15c4172ef8886abf2fb344a17e717da691dae5bacf171c720efdb57693942be485489818267d57ec104d6d2a49b32a87b1293c8d1f70d83c4bc919efc68ddb54b09cda0207d8241f36e6746315b2f767cb021b8f66805c3f42f8867a2512b120c29f34ad1bfc704f4fd5adf63e34eae3cdd3d0bb97e4babd22264b34e97fe5fff82b3ac413ea5d844de7a05465751d633bd19a2e4d265e6966a8d47c2592775edf1cc699f871756bbde8a550825b7ea943ac8133e994ef69860ea42d1010c08ab580429cafa93226b38be657af781e4fa8065e12782bb0aaf03baf9e822be1ae269778df42703a115f7c20343de9622bfd3542dfe4c1934e3e3377cbdbe9dbcb9414b5b4e8377791e016a3a21b56fcca143aa07dc6ac3f1095a790b1c8d1eca5f139fc708ccabac6a3937bbe3dc3b0a581567b3dcdf97b11a18df1c319239df6bd9c653f1e28739a079e633450d52934dc6e540e8cecb3ebcff625a3e4c7ebd6481a1d3fcf5ffb092486a5bb82a970b1e955788975828f859f8d525934c2b03fbb632f31599588f9c9f0d9b628855ba84aecae61d8463477900694860358bf47d7e45ad0e051801fabc3534eac8466ae6dbdd190a0816c60249a58572113ccf64da4de3ed40fd76eb72cb2407e44e6cb8658c3de10a2479c5877bca625acbee41281ec4b7b171d21ea6b022671468c05b63a7b8022435c0105c4d1b01b6f9a061d116202b093ee3b61e20e8dbb05a1448de9cfef989d3e661f245573e3b0cc8ca7a5beedff423298a50d625ff317b8428da28fcdbe06e0341d11e4aafafe8814babbcff870140f9ff0f4221bf16ae93e344ad39561524bce59340c5e9d40455d5a4b86afc6e43af31e19c40aa64a3ae748f51f8b1edebcf58bece805ff6ab4b394797236e0972560da6f18de674b9f252f8d1ec5b7c96ed6bc75cbc0bcba79afb2430bd4c30c8528741909dc4c18b7026771dfe560c18facf1323e02e449cba00e184a66f75f93b02321b4c75e833aa140fd10952a6c24fb6e9ddc712fd46de7e0fd333bdef9eea8cc30b6e0c6ccccad5f0cd3e0bcd6cfb13c90387772ed75196cc6d40f952b18850f256e5d82663603321a8ac7909020359b5cb717be170fe6a555aebeacd4b684f485683327913122f93e85b5f6e0427c5832597ca5869a33e9c52f120a9dce55c561a9c408966af550b018e515be141d2454218e31ea6b3ecbca392689fc293bd57987b2cc92caca695b287366ef2ef6711a1a14b51c103c6a707c5f68d8e14e78d936f1ceaea82eb3eb05ff204e0c39d4a1d0cd2d82d033c846fe80fdb65bf16d714a74f529cc46ae797f81345fdb9371e81ffd263005a79e43937ac6db82aa08eb9b89de4a194d2f3c7f57b0c9a42244ff1a195a38b568e2b845fe70ba9a97742e554125fd2f60ff4fc42840a32e16f70a061acf74163a8cd32c8c229d5f4c05f6fb5ca1171502be657a889750d9c85d22671e5aa588ffa91f6a48abb40707605375eeaf737ad0b833e60ac678a4a6a5001b2266ee8d1af7f40937da7608d80fa2c4f7437b496c8c3cccda3d9155b85c82fc2b65589b19cbe223b79158388da22ab025ab1de798c3272d2048b6030a5579a03ef11e2a6ca3aa1e472898a6352b5266733da98b2667affa84729ed677d259de42a00dcaa8f4b29342bba992e0d320aaa2b8467b900bc6036889239159be1691186c69f77252206c2bac2866f28a3524e40fb16c2eade4704b339b8ad0d26ade9eb2e57f20ef767295796b3dfa9d26bdc1ded298f3bd6f91919289addd17c3fb535c456cd17e94087c8c76bb4c9871d58be861117ec87addbc5b007859689a9b559da01bf689e36319711b196898177556a40f74a7f5505c72ca63b52f825962ceceffbee83cae6bc94381d97b6e34fcd0109d0bb90da9a9a55e1c52531c6a54e3054921cc6cbad55f6e7a2da49ef77b3195b6368b35d711195a3af1d7623408818772d7c5a6d225a1ff8573cca13c995b030bfe40ab5401efe4659fe8ee7e293e26664bc8973764577fd9b380976fc8767584c9308f7cb791ad8d6e65fc42aafa8800483f95ceefe5c46ad53882b4bb1dd0201e1d06c6e771a3978c52157058517c0f03191b0e4ee7a366b11ab9ff18c7fd17b811eeaf317d051c86cbdd69fa9c90c7a1bdd46bf57715858189f25ed6be8a922001d3dd6dbc7584a049a5954137502bc9ee05b7202abf273b455a2a76a3b0acb28c716ef0b3a370dc55001cfbde03abf12fbb13d4757f4417e42166705eeeac511f747ed38c13d584dad42a426de511cf8f025d54897a1e528b5a25ae621bb028d554d1802ed36534b9085fa6658e1a7f0a6166513e8a584f31d821d136b223f7b20720d26550532e47d04d6df7b1e11522adcd5fc0df0731bda3251f06672b59700ff19fac9bceb308a657e028350c1b302eec972ae68a948f0c7b32e1eb3e0c624440780c9c3549b75592e188d72883746befe7aaeb7658c27df2972d1424920c256ed0221944bb2a5db92d6a6711931ce9073c83cebb8f4b4b0cc9348ce7bdfa4bc4d5726672f74d82a6952a88bbb3df3fcf32c5b7eb9ef949aa6e9442b764a4e486f36e133f21873ab9c72dfad42b08191002dbe8c268e806c9486d87c1ab9943a9e9d4b81f8a6d6c36d69f08570505576a086c8de49e02410b04b3d1b348b48e494ae0bedf1c5610277a2d3ac089ef77e03ecd9cb3906ecc799342ce311725b415780b343ee8dc203166d2675a8adc95ec343c92b75b02e7df3215751b8d4f105631a72420f1e4fb4051bb960856cd2b4f7425c9bfc9ae82289b33583b537246a813f4568679b223418859e9766fa09e6a52a5f8ef5b55c778abb502da722a3b36942dad77253f58ccf5f6ed2534a862d35bede948e876627fd050f7aad4b357dae10a7c02f223bd3549df979d729c9975bf69d9f4e3ef9dce27124bb2c62790fcf5b0f7669fe9a7211c5b2605840c2555335cf30fceee1e573e4f5b6a3c547bedd27776d955e14822404605acefb3f71c7bce4a9b8521c696ef0ce77309a9de365ffff40a265a22b1a7574bc0ae4d0f3a08fa280954abce55296e2e20b036b18bfed524a5527841d59221f6ce638314542d3f73c06777bf68c822011242942c2130449169f198e916a054a3857d61fa1b26342cf4802ae250958009b5208f88fa86aa58a208e872c741867e86ec466725a4eb18f7937ef36cbee0563b1a5a489e7d3235879cf03e0084559250008e8ea32dc14974d8e19afd57fc10dfe2075372100d86214e3db4067cecdf6b78f5791f0804852a4607f51438155eac9187ae0cb09f8cbed14cadb5dd8ee571a58c1edf4d69d079a6b97b37fe6d411eb8f0264223b5f8d62c45f80d1b4bf22bf129380186fb798647fc71713ee45ed31700c0ff07662f43dfacd3700d13d463e40add499824cc43d5864cdbff69c47d167eb78882bc6ac48ca2a9d1cd96be37aba2712653a25567ac34b301a537c134e8839635a8718984d171b28baea28eb0b89d170e0b834cba4601b29349c500010baba10e39537dc5d6e87089a6461c60028b1eb5526c0b9ac564eb008c878644a510043ef4b54cb511d710d2d85da0981961d6585af3d88e27e0206e0331ab39656f8f4731534ee8bdb49de4d98dfcd223b53b8e0be1acc20793bae62d5d2fabc30919d4441542e548a8f5bf2cac65869da0da6d841c8ce50f5398bfde61bf87be3104cee6bc77a73aecafc8a05104e1f77e56b597fc64758e6f2bbd2ca26e7a53a8b3dcf0b98688eb2a436bf5da11ad500646790f3666e112e91edc843d7cd642d1812ad6cc170eb5df749eb408416bf6354d406e80d1c07bc9daebf87a702374dfffbd59cadf35724fd5003f3209a78d876d801c8ad6873f026525dfbff7a45e5d6e0dc06fa88db6b12343d2b66a9455701165f64a56ee1e822211a518dbfc0aa151f4cf98d623ec29f27407835bb5bfbcc771a6612e37f6d41213c65c80628695f101cf936f97656a40e70b130c04388a95df25ddb643175bf78935430ce1f18f956b35df72f7ae03bbe21d664a407897bde8c33be085087af93d56f92519c67baa31c2602222c6e6e6645b900a8ac5d75491d6130331450a6da887d936c2a50fd6ee3fa0c0f97ac5d8e322e862e79f49263a46e0eaab299e505a25f3ee2f100beb7624ff0e1a011e8c1f5018db5351c8dc8f1101d6337217e6051ec31a286b7802d191086a21357f0d8f32211ddef919149aa9933e2e0cf481a4de16b46c3da8f323c2728f23dba4cb3efd8dfdacd516c408d8194d9ecb7f3f5116310e61bf7e37be6177cd8056879d770ec67865d30ae9275e10d32fc3bfce52bda4792fdbcb3409a1e3ea22dff50cec414dc57483edd0718135377898d3907ddb2ea734dbfb303c799126dee087aad3946c3b637cc8115646dfd3060ee55f6a744bb53bb5bbf6645784666c405a37371937002673bba2f70e2a8e2948dcd2074790582c7cb1fe5c80df1e6b1d2e35907e448cda962f5209071d59ce04646a8902f992f2bf9d6c02c321351f622c78d745208eb9399495fb27d033b8e99ff9989c1c9d0a94bf8ce6ccab18182eb9881341859a56c5338141fb8bdb2afc0a881fa0718c9a59ade75ccf9de82658003c6a86d327375c2a3073faffb40c012e03125f0480218c3081d15726ed5c535ff677157890f9207a8b89c9fcd5653e2897d9359355781230d41eafe7fa83225b28ee5e7c36f05e21a0579c3c79a657baafef288bb94584e2abfc01bf9af55bf57070ccfeb0294ed2de65913d52d281eaebd605ace9d8c932d420971726bf2a8124f530f496615efcd8b966ec827410b81d9c95c8deca3e1af080e5c326711ffd17076c8ad348262e76c78fb7c39f532767370f6d6999ca6636e34995c7472019e60da423741761580e1ebea4abea8a6a48bcded5477479ef619b2c6f42fbb5910a2a2161c9cee00e792bd8e3592cf21b70bd4bc431f41867b734b7a966eaedfa1332adedc1ceb55cc2bfa86264ac0ef8c6b5af2f223825c2fb61464bd1572beaf1dcab6102b048cf8cf9aafca70c503c71e2bce84a88b1cf46e5bae882a276382e5565d06a397316dbcb80f159cd71875d776b807653d877291d9722b958350d07d7bbb651de88f2dba76ea4227dd86a2fa1ae6f993abbf45ac5d83994f393d852130f4376a78947ff78ef72c65e0e250ccc0cb1c2174f575eb1a6e7448c294e2b251dc7160cf71bcb3744d59e4c77947e66183638a53e508993c9b391b2b26759eefcf0c11a72b359ff7a7f2fdb752ccd7b0f9049e0ed8732eb0b2ae1697deb994ac1a1a8705cd9e5e7d713c875329865f2cf964bad098e7e15db76cb2797ba5af7ff4d514163a4acfb570f1e32ffbf73e436a9eec699860e7265017cf1d3f33fe183ae3468474aa3bcb5f6239a3ed9ccd0e847ec67e1bad2bdd2d9f6dc8d8a1d03f01dd845ae19ef5bb255994cc86de95301a97811a000d0b843810a716319cdba9b0032a9b0fc3c665e5838ce950ea7df936b72bef68e2be672526cd226b50e71b19698478e3b912e599ff99c96b6b19765101c547660f08207340804beaedc37aa0311a2452b9de5653a6d740634f2e568e3d2e988897b667686bcb391202f110b4695e437a390ff1f2afed410ab8745f31e86f81a36f270050dd649cf8fa4eb13e732d00f075d40b474df160de75b72df46cb66dc09493e23960a781c87ae623bd1caebd24cb1c49ac71c39aa3aa10ee61c2f88070cf27c1bb9ef07e827d5c808961eac295a7fe52a74a085d22a5260d55c3bd8d024afa00830de9a8b6bab50cd563456ca31c945d32ce6a69c1ffd70b921d73af3c958df6564ed4664812b195841a8d2998195960dbcb872336e1289ca4475838a4c5152cbdcb29e69cfdf3d148cac95abb758a38cd960ba5ea0b185798b905ea5c7fb46d1d9a313d814da10d26ff6429785bd01c856ae063b620f264e961d0d4a635b5823406bb4ddfd17f562058cbc91742af371f847aee11ff466807a3dabb66df0e47fb81803d27d334c73c8c0f19d771265937aac042736d008d84217d2efe721a2fc412206f42ea33c1e99e68ffbe0d1c2f6c0c3f816416d6526f0c8b86e4ab3e93c1301d2585894bcbbf36ad36b2ef1718e04c45edd46a44f630c660d48f158b5a64fdc1414b8c464c59f17db7d72b47f01598bfca7d06821aa73bf1744e716770e8fd359991dce86889c062b98ebbe856f92d0f051bf8a631e5147d020ec042466b7683acbb611cafba3d01989ce6a0f33ca987801d9e84af14082d237d05fac0aee582bbc25231840d471c9ddd6234f5186f0a8d439d2694a772599291cd541919a4b0d665f6b0d3e9ed79710733c2e55ec052f7cb313ce42875a0833e4fb7b4fe9461cf3af573f285183fe9f3967cf2a1638c5699a28defb53a4104b8a5d59daf4f08edcf6f0b5dee1cbd6b98407778ba6c72ac42a63ff001c3cbf1a9b7789196397c9d02a671fcd089adf8642af9af528625d11ef02e806ce0ddd3fecd1b375c353eba621a3e702091a34fad4dbed4645862ec58c2103f881f7661d092d31f423bc2fffc8db9ef1caba09f2cadf20177aaff568ee25efc26ee895b0ce9691812706ad922c5dfc0219b6abb68f3ed39fedda4ef810ca3999eff141cb4dcb509596111853baab0c50477d5d6ae55e3751bac7cc8fa077e183bc31caeac8072dc757d3ec4cfd4c59f49bd3bf0234f47b78a391293a12d86b463e81f164f3a8da022632c5ea3444340794d4638b2e434dc3fca362ae3b856e927d82b35557e64f4d7209e550fe7817f3f1a3ad5ac79d4b43a0fce912740bfae71d909a8bedbb11da0e814b7d9836291d008ae747d9ac488f2075014ce75f7404643c5735317bbc57954ff5a3aef47b7cc9a6e9e0f8f9b9b5b0dbdee6399cbd6acacffdd79cae488866b950502fc6125d751a0b58632dda75b5051ba4eac98519d766697d5b6a64fb91e4dd27465df58f11b50673ffab0c9b63737bd437bed10f9102a58ad1b7c15156368854fb5c8002f83e2ab056663667980a5449ca1a1634a912756cf362703e9781f95cf1e3df7c9d1cda768d4741f697cbec0d85e86eee31fdfe95bf49745fb88da05c7a9136772626b670222a6e8714dec3f5fe20d5d62df0d76717fca68ac97273a865da0e6c2d347a2fe83a115e8610851625f1509407db54b471b323fa52be3c4ada2633e8b593c01bdb69c7e3050ceaeb1a50c4c2ba6ca8e874f01f4d3d3e5049b02c130645c396f4200117bc62ccb7d778820e4833d2d740f53b18d9921420fb96f1abdb50c0318a1a5925ce98de972f561f84c99aee9040234805267c8ec3f76d39dd064184eedfdd945008c34d9b18346351506d9f1d044736ec7172c9280d973750e69c71a3d91d67c4bfd72ff8212a484552542ea977cc5853631efc8c4650184d8232a55b10a8776eec6b9250d25e62997fb9403e9c72556976ea6ced464f17d5e3998a8cbb4317e813e7f46116f505c66cab21db3b0989bc3764dc2eb2c924209dacfd9545cdc831bfc310196de473044688f7ad2f3cda0f67deb2b82cc768240375e3b59e2cc37e75f2e6d697eb5461f6b14d12aec19e47e321ced47ee457394e77895e270f91454d48fa162ff1200246e91d8806d36b6501b4932e1c49f3342088b1f477d538cfe8f0d173fb19996fe1a3113517acd664a4ddaed64c6ee85a63a8112d8d3343e463e64ab538db91183d66327bc5e03ae85b0be69b5cb904693803064fd05883943554dd67b24af576eece8018e046a29ab6e47e605d378bde83dff7c537ed2a31330c43dbb7e48cb1cf5e8f553898a02d84ea195e088b5badae0ac1885b23d914e2bea0f322fdf7a0356442b5613131b19662e7a7bd6fd3b14a05fb25b0a549bb77e4a48feeb1af5f4b9df3d776a806fe52e7f8cf02683119ac58f57c09f7b7b28460c06c85afbce2e8fb38554befde8d6e25a513419fd12b998c4a1bea95d5c3a59fced87fdcb060364ad78f5422e0be4cf15b8f23dda113c10802bfb4e50912d1f45f0e076d32b4c454080dab3a7ece71539e23e465867319f10bc035362539b4e1aa7ab0156a98a8edb87fb2e07eeb1752a4985c23cd2b6fa08da14fed84d5c2cb4323aee8ba66fa92759b0dd6a202f16641194a1c93745bc6a210d074498018ff4172cfd6eb74b48373e8c25acf4ea631758827a62a9c33cbd9a0c941f8f5b90325f028535758aa58bc8083cd9fcc58bffe0ed34b0a8d89e28d09fbe313b929c975292ca2da114d31c48159907b80e53cb8434a498446fafaf5974dca041dec41371b987d395194250bd3c795b2e196b4a440b2c0e29bdbca78c628701eca5d4974fe07d773292cd53fc95cae8c72491128249fb579c925fc22488c85a0fb281c272d935da75a82e3c81b14295e9d3a4fbf175cdd8f910d55fd72e8cc06488ed66b13fa5cf5a7f98e6dfebae4f3859e8c9d6e50440f77d34aba518c7fd0b1c178f79d3ba33bef54543deeb8a17452ce041e782e81535b54f3d1813479ca374ade5507a66acc90e94816e50adfd883d3575bb827c777c5274b6193eec8aead176b4b3bc584c7db933d6d89a5acb906f480cb27aa065cf695995308352c7ad8b30c273dfab7f02c5b1dfd7af1f084d702cf4a8c5b02ac2230f02f1d1986a707e3ea4688009cd7393857762af416dcf3e9e260c48c35145051e0087426e10c3c8651c09e562858f45715b9264c9e039511376582fcbfc88d4f582fb3b5dbc8ca2b6b2ae61faa05f24baf79b265b2505343ffab012771a07e1a9f24bcb28b73b25bc43849fb2b0842086cc37d738e9508aca7915fc86bd15fffa245b255fcb8ac4cbc9f70fa63d487778913869c2705983f56a4f486aafc4e078e46ac66ff3ed244a28cbe586c7d1b905a2d36d42fd723f3465e247cdc1d533cb36b45415f45aaeb3ee3b861f866f52eb4045e4d9f790250f520f6b6ed12052478c5e3d09de55d97195fa0abc04d67d4850d6f4e9edf857008c93a25a89f995ca1420deeff5eabd89a9a9b1b3f475817e70678753d91d94ed5f5ba0fd95cdbc47a3c379e1352f917a29d9644f486872b21a942ec02b5582576498f531a67180919a258e521e35483ff18dbc069c1c57a5b32d8cd3d8c9da7f7f69fe3e26d32a9128d63cbc4b33a1f057bc3735b523817a9e1f9e561962234cfe8b150631aeb5552d92728d2a4c70ef1385f3e5d6afb2b903408efd9bfd2f0618ba9b2c4c354eeb9a7daae58b523cca57094008fef3cf799ccc766cc3b8dd7f9c6d7ccaf1bea23100837f7bf80f4eb697ee5cf15838dfb77ac5ff74a56b023491074dbb58f8184eb305b4c063f107b852216d687415c12138293af47ccd990b8ca745e444327d4f534a477570ef68659d6f1576bfa25ebe02f25f954c3240da79aa477a21add48e5b12bfef94f0a1ad1ee6e28da894b73ab8392c2787b5c91991649ad46b568c1e775a8574eca1b9f0ed94fbdbb4b27f39a40b93e0189a63cfa79fce4d6061bd4afc002be6595280d90f01d3fde98ccaa8d7880cd47aa1c25b3be50754ad86c00b0b961da6eb3c171e347422b831a580b75a816862be692f37e60eb43188e2bb6de5c2903156e17c6ad2047f744f907b265b74762dbb3156975b02a2d7fc648388c4ce834c8352c82521674c17ef529b547aadaa723f12939c881bdaa21e0f841163b25f8dd5dbf25d5b2e8bc7bb634b9d8f9a772172b2ac99b2d282e92e7162cb843849febc8bb5145cbfdcc700278db312d5c57f3d6f90084bed3f6d485ef01d32cf852fec199bd44799d0ec5e5142c022497220b2e3e5fe2a08d4a1c1efb4d46698bef053ca19cca3402115d83789cc407e939bddd788edd2555b0458bedfa6e3465a5a7581e0cb69185bf60ab711106ab090dbb4d2ee83fb587e7d20664fdc82862ee6e487aed66c69fcb8fc0e5a16d9442ff2baa87f633fa4debee8b87c9e4b0d95e367d9e2f7e7e992cea51d4a123732d76d1e52aeab302558b53889ddf8c50ac0289ff4bd678eb83bee1ee763349d3f936e2158577d668d86649b38575a792b64fc8039ce5dfcc2f74f1ade8b2138f70914261bbece765eb52fc3b5bf54c0888fe2a8b1f643a938859435e778cb8d83190479255274f602f07dcca62373c0c5abebb8620f187bfe691d0e69895fd13f3fab4a02123dfeae3c9cdf20f432beb4f7d10a6f1e47fb75e22a2ab2fdebc0e34fd490672599d42f83f9e7a4235e9b67e34789c7bb18981b919129311e08925ccdb2bab936ca56b6445d6dbabab7ed8af1b7ea22923b3ae3218f46cc7af88aa4332152d9631a686286ea45e8ccf1eca58e0899e34a29c828d24e244d34bd148b9ee1229be97799c627c9344f54fbe901fd4a304b82f2d133f93bcc709d3f2f28806a4c7ae2359706a1dc4992b5e77bd50871884164ac558b44973d6dffbb935c50ada6eca29d1aded344473316ac60a5f585aa41ce0c1489a0dd80feee9a2bec6b0622fbd8e18d5498e9372b2c6e5026f7ba6ae80976ff1375c1f7699db6b8e8b6bb13d5e97e7ca8c13702722e693d21ba6a45653a4730fa796bca420d7d3088e9fef112f97ad373b00bc5f749cac6f64ee53d95793608995d6ae169f5374871484783da773efcf00adbba99e69211d88e5016bba15479d2cc6b05548b5996025dc50a7c89bbd0c2db14dd77f88500ed86231a12fb566119257a66f1c6405e921a0d0bd1039b8b25a7bcb039c5bea1c11897a60fe97b036ffaac1f408cb86dd80cfc44b96249e0e1569c1be0d37adcb2860bd035557a22d078a815e5a9a9d725167043bbd190e40a34cf244065e5d06a468a1da770f9667557b524b4cda8fad5b5b9c2c9a319e7d933f1a002c29b29001360b94b2462f8e293a053c0f5d6dce128649aa7fafecf5348ad3206b9e47f5849b984206c8190359c7c0c39e7e41a8cd9b4b3a61fa19017b286af8b60d182cba7629826abf09c2ef47c6d31046eab9b1be1e715af77c6e51de1eb63e115a179ddb6eb143b4603c58472b8f83aaea45650483920888d824b9eed4c97bbe5871c6a27ab74b85a10633fc53fb33955bb05e2ed5da05fd3438f9a3240a3ad6137a2f02b28437a1e560b9bcbb4d46fd396ba5d3da1b84eddab430cd9eded03ed123af84be58c4ffefe3c9ac984af36796223f18c277eb67498416bd97a5f5018d4f4bc262c25fabbaf2881d5fa211173630abee0f4119f880bf52b3b7ce6e2a561ab236896e387633c77d499ca430c4993bf517f57ecb5dd0712244d843814b33e6afc64c2b87e88a54586ef748c8b938ccb3715476fa684583ab6ea2cfe9070943484f7fc1d0bba9917df1cd665e8ae5de660d1947b95660a891f97ef59b01741753feec48b1ad70f79a80c6fbe3cf73f8bde120698fefd650f67ce3be61963648100a6798b41ff99f94c87d2a5fa116a1b226afecc4eddd439071a2939c88c02b5339b50f7505702a9a2edaeb181e85996d3548e4654de280371920f30c9e4049ca74273c6483c89af67e812042a308cd2d8ddef38d8d0be8c65a861a6b85b109157df34d48a1995c32de9a846b6a1c568880bef3846ee37b4506ad42f60498bfe997844f2c4db1dce3dcf38599bc8f68ce1e21c3810d95c1d18f2e97e85ede3a30466c15ffb6b895f07d84c66232164d05b5c1176f083378fa4406211d5a61488d957fb9368105cae192c6d83a9b9156c2de5b4d75bfef6a663fb91201f96f49097a11455d6fe113f66c1b4c463a6c32721b37f158a49134212e32b708d34867d2d825c7ddfcac6a5e20e7477a045f2ee0b441cf8e94f2fc2338e98dc102d8e686995d04d0019f19605dfdef19b84073a84fc1f09ae01458eb62b92ce59e7e855997819d5d812872577821cb3b1cc5f1e4bf6fa0000c587da3c7e7ba11100d59b9918c5dd86d2b4a2af72f3d8ac661e080db5afc9106aafe268bfc3fe2ab86093116bf2182bbf18797a59a57ce4fc3f05c1f09927c2148dcc106b1ea1e63ed1f1886cca3917d9b88fd2d0b18c1f4c947455c2ab6c35ff45b8c94aa496aebee131c193117fdabed9a8e1300431ea761ee95a9fb6469593d0b3e595830d71f4b1423f421b39e401b8a1f2f9e536f704d80dfaea8dda45e3d04e6e901e4c0fef4dceddc3d32d2a80f518b83a24a5844eac0bca67c637ff6b3bfdf93040114c82df4178b03af8b90d4c304632a934422ab947a2573acebe298547c9e50f7bfa9cfe7e9cc81bb05bdfa102a41bdc61c4bb63e04f4a0c5a2e94c6816b44dfda45220b9c3c4e1ad561366989c7ede86ca0f808f0d99b1f37d7ea98c9a7f99b48c3a9276bdc3159fc32c7de48d66adf6d3d5c790619968d3a885c57540ae8d99a570eb079d8189553a7b1caf362dcc545b91b6bd3bd34df77de15ca2a389f744075d7f7a43ee87668e164bc38ff49586477991d0d5d84daf5ee1e82fb05d645d5b72c9dc4710385d0b64c62a8566bd4fb59557a3c59406146ebe5e1c5157a7fe88a6f659b6698b4f08b53fd14ac2513e6bf7e0f30006021baefa42079c5600286837273f1d9d8e2f4c81a8de3d8408fd734e9708571a18db44650f8dcad2a1f2afa1446fa63aff6ba187d8cb694e8682f8cebcd54db41b76db22b63831bf7e9d95fc02756b7ae63abd7cb323d9f55d87d3faf4841336679a5f71f0e1cafc9bf966bd13b0d5cb516af8b43a7844de8051c694f33b94287863a403a75d85f351eba6a99735f7f589c439e4916a586cea8e951cb0c9ceabc9fc0322bb39900f714a672d39b6bbc1dafdfbf6e4403cd38e3931d9d34e87c152766a5fd07724d726d32a97efeadb9d440fa2aef2dfe25436ab1c8069b151b8cdbfc40c1be7d5a8492499c98fd1685b0f5dc1ad3cb1329584a28b4ee831164e039834109ef7146efea086dfb52fade29c886fb42428a057944663998677e455ceacc72e394314732d24cec7630e0eaeaf25f8d1740bd786e31e8d24b238fd31d400cbd18cdf0d54ed53ed891af57e7fc2ee3bce6d06b709a5f62869e135e1c7ce419db8e9f0f40fa187ed740b69be7d2a4b269cc9ea5066bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
