<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c4643e4177c884dd448bc7faa94a0910819877c07f77e89a0d33739ceaadf06b4e758d6cf6bf9be0a3065785e42e8eb8eab465fbafc5d279525402b2f28e104cb0ab4a776f45fcb808361a7f816342be1d36018aca76848425a1e15437366285f94a7604f6b01cdbb063b7465c53c0b6e1b5333c5bf4657d0d857a2250135cfb66e22cb2a85c6aff3af86a254c8e6d3123be20cc9852b331c8932102f4e84b5c323eda3c0957d959795d90b6c53c2e0a95f9591cc03d89f7d5587b30a36f02121a7d69bcdeda6ba7434fc01946b55dac392daf54774fa8a5278fe5f9a8d49171dd43135a467fea43e431dd1697b636c646da9b2f241ac763504148eefbc734ed4b682621b2bad4c557d08c370c441ddb978100e7e716b3e8cad17389bc958143152a01c1032736185e41a561833d77a271844c03f1f87a47d18d12459b8892f716a6b829f7db537eb7020e683aae7ba8c01152357ad61e5c4c9c8f91292d907e683bd143e0db567ffeb776789628035ae617ff01ea8d450b3c4e9bfe5db4f57f14d0c58c981e9accda798c5d1e8329e2bae69c8f9d149ac4c90db8dd8de7136e3191fffad5dd2a1fa96983859af1c65fdf890e50c840af7d95052732cd8309d5f5347067466d4edb50d5d73ebf3fe16f73097dc53cf01fde224f0a8c26329b2b1677e1cddd694ea04ad89055a8e51e12cb374044dd9502291d4779757f492e5dc9abf7df7f2f8cd1e6352d03834f85ea9e2044b9307a1eaf267b71301894d4c2a03c97b1f7a5cd6246143de97d9b7b4529e6f9009bd35e0d59360034aa34c5fed2f10744d040ea4f18835ed3f1f6295dbf3d6756a74372441093388e6f3f89abc729f6a0e4e293725a76b3dfa6d5dc488a563cf4be107b710bed512303f0cb665438ada67884935ab3d5d330ed4f22fc6e37fbfcaf0027be983c7e50d99976bb6fb2e6c27a9fa358a9308d354d5ef2d89bbff2d97a2d5263e8008d14a6687be082df0de736a0a0a1cd7d69e9bd2f4b9f98f038c205abb712e7f2f3c931d1bdb77806555835896089aee437b4c664ee945c1a112e7d6951f393cda64960dd92d17828cff83a062e356a6ce417c4cc5e6cc84a2c2ee1d5c6481a63326607ebd1678d1b64cb7af2725deacf88e4e62d6a493fb0838055b6126c62ab27d6fc745b837deee5e19fff8448e6e9a040a7711f1bafba0a831cab5f0e79c33686c52d7e3095019f05e9ca112c10f1440e1a2c15b14d8fe551212b739fe53990aa707ab6f45ac8d727300abd98fc74f6d7bb8ab9e2f880621ffccf07676a2fe78451f9bb318695d7b459c15ca49e502dae3d90329069743421970d1644a9cbddaa985ba25b8e6d01571233b7b843d7de50fbc713588f9e6523e5c44f98e0e7d05df791b7822d6a080686a0985762d8255a8cf71c723f86782870385f25dabb0628f29ab1d40c0da5362a02a05584d4f8eadb7606f6458c378457aba7a4af9e29686bb1cdfdf53066d9e89d2b279c1978720bac48acce39944d5c07c6cd03dcbaa35b85f63d0edc6329a06f2a527c61de8814e250a84f64c982fcc54cc504941bd6d4249d08981d7c5aff7842767fe83ebb4b7d1ed09dd2cc43969309b8da1e3dc546ef91fe2b0561cc83f700115819ec71db8282fe4c1a5556e9f4b236f1609260ac2347ec875895e1e0690ff612b2c7cab89036d9e2017089cb18cb7a49b17a4c8c296afd06eea13a6a64fbdaa580ff78a4876f731018d715c809b2054ac91959c006f54bbf2951d82ed2814a600099c178479058a6840f0066d22923e529c4dce9e71d028cee10eb76d10815e0dd16b83ba04a6c16d5dfd6f0877be9050ab2b474204b889ddeb8325479c44588eb876028c4b7d67ef52073d9272b05de0dfd673e16851d56bf68c51b007b4577b1b7e74ad3ad43499e0ea28b2311fe877798daf56521fbc5af3fed8240f6ed7ae3cadbd92fc83c4308f1fc3bd24f5e4bc2ba011091f5f3ce060caacee8b76ae918f04029473e6db7463fd93f1b7fd5cc12c1cbe5b63c01016a5ffe36ae555991ab64b46580633f018e71bf4ed9eb12605c96465f297b3f872925d21faabf96e87e50b02b5758ca6f563dcc6780031e0cee2fbc65e1d35e4094d449073028b0341c93fbda67626cb64a2374c3ea6446e0d24e394c85b4fa1cecf6254720f0ef4660e52647835a71fc62c98ecbc5e250a03387d65d7b04c989263410f4397fb1485ccc7d9139b846d7de6ceb436240ee3d821703f0fcc21085bb816da2e9ad96354f310ee9ee7e90ce2b1a40027ee6e5ad57d23db353ea09fd55c2d13cd6e93c63dd3978547fcad2bd8c890fbcb0a3fc0bcfffa49ac8a806439d53ac886e1b8aa9f25c626c3917ea84cbbe5b9f82e7641c27e8d9e5c5a35e966b84c52aea213a16e2c65f88befb4b7d5fb4ad3a742891c4382440d2f984d624475edebdf81155efbf8f37d27a1c01bc90ed0aaa893d8dc0f50463fa3178aebeca8bd512d75731fe4f6fcc6d25d2651bdc4e4307fe46c231c0b513bb67164bcb5eb42a464a862fe2eeaf2faac3ca2b24325ee3be275b56bd348848c7b8a087b719caaacbb23173dbe9abd4b908bd313b182ad8d5089223609b39299a5c178a0b0d459b9c31a0ab5d0326282f451da3d8828cf356978937e8bbdaea2a71246659ffd164aedd875c48aafc7a1921231adb48e7ba921dbbc09a76916acc88a2232d8fc5d96d81021b7eac68830f3fa1bdf64551c64a97419f5d87f04ebeaa96b591125828d10a5aec8ae381111733affa59a42e1dc4100e882c7c712deb9394e9d018456ac3f4cf63b7a6912319a9435acbe08dd98a416010838d83c4c6d0178a854a6b50b85de8ba870d4fbe9c97b1fafb1d3245e57d5b7f7df32371ff80bca0c1d8ef83b08ae81532f8c169340b27e4ff7b4bd031b39e47c0a3aa2b18e44ac26485a8cb8fd5ec47bbca368922de19bc0a3d8469ee69d3f90ef311f8d8e8e90c7e4d4a4c819067836081fea0ef7fbaf32bfefef653469ac4be939bfd85372228fa4287e033f4d5191906c5e1e4d6dd47bfda70f586b38131713723c63af8e0530b30c8c3ffb5ea70b848a6a07b650ff920c9fb8424d58935c9d27687dfeb9278922427a3a8573b69897d8e66c6d9716e3ffdd88f0e13c3eca703c5ae5a2a77c1bd3b8c38a976a3e6c560ea42193a366dbaabb6c39064402e2ae7c8c23e91c44fb02444e8212f8fa0b502e011d073895668aee405d7e90ae24daf94dd94dd548ed65e6b527de5312f0320a014af2b4b096399634703e7a6e63ff098e1992d5ace4ed2b2c681a23d87f9500ad12dcf8595d378461a3e754b96e915a3a282e5b72ba2c50c17901c295a3ee809765bf69bfab7b5891fc72535b4c8a20b7cf5ee5fdcfc5c5b9fc137c469989fd464c430beb49f6c6f3fa5f213b00ced7f13e04b479840faaa64ed1ec603e735684b427c229d76fa85d2b42cbb71ed3a214559225cd236e05a398a32ea25904df22abf7100e54e7794903a7a704d6da936628dcc6e9fdf449c70a458b1ce963254df2cf8f062a665c29c4d7fed3e6f26045e605716534bca5307ec241b72cde2cab59d29c54caf0f51ca3391d8617e681ba4c93585e6943711fd23d41d66132fa7e17e8f42baf3ea9c3659a1262316fd1398b30de10357b70f30548ca6cfc52766717fcd9c8fd49232689f2c1b5bc0270c3c0d3bf920faaab09d3935b9c8fa059974c0d5a36c2dd1571bc3e2b1f76a2e77041e492f8fba4da2c4a1412a8002e29c65b3adc12f8b6f8d561433dbe39b8cf8587a0b9b5bc11752de3354df792af2cb4504d0606c3bf05a495da564c6f1ccb26f69580810852310be215f0ce8a718c564ba12743a63e382cdf97462b6b39c0a72cb639d713539cd3c9b4ef7870c8fe5fe36ced23b94ccb6efc6c490454934cfbb49c43296b9ce327005c160a404f41f957c3dd40976310730d30b5d1bd1a20b08a943effd518696aa988d4de4be31ae828059c901d2ba75b17c487705f1df606b2bb2f0d6f47624103ebb0fd4de87a1361cfe98f5e4b0efcb503c161ee3bfb04d6c99fd1b919096313c14e0a7c13db1b2a65d806e85c04220ca28402942165a11b62ba1dee25db1f983a00c01f1bf59cc8caf484f46bf6670c6222b4ca275b688f49fde88783d5ba2fe4966b1b6fcbe38113494cffb4501d5853ab30aa1609bd530457616c2086ad3d8eb17b0d252cfb34055be75ed58700d5f169e2342bd85166d6767dc28f9119438ebfc6bb522946b870c6a7125d7fb668ac0743279ae735e07265e8ffb511ef947ccad955aeb1a60ca2ccc5c1a7fd148f5b39a8bcbf2056987857ceede6d070be5308980a5f3b3ccda00cdaf5b04649c524681060724d02b5abc91d2c4d648979165945595726f8cc978965225f5cddf58c2e1ccdebf57822a73cc55e8f765d3ff0865ac9c05b9baced143c340f982851266c7c0f8d584b3d183dfc7c909a044986b0b2404fc51430389f72c82dee599e7e4a4e864cd465a5271ffdaf3869ca91da5fdeb046b419708e44cae90f955a043634c84aa0965da8f9246898211b424a1eb620ab05e7b56fdbf525aa3058317a7673dd771ae68537aede18d07884205a1326e23ad34dd9b801567216d5186ff617f6a892e1b3fc825fbaefc4c1b8dfb9f3dd1c208696fa60796c26a85ec07956c4933f523ad99c38f933c49dcfdfdc02a53045701afba8245548377a873229a88445680de44ffd23ba462d80c7635adc22ddfafb94168bcbacaf5de9e3f01fe58f624c1a8b14afc7c82eeb475d8ad6b9b3a617e58d57813144000da8a34ac2c2abc2f2ab0615b01f4094213c462f7cc32a8b4e9ff6e8326a42f457144f083cadfde072f7971fbf7120bc9d567bf3e97ff604e502fec7d36ceff954bfb7dd6b30e8c3312f41d461dc961f4ddb4c8aff15bcba9a1f577a63ae9bd7dff492b1bac725c20df810ee58b403573531bfed6fd56b35c3949ec2d57184f4e20201861e0eeec31326a3ef486bf7a15496eba2faad02a443864baccf48da8de35cc1cccf304bc9e917199a42a2ed6f3eaa5d3e0a803894f4e8f69f71dafb18a0f12212ad838d0c4c9d43608d4ca9ce165e9b97ca6a0842e70303fc3336ff22f8033ca4c9c548b2e610467f7d36e8a113906077986f83683949e6dfa457f418cd525badee1c88628b786b8b4c60fc240c4194bdd35a5050b063b34c1d9b6bf9a7f89d1feda7884578abae54f954b55f4724ffce23e3f95cb76e821888ce631add664ea6feb8e69a3b49cd606c4f42023f60475b5fc5cf8dc5cd51630f8c38fcf56e2230be7714754ac93af51a87328dc929be813cfa41751d75bcfc05d7226042b828671c6ba5ef9c960d8d3cb29b5931f7d693dacadd15ebd39f43fe1634c3cb9505121f0fd2bb63cce21892c7399b2f20fc00501f30bcac5d5999cc98f79d3c341d6e82975fe1e80a1c18f2738bbba4f33bdcd5d750d989a8556ce11e4483bbb751c7c9206eb7767b7e48040ebc173212bfca81ae91eb473838dfe4ee4931e00d6cc076413a331d0381382f1bc80c60ae640e2db620f87ae7346442d63e8397ebb083ca3fab90629898ad5678f85362791df82f136c264af9edd4bc1bcbc5dd53284204c030dc3fa90bba66bf8f0c6af55724a35015592831bc29bf7738a9a8c7bf6f8ccf450ac81558b4287bc944f48d04807953f8b77dfa8154fbeb3fe8cef709836650296b498862a92014583211d2930327c6a8d4db27d56cc95f93acea3e0f85659fd88345cc8d43bc542b2d09c0ae1184469f9e15bf778782f8bbb1493990dee0c0c9183d70bb90d2dc00f4229f199edabd7e8b92537a4af17eb105c9bcc843270bee59407b880e0fa5af5ffa7183bcda64d5753ab088abc73685bf54c651300bce4f6616204ed6602f35fb9944f8f9bfb75e7a105a85721dce20aa8f3ebf9838b8cfc895bc8ae72f7cc6f5e57f5f2a959edb1c714714aa6ccce56c6c4bbd9c8b6a317b8b8752d58db9a0f55075d307af1637a8e68147128df900e92fdd89f42220e6e2743d23d01e8ae6b5e6cb7d203ba53d911dea9f99edce34d1d40287d9fc5d5d948bcdee26d0307d3a8c01eb5dff4673262269d173a6eccdfea3bb77ce4f3e3443ec10295e0a8ebf4d00a03f55e101fe7cef40b04a793b5085245b99046e49cd7b1001a339be2477e6813ddc6f7890b1cd9e7ac3096efc17406573eedb3950b1de21d2664354e9f555ba5c62ac2ba534ccc11f627b5850e55a8bacd4f874b44326dbbbb2a005b98cae0ba766b2c8efcd62d27b22404ae61cf3f5b6988888facf34b27157ad2f743da5db5b9cab3875dcf36f5b2d20d539d904b22f497535656a59a32651ff333af397727c48ef9eda4980bfe3c353c2395be9d5e28676fecf63ba7b0566f19516df779a8fdad2cdc9ee2a508cd416ab4e3c33389c54af554e0752a93cc74de37bffe1ab7aa011b0a79281305d9ff84d9506e82db1dcdc8590d9db18cec26c028e91f65957b7b26a45d2a8ecfae54efcf275b24406156095e5a4f885329c6ec204f74e6efb0cc3fd8369db0cebdcf816ec12a22f4ea8a2231231baf7badb44f71cc92a01934f3d7a15a7704a22d468ddc7f1dd92e2773be44be8ba7d39a33275d9fbebe227e4a695b584c195a52b06c0c01595be20959f4d2db171412167605fe5505f5006260758709e74c0a84ce5bc41dd1072b53f9bc003ae2377233cd14fd59799f577e54bd6bfeaf576d2c36fa55c3a53a7a7815d54a1eca076103e04e6451acf465475d503e9f9d6152569568ca1071e5c070dc604c5eaaa880165558353d8239ac0c5ef90717d202524c231e57db5ae3b199db68a4f8f704a9f7e9bc2f734dc6a0ddc03defed3f7ab1eb1be4cde1b5183974f0af2b284eccd29f4137cf892d338c1a711f02cbc0aa5222b215ff685cee68b4ca2d3fed7db053db365d3a0ff8f4d574609cfc84947ea5e08335cdcbd22bfb1d82d0b918b3aa668fa1fceb41ec966ae0142f00b6dc60fa0787cd7750b680e9368a1b4df4e70b7001fbba781695b86ae1027b4c60405778673e4ecfa9530062fe6f2e946e213264d6bd5bd0f00fdd0858ba6731929c4ba7c811ad9e0de8e862eda23ee9400362786ec45502e41053c80f17bca8aebc8fc6f5cd6342686435e5b0e8178180f7eec3abb041ecae31c266efe11044c39a10fabc157d214f83bd77dafc97a581eb55af0823df17b0803ea2146aa2e455fd504bf8a0179dec0307a65baf2b1a5b80f820abb302a511e5e60a6cc8bc8275c86c16f1e98fb0f495e270115cd7728b9471db654e3e29530bf990ab46a69d0193663229415d3067a4a4570e6f6ce2dff00957f8ccbd6b7f17dfb1d3d5fa032a7c5f2b3e124b901448a4558bde72c7fcc9b3b3e6b57077d7106f2454c6b7817b78f0869c0619d0dfd622d2a7183bbb6be8a2f1c9950fe8d85ddaf9c3d6feab487c5f959265fabeb55d35b0e4ffb2701591ea78fcb0d9cc5bfb23f9826e0b75a7fc7a9fbbed52fdebf6c4707a73b06efcd5ae7cf7e9ccca908ec4230e048bbaefca625747cbe105d8e2572a3e81257d3dc0042160522b9c8c606ebf638d6422a4889c5fc4bc0ab1cec9ad14d66151ed087a289306daf61ad6485d319670c51ffb6ba72fadd232336d69a28d7d7950c8641f7f0c764cc4ee74d7d2078e91c3e6a647d397556492e17f0d7a06db6da4adf30a897031a4e1e41dd78b6da870ff823ee6c8d7ccb49067bdc9468f5d7e5f8fadbcb80981e9fc7b934f4cb0306ed76617f198c5bd99bbfbc980afd14a7d475190805d1405707d04585a3674d03888454cea10ffba54050feb2472dd3e2dcbd0b11a7a1059e4163b444dbc8c48ffc0b2ba88bab5cc70dd35f89f13db37d3abd6d0ce12f44624541adf9bfe1e99ee83275534676396990bad11205db3a46e6866924f30066d691fe230812268528984df16c4da06bfc7f066d9582e7a6b729781fd2b03a4318d831ef6debafb262b073106ee1331e93e8fc7ba2f4222b040686845aefb1e03c3451f594bd60d54514e8dd4d19d9dba9c9c898ef81b0d8b729a12a46e4867638a5f0b3a0579adb90c031b6fc504487d40793ba58360e50304f1eb5cbdc96266c5d79e09ff4f1e778049a6bb376ea53dd93c07a48c9d80fa6df9fc3d8ef02c881c2df689f76f052fc25f60b158d2c16d23262a1056e6ac8f7ffc761effb3da645e5087edd3ca2e5ec39f81ffdcf63a3a7202045718f8f9abb5b5f8fa2fa7ff3293089f2c5aba4fd6d9930a95840ff36d5840d74ce65b8edd92ce58e7e48c26f568f2abc27325fe73eea9ab6e7f5054c0e5e04431d6882d46df1e693581dd6daa6c358dbaa8720a30558bd91aed7b240f04af731b2779ebbc39b47fc1a01000fb327d933d1d6d3626303a0ef6d5e328d99d84238dc42d03deefc0af3cbe8b7060de105f9fef8d4f7b6d5f650494aa926bdc26a07d0aaa28ed6ced16e72d707d80f580a4e85efad01825642152f9d95e44ccf988059de40f66b36ec7ce11fb4b523d18bac74a61affa35b83e90b4938d3f2ca2419e19202cd8bc92d704694d5c725131265786d0309cd0f38b986e23ab3c0bcdf75704816cdbf50708b39cb784c361c7443bc39c63de321145447b72a7d982ad0db5f8c7d5b163dce7e73396f77054c1a62ebbfcb6905d9c6156903f16dce06114ae92386d603bed4337c7a80ffd94fde7a0a212fa6e21f463bd346f70b076fdf67660207bde55f79b7991b25d9bc9ad7d939650fa95c5302fd700640e9d046f5de9f02d3776a7476986e8bd912c868d470e2ad94b750188d6ce78d81ffe6c6ae50ded278078be26ac3c33677cdfffa310e83a5977f004340c48694a62393aff55d0202ebc0182ff0d2e2bdf7cbc2cc40ed0ec44b4bffe608cbe91637dfcabe82b89fd7948fd08fd13cb2b1356abfccb51d4a31464afae5449bb48a08d8a2cc934213c9aa405cc76a08de4a31a382926ac697b4dde53767289d22dc5b1c18f2e11f4ada7d939ea31e6d32fabddfe616875bdb7dc88256f082f44b2e27edfcda480e733f1cf511b5e4f7fd2dfc74d77a0f7e646fa8cbf6f385b4d65bade55c46d394446058506693c64f3a0925dbedfc207ed15900a0badc99b62a804f01dd914dba61ce84016a75a0f0532931d11c30aa69919e7104b435f3f4a95c5833c604e9686e1286fb67443ec315217b814d88b060997b41e5e7d6e91a9dc525bcec243a5016a2de5ce26c877b8e0a3e98c8d6a0c0b18ee667220ddb197cd655dc642e5eeff922e5df99d5bbb390ce268ac6b3cd3a68aaba1c8af29ca9c6c83fdf4d4a3457f98588ce40cd638c885f18d93f9da30851982e2656a8a8c601c223fa72a9f4a2a34a21ff5784930a114eb622413fb77dd7dcde5c088457e8179c51a574e60c4f9553ff7f2b7726f27a8b5ee654f4ec2ff264e8256670e7bed19e0ae7d400f88ab85193bdcb3c89f1ad0c9c161da8d313e050ef4f112f9b208f5b5370a87d1857ccbdba10e091ec664efa110b1c78ffbab3b7e331ac7e8421e86a7792f320121f6566c99a620fab8d3b02336b4d02155af0ec9077613524c98fcf5575597db389186c1b90d94257bd671442ad9e73d8d8046ce389631049d36a066c3385371e3a19c6598f3e7c196aa38e5a7743fadddf221f200a951ee59810c920a644abf918543d27fea60d2eea1c49c3f9e11ee5d7a3b90ea46411bd5d11c565153b8f5255ec27068e67e046f89ad2d4c1ce64ce9d7e72d6c585cac5a657ef0da57b4f149de4d2cccc9f3cf166ad6eb0eef536569e6d01f7e99561fef500bb43fc5af8d092d820b8b184a5ebb17c3c9abe63fed870fd0e9dcb78a738caf76168686c764f99307adfc6cfce67b480942d30aa2639570204796f424031ec5cca0fc9b281f730a255c49ac89a3942933da1d657624fe795f3cb8d2a62e2467b9f33c98ba1107e2add783622dcee36a99d5057b1ccd7642acca7c2525d9a599f542649cb5266a6388bea623bf4131ae4336c79aab3888dafe72824158db0afc4b224547cec76233318fd73bdd0b6af0b34213138abf0ce050735e79618200218405b77b967710a594a0189653cf9ba962346d6e53ff8333cd3b071716f0812761a957d79b32ded4dce4dd42e663ad38852df2c71543f42f150fa028e6f6e27c78c7e09b19a7d9ea19fc1ee72938a46f947d6a7045a2da92e6cd5bbaca3ff60aafd90cd5b179440932cb73d5ae6d384daaf992f3569772f018aac47b23b84f37be1f09f52d4439c0b7ff29f6e7b848a061084284a7be460d6a00883786a94ecc55142a1967630f17ef9a11399a76c780bd5a31be4a319706377427b476428ef3b7ed0f4ed7a9d35b88874dde02f9218aa5d06bba4b1283b16188b772a79f7777a452fb6b3d61374bf1b131bf07d7e202c00ff6f3c5b6f91f514c86e8461bb1d49c83f28c24466828b14cb72c50f73ea9081b77dae01f00db0a78af8c9eea22dee7e1486cf49ac0e63f4a6caa5d12fdbf02d7d7959030cb2c36f6d5fcd00654d4b27675d67cd6ce679b901e197cb0b5538e1a2153620adbd5091a5e850322b43a237fab88afc41d1da52d5ccddf5bd37b903234eea6b7a8eb08a14903a9b63204e79c06bb7b130a5ecb5118537daf4d97d942deccbeafed69313133db38cfd6de090f1a7b6d71b4ce0941d26d067a10cae892ab4c64eab63d0355cb3b0ea9b65b8be59a5a62763f7f45ef146c8ce6035b8dd722a93cd032abf16d6e6c1943ecbafc50da9098e5d6fe94eae1b097d9b69fce1b19b36d8ffa9ef839d434ca0c0c904025220e018a200b2d4633da6319a20fa1525e045ab05b0841b916c1a4ac5448c10d47cd34d381e69949dbe803817cb28c1f224ee56cf1df3518d53b0c1a2604c515c119952af4e27f5dfd265e66eeca110817d8601cc2306a7b97a9ffb9c89e96979ba8a0de2d7d41361d9697d5ac51e3d619a150ed19402bcbbd84ba9ddf25758ad80357b072cb7234c9808deecdf5209eb0085deb399f220d38e9d7e9f248b952c80d2dc3499ccd7e51be8a0283929d2c409545848671419734b0b9712450744f0230cf2ec7cfb82e95a6592e9ca51bdb2a1316da9b693592712fca5b67df36c06aa5e2c95f6f7f6693cc74e8d7d48697b536394e5d8aa9663f0467e275848a1eb5b735543dac0247f7b3fd1164fadc1b7774c8427baf02977dca5d23d38efb08fb38c93d14edab6219380f878c3833c364c281375daa815fe226a08835638443df714ec02a6f598dde947497e6ee69ad91a035bc4d53982bf9ae96f9c9d7d1eaf0256eed417f2123ac9739539b141adce93ce0fee31ac852c5cd33f57114a9972f7de6fc8da09f0db87480ebd8ae5e9e68abe3e2cbfce81afb53f9499b57989ced74210875a966c80230453f5058967e84af839b092efd48a829ecc8cb787c5a21f9ca7bf39b86d70fbd49524781ea6b626bbeb6462d662590525ceb98f41b3a97c1009129fda96ddaae547d143ddcb5555cb5a186225db4c233e99753e46295ac0ad2fe84012ae3554fb5594b7a7ec5f6f6a9be2bab4ea5e791f73ef94302abc310edb75d219951b2e1dca2673422e9232f9e1a8807647f190a7c2756d5df1bb5014ba28d65192e27bf5823ecc1cb73bcf0d7f38949a423e7fbcdc840fed0a9fc7835f931db6d11328ee662072cf39df2b63406077abd54c00fbe0ad564db18b41405cd95f37cd5081c0ccc6e42b51487679908efaa757a3fc95b63ef35b04c18507a53ac73aaa5dbe3b980a0ff4cca691d2b86eee9ff925a968968d6b5307dda17764d7993a08602de4d8c942af95d8dab07eddb19eb3207b0792152eae63f7eaf3d91aa1d154d474ee614339897097bff809699a2c90b943c6888f0d0d28e80976b443088ebadd324a0305a5daa4f50a130bf5ed2bf226bd069c2de9e43ec4577b0852b7245cac79d1aabc4b1c5e528fc265c0ca312bf7caa2ede76b06831ddb522314d8a5ee4ff49c2faa275708680e6915d2b4b6f13fc54fcee97ecf2a6fd4de658ca6d8e535e9123462e66d1743d08806026cc86f33e6cf1da04359a75d1d5b9f488aa2c35ae2407f448ddcdd400d0880afa83510b81d0a705f10e0541157086ab9249f62d16c96e04d48fad190ce7db39bf19a38bfbe6f228d414365bb2874f5a0b1179c475348e9bf7a6494d6ad6f45e79c4c2450283838c61838fc9f3ecef9a8b01849517ba0cf838bfb4e42318a8e1b62353668ffa2190228e5b18fd1a620517d8f9bc2de00dd0403f3a35fc0fe54c057673a7ddef330dbd5b4fe0ac4bea1d952f411f80ea27f96212331835f065696fd3e7ff88d5208e900e33def795db22e1bccebf1693714e9b396bf8c92c62569db8a96a3b555f199573c4df7e6b9f82dc2f52c4a523138256d893a3d16334408dd5e6f400deff2c7fd5fa7ad6254f9cc4c22c042b1956041b7bfaecf4088cc3ef9c567c48928aa16b6f7797bbd83e58bd8a625e89d6560cadd598c14deac63f729a16bfcdff5dba4159965e26f0aefd71a8736bb184a0ab786d05a6683c78d4ed1623e79b64eef195c71f219573cf1c86c275cae54c1f37d18a0131d279925b7b99fd28ef7ac4a90676a52a6862098e911ab4060484192cb353e2b488cb8fa72972b1fcaa322d08522b8c17a925bc8e286ac034aa51fe2f70a92713927d7b07e3067124cf7351edccc01d896fc3bbcc1ad617b3a8bbeede96885619e521b437b9584d21ca573cec74a35cffbf03fb3f280092d2adcc8e1edde12fc6aeed6f4bbc4099abc53ad8ae77699814cf349a5bd82caec4daf2b30f7228d0424c67da6b8ca11df5f5686444964b992bd0a53df4f9373e8b9c4d0534706987f3514329628a866c6983cffaa85e7a736452d1df315dffe7448a47473ee5928388427ff13f7c1fb862c2e62da5aab7bf22bc725bb5f2f180ecac999cc4caf0e6c0cc7d80e54973ab1f713fc7204545d4864aff572ad8f2913f8d79d0494835eb0ac766af3a1fa770fe49c80c7b0db9a2ef06e444168b636eabd5b12d7650bfcfb21a8275f9f6c91b9c4a8d5d73bb4cfd9162d5c2dc86beb211507a626082eb9169a00b2feb788e63d606705f0d0ba68af3653c1e3b093f672385a6aafb9de6fb805db8e2fc7817797450673e5f0afbe7c9a1483e06257bb0fadf13180a32fef5825c05bf761f756270eb4fe226b877529a5904e48480beff7e39c7211796418ff2bfa776fb9cde91e088c7e84e2dd4717692134364d159b480bdd8f2960e28004fef38110888e336cf0bddb6219a5af48612d726166ffb02f6af35278363ecf3719a65e9bd476c6518aeffac1e440eeac4d30ad734314bb151cb32f48725b95b07781cb142bfb42fedc4e9a57f3c16580446748eae0d6600d053666b00385ef9422c967d6e1b695c56165e60756d25cfac48beb6785506b5fedb61ac785c9f32ec15a960f94606085409fe825ea9e67c3336ecf726e0617a88d39c5a7b9f34e2bbebebdf0e7ac08721f91def334fb16f7890dab3f7f861e473da0626c74f00303d8363e2386366584cf33a34e6455ce9e2fedb245d135df87557376fcfe76d6a7ee6809479a164978ab11f530f06836eb7748ad3b1766b8cd09dd5dae0e4175c01cff4e9c13338af906aa6effc55cd198f3f85ebca9aad49a7a28ec0e30cbc118acf647d4334ab8da8c3bd258e66163087dca13863d4a2d6230c24245007c8b70770983ede3a43ec918e9e4e036514b22f555247584ae669eb2028940d7ac8334ab4de0b1b8a0da5a2dfa5ccf8dba68a5f564cea4e1f690e37b9ee34a286bc41589851d77dc62725e5df7ee414329cd6eabbffa22945b075523120b75a8467180a48f56f268be3629966afcbed13c07453ded91be893646d2ecbde9d37fa3a62667a08af1ec3f116df69c8149ae748d52a5505693b48549b8f7f4e60b33c743e2d48f28f1556542966f05ad38d58be6e6800b60044dfefd16c6699015dd52b2b4192053d173e4db935ffad7d8f5fbc799af9b1fb7c6ea899b75cb0685f2f98a492d0eedee2ecdcdbe4993eebe772077c544845a1c796e7ad0829800873fcd8f17555953a091a5e560e75b2aadcddedbc647d18a5cc648e9ff9ef2308e800aefa715c85893e443839afeae210aa5aa7aeb54ace97d7c72114013023376325a30f1e13f4e46953d41d192539696e5d5c656af769a7522d739e6b17667636953b30372c18a8a5076c8285f6e92666ccb497674cb77730d6fea8f03c44d9371b5a33ac0cc9262096bddb530f961c2ca3a5c990de955dfb7d46ab6c6a2ecaa37a2989b1ee017909c9956c3d67bf8751900799f99abf2302651fc29e17da7da50380d5d0866744ef7ad7bb80f63613cc9dcf2d7e70619101411f9d209c39e6617dcbe625f29a7343cf7b91b3ba506e1d938ad887df03998b1b246871b12e9856c6447396365c0f22420eed4830a09637cec7337e5318baa68caceea7882e73dbc3e2cfac6e8781c002c336bb92a41c142b0701793a319b5053886ed99ea6716674251217bb4185d1b04cfd0ac960944f899624545fc7250d97b92176afb68a34d7de307b56907f5b803486d799ebf9640e4a1a691374f8ddb918fd7e400f8c37694d1737f88dfe3e221546c315cdd94e6b234733d35f3c1310055935ae3dea34dc6aee88407480fecaff14139935dc1f30c5c3f4b9d8118c2f6b28ad39ef32554db5eaf2de46c5bc0483c1a9adf783bfa918c4334933e2463595970c0d7b06421f0cb79e6e60ff44f8bffda008a88e9288c2c5b868fd89dc19e142dc116d3f417f25437427c38417dd3b6e1d2b44fe95fd37938ec6683e8985a1a707fd0748cc410988ec91f02b56db5bf594366b624a91c6ec2c4b0fb6d8bcbab0407ea411d3da5944c251eff59b0adfd56bd8a985725baf4723dc338dab2814a8402f998b232a53d2b74fbebbda21286bf8ea1f30d7d544e0069074b8ace1db3049c2d68837db1fc722c6d726be8eb2d4c1b30a4599535175ebebb6e514af2a4bf69f6bf8c93bf905d437811064ba4479b023db068268432eb6a3a197049e0b37bb6753c55d2a68913a02217c81e6a1bb78562a951e03366ae8794700f5911961bcaa4bd7abaded37e7221aac1a8d0cfc7b11620c86e6ce0e4e4ee6a71e4338eb0a9e5f9d417535d2b4f96101a7fc7cc0daab21b4057f51b02f5226bc9b1b2766344c8f73fa6b28a03e59a6f4caac42953ff700b5a424800021d91d12626ca0c4cb8a8188c457ffc77ea0fa2ce994665744bc6276108694ad586709518e4992fe09ec4d151293139d39716f5d94707a13e11eb8416b94a25d66c5033c9a38dc24ddaeca8e0ecae9ffd34c120bb58357c239122565891bb5f8fb93240adafbe6b2180bd6930f85586994e4da2d80bc9d3a77d12f7e05ea190bd02438eb78176b148033dc2c0d93f5b23360863c8ab1c538255e2874712cc4758ba14a29b2f8eeb52390a887975ea99fe669435bab64ca374668d6e8b2e77faea8361d9dd2e8dbb87d325b16a940375d4fbd50469ad48202235c2543055ed9c25ac6ada2ffdf48a5eb6f826ebf8a56bfb0b331af1575c900015e607b6af0b15b66de6721124da38d01c7447c116a2a021120d7cbe8a831fac84756141ef5e9785242fb23605b9e7e08366106ff462925b69b9ba250a7f023b80b3a40e53a72a74fe569974940df3029aa3b0d8b6b3756b1cf887871ecc2742abf85e79338749a53a8321c840539a69ce37abfa6cf26745ff7ff4bab0f6024484efa0e2d3342e95b0c3a36b696d0d8cbaae7fd2927b292ec3bb657d21130278ec70864dac24b660b6751bbb0dd6efeae8fdbfef3b86e136cfd141e74c38d15aa2abfde9b6ee3e6a9a5a99ba628f5f4f631f6732aed10367208c8adaee6940f2c1ae8de9913727aee29960775fc5a315fa3ee24a15985d7252052721efbcfab7423ad9fbd1ede571aa99d92dc9ed80fefad11eaa844027df38223ff6fd6d14234f8ef347cb2db8ab833f55518f483fb19d830ef996ba7a30ed37ac9fb2f866ee0a3baea6acf573f0d35787d0696f6f18fc8d19978ad14f690901586927a3d73f65e525aa6c4ee5b982fca10466958e0536359b9bd447a01bfa8ea39152ed9e3aad6e6d28f1ad58563817208fc37df2049569d884a7c3d14d112dca9968545c476f12ce43ffe56b75b5a6f54b7fb64940815b9b9bb96963b0f69443acc13466eec8d1fc83609cc39342140581c1624e950c7755c8da9230e130ed3bc4800aaa6cef6ef40a437ee58131ac6429d50e6bc809b4008d6d39e8b11704b3c46c3b546b3ea6b43e067c4218f6c6b8dd64c559b1441916dafbd502750cc2f35ba1b644c62e321ed5f759e0dadb36638b7ac66670f537ee2cd8c4e6afc025885089f589a205827c86b4c87a7a9f31a7b8750488a065aac834725051387741e7a8f94c43b79303cbb575a31c4f6ed9cbd33b4f1d0ce9af102e212dc8837b11732f7ffc6eace917c75713abd36109e6a44be26004685f8729b213a373d8a6492d790236870dd76c487a0a8df7c8a2544262b5014ddd7b607d760172d1343821efe130be8f9848068acdb257a5b8538f077d4abf78c157f7c2a8cb47bd2dd4d3f628c34e9558386abf00959ba838acfb80125eb74cfaa3b6b5db067221f24ec8b9d86b7436caaded283ae4d6e6ece5862f68c1898db925e36684f049f2d5e80b64e6ec7af8f2f28a21d285f7a606d6bdb963a5626f07ff1d23d7edb5c1d0fce231c8cea5947428e0bc7c6228cf3159a345dbb66ba9e995a928431a4c3262e8542f6a817841ad14ee5d8e08515eefa05c5e8e5b60a079036d5e3d2d918c133041895996bfa7b2365cdb5923bc209a0cb8e1967811df45adf51d9d1532f65eea98d1a722a7e04fb34281e95dc0aabdb437c378b2a205d46333717831117d838a10676390a9f21ddb53577e5df144b33423560614329960efb488516dbb5dddb4e93c066d54d5526ac1588d6a585d4519677af87dc50b2e7247abc8bf2e4435563f9a234d2e2be53f1eedeb66adc3cbf8f9e4fc2155f0cbb2be672a548a5cf69bc1422c98075ffac9c855924d589a13bdaf31a337b2f5f0562436eeb985698f68300256930ae2185b578fb13c044e964cc9ce52c0376d2c7fd3c9c836413276d2abddd8928de7aa297b95d6db8f39f869728cca7340c29ad8abadf823c711055fb34928e2b57756cc52fe50d71596bd9e425cbe8ba7e35f5dd86f2c5878f43b817a1bdc89eac691aa89a2aabae4a0c9526afad5c064bfe6886adcdf1941d50dba8aa0ab13f275cfa4b391512425117d659e79b22e1b91a665e3c0363abb651b6dbc1bacbfbeda9c2863205bd50074c0b07d954c299a05b94d770213477e7e259632bd1c6ca2c1522e56053c2fa3eaf1a188c449467bbabb861166ba9f0d29055d8ac8ac0ee76d0dea32d98bbb31718164b7ea17f9d23bfae4fd3d8aa22b0922fa1f9a1b897a0872188bfebee623e260348a67226c6eb57580475c2289a4f1658d8f785a9a55d7630aa4ea20ac0d28fa7fc5c90db8e8e0f673bde40e9465f02b7c23c9f8567abdc7304001c1269deabc5760d6e32b021ec64ea8a694bbd2b96f85537e0c671ea857b5380cf5ff694a7d122df711fc33069cf3dab602d0e7e97f13cd0b486cc67cfba226d54999d61d417470a7c39f2ad691ee623c05fe8a0bf64f48d2066d55c394fb255ab86a9d850b11f933b88aab154be4348eb7b34da782a537711ae5c2d8a01c2d1447b8002c079d45e492b1605bc181d7ee4e705ea548550b568c3effd2522fb34be15515f7720f853c685ba91fdf5049bc60c1fae6d8ad18558e106b9499770ac5a8d43644a6d358dca650bd880bda44f4d15258288b84ef1fc83a993a1d1f987b5d7a700851b4dae096468a2bb86b5d35aed9d04113119cc5f5866bc8589eb8e32ed5b7e8808829b2305cfcae15333d24b6b9c4b41b00f1509aec9e0e0c27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
