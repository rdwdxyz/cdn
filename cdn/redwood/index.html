<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea2b6594c414c4fd865b4cb6e5e7e4e8e1b7896dc50fff2d05e27234bba9fcba784e6b343de4ff2927c608ffd1fb506ff0b0c2bebf5e77fccc3ffc7cacea5a537925f88245dae2425bc33bd94e276148b3309e9f15f952f286359e149deed0cca38be74430de4c102a5a1d6773070e4545bfc63a76983035171f75771816e1190df13be08b176cbb3405fe112768e39ac0e7be81d8b37a6b99c01eab194b18980f2b835db349899fc8372003d6eefd225eea0efeb17bafc28b276b2658b39ca62a6bbcafc84852cd3557eb0225d5ee54f10c6427c4e6ce21bb985ad96f20067f5b69edeeb2f3b760e2a0379cea22c9e83b3215ec4a410fd74662cedeec7c852ebfa3a665bc8a91a6c198f932c6196ff5cd7c56afe54756b8eb94a0a78ce7b9bc29e94d74abb78c501f0cd3dee6f4058c3c914255372a40148e57969b7384cc9043c328863ca8a40c0d747b5a0b1cebf19001ede8dab9034b87f283ccb36542076da2fa7406286dbd265c3f18eeb5e2861253a9140605e1d26757c20b494447714ad7d04ea81636cc606c753094a3eec3a8edde3758ea71827905b44bbc1c25725c287e34c529f96861b54f33e6649981200782512455968f00f54042318284c5f061a315b2d8811bab729e6cf124c02bff0b315514453b08fde7c85bd39c2dedc0d22679422e0d2788d794ccd0f6ccce466f385353c985f2955a5808ea5ad36d8c29c4d923bf8f43c5157fb803163f3a46aab879d5ce5c7491ff3f436d732f10bcb4ea0e3a5e62b2286a050668d4c8de08ec6a1583cbbb0bb48bd08ce16747476b7d99420b2b40cb3e6cbf88657d46d1b55b7aab446e786cbd2ff094fe7f7d6d63b57560ac0b5b0583d5b5032861d78cab93b6d8930519c98fb2ebd47f25e643f3404f789de054ccf92ce031faff41502127399d0d9bc35ce9f78001266549a0f8d3fedc01fcf4265b62b44ce1baa55596cd4f42beb756c49365c38996816091ddcdf3c2cd9c5791bb998abfd8c802496ff1b8dcaf73bb88e9c4b25f32d111d8335c170168f6626bfe6418bcfa9a8812d9b207d41fc774bc7aa60ce03f2e1f296f9825b1d8ba2a7d9fe84f388a1ee61eb2025dfc0b727ed5b2de89187d09ecf5bcc0723c2aa1a4e803b991d1169f59bfb7e3a5621bba8d4e7cd669d836ecb423364a86995d9504cd67e3fd33d2fc5da06aab9899eb86acdcb9e9450551b304055c8a3585bfce483cbabf8ba7b412a545f4f22d753ce29962407e5a3ef074b865263ffb8f365e80053a073c1f1c52964ed23007f7f8768c09f12b68f98b410dc0c4583f6df2a1ccf5d6b297e79338e186f2c3eacb5658c5ece81c78c18c19a0e09d31b06cabc3bb4118e17f9cc919a2aa55866b966667b6a517197f0c5f25195ff65b04373f30f0451ee9d6ecfd00704f9a566ac0178234fd8268d1301331c23dd696c8e7674085130728c17f0f05ba210189ba410791c520dbc5441407fffef007362aaefdef94c179ad6440cb10798baa95ffd65067bbbe50dc52d84c9550efcf458366487c3e0d95905ad0e1e5f85a1e6aeb4d17847e0f31e9f4ca6d3ce9f8dd2a7e2dbc08acd4ec738e645691daafe4cb5a7943073662b9b066ed02a8d38a5491fc31ac56b037fd987d8a2c0368e27b8fc41c513958e2029a0261dd59979067f76bce13bff8f22feb528997f585e43b2b235570ba93229e9a5b1bee791818ba65e94e0ecdd8790b9ada9ae00c8d9d348c8cfcf9ae09663567ffaea63ad30b32ce102ce348487f1732c1fcf26a6057e88a434da7dd7e5f104e24a096463785d7f20fce82a70d717d63dc3fd01ac95678c49f4d0012e5427796d3e2f21cefd467e2fac43a364aab99fe214c8dd312a813b78413af2f701890f2d00b8ddca51c93f78d2b181b701c3565d86a2811a9efe9ec3c42cc6fef931774ae30ee375b98bcb88a71b8b79c8789d05bccc68a9d8cec1fcd65d6a6bcb236c02b723085fca96006e6dfdb03630e87e0980f2578a2a87840696690bda2ab433b934c68383dfb4e41683d9dba4c074d951fd12a12e6ee1206a24d8cd5f66748b087bbc85230704218faf2030405128a9b5a47dd44f6606660f4cb5b5e886053992921455575c261cbcdccbe1dcf609450a46c0e76c7dbc0fd4642d1f721e467accdb286024cdf1a31ee1314b35cd6baf83ef7df7e179d764a385ccd1561ad30569ff671a64758d9515b1df8ed7ae6c9eee0829bd328247ff4caecbc62300ca242f375b2e65a68e039edee389ca2a516e70adf51506078077d7fb6b90cb73c9d301ca3f7648efa480baa409384d826012472a4c4ebe7e5beb743d48d66b0677d567c17f0f79e06ae0fde91280fbc4b12aefd5a6bdd126bf7eb3ee5254ff6835b12eca43314d13e9e683abc75e109d94956eab4512df005bc63e4eaced27f86a72c230ba9039965e50ebfaa65011a54cebd384fafc608b82925ef1c9d8fdb61198570e3e510259c68f0924ba262a603d6fb2ce97549159a01ce596118218a19c77bb7f633e2f946986c03fbfe48e3b40ad30da2aa121e54d1a8514aae4023351cda1efd730820edb03695025f2479ebe5cebd35a3bfbd665b932707fd575f172108e1f81a18da4c01029d8f9d7606a4b500fbfbf3836c5f965375dbb2a785464c3c427f5e0ffaa2ad05fda93bd28e43fbc56beba651a9296030d0af21b51af9d1bee56b94ed22cc8d22d6186175d5c9b72f19e4f739351945ac8ef61b79944904b4dc25a6f0376644a1e705930b52aeb0bc59b03c2034584f141d67019fb0d35b3891bf163beacdfc53f29c7e9405aeb230d46dd4e772e71cbea9599e196184c7802e3741787fde151a6ad829a0e74906733fa821d53080b5a18de6f94ad9aa3ba533eeec356cf722827635b771f11dcd494661d4d6716bf560464eff06fb7f9f93886ae9fb89f826a93b1e9343f8eda9cb1a06b101b5108fc0fc56fd4cbbb55382b12464462eec6d4d9571591b3f301509d2a70b7d8b3eef2852dc15313db2265e3489edc8db22761266450c303a85c3641d7427fd9368e54fbc841cc7333d842fc626c7fa60bbe0b1ec1ccc0dda19469cfe5a0a08cc46697d31d199d929696c421bf00fe68f3e9da9b9fbfa12608cb36cd56dce5b6eb94d94eb672ef6feacb0811e25702d4c80b33fd3d0f2c068d2eae2603c11d1cc64eb8640911c66a3a9d1871e29d546f36a96070f8b87471528cf170ce303126ca1cda938b47b1b0f4dba2eac8d00be08e6381bfdebdbf08c077261d562b1430cf9c831908d5094a570625b3bc2acc2e5449f748861e93cb7f6dee86c19cae73616e3feb2615225d885ffa55768af1b23afd58e4e0b035d52a7a90a9381d6b3ad3791baeda92280abe26bcf15c10997597cbf1cf6c30033c2226714b15ff2f42967730633bf6edff749fe17a0b0cdf27abbe60ed155fba7dc17ca298636e65d8afad9f5f3e90520db0c7f7b4782195d17f2a0bfb0e8cf54a13418f6055b2a335954d932ba8419726d39865e9e1dfc6ac74f74607f618f91e68a51cdb7ce1819b15533a92a54f1392d61d9f940aadc8c8c6d44979fc92bd4e1ffd566bfc5794e83197fdd962dbe30916ccefbfd7dc9abeed7e6da8c2f8c1a8e841b23fa51a43cb582e19a59f569ba2a265caf34b995775807832f2769899cc0185427848b8d8dcde4eb4256694b46db979d230681995aacbcaffc20ea361f3c37634d269171c048b306be9cf10552fb1713a20ef8a51d057f8c3d10a21fba36aa84cfa91f884c9b8db138f364782e26b5d7a591957ca8a18ef21a680ee7ba71ac60ad5177ac3f41228c2782de42c122bd1c2d1eca6d2f73294be673392a313540b280a2873e63a8f7f3c19609a493b9bd37279b2f4562689f78fc00438758fa885606755e9c25d2cc870655695acf277e41ca5b44aa7c116cd56262dfdb382a5701de366ce808ec5be02fc37fd8b5d4fe348ce6b6cd3942c66081988bd0efb6f88d18c9849d4188c436d283f78c959c109a509ab0521a429072e79c364ce45d9e3412a5012a0470e057b8619abce7d7d9d4a8f0fc81e1a80a0e92be0c1aa101c267ef32336da5084013dd63f7d3e346eeddb5d65ae60ee5f0ba5fec60681dea2add34bef19f2725502f7582a9c057c8255438ada6f7b269f08b091569c7ffe595b014ff86b80e16cda1b7b2ce42430e4ac49bf3cbfb65ce9cba00ccde33c26334e2b526a808075741a7fec32fbbddfde6391080ccf24b05241467810f5cd0ffbfa205e457b52f285ac992fec8b20e7ebebe100da0ccd08e2c6b003a4edc69de9a2f0bdaf02a371025ea4dfcb390d30b99ac60cb079ee356e25185feee4d7a083c49fac3c9ab1bfbc7e759c8dc6963e77c916b097ed6cbbeba4ca4f72e743327448d5b6a3eb857ed58eccdabeedc56197d9ece47898e3d2dba17969b043bf3cd9b29f4ac88393e97f26e89c8c7c8cbcfdf4a12c54e8f81abdcc705deedafbd978d81e763b00b5f709f272430745156af1592c17b3cd5a96f30ea3d82527a69aa0e3e90f39c4e2431b613ba4ef0ed93419e3506f0e40d80c0612ee174e1a0fa41d630c8548a83f678dd7639d95abf8f0108d946fc6ce3642836e2febdbbd4e3011cfb005114ddd0f1bc0ea3e2f1b4fdac13e4090d13cb428cacc3ac2c34d92f6421a5aedd77189843883b84849bba6d02d952dad99d96b229a571d698d15eb3784c9d899aa664c321162eadd80a0ce9d3a3885f44b54a45bf20d36690792b8838ce2bd11c3ff840615ceccd17a1bd950099740ee4d1820b2a34012eb9bdd6a85b9acf403d077a507f78c89f1624e7554e4345f1dc97467a979723765e9e1fe7720fd38cb898b50ebfdd187187fcef77a9d6b3bdbf9ced13b89b3baec43a635cebddd19bfaabdc2b66f873354fc87e827bdb0adf7e5a72b6feeea214234bf635dff74038872d5c465714e86184ccab03abfe49650c8d468f07c05056b5b4177947adb6e1adcf6141cea661023a0bc4f89a3aa4a84f07a90b0557ddc6dc37b56bae3db11fb7dbe49ee909c3b1edec35f336d007a703c90513c84612590fc61a6486b995d5c1c8078f3dd63f19cd83e1febfff25df9a7860d91ea4728551322f3efaa6a67e27b33082057696ecc9ce0c61468ffa059b43dde8cc1e1d724998e671e773b8333d53ad52def6a4bb99f16dd38609ce24a19f21593226ea797dd929166795c0d4e74a6f7bdd7f2bc648d8dae9e2a6993dae47c129c6aa76dac45304badad293fd1bc6bf78745f7d2e4792d4d16467f01bc33b72c00d4c0296ff7fe61ececf1c1617cbd3b8e113f04c7bdb2ba2370d180579587b4420643fbe32b6199d5306d33fbb64f23b88fec42bea7774a35bfccb8ab476a7fbddec9ca6cd800ae8d8a7ae31ad1bf67aeb32853f2e2ee84ecbfef033a45d7ce549ee848c375c27f00e865dbc473de3196f54513ce387b93dddc1edfe586c4174fa737941171f689453940627f3f772bd491baed23b539988d0ddcdf034ffc459da6a4a55affe7790f926126f6165e91e7eba24d4e46224ecdaf2f30b44096597ceeac288e65247f0ca25cd179212005491678247af36e69656bad3dbac85dbaaf6c6a01494cf78f8306cd35d20f8ca3d9288de9609bfb9bcab43965f8af417e943793e3e9c4bce6eaafc0942ce11b19fbcd7ed3820d21d7d6aea88aadf6e512bd2c0f50f8600680f10d000e33496b36a25bad2cc6136e24888423e740a12270eda771594aaeeeb4ac2065bef54000eff92836743894903875b7394a8c82b0b788ad6d5c4c890a3c894e2b52cb04c527d65e271cb661460d87f5c877e53053224a290109b91dab4212b0aa5cee506ab48301c165bd2f3bee2d12dbfbca517dc7251a6402aeda72bdaec7919bbac5e88db7ec7ba1eb066512af5f1232483b4b42df0b7642a76f5410a685231c90c714e232c4f628eb50a2cf6cd5c3a0d5355f7ad57451351bd90baeedc9b7b6204de721ed6d920d3adf089647d78254ac508c3e6a70ee6cb4cbedc2c7a72693fdbb801904cb44949fd447860d878a8da9bfd6f69fc4e481bc6f4cdf3659f081188c4ab818d42855c7241019423dd296269870ac990c9545eee3aa05c95f58afc9985629be15dc61e6ca843ed816b660546074e4182c3a6db85a70a3903f8a9217d831edf012975dad3631c2526637c7d9f9beb1816bd942e6e5d08e565bcce83356df01290afd1f15e993487ffd25f26993b72d9e4002d0e6bc8dfd1a0db69e6134c101be5ab690ca4ef84a44f5b6c41978debc38d29bf3dc6e1ca75223456a8a46951c632d8b955b9390e928358666986762b6f35d4154d4aae312d9917e4ef16aa57115ec0cc3b80e8e87886610cb6f0bcdcb0f62014d94e64c89a78435578b3870c235b65258604c3626de90dbbf3414d60d9869b4048583a23e291749475133715e3e07a8d0a2b4d867294a0b13e52db5256feafa0ecba877df12b06ddc2531bdce61728cf27227547dabb8fe4248fc0bcbfb267f634e3a0f6b9e1b9c0bc14aa395503eaba30e7addabf7511caabb572a91e3d4294ac8e72716a2ffde42f3b3141dd558c46be8c892f7bdede1ec8145c89c2020fc7aca7a2f2364c001daa90e4154a71f4f0730048e385adb8f1394e5dd72196529d6fc54ea27f67edf9f16b86aacc2b3c66dee39b2c610dd0433c6c0bd64558f22de9b9cd3bd1c43fd361fbf74efba64f96f4163f5f10537a349a92a707abfa4281b42ee9090b49af4137d304f1a367a49b036fed68600c28790030a4b1fe37abe42037e494f1dcc6568ed4ea656c2fdbb10c8d4469b821ea5dc934bc6af9fcba61d6681b544c7604484b1a7427bb9d49739d517166de2a3402c378d497c309f5647ec5749726e009bc83c0f683fafdc85daed8cd356503bb2f3614be409a70fc769591051cec73ceda203110df3afd5bc992f4c7d18c2ce321bbf3af0cc2eb2b4fed06f3a7a36fe3320b3a806ebe8c86e6d827e7b938d4af768a80a90b1aa38f7c8cb63db9809a204f5d2063e6b000c97e00f6c24c773001cfdc984a2ff5bac0187ab4dba3b1337a8751e8bf51707d4f5319175378cd27e755d6cdd584d9747dd30a4b1a5b470a840cfa2a7e04ac58e1cc3751d91098db0ebe7148a2415437a717b06a40250c52e132c0e470e85b48707afd6bfa032551c90ce53f46babb7d5ca583cecebf0a4d934e62247050fddba31b52cddb1e1b738b19b4b5e3d88cbff0ad0098d1cc6b24cf8539fc439b0abcb932fed7f7c51342faac3cf3875dbc7e76f71e5566bbbd364ad599c27320a44076c59ee648853b4857ce59c2347ad31f664803a3d7755a0920e5547d7c44dd10de416156a7c080a25dd6bd5115a764d0a3dd8649f34ce5862566e05f4eb440c5686fc279bcf0c71b1cef769f50bc0ebf26a8c6084f98932bd78aec8f6488892f61076d77f8aee6c2fba4624d4847abdb1eec0dd866c164917267f5e256fbac3badffd547ce5950953337957254f17ac5e358acb47fc6c105e3a25a48fc366be73d57902126d4d744165023d2cfcc3a7157f42dfe1f6c49e2ea553739b6398e1d0de7a2d6eb098deff47840fe36ff439ddbc07374ddb1dc487db220905fcfbac217a6e1ad6c93bc96a4ab74879e7844519738e3ea42d04f4237cd027c45674faf1c1ee8600ae0641f051e9d375ee7e6215e89fd03356f3c0e14ecb38adea9d1a315bc6cd8e40ad602af02b559b970eb9d2772c831ed8e16110785d54cec0a19f9e9c886d49f3ee4dd164db7ad6c1477b8aeb817a2b70727cd2f1cfc42f52374cc4e25def0e6ab7706971d3ba8ed4d32c20a50032f270578239ba8f1ee5300a2af123ba40f12b86db16b82969fd4bd1dd72384cdeb78a89d35a46e10308afda622c2e835566a46c03054d2cc312512c4e2fd22e1eb9363962f3c42e155178e9214a54dacdaaf0cdc1f479a18c906479b015f0824e244eb9c092bf473389f4a654b6951fc9299f7a6717bc064b6c36d36ded6609c2447054051f77993e121558fffd71537bb7eda7b66b74e25c4ae54f7b4f15f6d03d3d439742329164c674752afb6d477963d1b35b029841f7f64abaea1a054755f433fee8d3aeda85071ce234607163034d259b990b5cf0c8b2ac74430e48a57609612c8eccfd4252bcd6b7878816b82c2876e48bdef74493dbd05802b6abc31afc5224046869cbf55c2f1a03790ad3c8cdbf5e43b1e652f4b32f8ba5acdd32a1d3d969ff4d80cb381943c64347c36b654ecaea0661b87e416a1f9b772b798dd1b73a1ab536ae8223aff9842200d0ac5b8b55ed362af765540677aeea4295c6ef31435808b6595e8ad38545ff1168a4d72874f582c08f0de11090201a8f63c7d65567cf3a96c67d8fe9d176e48ed64e3ffe3dbce66f995de2b3e58e6ad29123beec1b46bd7e45a507950dd7e023913d8005ba6d9d3c2396d11e31d7945380782de019b3866f21b9e3f8a0bf427fc11d73eca09bb338f304a667dc62a7ac79c0a4c04ab5d7677d55682ae7fe7ba860cdf7b2c2e1671ca7c1f99e5ce8cdeedc858b4898c92949d66ff914d9919013bb6f3c9e1ad80af66d76edd56300c143b0ff99f36ec8bf43111a81d0ea90e1a6aaf88a310319cd0878a1bb1a59f0523f7d1733f75a1bdcb04990f11ba5c1da15980fce1be77ab1d6d343bdb1cbf2ff930d83aeb44b42eee71d891abaab06776bd9a70fad5c4c2fdb68c2aa9ba19d27012f9dbb969960c2ef9d15e83a67cc5a0b43cfbbc31263b9c2c9dfc7fa29dd876ffcd56c4a5329d2e2db5c4296c01951462997ab7b6b55681f1bde7e8b35567d76956eaa134f7d48c8e1ce597a68791987401f5aa19f1f4aa1d39af49b44c3e6daea4117f650db1570613e81cb4ee8fa95060e510ed4647dad4fe6d25050a800ba4c36b47976d553ac0a6ba98d4d01b50623e4f947e02cc238e2f03d8bebe98d6458de0d9c7b2efa98cf95b57dad4b60dcb1ef60b4091812f1ea02c6066fcd75428cfd73854bd3474accc6a1800c9fe0ea7a72e1f01606398d96f9839ff14376b9e6c288be3a5c06f3533854de8fa259a5cf77525620e8a8d131113d5f34ad9678c9b9de716acff107927eba0efdc5c9e40558b96f4fe3471c83506ea12fa8e62177a04d623e3f835b340dcf9f5cdbee5e03698d3deeb11b8fad25d6b0fa27d9b10a131d14d9ff170563f837d4c6168fddc85c82de9d62808c48857fc25dd2d1e8d6d2acab0a46a966c21da777db7e8e23f87624af77f4a44322a1d11d7affb610579de20ab52cfdd03317ddbcb705a1db2962f36ce880d19ee711b1ba509b3bb22c5882eef7e6db38c0d40298c4ba705d88f0f1d7b0d120e4ef268a2cc19c4428952e5896112620fb92fb9f49c40251b9e47618de4a8daf60f52e2c48dbca2a2a054c5e0a5bc06864371f7939295e0d6dc037ea0777c26b8c8fd66ea90f038270049fd6219154597b4739e6d5723ae762419b1be1eb0165d024365c6c3c0b14debae12a73920f67b870448e92f9209a11348bff6c474f319ddfe3eae0b0c6ad545e7bfb9e9e97e221dacc14e2e41922088b26249a8db3a42b5b4fcb39a485ad2996b0950342d64627b1e5676b224529985124c5e02a72e593b9e1f9b125ba3f36a6b39dcce7416ab5500bc1760f07e3ea2b969f75df8fd680ca30652960baa71dff61ecc99f79430f38139111a6ce16e52f76da6ca20f39ad11f4f49637f45add8d0808afcbd8a481ad39bd64db71f87afe30ad742aa1bc9ba783b4b920a3e2587596d0e0b957be540b71f488cd59ca86e5408cf7cfc57f4c471f52805f75d371bcfe34f01361b780332eb3cbc2d07593e047abca66ff771934957ab7ad5b7d916b08a873c34a88c3f432eae026e9cb7032bcbbdd03638ca43e1d9587ba6e697029bbddd21134b9e767afc8d7e859536cb21fe92328d949c3da1b362b1e0e678efb55709630394c8739f3c64e5cd537296a36c067e2ed16029e8ebd1a3415f21e3214513602a4afd799bebb7d91509387f6887e1431d76c2f029a6a20538f3de690091873d47b2d1ace427d3d20a0df927a3f3ad96894ee4ade2a07d426a633cb7bd7bbe67af80fa639be1788e70c5c46d34be7aaa55e2a03af3b5576cf9d0104a46879d0a74fa81e66736e8f95f0d12d7904bed0107dbfad27f3ac5b9b0e4fa76ef8acaedf8ec26a6c2bb158440f2e00e28b035d05c2b83bb0d5c1472a708c480b87171aa675870492a47d4fdea70a893ba55ea528dcb7acb98e330d913db0fa6df938328866affaf8db41178bb67fd4bd28691b151caba15e7d4659dfd119f46e165242c7886d243870a6ca7482dd2957848e79809a4eb70f4a56801f74df27eeb9c98f7e74f16d6634dd10193e4b9f353aa799accfce8f5aa215293fd67748dbf9ce3119acbfad98d4e97088fbbd4fb92b8f2f9452ce51bdca3c8a882f2c694c6d199ea0b42dc21e8d389bd8072f48b3a6a71ca79cacae650f04910383d9c35fe70cb552ec9b70a0a30ee48876a1fd4418df259fde72bb59e95d0e63bd7b098a3371b181057a7eafedf571d62b9b066fbeea3d26a3111976858193f178df4c7646e5fc97e764f8796dc7e28ff1d053511b80a14bf66a13aaee2da3fc263422130fdd2ab656cfaa75eb2f681f28b0a2d0c742dc457ad2a99ec701fbcc1a70ac41fc5e1de1ae4b12c070d10d9242026424269f46a9efa333b503dccd8e610ba43ccb9412678200d176869604a78630755bc9cbe4101ede31c4a74a50f911b2e6243e61b2f815c1dcfbfe15ecd980d6c643fd24939a7048149d5b22e218dc67269a7d536baa1b09d6a73cd0a8130404099226444c449271441f2037759bd785e1a0bba6f085c2b51b6b23a94bbd71051ec8b5eac97aea813d8c7088b97a7121cf77894a76ad58ccae6727080bb3cb705bb9cb44fb7f252caa3aad3dfac9f66ee9533f10bc161ee28bab7b1054bcf72e0a2355eb701d5e3f0a7c7e2c375c989e6654e9f80b605a730a896dfce17bcb9e50878a60e6f8424b03094dd925ef24765f6b3b09d082da8e85092f0f30fdd6907db43b0de22da6a96b90ee53415d943e56b9893c55f099c79c2dd392332954753e16c4b071bea2a5ca5dd340ddf2639abaea0a3ffb86a4d8d2b394b48a84ef5e737b979fa9afbac8045256e5dc7de6e6a851733b36990046eccbde8fb2b13da679079e2736dc59a2d4a08527b71052d4a31af46ca38d24e791b05e3d5821fead33be08b2198477e1cd030dc3efd22e591effd63754cdf635215ed7ef405171345a3e5783b9c12c0bdf9cb54982ce66ba941e21e50d448cbc34d7a277cc8488dfd3d24488fc3f8d5994fad2d843de4d0c6a9588471181c8a6d2591fb98e061c9cc3ef3f3187427d8bcf3e29b6e0d2cb7009e4a775e6a01008e34e545073c7e12da132cf1e0ff8a57113105ffe35a76fea0c9862cab7aaa02d0a80d746acf7b899dbc7470579c0b11de7f3756c7962742dd899e94ec9e8dcce1b4aa25dc2645de3a1125fcfa527342d9529414485a658db36901ad4ebe2d745d01f91a7697ebc2799ea72c34b86abf579f68c42937680392a86c6d57d657b4897d3c711f2cce0d8eb38a9b3ebc256fe26deb1ca44ba7111d176321cf281ed6dac28bf3afc183104bb334e7220b0cf39ed0a95eef8b66ff05bc7b706db32d79913f5d4a7c206153c8d845e485309a19e2a1dc2df1c238e154a6aca1da3333e9283e2c67ede1678932dc339557286d6e242b70575d5750141ea2c17b4cad03cad1cc0ff1d86ba604dfbf7063bd611f89073affbddb7063970c1c46d234d9d528c94b82abb7095a025de92185a782a0c1b6d1e4ffb7d37c757d4095742e1cf1f9d0b526bdac309528f12c81c100f27a2096be023bcc92e3313268b02f1cb2afd6287b94e301ab7993dd9062fdd0153e128e4aaa1b144bcc497e51facb088ed63bfa779721399b93316a9dc54d0c139013d324fc9d7be1a44c22f2f55778fa2aff2d556224be7efaed2f7d1d9450faa2ba4cd4aee7d7afbf24d799982d1055016367fedbaa6a6e33dd36af6be2f1925e4bcdd4e52ba78c53501354d4dac83e54c3723ffc691043bd602a42d8d0549e723babaf0f17937c8a4647205da3efcbde5db6a039471b0e21605224e4ce28c6c1be8da63dc997af95e13d94d78ebd77d3cbdeed4610b832ddade208321a0e95de81f49b70f97f0f2008cac4d1a523969c8d245c34439f41bd2fb4b584f38f4dc5b9e221225b8e6a177f41449745665caf196fa9dd1bd48e41670c3e8340ddb611962b030d03533b49ec8c89eecce63cc007bbc36f2cb7eb19396c1a3395f37277c09b7936794c4b8e7ae9da661f58673ca76c8b8c6ce8371f0f702643c85d6bfd11af60a683726806f936daf631d412a07ddb94cbe192982eddd9f7cd5b82619b2e06d94a73108ba8c668befd592e07b2a6d7e9b74cd68d34f9ed9a850db97c5830ad5bc11324bb7c5813cc2220dae79ecf2b59e10efe7d1519c99fc9347f22f559657e7dc9b731d3a520e113c593b1ce7c6edd5ce207afcab62e22259c9dbf1d238881d23049660f5104e885872c38852098407e3541d3d0bdb941a7a9e426590b900b1b873d389d30fa0e0ae55a29a996485fcc21061d159547c56c34266fdd4a90ed490229c3d24515e3ec7cfcf3274f984aea632512d586361480a54ed3ff403fdf8c464f53cecf483a548ac810b861806c2790e9257a2f81780316bcf20923027ba7f294116998011c29cb63e2eacd847f00dc19ca51e89a0f7a3530e3892ee63b2034d07e1388fb5818447495398cbaff76318712a91467311adc0387f6f52b9a9cb1e6ee1a0ac4d83c6f20c0cf33bb1c319332551bca37e5d7f4b6e4e1cd969cefd8b6d9ad61322e651d7e7092159d5e2abdcf9794a087ba91cf3c1eb895978d03e7342df688daccfbae5e94be7e0033a0fcd2b4646a86fc57f2ad30909b47cb13f16be947acbe6f06e5b11add49e2bf7d3e8687cd792278813aed89de8051fc209325e72a75dc04034be38cfd62dee00cdda66bdf217e3e63f3dc1f5040b0c960f873633fadc87ca7466adc47dd17feec858f3895463a52677c06b543d7ad9333cd77c322669033b1f1123f00a2b6f0d73102b83e6894d0828240ea4dc1353e987e016a01ae839b74ff5758cec5bbc6fd8493261acb1d129c6f0075f2dc377496e2c9ca8c2c1c552873ab565e8feade98d60a43f8a063a1754536dfae32613ae4339d56abdeb2552060a9c1a67d51936b98644f0c494a14084037ccbed0b37530a9e904468cd50ff25cc6e60d03a2225bdaeb428994003a94c39301457212f4cd33d7cc677655e5bdf50967a7dd13325df01ce03d3552bbdd3243f39c9ef0e3f12263ed6af7d2e97a2c64152d3a2d945616126167f29363cc33352bacebd2a218032588f7d6b62274063eb838b6cf23e18281b07ea849240ecc7c602bf9e0ce7859a0ce86b2931a18137be82921c9cf88c8655042966256e08d1d5656045611e9ae6bb8c736a814b8264b6e2fb3173bdd621d999d49f670297a427afb2296bd55a17713de20887d43f9a9f24469c15c3d4241a28ca8044f41bd6318c0c0beaeb63e1b3cdb3d0b51619abe4658ee5c4ab897349b383317fd69291fa41411a81dcee1532507b3e8716e850b2efc5a7b8e18f3f9c824575b192843ba2bcd7b751f68844ed2b191d0485ae85a6d523adf1c9ff658fc8bc58f9a4a684e6b35986b89990119f45758146ba683e2faf4047aad9da7c5b0cc47146029e81d7bc9ae737b68d32157487413e6a3ccbb2fd41f4c36b6c25bb1385f13c7b6f60668ece070caa5c0818fe0852575c414906418ad3c22f00a38c7ce930a87bbdeba80d6794c2c63ca884dad6d6b0265c87ea7349a9c8322f1dc3def01b4f5f0af0b35757ed461a6156ff1da9b5500ad2eca066dd8031f29c5b715921b64e0c5939b988a64abcc779669c8342bb45b4fc3c82d5d8748fa31936cdbe40ec20aed82aec9cf3ae27b0b2b6f29eaf2014d68297b5879d379e894d0baf94fab0dd83d0b7f74c7e2b200cc5a80baa78d1df11298d0e2a1e094e5b0ff16a01611a16de378b5d2867105afef9a80944a74339d7e40643cddad684643cd0bfe9246dbd53acc87e71fceea18cb7001a136315ab2ee82833805159ca54f37afbab59e52f2be842a6b8ea55cc7e84bd3be89c355fbed4951de56ba7e01ce0955601d043c4ad0c79e041c9378fb2853adebaca2c330c8f0b1930d8bfa5c55359876ea3535d46924949cf4aee41f1c5c0fe8f3ce149b1f64534616deec949778288aee10228f2c34ef15a2d592e66ebacce88301067ed47e53c0ed8aae262a827c0d7e0e701002ffd3ed8150e17bb83256611b5c5aa61b89a20964892a3e31e36ad70c784671204be55f05a01a576d4655355280bc07321439acee57717f9c7ecb4b4a548615b73ec476ef7efb5aa33a49f7fb0bf22e54d9644a1b4d947aff298fcf038845e43b9dcafcc2c2e46f54027133d7dd240a8db3482de7e94490469fd5a1f3fc28062508e2123e225720b5972006d84a386254c548e84523b1948cbe29ae70d54f16d28cd2a321c329b2c6b83713206f04bb9fee164211d887d45f3269cf21f2afba089d42344bae9a310941bb7756f3fe883f5cd5419c6a98d1c9ba650d3845f2099a49bf1089d1d0b6c04e1cbae88fc9ab46e455acca321cd05277ce1200d996a08286ff138931fa2197ffb03594e8ef5f839cb38939f34b5424fbeb252144bd4f9de70d9dfa9eecf3c971398c9392b427cd091fa382ef1673e16ac3271f18376cdc87eb042ebacd192198480ee3ac12028033b910304fb39ecc20e53d272c94d621ea2be4d07e07366a931412fe58c625bb6d3f7ee840c26ac5ece5720e1cf2d2fa12a02a0ba775fa0ec02ed2d97e26b952821dd31ad21df8ec9928f32a38fb1df6dcba14272a8c7d84aac9bef05f3b6fba5beadc3c693f054d30f7d7bc4907d6dc774389fbbc6697201274920fcc95d2c8efcfc165d81e7abbf13d0eb4f05079631a137739c76caad7c5f2c9415f24833f67e122fd9fd3e503f95944417d60ab522eb100fc54f5dae9fc7f548dbb24870d8beac326d4da8ad00ac5d5eb8226072e5a4632d7b1858bac763343eec2edab2c4228776975569fc1843211e6ec8bd3e8ac7d8176b2c1517e0cb86470acff472a13c3d6a885be0c825aed8e9db35f21f73d7ef46b2228d443a697c2bfed2b351025e3312e132745ade319c491c1cddee58bc2d4e852425c3b74dc2aed072b2291950fb56bb5cc05d896e4d0ba8f3254782854f36a0b6b807997539071e2e08e204757c39d0e96f61e8b5b2d4a93be1db1dccb1be0a9dfc7e8413bdddec14c178e7c9b37e12fcc461e1e0c7fb0fd9e33cc1e7cb6fda496f31d6f7e8ab08c461fc6e06b79a21f42663bfd8d4aa3bb789b86d69e0b9949bce903b37534f1be247a1461ad45044cbe89ccaffa5febdda725d2548847a66781b5afab5f8afb8856e1fa3124a9c5cb1d44ec0d320e3d90bb006b1ba4d124a6e46e38948b308d0f1d9af1225d45d8df197e336d9cd3663e2c509dac9604bc63465a85864ed8515ae2a089e93305377801dba1c925284fd1a858deef29464ff094c092106bd9e697ddd5e889e779f2a7fbb3a88d1cefb3db354bc551fcec77ccd9199590973e9d90f281cbd9642d2b820196a0a99bbc0393953693549525535d4f26b3b4a7f665b9a3c36ed12cb016ed8674beb4a732ee71d2263f47fed46a4b2edb9e8c1c824e63f1e3389f9f6d34d96430333461b4e3c57cc422015964185be80eec41f3dcf485178926f81508bac74b4dd0b08986af44bf4bfa44356bb9d2f85ded01da6b899eb1c5d74b1771414ffad224c5733b812750bfd34393482c1a10a8b3a945eb9280804a97b44b644849d4a895e6c8461ec250c0f8762539d6132ff0f2b1268a23b414aa717d5ac8b5a3ff3900aa371d4ff4ca0a45d75ab491c1cf316be580219a2c634741607bbe35519604ce857befee5e342f1565947f479506851e9a4ab1a505feaadb6f668eb3c8dfe90aad0a102b3d7d0b9afe5445864e19cf8560dea109561995009f9609e16056e9c13a55e6334bf32e4ad0556ca3b61fb2c5bfc89730f69ea9f5092131bb43ce62340dd51e0453f016d7c714d456183d0122295b24b8546d71c4ea6be19edaeb19b24f785c56a7e0a71903609ed65e2d60bdb689dddbb56a2f8ba3dd12699d6e19fec14bde01af5b8b0c4989b07a8693866921f4f19d2945ab13796d3452095637bb1f0ec418cf1948d931934a0f8497abc6d0d6668fd60e51f302da238dc401f4c022529ba82e30c3aadca22bab0f3faa34f29755afaa5c122db09420b1f3df7828471f49cd92d578d1e7e2f3869dd34d47c701e8394657c45a34752a5b52b9c94d8f0cbcffb4fa6b7cc1e7df327e537659e3355738d0701f80ee1afabe789063dea9872a678000b272ae5d4025a1390acd63abc32b07a48e1f0d039d6c50829981251cd43ac636ffe600ec196269bffb7a6fff518fdf85445235da07d3f5d2176a3815637869062243a4ca6887f442cac5d1f2f679c0199a0f988bc7ee723a7161b032a11ab928b2447598ebc17503f9f5f116d6f5229eb4ff364605ce7e158b2955e378384c6e09c3ca825a7f666bd04321546d8a29ac97173be7ef2cbe5e4eab954cb6f505e1e08c6aeb38d63dc920509137312ccf812b97e9dab01774315419e27079ed15f8709bf7c5a0633376312d0151d9953c76dcdb7b683e2f38efaa67f23c8f8060bd7206b735bd7f1d4649bdf0b7b037c9940939d6b4102535fa36572720264003350db1f0064fbb84db18b75c44489f4b524a64c80c5f6d9588b30c941a34b979cef131c0fce443263a8fc6d2857b61117d4d3bb97a7c1edc3621e8317ed468816449f6e8c9ffcbf54b2d8cd5427786490942ba72271472dbb65dfd3e23a5b042190c75d4bfd58e2d74f64fbebed9491c6c468abbe449128c716e828e4aea3a298dba50266f09aee4a1b86c1dfc1e41239c5e161856f33c042000462debbbadbfe4470fc18fbafd3c0d2d4ee6fed8a41a2ef2d41263ab7c0e60e91f69ca92392a42a29c6b0b61c826ff1aabb499da197a5161e194a607b8c4e4b8402c476d8a88c13669a8b8dc02b56d2d4fd0ee63c1a916ca44c5133a78627d1fd7d37b0d0dd0c1fe75b6991928a5f87804770a6ac4af201402cb0d3c6ab60d4e58f1f1eccac8014674bd52f7e73b45fe9bc708f16a1ede58501cdc38735130604b5d7e4017b467007be7c399c87fd208835a7ed041961fbe255eaf6eb005fc268dadd4a84c7bc45cc755b3315761be2fe5227a0f809966b6e668637d7198abf61307e617465d0d0c82c988e6cfe99ad95e98ab6a7cb683c17f5dccf157aeb4f4ad1968bd4b3937579982f2f8845ca43484d3cbbf4d66e4413e010039b4cbaa3cbac5b123fb218a4478bf69fcb16876a962b82b0931dc7f0077eb482875de938f855566369509d64dd4256d710b25ce3230ee6527ee70f7ed8b2605baec65a67baa266f8de7bef7f32e4698c1666cc3f44ca24972866d984a5d4c735480ac483f4fb1fad259329e047ccff0ab5539b8c4e40b8329e8d6a7c6d8a3ed3bd3d09130b78957f476fb24af32e1c33c7e7537faac4da3d06cdae58ec940be2b3288c44784fd391acb6ed96f6068b45db5dd88be4ceddb71786c9e132043c34f1dd1665cbd5c279d9985441f4065f57d13dc9c3389f29d95d6eb59e8f495ded093c36dbd35f890497f80e72d970ab7d96c599182add925a02fa4d9d412f57bead9b3d81e30bcd7c7da234816d985b2f190898ee492b0ddb8a95e248027f30a485bc781fd397790077f6a500eab47d52930d75a4f4f688dd38d407cbec59802160425ee44016e2e0e4bd90ba018ea3eaec0b57c68bf9a16e2ca508eba3a6bcecaf0585d17ebec1a454b18417423680e45c26f11a4260e6650c1870e24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
