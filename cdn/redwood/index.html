<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5811cbc2d5f4f318bab1ebef325937bf65f0b042d65300e669d0bb1affa97161d95e0c61506b6731053a8eb7dbe5ac64d8a23c34fcc58d18a382267f0eba0935936342cd26edfa6bca5e93d5eb44ee5565072a39fa74eb5043805eb5ac84be149e4a1435dfe9896353ccda27e3a3531b10e9d52a3c3a7de6405fd6fcc2be8a61a34cb92c7e0694dc457b320e27fd156ba69cc34d4ef5c33888740e129d96b173f0ada7bfdd170090d1b45904e29b1de1787f4e9f4f2618ff77bf5ff8ee714645bb50c96f796316cdbe6fee72dbdc31b8ff1a21455e90e0d72ac7dd0dd9f656c5b30cbc24ff3de9f53e179e2c8e38404a8349a3f829842b2dca9e1fdecbc71194152d0fe852245743b2c66406716d9912296a5a88777f77888ea50fbf5292f5e2a8ade96186dcfbb5529992fa07c1cee6e08bb2374620f201a7b4c90cc68aeccde1bd4484a08938bc9a71727bec07f90bac4a29bed5e0ca74b8d78268c86e99e1d03cac3ab5d2faab698083fa393253c6c125899acb55a1baa0ec2c1bdb67fb85fac8094b1bcf9d7a4f7fe4355687594847a338c2b2fb0c0262e7ca2f3b6d4e2e6b6c34144b8696650b77f93f82749770863b6562e8534387a2fcb484a1b70de8a2ea355f06a72f2af56cd7407734b932e95e00638a694b6d5be8088da54c62867f2df9e2e6b1468a9c8c9ba4c960045896cc64a0ddb0088aa1bb1894dd307e4d2de0b0491a2a6e33a44bc08872fb9fa6d21684cb4038c77e73d90234cbc3f8be1f997b9ac7a96bec1ee3866f89c6f898e44d40efe98b75e7610c6f818398bb68448967c647ef6ee99d43bd1642e2a7a4a49ae3ae29e8043a088a5b013623b39f2b729765946f51ff3013261fdf2c7a5b1d903cde6f377331e8efb853b89146b34a79d3f09871603feb246300680b723b7192101463fa217dd2f96b60e8e2c27fe9544d8524b9e4507c636d49e5172d981ccff6d851ec3890362ec114db0de94a30f644baa2b0a430e3ad73e68253bb5ea8870f3927ade25161d0cb09e68e366c2ed64ee3f8fe4fa26e8761ac56487118d1011fcbb0be152b05d77144dd1761cc0fd71d4f3a8b59dff03e2ade9643420fedb618b4bbae6c903516c9b6af57a92ea13e614fa43230c34e903ff6d2330360c31ba763e228cf55ea6b15b3e09017adf7a5d2c9f35e129e8ab3be86c7e5e1aee7092df044cf9ca502a7ab0da428852b5f7ca759a63fc5afb10697c4f91f26c9aba39cdd2d59c6e9af0fe5a5889492f72b1ebc966c24f51ad219bde03ef23a52df8b1d265306fa0acd2743682c9198580f91c23bc492d46a99762ffb13fa18106e817f9d0a45b32f46ab5c5e04fd1fd6cf44ab8853922684fe51594c5e31f77d717293f91682c774c52157a4b61d029b54fbfc190f572f2cd74498d3a005cff26ca580849dd955955b94daad5b1252be1c68964a413916daa3c412dd4e4cff0b6ba28458849d2941a60e1465fb33d376697c8940060d3045145d9ad1437afc66db63c534ff6538de6d54233658ad46a4570487f1d4a06658bb5660f796e4ce6df561f37d87168eed34cb4f2d8b37a7f9acd606ede54cc89dd7850db664ce1148b8baf8e15191da0e26c2b30cb7499ea5f6c92983477e31a9bdb822b3c78ba91688618bb763e8bc9db68d7aedb1a0788bd251f47b79b8901e8d9b98d5f56b8246e9b76bff00ffb8034c93fb17e2a271166f164b780ed49f324c77528252ad455f3169c2e84042e496232c3bd075c4ffb57a1736dbf505838de7dc1f3f50e6c7113a82c1c013dd0251299245af09a0d8d60a75e26490bbfdebf2524c97e835e24422270a417cdd35c5a97560430f2cfb9a11f7265e0900ca2e25916e89010f0fe5b01ad48d356761d5a2d7342fe5384a1506467ab527b980f4fdb115c2bae89fa5060f13a05936a19a63c401972523658f50b19bb81d8c33fbc74981f62f553e7bde1ec22dcb679854e015c747f53f9842efbbcc228694f13adb5ebade7ffbad1de79efc351d6d2d37e11f48f2771e1d4ab7a81736eedc4c3cfb191c5054223d2df9119bbc31c71b37123e81fadd3b306e96944fb387e6573bb59cedeebb483ca907aa8657b09d026d0758201bd13f009bc632519544c258e4868eff28c2fea52eb99abcabf8f7644210cab5f5366345fdc03cace0605881cbce837dae2ef3057804d43950ef551f914bf568f6048e314148b512d7c29ee8fcd9a2b2eccee6c8c21a094399e64ba689ba9102446ec951ebfebbf24bfb6a9290b9420ccf5627e047412636f74c39951bfa31e18428c2cb304c1903b8a5ddc7486daa1dff010b694a2099564a1172f303af69edeeb3e90e662c7b162d8e14d9e14df4a3676910e11b778ce07f2fc32e7019a2583c3bdcc58229884e4d1a8c52eb869ece2bcc62b868f6467242f995b5dc84e2321c294fbdb3bedc2051c857ff10090d74cf4097ce38d91b2ee433e988d0d74c70e02775a6997ebd953818ff4829e735c3bac854b2c6447ffc0a5d4da028312a0ca3d506a9b0f48cd4aeb5fdcc65a02aa2e82488746034fabd2dad4e320da0f72477a3e403ed1e50729fa80c6ca010358f5a267f2d7d3c43a5246c782f31abdf8fb2f735e60436680414034feffb8aefbdbd7a055e11ecadbdddd390ba09e3b2d29103c7798805133429328c6f576750296a4973cb938876b0cbbcb8fd701f855ae559ceeea05960b4fb2c9bcf92822d3e55de36a55db9bf063c8492d6edf89777ef14ad474db30a79d77caf6f2c59f6beb3494ad726c55e43f9ced004cfd1e281ab03efc23732e153d95e0c8eb480dcdc02cea3bb2db6e94009def6810bce077907ec6be73261119f618bc492a54b060c6cd51774c8b6afadea9afc355124b9c0d707628536cc1a84a97788077d13efdc355f256a48dfab934dc6e1a0030d7a038be81ec265e63b744cca1694c7c4413d95ef18c54cff473077274517431e4d6028d433bb8dc870b4f7e55044edb8789f31301ed189212794bc8181aa7cabe1ae24112ee5ca50786acf77094f09a7267db4bf260833c201ec0d9ba9dacee08b7cfde7a4ce7bd8325d127b5d234d0e60e13535fb6906b32ace4001eb16b1d0b375f0860b307541127e2328f1d42253fe5606a9e94842990c84fbc8f4281566017376e700d511ba33d8279f8d04a849bfe108eab9a6686879a67318aff705e48afb725b5ff5317bba4a2a580e10e93ca3326d4983bb079984abec81e4ff398efd9b51ca637a66146481dec59ad9a9b49770435ecfb17a7e5ff6278f5e0c02c660a48f879360d40e6715b019992b9dd8906efe14acf786b5ac5d99fdebe7b04c6dde9458923f62837b7231bac8485ce850b718e2ba5027e0fee2220e9a352fbfc11fb0c5ff3f10615904dd0920f017a8aaee3d6f820caf42fdd7cbaa0011ddadd479196d5e2963ba7cf942cd118e2ae350baedc94a24df866d4d0a9dcdbdee3c4ae922b07a09a53c67310dcb307da5262b869fb9ba6bb6188d45d41fd43fa7a806a2c2de1c35d2205d9164f6658b75853a6d208d5c91557e53ff5b4739e583936ee2c893dd159c5fd36ece513c6767db5254bdc696deb5a4b3e9d051c0c03f8ffe024aeabceab6f1baca4ef3581c7ff95ceeafd5b536699caf6e850ddbe4d7e16dca956402c0eb5425806b4a11bd2d6d712508a5cb8bef19a56b8740647b1736c8e47cc3038930b7d82511b8ebbb9c7fef625765b46378be40af755c9833177728eeaf3383fb609990ebe1b0205fe3e9ac91a8c6c7f1cb45187cae0424200372955aa167ddc09c8e6a9b323c903c04d50905132ca67989a8e0927950c7513eeff7646d1d48c00528c21480827f8680f9d24ca8298f03aaaa6830f207d0739178a54ce29ce305406492a76c040ab3cd407568dd3c8af22fecd056902b075db8d228bebe3259596c481793077fbda80422ff9d793d12ac0d528dd3c59044d4abac50eb18ec8624415b3adcaff99f8914a0e29bc711285d852595008141e86f73a158bcc5fe790c3c18a77a957624999e1d8ce59fb0a5e4be249050f1cfd1e407d4db762ea45aecf28f3a897117af928fed3f395d834585ba090880f46b2299af2c1ffa3e4523a7afee38ec16eb9fed036560b906f801355b8b141dfaef09dd3208b4aedfc8858dc088303438cff5b780e0fbb396b417311db45a342dcaa7ab5da03676c5edf0b4c93adb111504b0aeef64444081dec7a9d47c0eba57c9653d175f5e6742eddb6daa4bd7511d5822535bf1c6a967ac95e54ec74307ede14243437c033c9386685d7585a47b271e428902307fca82c49016d0ff2d06c894148d53d44b673b2c370fe1560f91344961f4f1a42b66d64f70593edefb928b27d503305a4ef19edea1a58209527e36bb12d8a25c4d935a713dd073ab5c021673e3f0b0ddf230bb0fe6993e532c094ed62bf4e7cd5982474a08321df5bcb4cf11d975daf791e325880ed62040161c271e54dc25da2239222fccba42d44e247819c3487207f427da900abfa8f4f9aacdd922d882945cfacc592b54ff709afaf0075f4f8f705f248b34672a880d66ec9d8f793fcfb33049030ecf8806a0f77923160d3359d97fba34489a1094fcee0ac9ba1dd2992ffc5a3fa0990e68035f5ddc714c8a439d95434053fb5354a623e922c9dda2a2fe8a137450b365b16da11b2058c926125b72af2e7196225833c16a14b2990ee6c144af9eba9a8631a03377b27a295f65215eaa1cc1a76e1b5e96ec2e855eb21d7dd905f1b8bb5b37c0916a758125a59a6d8ef2143af13aedae59e3b2fb5d96a04a27dc09fd0d1cdbbbdc32cc1c8bc2fbaf07d1e927504feddbf6649396a76c3768a1104a74d6693856f15bab088957562bc6cfe873b5dd18cb20d115000fd3ab6d5cc49f8a146d04165f22fe1483d917e536469cc4ff14a80bd36336da4de6880668489354db7fd782f3698ed3c8fef0deedf78937baa83e4be51510f3f732d20cb44b294d8fd1d0c75b9473efe8bccb3c5b6d1de4571086998c9c68a05a1d016320b51beb0bec0df9321aee564344b7a1cf34588ac09a5247aaf55ff47cf5f5f2368701035761744eeb7a1900e37ee66bcefdca0a965a52f264f79c86db83d4401143659fd62c297c14867232e84a9aef2ff238fafc5d812ff1f3972e046e6f7c6bb06726639a543716c14f93100368e04124e5ff7d852b0ea3b1198a215fe84aab399bfdd489a377edfb547bfb048f27c633602086009971f13a44e8c90006c92c4cfd2f37805bdb5a56e03703a755ddd712a2592cf9a2d8025a72ba64087d796c1a8d481c567b3a77d73d4a59ec21ebf262bb0803c48da8a8be5d649d8f21713aede27bc955923d99963b156f2a1e5fed03beda4da0f413d1f4af3ff7821fca7f99c3c8eeb8e94a16d9ecda94ac33f2f800dbee753e7b2e7c252cfc12a8d6a52e520dab3cbc1d91225cd987ca762e3bdcf43207013dc6bafd3b3a42b87c80694abd9db183d9396fd724b0e5a9f32618551bac3d3354eaa61d4060b203ec64b944c7bc73bb7103d4524456a82ef89a8086ac1d8aaf2a879e65f28246078cfc58dd2bd406c785a082ca48fbc95a871e7b0c780dd918396afe31def92f5314376fe19545034da21ebb093bc9e256384eaf87bb4842093680894869badb4b56a59f571caf188c58ced716fee2d50ba54b4b228b162d68b241be73b7965000b1555190e5c1a7022949a8f7b8c1ec35500da52ee3773f4c90b1119b0829588a64284c48983d4efbbad76ddda076ae56a0ec65556ccaeeb08252bbb4c8222b5c885af39838d79b79e9df95b781fa595bd8ea942ce5d4e952402340a1ccb93cf5c491b3139c9964edeeba75e061a950a1eddbaac8e5f2f0c37967824d90b4492b1163c72ba14089081810009698d682ad092d61a33a4ace209a32c0bdc55fddc7434bcfe8c72ee7ee9be83469dcc3651cc19fa7a482f3a24e6f88b62c3f094cf0343a42b78b712c811ed8f9a12430a5cb2913f41e934fdc8f2a9f90f1afcff72dcb418fb6bd200bd170be133cd329c49f646b5c21c9b7aaf912e6a75554c26f7495462822ba6ed0ed7705302e2756fbe4513066b60f55396c3556c69697a9c36050e72676c9ffc7f802d85d8f92003e8b8f1219f9821ddf82904f5392c12a34e54ae091ed818b1f8c2b684f67e04f42062a8efc63a5e9d91a23cd06bc0474344e0b8ecdefd2532d6ebf759c6c6631640796be60a8128ac3bbfdc34821cb5c2b96a0f650c22aa32ce469ffcba09afd1d5a395c1e365ac501ce960d3512fe83382ac00c05b56fed95fc3bb8fcc738efd8e57a53f92cffbb666bdedbf78b9ce9a3420ae3c5d09aaacc1d57970e4f3d4133c5909ddabb13e8f716c602262118add06550fe1e91e9bea25924ea6e0ee7279dda75c7d545cc6a394c9cc1f621d069bc5450bdd7f0793db4c8ddbcac800fa5b73b8cc268d5f6cc01be97095c03b3c8a65339bc4cfe2ad5c226e03e2ae11fd706d318672cd9ea1425e7cd833a78c710e675271b3f7733cdf5ac390fc89374299ae9ecb53493f22975993207a63089e18a08698df091458e1fbfc1cedf219279177cd95f54579d2c81289556984e034b8a9c3e80f6215f853e896e039024eccae342b865fe246a1f285a353401081e26303f3dca4c735c807ad7aa712b8d35f8c5e7283a3c5ad2d66bf2c18866ce0b15787bb533296a553e7210c361e50d38624f26508e06555760fdde3b6d41ab3ba69f0b94e99909db5423ff79b4e144b57905f26f1f14ccadff94a03cdac6c8cbc6ab3b09184cd6379a6467cb56cb4a922b5c5bd3a92544bbf2e2556b0d61cdc530026fac6ebaa57d236d243d6da199c7244f0944e1cd7dce8d6065518eaf91d56d2e1723dcf6aaf6ebeba58e078d15df14c5be1e50179c4b993d3e89cefb9677d02406bea5ce34d4aa77b2cce18ccacbc090b03d2ba3fc7944c9ac80eb32fa2750501d7b6413fcfcf59b5ec2c5c5703923682b3a003ebc6048b76a76e008cd9b98434bf8d6640a992bc656a888a9ba80960ca772531f72dbe4509de30e393e821f7907d5132a6416b64fc3b64b54a124ad01f1cbc21f7f995d8958c27df08ecfa4f0a044e5d82bfa3cb428d54bc56567c2aa4bbb1e125edebc7caba24237b2851b9d17319b0dbc16e66506ecf6c9f822fbe28b3521e1b8f3e166eaa2990e34cf1d3df21d822b12c788bd09eec0e94ec1dd4df4feb8d44df9a02aa53b98858d2b70726b27f9344527de70f54f57831df21da18865bbdbe7e52360b0de0c0b5a2f51cb9b16f825e3d97f38da27a239462771f084db8b0e99c5ce32633becd6396291d6207bab78dc1f7ec8ba074da5e152c95e5ca12840bb473a4afcca0203a5fa15f8893ab02072e8ea1418bb26b71da5bf66a7b8ee5bbadfa9ac2244edb434b894294e3bf4b1e64a19d0b142a63bd925fa1eba32a4f3df1515636196159e8a9de75370174b34b05c38682fc800b1073031cdc439b29ee2210f099f12d730373443a3c073ca9680180758bed672facc94cca41b67860021f8cef24e228b158bfc9f7c7b78586d78080c7f42f4c6b5d9b9631834a43204ea9edacdad804ccaaa87c433113567049a8c115274b9fdb673b8d6a25dcd3388cc805b4e27cdd9e24c6f26a2df4ec911cea05db62b3dbbadf10416ace846cadd970912fe23ca79ef7227a9d75ab092c8b584726609e90e4f843fd44204aa6c23ca25308a0c99410d69cacefe7bcecea664588158e39aa00905de92bedbdf77be9a16b5a5726275c74876e6e3ddc28596694cce7cb3601f7d16cf7ca98799d92a9df826beeb4ef65ade3c4405a0ed4ea80b9ff15a2ce60b5e49f74dd44d3627c230672d1007499dc8772dbc800b226d6338e049c429e545b36fd8a12cdb03d656ad58b6e6a0f80a0880f19d08ba53c8e93b989c38c7c9d1fb652c3d3bfa4e03620e418688bd29b16bbbdb6d78b5a853aca3f5bc6585bc02bf8c13f6551b33930e3a23582128be51d42c91c8372dba68171bfb56e26d94fab497be845125d24311df7cd0a3d74fc2689aa6e880e30bc2049acca8aa569df1627306baf5fa30f4facb79e0bd2b04a965333bc260bf6bbb15094ead648b574104ba0faeedc9c7aea6790606773540e217fe946afd4280fb565d263e37af92bb0bcac579d50dc15d6dae5eb22b37bf9636c39c90dae09f4b229e76a795e2d5c96f3215a183f623d9646bfc7443d6c20764e978f04da77610a2f63552502b3b38afa05f7d21ae7e8185b6cd8d3f6f230791af966baeeb9560089be011ae196a6e2452d0bb616ff77b25628d08c2edfdf6a3d960979ed1a62341dac2923aeec4206de503be32d7d8e4f199f972aea8eb4fb3ff3a3573dddab5467382de223b6604b4b0da5ab91a59342ec8f80e49099907fa227bf0ae9abc54d1d775a4216666a9ba4637ab263b7ca85c6ed4d240f32cd0d25fc76d48374071d65ca88d9ee4084bf92022727d8c5862364bb6a4fa87121d8614897739ead6ce9b40d1835f1d11ebf6fa14464282b75e21f56654851c32eac45d7e7b4a78b5b5f31e2cbdb6b8e2bb7ca298a6cd2793572e76920348c40a0c85c026c0c41feed666ffe3ef1b0fd33ddab2c15269213bd5dd170998d55c633e044a898f216b0d89c152ae3d7b4d6fb836ab923a8829b45ed38c2e45bfc0e80a521ae038c8d35b0afb019c783aa090e4b473f61b014d45087ce62d61def38c9cd9c92b393b462ea52d106ea8572c393a30ee5f8e27e100edaecde7b20d867971223dae789027120851e34ca86dee98c270b6b28614b3fba0b5d010374df160c81a5856e5131a5cb67deb67c88d80bebe2dba36afeeea04437ea62b21433ac9e03cf5d1cee4084779e21e80dcf34f19faddc944f2ab985a797086cdeacb7dee3a5fc2963b423292be80c8f48bd73537b82cc095dbcf8d21e1bccc9b8cff5035a997ccebe989913ef9a585dc7861744739823599f2d99cab89b2931cda3ccaec5f4d6dc11c92e0f4d58bd6bd3a4339a2a9dc072322fb4c55c4102fee356ccfcd00c3307d355e3adfb897d1f518fc474030c2ce1b037cbc5a514b54415ebc42567e9c4b1c74b960a43ff2342a43e18db1ed92495b523bb6ba3405d9bbdba3f08cbe0420926981bd4c1f0dab400191e0db653b08cdd0f42eaaa312083c29e1a28f1c6d69b25a3f699055fbaa0af6efeff3099b3b33eb41d4053b2ff900cd2a246c6ba57c56bcda11906e093b0021784544515590b093cb0930ba728d989cc71daf8306952a64c555d50f5bccacaab5de41fc0eabf543308de231aa82e3d562db3d10279fc7303955a7f3daca4639bfa3bf77d5973fa92d86307c0edbef1f961bbbd13e738dbdd2058937c6b41a99c784de18a11e762c2c9629ad092f75ea8b33faa9669da0178a2f22583b5c0dbfd3f2cee0f8eecb8f31ceb77dd78b2166ee5ab8810ca9e954827f88b054cdf8d82c8cd588aefab986cf69e927ff88a01ba83380a9e44cb889358cfd979f0ae112082120e18283883abee25a39447282c96de0ad06dafb7cbca6f2124582c00d4a784f2bd0b0374615edf662177ae91894dddd8f1a073fe89c171ab9d090005abb14f834cf8753ad852dc535fa89dd8c6a5a3b21714118d0f10eb946081364e40778f49deb58283cd9fe1d04fddeb315f7f741cd133b424914ff492d0da5ef6b8d7fc19df8234f0ebe7449b11eefd2b2d1bb87126417539e5e5de59e5df684ed4aac44900bbb4008f5a5216cb625338501c4ebff1722cbacb872c999481d03f841eca575066ea333cbec3fa21259f41604a10b85b3aa6d23801f411eae2b7a35139ed4de281ce329d3a137e6098222c86790b04cd8d3204863b809e86b48e7f1de4a11d6280852fbb41e3ea06f631348995334ed3b774ca887c9de95c1011c3897991250599de996e9c84eb63b820ee36ae96210669f747c17f822e52f40775522d31ca84caf76b08ebf90ae57519100ae4a0f12e34ef675ccb27bc1ac535b09ddcbcc0c93d41634b90ef301aea6e171dae9ff567330dcd687121847ae2eb14f7c10c1577514945012bb34485159013e2e8b18b69a8ad03bf910eefff32f72b7cd9bf26002014f1cb68230a684f1a2284317e7b414adba04145fe268058290f40b7d7724dc1eafa0a9fc4ab299c03cc6f9e95f6140ae8285d5d3bb1db0624c5ca781c1aa586aee94b8f477a16dacae9812798df5acf3d5f83f5b3c1b64b3159f86d5baed0dba94e1c1c1d1271a2734cbd743b0b1032314c854c0e392618c635f9038ee9048d55bfb5313d6a9412da9dce2411b6cf26f45d024340c033073c4509ae8b8ab1f282b7554a68d7b7c5e649f70ee0e6af2a643da7ed798db98dae4a57e09619abd3486e7b12a104c0f5e5494da9d6ef4a44f6b74310ba881d1235cc1afaf3fc44cd6dd02d6fbd6d904f711786c98c5359b73a6832bc1f7b2cf9df1620b3a759f200745b957391414cc7207f7bc315f15af9f1809721f91fda3b23f6d73642f84a7446d4fed3e09b6b48e7139a7c5e8e9b67eb7c6d66fecd73a62e99bdcd4582191d06cc7bd5b4f4abdbe73fadb3e418ca5cee1c4291aae035ae6f2e1821a96f46eba072f85aee2d75126af4514c34986f1f1fc7635aa1220a49c71d25d609355617c624d32270c48206df9eb97a40aea3e1b761fc8f5143f06602b816d93178b516df278eebc18d5eeac6c026735be85d61f5c87008b8317cdf5c6d4509c8387ed840c4d70781737b9bb89982b94e592ff106cb5ef358dea59e4742c5457508bbba61609f02b4e536e5e443e1c387741483dacabc7b1392cee285eba660c81446cc66937e3957d626e60f85d70bef1c60439fd8d6f28b935a087739d6e9e580d67b12c1760477ab917f37efb157bc06f17a5571434140ecdb79f6eb70c549193a4ff6d93c4a4a7ab21378d026d26ce7754458454633c946a3100149757c8003d300b129fc1639203e5638b748f404e74c95f721cd14bcdd5c665bb555ee2db88936784b53cd02c702d36bc9d271f3625940d94c666d83674c4b79c9019aaa4e5a0dc24e86bd23d5e566ba1e52f9002fc9b558abfb9ac72a2a281a3a008d332aecb50984ad6bda57719d7319aa58894edc1eadfc2b06f37a86e156583fc70359b8c3f13a478bac3d1faf23ded5324789ebe354f2ffd3ff7683d6873cf3a1c9ab79d2c10367ca974244260f597c5de54855179c35a559d0fc9ff6b9c306c4ce25b2a0ebd2df445df3fcc91b1d27c8504375dcef3be20a3b3e9f70857ca8e981d105689686af7ca9b19ee64fb06d509a8d425780c237c809c3c3ded802186e3b0ac3b7dfb6d051ec6e423ba0d1784cb419a01b2c48bcd690d53343735fc6a47c7b50d53ad7bf75fc955283eb7ea1d1ae623b7a780d74ab3a71a38bc8183f1863ec17d550ad074d6e7822abdc71a8adb97fa1cb77c76aa2ace9bc30870f09043a506dcd58605a05cde060a61b4c776bb5c89fbcf5095ab0d1a252722a895d21ac8be766b067019f54a76a8dce081403b520d71433f8b714910f69817e47943fda21cb467fa27e060f9524df8c4bebbf0faa415c935034ddb2be4a44a4015ecc1484cc38e38a063d531966ce6b4279c89a502f0824f2cdf0a5d9436e99c6e564e1db8e2ab6985d11269ad0b04d0c48c24915d86b58835ae402bc2a53ea0cc578d092f946d694a5ea79a70426ed81414ee56da1558be19a22097684ac11989e7f61ea80ed030d2dbe119e24f6e9e3c80d48a4dc45bced86d8ac8313092cce9d93bdc7468cfcb3e2130690dd63663badad4f6663875eb6173c246eb52d4e96595a1ff2edef8e0ee110a207e4470710240866891afd6fb3fa59b9cb455371a1f432dbe3f8c4a16ab6abb870e08ed5f768e7b733a6485ccfd7313198bec74f6bd69cde0eddfbd07c9e9dbfb6b2154c456a98583bad98aab8223ba5917a08bccf1485aa073b5e33871b76e31912ee4773716d27f5863767eb779208ce92bbdbd389d99ab9b03fe9f51d6383c43180482a649e20ad4d123cd31f6e56c2c04d3c29581643e0a3e5b080cf22954a0f57eccff8d0efcafc8fbf40f3273f748401e833ef9801f5874b970eff575c18c8ea2969a38b16a791ef287600df0c9f7afdf321f6c674378287c89da6b80f628b9168c6c2b4600ad2597f4af936c9a1b7bf67e3afb252e166bbe093a43c314a667ffdcaf7fd3d3f31793dce1ae9e21a9caa8bb363c9948fbd9d59daa2320d3443572b255fc4ac181f02909fce9a2c44c1ef6fe03cc7e74dee81921a9f508550bbf1ebd4f55dd0cb00043df2991380c2daf0c1767c9b4e9fe50c455229db7bf9c4c5dea4a9919306e044189ad283428f17b91e2697067b8ba5ae7206d3b4438d3e7d856bcbb221a185e021d702d9d36ed30739fd131f8ca76960bccbdef2378d7e3700712521ba87790071d76d92372359b496700f5559a857bac746004ff91a9cd1edd7b05c364caa9876d80a30fd3f37deb04cf494495590a3b34845560f2540b56c055139dac42d33928c0ed8eb6a6c3e305fec3fda80cd5c970573382cb1b12647076815c0f10880d9f6443d7dab5d5e21a5521135042a333aea02a0f3f164e28a3d94859fd7ae6aa5110d581be585821d96efa22a6ecbb36c0afef2c62360949fc032f568b4ac971ec75be6eb19de7a6f9e716d3927da6613a67a7e77b071650ed36dcbdcf30ea0beb67622c528f0935a1ce2c9cca6a95194361432a47c54b8dacad8a44a106904d70583948c7909a6074f1957d84faff3f26c2c6c670714578b4fdc3164da5cc44638ea1c4594866cc7590c24d8e6b1944268faf51784ff50c07003a5e013b8dc4607091a21db1c364e34614461fe13793fca0c4e6dff643c759e1826ac3c0f51c67a2b1b971fdf583e6ddf2dccb31d6dbb68e1b9efa084e700bc28e8e3f68b909d8e480b8e6ff5aea8e4e31b5c6de6a54927265471c953eaaca4073b9639ab63c106e71254d49e73d4c7b43c735c65117215f29bb05395b1c6cf45ba9600fbe2c3698b87aed063778a3b936a27bfeac503410bb37478b10632e95a9a87691345937456c03c9061e96a9b32775dcc959d716709945a59b3abbdf2550011b65ce640c2b7b99e0e8a4824f8b3a40fc002b8a1f1b3c11bb144498674618e2308efcd32e43b769cf819ead75c94e39f9bbd9db13042aefdf526b2714c423e03f5c33a2e5507b44b1646706fded21bb5495bf9fa338956cfaf4bea07f7a0877be1479001836c186ae36d12af491ab85e6b27ebc7a2eb915cde6f6fb139d9c1b19a48c9fff6525b5c73c9523ef4cfe1918b0ac2c884a5bbf7f4b3042fc8629a0577a058d5bba8f1fa0e489c3c860eb990f89a3d6f54c49ba402cae67d544b4edb7595d38c61e5360da71047e3e97e62ac6c1484d2cb707c91d0250cde09093743db0a19154484842393432550bce98dc59f20c413d8d675a138a304214dcd930d2ff2e17fa7f9d783b3b8fbbc93b4a74d98c8b966b8d1dd8d2cdbacd38fd951d119216535265409ae0ec04849a15429e89878e03e099a5321d6c364550b5db078e39117302a1a978f166106c39e8c5a12f10361335dba99dbf8056d3f45ee7506d2a25dcfcb1e7bd92c457ef96cb4b87a89bc609be1de656b3a6d94743c05002bf95bd9b87623b3bce5bf4d81fa36d77d5af9ce197d9fe37c178ce5deb7606a16d7289d7186124b769be08978f23053f9fea1eaa6638ebf1f5dbd787a8f1f60c008b701acb70d0d6afb66630cbbdb90022640753f860920c491d1455e3388195b2cf95b5bf63c73b1885d44dd8c0027c0849f281d0020789132a5847339a662ef1aa90add6365538ade64c9e3edd8abe59a5c909903da65dc62990656722935e3f01846d3020d2ac13948f168177af1c02070368a293392e375d798e353999c2842d8ca0d411cb9c74af0ad0ce807d48648a6e1e668991a3c90dbdeefa1084d42cc518d90b291c6fb74dd0f1c7e3988aedcbe49ab62be911caa7f835b209ee75b846b52fbce39e963e23e65def753ce35b552f1c68282523539b041993221a6fa3020d7ba606adc09ff2a1c6c3cd0d4f29e44684719956596e0658b442dc22bc84f9ddaf6469a9ac4e1e44fd58359a06b83efee68425410e8180a5070956a9d7e02fac8f8c433aa7f0088859b669e5edd7675afad45ae494c52bd1c9b1bb11acdec7d136974e6bacc4364b761c4f9c6df1c5fe691f369c611fcb76552855d89ca71c3b145a1e56f586449f1de96fdc047470df70aad51b0a9aad822332e96c959806d2b356d891ad6d47341d00067b407ff94ad1f7907f03fbbcffdcfc3a3b86bbaf8aeb261b9c09ff514e83c907fab97451eabb1a71d1e8d573557c4145bd2304f4e483a2517999d3026db3c241c37edc838fa200c547d1ef14cf2e518425eb223a166a219bc57ac232756bf23fe784c75b846a8c5886aecc1c5aeb46a85a9fa0d37a637576acf08ac70c7159c7a29b5bc5c750632306c5f26c66064e8a5dbec6ab183af98f57949759e97a8e3ff372d513bf807645c150ab22ce6f5beb0ea006c78c497ef5c93d43a20c4d461a5345c431c9cc3f12775f56dd05e3b61ed1aaa3743f60abd8ad45095402f6cab2ffe47989794028b32fb09e2cc06162a08edb0406a6f4f6cfc4f566e38907f4f32620758009274287a90cd36a7a0d764a60963a26acba4c8ffb323e2e749418a2e00117c5f7bd00a8c897aa1eb95b0f1e5612fa39f6c8653432688dbecc7271af00d24b19e99ce7e3f21cb9c2661c0ef0ae32b3ee533036e3bf4423cfbc750a85fca0e43d71786efaf2483528c3df628706ef725ba9a39d15a91890e1d8b16b998c8507187a470f6d3b5c1b9d93beb7b93843e9d3c907d3913a0a9e9fa98329a0e62bc9b12377be073df5ba27212ac8dd84fb101ce50001bb4b96ced74ae0c8578da55e515eb4dff36a7fa14fcd58dfb1138a1f34b4b4e88f40d7ba0510e0764fbce2ff744c74cefd4cb7d2a2bb5eb90bb5a253ddfdfdb7147374f6fb66eb22db92dc9389c5ebfd98299a0527bfdd16e359430cdd1b541f8dc5e4ad213893b2bee0ff87ff317399c011c06251f92f3a2dc07e98cfe2ef28ba54117e1fd58d946c31c6684a174f3301e7452903dcff2b373b11f66637379151481efbfc549d005ef8eae547a78178e8c60cd3371e8a1ed15e8fd624a1e0592ab0ada14a58cbb35430a2d959a2209a937a1614cba55e0e80b88c95f47f16c4dcd7bcaa2fd20334b3eaa0277e50b97d59c39d4c37ca76814ac4f3ef4653994e2bba725dffc26fb7b21c9709116815540195c3df997b878b13a3f772937e7646b543c0a202b582b434201b8fb02002339e2993f9faf81ae7bfbab1ab9043eb5cc8182c9c171f5ab7d16165727c980dabb446b260e0083972f041f975a4fb6e7dd613ad08c6ccbc03dc2d63a7fdb8172eeb8b482e508c27f92455990471b2eafc10fd5690ee327adb01725ca1afd18cdedc30c76513ccf0233cd89e60df07458ce4d314c15c9f7ecc68472e5c16ce7b8f543dd86733e1451b6a4138415a0e20d38d2d341365b8b8836dd6d20ddf23047d46abca71ad4c8ee289e8e53d378477dd5f39158999f537ee9d6b7462f45556b64845e93e724c46717176cab6096e15ba4e0288e501474a3e310740bf2b72db9e5b814977fba3c13844b81020c5ea9fab17f51ffc7fa3a4a2f09c654f15eaaf64da81656e660d784c0df075ec6a9de90a10e1d7d802c03df4e6c7f54189edc1a0dde04e49fb9fb8fca2df5685ae9abc8974d6459ea716723e7cb2fe8cee76fda9a4e5ffff45ed735081dfda06dda3fcd9a08a47052614797232663d20f3c2209e274a3ac40a6104b27dcf1bb37fac3431a44e24fdfab81de617c9831e454fbca0beb6a4b2bf7342a5f0d773138c3ddc1cc35535facd12400d15920d1a4708b2f0c75f6c586c83c481b5bbb127291600a7d3e45728475056ceeeb60faa234f45062658628468d50bacbeb0858dd78badda2a1db64b30d38326830d6e5909a69637751e1e28b7597e36d77efb566338a8e77a543b3765c6eb4a67f94b51217ccd385a1b937f354d0b8b3eeaabfecf25431537238e95b67526584f700665beca2dea95c34fc0d29b80d0cae45556d8177e9a92e2dc961efcfd7fe617bbe6b02698f0a4d4db760c1a71e02c7d31e55497b054432dfc7dd21f2d3ebab3fc9250e8561a3b8926f53856f891bb8024cdaefb7a400c1e03c682bcd76c80101b53c2422599e9cb7dd2b40e0829aee3cd1ab274c0b372a66ff1fbf5cc24c97d3adc11f143c072aa24e3837130b23469eb1fa376dc7203ae14da655d16bb96b186dad4d907e4d488eec889fa6084bbd5f98f334e1db31152292cd13ac880a0845e85d4e68c25042f37baf4d0b8c9f84f19c8f8711187539d71c16123c68dd1288c3fee7839c7a75135dedd1e030d0eebefb87ab6748c63bbb9b8c29964fa3872995e0bb945f2c76a0a8d9c032025e7284660e9e3529a54c4a41628a998ea4c6215beb8afb78a96164b49c3e7372da1185c6efeca89cb5cafa19bc72b06008020d206c8618e50077969d99b36ae421d71ad26a7646099bde900c0b40c912e4c6d7760711119ecc837e0499ea69496d08c7537bd98d0adb1e9bcdd0bc563b27388e2b67d53304e2512b4d34d3e2f66caba7e0d7ef7e91cfc0aaaa282d76c17a6d95ebb0aa19423a2cf098be4752981e4a8c874af81612bc7644134781052396c958700c6ee211ea60b9f428aff65e60ae4f1d08fd578a2e334b38a9f18898e3de78ca8a178ea149994fb5db3857ce2da8f2394f26d22b27729e8c2836b60d5c717f047b6e1993c25bd5d96940c050a85a73a2e9ace88271257ddba973325970d8f12744b12e2f261532de9f95b9aa2dc4d55d59131c7c86e4ce1cf3b58653fedd8713979a564156fa8282e6a6b7d341d313e7f745cc22e335d634368682961e3593915e97952816485f0b6ccb15b69bc0cc460c1bd7804a2645689de2bd7ab694a180c097ce7e87c40a695f036521d02366e1c4b2c42e75c68d42673d006e826ce02cf8543132ffc3cd0e4ec6e16da0b847d5947107cd077085103dc1d8eea08a868cff32bdb39604e34c797bee158664b5d8f3e75a0ac21652db2c68d42566dd52be10686c07e3037c4d45f5d370aeb2c4dcb12f6552e486cd59fa0b1fbd4503a88e8248f4d04e687c398a77bb40532dcd88ed23c7c5a4eeebd36ac5c4337502be2a6e76274a760dc11289a9591df4b4a565184f9df2a58db0f4c02faf3515fd775cc455ad3f4d351ecf10150c5d98324d09e87ad87f281d4c13604d766d6df0dbcabb16da58d7bf483fc2252abdf69f3b963388099e641633e19e1edb3034646d1a6d6010d814f6df9bcc7ceb63de4b865c2be5db4c3905c4af50e856455d7c0a4b5fa5f7ab35497b51d0318cd1a0bfb6053d0771615c92581f81d9804c24c7ae0a591fadce8fa917eb5ca2b86039fb2879f9c3edd8400daf046bf5a9370dad56bc078836151787b012cd83f571037c7b52dcdb7857d9eb026a3b84679cd54d70c023387f26c99c10bda68963ace39c165686e069d6853574254112f1fd1b013c2eaf97714b2481400633343c44acb10951e46cc3494e70648484d42006eaf06a5a5bf9d300fe9a3361e5d3a30103b12d2ea48d23e9d352c9c5d922faf5d0a9416c8618e1f8d422d9184829e9b1e5f17a29bc89a50fef9294817367c3e87383a34fff480785bc073508ca99b56e6d26856c310e0bf998d43198998e296fd6cf017c28c2f1a3cafc32273bf51aed8474e48c11f30e7806f13d67cf7a38409e5b8043e2ad3dc0ca4ff6bd26958a74837daee45c3a07fa8f99ca36b2fa828a88ac903ade45bbdc8e80aa9ac2005390ac7876b328ae7fb04fc483386032e90f0b74c4fee271afb34b453721491004f98cf4212bd1b4cb1c20d1526bd9a38be3a5979a2c8365b33d47a789cda0e9b5b451e174b0d4c8f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
