<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08a67dbe7daeb3569be2149f3c255b84480b823cecad7e4f254a390590242b258d170403a038e12b1c298ed765367da2534f21dcd7d63b3aab4e006b182c95afa0fd272227df2f71d023cd4b53116fba9bcc96252c1e4831468c5ac2598f9fbccb17e6b3a0fceb6de8b02a196d8f610ae26329b7510a0fe917042aef908d51100730437f7349f8a2a232dc8f700e9af66eb4dfba6fa74e4a076e55b33aeb3511d1fc6941c8e9a7842a046a55e94b28f7599b96cc5bef2bb6275d90c155fc299fb59b494c304a09a93637d28005b8ba7f897dd98b2ab4aa33fc4151b67610e299fded2502a7b37b15e2fd304a29050d522b55928c32e50b0c1171bc58b23ec7b7a5ec80091a790ea61af8b19165945c46bbe433d9c584d6e3fcaa32dbc0b9db1ecd63c7fb91e5b9999dc1a980b3b0b5652fdce84b4e7819bc284ac6698363f1a3038420ea64b427bc54ddc4c248144a061947001f0ea83ab0cf179312016cfeb0c41d4712f18a03295291064af827c5cf495e2d48e0384c4049518c5f02fe928fd9956d4197dd2bd37b0f3c18092fbe63e9ca40d5b5c5001d0426257f41d9ca609a859b5bfff30a4a44303c8019914f706ff6d2162abe9be0d15ffdcfc46dbf54b04c675649b3ab94afb5e0abdb24a8ebde14907b69909a91e2d5a51047814dd46439ee109da2a4af62c9bf91319b00742de685dfa4583d9545c011e4441999cba8dec590bd9573b0df1a97e213cd8bb108068caf11d0c6576874759903fe7d19a3575c74624f29add3557909f962612fb695adcbdff53636d7cfcb502112d72a7580926400967cf5ab4918a6369910f446917dd05294893fe8dcdb11aef5bb8e2f4b624d9f42af4b9f7c787ca48e546cb6d8d58cd686bdf7c786d5bb2a7efc453cb63c3980e1f38b47a880333bacd8e2cc9268d56740f68e6bca4a19c894d49f5eee9de3f51b68e79d8fa6076c9af3529df80dcb851c5f3b3be01969a5e521a2acaba7de235935f8cfaa20f286436980433ecf9532e1cb6cf5c90efdf0d969f45e933ce5bd70e1a70e6240568238064e10def7711ad33875035a2bd0ae22467d56357cfd651a6302f6c6a1c1e714abe92611bc8c1d4d54f5c4846e042e5947fb40f5de94202416e4d8840e9b95193bbc01c2c500aac81228810aa47c1e68f36a0b358281ea9b8f3c068ee3c35e4f50ee155d201f8a0ed81daa797c01284cbe6bf68e10bc915e11d25c7a44bfa27e0ba7cf40672aab9c2cf6fa48f5c294a55ae841cfe3dd5a639f8e4b5268a1557f1ed4968d9866a9d07e35eadc12f1d4c27ddaba29775db334300c75bb517818849f9ee0db4d89dff1dee6836f203c76fa9c1e92d81b517afb6b10c8d6bc989124726c1838083d37ea568ae3fcc32363833980c70e12f5da482e17458d94007e556d3621c784f564885409a5feeefda4b8872b910c7ac0e07350dc46bcbda2ee7b0d3dbaa349bb1390d8deae79c4995f8996a4425cdb68484e6e3c31aa3ea32708b62642b70e4d783ff3ca060b53c3fd410c1619e9e374beb18822302210db7a70d4d68cd939d38b0219ede01f6009395a3da1ff9ba0487bffa3e6cbb742186895ecc25eea6c3138f1c22845e8b176768feaff2ab92b33dd8c6d9332f60c632d5f14d12e168d628988d27f6ad5dfb71de17a5a63b4e1355f1bf50b36fb2c5ee5abd4c4ebfb5c545d2dec5c0cffabae8ef1152a4cd6d49963f3cfd7398d118512e837c26b107da291a7ce9b4bc5b4a1b3d06cfd0d327adbe2944cee9dd3fad379f48a680a37b9b79c43610f5d0055cdcafc2fa7cdd8116986e3ea16d1ebb8e6a08eb047bc71910b36b2fd1b406d7d26c13e88c712f37b4f32c26b7c9192fe4682c7b2bf89046df72a32479f3fdcce5d7fde46270860621f86f8ccb679d92e4873f5196c855eff00f2468e82c38d13607b95dd7afbf8a1d2c7a9efe22afb9af714af7a56bd72a5245b5e0ae6fd2eb83acdac739a1181e54dc33cd0394a0a107e39b45c7db0a0a4efe3d7ea9ff44669518efa6cc704b4b13a3247efb882ef8f67c23746fbfc69fff5b1dc3664d49efc2f0500c9c2e0fd5ab15bf807b6c0d41e8459c01ca6838ef3846cfcca7dc59f6f234c58f5b1af14c4c9c6ec883f56c6531e2211a5a4e4f053c5bea5fa5467623a708fffe540707dd7304ee503f4c23aed2d8bca17697667ce328381f37d6eb1e569db188af13561ac8793c660232d9b4d61dad6854cc9f10c7a4625fcfb2d948b1e0b08e920ed8500393d5fc112f9bbedf28465576aaf2fee5b694606405e154c229218947ebce9429f26610110201dc712460b8f6836c634aafb2433bde2b4f954a858c0c78a76984264c600f979a127d31feab6a381ce7d6c3697df0fc7fe910eddaf8ae3e81b6f200affb8fdd49112fabedffea549892024f912d765bd58013b871249b0a797204a71b2df20ae7a1eeba56a90b061ea640bd82c56fdb9b625e644079498335306e47f9e3c44625dfbbf2ad34daa90edad629bef0382464bb7da01a1cb430413dbdd55c20a0bb87e160db8755f704d1de59df5bbb17045f77bb552cf273f3ac5da5072e63dee79b419068b2dd31a6dd13ac5a569b8047309685fa86f9b3d6f9e1e6263038b8071ef0e25ac3192c6bf24e60f017559b73c6bb48843afcca914192bd47264db1bde9300221ba1ba23bedcc5d82efa1d9278c88bd1ff56acf7e78faea7c27396fa2686b3d32ce6c4ec1e30c28aaf6867d300cb83ce3e9101dc2f694350444991a12f797af639427fb2476e43970c622c23e5c459c538ab7aaf2f7026fdaae252b59c8200969077d9c74f6ef0277a1ed239328cdc0382fb80c5d512f49d175b438fd4c86d7980f19be5c512e0fe9e3d5b133403dc62778f650ba1b0986b245c0076cdfa61564e4f008eaf705ce9b9a3e61c3af83bf4b572d2d4983c320b5287ee41219ff89ccc6b7dfaa478b409ae62aa2cbe81d89022eadce0ee2b862c4a5d2c2d1fdb3aa6b20e849f6284923f83d4856b22e56b9273d951d1459c087cf26dcc661cbc2f824865f8af7dac9799069c6cb9c7ecf6aa11867f0e54e8635f54dff1f54ba62bdb96634b64129fd5a2d55eadf239b4960b8b5c25c62225794821b6abbd50ed49260af09dc7d69b7b232a5ba483f5fed920b81b96e6a406d7ccf2f88476b57fda00aa377e9bbabc116ffd5ae3617ce8fb96f539c0fc7c3e99e35de318f0eddfdb85b01b0fda4656c5926700ae852c779b235fffec77540a8c33c57e4ada169763a7022c3f4cc1fac05c588003eb12f1a253289fef046c5ae1933dd735a29b9c9c09692d31919a9094e54b337feded20bdd62709df3187b98b25b005fc9fc4da90b4e7c412872d5a0913ec6ec795fd7e96caa8eb4cfa527718662ad3ba9d5b9991ba879e9f4b3f37beb9252e4833bd2304bab589b1a3138aef128b3cb2260082c39f98a1f5882ae9347faa5aafab2f85472ca9efb6e43673aeb90e0980bbcddef39c1b66b3060e74f89b4c463238320c1c3bed488615bde817e1a582a1350ab804d0665fbada7bd0301b1740a7bd79a8ab4ee2e39b354a561e2b6f28c39f5b84d98e83fa214643c1ff3a2202fdad1a86b4024d688d286641f24b2be4a99a8d8157714f0e12d38235f6dd219c2459cb81aa13a045ab0ef135e629035b17e00501620cf6cd5e99077ceaf7437a6e0e6ba3d9354341e379f2249eb9c70c91f022cbee1c1067036ed4fc921088b46a452b3f6b915b120fdc03f995af87cc91ab8d65e973baed7a24ad964710c6f749ba2922c1c328125d8d0140a49d503491bcf66699a382b37def229e4cd44e070b4042fc7789ee3ee78f7ccf669a991c8dbe504ce898fa6a579fb55d18f56b88904137a4a597b0bf2128b9c6d0a1b54698dfaa59fc53928c9ac6f316789c0cda62fb0e30dd18ce9748ef11d5b04224cf786580f0434e48e7cce2cb59245df2024b659ef7b44b1ee371540005fecfa759058e97bb0fa7dd4e848d50fa689a58f103d619b7a32e46ccf307023748e8df7db2dd12846ae49aa762f7abbeacc514078c31c328e670fa94afc1ca2f3fcd3f208252d88f63664822bb8cbd17221293111201bf2366a51689701e44f968445fdd36536a4d04dfde056e9b6c8999ee5530d4e3d260c73f72ff24f87fa8bd4e8cdf5ea4507b8d400e27e4e916bdf077a7eb44f6fba00f9b05e0a6a37fedcc5191613f539034e06ba85e466e8e3bc814898518264b1fc9fcb015ddb2edc979c060c338c5c1015a3ec3b09d366d4afb331c7a89bd3b5e85ee0da79b6788d56f238a5d4a170cce1a582586055ac162a065958c4391c33556e627ea528f042e842cda13bb76e47ca4ea2bb44e0e49ec9de5bee02280fb6882733c65b55eccf4ae9bedccfba8e226ed2d34f4e583372c2b0a688621b444ba78db89aa7be19ba59151fc664419d7b429d245c23c9949a5cb243178f07fc640a5d9c426f24fd02a912194694650ddf3d4ee729ea21662a8ca180a98c8f296b453f507098a44702b6a74c5ccfc92c0132b44c7c4bb6ce293aecb69aff17d49980e25b6e90017f152c2d3fbc61a81ae434b32406f6bfa0d1d6f4d1969fe9e9e0351979de91d979f6debce1f0e464b8eaa4660958d68211aa130032d4bdd05a12a42db77524d3584461aae6d1597d251213f0d0f96c511b3e7d3fd4821fd5624f795d27e99850bd271b7473dd858af67434c84d5e7b70773939828d523cd16b8c9eb52168ea6fa050443af91a7998b62e1ec7541b338b731b13f5cbb38d7e08a75010702ef573d7f5581bbb67b45414a8aa61d4c522de2ff97e2445e8ac97e42a8ed9cae231935829c0c5bed9dd0535e8328d5d9cad01102932f4e6b0ca07a0f35d9146ae447790c4fe7bf66b4bcc17310be6526786d23b830910954da98b8870668a256e133091e6b65a79134ccb0b245b62b8e3c2a91866b401b4322047d91ce124739118a6f4edcd82804b45a6cc1ca2a5e2a8513b43df5b2930fbfefbba8dbcaa72d2c8f9105c5f2d56a4fff8702df4677ae08ef524d2daba4d749c8ba685cb05d839511704b97a75febfcaba8cbb66a5c38ad22ce71a47dc8d90d83117b2d01ba6f114d2e8b1ca89ca2d2d9f53372f45bf764a2067855ceae4b2b8e989419b45c613311440a305707a62b53e28c41c7715071381185a3be4768d4265442664b0d5b3becce752c9515fca1e510dbd2471cf54a358397b0305d600c0b0eb2448095d53b3071b52f936747e07846f19a2c449f18b673794c60f052f0aa49348149c2fccd73fa9ff833695c1210b4c03d4a7a492f616e837ea45f3363c17b702183785cb6dde3915b971e49ee319eceea2e444f3bb3fb127ded1f6dc4c65e5dbfb50a8647a09e6153d266d2a7bcb3e8d6f1e1ca5d83be6f15e278091c785f63ae987e77003e200672a1f625bf1167a08d72efda13cb2cd6185acceb05b410ed10544fa6f3d1d747995690a91f32daf2025f018c989fb8a353caa96499b1cf77aa5fffd54a0e65000cc17c9435980a75c4868cdb7556d813b4fbaa9fd6281c684747cce09d1baf2d2da935b68c92de4d26b737cfde2a85fa495706bb17ab4c44b63eba47ba1b7163e6efa625b9fa6cd7501948f8be54223d3a4c1f087016e076f9a42c7e26e8f5af160c16a09e87cf7be7bf1cd9761b6f367651aee592716650f58451e06ccb0e116d627ef7a8475348f13460c603ecb0bdf959a6bb48390bacdb0ddaf756c6315b269e183b3bdfb5cb3912a5113b032fe37cfe3e858240ac1ee0fb4d20ad2cccaf53c88c0d68c4ad1776d6f59fe0353986ee0ae4f6cdd8146771e6bc4c338a40a174d507780716b94fe0e73e82013dc49bc1e5decc1818a19b7f557de2b5ce7d519140ba402e0f7db218f6eee8fbcda56c4fe0ca6cc555337ef1d42202cf52c4d25c71d61a9b93cbc888a93f633fb74efa7685bb075f7f1d12b3b04d667327ed8f3f76c5408f359b2ea0a8f27025a3b0600eb1550f2387fdb09317c1b59690de6d999ae271101f5c1a884d547d22f2d845c9b087acd1c4ca51a3c5eed55b8151a6d054b67bcdbb70c30392b693def1ce4d87fb410394579a6f20f6a34500ba6b0547b8de23509cb21184d34444b6bf695459c71307d663f181858a5662c8859ee2bfbc5f2a01f0bceefaf4e7c2d56c3b9a5f617c1e42eb658c420947ec181dd0df8a841e3ab10d8c920ef034f39c5410ba9538753f670597a6bbeb9f4f5f93f7b5f24ef4d4a3cff24e11be26576ef13d5656ce32e16e697b2e2674e8a0174dd824be158889f477e860320f335e2f9886bac7c78d7aa2d90349b0f2433c63edf2f656a048e69f870a0933eebcaef97673a27078b28d9778b1248d6ef41ade6adb7cc2d5330ca82dbd90a64931a64dbf00d25327fdd8143ded74794b90a35c58d56a0310eb0fcc58d665dbacba228378c97ca3eb67d2fd3a6983665567387ce3fbfd6776f4a164fa681e4b0fadc6abccd8c49fe49b2a505fbfa9aa73e2bcef9e8c5b269a8329fb739fff6b8493b8a714ac18e8f08aaede4637d9ec38a61d7fbe52e749b0d824692f97ea285b4a5d5c4789c2503356f36f23e7621c0433ec3f44aafdbc93139baae0362913e0975e28826b8c485ade21cf7b1d725987295efbecd3e1abbe9a75fc238b3a00bdc34d9bf1bf8f4dce5e4297d0e47af272142ba5c2505618b3781bd30d7275b433afe7d053844ec76f0e1525f67ba2a748916b0a823ce45c82e012ab8b581b9dfe3ee8b695283172117468545264217058ca0e91a358a4c919b2e9e7fe8eff6820c36f43a2f289661e98a8ebc739133365b71416d92b2f70d2151c9db344f36b6bdc413eda66786dd4aa7a09081fd77b8387eaabbda1f7eb7c5884239f2ab815c9ebcd1a56f58c1e01c0f71eb34d4f7656cca0bda5425892f1e2708496f4f3e5a4509434b990bf172c23816d478a48507269dae7fb857a02eb1d671993a784f0a31725c914e6ee6917ab57425118518e9ade56e09f2e129e21df35e3f5de71b865f881fa585fe42eec7bc9624b2eb71beacc99954bb6878ecb65a99aa7a200588c055349eee474c09d52180d1c906f28acc84aa736a39fdd97e4362c74a71e0fd2684c06dae3fa45acb39ea9fed0cc21eac07b6d2d09f10b84ea09ff831a216c4dc3ccdce97877486166d6d7d8fb9af1fc7160ef44e97911ca14a4ebebbde56d01b7346314f9e19445deab57cfa52a42de32070eb6e0b31a083264fbc0d8d8e339f4e1728a2ae1af5c7a5a7f9301f99773a4259c061018f70198f5477f477d09420cde5e06d706c0fe692da2bc5d98248e43eba3a320f5637ce6b6eae4d089bc3060db6e6ebaa672050d530dcd821c32f2d149a33a3318f7f1d5f0592dca2e85c015302a36cf42e6186dd9b3b316933d327da0f325905cc8a2105ad3ea10817931991ac6b9662368b020fc941961e07c6a7d393f5e8b3c1b2173af328a5b613d47d52a9365e9b7764440924746ad19cdf656c20dfaa51e104d3bea870d45be8a0435c062edfa295da5f9850ba8db42e9f7ec218a8f65179adadcc7640a06d6b6190127e8576f584cc904f55106cfbee445c9e3a67e3af18b1824a30c8bed54a07ee9a8a141ba93819cdab4e42ad5a90621c1b3ed139e2625b313eb3eb65a398f41934c71994bd76f72f0cecd11abfae1f1cd4affa293154614e6b00fa827b93107f55ae2185992692ab6767afd04415fef4ccfd48345a1ebbaabb0d25887752623e83d5ba43489f0f93c7743ce9b8b2e87a2ec8bf7f80b34caa4c884c641c4659d97e4d59bed4790c92fed30e5cbea5e9def566e33025360ba5fec0397dffa1505987b33eee74d88edf6d848be110190d1634b7a0f6e3adc2d837c06fa61da327abec117f1c7ab9d9179a60ede0e5715068836564ee57412c2d686d996dbf50098f0373a2a8d971df337a9c0c18dfd8f44cedf2feffe4ae14ec5668480273b9076223ba2be1c074262ddf4e6a6bc8d707fa7064a674ca5ca957aa2fe30ca83518f05791695f666d9884eae61162ba1e684769c4e287f92b6c6c6afa43a93f6c823e91c429bfca9a7e686005247738d4c907c6a6ec715f7e4dd0fe35d623a59c7ab7838414690306e11dc9685790eedad16890dc8eae0fe0d946c9e82aae66455b863c26256095f06a9137120c1553e6328f29f403072d9392d1a494eb1f20091c91b30b04ace7933f00633779b9ce31f4ee0bc960a9b90a92037c31049df02eca9408cb0bf71811cac95ddca4779977db117dae266bc43080037dff84265e01f2384129c5d406944e1c6655940d9d98039e1f55dae7c600c3e58563e598197b5d92b5c8692b44c76ed3378a25bde495e41062d2ff9023f366c077e2d9f712a78f4ff63f9fda176d426dd37c689df0ac07aa2024f6a0aa9bfe74d33a347e2de5f942da18aa3162cfc59402def3e48fe83ac4e861525f3d896da0c646f36ebe614cdd9193357c2e7b806039dbb60a945d8faa2aefe257339175c6fba2d360c8a7c86461fab83172ffb39842416ebec233679b96270e0114eeda479934adaec57072bc513e48a44c4d0ba4d958b1f52093be295d35aa8dc1973984bc171ba23630a5a1b46813cfb4007ab73416ae6b67b335c4a8e07d090d5644b6acc32922f011265bad1040ccd0df9ee0fa46b9f6e53a1bedc4986404ad0ca992547c95d66da5931131642fddc26864c5fc9f4a55fd89e902622254143a4367f6555c7ff7a50e71970fed4682175b35ccdfb71bb248d5b624ef8aef2f56f134e1895b6dec744911e2671212dfdfe30b6fd0de1a4666093c33af9013542a82800093b55e269c0ceec0cdcc17be9a4087c132f8fea8ce3fd107e165b086f67c7fc8c3e2904d5405f4026697a49a9c9bc0fde9c4e09e943154f2de9ed2dd943f22157fe63cf62db3cbd4836e695c281290b7525064c00b23b3d11d88ee072f51532d3a02b933531de0d97f3f931ad5966256df099e25fcd1ae6626888a4558846412ea07c2b2ebb6b9d9c1006c9729db498cb8372113534a531752a1a7bdb91534a31d3e893884ca7d964d45487e487f93e074daa74ff4dae3494aeffe99961eba5f94ade685f14fb52a55c804f303aabf2aaba5586b29556f19205a7d13fa00f4ef05417fb51f41351ec8005c4d13c8d3c2daf81b4024fe7663ff53859dba23b3176d90272c579f2c5e18019a64b8548f23a45eec65eab49f56b06e71dd27b4183b10f42f1b155b724ece618f44e9983eb323e5c31c61b8654da1159906905ba8eda8e3da7606be4e2ecbf3d9c556d9c5eed86a4943bb24045f51a1424d65a4d49c1d200510a74898cb5e6ed702984abb98a285edb1f5e14c637f9b429e8b143f5c3910879ae9cc07ece4ef402a0a73f9bc0d9c1f95f404c80c1c26465e9b0e09c900d31ba8d389d7e7d895a2d37525d93c1fb2d023837dce8673949fab978b5a9cbf3628eaa3734d9a48d5b70e30bcb73d4df8816aa251c37703f74ff2aa68024fa2dc0b09aa6b878de129d1f01ebce0cbdba00a0110df3d21a7b54e8902270a552d16567dce50b1ad7233853fa23c73d2316f945ff62cbb0a85a29da795ced52056265b210fbb8a2aed6fc9dc59462db7cd2d1effac9af056ae300bb3c9237e39e35108dc27eee9508d09e1c7f324c689b731379a356e1f68aff1fbe7230efad57a210df0995679458259a66dfcc2c1897f5da214670a5eaad6ae811028cbb04a3f50d965e04593d575800c289a2a544dbf9edcc6accb27aade6519f0e09b4bc7fa71199d34f1e93dadc0febeee56975d4c6905259b8449091ff2f6e67824bafd5bd49bea0f9b6e6c783198e486291d21114942e8419df3238fab55d20de11da95396097a4f3d663f1676af37a633a8dc1798e2cf2062424aa892a974f2bcf1bb1595228111a22a6bae4f99b7e08e2661030f97a42e2be53e72cb1fb0d603c216035a00892ad895259356caf21682a19b2a8f7be7d2defd943dcc49363bb8fa21ecebf426b781584cdc1f949d79f6c33ff6889797681d46798f8490b5507b118fc91d53e8764cd8d10377b6b27865b2236c14b931f33ce2b7e8deb10b1a9ee2c47c2bbcf0085201e23f48876da2333eb9db1222e3fadd25681896355f4b1a29711cfd4adeb20c2e28f11b85925846bc7edceb3ca72b28d724651ed330529dbd9627c34e5c2fa64c682a234f54fdd75882c8427fbc69e20e0c5856f4ea67851563d6a887ab3b4b28e2d2a06b134f3c4f0798f6917f3c2f461c0beb124929655667ffb063163b84d6490d2359bc1eb1d82861a946f4af1c87435d0e2285fee5a2cafde61f613d57711503b6447526a400a3b39155eb90a8ba280e863850bd2378244fa8e0e905a78991870868f5934af8eaddb8f26fb1f9b29c017718a8e85304643d404809365f9824573bdebf4460bca0c20a029439d86950a0a36bae070460f5a9520feea75b30de45f3f0c68a9050794b5fa412e72de140a9b75a87655db10f8f28305b7d52f8e2102d32302ba0fb57e2777c6a3243de2918791e8f243d139cbd962e54f4b15a25bf48602d7675e5468010bc61d2d31686ed0a62bf38ffd884f2bbca463cc849cfcdd879d3b358f920458a5cab550371dfaec49c8b9b19a0b367a23bcc4f572add55d1293f981f879a6c7123a3e9f80f753a890959a1e4c01c7979a899930f44120c04e0f3dde6912d3e21a72887a6aaa2afed5244c7578b814b08cbeff7b583ce2710e95b2f1de03e773fa8018662bed894c79e87237754ebc5812417936812f731abc8531c23782a057d4980f840eeab226c503f15b53439c3f7e8c4fc9c305256d1ab16d76d6c094c346f9c424cbd826d38793656b39e9fb3c43755bb3d1d8163576a60d075a6796a1ed67afdbe1c9bf53b01131067a7e7ffcd4b7dd90a9c80c6e7416b47def221cf843c57a5a7e1ff9ecbc2b59645fcb7fdaa33fd32219bdf269f37593c96c9ea4d094423d1125f05f01f57e54504e43895a78413122832662b327eaa589416abad72cb8e6d140c5ff0284d5fc6c82a6c3ccc128965a2cfb5618cf34825421d260f13f68a6b12b2612289d28cd183bec7922ef3343f99a7c6855b9b6aff9658b5adebce8bfd9daa3b1376623e305900c0a09086f044a4c465cae586b87d2fa693511a2a49f0ee2d00dd43a330da6b52506860358e160f7e0fa015396b758784b1d8db95e6d8f2074089b73ac1d6da86b0e4c11cc589135316df49ce8e218d27d469a1bb2e9e36b6415f1f358ff78dedc36e704a832e2c9127aabe859b9f0e8ebb990dba232c1e79ffd014884cfb21368ea040f81d08fcd59f5a826fae69e6165490d5349894c749f33477d3607531ef788760d7ca66c9c425cdbf3afa1b89d00ca4443e4d6fe7c02a335091aca59bad206a1c8f47b3b26f664dc8073937065d2fcb0046fe2f9c3f4c98201c9171552c7da8a59db09536f31e08702b994266f70913fd8a62fd756ef8b6b5c301af2ef62659f7d7d042f855fd90f549c1de3dd8b962981196cdf3c5f73fb21263d89f7f31f6e0c6b99d464008c14150922aab2e6e938c32c711e700ddaf9113e0ac7445131fcd55b42b4a733658de6ac3f3d75b21d52c678a9d04da38949d01246f604ef80db5938f9c799f284e0a753bfafd7711cb80a5edc3f035dd7953e19c3ee2a01b2bbabd2dc62c4fa9b5f460b67bbadb3b5c11101eb24b033eb109f2555ea1ea945da1955861aff280c54d477f656c37c4ae6ab0805b4c25bc0996b6f6b13948a384aff667544f42a4a0f02409a6fb557c358c574df22da83ca912f253769d1f6d3a0cdeeec1a72441b3cefb75500185361bb8b330c17ba63bf34959025301d37668aa77737f42f46df1f2ce3d46365cf62947aa00bc613fd8534393e8e5fb182c8d47e66107dad6876002eff122ad6181d1f4bebdb379d45872819d98cec9b8ce80aba3ce28bbc489f968fd9a7ebb1751d1e23ea64b851d294c60f9a65208e03ba3060ce41759809b8bb4c1bf753a8cc74e7f573a9b37f0bd608f774373333fa33c28b2d3d1514724c9f3a449ed613ae6622bfb583f3c4dcb133d1b391243b9a0ba136766aca8ed7af074888179e70badd0f72262989a370ba1a76fbd0102540795fe41d6c7dc2ae22cdcdac15b8156efcd666813a576e46aa70c962d1965b47a2ca80146f7c6aa8fc168dfc12af9beba8c191f28068dabbe02b396a1a8d2305b138383a87c27cbcbd1a79977aa8e4ac06e642fed983cb3d3d60b72539e3b20ff5f9dd19ee588a2f6b21e2b4b70d40c439a85ea723e56b7ea6ec67230602d2489611eea8520620cfcfc94ed4d8d2f0fb0b4c68c410bf12c77193005a2dccb66e8a5ecc8f5b2d7cfbe102b48f7d52a0dee7c73b307fadf6d811cfffaf52e44c27cf7c47013c1aa6473726004e42d06a33cd73ad694f98f8f50b6f7015ab75e4591ddb8acc3058033f74f778e1badefd3571663cc5863c03897d16d2971b44819c609bc9fbfb6003f8e7a0c1e9be81fb20673016808856b99e382c5d224e51a50f8854aa73240938762b5a9b986188a8e51e5948f5abf9fffdaa31708946e6ecad365110fa5f28c3fb1c22247d18fea0ec378947045abd0f610ebf886ceec1ed46f3150e7b603e536baea7d0404679f64e77847ca7c5d871bbd0403e65b15e6736297a46e601528f5c759775cae8bdc70fb56e4fb3804b8f3f39de0dfc78a9a50a994d26ccbbbe19acd24f169855e17f7015c1165613b4d74454b505ffdfae35824cabed18729b3387818794ae1f9ebdb3532da488a68850c2ad4ebaeb30ce04ea781edb18f20b524af0d720df36b89b9bedd9538e6ed57442018331addeecf5aefed82e2110c8e23dcc6b4737c3cff65e98b89d9f59438148d50c9a49db55a82988a451cb6342ba81152dc025b42fd7e44a39b7a40eb2bc3961670a0238ab0797e1fe3cfb3b2f6341b615cee4ed798644945b0d176b73c4dde6563fcc52f492ad37bc623903b80bcca2d6c1946615d670da8c5acc109133ca8afce048f5ca457e20cc60f2675837cee2fa4f90dc46c0b419ff535b838b0d2f0d6350af35562d8e241d5b96eab918c7de34817b42fdf8f353b20f1b3b4aaedf2fca6635747128614e02e47d4986378a583f2c4ad00e9701953da0e211973c4be73f5c29feddfceac689e47e80506f2a2c7c1110dd6980de598ba6ab1bc0cf61db9fd1f7a4806a4c8e1005a678872c3cb202f62456b45fd364707c240b758418277cbc18bffa5f4e6e7f9cfde2ad9fe3d3c94b7283a63d9eec9fa714c6a8e8cad98f4d66800dd534d92478b8e1abff78cd87a5b30f7523df77ebeae5af97008968395f6a112eab0c5b08d7dafaa866986c0badb88203595b6621a50ab08760782a26cdf23aecab7e926c1870401cf399327a74c14ee671f76bd315b958b53fbb9f50564fb8037e28715cca0408958d10d2207033ca3bb0083a9930065cd41c1ff05f93e1c2d7cb1222f248cd90f9976ad7e8f64c19792d35fe50ece9d2d427f9c405c3fd68ff86b77ba9e886fcea6da87b77ffc790874cfe249f77cd92f7434b791cd0be0baf49dd37087d5c53a56644abc54feef3d6e8417de01b79ace7a37beed90e31bc02311f12847fbe41694f5005f6dc49f7f4dae9c362234198c7ee5a5dfc04219c4c41ac814509a0175c6e4be453dfa72631145102b9428872d3db64b1cb3584830b2d07a951ea104168a326c52caa4988503785e1d90ff6760b894d52335ca2fdab26827082e11080d317cb6a1cbc1ecc8c52dbfbfa8b476b0e1a90bb45b1a2db6f4816784fa9362829765d9d3303d64576a9f28dcb8d6b9bc00a1aa89545912736a3bbe855a54f10a7349a8f176dd176fcd6d11851ed572c8bb7ad0880b036f9e58fdbd8d3d03a35ad4e44581c613730910e3d8ca86976583a39aebdcffad1c363e15e1e01f21067df5b4074de18fa0229d9a8a70e440af41b85b2d4603b9f4c82ec3becdb21652e61ae748b927274db8a7110f86c1094768db9ec44f97507db9a66b27755fe7c9b11b18361b0b89bc0e086c143c7b098221c4b2a43fc30859021aee52f58410faca8f62cf36ea44bdcf2e21e5da0353dff41afcfe1d214246a5d059c20aa556fb666079d1ec84076cf0fb048699fcd3d4487257890bbbc577bbbb85825b9da719204bd20bbc2d16643ed47ae361d72e27a6aaa8bb166204a3d1438f98a639e38d48b3800380e561aaac8361f5a39837d2bfe7d42f62409d23961329a538897b009d1e9a6de9ec51735c8a0add3628472efeaab5511fd99cec81d623774cf6024fc58a57638e3ecd325a1fa04f861bff2818bf59451c2967081319945d775c01ecf5d0c7db27f0c5df755e8d383e1638e4dd00c4a549463186cc5ed7ea81b8c41e2ff6917513955a0c58164feb59cd1d9a53c9ac61d0927e364109e0ec6365ebadbeed41455d19b2e51bfba3af7aed11061a6160d2abde97f338a2ad8a58f690b94e83ed0294b76d1125021db451dca4681dc942895192752627038495665fdd5cf2de5ff1533096d78dd8a29383fa8ac7b3334d2a8642c5fd3620e11ca4cbb44c0abd8a381b270fedbc9e18ed255ba3552525de4ebc528650675e0e64edc6abc1f90b90b56e58b2a2e1b1586572382914592edbcf041a25bc56b7397831cdd6db4c4c833709b7b8722bd7282aad4be6ec33d7d939b7a9950d25f1b596730bf236b7069b7fac206514abc3d63b1dbb714e85d71fa5374134766eb444652b08c1f24543c08db9f480ff9ea0c3b49832a8c3a75a2b282e31b0aa0b674ef0038ed8e5af383d5a0de0c9274feebcf5711f7d2d9cdae93b9091f762f84495d894c654eae08867f7965f3cf75c69a94c4f49c29f08230652fcc1cf6a37eb0dfac353440544272bb1fa68323a0ecbf04e13cc50aa3ebae20153a73ed57569e76aa8bf240546d55f482fae44b056e605d2c4a091009d71525c885f6a80eb9a54c6dd7b66c08ae5114f4ec94ce2e228930c21548fccb5e61d781cbbd36ae8bda3f08969e0919c3c5d20aaa3ba41fb34c4273170d5b555d0f8b0faf48e6f46256e199801846def4020a69a55576f433191547355a175ec0d17a43a2454479a8c8bb9646cbd11149586f840617f0ad43cba96a9b2fc36ae546f775f444160714fd8e14c9bd671ef63cebe12e3809004914e8117704b35b7d5a4caff0125bb3ac3dfad235b090f3c9f35c6ceaeaa21148253a12ee5dd8e6ef176b8effc2658f70a4b51f3532051364aecf8aafe77eb2ef1cb89f7f2775d1400c27ce7cedf3fd599cd77a34465df7837c9ee3eeccabd5ab09d883a4c85994ddfdfce812707675a3f2100f9cd709191bf33a95b5d91433762734ee4b12e8e7d7b98369a7eda4b0f81f4c2cf09ea9dfd68052add213e566c0df6a18637e6d1870b2f5182b0a6314d9b4be1efb35fe28479a1ddb9df4da4e8d1b209a6e46842edbb78ba200c088ea83d128c04b7553581ce58c39fd2bd95416029ce276daac821a18d2aa098324d318fd0e385eaadbf8dd92b6625b03b33633c5f82facb7281af16f9adf180c76b668872f6425248daf06e642830333c0bc224a37f67f511f97288c8c93cbb43276ef2f0a2a39cf9cf15d0c4c6805bd208911d92e7212aca596c306c6cfa21162f42e82d7f5cff7430546a9fc0c3a4e5e51fbf74ae0430159d440d5e990c0b726f6d757c91abe7e4fc06f7ae4d711821743e086509d78ff88bc6465b728bff4100152f38c27303eb04a7f1b047e6daea3a8860db8884d356747b30bde871e7a523022cc236f74c6361e98d5dd7db1cdad71b8dcfcaa8b0369b8c50fdb2626d6e3bca319f108b01fb765b1898a57b61abbb461f52723dc0c53bddb778d29b4e0b0401349577838b4235d5a8528c66be53ea2b2ba15e7157eb968abdeeb32aecfcf440d20225950f4c49fe5206f67af6c0c1c412e7ca1c790da9ed6b98a75153ebeeefba2db6feafc105374e5291dbcbab806f3a2491ca2a2492f18e2bb7bd6f37a63ea239e9d336c17f64f82c22590844b538437eb4bf1d5443d3ea1691124e1fabf92d9b1d1eff7d46cc789c58cc46a9b44223e69684622683fce67607339b29aea98cd30862921b30d563b2140898442ea6011b398829cbb2ed38ab9240e1239798cc887f10ae8f75a484a5f6617a16424342874576b896c00c45cd4c06346b939c2078533d50a9f8a3944a3dacbcd0d073b3b1d63625bd892b0facbf7fd8204fd5a6ee524fa2caa40cf508310a4b93add2da4592da0aa234328c94f74f06dc8a97f81b3fb5a0d5ec779ace07f4f48a6987d7345daa3c77ffdad5a8778f6ad8aff20595f821e92b5cffe464ede06d286ffaae2c81ebac1490374306848afd1283ae113e7ccfe7c0c7fc6103e7a35d38f01cdf95389b6e160ade47c46bc56ba9ef3c3a4a24516c4c25d5ec6d19948023a7ca93378510f1a886153b962acc08af1079ccac27c40a8507970ba8d48ee4b4e31cf103a9a4592427009e9cde578d9ea40a6acd5aed48150c6746901d057901a54d20588167145cbb8d066709644c14a2f60f578599f45d59901fe7e70104e0f55994e8b85163237d6be81ca77b071063f4ee01572eb264037aac2a06bff0036e0789d0a07148d9d1f602609fb394672d26233077293d2ed746f9a1f0ce9f2ed43fa9084bb1ebb67d89749344372a1324a99976a0d7d686d04a1c1db6e390a658d3cae379c86c8f1274bf61f75a362ce2b2a00e98d7b1b4329203da1350461247fea7d19e9c206d15f56bf1ad805ca6876044eabe6c9094bb010045f7c5812400656302b248c49fd8c2a55cc71172427967f8cc36a38fde21567437bb62ae050d4fd4421c4191e00a17703d313eb6cc650eaf9e4b27b39fed53f5886a482cf018103ec0ba89846500644aedb6a26b00d1b74c4a20108244cb44c340b6486d069ec195adbbc44634810d33281193ff800e9b9eba1565ad1531b66a97ea43945e02e97d92332e7389e7412db1ecbab2848e7d3ed753ccfc118737fd0b34e900a9025ef1d14bb997ceb3af3ee1991f177257b8fe2b1ab2bc7d5aa48e432402f9d3c348ba5861bfb07514cb12e03db3103b7d6ac6b4eddbe8ed6e0b0c86b67b31e582a24ad1f92a95a0fca40f85003eab075680b262b96cfe14f811386b5fe3cf28499566aba279534021e2d456c33e1f42986e045a262a14715c0f24edbac7bc143dc63cb5ad8e06c1fbcb9700f20d1698e41ba599456d137346ed3c59feeb7a2b38bd02d12d6b98caed14e6a4d2d3693c65dc7f00e357d3c810dc5dd30e49098918bec76fe06ec99a961d1ba7c8737d30fe17c96ec951c3b5abfc25213bc804c7bf0fdd9adaa1766c514a5b3cf2061c3b46ae9f55c1d73eedd9503eff0099f33ded0fe6c3f9fd55517242bb421b7d4f6deee9e5b58e69b7651925df7831e77f6fd94724fd0355891a3c9ddd802552575c90ebeeea86ad8479dfa1c15c2ea270320dcc5b1662b15d6ed557a50a7eaf9b3eebbb09b4518fb7919837cc32b5c740d343610616229bcfc844682c82f70537db75b583d8f5d401e8dcf51f2ac5c2d871fabb8b5b827ed10599fa09d9e275c98a12ef692a275654bc2c7226c38b124d8ce01c053c3170ff8ed39a10b0b04ebd04a45497a0909edaaebfa156009644ed84de23d8a6b87179fef92c04a656f1e4ba5e9d220f3304cc28f99f6c4ce81b878100a16b3ad7f232ca094735a69b4bf1172ff194b386c125782bb6b7bce5cad9a82cdc63c901fb6e156d6d10056f60320695e6b231d82bebd01c8ae7d999c9e84d61413ba7f393b2016297d2fe54ebea9a95e78ae7decc9ccbd36025932b2a7eb1c2bf0c8276401245cb5854ae4150f5b4f7d5c266cb372ddf54393e142cc7826715dd7596b7e90fc8729f8394cd6c7dbd224a5c8f578b88c9004ba26141ba1079f8f5e2c39aa052a8df3bf0ecab84c01643f518e17c8af674c49862ba6d298b720a4128ca4ed17fb7972ce75f3ff0df82a28","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
