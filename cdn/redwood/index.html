<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ed88c1eafae5f9c68f302736da9e3449d5adab163a36583bce9142dc43c410a1f0d4af8f08738539c462163d9cd8c8198d68473bb1b2c15a07d728cc44ed3d33c5ac0dc44f5162c237179e66558ac7880cb882562c851a32dd5fe4f3f3fb40d73d6c578e01b7035a8908ca866b622a65c052bc0efec36de433bd7afbeb75239c1553597eaa9ec2ea299065877d6cf32a19462bc6e2809786c4ca5351c3745d04f2b5d9fe58f47d13d073aaf07e96a27ebc443678f3d541f1f96287c9d89c115194c75056c71e306fd0c9588dfc81681575951fcef074fdb49bb11e07a41e7264f9f68b680bbe34c1317d618a9408a23b395b27e089d811b5cc7c8fa8d7d094c636ce8bbb8f36c8db194002646ad4ef6bae766e9ca2babfe42bb698e70f041900a24e659c74f08079fb89ea7affd4bde924972a8187e38b0502f011b66b0c93084268cbf2ee4883baae51e7f69cbc7661f99e1581fff95ffb7517447dc6779ceac310fbbefa72503ec122b537b0afc7c5fe027dfbef91dbe62d43587e76dba4d0fe931ec55ef58e11fa7cccc77148eaea8c16c4c4e2dd1d8eccad7ee4d204b99d424e37abf08c34d7f52aaa64df9c162fc8ad8dd505416ca5a3d1707a53298acfb33cfb82627e78cb69b7506a89abd4b808f6e7ce42da3d37a943bd8c13f8db0979ace60253c4e4128d9aced8d0c80d785f81c63f39018c9da566e8ae0f448f506f5f760641973e7b9b996a8e1ebf4cfe1c3b6076c44f49f0bb971b88232a917cba999cb47e626d2bffb85309e684ed8763d21a5d1dac97cf279d3ae6a516c747ee6f9c067ec54a776cc2581740327e64dbbef8b098cd8733e60a27e808dcd94dbeb99594c1948db033fb215e215fbacdde75790a5275199af99dcccced944d7bbbf648cb4b7dc9f05cd0627173e2d01b711fbd032191e55a4788491470cbabb95a6303b5dd8b9a16b7b0f340ac7db6720be8459dc74531677982ea4d75a93d5d0cb382bf7e9dbeccaacf449019ae757771436abf8b7c70ff984afb2b5d5811ddeed7e452820221d81262a25f051ba759a6b5dce9c5a24f01de48fe5e435fddc4b09dbbe8f18b2c6f45089ed03cfe03d7dfa97ad833ba8e84811794dc98a3791fcfd0cc7c0f2fb9e05cedf7c0fba799805ea1c2145400bdf7712d0e2ea75d3b7ac843bf952abfe6cca15f9540a94a5b7b0e6959c83d70cc161bae545717eb13e3dfa817c9ac801c0d70bcc8ace18f4acd90954dd84524ac5972803fe10dcb8703f1bf17034d6cd01f86f408ed0da8e25cab74b0ce32e3ac0aae3e44ff36b4682edeb0c8917d1e545ede4b02e33425a349b16d7b25a30484e87024fd950e3fa9c43d502b1ec4a2e492de2ea109f939854144d92f1820887798d5ef53f0297becbbc3a445d984b0adab8a6fb6d912ca2bf14856554001da899b473cbdef78dad28d5af8d433a078540882062f9a6ae75222b9cf4e144ca677755c2d9d0e46e724613b67523a2ac2d60de41f4f6594bed956cd43154b986f4e05a9f5f74e050b262b5c861ff1c54eaaf37b538c23f50b4d384fe06c79b043d9a9a8d04bf71ea7436dd856bd50d5146991f648bb55009a749e649eac5f95fd2a9dda2653ae67d61350b71b7ec576cf476755c266d85c56f1b51a64f5064222acf1346b108128e8a2e82c704553ce45c9c5739400201b1fb5dd792d38a3df2a93a0abe799d81c911717799a09ddc3ed5c3278daa5d71f2e1d5c5815f64feb698b16daac6d6bfd566459198b3bb8bd37a7d73c5450ec37c2c5ba2317356866ea6c4a1d0d69357e4b0ee1c0dd1fa9053dd03224fbc70b1ee2ff23e04021ba26dd4304864b8b8982013eb51365672ce2bb27a2f92713cb805b8b47275711a888a2d18fe8e5e277f8feebbb0c54d631feeddec0bde296920a0610b3f30ec3a2796fe4926e698f965afb4bdfdbc47760df6784aa48b89446091dcb6c78ffc61210a6c9530ae499ce1061b4149b9abc4dd04c57ef5c6fc5f8effeb240d7cc1d158d1cfc8b392bcd26be2574bef27386966045039a4e848f794cbda8f4dd3b0449eb395a52ccb49b6fa47b4ebf255529a0f41d95e0f9e45c6e05b54a81011a09c43d5ee4e04980744d1f0302686351d56579c663d25eca755de9065e3b0d1396f0e92c99489c18850ea02e5524c192d809366a3f7a227b48b1dcc7abf95b238524b1a9f16d037f1b09259da732c4982c58b0663301761968d21454b37dbb6c516498272c831d5de1a136cb0afd179fe06301972975ba10b8217f5f8ec3cdc2578adba87c57d00f47bdfa3a68967808c6e1949ce88ef19e0656ed94716df8a5648358b861cbcad52771c854f5af803641fdb1a392d756e99580d094383c27a30ef6853cd372a4b6fe391a7b3191233f94dd53a4755ade463b6a1ba3bc53d3b0b33553b336466cb8b013cdbc51050de4cd75e31d38c60c3e948f0a8031192b1465c54958437a7cd97a68af7208588cd718b32eb7480b6c3e30cef376a1b644400e68e97156b2ab464d93f8822fb03ba2931e1f5fc15668a0fe07bfec7d583eca68de509ed77abe0ebfcce92183535ed21279eb289d838176774e005692e4396ba2ccc9f992a131b554ad453a094ce4073b84d4e6ceb21f66eaff1606acd552602640781b9baee91780ab21878258ff994c7cb3ce5fab4cf33d7d5811e0bc0e99bb7608e22f05e27fee871fa16dc0933963d831adbb413d4e643e0c0499790d4771b3ca3532f82ccfaf82c5aa377b6396af030a472cf6f5aeeea922558c17ae9fd4fdb41b52da0c6e481207468202228c51ca806ffd5c5736d4c781819bc71bdb1e5bc83a38b4142f30a3329925391cb1af0fbe53108164f848fff53fd85de248c6370def099cf66fbdef826a3faa2a6a429f61b70da8c905749e505f4eec3b440c1e5dbfacb894a081d06bfe53ebf360e6aea7ca92efb836187ac34fdebae5a62a85439632c2706128468f491bad75133c7dc3a324f98824551ba54ee7ac07a537a25401bb9ce356209f5132fa226d1e2ed6a936c020b80791470763e1dea982c16f1a8e5d61d99d17bd343d4a0bfe598fee1757f1ec2110eecfbf908fc8b9fab17fc6a1aeb3bf66141c5be275ae9414782348e12d5c8e6cf8c91a9669d5c696160148e038ef342cd3000c46c30c5f11553c389e5fd995d7b1a999d8b76d3a85462e76b2cb2536548c7f929c8626f476ad449f4fbc592982464a14174f939d18602cb5c2187a54b5dbda6dbe9f293a9ac52877578861141840b01f6df42a0cd6ee0af9160ba7d39d55413b060119acbacc2a41bd92e579c3290c63f4dc41a6b9a96d759c5e8cb305c79e78011959338041adcf180151c5a47c52acbd2fa66be6a84d6a6fa9ac5bf5f85caeb19b391308f290ee66416a7c0645babacf6d52af9a4c44d4024ab58501400b64ee562895eb80cd196b07fe6a22fe393d76e8f6f3fa0fd7b8f416c04e845de9bc16c2d3bfeffe1470eec9ece15d366c8c54cfb10ea960419540e221dfd52e0a8fe828706f9991662624ac2444548f59939736f27613397fca83a6c03386709fe99d2a698016e4a278025222310a45ee04d032268b148f01a32d11fa4b8bdef0bc26b7518d6363a6f738207712bff492d74ab26a50babb320bea02c374c6b89f3377aab3fbc7bc4b05453fca9b02047d259f2a913157e36995b907ef41a57e7917c76d55b8cb3749089cf1a344ea285f6eccf58b4e5ce153b9d74575b22f6eb79f6538b3364144c34fd2e78208ff329f26b5a5d61afd054bce42f0f0e1a9332033d636b87b610efa0170c9a62837d98884973bfb796cc9389df772350a37570a30b62391f86a98d88ab91b6fe2a460d5cb5007b9cd5228a44b09b5b428a5d8b4c344b216baabc228694e9c0878ca2ead84de28196aac1855f7a3b62f34ee76c3a166972e87dc8d433f5c174db05c8ec7fa85f2fbf37fe854b08f157a293763e3f22683b1fcd0c0cd1d1711428307315c157cf3cb665837fae0333e1a819ea2fd8d1550855021dcb0b1f05f7dccf0211b273e5eeee03303ec9e768a7594f9ba51e6052307ae96533b1230d48d72040dfe66b480b33387f4fde0fcb63e96ee0b2dfd9f598252691ffe9f4eba41d58edc03baadadc5149ce9f373d7dd14d5c512f3810de73d85b3dc6a2907c154a483d9dde2a489c49beb22c070dc37a08f407e01cd16da67b6e5fb6dab6b051d4c9d41ddf461b36a205cb8bb10acc7fd8214385d4f8424944339cf2a8d8747c1efa3c6f028a9aef6d3d3b3b5b9512f8a44afa9c84b53b2f060def057518ff4d89b30b7eb1a34c15c00e3001868ca9664d8c4c83c11025f488d083fb7e4494705b7aab258783b487d5f5e106471c59f26b61718a11df15a4ed7c8159ef5d9ee965ef5f53fe126bd9161432d6e50ad70a9dde4d8a44df8bbae32fbd6a276cf0c2a4a49b1e1894337a67a04c4c5e51278b7eceff298d7780b7ad9bd3e20c823933e6a208524d6a1ffabaef2cbe5a4a27bef00324d111106ff1898fb857ab5ccf423a13329b57559b9bf46c45b6e45be1830cf8598197d3485cc73fba971f14de9ff6d996ca94ca4bd1666fe2c3ec9ba8de2291166b842b5668c341b1f9052217a664bfd6a7e9c80cd1c269cb07fb08f00043eca09f0f645450003b58df76999eb48917dcb76668b37b5f1dfd28e39e33789e45def2575a7311167c055084b508dbf03d5d554880bc0659a8cf511e2356918b4be60caf4565cd8047dd7563c049a1c0880f5346fcb7d62c1380d3d8775ff044d3ab85a52b6aacf47ef5dbd5068824af92812da1c70c1545005cb261c355b5b2434f7660a34b0dfe1445b9fa56289d7daa9f04ab5d3c65736cf60bc831e170f04ff3a9f8e537533de9a8a474f9f18a52078ad22bb166a7530c300e237b6780ce63bf1c624b1d1ba0a1f4f69aeb781dfdf076b56c48fafb15631121637551a79de8f85d2f62da79dd0c165dea1e4137a8a11bb3057d851e2abe9b675f8c5b1a752f7bc1824e8d62f29f79839097b36a7098c6a4ac07c93267881b06545fef85f58d68be0696db704af9838e31cfd19857a6ec002ea1cebc106940bdf1518695ebd6fa24f1bf10c84151f40e4060165f25a076b383cc2adff07d179a2802cefb11e5d57278f4f295578f6c060e606c639bf42677feac16f26b04eb7f91ae26c76f6a8a985e42488c2ce06257cbbf759714a12d4d20ed4d8f3328af2f001d59dc76e710a12dcf87b444c2207d8fbbc1a2e7f35341ce5f0ddef2e0a92bd77202b19ee281659d0e69ad3d9458a8f0100a50dee9dfd09a0b2e15c0e7724a1c6bac927423bf179be5a38146442242915c03d6de211b93e00f2024e9367c02e15f9d5420cedda4f53ed050aaa820e74bc9b27d3798212a3166c31d5e12b86158bad1a0c1cccb842711ae8fabd88112b2c109162dd4e8c9a7faab1adbb43b90123683ee2693de39172d74188c253d2be0b793112c5cb8ac3250a3fb00fc32a2ac6f252274e9067108c33e0c6f1823dbfb208566c114acb0b74ef3da4cfc8cc29adfe46c2c9d34c694bb01df9594e7c1ca77be07c9ffd02fcad0154fb9296e1e4e7404da42aae8d9ebd7467d0bd309cee099bf2f3b9a20317470a96b7e01f468aa2e53bcf3ead801b922b913656478fbf649387b0dfefc653f4b1be3aca0a4f9025aa2c6699ec1ceec9a3fa1b0ae04e27ff2a749e4a34ce54bfd4f83cc36f62f6f99305c7b31013d1d2f91aea5be1348d1d30b6c8bbafd59787a6cdcd441e2ef3e59300146069a63f52780e4ae50a1b461cd4b8be2255fc6acc328f023583d3c0a1a45405aad8fa996baee580a9f7be5a1bfac044c2ece174438722324d4b8cd48c735b58670c47b5f351520ef4d4b53af3f9b43c5a55852e262d470f06720ed9b0dd1692e102ced7369932d65f8b4f0c0c2bb1bb3bb562d2fbb329fd66703612eabc31c311faff0b860edd2b4d03fc07e7d0a178517ae36bbb4ea294b6ad2ce35a8326c0b070aab5b248d14b2463fd40c69f2508b582469d0a978b8c7ba4feebacb7d3890c84cb448732ce8d7fca431e1b3281ae2dd584214019de074f9856f3776204a2f454e2946f4ce9379558e46e280d69e740ac4f53cf39e10712ed268a2ca26e82a659788caaeb56dd6bdaa730148d106f195753202f0e33d8284bc1d4ab14626d27277269ae6632ec2697f2371a1eff59913396f92a32b108bbeb46ae56a4e790b9b7628563eadacab9da598bfa609c118b43d4aab3cd2f39c881377fce3313bf024061f73a65b895c931f8699839aaa6859af365b4bfcb1e6eb8345e4ad5df40c8fc5b1d72b58fb66b8788ab78f09282fd9a6ac83742cc026a8a3d43f0e6bfe11f2f1e10d561caae71bca83f20752b54824bf6f74d729d4b76ce5d152f7a9558e82ba60c100ee8c0823815937720c68653961ed2c0bee526d9c52a6c5b618251b82359c917b4ddfbe9eb5585b5b18f2d37accda6b458f6e2868e7f53a6e47bbb5675ba475fff4ebb52d93c3e473d984a26f0ddf9bebe4f191453e5dd916cd242234273f8b31e9a970a0db6ec9b2ac9a681e5b66c93924fe307ac4a97e54c061a30f345958c9bd2a95d97961c93d4def6d39cb73eae7df14438ea6d790c249295fc7cd7812dd5926e06a45fb1f37c33ebc9b53170e785d84c9bdaa69f5df22b8455b0e8439c906d80edc894f05064a43a74ad0855d099242a7724c98cc906c568cee66f13cba165b821c5b3c43aca751c00c91346c45c86dae412079af19d2415cc0819c56426134c67678490ec45917eb8dc0bd3d9ee763ec86d3b29be67583c7e55c0ad70b9e6c0e22e7c14bf75aa370a6a8680e24efd061bdc17298ab493f4f56618250b0d5529e4cdc7b42a1f14cc77f07cd39fd1e4bd14175ccd7dc9a1877dfec08c6859f2a2b6d80a512a6e55b5b185ed8ba1e46322f75a7e6b854b94eef2d689f10418912911731cebba239bd61afa8d605b8e0ee1243d144d17b2b2f7f871d56185098e6b23bdae93f80eb4dafcb5ab97ac821a08c9b95f0258c763b6e20d9a11eeddf1b20160f86de6171a869f03fb1176e6039e4d10bb32adfd7dda0deb9846401fe7f3c67a6af7bdcaaa0d90f8cfd05e62464de319b6cbad7e4c977509f75607f467a3d83427067e5085946a272a788028887a50c0d0bfbd2f804cb0cf26884965df0be5f93cee837cd58fb13232e91c3b70e96627602374e982743a0782545a92443c89f00a43f91969874b61739e05633ddeb273767f0fece86c97001d2f36c75b8896198e214cd1f8f5529f1a01841a11e2252bf3a96b52d0da01b2bf874a55aa2842e99de47a1d813c390e3fbc100484e688001b8b11add818f365a2b607f446a0162d3e82add3bbe8670f8fd157dbd4eed96d9f88fd3f79a0d00a64ced9166f812e0440ef78bc9b1369ebe3b5f96ed48fa50dbd75f0a6e89006f980d95b3a40e5e5724d7a2e7e18ae782e62464f1ae203d0c159aa17a5002561c7ab2e2b0ba6ddf8cfd58425734313431aa62f59801a8947d131397436f929e7549a100afab910408a4b5fecd5e37abcd6195049601e5a976931f1fea2fe536be4bd0edaa78010364ee9ed78a63120f9ed6cdde91cefaa02af8b769702eb46ea56d3272335640280598c21c3ec60cdcd6c23f47af333578ea8315560b1a7611908e2f055051e13f1dd38df0f15451e1800aeb8665c6deb9138e0aca5d833db4579137800ff1dec446add6939c9cd51f02ba0f855f9f77fb668c7142672a922dd91e9a358a827b806bcdc86ebe8c93c349d24a94913f0e9246832ac701467591e87eb729fe27fef67fb6fb9cd14c9451eb03e558c48fb1c0f76a70c29c3ef9e0c567e0bea3834790c24bd754f1de7915402376dab86950270350f8192c985b14753e63471e5fcc29520d7192f4f9aaa5f39a94518e83f2b09563850fe921c7e180a7b7f8fe38eea8947d7b4b2f11cae43e4b80aa4c6066b56e4ebdd77a97e4436638c50845ba49e62f5942b223aab78a35d918583eac2fa764f2e5f36c06283bd41b0627388e5bcbd51aa24f78c49a138ff0f6f228897dd018559c99e79434a4a808c666c775838b15f86eb434b8eb0b466bc8609f79d7ff264cdc5cf0daddb5e98904eb55a5f44d59c99c618cdc7eb2e0f3e60c49b5c78b552358b263aa97c39f09f5c902917d31398187063efa1fd671af681034bfdbb768898ac383dc09e8e8912b46e2ae0a618dbe2e2b9df3881cd25d10422feeb363aa5459ace1faaf98657bc18d388f7da279c79e71187c50d9b58a678459846d3544f0f455a4defee56d88d43f71e3e7fdbd71f0f1459818fe2ccb8f28d92dec88089964b08b0199529dd72323a6d9d685eeb94b184885c673ddce9b28c42acfe2fcb3f22453eb40fdbd155a6ff6161bbe7c90465be00350af472c2a5cbf8640caf20154520f208e82626467d29b2aa036263b89b93089e014b2891e6fd993b376aa3178ef333b22581fe35c79f55b1c72821b309613807040a694ce9b17699afa42953a421af252c587747bda740bb55e0932d775485395e36e61a01104b5272fdefdff03a98c49a2ba85ebcc08aff037fa804be3df532e354105332b393d6863acced2b7a6f750220dc31767038640ca899a6ffa28fa9a237b3ea0f091144edfe9e57a8d921fee60403c10528279b0a28cf0d1949b3f5bc6d58d70719d287a274b9a8848ef4d28b189212490185a10f9acf8c85d3eb9f3316d4ba91b13468f82c727d1f5273af84f545508174ed95c90f0159059e02fc3b1c071765083e500fc48d82f894911f039213b94a0d3c1d5c0a6178c72555d889fffd42d24b80ef95158ce74a5c803fdaa0f63dc9616282e7934dea75d18fa38ab4d4fe119d8f7c9cad47365e44ce01ec41ce3ad00ead56d5f916de9eefcd62c7d0ee3269dd6bf13f7f845aa81b331455b6e3827ff02e6267f3676461901ac95886810c85e070b8c626fd062afbfc480e34168fdef8150b72b88bf70117336d466516610dd760085716656f142179f5e16fcb7155c2d15967315a848f378eaa05309b2f0fbf1543ddca26f016340e8c48d5e2ec6e12abc08229b28bf4a61e7c3b22d7dc7297a4a45acfda98ddb70d647d8d0324e59faa1e824538d0f7a5d267d8af0059433d1cf4a6c047120173c3af366840cc548bdf8746a48db073d2732ed5a3174fe7adc87e7bacc765596df4c0e46ceb46fcfd2ee5c2552e8be1916f2d2444f76591ec9c7f8bcbb0a04ea53183ebeb972945da6cd25654a5f63998f4b7a83cdc2aa57c5f780666d7467e135d9df9d6423750f52a4e578ef74374cbf47d9032575f32c6eaf43dc3fd869b094c7cd02b1c5ee0dadc13da827af01f364d20daacedba49af3e6dffba0d5e4a5f4f04d2843db5b8eb98d71c3833ce3a3fbee3f39395aca64aa4a5cf959dd7bff418ec2887ed46e6599262cffcdb8d4253c27ba24e403eb1d667290c19f9f28f5a4c8b6ed00e81df0a6c979c014a580f48d344f16d03f6f8aa092d8e9dacfee01486e771a8766fc646362acb765703b2211d6802e63ebb02c47413f016c3aa92afebf069f374d27ec187262c4ad61eeda4d280c7d55aadddca6d4ad04ca757b79be25684e8463e0055f535e185df6c1a14de202f992fa977a7823b143c0003dd74e33431db0bf8329bafa4b8cb6ae05cb36daa7c1726cd45cf562a161cc6fc03a3a4130238b3d58ea24e1ad41221c12183440979b33f23548b5882191c3a93a3d3329d2dca95fe969091fb8e86093ed0abcafe502aac2706c79f2748a3b303d2d11cbe3e28d0c3011b343bb5a6d25265eca9a55fe7111aa30f29de3f5cff953625ae812b041252d46c589307a5e5904b162a4d987e9b4366944750a334c07bb125826edb685da169618ab6efbe7b6e9fa1c9a7f903d2b12339d25409f3b64da552b6f03fec99776992692453182444410bfb3f688cb50020f000ab5048b83c058d18c59911c27ac834df6b9a40e999ab2576bdf284587d11b929a0bb63043e45b6d870894cee05b9c66ed746fc1b90c7c7566e78359c81894e597054f9282030fb86a5019504906929c72cb1e97f8e5c2920dc66a617a150d85a5fa3f795fc599fec4e49f4fe00c44ad45a8bd0beeabfb079dfac036a057c58250078d37ba672c68fd79019f3b7ff5a6aee6dbbb1adc81251d54387aca5b5e68842e1e2047751b52a5135aadb8c371b6df9d68afceccccf80bfb9967c205885bb33d9d76bfa1a57c741bb3958cdfab3c9700def7290810448c6e0bc977d47eb94a563ac29cce84d4c8c2e05c5f68dcac5cb972251a376cd06850923ebd35d29892e72e3b841cf3f67a05fe8c5a1a5ab2dc54c88f05b14f2767b1b01f139c7d3f025af64e176ed677df2148e5b11083abae88f67203e95d2854ea3d653027744b5571fc6ab614d0023b79245b0ca1f8e186344186c317d5bfa18f87d9bb0762ec336d0901c8b1a971840cecb2a7075cbe11462ede57d150e073489fa05db06f640fdaaee438feaf463d1499c76902c5a2cf007bb459824162f26562c6cb1b89ac4d5840c8e6c5a1a1c228dd0fd5dee84a8ce02b30e5af69bad21dac9d3bee3a35d4c220283c742b9db99038ea1b1ed6dd7aceaf70bd18a1506ab99bcba77eddb243644ce96c494905d490413530385fee9c3c4cd91782773a66cab66c47b2848daa7fac4fcf28512b9bec23caa09427f49a5daaeb65d93c6a3ea810f920c2279559b735a56e75fb4e9624a06da197640ebb482f0b3a2ffabf746700fa864db468ad727c657a5420e95edf8feb3ac9fd791293ec7fdcadd7ebea2c9a7aedde6e189f6e6f48ef2daa42deb4ec045d42ace1e8d59b79294afa7807e49d4dfb0a9414ed73976aaf82146e734810ff0f03d11dd22f69816daff5bc37772df460587fee5eaa73020a7f6ff750086a0355ff3fca21160a6c619c7c3732760ee4b468ca76f841c01763f731bbcb07b900a86bad71409d67b17c7b3ce3106fad3969d108920b83e05c4dec293242ab7f36b180da92fb9732a3a85465593ea85b29d915dd25105e12858d2ad1d3f2515262f12d3aed5ab2a6dd6c5c7eef2519039f16fb4927643cbf2f463b0115221fcf4e951bce50782a5eba4f7b680eb61de0ec07428e0478b0fa19227c10f35734fc885187ac28ddcbe2d38fb508c2a5b023615d32f8d4aba6d2a1d428133eb3c275228b5318d56565273661d6abcab4488c6a7fe8aefde4c7eda4850e3836142f5daee2fab8eb6cc584bc41731db5470017948963bd3d7a08dd304c2545b159db0089315048e70ee407b5073e025e248ce53efc32e0c246e2cec498d36726253cd8fe89e3cabf08f43bd871e483fac633d72c13c03391f35541b6c9f5dc50fb5b8a3a67047fae8237f50a27abc321ee5792917ce7a9c909374ace4c5a186de60d3afada88a36fdfcdf7bc6925502e380f1d98fb1311a81878b44e4f970d16df747ddb83d1d7012b06ee5014315b3878a05b165436e81730c25dc5137f8f4e9e615409b3f385816364eea82ca319d0049c3b26226522aaa685e58d55ab530f136b859c4bd99d6a3d8b4bf590219fe72d3dc7b85cf3ad2d13a258574413b04fc77e336548fbda1d128caacb8c9eb1c2fa99e51ae79ca79cffc2b44c7be51fc8d7f3db3b9a2e3b1d630bf0a1b06dd75e6d13a57a85f17cd35bdad32592459496c16245f480a383257db608295e9db94ebe2c9031f68eb5b2ea36d907717030221b62b12ef6163163e8f13d1be3f798a61fc212ec489f6092c7180028128eeddeee3a7eb087fead26457fab65197d4e1feb794171bb1b8d0a376ae911e3491242809d356358dafd73ba96ba92102791a92f43f6071547d67b9e227c10f6e24836b67e283667d790639c8f97536c79cd705ab4379d8ff45bf4421d140262ba6496cc88577e630db61c5dc6ec90d6299d08379dc474eb12c10ed0d6ff28fbb257c0dd9e6e70fc9e8a9abda7e1848f381b51d6eaa4fac5113b99f06c86be29837204fdbde185c96980be1eafd032edc368af81c069b65db4cc6cc8d60b729db095ae9bae288ee28bd276bcaffc292e8cc68c99393badfb9a39103f73e6279cc80122b7f0f841839f4a517729f10570d1e8ffa4604ace2fbd85ccab507c48bf63665202dc13b208185f25027c5753e39e9d1e50947ff81bc5f466d34fecb536f6640486a6a627c78251fd2603befb30a61eaa88a269ae5f025ac6230452250e979f44343af2ef0bd40a1bed11dfd510929d1e6bc5d64329ecfea5ea5fdb4fd37b14df30acf2e99473e208a89f35d21e98784520bb2c93b0fb59ff95c4cf29e274e33f72d60133df28fbacf72ea921c3927f088c114045af32742c834a77e31696d6ab68a87787ad200fa7b5df269c66a9cc9c052d37118f8504c507a587819f1fd3736661423fd89498a9383eca247491b0e01d2b8378f2380cceb82f1a5a1eb02cf4fb0fa23edaef8a4db5b89e0fd9315aee97a03624f62c70be03c4baec846dab7cddd0a7c785b6ae42dee6a93bb4558ca0545b0d5dac146c05df1fb72cdff831ba4da1394a4ece7ab81c37e00ee556f0ab8d9cd6776baf6cc2c2e2835cf0d81ce0704ca0e5d59c496ec4b3e4999afadb559704cb3eda992c51406089e058d646d9fa7448ccd7176bf7bcd47332fbabda31668362900f9787882fbf5b170347e74dedda0053bed77ca1fd9916533611f64b15728008cb9308501503bb8211350b2b4134a301aec3e460f55915c160f41afc6da789f542d2cd7cd42733647703398b5fcec5d33977b824f81e2da561e7a09ccd46ab461944876dc42b69e8b2df19fac81b44e54a07100f72a63922f75f8a8347fb951b3771d9a8d6634bce844421e4fce4b3bb9a5527a643f07521fd2ba0811e290306c5c29a547d9d5f491d8dd451f2e42333d67f83069f516ffcb3c2e4be229ff496a83104f2d9f7dd9f53ba743aa5872b277484a4b6842e5591250c981b1d6cbba6b562853236a35408b228d2ea94a3cf4d49c628a3aa29242af9cbe67cd7fd9a1614cd9222a00da052fed6c21e4032c451579be432f2f125a687dc58d4af8c4b76cd7832492b68b68f0e22329c017e904821c047d05c9d3b41269e446e1130458f9f174c90eed4c2cc1e02ab8262c56bbf56b45854b663147b136c2720647ff3c1ad3c5639a82efaa0630bc565be4eacdbc3ea05e68ad62cc501503f73f26cfc080f33bcbab60c5749a6e584ec3531a1e420cc468ac0a782f604e0f7b68b7331e55c2a79576304bf9fda0f1ab76faab0c1b9eca154a6651fa5f114f647c3b86c754d6937c3ab7753825bf0d4fdc6d14471c60c090ea08b5378592728dee9366ca9cabe832c2f771045996c0cb45439fc2e05d20990f4fc19280f2d06337e2e127399571676d2e592d122a4b1e63bb3b1764935b2b7b347257c4cd804b5f5a9bb4b81872897b4c42882ad1986d2789a9a3890e1263aa75a1898efad630f17dd110cec064cd57d0b02f97e25c35d70f49b2f679dc967b377450fe5850919cd96b6b1453a915005d86801d9c4d84792e6f65b661d09701cdee0310024b3785ab2e24a02aa8472e2ac352bfdf0b929a511421b70665d4838a57752e4c341084a83934c1d5286ff9632565672aebe2ff6eb649cbc8eb7139cc06d07de4e9fc72c75e81e21c3761e596342a6825e5114bcb90215c017d1adfb8fd7ca4b05ae3114cefbd7fd71c387fd0d3406abc9705cc6297f6c462614d26f1b9d2cc89ec879ac282f1de3e4fe82a7a1f783100f322c381c12da62f13ae5515404b9b87226d140d931879077a58ca6885a3c23e148fa22a275c61251d7152fca7e447932937517bc07ae527519789e15d7c2742204d2c26ecc7df644a27f2dad70d367cde54cd0817c97e1ad3d01b5233f947eff1e60f32bed81c7a0836af40daee1ecd012faf2159c794ed3be9cfc85e76dafb50907c303096ee774a6a3309ee3d0661ec0ea603f0ea73efb9dc96fcb4c304933d83112a917f8e7e54abe91bda11f89a143c936eb480cd1f5656bd0c91a00920819a600793a31567548a67c1ec80b7fb0b0f0bd76a632188a2fbe72d64597e02bd7b167d14f751f379b38eb51d0b147b1544a986bf1e8abebe66833e4469f7cf7fa00c05cf82bf4e62ad86ac0380b67dcdd2fb0d2788d23c77fdb8c5cd95861e84c937619e5adb271c63da5473be45ba6b6351203d9cd8eb05e743f89c80d741108288ed6bfa35249651d0a1c49da00b6af08f17cb5d2eff0ceaf460e24aa10cf4cdaab197c47924a0d2266b53fb2cb7091bcf161fa7090e3af188e557d4f75a8ad34eaa24508554e3cac1ae98b0577e71b0d535d5dc05e454c8cd531dd7faa1d6a8215c8f974c6c812288706e6ce3c1c44e674173bbc115a30afed277c74ef2d7d7711eb3899142f03448b7c710dd510210a5b3f0983b459ccffeee783c3758b779603cd437dd345bcdc0a0b17c09228a18a940be9cce68da1c745f9aa5250ad2032fc6b3f80b47075ad8db536f3addfffdf0d15d2d90184f8d673dcb933412d2d955becbcdaf5525a9e81a390882685f8ac904812653430859629bd609dc63f8350bc763b377ad6ca625e1dff0b9750caf4902947edcbfcb9e1fdb2691cec4a6a39ac58b56aa51653416dc463a705ad40504f9d4b56ee155528bbaad070b9a57a0ddc95bc93cec258479820fbe60ec2fea38fe5404a7288c1e65f6ed34da2dea07f30afc8d48d14ae18e69f1b5b94dc323f38a2f6e6e82be999da0b652ee8d6696d49e94817bd357bc4b23657fdd12a4c7d0734e77b11759f58181ab6e3dcf5105b2d3b5de9a607f39037c05ce1b753e15da8ee5070b443eb7654294e932cd9cb9e4ed4ebf0ab5c7ee0e904164dec00a0a2c2e5c06d94bfcfeaea60682c8da96e5e1391aaf6105b796657fb8b74e709826e8fbb2d01d78f370929ba282b3fde0269be8d0c0d0740904288e65b2d96eb157642fb36a30a13ee5d5e8624f17054f2266ab2e96084d7230f5223669f6bc182857489dc2afd4144504217c1607fd1b0ae43c1eab04a98959103d45cf5283503caf7b3279db6ac30a6bf86797df46892ac4386ea78c08f59ce9e0caef83e592c5f123d6b2d0a865d011ac4051768db07b2ab767fe9af1cd602f50fcaf295251804619814003d7f3c90c99aab4773c578d3b5704d0ee94af30966e6171537ee117a80901b0c3a440fe287f03784106553f93b70ae92458cf53343030bfd95c87ab0483ee44aa7af7e1b0ca7de6eaf98b670990993440d6db9b7998ed11982d779a98c9387feb545db8e2568ae93287dd352c5fb14e245ea10947cb5b59fded96a5a0021993118563c53b0663db1a36b536d92b19fef64ae6a8306f96b33c01fae19fabf3853baece5da6cc7e9b020ab1ff501cb6aae3a68597fa73758b70014b3ba95fbde69a522aa0a6f747a76b88d75c66418a05e419830cdf8c9d83ccc4016a6e67805c769367ea3f1c1a140d4e9e69bf4fe71bd0c02b93def1611fc620efadfdb9ccfc3144809dee35aca3b4c22da63423d08f5a66964feb4b88c1e32d955b8063236aff198cdf2a3345415737f2f635a97858754d05019a2ca62b369c9397d759f5e0adcc9ae3a5bbf466121d8b37bfce9e8a4bebb2c656bdf479dc7bc7fc3dbc4d790f9a8842acef2e14bc2398716689ca943cf3695b709f05a00e81066ce076aaedd999b49d13e7e81e7ee801c5ac23278e25a771a4ff94f08cf2a05c4cef63fc47a6c1fc32e70855fc9e73c63831a2fe191fbaf0fb6f14e5acea6f88ee79f6458a5fadc262e9f0d86f241584f0eaa9dd4a39c8fbdc07e1adbd706fe120f89b611736194bd9d5ac446af2ad3e53af0221f1e32692bc2470c9e2a0f6e9debd0e73b4a5003da4dbd7ecf00127fdf3da264c798b08c363e966d3def12c9be50efaa19efb484110d51776126ef59bb368b4f3bdd555342ea05b47ffdceafe6536fcab5c2e76d17e726c04e5351f895ea65cbdb1430109c6f3acb0740b218461ecaedb668906e067f66d657f66b795fbcf8010acc58fa184ad1ef2504995fc472cce85da9741b5dabd77826d2d254ff15fe3cf4f5cc898e089c719668fed695235586be0d262e6cccf553b0f249d26f4be8e9834e1f2a3999bb37c788c337c450dac163ffa1334172217bcd26cb8c7eb21bb95f75725b8de5849e89bacf1f32358b405d3cf93012309f6350c46ed9ab9e1651154aaa6bab109c6b60b204a2a10be22a1dba47b1e9bcffa4fcd4f5f0a0c7ccef12de8a2bbaf82477b5f31ca9d9f30291d29942cc992f3b947e02ad6d023eec126c259ef05fd640acc0f2bfa6de8dec6b79cd96b27b8abd507b9466036e6eea60f40adec5035922baade3314f68c3d2d3adcd31b506ed71c3b7276a40e5ee0a65ddba410d9fe52b4a169ffc40303ce57a2293afaa9174764d0b836d55a647f5a26aee45714a5977aa8e8a22c68898ea89076873e7d5e368a1ce1569a377f83c7ac4a7de609e9fd9abd530093b49367580210947565dcae1096b5a4eba4b2f4c7eff129b9c4f940e5b56d41b788ea2c3adffc27860bdc67b76d9c3e8be5ee95f57c55ff483f9f76d16be343550d46fd0d7f53ff79923b3c7fbe29b992dcff12270807b25ed1965227397fd2677913d98db65913d485b8ba551686031f4abf48290b0951d4e1f835c9e5fed9790e691390c80501f4ecf3631b5e2f65a2c1e2ad06e3165be23b94bf66901d4a190f5f18f238ee6161e7e76755647a2cee896a8262bbe6700c543a2c626d2b24b48ea7d860170c8d2d5af19147de2303698788d8c183428cd3c9da72bed37560bf51ea7a9af7f121636c3a3ebd39091025d32a241beed8434a98e20c6634dd335355e1e890d7e6dfaf82a7f8f0dad6533f79811f2e25e0a4bf0934d48681897d05d87d54ca1ae104855a77aa879595d7745c9094f52eb82231ec62b42efdc06014fae07c02110c83a636964b6ca7bbf8610526c33a4ad7fb0da53e5e7b5be8365e1b5aaf28bf67db348d804e86fdf38b221b41adb942749aef37f31f0ce7dfe0be2edf1a7ebdab069e2533bd828f2081a185b55157d68e000d1786796617e4cdc22c2eb220221887e986b4e08c95f6ebee897039efcdc0b244c51b565ce24e1d09d5b82ae4641884eb11d3c5b7c38529a1337f4ba2b636b7d63b02efd05fc2235c404105bab74f0ffbdea5e489146c52c8a74b1ae6ef8320e5a512f1e9b49734236c7b46b58a57fd75cccad5b672f52a0abe8502b5c8dcdbced61cc52f8959839271e0058bae906a3ddbfc8d40eb18e994f6dbbda306c9ce10932a19f8b118793178fd859b02676b937bd57178e96305eccf1ad604c2187305f83abbe6dea0ac0774789f5b02f6b4ac13fb5919b682fe9533d1e2bb3a11be9447776823c7582b311c0ef1d5e76a54ad8f6126e8e65fb5cb1205a90f9929f6949fc6fa0507bc5370fbb2bd4082a4abb72e7d3feeec5f067827151f62854344f63e894f5760456d42dfad2ddcf4075183b90163fbdce09a583c9cff434d5754512f478cf8d7a3585b456c93643e5a562e8f8c04f864790c24bdf1dfae654c6b79571c02b789611869f7fdf52017d946e35979e676a88d1b5d8bb49711f7cd27c2505e3a759719ae37ffe5015ae67978ccab232008bb0d2c3ea314605916f5bac5916e031bdee22844d564437eeae3276896e9abdcd13d9a566d33b0c018b6162fa7f400461398a8816b8d1eaa2fe94b2f05ea2da33041af0cef71003579119c4bded1db2c8be8c77947bce5ed64783762ab1bc8b714e16591b2a9e9193eaa806ec0b1e04d0e323cacf7a4e19e8c626a5188b25661507d480ec7056ef79269bccbf3e2acebb783c53ad5aa86abc27b65cef61420e38d7d88d59d85f884c47eb9ff85fda135c2885f1a02215c885c8b1ca75c3cb6dc3fcda864f3d4d353c3dc2e5aa7b5469ac0e1e5fda2f7ebe09eac87d1ed08cebf9cc2129d3d42d379390a24855af74da63","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
