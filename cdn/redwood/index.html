<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"219f040a4926b7bd13853205c4fd3336c5b1845d5a74ee8548280b1403f27509bb08fae57eeba6d6d9115053504005f66cb5afe5ffa0a16c737f53cd4b6f3f309ec4ad4d0ba67cb29eb61a817e3763565051e74c8738099aecc0554ea1d66168182895adc8438914dca3a650af268c0caaeaf29f6c964092bf7fc25b209fadb1263ab9a37f856500f66436dc0ab8ca84170cbe598cfe50f26f7905cc686ae744585cdda9f9c74520f03bcb3f2ff822c99221b5efa85ca01c78034cd16ead910a180b9e8d06e70523bd37ed2db07dce20eaad9fa9f531eeccec41ee3b6ceb77a759052b9fb2ad5e483210677dda448f08f37b87a5278a7067dd5b906491fce0941351238cd34f67ba70d9c34b4e96b2f3ad7f1cd0f1c08b79dbaf250866da8f90f428a34f106a9818dc2f020760299b2ef81804b7d7cdd4e0c0dc22ba85eea1c43d6e2daab648281b580648175efe7a282f2c165667b365d94ca730c766964d20e440b1ed4bccee612d6c9c3993591d2f347a1094caceff86e1c16931fa404b75f5bf20786194bc59411577014cb4d1ebecc9f767eb144dcce6a74402f82dd223f55c385f5cca010375f68917896e93f3cc50264db7eccf270079a53ed008723acecefd4845c371cd5a8cc174bd42db365159f7e57646f14c62baaaa266527bd3d67ff3ec965202f82e56ea22802c32c8ffac22d45db552f439539e9445bf71e354ac1eff6330139b10cde3d1c01d52446dfe50aaaec965f5e077c48406c3c405b6c1c0b4e107e84c04ef60967b8c2eff6f96a928c11b25a5607d1beabd752ca6d399f9ea55dd204958995574de62be118ef21976280460b8b7acdffb0c0fdae535726465f5e58afadec10307009ee8296cb2fc44dbb477b21b5558fd62b9faf1e3a04c6c535aa5f40c7d2c1050036cbf6b34ba42fbede3d04409dbd1bff33c2ca2a23f8b03c5701ed6a4f80ac2fed939143a93f850cf8b473cc1aa327ceb0d7d04ac10ac36a5d2833183997311a2634c0536ebac14b66abae9b4b8a6e4208799354abde3deece71964d080e0473ad59ddfc00538c35ce962fd9c39d5ee4bd16c1900ee70e68d192081a8646abf4abe68ec700aadffd025bd9191b7b50a3855068680b252d3d71c27598c6bb81c667c51b7decca22691e8d8dc0f2f0e09f191ca3a71fef8aba06626c42d3d0b11251354a62d335c555f8c1f2077d527deeefaba4a9a5f6061baae95f93a5243ddd76314e04ce8117c41b0659857246d5a02df65cbf7de8a783c60825ce2bdfb7c01823b63313a17fa939dc7161245b4275cf0fd3301f029054b235460457da7a39944541e70656f421425f2679344f76ad304e5d566167e249e52fd1934bcd2acc2eb887f6c6ba350d8b4f04feb808994482e390d2a81fe1e59957b045dc99d8be5f14f8c158b260edf2a72bf559b0098c8b6a79f7d423a5c8336fd21871985382cb710bb03eeaf5839fe45397c12e432628cf09b2f1ec4601cd06a08d8f351aebb73820d5724c6c16f1b626e04b4bc8a2a11df95e86b6752833f897320cfea4e911be06f20115d51fc13f72f9733aca8d839ed2c0248a239b90de18b3a1fd2323ec1b22ddf71329f80803bcb363ee643130cb02de8e6f954dd5e5424d1937a72a60446940182657f8ae1b216c8b7c58015584fd610f6b0525d50209857985a8d318db6bd68d35c3b14d04ab0c6a507c14a506a14e807518af8082270c36aee9c778138ad825907adf4b195eb2c1d60e90519f0704770e6dcef4b66d97735e77c01dc698e564d3716e9cd5151366f3ace3d341cfe7fea44fc2c3bd89b10d0fd9fbab7eca976a47058f1e8bba956bbb101cedd1c1f7e3d657f5e1660917aa0f9150dc4972b830c50b40e2ebed0468930002a842af8e50a668a61f2af54c6ad4f6d7f01ae11153f9efbbc43fb057d927952f381e80976d88c23fe11bde987399f7b8624a3463b5fe21d25cc6c080b8feefd742eae85b2789b6f4a5e9461d1b95a8445876f49915b91a536f40a99dd0a7d2fa4929df669035d7398dce999e4b03cada73d5e8bffcf4beb723c5277a9fcff8a55d3ff3cc5f8e0c344cbf14d07a8670964a49ed00570e46b9f459a355178882119d944e4eaebeea12baeb1b848e0476130c026d39528f97b130da88642f70fed91cb3d38df0dacc6e744f60508d60e46786fcc699d1e03cbaee5410d637f7cd403a4c7e9fa20bf50f560a0507bb3a577ffb0cb0c8ef89a5c03407398b018f6dea46141c0eb5dc8e51d26d5c876b05e719e0a1ea1d8110abfc267cdefc90ef2d46343fdedb5d4ef19ffb2e3dc4e0c49f8e570ccbc1cac63d1052a6c8490f133f4f1da346c5b60be5fa0c792298e15373d74835ac3a35edb62508730a7d2bb90c649984a33a9397af62a529f5e087eb00a7db858317052c63f0dacd661b8f843f02c51316b425fb2aa325a59af81ea40583a0cc9ea25159fa6fc495560ff290a845d55303373ba9b4b10a6b9118d98025eb15bb05426bfd57199c365d199a95b4e2d98bab83416fd202bd2ca09b671e389f340ce20f4d0e34f583cf696387fa11f9b9df6ece195348f9b78257c94ec901222106301988841414c18b1ac15028f6df0ff15404850d6769b7d262b89a87baa31fc91628c0b729e82b7bdb7ec6ed03e2a59ee8d3fd890d24207f99222ed666193cb04cfd2689493d183c409b5708e86774d087ccf17ebe7affff72f13dbf42831db83b0d307f2c10f19ea1156e6b5b3e43a8520b10ef19f901ed14a7f08e0c23c1c31a5f85e70baea074e5fb52050310687cc5e26e026cc30737b04d71e2065beb72ac9c313f8c97fbe2c807b72e3aa65219a46b06eb8d9d3e4271f55ba0592e3d243097a696feb70bc28b5b9bc21fc33e69d4c82e1eac14881b153613f64b6c29933edfdd99fa720be5779ea327478d6919ac88dc4774125b93198be2ac79aa23b69c8d1786df84ff74c6b9468100dd59c687decc7339d39866c58632b402f351292115c372cec79614f76e32c65127fb9245be68cc61742a416bb7bd5e72655f7f643f6a9fe5f888c2d5eb146005072c2468649f647ff5a9c20a2a1589ca27e132268b2fb1610820abae23537a49137b22038c7da68d831fb65ed97a3a09c0289733a52cebb6d7f4f9a0009b9ba7dbc2f7a4909a3451888a4e4221bf61f7bfec804b5692f3f12bc07af66be7bc75fba6eeeb624925ac2717f350be753bdb37cedc0caf4309808ce28b36bf03b5f272a0bcfaa25b5363c79e36b204029e98ef24ed1a78f87b594a3e10acda850293e5a3cd31f27563e91f290a74f2f8bc9a34c879f5b6363489f357c12ce5eb6be8f6ad5481a1e2b31381fab94275c52e8102f26dd7ad4cb80a8e02bbc988d4e92c43bc96e693297ab0061334ddd186612c0050a0c55ba3ff95ed64a51d97bc3c2e01fd048ec6a4510cbf2cea4a5fd76ca3e6dd99166053232a508a098dfc66e85a10e8bc2fab16e6a2f091d624ee5f66c1fb7e5ac033e03c82ade44d0980f8dcc67818943824316dd3c823ecf4812644371c0d6ec8717aaab570b07787ee29550e5e6b82f003ae16c02cd59f8b0f0f943172fae50adb964a3823eb1fb43f3d7f3690fd1198b6c8d596b2f5e4658158e8dc1a7f0c6438352e1b4f140902177fb8074f6ebf67b207500cab4756695a0f691f9b2e937aed379b950668fdd759c01a3911b7a3496ef8b731da663e84d9eb33c24a1e2f007682f133b2be0d8b12facee07e69bae9edaa39a2c38ef14f0a4ff7cc90d42c1482f23052a8dbec0ebe53b2a1e13e0019a59f46b9f5c4bb6ec6c2f54632641aeebe55b95bd6ed843f589a8fd66c955503ab4cf7d6f5cfad64e893dd0ac9307289b09223fd2de64f09fb052a4b878f9d335e9d3088adbfc6a7d4a8e94d090d53ac7b2ac9557218cf77bd6c8a4569886e1ea5584bdca36538bab331541e89f685039068a89b21a67752c4f04c6cc759bc0d6de304fe0a827b4d0feba2e79af7fab80a969065421e855888596176200e0b9eefe1a3f329e20fdfae9346332fc623f16aa13dcffab25dbaee1536f7276b686611a1c837189fb671dd89015c290b60df3632de7170b53c7cbacf5d83b708e8827181ed08dce87d7b67b335db23e0291b66252f824ea5089602d5dbef23299298918972fc2c5f975cb13cc0edcbd1320437c0e8958f395e162bd65d4ae7d318720dae60962ed35b4ef2b3146e28fb9ced0b80cf4e4ef9522a6e37a7430aad5e2758f7a9b8bfa88fe7949db5288ef3d649eccc1d8c29ed92b7f4837141b74a55019c00e5de524415c4bcd3d598b97d31737cb6b7b10cff68b2d08fcf6f1dc7f203e6b2ef445a05ee280e736e3847f991a43ca3e529396256a38e4c50761f4b158abea860cb3536ebf72391d7dd52a77be9567742b644fdc842f60464f20900415c9ff3df1e21de0264ef2d8381a1fae58026d082a34cd15ab4ab1d751abac3fad03db112a49352ffc5fe8f7e4a8ef61cea15e7b56c01954ab543b1bdb5db4f35976fa0aa941eb055562ed8fdf7a7919e27d3c99e8693d26a586d55ca2407a77d31be7f20176e592d81f323e6242baa7655aaeeda755dc9fc06c5e31364aa2d621cb4629d65e093581c1c46e5ae22a11dec7e8c17e42dd4b5f828063c8deadb03e20f8dcc28de5b74ad70b7a4b492f6a00f6556a93e887a0acf5d87e309115f12ea7e17bf67d679e06bcc46eb336136ab9a2dc05ca5560d3029cae385a474f75c8c61e22bf1748473351e45e237beda0367e304c065a82718232a89757262889474e4bb560ad2fe77c3968e61390c9a83016e37cb32de76ca7ce3fd22ff06f877cf0c651e514214a87de798276958a8a6e0d776d582e6f64bf7ba563eec2e286d3554d790d44127de27e70048fc478aff61eea408f178e2eedd0d481a73bb62977c611e4b9adcefa0d5439ec7307b4b78bf4aefbeeb59e5fbea03a4104844bc24d973f847d6c2d819930213526c3202ea0075b1633db98d08a8854b73013af2f5a73a1ece0969488c660547c59ea640dee67d9d48ab4abaa4373a98bb1cfd00b6d728ec0b871726c9918e0d23b3e4730eb9e10fc35393e7905adfaa1adcaeb82886c5bcd09f15b190ddb4d9183e53325d85215ba95366e49f2fa49fcd8726c44af2ecfb548e3835ad42ac8e30501c4089d11bacc18d4b7f315dbe08c4b122b674f371baafc9003d4d6979f75cdb998c307a4a57c6599a623abed424e7c39a9530da075b56c5b6eac07b8d8783b4b9f8480124e629c4ae7e525af3cd3146e3f749a9774661a81b030bb36aa2f673c97a585a0c0b4d46e6746238b054d9ef7451054c094b21383181b5093367024cf69d0fee745affef4e04a304745b1542986231c8c0de0f58aaa637db290c2fb7d811959813aff0df7fd3407e1a6e0fbc21c15692ff805c0dffc6103445a3b4f4f8659a1708b4f1ab42fa161a13ec4c3ad15d52b10089e14b5534ae5506c496069528340f594b8f56cfbab62729ce465725c48fecfc008493c8fd031d6fca78bb77536016e047fb6ef78fb63ae92d36bc1bb979fde8452d51ae1023f82bdb36efdc3f18f91f6bcd1b91c9c7192d55c4202592e7c02d0d7ccebc23e37108e46ab96830ba7ed3af416bf5d07e1b0f33be2a79784cb3847dbaefa9a6ccafbb93fa930a7f40355ac7acbc3c92c8f7d5a13eea96b9a67dab66984d666632ed2de7c969c9ae0c023463981ebb5fd942b10f11a5cdfd0704d1e14faed58b9fc4b9a602f4f5325970c6f4258051fcb0e7d7ba52a2f2c0f5f0c3ed45b9fe442c28398ee97ca039e331112bcf5448b54ae4d78fb0e94e1a4253f1ae571430ac0f2c57394ab9255097c0b6733620c79a2ee41a2710185b7f652a74d74d8d3e4dcb893d45f09e983c314a7c5d85691078b7e26f8b1c6e810a135c8652bea0bf723c2a033730fedeaa8cb7085dae23d3077376fb42b93307363b5c657f464764ab00bf7cd7e4a665b31bef0b4f50f07567ab5177aa26d8d164908ece10f0e5f49165aa0849a277a5beb781d95476736ba50462a6d7b8a30755ae5b0d415778b25c5e18b33db99e36856a0156b605bf040eddb24cf6ff4d636c67f074b1c69c051ad9f56da04b412031d65e048b72317e6222b5252734efc2881c824b59d9f7d1e5be7a97ce94dc08bf8f54c82f9b6d2d5ab9d5f64b411d224cc8684b7638c81c4b3d6e05c31706ae8d0ce924922ce111bbe9f9f79adb60f0031cd4200c4dc7120356df87ee6f16040d3b36e2da0c393e53d963182e300697bb82c17ec2fe99762bba7177c2ebb437a7086fd2b5420ef939fc06fe6613adc562ea9db9ce72926333452cb9768538c9e5046ecabb94080f69f79946990184f4448a37091df92d6e886caf52050cd52b9d54bbfd3b83db50941da7f1db039a97f87c70ff8e92c15aef75abf6e24e9708230e954eb33523a660904482db08f7f63a1a0ba7249bb4aad4672c22f2385ad061499b4fdb8d38395dd296f8108dfec44c11b40070aff14f1dde499cef70b5012916f6404f3c8394a3db0eb56fc643faf5298dcead5126adf4cd88d2150b477ba57c53bd48daf2528046c13b1b7e4693aaaca763a9fec42ea8c1dfd7af7e628b07f3f3d83bb21b0fc8791ead22abc3dff6e607732887b29db8ed5b9c3a3736b97c71b91b9cc92c0b7e4f8c2abbbbf2b8496371abb76e4df480f47c90bb6c2c3052514952e653ad624ddd8aed12b3ae2d46e9f7d0399a89518a6b3302734d266ee76869c9c045ad1b0019531199c70301fdebaa03b2d0ecb7e463a06ef95ffc998c090e5e33ebc216ad8841f5a0ea8284f7e4ceaa4e725387eb5faec55076437a12cdb1fe0f26a41220d29d2b25386ca215930280bd8baef83b20ebed175db3543f1e29de16ac436bf0e3a59b9ab98d8fed69dd03cacdf0c3436b0a3745f9ec358dd83827924b630f80c8b20f561a7d52de1811464f6f930af15998662478aa2cb61193d83872c4321ec7ac26879681154b72e3296d13f5e5cfe5811a0439f4a682ff87913db9b3881286ce308d44bdd8b06370a7cef27c4a5f8126eef5c200599856218b9c71b850183fcd7879e588a167f920cd42cc990e5e21a267da22142ae64470e693f739b1b8e1e1067349be1a0570333b66ab2c1f2a834163a30be7df845c8335e096fa5dddbe80a3d9871707917ef1c45fbd40937218884430b05b001344942e0c2ffd2b9a4102f0dd2c1418a9951e66f36593bcc10da3296c2966430bdb3b8aa224974e44a61d05a8b0e3c4ee80a991425edc229d5f43db49d4582fda886e0d4a8793a27235f4a4c42a5b8717035141150d73a753363e5d90959f24c109233e8e494baf44c924b030e3b4b1b16189b68a8716c861e5e19bf8ee103daa2c40be82379ec9b3f58494f2947bbfc432b31c887a283b140fe72ae8029a879c2dfbeca411cb8f5e491f86671e4d182d815506ab983c24359945b8d42bd33620c559c6bd4db66bf58a6df420c26bbe324e13ee465190f5400620cc9e59c2e13c0aedee0238f7064f6d5461a83dd6f51da48e03211d636f3cbc494707bb2725541056f205f2804027f92900c83b0e3bdad2c30410464f21bd0568bdfbce5c4637095d438e4424f9690c06fe16da6b9083255da84f7a5940973b9f7e1c32c6d6d1956ea457bdf500f25979b2e717e2896dc4e1ed161dd70f90e81727f79552056fcfadba482ea0c9872b353b53efcd2d6c2759e0f649acea5d0cdd189eec599b88890c32c53fb3ac005ca9d9c8c63a02f0732ed4d2f0cea12d082c3f2c92228bf6dd2661e347a62322e066005d5470c44739ac65632f3b246bd68ba253de6f54c876ef2f47f1b5f12813d4033133e0f9d85eee62d0aba1457334bdc17ca3f6b41217bfa11c1a20fd9c8b216e87543c1de95a13f25287ee28beb606ba7fc7f8ab8c8599b819188c43110a6946a6a7840c48804a0c0c0e494ee4e2b0f0bd6791b3c150740cdfbd97b9a56ea9cd78fbe91623cefc5064cdc034f8ac0c4d7daf1322189fc85e7f34c0f80e628120f505e306f1c10f58ce4ef353433a67b14ff19ec9ad865497adb7cf09d5942eea938a78984e502865571cf28b66c128cab357a7e7af999f950f6e3ae6ddd92a2d14086683b0f9f8efbb75c288809da5b3bbc35e55edb2554f6e21a384750545c258faf651b10c0bba3068d6b81eac55c3a3fcbfc0d416f95c13816bd28042a5ac7f75b0cc56eb51b36b5d06eb6bd90ae2f47587dbaf1a6326d0175bc6ef849b6a46122fa9c0df46af8247909cc46653c8d072458b59d1f6577a3bc18c99cb245a407e3ffe472e3aa6576c09c6471c527a1906b568630f35b0c7a1d21c4a8d6a7d1c79a2d0fd7f80303e6deb185355d305baa92a8e28ebbb05586b6112fcb5897d4f1732f547690b179be23782731bb01d495b43af5aaf944177bcd3d73541ee4ecdd3dc0e01c91e4592959cd885c5ca7ccfc3308bba11e06dde5daa1ab6aaba1c6501db40ae613cd7ecb28a01a82b15cb11e125df275faed7fc620c6226424a914b86bdd3cff8ac6c7eb49e4bcac3d7775332e13cbfbf6df444676b58f63ce3abb9524d57fc480d4200bde3c6c50ca0f80e90d926d6e894d7eb3926a657d4eb5057e9f5e9c1713edb63655c2b679f10c5ed96cfa27ed81e7521a3d46266f9fa55f209a9103a1edac12a20ef665445610e6fb8eb56e9deb41217b8360fe7088a0789f961a4c4118b72bb7078b1950208fc421f4384c0d5d5f8bf78b32e1331a89ebf8ec4352c8946888a3746e56d786131e5cb02771248479402ebcc81ae47dbfaa51a97481e05e48a0382cb42859f23f3ff2d05a247e0f033d0d602a0732dcdd1ace06592b95797d111ef066da397a848ba77a1defc21434087f928a27ec34cee72d7a417e04bab8e2cab5aa4bb5191ed11c94120cf70d563e790c5490170327dc40eddc26d99d2e98e1d7fb3657618e5ac00cbf2ee1844c91fa0e4656dbd8146915e25b3dd0956f4a3a2810bc320e5a219dadc2ab79defcf57556943e8585a63a1ebb546d98c0153a91f63fd29a279690bbc9eb651bdb40a55544bb14be2f34cad4683e20c5187ba06c28aab2425adade820c51a38426ce490ec0e21f6e425888dd207bf4a2cdbf303235404ad4af7580a7efae068a2bb5255b9369ab5b186578040657478ea153731d12c7b1ddcaa8a70895a99aa5bc48f1f107c79e8d7d661ca3cb8cb7a231d260459ea94c5f0a3053eeecf7b547b04ea32cfcd89278063ea0c5ff93fc1d0823a7f54b508870d6509e910b2a4d0c98c451abdc94dc27bd7f5831c46c7fd04a778bb270ed273148a2f6ee5f867cfecf17bb9ad7368e0cbe6351582ba5ae0d1a0a6cb70be2f2b716b7101915803951344c5de38d407f964d6f5a4017fbb96264ae34a996df908a4b630925a0498b60c61fc74db3f68675acea3f2a7ed1c285af1518ad2d3af6d22bfd5ce6a428337221cc0c53df2aa9a275e565d7fd8f0be4c46252f80ed279e9bf90116eedc9f0f7e527ccce70edb506a3504a0529703d4255935463124e6edd7435f9b29e1608123a8dceba348b18c480acc3826da90ce483680b2389f3f3f701f3c138d34e61e945c3ca5fe9d01477551d4de03bc914d7fb6a1b742f92e4144cd8763b33125075c1a545698129de0adefd63eccd88ff5039f9060b7430ec7e706ebf567c71ab6ef88e6bebcd69d84484035682ae2d721a0336d42b4949a7a958f89340dc654652d885cf8cb39cc1ee20bc5898a306d8416dbb98bea11d76fdce7e01e7cf5ff44710b7304ac0afbcda82566dabe6dc4aafd0e57e444ec7bc164a4d8a1062677da4f13593fc52f5f1817cbb090a166de006408f23e88ecde7a31143f37d1ff41bc87155092b5487b5d6b738fcee365f262e57adfcc8823dc7705df67c9342bd381c740d8e1deb0f8abd57f58f687c0a7baddbe5eca7d09758505f79d65ca36aa7548d64f51e81ee92858b8a866f374d5481f356619d0b56a8c19f6acd355f6d11441889d8d83379ae510bda1dfa062bf817f86641d78863d8aa8a519a8019ec1994f66d75c805968ff58981d41c72b9be93fb6373feb922383f2217393a66607d4f7741a819d505dc79f9a98c7435eb37776bbf11f739a0f47a0ca9d277c894607304f008c86375a3f95ff02efecc68d9913ccfed230b3335203703214c9803edbf208f212aacc005de3b47d3e4b4567cd84695a5e24d2161e73937c6f249dd5cf065cef4498c910c956d1cff5026db8516b79bc151fa58a034c2de06cd3c23c48a29ccc0604a2a94a2f24132aae0038da0978ed2d60b37258b941a69d4e04db23fde25f166f49ce261874210c7f39046fab98acaccdee78415e218e80b1dcbfabeab7f3389f31c425ee1e93785f5003922cb3e3e669705fcbeb3ca34719196cd23e3bca5c2f7a8da6132c0af7eea6ef24bf9654015f3862727f884b4f293672db1d4647f8059013e2d50b3712d2e1262c6fb71f5091f2d7014d0f4c7df56be2ad1bdd63aa43823affa4d59dd5943e86f471ae6d5296d980714f4a04cf7697422022dc23bf210d25e20ebfac035cc87d3477b154c6291ff01646573d7d7ee0cac5dbe006a0dcd8c0dff65ee2d4eca7b560ca49abf651daf44acb1cfbfecd302cd15a47dd44015b61bdf48c1cccc259ff8bd7905540762c57b33f6e590d0ec4b60fc532fa5aaf4b1678109efd2202842584ecfd55029932b86bbb2cfc6db60694fa21ee37fd0db0fe3c4d3d5c4919f63222ad771bcfcccea872a708c22e380109403e3970d4c6d053f2790c0e0ca7f11e02483669cec630e197e1a7dece97467cf752b128d803122148d87873eaa9bbb388ea07c3674ed786cfc484144550232b688260ba4d5e409a745455be54cbb9e5565e783c12c379087111de301fc01e328c6646626200140f3f0b37da303c22da7891ed5576cfea01bf427ce63ca17a9ed25166a29b4e39c576f8f1dda37117df076c8f2b57b38b67218d31acf65b32742f64d36c16f4fde2fff64312b1a7bf863783fdb25a63da06a34d2a5933d1b3757e3dd93e03734913e045e88a1c1f6886554594a2f9b099c6b47c432fcdcff1d198cc960aac0e30ae5a9bf60e875e0ec5dd3a54a43ec3e2f36de477f549b37d1f4088c0d4ce74dc69935cce593ec84a764789d18fabfb478e381f283e4b1e50d384afcd16dfb45f17bb267f1838a2b25c6045460d18b299f50b9f672182634bda9b4910b4f5d32c2fa6cbfe459f55ad727c9b4d1bac137ef396014696fab3549d7ec6188e836475ffb5c85c9c8386a81f86cc882c55ea2da76f1ca09c390eeff91ed3d1c555adca5a857da063c61a90914483d478eeb6673f00852904a742457d5de4792577a97ba67176adee43ba0814fb32467a3855384ef15e986d9b30a77f14624538a8b48301417c0044598e5f7c1ef692850afe25483c5eaf7bdf2d66a898ec206bf198d557f77459e658e887196e80f13a7e8cff9034557ac4cbe5417d69245e94d0ec6a8367d95c5c8d8234702a36f0817bddaa72262fcd273a8022fd2f680eeec155b7e511f878500a67f2cfd709907970ea5969981eec61a914eab1109c3a05c2e86853afacad8008ada3eadfda752a98a70e9b6e3a10c4ca55499cab597a50f92bbcf7d635448c48ee16452cf6ca0954245d51532b61450079ca12d3e2570da957e0a61972ac255b12cb7389146696131262a01aa8e5975c7abfe570ae5d0762a6b7a62196c5ed1498d46442a28d5974335c883627d05a159ea95d4a0ef7890c962a50f72851472b2cfe2dfc12dc7b6b36ed2f55dacb43a8d1ae97f2800813c12b71d8f86a901d573de40c17678d8805634803f17145aef41af8ae07e3b5835a02bcdb131a7d927a2846ccb398e388eb6c7db243a0038dcbf8ed4d15593367577382d3730ec2a3b9ece1a87c67fa32517357da88eb0bc9b3aa3f54d5312bad41482eb2d9196d89854922e3839cf7e8b4cdfdf688ea0c54e370b14d513e8e87a1b1848eaef758d35e70e085c8fbbd6f1b502a2261ab07bf113287e40d02e70d516bafba7ab07e820f862f7d51cb4a65826378e971a7435b616805a1cb8f40649f73778eac3452cbf2176b50e9dd2a816b7e02a41a3897e9867eb29761653077ce5d9c1127f0bb79c73618260485fd05bd0ab7ae31e7654c316218b012f6656530f6d1e4ccf20679e5251c59ee6c2a2425849fe2ee5af650ad19da0d6d98be36a3b125cee01c20425182c543f1c789728ea3f6d52fcfff87020c4c357654c0a54f11cbc0c1f6cdbc76d1df3f1f7bb194edd355df16a8ea0829473a8a999557b89fa07fb2978110f9a502d427e2808e160191d1732d800ba69b86b0f5933e16ccd369c597a131f43176813159848fed4e7c502f065fa6af0d08e5b3255cb7efa9a39474b0b18c9ead05ab451e1c1a4a9145907db9bf479aa74a7318f68843e78a9f4c75983722290f58008e21d832de8af84c30726b8e31ed2e22c5e3a287b1392b4ba65f59aeab507242e78ef01ef2d3c8a2edb4ea2e32d8115173c4e71a569bf3d445cb753ec930dcf5dbbcb1e18fcc8ef17a2513dd3e1e9529af42b67483290fb25241cf80f8be29a947598fd6b033fb576b7fdcf21d176a150d8ac88cd89329e411bac9ab6626896f34fa0c47e7c144aa4d373c84d3abebcc85765ee7673998ef6956e643cd7de8a79187e2ae092638b824c97282511b2e8b8188984fffefa0e1314598909b53534fbc3207a737d3330a36ac861edef4be1ae7147fb9cbe9201b367851257ed8085d11cbe699c5a6dad318bf48ad7795da156280dc4df863c7b7e4bc63db890077b2af59e9afd72d2e62865e562f10226177b31f0be4c14fb02684cbedad042fddc22c9987c39fe6dc28e34a9c7c473f37675ac0f3001fd5048449f694d934de830afee5d41c8ee814d108e366eb0dabbb3b604e0b719f0f0e6d2566354d5e8d44afe3ae002fd5ee385f0e4b11481a9a34cfe0d68612d6a8d8c35aec3525c6d1cf63aac267226cf4993f003c48b91dd32d957f62cdc79e14709c45fd11ced999d83670422d05bfbd700207b2add53d3db1f60f5049183d67e19a8fd3a162ed43c5fb06b3a11373be86eb92694789e57015c13c4361a2c31a53f6555def7d550a9b8f4ec4c972c584f7a1a92773daf43972e35b7b058d876e118f675dc22e0344c431aea976e16c347a39385a4e0be212b6895fa8b14573a66b25ef54b0025ecab519dd7b536be81e3b608d7827b617ac60cc0faf18b7c6c5c41a444a05572cecc9db818e9f319f946dbc883089265ec26e6032440b0847e30e7cac087d6011cfa8380551f7560738d69a236c6fa1fd62563051b9d858e84aeff60b019436e3e527c72b017ed3f428a54d3f188ab5174a30fe99aecada564cb198938e761770d6ac63dd58e9f2ac9b28cecca136b4ca8ef6c010cfdf5fb156eaaad6afca4482c84d517bde262f09130b30f2a4936e76204aca602859274109e97e13e17b50d2fe00e0a84e5743b92afec685d407c80627f06987c996403915ec7a222207e61726d4940b117385fdc69e2775fb8cd855d4de60fcdd23e9bf172d34e64811739080120a02ffcf7bdcd941486ab66c1c1b0097393e0d3cbbdbbc1294164e69d28910f5e8f2d0fe42a9832fa08af9296936c8e0a02cbc2aeecb9f3d25d9ecf4a5fb5b5614297b38bff7479ef26c5039fb560e413074cbc07707a7fcc8fbffe1a6ff7f201ff30bfa5979d1186e181b6e6fcd0ad22339d20f3d48f8f2deab7180f4943aaf2399211ddc16ab0b0ff31372dd6d7c3dbe9e7f123db40ecafb90548a09aa82b3a792d6f30aa1af9189d32f993fb4025040da9d6d432be24256b0034bcc9c772e521ab3180ea950b9ba6eb1eedaa92fad2a3a70e3c0a23a884499caab22907e66d83aec91337d840dda77dcc8b97cfa0158612ee81a5d96317461b29f40c3f6267b41f3967952baf445f0eb9117141a422f468938961103e4405923b07c3afc3face0651d9588ade4df22c44fbfc97c8f47dffcf18ae28a345c98b881d6b8ed8d116fa16615d0458e538467b9a14f09ea8a074d90a40f58d06eaf24aca63c2bfc57ee71a2e3a36909b78af9a3a30615e5085ca69d145970751e546e6d8d8f1cf1c102b6cfaf3533d207757ab78fa49cd02a166e82b50ba77e737d6a52f9529fcaafa5c220184fd055166f7d86c187728723ff9ca81bcb3ffb567a3e58620302a0a788e94bef42cf132db2bb14739e03170a7cda0fc86e7e07cacad1a62fc396db9777246f35eab379dd7f967abe1a892f33a4991380e5c973a53453909ec9af249184fcc99fc329eaf43bf2164489c915438c8c3508ead9bdfff5d3c0763f20b9e53d02c53f0563e665a2c8994055f61773b59432db5816881d842eabb3fed3bc9c038d2b37c7c970283e8f2a929b2fd34fa43bb99fc80150329497729d3ca9b6eea515ad0418d1b52a5382fda5b681a77d01b31983beba2f292e781f28d30d3a06f7eaf070a4cd077faecd17e3b21957c3dfc23959e7694fcd2f41fe3795ad81d8bb3e7b239b858a373f95fffc162ed31ededb1d294473d8791f93b6c9c2c53c8be1db37b5a23f9bb539c0f12bad1420d23b8345f7baf05da3918eb307b855afed2d97840e915afdbabb55faf9cd1e5875bb05f0eb9e292a0c27080ad058242edee7b074886fd15f334d42a2b2a78e6f40cf20378286f45c0c9ceca1fadb96a4c868e2f0e73a07873553b7e1d048954b09fe61804ff87e10b2e815d10e4b51a2383a20e7ab3544f6d9ee2929c4c46f8da94c55e4be32abbae4d68317d04db6c11dccbf5ae50268b0d9c455fb7310700331758302e9ceaa57884fa98ec9d15efd4044dad5ff6a342654c1597e16eff6ce201adeb3a243d0b52d2e46194937fd792b69b7a687e036e760fcfc8d7a66c95e7e5583401c532cbdeab9bd5cf062898de9633d01f7cc24c25ead1802fdedb10a3fdabc6ef4b8f02f9b18ba6a6718e6b35f18cef39f21bbdf3fc6ba014fc1446838a932d9f139d175a08091c63ff06f853fbeabbd7c4b4a9e4ddaff9450747e5fce16c7d465c67181b13932b0c81f9779beb913412c65fbb6395c6cb45b07882f655173bbaaa5f9c8a5f483a4e1651676c43dacb0365587fe2b18246b438c7271a4ec7b994076b3e0ddfa1f66abe9c390929e04c337144f344bec2b7681bedfc6c0055a074ec710666dc204197b3503029d793140867f0d41bcf0a380ae6ff78046925cf890bc565d19e6294f254f6b049ecb35ef7333472205860c4227b163523cf1a44446fa916bd89331cde8638d50dd96ef8babf517d823ad53b549f72bea3e9187e7d57e0c104d00354724bee03b75dcc11029be31a1b1d25d71b3fcf0bce8fb92226ee37538d010b4ebbcd479351ab7a4a6cd965a95e64d2511ff9fa6f5c159f3cd5301494d871bb0f52fb4e36228516925474ecab13bd28982472078bba29887b7d90f3ba233eef247ef0111a134ea58f026d01d8d5f8b7678e0e736089143f39d5cc663934a2e04c747c1efc71a64f8359e169f90d1441c13445c3cdf825252f009a667c2ba0f635dd395bcca7d2779fa8a7336be0b12e4667431be4c991bd3881d9a02d73fe16c0e7cac81d96666323a82fbdc45630cb0801b2eadc0e8ff0e4dcd6dd516bb62abeae3556d13996b54e42d455625b4cd22f3bbdde02f3dfef32bcb2f8f8b9c2e2412ee2422db5e556395015465176f2d806399d39b5ff0bc3741774a9498a692066dbb2a15f7d2f52133a180f109aacc35985232f4c4831f738e0c8df0ca621662563c700903cc928c52b74d6ca65ab9c9dfa3ad8ffe9b5a9de692227fd9a89490f13eae70ebc866d403fa464fd901ec037b0fb9a4169073165c80648920e59090a3954c83e312f026158da7ed99d41f86d62f0ac1bd05dbcf29fbd7645b1a2979ca71a65811d8ebbde10b0a6d2ebd708dcd2119b0252338839ae80ede5e5a67895174c692580f67137408df3f53325e425c7eb8aa3a00c8fd63206d4669f6836e4ac99642c26215cba9c709b7c10f5bef400f3e6992c0ff096af0575692750750a2cd1d3b8e7ff847aed08853d976b5c212c54775b7fdd098aaad2c1c0e5ed932cd8fa022736693e3d887e9a772335926f2e53acad35972008f363e70589f612a6dc5ae6e597028c4f8a447e7ec1a04020879ec396f32aa29dedd377e909a8209ddbe97d2b4f63f0ef5229b9b451d3654091c9685e5a66e2ac4cbc6a578a11bcde6f480bd7b7031c37f5cf5ddfb39df74c833ecb7094ec197baeda03244e81fcbdbb5a9639d1736d93eead637651e11d290b9b9cad3797ce8d0f29626b6091c26338dc16244182620460e9818621f46da86997e73732301767b8b89f6318b4dec3e2a22e27f2dd71afce38903fb96af4c7b6309f060a905a3874e850776a64bb8023a91f7655c207026bba34966f3aaa809dd032ef8e2bb00ed32281a08e51f8c6ee566b8e09ecc9c7fa1d66dc05418480cd1e7e678915fc43f14462660f58a0cb192ed0b1d29793a98203f4c2f75d7ce6991c766f6897189cf15ea81e0b1f561d23373186c33472fd826ef43bd04ec5f381f4ba989a007d0ac9a43a3e7cc70c3a132f033294a62cc5bdc1883af4b2d819f7712f6e4f3ac01333f0dacc7854817e4c16fb41c798cbe80215d34858cec9676b3a5f6e032f41ed804e93f9bdeb7a09f17be22a0c0a8a1b417f9a37d49cee2a8b1ec17b8da7e2a97b19c05edba3b9e9960b507c2b9cab634f7d6810ced029385319f6f1b3e00c5dd37bc73e027a5e5891fc957bfd1a6d825c8b644d0a874d84da082eb5ac93d2969213a75f3ff4f7fa683758493a32a81b9164a258b153bf3d95b889bd2c64daa661f1ba1d3b55e3a102fdb399ccc1cbf40340c84a61a1adedbb702174f1c58b4243d74612626d5c1b1a42794b31566fd7c0f42212bdd3f167e3dc8cad31eac297ef684c93fef4736042bdc8290289328263ff3ba52c3d50a65f285113c78f094b49a8f38d68950c06dfe4694dfb5f28f88cb07357d28c53ec7ae2c02bdcbe4dae30e1ade5ec241a9a4fd83f8dd187b7fcc200a7e9527a37c6a7a4b484ef8ca8d29e44090a37378904a338a3bbf1594cb2ae253189336ba7c1e4bd38273d681d4e5693445215d13f5f56ce4d4bbc18f7501e0d7f5d2caafea4576860ea451a782958ea940cc5b1ce59cd3595d337e7c5da7adc6ba1a3bcbd2a85ca1b7a2f68133559c78deb5e9b8793577954d224d10f6ae72d35b402bbcba5e18be2f52ec396e7a4b39edf658df1f8a0fdfb4679b76ef9db4e2b43d5d30485501fb4c9903222a975222263f031ffee2119d1cf817509090f770327038c19620236b74e518a687afdf89468dd10ce85e441f0e443785739402ca4624ef30c8fbdb95469ea7c691f0b698c6a68ebc9b4206a2f14d6f5912379f5f1e4e6da1f048c17a05087941a511ed11b27d2351b7a33dbcdfdeb009840c686f4ddef3c1aac72eae1a83d82bf82334298742ebf73cf77c0d1f1c5e8c67df7a7720352558d01e98180a182283f2ea0cb567e2bb98074a4d83dd14e508d356e83d7ed56470567ace95f4335cbcd1eb08dc1a482224565d0b3215db147f39003cdf696522cb57a5882574871384200f48bf629425286d5b2216cf97756fd363fec7b2450ad7870f05ac6d16b8fea076f22ef4c3fa1c051b10d2ca4444923435ae54774c04d1798e05e3eea23cf10396aa08194af538fd7f91d8aea767c042266d57dd96b2ce09bd260406d0e97681dbdfc16a0497a739b62a59c29ce58fb232b069c059249a6539588efd8848e082f85fcd160aaaae9141c7a2d3ebf758dc5beaacc2a71d0d922930205ead0af300524c9e98d946a2910e6970f0975449acb43405c9b3c00cc6b81ffd217dac6d274521f8902722ae4977545a357f5479a5bf3bb0c392ec0ae290a79e7a3bbadeb83d5ae9b8120cec9ea5a99559f1986279746db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
