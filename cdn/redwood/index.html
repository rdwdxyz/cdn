<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a23db1dad88aba4cab56bcc7e6f68029d5ae17aeb9966a565a1a3892ce85262f6b7958a1adb8d525745ba0dd4bcf69d690cf4f89bffe62a78c63a511d4665cb2944616100ead6b6e9314f2d5f1e228b4f01ee2ae9ffd964bb4c8ae2a64b2bde0a4d385f6ff4e01ff901b972f6918e984c8ca935f716111ac88bbb998e12b4a5b329d7bfa67f257824db4a84601140edbd19052f02700f84f8ab52ab5e587f535744edc8e7fdbf7052d7e4a45065b3bddbdd29b95aa032ae799855b630d12b12320d62e0f82e35a9476a1fa67f1f1e06c11bdabc18d36346378d6bd3565e6a5ed02445eddc2483167d040bbd3cbe96e4248c916a179715f6d2d2cc9e3e403c8251d7ef37a833213ed94883817c33d46d081f50657bfddfd8780dec70ff89a857a946e52cc66607f711e50d11b80571408f0e5c586d10876a15a711ea32d0868eebaddc7fcd029ba494fe7f24dca73810ff32941a9d8e160e275d4327e2721c686e75733546cd2d58de6c361560812d23b38d575f7e52251f9902084242cb458b6c93f596403b8c30f53227c9684a36562167b7c8490b914ee4173237ac66d1036ec1687b9bf6226a29d0094b360ae976e37c1420b3d191f1835ada2d0521733346d295b4def5a760a50b2931cafaa6c76de4230a507759df32864a6561505f85762f6a33af5beb52e5134b94308b8454333fec4a146f14adf05f7f3d432baef52d4118761ec762d9bba15edcc295a18e14f48137e69c0942a85134f5ce5e02374063b1099599e1b8f5669d62c9e0b0c2c0eed8f4e2d64612872c94f14761d712e2ef4603315f3cfd6a7e424e7b74dd06a6a01889f0dca11482f45ca35db16a755cf03150c7424bbf771b532ff7c8975b7e7b0c4fd20dc42c0bc95e16c582139692310b6644e7696f642eb8f20045f41aee1349bd2128c06b7d46a5dd6b89d76b5269eb6b78cbd26497aa21da39ded0e4c361768201bce91ffece6ca1a926d8a50c0bd936b0cf7a000fc1511de2f4023918d876b42498fbb3371c3c7146d53518dac55103cbc1804bb07164eee4892237c96addafc99410eb96f2d4041ea6b436886582aea4c2a3e464036f094c0aa006e38bf226f32a94b186298f48dac8b3f7971ef0c3f56333cf41fe92abb993c707cb4aa8c9bec9e0a347f9fab1ff33dd19971bcb3fd263f9905e8f38333c320706d11d7ecfdf7034f5ddb612d67cb4080f28fb8cff4dc56b360fedf3001349dc3188fa1200cf0fd7d69d81ea194bd6f179517bcead4cc7a2f13c33798d5480925469d63ce6d4941a05895bfcfc7a0758412ae8c72d1b0bf512f3f91bb40cd752410cf09003f8a71f421cfd2a281b639acedbf3716a0d00b9b077b08ce6f1d7d255cac5b37d34140a43324b05c7924f5050be5f397c080d421ce3e84cbd2ab62edf9d5d75629f462a8d9b49fc3e61afaa58502cae3413bea28179a187f203ad2b636442fcc23c96104ea41a8c1816b8d3034a469e90f17fd0076827f99e4301f440e62b8a643c45df5900bec188bfb818bb04ef68de930aab87759767c6584b7162ebcf6212409f8fd1b1297ee4a168e1e6423840a64fb1f059ca57c988235614a82e7062bbd971b3cc14d7bfad6531e153d68f200a926395ce4de0df8bafc8c7aa4dbfdc0fa5e71dba9a1b14762cef4ce234d1bde1bc73035a72401d4ac746bda56addca202343f2fa6c294e86fb4c6863433a08163df682b85dabd772ea8019fa30f594be654bd6f2df0c339fdc86f51cbc06a9d0ff2499be07bb756236e72d8282050913848bfd27265d47ee4e19b0d3facdd236dcbcf71acbdf946205bea3936e783368633ecdeb2193aec5fda27bfd213aec71919b9bc807459175f35d6d3c5924ab3250b80e84f128300e68cdebf4c36ff4d28ff462e527128967f50494be348fce9e6e6ed9e4e8fa83efa2396dd41f643fc2ec50e29c358dfdc4c615a8553860ca015fa42b3d796fdb9fde2d03a4d401aa03658ae69dd1ebeef63690c0f7172a3b9dfb9bbe1dedd8179ed5a86b897d49193f14002941fc45883462be9519839d462b2ff605dad48d284d6e500c1fab2e81e5198752db0bc4e51c5f69b644a97e90eda34c316c855acf7d03417190bf66f373cbd50450ec450464a2246c2eea1c2d01382f022860a84f6f893e541c71c6a0b189ee9c8298ab0dd8a7f3ed57dd98cc6d62883613939d76d84714722a6f3f276d16da52b540dc5fc40fc7166392f133759c234bf2eceec87135881ce7094ddee35c6be8d3031ecbaae4682f04fa1d89e3574e2e87031d5f12700beb37c12b8cb0a020040c221ea87aeae8eb6e8b08b813bb9b21c8daa384e91cb21c05156a9bf5d0c617026ab460a25dfa5a24eea18294356281274500b0500fb360a7cabd8a943f4a9ae5116e87a43a484f6d5c8abf181b9c05b313283e52ecfaf3971ed736279c5bca9fca0bfa9c0e8947fab8a2ec58215613d569c110f989fc3b227bc2b669a13926acd9423400f3f73ebf7adc28025299d10178bc1e3cf7a31012b62f6daac5b38662c307c05361bcf49bfbb393eeec1e61fbcf7ad61f52c29ac883476c3111d50144cd4fb814ab3181fec7a2206114c787ed2229bd1190d697509bc078476e3cb835a473c40789098ad4068920f33490d1d201f5fddb391e6c81f210a715d411c587509ce80d5554d6f4462817a5db7cc0d31b0fd944e599f4e9d69c92eba16516796566e99906d4bb9f8761da89a6a3cf7be40ce0027b522e31e9a0059052d3c2f65342c987f3799698a41311473983fbedf781e74ace363de84e4551b45ad3321eb95f97615a288b0fc28e24fddeebc93f89d57e7b2786404cf29ea70b0abd81e735dce0f8cc1908e98f5063332fc492d0eb0fb225193ad4f3394b815515a0f54313acfe7a24ebbde8318e590d39bf57b97c81cb5e6bad2dd730d36e465f4fa720d4042396c5b04b9f8e345123a26feafd3a6e32c9fa5f779bd7d2e289defb65ee79bdf246fd5e6fb7c42762e011a919b8fa9ae377607e4340953bd8a30f5b5c39c43bf6c515fc461ce67a80a44b28c25d8be234d655db85f362aeaf06390f180e0dc3c8516665051cd65e248be1dd2ac21519a571a73975db59727cbe0a8e1f723db574e77945f73c30d8073448e22e1b31048711eb94279aa5a95731613b49aee67e410783979b227153f69e70b2c5129f7c4c898a0571516792e1d60033aac175bc49d1e3074114f43240f937a7b63cafd1eefc49064c27182898aeba0a595c2caaba13f1af2c4aac6bef0da1a70e76b1470cde8fd860970809606acd2de6b4e43e7e28b714aefa19b62adcd2ea03dd03fba09fd2582b22adc47246228b146ef4dce33995060130f2c8cf20a24b44014d93fbb3ba85eaefb7a52b53b07ad16fd798edba4a12100a3fbe6472d7194e2dbf77dd6b6d5f7f064c333930d6b358d0f975d70aa08732f6d601233143c1c3f4c405241383996ca831aa64340ef8ffedd0da4d836903793031ad13fa74ab85592682be346844c472c871454d36db2f4784a29e44687b5960dd270dd2f5fa2a1ac997d4c2bb820c991a9c7d82fba8ba6a81fac4b525d2f44521417f933df9015ed23257af8410ba4885d13d67066161abcb274f6417bb2bb39c925955934ad8227bc2b3435951331ddd7e66eb77ca50ad3d0707a81859f914a06a931a744a366823348cc2d2d4136488abe8bc685d71a72e65e8536146211c0369d4f3a803d9aa01ff854c8e92965cf97bb1b6821fe732072827000ae9866aa8aab01e7089ce2bce6241ae27711f1fc879114a831710dba3fdc537456b25d576d76bf8de5c8e50225e882c4b62e30dc42f969dc0fe5808801b38dc3a1b0a1a876b79e6388709234587db44d564febec1b9effc43d935526fcc8825fe3f89cbd92b191b3b94680eca68677fe5e423e743f5ba05a6d0815ea821b0655598149a32f5f39378333d968a6e8aaaab4592bb7c248556905b0f0b509dd4d8a74b588d56ce98a110339922721ec88f405e577859923d0d7607114d63bf8c9ecfba8bbd83bf3480e9eef646c5f48580c4234209f77b23a60853fc68572340f1757ef8493d7d4b0341787ea57716b0be04254880de4d837934a20a1d787db3534fae5501923651dbc9304fb33e3f65677b58108c0701c2c55a88aa18bfafc5100263a44d80872a71eaa00788d209377eabb8f1e273fb0392035bb2b4565362e88e063d5e5d32ee924048293e6f246bef89de9e7a7a6f979d871c595833dc15fb6e0f1bf08c68b3b3d7e62cebce79305bf0738256b8254ab639fd199ac1fdf84fab60398f971e133308e85f8a50993727a910f4356a53db3b789875dc465ff8df5ee63994a4a0c69901211843995099cb92da2839ed4b1fadf4cca23fe3c6a22a043fadc6b8f3b698ed59a4769706ef3f7986a333260d729a3187defdddfbca32d1f51378619a2e4b94801268b9cda86174f33a3d132cf4c84fbf3398f4e4043914c8e1fc09d3258fd204b384cacc8744f86e5af671996e60d2c21c621d3adf5f6045f8c3b1b72d241c4950c938bc7a9548772d5eaf2ddf3b08636c7185e52171c56477776276f58a1abe7682ad6080385b7a71834fca1a01a73724e21ada818f9e34bde50131006c7956a4288b5ced531cf82a93c39e3b12c38c282724e5ee609d7e55d1c3553a10063948662429e43672f4b01293feeefebef498b8c5a3a398652461c642015744d352453ba7715f9945b4c3fdc2d9efb74d30663fed84fa8159a7cd134229e46aae2f1df4d6efa0c07ded63f21dab25d15a204947e484d064e3882db9e9caa5e5f10bc89c769a5c9a849b7e9ab3c06a5c814dff0731abd8060bb62c69bb41e4fc9063d4f6ae6c3bf77e467611cbc42f228c60c0c37dfbc367916bdd31a2c8ae7a1abea26abb3e82837550e430530e4ae5d7c1a3029de0ca94c28f5230bd204b0345b7be3cc418995104d8d37e740ed5ebeb49c649aa1100941b15db68a620e8fd3f7d8b7f0fe8fa1d2f30be0ead83a9b08cfb520db08db5d3141515cbafc6c7592d05bb3056bb21635e7dd0085fce496d4d90b1859a803fc3cab000fd7462cc3ec40ff6046c36bdc0c18ed475e1f012032261e1382c596795b2156f554389bb53930c6a5e67ef34c59153d317330ee8538fe71afd576d5fcd85840ce753cf435517a87eecf7e5e6ca13f2e52ed69c9e45c5c9b50248a5dc2256ac70ebdd202bc6ec8e6aff46ff825613eec47f2efd0317fb15d033aa7cc3279f1ade5c9b7bdb4d1983489291840b0ee357ec6669389c830de84cb0e0c98b84a8ade337a511bd0dfb32c42ca797a6ed7392fe60fe0bfe1a23112b8ba1d4177bc3283313d55605186beae565989fc2e350fa768c3cef6b814f455c8decfe76ddca05af9621a79ce8f9df6684c8657cf2d0ab5ad62589c186f4704b7bd5cabd79b71e6729ed7490aea8aa6cb5d3208814c4febcead1c8e18c13f1d510b9a4a3e62592ed602ac03d88d77d85747d7ecc0539a01de79f5425a43b52fae0c9780d533c5c13068811c7fdf6b9902d9a9ee4da00bcfa912213b2871d42005b0f8c94ad79d0dd01d3043a793e6c19b5cbc1dd1a727c8a9dd2bdd453270a1668cf128fd26d4735729e3e3683beb1c28432ca029cbcc788a08c7e0ac4473d94e4a928a16880c040ba91fbc08e741bbad586b2275422db5d4d65be8490578b558562981deb9bf1bfe4c475e525e3dac71338b89b53d571e1f8bfe22ef1ce2592228e35723d5ef5fa1bfa60889f7587f108b1ad254b3f1f98f931ce1b412f5e9f18de106cc75319901bc0cce523fecc6eea2b0b5e7b93f402c452ba752b533744eeb31622ec68561220968a02b3f97343c2cbf8fa7bd78e38424c531d7376c3b21b6ab45be5c1937ab2416c2b4152021c47c7573e3d9ee69b64f2fa2ffa6222804ade94deaf2fca876442e19002b5c693dc79a0547ac9b989d83065da508a91854ecbb536a5baad2a45cd0e14ca9354e41fce234bc2492aa1b90d9cd639130bfc28e783c2d97a5b7b03b1385e16b1dbae33fbaad38e8915420e68ebe1ed02f4cf03056f8cdeb0247416a556119a78aaeb470d8316f5add4f7c23be86400172a1ee596c9e6470bb6e0cd4a581c37de822cdc7954d1b31d187fe5dbdd92c68337a3bbfaac339aa5af1b2ea5ae6edd70a7f173290aabd1d00557a5d737c46d63f559d4accd6d950f0e5560f79839fe6bad79930f8157122515913b65b4f9cc82f244da8028d00f657c0bfad84144eb733ce0993dc1c0d73220c614efb0d504187d5b639c4a0beb9d88653b50b36de2aef0536ce013a97317d0c43780c4ccb4f7c4d16b812b7c7454d02e369fc28cfc84ff2552b6c01d51914e5139d664d56dd1cfd5df7faee58ab58a98b028861a63debf628b1dfc0d17cde61c8407760d7c48f600b87b8be65290628549bd98785ef87271795fcc2e982807f54d2f87a89e8341eebadc5d79a20098713de12977d64c0024f8742ba9ba7b428220cc3d60b9fa803b5660456db2b6670560ca5e32b9852b33d6b52ad23e746f9258ac8a01adfdb3bee36dcad9441cdc8f3e1fb9098c5a08a1280e8ecbe252665b5bd484376a240f8db716a5b636bc7bd7b3ceaf095dc3cc7667d03be5873399caf8ab1692cd12a4b72eb4be8c8432da6806d1189efa8d3bff0503f841df5d36de93ad9055d6ba0507e0bbf94c81b645bf879a26e72cdd1b3c6ca3a204ae1899682531b9a52c9bede90021fccc9b407ec6127cf0ea997e85b09f8e8455f02a6b27440f1cb14004fa359ea2942f2ba079496c66062d4b3323f5209e20783f71a1363c3aae924c01e6185930e0d0b1bd3377438d3bab2b11aac9c494bb9b5163e75ab3cad1912f95707a7f8eb9ad6c231eb1516c63e3d6097edaa9fbc6640e8cb06887fc2cdd23625c191072e1fe71857b95c38559a5f3ec2d5a2472c712d39266ca75a60d5d168ca92898c32ce851a9332ef7f0f1a468847f9301f74ce33132d9406bac731a9a402cc72098def57d01b7abdcc2f7ebf18248a852a7bc9511789259edb6b7c8c9f1354f8d4319b2db4be52426e8f2594046a9269dede04fb894f5c4f658055988bb181ad22205a8ad46ddee76216fc29aacb1ca06c036e63ae05b4e106a14a74e3daed1c738d712d3c398b7b8e06359fdf95d904e0c84b0ee9d0044b1a440e75033eb74ebdd6dcb93b54c2e5ea6e155b3a6bca1900f0d27a1839b40b72b60f1f296acfc5722985cba2bc57c6ac3d47c65a4e0e63f5745ed0f8bce04aa9e42f4afa102d1c214f201548e5ba728c7c5f68cbdbfccff1018ab777c587c5443af7b9b08c1d910b5fa555da25b6ab3094dfb00d8dd3aeb6921d6cf7da6f22ab0aa678b3044c36f988b6722f809a33c8e039e3e149d402d238ad2274f02f23800f4f5c433a426fc24d8ba8aff53a3c386f9fd4a071f6244385a30733cf032b7c97973c91661700a39d5cc2f475b9291ed8545ef1ebe6797809f0846b82981f448f228acfd36892e399c20e5b82835b51a23a882e64345801ee75818e82912fbdde98097db3d5d95ab657b2ccaa8140711040ffe5609ca896ab325bbb14bb0c78baf55e64d212cedaaf5e94f4aa5012be2cd980839e3bf06c7fc702bc137361e04b8aa48d81c8f85024136f8ac50ee807129ed9f62ca4ad7881cfc3b9b1e223099fd14c5122fe70c3c60dcc1b035e828b4b54a1797f7ad211c54d4efb7810caa5e6d2302bdd43b7a30ddd59cf9440aca11257de71efebb9a1d792ba30385383fe188afec9608d73e4b125ba2b8e9eb1db87675ae85be285af7ee1cc855b86c718f68e4ca8487190393e73e61e0d6b8ba7f46a80b34502f6b8d19446bbd2d417908d627b890733ea10a36a6c1f4e4622ec6721fa1cee42ce6a99026f8ea66658a58625238561ac803726834615384e3795ec56ba3e57a29e9e177fbcd0c9eb3cdb7c3ff2785be2e5b001388740f88922eabaa8913eb98636b444a4d58cf3213e6689cf5257ba88b65c7121f1356c3901bcf7fb636ca59a54d24bf9dc0b3ae42a4d7128ceb53e2284913ad68d8dbdf3d3f5fc312e75df0ab9137b72c3291fc7413d3706f9509e710d7473f60118e5329b938784e6783cff0b9760b6d2db91c953a771c4e6b1ed09ba16b330ff6d1f920e04f69d36d6eda1bf19722209d19e8713b6b4fcbda47f0b5a157481303923a21fa57f9eacd15f81b3fe07a0dcd5e44d7f3d313a02016ebac78c541036789033ad73b4cc433f3fe7b912f7bcd16ecd5f2c7483616f66b7d5611432db4977d19bae7d1aba6acf872657a5ed651577cd3362292a98537129147df66de70d19c64056e79ff15ee258f98a0e293748355454e3a8eb80321451529e8cb5d035a0140e263e9251f343ad49c1fcf8e7510c2485dfad0a356f2e468934d483d0b5b0249938d2444e1a5f96d55a94c7b53844c361d82e2ea87f28931dafadee86a8e6aaccdc948f4a5b3c076a22f2de0c03a16f3c6fbe1259d485136d81512476750c12362c2a2afe3c3acb6722804efe3c7f2fdd53a95f29c5291f3c0e58acd9beb47b2e3839b827cce7730050c5c3b442efd07b4442567c14a7b2445bcb026bc38aa737a01778adc2537eb2372325067d188f03a0c17426ff87ff9d6b5197f11a54febe6b5f22615301485af98c8e7886bb2ea86ec70e961b9dd33bb7b8de6e51fd467d7a6d704180f850641bd3875a602951ea5802b007054fa028edb27e3b81762e3275540ffaa05888e54e95d493b68bed1867003b9944d619280d4c2a6dc2fbc8628328e9dc0c14ea582c8692d3d4ace652ea599cecf7d3b201e20fe1eea74ec95cab7e9833f9b3e4db67761cebac28a1210f6a55e7c713bed7cca63dbe2f472f491d23806a514ca6085459a6e8548a5897f1278d8de352f0a9b239817a27c4163b4fb4946c46ceb28e7cecd5f0826af2a90ea440834c2b022dad6d0328b375198abcaaf47076e81156dca0250b48d99701fd4121445826cd3c3230238a5f07ab6548a7dd6541c0dc0311ba54399695b8f0bd525feb389803fcd42da0bbd24a02b92f04ee3ca40a57ad378c741219aeb21f240877aa9eca0a91493b463e3d4589ad55d357a8bdbe9da1cfecbbcc00f3dbdcbf7c66e9d9fcb4ee369d0450181439f1fbd0a1df7d214af2703830a90a7c1a04a5de68cba5010e2b50492a0cf8b96bb12331ec91a268a49828360bb6ba6d1bf17fca1a8e447d7ef5b4fe68ee3b365a6b88307a493162f87f4ecf20b688e9d1a780d47c341d1f4f540ebc21de65e42258b507dc581887c574dc17ed669608adf52eb20f9de85c84a263ae0b008999c74373fbc5455322d917914f7af4b2807ba605b80d8dc44b095862ece548b48d204a30424460e6f50f409e802cfd46cd85d1fe3886ac405b34b7a5971f5616f0e5a002c5668c5e58ed39af2e6685555f7b5bd2cd843c851123e1e2a91baad58a5955ceddea96c0bf9e0e05cfa3fe380703c2da8394340633ed6150ce5dafeea345e96a445c6e47844654be4cf8d361f18857f8fbb7e14a7e3e5f069284dade543dc577a01e52b5cc149776dad622a8450b9c8e91128dd9460eb67c762aaac47cf141ad8ab2fad98bfab1b651eca2da06d19df85969b1c62597f5df78519f499d5ad343f07fbc8984cfbfe85d11374d8975f545c3e579b9bb11670c39b8d7f6fd1aa5b14cee288688b0bfde5a46d5a000827c085ee1e8c9160546920ed71006d6cac14931af893e3bd1d30f0e07c212c37e6afff061c558b78ef35fc32174865f9d98bce1dfa659292f783f8a15280f038cfc2aaa6de275b60d5c957290326fdce57fae9745a1a3025f8f62a4e73fdc60f72b6270a2548e21474c09f20da160d989f892c87821021a5529f2c82805a9b1762fa5f79dc2956468c52a780d4dc6944c1adaebf355508f4a999687769a5e5eb89fe2d8ca7a73638ad4c744d63c9ce9c8ab36d6d7e80c553902f9d4c27089c8454eacc43e3890f4b1c6a38374b5b21a8315b2c2475441ca1051659b84a5e16a9b4e90036078337bd68d1f7aa27c218d15f9b6f3fc6d00a77f8fbafd763b86ac15dbb6071016f4b155eccbc1b68d30a23477eb28854deee50eb3d92fcec68ae324ba3586a806372494921d7d4dc2e5e3c8136715faa464b2236888d6909fa261a9ecf1b790b3dd09cd83a4b0eea500a658653896623c002ddd2c2dd03ceaa84a7b7861c6a031db21d7145099645466f39c258e0601e71ddc2a1ff78d77ca07ef4c3a9cb6eb5b534ff1f5aee96b5f0c4461946668988986495e433e19c3b9ee98bafe4d6a65abae0eded458b7b39a875adbe6a791d2305446e503c220b4b64ab2a7822e9e2ddec0a9fcf18cecf5c0aacd20171ee8a0a7231dcb6b59f93ea6fd8196181cf6c6264f28964a11d6ce7ee6c637404d7981ccab18c025a63d4125a3091bca9a593cab4c395aaabacbd3440afcaf0ac1c0a5bea16177cc3ddf97746bf5e7b88b686bbd44add1321fe21cc507c2ce9088b7061f45a75b8f9eb5145aca4d7aaf59bcb45c084a5688daca7f64ed31e76dbb1894bb77137a7faa4afaa9d4ade74021caad5c3cacfac8629552a1f6213da7862262d03fc0bcaf85f025a77e7457924c9b7ab1e066a1c55d2fd9e5de73b82d9131f773847d348ada71cee57c46d022e23dc868c61fba58a94e9d8963e049cc2f6ca9bf88828205e3ef39cbf65382f4ba6a7bed072f674d1e207313620cbf9797cdee4d7cefaee60312eee84aa5ddf4b08aa7d999f8d360732f23a18d39ad4e07690c21225767351418cec02fc6f7102608dd8c36d041793809206ed0e0603787013d845da8d00f942bc4007bac4e3e03720adaa9b29dd2582d7110f246cd33735cdeb8106a1e172f194ee2dc9d77b139043aaa3be2d72c36953648f3b253d87a5336ed304486fe4ca117f9105d479641486d55ae33ddf15f9424a6a3e324d54bd02de18ffdc3551b7b0ba4c517f9c5b8e7fa2ae1a16b1b5ba26bfccce2b47c16e6b895ac11d231da2c6138720c17721e7a15c1b8b23c65f6cd971ab8414882f26da4e666ba4ef6fec0d8c5154760050a7c3afb2b524205789b0b287da96b78504c5bd13dfb3bfbb90290a6e2f875c41bb63cbbf953773ade610125adb4d8e62cf59aa1d06aa8fc0ae265d5bba90a9b7eb9dd5e90026550f1b9053269dcdf911f80cfe3cb893782e637b15ede346588878a563343b04d1566d0a14ef8504cf83defaf25a2db3bc0e56f92db8668f9ca24e6f52910faf246b6bb5e3f7941c8171cbc597731cb3b71d1e1f3a0c60abca9a3705672a41b9e11cb6ec1caff40cb561d64ee7db70c5a049c8b8b9205ef1613ff45cfa6a3cd81dfda4ff79db2467e37572381b143649ec45904fe91413f2ae6b1977ae7afebd943e8f9cc80759b5a70fe7b80bdd7392e4e4ee6e56ee1c0aa4431ae26e17ad58e3a1b10ea10b6f40008abc538cf88665cda9c57eb95830c0cd2dcd74d0b135691ac1eafd1b3c87a37ad72965b2807a26d4568936b81f84740ad5b6a0c1aca795ca7a79d65a633224389c017be78d3b00fa1215d0e15d5058b1958e92b384a546c6bfa79f13795a3d28c89c0630ab76ee5cdda6cf74db2091138c489ca47bbf0920b6e8df8fdb5e878ab637b1f288981d70723c032135b9f7c530ebb0f4d8644b1663585459354c4b319ce18e67b809ffeef6d3c2e9d358b4a1ec1d3b83dd0ec3ae2ed3ce6a8f02ebcc967b8bfe834a0573096e00848cc6dc0ef335f8fafd1fc762a65db03ecf340aed5f5769c3ca190eb2e1e213b12904ac492534f8ba4c133fd9ca0f731fba7e037be33be40afca282d9399026f36d02065246008c017382629e74024e98ef188d0b5a9e65ffbe0b13782933e267955d1ddb43ff4d0a9fd64c172624d9bdf0b4f4b61871333e67f30c55fdae49ba7b4847ad3b0cb4dc6e342fb742556344b886b7b7d8683208b9377bfab0cc481dfe1200cae547093fa6f650682dadc25f0177f914a4240495d04425f50d3e75a20589fa9de41ef8891a47bffb940b87cdaf527edface69812647770abecd5f4db7517664c7f77900a9c2be359dd43edcb32482b41225a1675905610d37711e6a5420a318f96bb0abf5e5726eae32edf46dda73814f8e89cb2df68f4671a6092861ffc522d83ee836483ea66bd2930c7dea144d506fccd0d7895deb8f4c5e0a64e1a86950bc13055bd405e0371883990d0e369d6fc4e23007c68cc821a85a9ef7f0207370c1af52aa479a7ec16634f3e74daa190819540a103ebaa58c67770fe02144f4bf0c458d81cdc0f1311baffb55484582d04cf5578060cfdef7d62ce2a0a8f7eb9c6028b0bf85e62a1b2e6d2093a5073ebd15eb0070e145253daaf82c8707d685ace58f453a21c9daa307bad9f3b969bcb33fefb7673896a7aebf41585b0ea862da354370acbf08744ad98018e14665d32bbef1d86610993118b9374f5a911d82d8d4c85ccd78988b4968775a52d163028c8c4d73eefa06738a6fa703364aac0b0ab29c336745d21578669b7bb92cb10a9a85c72b3f28b48c1d4df601bbda98d6d24bc0ede2e2ac63a75d6026e3d88da947369df1d410df0f02e9c473fea501b9806ce154b75a35dfbf10cb19863190e24ecf81419b508a8e25992bbe79f29cabda5e05cc3a3a9b71def867b78ef214157b07097699ad93756a5bac0e06d6ed442a127a903b124f67094c4056deb05c2c01a500a8925d650c353d40131883b820a1b53d6afaf13b88113c4d173873f18687e00dec15511b25b93b6fd17ead6771f9d4cf0e34d8654bd4d790654017db4b009e8b1b6148825d841d3de78879ef4886a85fe4ca0e37e3dec9d749b79f54adc38f31654b83979918521c4c1470d02c55b8a61ce86f2baf04bbaa1898efde8060dbedaf4f7d199454811b8236c3b22e907cf4506e06e0d4b5e5008120fb2ed031783d7dc1c42cd822c0a6c40eef850fe9066db7eee76fbb3a63286acef3eb5472454235d2f8b02669ce0b2878d0321e2fd204d935f8ce545075b552c1819e894a8206106449bdce1b97497aee8e0884d8268937d05e07f70e99089ec196e39c1ed76e2532eca8a7a507a1568d5eb594d1ae3c2b5554a7b26045d7f358a939a55fb86108812d69f4e5d2617382d438806936142c66d4a70cbb1b8b4a7635b8553a4d689a9cd353479ce82cfbec9d72f2615065254348e2f6db72a380c6e617719464be9724c348d8c849b533a984e6de791e861f99e1988f5e3d98505c8b7164ef82b9a42e331bc164958af967637b2e92cc98d04e10176815d90220eaca17d659a6115964bfafcd797baa534fc97b00b9897d10620c9febab08e7beed604665d9a509b9fe3019b9f2de5d8c56ec6b7f700ee39a0ab07dba6820b11df393b09b53689f6f95c29abea0c9eeec35ecff63e645090fc268bc556bff74127898d374810c26573e7df95d4327b3f246ac9ebadee67850705bb27efa8f5ec497b6ed1275325e4dc8e58cae46cf6b85360bc18f5cbfd7d357eaf8162325924353bc0fe53b1963c4ea02d0f50698c5411b72a004f14825088e549a6b51ca254a529750d42136ae608b94aa6f288d3ceadf4878ef3e3e1312c4f2f92fe7bc0de4271542c6cb9a850a1ed457e6d65bf281ecaece1592320d31af7d67366ee5a2712e6324cb5119d8cfe90866d51a4f80f18f1b60cb2a4e757bf47179f2f6bf9057fd49ec3886aae220bb676b0571cea253e14943ec546268f880627a3f559eb13995d7d05b331f0d952f57f41d77a21ba1031c842c668c9e401027b097d03dbea08c8022eea3cd1da791cad59b08c9deb554c0d41b1e45654c637dbbaa9888a87340e4448bf34c362c3ef04a3c5b4b6d65ad0dd035c03229dd9e9a3e09f787bc3a96bb39fb941eb08f70a08f3371f66c7e47bbb60cbb6621a67f80746afb8f848d31a29b56f76315eedc7d1b7362c44b6cfd24a7b032ca5cdd0eac097cb436251b6a335457aa47c891c71378f7303337a2c79042c2a42129ff6d9b54bfa06fcda3aab8442924ecfc36a0cb9bba45bdc23ea13dc1662a900bdd97abacd872fc6e3964c5d5c661529df60e00c56bb2e21deb0c2199cc25b188c771a74e112eeb16a22d5089e4aada367331e31ec17c575f8b27a3ebe61abc13c2ba9e3e57e225ed4e6d5a44b171687fcb9637ce3f912263f5b1b09932f6e1fc6d94ab4b879cac62138368fc1865bb7c511cb7dd6a5ca2a327793151401ed00169817f55b34261811ce1d306cdd11c3a0cb663de82d4138a4dc79e035ac0b089b4f480609063137316898b14e1fe17f3e75bd115a64bf5699830d0617a59a684636af4d85a66b54874c4701e5985409c946979836bd92dd6a768602aa0b33fdd564a7582808a15c599f7a493f6776149177d32093771681a8eede9a29a129909280792b52b8cd0cb14e5fd6a9be3146570e2e655ca136bfb316dcb9aa57c0b734d905ae7344d45d7b71cb29363e4dedd6eeff0ca91f1fbd2c1edd18a313e770ee98eebfc4396b4c727a5d61deeccd82ee81a19dc41fa4d0a394d9c9852182e526179fbe3f55875c6d6bc5d2b6debb50c8dc5f24f257a6b9e227aa422d6287217236acfef84b603f98ceb9bb1421d52e821d83e94d349648a3e5342867be22573c1a484661e7050c2b7ffac90a4c53e7c231cd05c0cb085097d1953fc77e1acec551d647e6f0a2a478234cd323f10ffdb69fa4fe3521d021fb78bd52d3339fa6586c31dbb8dcc08da1449e080cf9de853065dea604f051ec9f84c8a962d7605c6b12b544c25c725b58b68d6ade4f300ddf9ac04011e5c058ca5e6d5000425203bf6c9937e0979967324e6cb7445607508ad01f38f23ceafff3863284cd1370142d32d7edc0fb9706cad65a9af95f228b04b2c453bbe8a7dfb642951b4efb49e2a9e2685e140c32e3aa2b1816cea4fcba700120877f7a1f1f377e922e8363cfd4c113dc695cd501a41bf3aba52996531ffd9ede3ef44093f8d34389dcc8277f9952698504b3a8f018fc841c8752078bbce3fb81cfb05782eba5bb93cbe67304675e21bcbd7f3180c33f56e416d559dd96ef80c8edc95a17ebd6f2a9dc8e574a276b793b39fd4e33ca9ab25a459740be63dca137cd5f8f7a27352f5abe048862f9c42e28d9c7a9e3ebb8aa93002ced5e1cf9e59f42bb39e8b4f2a305ae4307f2858c15ddd10189f849d753d8cf2705b02a2aa7ede8d07050797352b17ac8a0f109ddf6c3e4618bdcfd05489a0da4b8dc1608fa189709c5b273a7bbe7398620f0c279daedea2a3c7b548329465ced95562a25b923258e75cc27e0a9dfdb37713d2b5582672a192c98a4251c60e0073d9af85529882ff8d74b03c96f46add67b7dcb5ba496345cf9dbd84e40ea1d55d36b139411fc3a55b026c657e358102da10d9bcd1436884d54f02050acf2e934d5b68de68b082f25aab4dcc5ba5ec97952c9ebd15090351f60a6182a1478c63c6da1e0380547e31944e45f9d20c372c3135ade28a475918145f7e4101c29334013f4d6029a07e835b6af50452cacfd0525efa20ed7d01fc79b0b87f46eeb6dfab4ef7737017d1ef251280f2c2bd4f01c32cde7a0c471690d36aa1a47484f08ac3bdb20b25d361b3227fda41b1c632f22cfbf3c53221fe9888dd7506184916dc97e0f99919c2c3041a531bc5b677c21169c94b12ca7d695fc652409395702a41fa5bad9c8abbf63d3d52492faf8f32459307572c84a35550c93a6a05851dfc1fed3c67df690bbc3ad2eabe23170eee52c5f992279a97f6aac5b4a33e9cada75a0f2237bdace691f34f1b88f9d29e29c768c6feda15a47bbad83a1faf1425e38e6472e4e3bbb6ff1fb50545b7f8ef190b4bb55a9793d974077953d0cd93f3e3be0924852cc7d4126426d9c9b7aa8d5bc1b63c30a46e0f823c96182f8ccc7a37483476b5fcc05e5d7a71c56f3d80f1c8854a2010a89a4e2593c8adaa305861c174abd71284a9bedc014f421e4132ebd8ab91c9715f6155daccfcf719fb39a9ae71dd8da6eacadf177d22034ca6b83af4487b88990cb0304508f357c031377db6b9255dbce6eccb7d415264606200cb7ed15563c8493f4450ed73044ab5283ec2782421519135da397d5073c42df31359717686f513680d0ffbaff07ff2fee2779d0edf2ecbe779dea592f263e1235c65ab51868c6fb65dab53628911917d19a8edb7ad5887045245a77e7c0c75a4a50ee256c2960d0b463849242a5dc08b7732ccf6cfafbfdb0ff776e04a8af517567553bcd223c9ceb3f4958195772616d587de531bee3620e1f8a7279f698d42c0292fda5d4254d334e7e89eaf3250e3ae1dd41c9e46fc8b7f850bed825db601d2208c4827c2554f0f94c118775368e8c97802da89acdefbf7ccf5c1a0900dad3fbb6fa4f41664a59d8dd85f98a3bbb43af5c9776ff5eff15ed2eb5cfe757a25340166c7b168ae940fb99ca5410afce276dbe0791ca3d462d36da7954508c734987f039876b1d111d16ed69970a5cee078ad40400113e2f4107451c4864a4b2adb1842b98514fb43731a56fa8c7f03f64f2b6f9df149432b0f1eb712f5dfd07489466fa2733f76bc4aa552c8961868940cf4fb12a457d27a7b3c69ae81bac9b73e7cbcf1a3ddf090581e9d8e647d58660aaca6892f51b192008301a0cbe7535c4235dd3be094d29a92d924bec287eb7cdeea5a6005a7f93c11cf544fb45a4e3e6779cde15ea44250f43425a450bfc41310ad1b9eef86f4510307090a0eb5648617aac520f8694c8d1af4b972bc252f62363bcf0f273208e46a62f3178ddd8fe3d680b6a49de3ebe5f1134346220d823626af1d71313f53ef122e3e52495a2e77aaf85f09d9ba7651ab3f41aed34bb8e3cd538417443225ea809828f646fb8e67645052d4a746a00a9bc4a75a18e139a122861d02ed485cb9173711263c2758455aa7b2722a7d7d428d7fda6a4882a96c103a473b556ce67e6aa360e7bdf7fd68e82c8c06c2102b6bd24a27d268d5ef3a0b0acb8a1f29bc444be17b370ee413773f1cc4a16bcfa23175d86e714dd4d4af35a57167d80c2d5f88d0569c4e1c718ca8d9bb282083af8a3c94516bf4de7cd6a4675def9a9ed94f608ce5c9c5dcd20cc2b8766f03ea1c0cb7ab3b0ca1feb05ba1ff5745bdd6f906c5171a65992867219f36c739186db8493341f7d1b896cb1e68b043122f95b05b9b215ec4bbb456d543097580595080d241ebf36a7cc303191602bdba5331562a3a2da39ccc71c392389ceca4fa5c4ebd18a59bf9e820d85dcf065ddf3790f2954c304a8284ba1433932f4427e5b0230c58e21246487641ad07bb2ab7fb2a2f39fc15d02b234f9cb263e68e4973fd2de9cde55947224ea0743349948530eaf31e8fd76e3df0a402daa9e4587a52b8b46ba85008d2bcdcab5785df14ea3ccb6c28e4816d24f42839815430c5eaebba01b698b097e597bfaf85c5423ebbb8613ab7c9a303c15a948b3d249ecf59f6d56c69c096708c48732da063314d618339f327ef6df86e917af80ea235153821f795ae8d2c08a856bac280ffe2a074752a1f27b54dd7055683a26af643ae460bb0cac21b9f703f473f480f7c46a04fdaccf97b0c25409db8908888ea8f8d87af436dec30b73a9dd2464746db5950257769835b00361e223a56b9d490bc915a579089a6e2df5beb7f4da757829a168124c5075396beb30307ff5d61982b4e91e067a6fbefa36319b732cfedcb1bdc0df61b76aa4c7e36125dfd31948e6c444bd993d3567de6589c78f0c32a93d4b0d8f274d56d29826d5607c517555714a8f8e3a997e3a0e84022c118f0f7e9ad01df165d4fce9eb983a973d6ea2808d87a6aa1398ef692d34ca32fec792cf022de555690f9938c0fa88347010582adc1fbf6d53853151f842f797595dd86e5e37805c618addc7c46901042599f12e252a4e126ae3af81285da29443dee02ea30622035ebb92518b25e0699cf511cec4f0f8b2b69ffe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
