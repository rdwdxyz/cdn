<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85f56708239cd73c8e6e0f091c3289672949472ad39e3450426baae7bacd27e6c2dc004253cba6e35bb59b82353111c5ae99f87091134dbd6933c83473fd45eb54b909e5374c46aad318e1f02cd1ffcfcebde613479dcc112e6c2d8f4b0f40b3d0cc0d4d747ddffceed898b6624d100fff5dc085deeaf0353a25b57bf64bc2dd7d4f3447462a068d4878b3e220128c66946236eb3d2f77ed1d680a46cdac9479385866b6f5eedc3767e6da79211c52db2197f897eeb3f555d026ec915bbc130568a98a42bed7dfeb9b766f60e84e285bf3b8e4e02a6a7c109ea9d8133cd1a2873684312650d520652be9f745cae124ea900784386418a633b985e6e7d64be9e1c09378c834cadaa1fdeac4ee4e7f1690bcdf7f98b3bffe0d2101ea9fa17d582e08185fb5c464db0e2bab733d5e9632c3cd6ef88a7c637b9596e0f0d155113ac4f93c74fd51f2b995e0fd52a76ca41e7b03f2bd183380a0cf371df320f3ff7f44904ae35c8914a8b9ec4bbd41cbcb2e59a8016c5514a5eff313b58262445e3a8bc38964cba12ec7412b2b2dabc86a34070f0855ac4ae05671cd0432a06897742df37fa2247af6a2517bf68c2164fa517076a4ba5cab137ae519eb1af066eec436e36645ccb31d2b80c06ff401398f7976be5fa806277e4b387d0c0eeb5c5c0a2a4a8747090fe873d1af0425560213ea7bfe496e811b5e27d9eb7808b2648572c978c00732c10468b1d23e6e516659f0cfb0a5ba48e5c4da218f1251e81fd571c07262a5e4c27a9d87f39b7150220e6d46f30fb88a3ed57222342d500369584fb00e08869f6d49f7b3b901aded4d5068f7334c322b6dba7dbc2fd61ed09c566e253f750c0c7f21a32ea1f275edeca6583b6df7f1a527c82193413a64b44c6530cc266b9d0b05d9611cc75e55831faf83768645bed00dc4bf02c7527e83e119f12e7036ec4e199746c013049e76687cb2aca30079eabc9a7f73e4206268cf60d24f153cbc446949ac0537af4bae79f18fbcae3a84dab6c8e65c4f0222825216d3d7533af00942cdf8c0bbad0385ce10d3c737d89047dff00ac46866452298a77513d8c12707cab92444fd1f1ecaa347ae9575c7b4b59884441f6bd5b89e73ba170cc18f196f86e5cb2c5884e8c7f23fc42fa0a036bc17271b212c59098cacdbb2b8d59343510fc04f1c85dae1fa39c6e60e1d3ad3fbdaa5145ad1972f418971ccb51ebbb8b0f6adc463ca070ce6f43d0e000c310d58a8fb9fe4828311a041492cf205221c7ef481c2f9c834d335fce94f74dda0483ec1f1aabbcbe4bee3b097c0b2ee008dec2d4bee9fdc381bc8a6c8e5883e518dea363b092c285cf46b1960a02682e1c814ecf15e8bca6165fd5b5599afc0d9fc37266567757603e05297be0c6008371322f7f826d5b80b3953638bf0c8c2cb8f6cb0bf4b12b3f316aaa2d18c39be6db096688651773f029fbbce1a358e678a7517e3ebae80e563ade43ec5993548b333df6d05f983fdaba8ea36668f5591a7b7e572ae5261db7ab97b20f4ec1816a92945024fe7f6ee956049cd1eed5fd11e4fe1a6115c2066fd7d53c899bbbe63a5c46d1d3aed2ee3e9b5304d04657d2340c66b3317cf91254877564d86d53a10fdc1d9b76392461934adf36559647c04788c0a6f73d9fdd43739638b2496548bb402279bdba03f055a456299e201e46e5c1c77b9a8f1ac84ea35e64b68f0f116d64cd12d57c908ed715542d1107129d159dbf7d84ed667d0cfcdc8ce0f147cba20d9522fe6c1e4e7c08ea67cc887787cd20313501e5ceea11134f1478650d7976fdf3336aaa45feaf070fd6e6bca949220897db5f3373a41fc21aadf8e5c3a7ce20ef1b1a9d2b40a0a605ad3b5b96f5d94ecd0c8f01f4217bd526c7c8e6b2a22f377f423a83d19b43cbf2df460b156fd446444e8bf824614a212108711f313dc8e2ea283bea6020c3163f9238de8f765e236d690a14082016db85603be931b5feb8690753692371a49061c1cbf5b3d4494a5820b17c8044c59efec1f2df23966fbbc3e9f0eabe78a01faea175387b42843045705e8733cf51ef3d114fca6d462d4b557bb54b43fb3e75c837e656cb547ba38261350f71e604a50fb891e8c7c0d2a3af9e4b1566058f6e60bb00c032b3d09dfbfb5af94b2931a24c88e679130da2d62262ba27b013161f9a6fba9738f7b6f9f68a6fc07f72d4c02f1e66deb9b23bab53a287047646cddf6ad1548472dbb788e1a207aa940122805987142ea2bce37b1794073286e554a5195972d18c18a2ec3e480b5a49afc5d553a150cb6e3e1a48bbabdc2ab31b4424d71072189c159ea52132cfed27c4df9fc577ed3242f5aa395921d6fd0f5e3387959846c89544fdaa93930620899bad792afed7cca42d7b407c07427a44d02a38a281abb10831f1bbb37de76a49af629419042441dbbba0440a9630395ebd8f85a09311aa11d4192854ba343d349099d202dd721e95fecb51b911a81623856024f3b0ae5d41f666383cc2c4cb3189bb4e4d22e2306a6e5e81b1ed3145979e8d1be306f20841664bec14e3b7327b6dc9cd3026ef6e154a19654181dbc43d64cb8f408dc5f2c1f05892e1fb7ab5857c9f561fbc3a1d5962dfaff4b709fb25ab4964ce0ac5bfc16a4e3569bfd5689c2c54c9200c0f143646ea4f3486cfc1b5685b2b3e60ef9e9a3eafeae4cbba34132bff05e8b58d994cb6d816d407048f986ce8441b266f8eca6ce51ec74e6b387fba03626d386fdc5d79b10b1b31ba1894a1969145fb2cc43a923281079f996ae46d22a1971b360a109b5153663849ea22ff4adc7c08ce2c41aeea34101ead2072c86cde327944ba99411a244fe24e99d5fe187dc542ffbf68acd4bc725954d494e34e0c43210c2c7a382d0b102f5305770541882b4d0f8f45379d3d190e17aedabdeaea161215dc033e77746f567d48064d4cf1bf9030390126582a680fd395b400460516c1f4766fde49d79b5a91e9fff87ce33b8f51e3bd389a3ccc07d45dd95d4db66a0bd9c0bd9d5c7bdf63d85ec3f6cf11e03b95f2b889399140ed1004d82c1ddd3874c5012bf07f6929a479d3bf254f4d54a83dd2ac83ac614c529030425d510d68750de35a7f77cd6a67f4b25652f2607a8691d907a30a88381d91670a5e01fc7bd5f91dd5d16a0e5ef90539370a1794c9fb668e4e7edc541daa9ea61fd609babd755a1f4e5c5937f283dc1434480b4a93aa6c27ed6caf0ddf65e647aa2debda6ee14c2bc800325c4648954c5f26df6790a7438d945a4e7e1b24463c9420a0734ef2c5dae89acad97140f3653a01452df3422a353de1b0049b1c840afdcc93e86febd02a6b7d4ff9b741fe0c1645e614042c88633b65353c21c366aa5c1d8616cfb1f739cc4c78473c1b7acd1580fa8c231d4e1ad945914e34af167bf4f35076a2435bcc41e51f084b458312d50e936eff10fd67bde36030903c724649c69a33d3f28d6e713e53cee70628aade6e0fe6c1536b7b0c18de0ea51dd45bb0a563be25afb39a5455f15d366d160bd4cdc3adf20b111054a99ba47628f7508ae3854f990ae7d565685450cebbfee0d7a9790a25bbafb70d57e31cb612889ad3560b7a23bb229dbea3f4dbd8a46a1dad86235f2c208b19d8fb8e45c4cdeb1034ca42e3a71d08996083eedf68fe20050c2deff5b8b395bf0dd31a16eed0b3a9ea44805a0315f30e01c2661ab3c538e2b333141869c863a7d093972e7b442bf93c00d085c0ea67077b3edf5afc1857c02f3bf070bb95ac12dd1f99b2a744fd0f6eee71a77329ed43859c4378390f5147a77ed4dcb35231bb2eca1df7327e8fda19fa7443805db40d1b0ae8372683872cb02c5dae171840c5570a2ec77db9c158af496b5dc72a8b5e66434fcd31fca81393b743f873f0b740e9193802f3d8e3859580ff67ae501e15060b44b0d26fd376738173f5fafe2f380247aa0ca75c23220ffb61181eb5ce9539087135c264b0da82762fc9e7b2790f76732580671eba6a19465b5902a162663e19572c3b4fc9aa42ea9c6291fb1ca4fb854d27d716f6e6496d9bfd087bfa6f9b3f44875fcf151409a0b5e9f4c3f84ed0c7e705d2c3d1d307b7d175765d7fba6bd0519162da02734828834f40f543edc91f84e267411d8d4b1e96653b0c816b3bcfa4dde598639f97639a6184f84b98b21e41c5324bc13ef0b2a278f2b8d8e59d6b41e4cd09f8e9dbdc8ca788b2530bed77a32bbcb73a27a3220bb923bc78590fdb158607eee6e5a225b7d6d0de113b259c3248038f3c871c8f38011bcbcff00b6ef5768d7ce30db5468ef6fa992d32d09373bff347043a71275c8d0d4b555dc31ecd6c3de59fdc74ba8aaaa76c512f9974bac34429d522352b26df5be2e97727f329ca3bd2327e4106fe52a0e0d1a840487d696ce53742dd4c7a237b24aa62f527f45493795a4f3dd0850b7add0cebedb6aedf5835505c4df51cc4458f6e8b60b249f4af554d821616ee52aaaac3b153f5567de6ff5f8c7857dc90c98415152c36a24c037aa877a145199a938c1f61fb0bf6ec07f0516ecde78ba98e9149fb3b961e44ab74290b221337813feb67508d2cb3c1ddbddc61719777fef7e8c0444eb8b0d59f074ac36d1727722d63418ed3c97b6b4f18d1d1023265783bee0c8fcac73df7bbb9799f5bcb5183ba2a250363b855bc3dcce266fb803b3f036d5f8faab8bc073a5eccf923d9d7d429a0592113f67f7122f3645fde41e647d5bbdf0a8d62fa15ac57dd7f1f57fdc194a08cb6bf23f72caa527ddcc8bc2da725ff1f87f223492e3f8a5ba08d9d903592b4710980183db0df8fd793b8aaf22d9b78c4088cfeb55668684ffbba515dcd124b0bfb2f053c9757efccfa98ecfc189bb170c1198b7132b9f572fc4663f13cdf17f0df6749afc8724e493820df90695e27bedb8e7e968a2fa178e4d6a724c017c174535b3c49d53b78b627918eea9feea5c214891b195fbbc4d77e47c06e9b2ce30bc6bb76e4e6068682092aa1339ccb22ba67a303e285172f44a1008f6c901c6e26e38ddeadb018ad1e4d160da464db864e50fad8d1c1341a1d996e220e6f47a4e3d6dce03de936f19a0c4b6a7442aae80bec84500bac2ce4024876c63b44b05fd44ee51193d2dfc761ae724117768bbbfe139501d5fd2c14e07043303a7429164da850ed5322b9d07517548a86109f33861eacbf8592c0bedb901bafe70bd35f58f757ca8fdfd34450a130ebc71635a8f6e0c6ef44f3130204adf518cb17af8088a9c260c444d9be36a6266e26b6a5c90d607e1d9ee303a447172b4a6710204999616eea3daa1241d6f0eb232b9ff0ecf9a7703f90ea05f8a70897210310be429351539e52a5ff74d62ec8fc06d54e3a9930e96835566e270067ed3ad19e7d2f794b739b63905d38dd3333011ae64f67c7ff8d220d7f89b9bf9cf9d111ce8842bbf8bd0f4994fe29f9cf3c10220886c32c0dfd97d48dd29b7e9c74c0346e6e5b02c9aa2c0e9e682585fcb118018c9a2e882d44c479e74d05c155bb72aa6792b0aab7d7cbdb609973df475020b318acc4c57a0997b2f488fe2c7eced46d3b00037b1760584e8755c748d72c292cda52103ffb3121d8a38365a2472f71d593ca8adfd8860840e6d7f790b4e7982f96481016059307cb02f462cc9df4242f1090407673b90f74d76fea405e998137099b27aac0de5ebef465b0f6561ad4329b2c53c4f8939588f0ee56af7f29cca4d9266626ebbf3410a3c89496642f51a3b7027efc50cfc4c0f636343c46adbe86b3700ebffc5e3b0d820d458db01cd5a48fe2e4d916c7e06b82e14a4e169b5d7ab3187bfcd1a8bc9b3d391bd1741d02c32b43175fa0b234c4ad1ef28b3e89329f07048f2e5a8ee393d21d9eae7f64a8bf3c31fbf628623e9903bd6cf01615ac9238efe2ca67da5009cc68d2c69064ef0483803774bd9f077dd66405e609f1e550bb9f010224c876a03efae733a203ca4db7af139a66c57192a361e5fd10cdc8ea203e415e931f66fafae079d622317b5b6baeb99a1697a3a2e6ceafc5c8a0780d8477a4a69d76288d9b73aab57618667333b1ef0772b6d0daef668fb078f0691b9ad0315055e72ea6299e14f74b67e04bd0fc8e3f1475161db03eddd84ee896bbd7385ad06de236d5733eeb333204f2d9ffda15dddf5136d9d122477d03f417f8b4a6d75c475c3f3b98b49632071014dcd8c0d1a18a960837b64942968f7ea67838fa0dead6dd7d3b8822ee9b75c414216badcb19a8366991308fae6cf640acbec40b7b4f8ece43abd79cbb4658375ace5cfaa6a4da7fadab72608383f56f3e54f6ac195b5370d2a467c3d470c1bc0c4fa825d6b16bf44abc041baab2b31ef71438e59e661ac71bf2e144419776cac3f72456f1209683b1dbced9fe9b9d77b86ec62da3784c8c2db9d710142add81815e4959999d572711e1a9babae07abb997cecc65d3f2e29a567a5839899bf7564603e4ca66fad77c1859c9d39f2c754b83362ef26fb8fc9c469f6445ee1e34ec6c490595a7008a7d99962b015999aebf8fca5c8d63ccb180c8e152f692611ab7f38fa4b473c57e9a3b189b79be976e94547cf070947b409d8cca19734362beed00cc1a8f11a8a26061cb46b6a72bd07b5aabb262f390d807efe38206136fcc3ccd6217172df80e709f5c0fffed3f73328d69771b18fb336b1d1673935ea8614866d597c08cfcc232724607e0027044a10f12786bfb3c4c39eef5c4b0841bc7aa39ede9e93655b4e5438ba86921b8d0a848c1df98da1ee6f7a7feae0cfcb0801da51fb08b6a6f0467dbb90e3fed0db0e7ae670288955efea8ae4ee9cbd9e6e6e64cc0a909d77afd1f1c799b92a670c395294382f0587f7062bafaff12848908df189b4759fd09f6078a20376d1e22c96dda017196730c5bcbdf68d3f918693d53ed00b219826279040820fe67e779b0f22cdde2cc51a0b17efe4afadc5753f3a5fe264e368cc954dd11d7b43c98f32dddb89b9995dfaf9b519ed90e9022667049ac97dcfd986bd78bcd2d28813f04347bc39fbc6f0a2dec80dde051dad3daa926022f657711f747b8a204c5159e46ca785d47030e25c93e22d2fad72245e7b189e1b11c54b8634ed92e9d5aa54d4fe8fd1b5aee4df28556d3a7d260bffd36bb05a9b5bedb2e66216f1dae600348095a4b1291fa6d3b00855ed7e9fe6f8d7d71341eb319f1ca319d942ee94b23767ab6ac5238cb69a6fdd47d6bb42b1ec8ead362e6eb02dc3467614d69b0e10d3d20cf30ec68752f0862c3bad654f7b5873d85fa3e95edf150c0544760739b84dd291c3a12d94d238990e2b82c6cc1c44d153e3ae78d7638604cb29f523f9c4d1fbfe573b92d07c1c50b64a10d370baf2522a0779265ac12199c8e1c0c40947b7c3b7daebb8e7e4fe98ad5f22285ed5fb4f4e5f3b3261bba032d2d00b39b76f9b769e8ad84f86cfb61b69906fac49e04052a6e9622bfefd3022cdb62b67b7cbd4108d33ef1c668dda254a76ab52ddf8b893560080ed17f101e68dec1fb22ddcf658ee6c98deffd054864d0eabf9572b76f2505668c88170b6679de2bc74dbd33e6870697ce2f5c64f64fef2766d4f58bec50dba146c5d5eebe71e86acf4f34755498c850339c8c729cda04d416ae4783c574c996d8490598b1b60e294a487421c5e798c476948edeb050b0b68669397e638a318bd1df43f42a0277d0ad8ef8ed878252efd5133e89eac841bd0593d0e62f62730200385e1a7e196615e1ff9fd9c741d4541958f331dc48ae1178491990a125f93f767983828d1e767075f481d107434b1302b68fbd73bd650257bfe848e6db9dff64a10238710f7efb054a8770cad8081d818667a8a0194cfbb412492ad5ee56caeb11b637a8a9e980f5a59c92842d239fbd717a402addee48a6c01efde62657d9eced303e4773ed5711b44f0d08c24bf21fcb8dc06e78d9c7b543718efa8e94517c5a9d1fcc6043a9e62fed4b54a7d704e1eb5f4c88a349eb0df9ba4eac12e0bfb6c550988deb54150836d6f244901415f1eb75cd18dd5d0f4093daa4dfab1438877511635ec89a1af5b8d62698a6eeaa72bbea431bf88367282123ce774958aa539e73d01d473d3f2f3e972564f7605fbe82afebab7dd6ae53de5a3a49174ee4ee3a67da4c58e375c410bc84cc8a9acd89efca8b7101cd2cedc38e4492b9023b40276726fd9c4e632c9cbf9714bdc573d35e208d13a19391022008ff9973540dbe3e5339abf08f65f2b9c97105e0135e247201ffe9b91da7990a594285e0c1b6408ea9516989814c52611433649539bc19e22afb0ee89286737768cb271a436bccd478976692adcb63f5c1862920ad93ae9250b68d224d51cdac45d1c6a1d22eff05cbb40383b3a9b13caffeb3d70f5a1a8d6be7654cb97e41f61e7557dc5a3394448156301fd9f61f0599415f3b4cc7fc37d26ea4059eec1ed8478f0f850c9e9020b4e2d25f3b61f1dd1a6640d7f6f8845f1d97b177f78c82f03409c8b5dacc3bf29096ab543b920725367cb35c6aa124d11ce5368468b61a5f96eb5727257e5a5176cbb0beece9e4b597db9c0c650c59e3a1e91068916b6d7768a28180f2e3f205806b23adc64901ecc7089b1df412435d068ae73e41b6d757d21a4b76cc53798b524d3173f55fc891f286bd97dd1e502e628ae67bc678490aae404d430cf4d70d825919fe0a0cc213cf7a15f6cff90b52a0e7d4da7854bfdd1a972bba1152bdef845254c6bfcdbbe2e40f5aea058d9baec400f8f1c7f7092448c73d387af7b1a6b6defc492e20fb8bab3e18874aeea57796ff2a42724697f5128eb59b70506295b70679fa548a4cd08b1c57743fbb257696db8bfde4f2b456cdc8b5fdd73eae5179b3855fad205e99748ebbf559b3ac3f8dfd14a8c04bd9d3406ad4b86f5f0a26f0e6a350f13d7bcf7e323c31ab4dc534f51ba998e6c439cc0160d04a4e5109e23ba4ee59d0bc605f3005ad88504ac2ebbb8d6040d48cce4dddd6c3573026f0e2f967fe8482680a6d654762ac77032ccbecb0560cbcf02c818a572abd575148f9ce555ca5d36ab54da6da682af7cf1709184222281bd8b1fbf08ad185fb37f1c81942a1cded902cee4b86abbaba2d74c681e014c21599d841a8da4f438e35dbae3bfd0d5bcbdede969fc2352c8e44d4f104fcf6c8ae1d78ea72a191fe169466face98638f0a56581bf188e7b453875fa5c8e186fec71ba6d64f6f30b1810b47363b466880f3fd2b205d7565ea9cf5cfbf5cf33a8c5cff585c5543f531e8d3501d6d3281faa46328c0a8e85b30b1cfadcf08919bfe2a380d05e3c00a41fb83bc8379adb68b3ed6279b7e9c85319871107bf704e9a98f631d8574bae443ca7ef38df0b56c5c82a6b87ad2cc284da223400d4934115434ee6584de9f00077517d5a1107491206cf5eae9cfcb462324856990b351c02b937bcc3aa59d139ac969061ffee4e37e1b476fb0067145d8eae1253094b3ed68de569b1a74c167c13ae287bff2cbc0f8a1edc3bf2012708a88e15ce95f36fac85243c211a44f739e26ddc33ca81e7eb75d20645d7dc6be9995cb382218cc67a25bb91be94633753791b6c9ce65a2e8c6d3d60db536307e09a45e0c1823dca78987601def5a66586c34fed4179e4ecc33e5d226e9a4ff4ebdd92e803de3aefc9b2c741ccf1c41f4d9acfad55c3f8b71525c80dc6526311e3193f8d88dbfc2185e6712a38ada399fe0a8af44f05007567c9bab2b7da7ca66e48ee1b963f0a10eafc16859efc42eae8aff7b1c653218bd969882363d008b76f358a22de82d46a8c762a00b772dcd6d8f3dbb6cff9d947530ef7e2fb384f1dbd344c3c0da4240b509cdf4c6405577f9a18615d733784317533d980fcaa9385fc804c195372b4e412cc47a6407ab5304f4073e9514261fda693cb49b63576a8b7659698a606c0b743a299884430dbde41ff2eac8def1f8ef3fe240ec377e5174e22e83c37570aa94f1072bcd107e8664e4c3fe6a8fe8fb59bef6e59399c60d2fb2c8c25a0436f9e829747ef53748f6494b3e68ac8a74f5969af2dd98b26873695ea28f4442d75eb8ed1c76b15c17613229511132bd3f4bbc2d69854f587916431190d7a828b04bf5714bd1349c7c43e21a8b6df99fc3f6ccdb29c1a3561108ea1f067cb9d48d964c2602678dcd199171dea898d7845641bb89729d5afb91402c34329629d13211029660479f2656d2ee2a433f8a0574a8368d65ebd31665b321568439f97497c3591611c994e4fea9eac465c91186db84f9f35a5351de4a91cc4b8bce01fc1094056a07beca899c4ff6486ed585f1dfc2aa3dbc24fb2cbcf495e2b9f1ef3ce2c08bbf5a41f676da382c631ce9ebf277cdeed1862a73283a07c8a394d2278304ea6ccda16963e1d15959b884222b962d213a848acdcb86fbf8f8874da26734ec1e5c3124960bb2de0abf62701fe5aea56c66fcb06c8e4540781bcd8ce413227dc83d877bca861faa8e669654495d61165f2e2b67c10622cbaeffd54433deecded2cce36c79a97d97665c4cfb50fd8547f00f715e4d4f77cb37c2c9db0cb646e874156717619389dbe0e336176f721684dbf9054d4866e7d662bfe8a706fd33030611f1c3b2117a04f56f272cdbe070f1f16bb410591e41e39f84f04a2bb01206c88f88bb80b525c1144efcea26e13e50a3a191628ec8f0ef43460d9fc777b56384f1e9eb234f0a48a4c30999e73105174f645c23cae47da64a164bacaba6f1525c6737ef5a285141e158cd2d73aec1ee67147fe0b32d3ede1bacbadd7e8d71784efa5b2ae0cd62a609b7270e09ec647eb207f7618183101b6e0e8c00f8533724fe34c4f87c424d8b135cdc400d0e088063e8a568734ef54fc457228bcccd1f0e4c2cc0003b72f56612b8d4e9d1a19e3e1b4e42827015e5020a5cc71847ec3e567234a38f70f869dd3fd5084ab06056fae2228a0404aee871979fa451d57e3db91a72ea40a3b99502e7dfd6936f24f51e02df9a4414dda10f11dcf56e617609c2df93f4d6a166d781e4b4a4b4a79e2ea65f29f443cdd2b5aa3d0bc333931e38cbe29266cc0defb91580bda74d37d8a7fdcdf4b21c30a039f968b187c9a44e3b097e5ca5ba5406bcb8cd18c25ad68dce9ac1390b39dcef5e0b5423d5890745069ed90893940781425e091454c4919d241dbc9d6194b792e80e998d720eaf4a60a1857f24cc9a4314027f2bc04899d16d9b1e59a26f2c48bba5e59c54ccda016321f491178339f7bd499f3dd3ffa8c835d1cf132b72fecb13e9101ba216c11a4a3c66d69e3384bb797c2c4b303df78fda23aac05565597a51945e2e0265590604f8e64392a63c7545e92147be36ea022bc3dc2c594b367aa08d75fc87d9abb0b075fb58de503e9104ccb989896377fe944dabcc5e427b796c3cc99a09a7ede63d86b2bd1f6679dd7262b240d89bcaf64bb1b452d1fdd4a22d29480783c03f3d18353e92c1b623cd695c6de9a5d208a9bf8215775b66adac488a765dacc14877999874b37e2d02a996c5ce862342e65ff4c759076f805799024ba245ec40cc499e95e6b314a610178d40e46b80108405ec43a5ec8d73da737df237f100f2525e80ef32ac2e75e6b1c23f27ad9fea3ab4f796722d673eaad77338fbecf7d7bcb84d974941fc9e4a28a1a1fbe06c4fed8778751f1fe67f2246f140e3e72c1d119e6fa04f1e50c23adc46ebfb3c877da3582413e00b52ac3e531dca4bb1fa719a3713270915e5e6d922adc4bebed2d52642fee844adf3798bd7ca08341cee97c1c6ee947a64a9b869c217df66b56d40e20ef686cf96ac72e68169625ca8e475bff2c3499a5595c856d34ae0b64f4094e96dd5560658c46582810ddbe2b5334691c2fae358bd96452f9693049715d8545bca1503d5c94339e90551c28a399296396c4af1de2757d563d682030620435d20f84d67d8dada1f3a27daa70acaf97128c6819792f4469f929adad1bee2aa97dc390c6fa00d6394328f456db541056fdfcc8d0bc0890f9bf2b087c3f5889886cb11ecd33d456d0f99ead9b787904c7f580e6ea27ca56a982ee7ef311c3a067c45620d784acddbbd515c7739ce918917c6a938e2b4410994ef4edd689e3fd9baad6b4c70e2f2eee5eb4f2610cd610e8aaf85a31fbd15f26f254aceca11888c358f8cf0b499405f1ad30743c4444a85c7dabf26a6b577f10eaad7b9e82f8aff51deac45883a76b7edafe710a77358ed7248d275e7a50cac542645b0219751b027150b39d86650761a882b804417522f3dc1521dbf7278ee2ec9d55181d750eec55035e86412fd14ca46dde031fbd9d3da892819b2d4eb01a36ef0ef7854b236ba4211160a4b9a1fd990fd8bbf2526b025d973fb34bf9a76cfffb72ebdf803503f8b703d97c20e5a499da70b5edd41096d9446329d657e9d52d8466daa96739e3ac10e63f46c9429e6389a1b91008d3eba96c30f19dbf5227caa6c5bdf3e987caad352696aa692d35d06e00d9e21a265f0a665a39a5edb6587e2acafd31070616204091306cd76e928a23c75baeb5d79ad18784d6720cc90e8523d72bc66eb27a60429f4e18b680f2c27483284dbc01e1e47e4f4ef68317f83de41c2aada3e1765e33c38d4c8fca042774736255beda5eb7ba7070a8a042b0159b231bd9896a79045c1d1056fe26dff3743b7abfc5bee476ccb25372779395df015584c99902c97d78267bb41c24dbec9088899be2937a49bb7aa34093c9b7b7695a675d151ad580b6e530b6e07757b39e7c303f8a2ce1276313720ebfb463cb11f78165aa673a403dcfdec28d89d45170b2309c09ec16f915598d22ca436585a921d8df85daaee42fb8735d73437353b296660be4a95e8da1dd96066574144550a01215ebfd147a79eeee21b04db3d7d9256efe12937a989583b0158e59ace38d8a585378dea9d794104905a7eece495dff6fdfe2ad7316c2887aabac93a19054b8c00b2cc2b15ac49efaa3c90f15f2e70fb1eef1bcd255b3798657776ef7722727643c593fbcee3151d9c52f21a147896beb42ec33e243c8cc6f241b7099988cc502bfc5fb2b36ca0d9eba3419645b6f203dbc86bdec19b623a17a96bac5b368bd93eaf0aeba5ce4980c1ab0f215a0d8e28c5df84601221c608fcc3c99387e271fdde66612082f6ed30eb1b76fd1896e142c8b6dd98893110cb5da91b09b20a5fd3e5c5e5ab92e94694c61a4cc770bf09728309c0dfccaae3ad2e92fba3e45f27b203113d0f3790dbc9b01a705bc95b196a3737a9e3a5c4059abdd321a1876c09fe711dd74c07b225949894cebcd91c55230d4da7180ae6445568ca43d6b5f3d1dbb6b75d1d21a0b21fbfb3496568f5238841160b71e79fe011a72c9899314ef0f19cd82fdc2b3b6aa8fc0677c89caf130cee6cc5869c0a9c59f69abdda55a541468d824c49a5cf7af7d8d6c6a8a2f2effb7908d970c0f4f219874d48943b2af2af03f0503354682fd6e6e322df5460ff6465322da6d7c3f97e8d60740d0de6fb539b6eedb04ff9c8b4b0a8738a419057e8616edc46f167d1094fab8784b14a94a6ddfa0004954e95ce39d1cf7f4f7e08f4ec81fc3aecea761da96102316035d7215dc144c596dc86f0607695846a0f7f3a42fea5f12e72c26a47fff61b7dfc1165ab49c2172fa508aa9a6d708c65746e5fe521671ec8bc7d6c593dcdd4141ead3a61f74128a23119e69eec22a1ae816a82048c9d436f205cb5ccf8f93a3f866f3f2e9bf1e501662fca346cb8023912d5cd01fdbdce4373e780e1fa92528c08764e9b69bbe7fd4f14c473524bcf776d5ffbdbfd1e1a36186805c5c67ed8380c8c2eb462380e7ec7ebf79f43c501b32e88fae1ef93d2a6e00c593053fda851d28e748a0de3c2e7855da3822f5c78a5f272ba35ff0d7da0fba95a98db4a4da853be6689b1ead5301d5ce04b2d6735002224d474e0af297dfdb50a01ff08147c11345448ced0b1d56480eb3cc65acad020705fe73cb22e61cffb8653034fafb3ba7ff56239fefc43293f698e7335d65456e96814cef52b6e454c659a02a9d9cedc466279f7b72b93f4d35efe0410867fa675964c5ff5a3062555ba950317547408ddea53dc8ce826cd86393d9a52ee3bc2511eb183bc08f95a04ddc56eb8ae55752f8c5d551199fdcabcd329d80daff66461134fef1e863f994ffcb50041c6b2d228624e90775dd5799bedf81b08bb586260e5392ae4a59ecf2ba57e80439e857663d76215421ddf6264282197a1fef39172b6b54d55caf029d5c3703667b6aa5005380f745e1d069cbd18ecf512ad7ad2102c3a0e042ff4922610ede8ed79ec8efbf10faad38518e5bd9957472b9595e9eb4ec2ecdb97de6dea0496c1d04cecea726f12b7e0bc700076fcc270e4a86806b5ac3be1001b2a45491fbf57f21fb555bb422fc66e7210885b72d88ffb6e315be135ed9c50a0dba80b564ce3543b10103cc584f3a055e910dac29a2cd337380e70cb9b196336bcb48d484679f0161c6b5cacb1bd2b6c32e49de92a4caf47a199a4a452d8055f06abf60cd08d23b7a136f17398ed01f723a32bfdbbf4313d4e6e3defbbd3f3d024fbdf3ad8318b7eea69255b191978716398d316c9fd38ecd3db0eba22b5e36f3e3de24c59a0a5356abb362bd0c910ce909f21d9cb9d4622ed292d0b62aaeed05f26c42806484097a557cf19f35f44278eb05a85443a7b625b4ffbe0a621c8113fc60f944730512e5da61adf5687a268c964a82545166977f2654a4aa9ea83380e981eda3eb66f5a9f591685dec2d9c586679dc91c8fa2d45519e6aef751d2204a2cd46a87344a3834edb034b61b77b22fe5b2c609e8afbc0131c0fda7d6be3319b44e03a02859a9a9c71885feecc14d60bbb25097e0f9f148bec4097762f9be6c4cba7bd40f78b1655852b8026f70ff986c3991874531017e28c9d949a60be99b5bacabccaf38a8b1ac801101503dbe3565ec6cf0d05815d8c5fd29bf38548c0c8abb1a7e4b9d26afdbda7fb82c99bb5798e3f15e259b64c8faaec0306b75e1c79790b74e13c24909169500d39cb445ef03e0211d0d1d620b9b5aaa2d7f8f759de8d6264bfc7de04bf3dbd6728c94b96dc6645d2f6bb16fec0a838333400e1ed94112acea2c17f29f55a4975963e275a76c136de214ccc375474d5b6f77ff6a9652123363353186568ca1a0380fdf2ef4228dbac4ff03c947f293aac34978db81b20dfbaf4cf36c90d7ecfc7c170c15f77b0602b0f3470ed94c63487b8b130b6ffcbec3b66add6870adbbd4e3c7c97e1c9a826b82c2796a4b893314a80c7a15bb7ae07f439f00d81912fd8facfd93c16b176a7b7049790e9c761a5ae201228b9d78934712a7df508f53d828651cf00596c8275bf45380072c6d277bb98b068d86905557b843506ee668206dcc84975ffcbd475a12c1367213b9209e49325491945b7cb3d6177a14c9d4d74cb4c7c4b339ad5247f22e29e421875b8d3e8b4a5d9ce13815e4e96d611ad2cec964ce70c6dabaf8a83aa6cf6ed676c8253dfb7f4e78a7a857d0db508a8717e0df2117dcf8a1c43d84fddd8b7bd24c2e902779528754d5c2cf785756d5bb18d5c9602ba967d46b8405e3938b8afa63e40be8e03438d59cb4638df4b3b8654395e06ba741eba42960ad6494a193dcc00ac87b3c01cabcc622556269946e405ee0c4f2e5b08348ad471c60313bf15546b402545a0e7384759149d85582cee52d2c3e3a36e8e039eb8d2696b02844dc93d128f1a488bc30ccd5d7ee3c281fb94afe62754749e003e75dd1ad87db245403cbfb99370a38caa29dca3c7d34d91fc3f76b2a1e439006b35e217d0977803a47500a81417d7e848555253c4245ab7f1634ec88e459dd20f15270d18477c6ea6b9c586eac6f5db05b0a29f8a88b238ce4dc92dc83805ade10343b0bdd54400ae063f67bf995f68de0b3d0855375ee6ee8b7c65f612d6b794ad8f6d9af2b6afd6045920601036f1d09b1dde1ea18fa2c26ae140eac4185c9572a8f979b468fd2c2844ef86084e5b9c087b0fc6771e142c3314b4e1db9c518db2e6011f8180b5fb20b96a8ea4db012506ebed621542b77e5b2a69dfd417a36cdc3cff3415b339f4c49cbd96023248bfe58fbbe67b9e9df008d5707d9ba4da8996bfc352bde1eb273cfcd3cd2bf3b689280240532e73bc92ea3e48deb4a0261d6710d646d31fd7b2afb583faba5a9fedd9d6023c0af96b21fec7cb0c410810c8016df878d35a16eed6fe2fba06a7a713bbe55f2c575ac30d2652bc9beb59f07d14d22cdcdcea5ed840d372eadf4db1735b4404300a4e447a05bf3f66f0ce0341dca2e6729eb170691e2b255db7de2f5c153d6b8968af40212093017a06d52351d80f71098f5ff17a4a633cde0b4acb3f297186e6f1a26c0ec761a0ce185828edf790b29187f5a5fbcd12183a8fd45394a76801b687cdba296a398ed23554fc049fe5efb8e1458d442812c529df80e0036b5a3bbbe4faa8866ceb3f65e81a70fb72fa5f5fff7fe89d7b038489b6d2fcda3e3e82ecfc567f83a02888b0103f17045454c67a17fc32cb0245719bd38a1decfce9def3b6e95dce05f1a2cf8f408244bb04d867ff0536c80abc7540fb120fd29b36dd23cec17ad17facf3a691af105586c0dd4ae8d50879d3eae5d30730f74eb9a6695f38d08986a7c89565559fcc4357005b466eedb15480e0ce2b501b6bcf88c22ffb1a090d054c2bbd8ad1a5d538875ce8c24456d8333a92f5a8ce9f8a547abd8b44ce1210801b375e48de7e7eb241f132eba145eb2afa7f740808ca47247175ae84b4f84fee661259447db9d4243e9d10f567479f71e4eb4fe70fac9eea509ca786eb730ad60ba70a54fc671423d36e5db28d4eb49a432f1c451b8ccfa03c4aced1968314aa17dc1a0eee7899d69593b76a7ecc60df67ee6fb5e1ec04693ed1aa00ef9a5cc4d900b6b6510d5b36e125bc93eb52e2be36ad549b66418963fe149e7b62af8ee0238f0304721b7cd69aedbf9ee6e594b1b3a437b624c984c9de7919fe9c1d67113a288d793278a7eda135e156d5724e00358e654db53d1a82282e4f2af4dda4202836edcb144913e33b0b66b7c0e7fbb9cfee875c023fc770a65191291b5b813acfa637740963090f744a6d8f826ef3c309eb7487f724a931ba71df65f5800e3c090bab2737f4ff59660acb8f56c4f896ac178c0c06d2457a7252fd902f2e5fea021839a98ccde2989ec4d07d4e46245120d2cfd8085f7dea3dbe9fab5d31050e4efbc48a8fbc560f36783cc8955af525539ff52435161f6b13bab01571ea425da678e63c61ce547816c15be8f5099cebaef526662fda7ee63318eb123fe929bd666b128bc3a52e71c616c3b088b26f6ff716f54a7103c766ad05c6c35db25a50260f29f8a6383094460bac8698736bbde19ce4a53b6656b0db1d38bcaa096065f90c62ef8b49fb9adb2a360aff29216435221ac332cd5f651c2c1635caa0a2486a01a53c62f7b25fe7275c5b395c1afb37ceabde166ac36da9199eee93ff717dda2037ace18a4335f73f458b42edbe5299aa615ee93494a2914c7f10e45b998bea043fec7e1991a96499b9a7c5ab8081edcb5c07efa4b862a2d5d31154f56596036ad8d7a365f8f8497e85f87fdd6ad4c927a9471aac6477df8a95cbf4b4bd2428c98be0e96ec997c95d55407374df5fda4dd6788e08ea400668c3fcb3e68f9480bbd1d1f9659a1355536d1933518df85015174d853e8180dc6ec30582bf3e6e5420f2e59f9733dd9afddf1304a34233b4ad16f56a4b09848b6066105255142fde5127f0eab666e347b9518aca8a9578dd4dbec1f81d28b25d5c005cf29c216c4dd72761558182c36d4ccfd0203aa87fb9dafe71b2fb65f3676a4817d989b261c095ffd4fb621dc0dbc019abaf31d6766aa01bcf33fb8a7205f8d362be0ec6bc7a1bde298f6821b36ba53af5e6d864a07eb9ac3859ed23fd76e2fe368e6e48d4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
