<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0c81a4a2d5de731242f7168d732e204d7281f442cecb130f155b930fb3dc5edb994cc59ad6afefd6a4ad0f23d6377943e4c3de95fafdc4024f9b651eafe47e098c7f62e096683048576c2c9ee1b2f8da2d698dbf31699ee14a3a006eca3b9cbad41d532f2bfd970403066d34e6fa07abb0febae5875fa06ab4dd76694bfd9f04b40829e0b26e722451b9f897a6b20cd21ac5110e1037398922c172ef267723213d4ae7b9bec5ca1227a1f9fcf5a6d8c6d1ae30a86bfa39defc76d80d4434b25ac184b7967023837abd676fb714f681097a458030671c924e0d90a476a646b1e58b7c79685fe342d51474c6c5450fd193a4437ccf4e63d6a19bd21fd0b2ce9044a7c2225a57f5d99e82a4ecd1640d4a71f2059ddf504efac0a88047ac8868538648092aacd6bccebcfab39a61ebee69276b23d17b88b5c6c183baae43b68d282d98f7a8dea7cc4527865b09fc0eaa29ecef6d8fafa9f0ee93a307cff29b646b6060282bd473ba09c4b007a1fb9b05a7b81d14db07c4fa22f56ead27f0d1a0398ea8b9625d727418aa9e1606b05b057a8b99230fdd5f707996bc5f3f2b7b8cb36fa838b8985a67266e0ec4dfe2b1559fc0c8396df00c1c94d587cfa1f2217812567dd4f7ea15245f95543a64e2d2d15dee574e7ced38c314fbdf13c57dbbe4799207e41674ee688a6a74aa4b45d31c84c6fcaa83372543b832308691a3f6841965b5481bbb11be25c2b97e55191ab64fb5a805537b83d27380fe0bda419d9fe0f6e1f7d6e8452f4e63d6dea26fd3bfd8fb95ba9a1617ede39f159f7fa41bd1afbd49a5f4e755f097bd5a3968a3fbf024123aa9a88b22db6c5cd0ae31e1fd099518a2ec58439628f6eaa14c038e23a0df06ae52d606c1221f52f88e33aae6baa9f7f3f9393403bdce87c091b2abedc6cdd1063f4c1519fb6907dfd1e70a058497f300d230c33aeaab79724aa4c2ec0bef2cdfbf1b61e2d6d90269a0168dcdaacaec3ddee25ba15f38283a94fc24868277924a462599e7ca12441912c6b5fd30ca97e4953cb7c8ff04817fcd7c74542b83e71c399766aff9865cd4b386ac492c23ace321de572425a3ddfb6a8c57f19b5158187afc627361e22aa2a532a2ebe3a3bceec027806ee63bfcf8678c4530bdc5c29d82fa44e2dfaf0fa2de9e3bd18c8f879edc52d5a903536be714a8442134ce3a344e963477aa7fe7b1c41c4c64aba3bf8792d1c63a2879d074dc92b96825d3cfc13022f3982be28802269ac31166754fe66d478e351ef282531455c1891d8fedfb133a993cc040f23e822144211e59fc12484e202ade737813fe0de20c75513f7be13032f81ae67274713a7ea8e01eb528bb4c1cb20405e58fb12cc72d0f5d92926a1efd963ef15e062a39bda06f6475532b60428b0d1f8d1f4dcc94158d686b93f868d861a8e00b106284fc09994d7059ac13e8b182d5cfa20eb3fa4ddd739caad7d9a05da731e8fc2aaed50a207188cd6565ff9de01916eb5ac5f7068070f7b1b2cba6954cbbc01cba3d01b143580ded4ddf98e675344947e033459ad9d11596c3bdee2943b8c476d3931a3356286fc5f04155199252df66f4131df82d57065324ec3063782eeaff7d43fd9993184f78da464ae9dba62c7c93704dcc37d8b54c74deb21ad9de1165139ea881074ce3e999d727fdbe8b1beb721ca5260948ddd84b10219b830858e7dc95c3ab0b76cdfcbce1857f788c567ea9a5b01298f97c6003b80b30cf84a7cf88b2af0506f166d3606379b27738e125cce89837066540ca54814c347edb55a7388a3a77c4a64ae5ecc776f27e89fa448bf4f041ca47520331c6071550fd2b95a9780c37923203e916c0f5cb6d5253f4b9bc8334e48ec7b0a31128512f913bc9669f3345c5973675002698ed586a1ec00cac9510f53928b2cfda7bdf2f83fa7c584497f943b6f7c5485963a43b8e6fc9c8adb837c3d9d777b82f5e3b35983018f388ff31c6d7ba5bf31faa0c144c3a3d84ed128f16019e6693ba6c37a52d758a198d12870882a1b205244f33e532873d2aa25e0cd2eaa781dff32e4193b422cbc03c3840dd7a3c69dfced5aec9f2ba1cec90a683f62ffad711a7001e3b86a7d07e027c5282ebace2044319a064e2b02be7ed2de002c0f6510ee52c4235ea822ef447e5e1b900836341c94f04d486348d426a72195593e11b44ed33fad5002dbd8249260daaf645d69e2da056fe96e545ec2ec14586c70067d73995d542799ab121afab038bffb8ab0056a3bdc62bfdeafc2feb34983cf9ba338e1bffefa3e183664bff43d318fd81f8e2758521b1a63974bdc4300b88323debf27e9e3c76302553f5d45825f51afd98eb162c6084fb5ac85fafb127372f63e25f7ccfab5abd429e6d4d2b5803e3ce6e808cbafa29e61fcb068c47e02877ff1e2da3bfa3a03d18404e4c914cb6b73ff1593f0e9b25a779c00c5587d49f1bcdf04e4377150ee0510d703f6e096265b6a109818734b18db505befe7405c43f763c9d2d800353c214642866024e54c41c934c0527fde2e34c5755b8f72a015e124dda9397bb025978f430d5508890767e59f725fd4b5301fe5c0942fa805c419a60e0cfbef8a7d0495231b73cbd620b8d32e6bc16d865ef54c335ed68e3d240b5d3430f46c6dec2ef5b1fa0fecb104fce2930d2173087f48e1d9c800bef91331714d129b9deaf08db21101c8d3142459cda1dd162f10ed093014e9e112ee90eaf993f3bfdf7e9ebed2cf952a37c63da0128865042efcbc11e4371266ca7c497d7eee815eb0c41af846aefc364bb14c06c9e56d9cf898110a23ac9dea7462536993f1707d0c18b202e6230e567604a43b41a03b99d8a07fb9100c628c8df28bd4b538a94e326e8fba08982335aaada5307577decad2ae7fc0e47c13157f3a5a62ad0a32af55913156cae41f4dc1172147bbb127e812ffedaa3400061d11a852c3d67b736e7e026dbf009ed4b4bc04b254d21539efd90f7e50ccd35b3f7944219cbe3cb2fd31a488383dc86deba961ec501a3d2e00eed8b82f2ed6e8d10e0cbd2295dc6c529f9d3ca5a836c33dac689463c0f5a073ee9c5f685d2fbfc1834e6e8b5b3280d699079bdc880e694c4f140ca5a7a606c1f878f18c2251b55c949e6eec4822e8d7d3e23968335364e2add40a1c7e69386ac038561b6155491aebd7c65e921ea10405726f8a4ad34a780e9530ebdf4b3cc57495a29a8ab312b7363e777fecafec5451432910ee3e2921ba7924c577e301350b560717fdd0b2e7ca7d7d777e65243e19d799478a50afa25c417f72cbc2102fb126a00094d07950d437ba0585edf9e3da2dd4df9391a00b3e3a65a42a27152e073440b9c95c363dc131764ed48e379c773182dd7d755708df673e732f76df7f2e199d923921a9f478953be876f0a2790d227ee4ce1e53d7bf8b97a6f2dc68f93170ad88e3b367af62dac82e9bcd6bb91ac21f1f9e920f9e698859cde7c589ccf3a5669c13077828d2006dedb05f679bca3adbe89f0f1654dea515aa53a068f80f88a1f4b8fb283b1c4ead4c57287b3f7ee5297646fe1e757c135829d41f9d74f755968fb431f80c446252534013be38602ddea9c1c8ca731be940e9d642ec392d0dfdfe81df58f9e6b0183a5928a50de46389ea06c42c343ea932908ec4bf6db4cc9759c29696dc610ea365e6742af49ba19f4115119fc474048df13b1b958390e696bfd43ee371b9d93332072ff8fa2f56544701ee34a4c33557263780eb503027b5a73e3d35dd3c7fbc448e14de802d6a4a1d9c6c68b8ff413a717a9c7ba7c16b5bd4fd963a740576409dccc4a65ad91b9e684c20a9db42c3ed54325c2ef6c60f9254c982d29151354c358ae3f49409441b9890eddbd7efe8908b0975bba989154daa3ba7285fcf1730c36342413f92d8172cab4d1cd17890c31a2facb8a8f92cd5f045ae8c1a63004233b7699127a6a9387cb46b2558ec98e5fa3edaadd3de41009b0fc26ec393af3ce2947d225254a871bf3b32f5f95d9c14e4545de775415d341b467587cbc0df2cba20358af4cc7432bd92795e963a0cdd293614fce558b8cf79487f2ffa96f349615f2ceff0536aa855d4655de64110ab0ae95a9c3098d59b3430e688155fc8f51080d2d00bab8f80d13890c9fec11c84521681f4304b7ef3c29292288b9d8aabce93a26912f10a9cad9a5eb55e3f288d1a62796de5ef540b4909ff5279da910063430ece68add4f26f954dad7a4ed6c6e1c5da359b7493e3d0755976773decf1449ce2ea118daf75019e36e930fce55ac3cdeed4606521302e18886572bafb238a539aa874d598f9f3011479745520c729f198e5d4369e818fa307af592a4afd40e09dcaeacd4d367bec53a9e5e63a13dcbe28da7c15f7ff86bbf184c991baa33724663540a5eafc88b8be6a95d0b7fed2ec10c46927f0bc88681c7a0b0d56e200fd5f6b220722bac54692f88828419cca72c48499347e0816f35544558d76efcebb85b08f0a11f0abf4ffe3bc2cb1f1fd8ace88eadfd36c7f1a1e90a746a308944ff2a7baef0c9552d7e6cc35c23d0456ac84e01388c8639b703f4f34b1838359e5c7e25657c4c7c7ef67a35a1bf1ee6cb4b3319dbecd177f2c89a7e2c97d314a3600c36426e5e6a56cbbfda614336ed335afbf6c3975d3f0ce719718fdac126578ed555c9cb810860548b569686077b6f7975454f9b85195cd8c74c78189465e32f434fa70058b4078e99d12cf67dc940e88bbab14f3c5d63069deb7271d2ea5b48df336cd25bafcfc57689c1cc6a8303e984a87837eb0f845b95a3ccb3420927198bdfb37d28bf55249d5d7a7e0a982a3a4bab8bad88af2e181456530703061c4c7517d758b047f7cc37c84461f59b7b52957fc20867d3708e58d3a7b61f2408b2911f05baee1eca36eb8d3ee219582d67eae4b8cfdd732e00a7365ca83e621b93d5ee2d8ea21926f2efc900a22c76cbfe5b4463268b0de5aba8033101ebbed9c89b86249db1167370977d0bacc93d8e51e65cb44d4fa4fc21916fc1aa6f1a4c4b91f2d6b76f4254fc12cda851e7bb064817f081e9844f857bd06c0b623df4d5ce70dbd1c15dddf00b7d4f940e214ebf5012cffa1763041238c570ef227187c93931352671861b5d7c09cf2c41597d7f321f7334c2942ca01d908a5e0846b0d89da7ea0dfe25576b58a6fc7195f06131b46ed6d3382bec89af1b5c93386a9ddfb25a6e62afb7d2dfb17402644b73ac4513db81d74909f3a244db961a681fee971d107a08737a915f7053cef895ca59eaea7c921e799048ff3e3e946f2c4de0c2000a82b28682beb9287ccb8fe12361c308362625900dfbd167a57f85927510a554db8a869bb7801b8fdf601b968a532c6aa846510575d981ed5b76089f82b27096ad36e25b0c1481353501b1b3648e4ff2d62de316f47b8c65e1445dbbbf0273c0dccaaf38e2e3c0219a9b4d0d0b3ddae2bd91c6e57dd5ac7358672a12099f691147118d26b4b07080cb7d9da7f03f68562148f8387cb6332238dc6f21c45112470be330422cd9f4d1dfc7d56edf0da70a10afeb1d1207d7b939bec11a901abc5b80a0950343c3fe4fd4c52882946d548e395a06e92aac8acd4cd425e09ce814d93996ff6ae0c62e8d0a2049c37e929e07b4e0aca7cbd310ce7f186322a5c28e4fc83e73026c981a6bbdc982bd75d51fdc754d3bd34f1127dcbe1a091a46ad59ce612d6147d304a81d967828dc22bff68566871d28bc94e0d7489f0a4a18014b1726a48e6e9df9dfcc2efa445d54fb4d1e46a4182cf5647fc0f8800534f51a14603e40c9f57bc73a7986365c691b172b5b05241dcea4efaa72a6a310f59c97ab6b2aa8926ec28aae3194ea34914ad41616d4b9a528ff6a754a06f5e003bc8112397a706a5cc8e7f3d91d6faacbda0e19b4a7122a3365e5f42badc71281b854167b26f7058e4485f14febce59b4e4ba6a143b6f1d9784d2497671c10178f589d4c01b7673652712fe9d82453d557022d018bff72d93af7f17d28bb1762223b6bf13f4a783a91b3dfe0b81e4fa76a023fd2b9fb2e2d2e156fac6fae2de61c949ee94aa0a0387d0376a9b5dd5e4c95a924c4d2067a056e0d442b352aff8447303f2eda95c8378cefde564a30d4acab8a1d50297f3d8a4e198d03abab5c0db73faeb2ec58aeda3b8a590baa3e17882c5c3e9de5753e1daabcfdd109708a4c7673caa9fe66ef283b2296ba599b1710fcead914c2edae1f2e277fcd457e4aedf3d991b6d2e7eea905d53d2d87a2efe218974efd58a0faedf64ced4bec556be507d4aa6256c932e01da9659efb2d270335fe37b70997668f4ecde0d5056a92290eb7ab49b39af1f47eb0d8cf3de57e7baf38860fc4e26a5c15fe7251f842e7cc204c01c607eb2af97ec97cb12c88792339efe3069a4ac492e88c193fed38847e82ea1b156180d1ba9ad0993fb5a2f482455cf8aa70bc805902f620de663668b7bc86a62ee9ec161548e7244e6b8a007ddb06656de94aee68ea0048507d76c9d4c1e8158cef007e9b1c68de85a07f1fdf4c2e72142e687f51b59c533d19b3aac445dae961cf4b9b352d254554c4fe156758a6ae2a75a0cef80c555823dda8178a2fd7917175001d862ba50efa463a968f010f03db094b4817e27b79eb0994954902f0fcd3b158c1a24c9667a4c7f38a7f9f79623a4a010f5ea15e12887a512bad4c2b947bc565429100a28b25bebb0d7a778bc436f2ff4e84d4e75006eb33a6df07a4add125f9fb8c08d856be236f982845c1ab970044a36db5619d72cc1080808cc5d20a07d7dbb1b55caf9bdd05d1272ae590b6eceb4b78c142320f886439da389a95397271728f8dfacea59c4de2e076c2c6fea8fdfc06b4b3be48bfa9dc8951a919f2f67e367ff0fcd57cce2721dd5ee53e80c3f4556ab62dba6297a06272224153fd960729eb3bdc7a9bea113ea277d298504e96bf801147630aeccc120c944ee91ac0b2720953ffc75f32991889555cc32fbc906475c91470216b1e6f424115348a5ab378dcd074407d51d636faefc34d96fb63273dfeedb8c310ca6a9428903441ed9d97e706b84670fc2332d633cdb4c69f79edc03d4b2df71ac31a7ededd4f151f7e791d69b84b472d5d196327d7cef6d524041aab6d068f6c66e48f2fc90c6a96100f185bffdc35fd187cad192eba4b1fbd6195781b827ccb2da28878157db6269c48af0fa9babf41ac34498bfe5494996b02578bf97137fa069cb0865dc42e01e3dd765c3c2ef63e12cb4cd1779fdaf2b8c517ad2625fc582dbe6b435360d8563815bd5d09f80f3c1bb410e97c6731797403fe73f0a1024ae3f8a001cd16e787780054d6b608120b4873b9cd3e94c838166c1faca402f142cc6c2069a07a964926dca89fb31231c736c2bcb0dae271460eccff76d74257662750f4e73d05165261267315422f7b00b64f1c5829a78cbeb8f29653eda5171e3c2028ef618d45b4963a62b0f4e929b232a39e19fd893ef9850ee8b5b2c3a6b3889dc2fabc938ab72c9f2cc0fd6debfbd7053890e01159c8ad70ecbffff87f542942972f33d37a77fe47ef0aaee0bd6abdbac2377e4c8dcef9f50edad847bb995937efb8032ca7404454ea4f3235b1a15af5c47f8c7ff437885cc16e2c51f60f29e1542512ac4bf92bcad1b63aae3c061a59d163afc02cba6a31a73e153802acf34214670242ff71912432386d51b41bc466244ddb28e261d3c82541d10ca16e71c1b6282995370d43e3f86b0cd74f692bfb124db7b69a8757dc094c9d0602476042dd57e84c326fb59105e9f9d738c038095676786846048951e59ca5bed531bdd2d9a6bcfd4b11985c5892138f27f774880e75780d536e2aaa656543a0bd73e283b05803de907e29e00227c41fad9489e46d80a4e6977bea08551896bd6fba8120dee66dd57a48b54895af752c5ea7705eeca9c877e6896959e45b99c1bdc734026e1fe26b25a143fef4da807d555bbab7591e23fb219632b09e0cb10fb5e1615da329b9347bdcbd4d09b1bfc07d71136cebed9989e72536fbceab6b41a65cd1622b672ed0d5d9ece6675ce44e13a04fad1c9f7ab4bddd7ee03330636184be8d05aa01011221ae352f3d60de72650ca3a0e0687222e0c97ce16532358a279e4e3f1250b631672e9896c36125c7f4578284e0569d5c8c302677a1f3211d425625f7faf94aef704879fa79028725c88cb59a19a120fe24979f3c3d8404e84607e2436d785329975d725d5d8bf21529c66b467345c4327000ab8f94044664789d3695d1e7eb69f0b985b8f70a62a9a834fb76fa4a0fe2d5b34ef1b77aa8aea153970d7cda29bcac7f7fcedfcf4fd23f70ff40f74cc3007dcca6bab2abcee88be0492967d9841500a5989481229a26b133b40f425ca2676ac921f3b9dde626ad516016fc4f4e3575adde205ee23d2065bf948a08d038182677c9aa8838289c343649e538aaa119eea551d842f23d5f88d527db982af02e609e53a5d72590528056125fb2b208c49e8d0d325aa11019c30b1ebe4c2b7e29b6a28c63f73c8ee2982f515de5aafc222714870ac9a7461c7658b02dd7eb5ee870b74bc7f4743976ab1c52097bae1a1ec0441475fa28cac69b1d0711f5a10e54b4f2b779bf58dfc5d6313b5cde00e7cd6b79ef50f7f3f754041f18d9c02e5a028ed08a1c9a7179000d6d8b71051056d4b643981b7a5b72372409a94721792a3b4d50bbfe28295dce40185b9e566869848ef08da74ba45e80d04ddd5af8f96a576b8764ead3ae032e9c36074ccf579c62fdacd955226af36bbee5815bfa0ec4eacea3c5e401cc0709671e2317285d9b1de70684db72c65b2c97e4fd056851259e5b2a0c1ccc26d1c407ab4bf88b72cb7051df36aa0f9f50ac161339096ee45d39cc9081f32497609f70f2310b3e6281bdb1b20934f68c30131a039f4e991bc10aa908b83127aef6a716b0ff7e121ef466e1824cc2a119c7c96db99f185ecdc101550b8bfeb85d5a541c80f5a6fff7ec49325f0fdad914267ea405de58992f59ab147c7478d431bdecf25f92b103b5a78042727a4dd2f85cd146d74f059cd4755a8d4222ec7e69f36610c5fe3b8129f934a5c6aa20d89064d5134dada8f988e3cd760eb7898215232e9a780b0de24e7ddb6ee8100c618895eabf464be040c952b18c26abb913089468f14e2ac5852cf5b49908ea2391599d5029a66d2286850364cb7d93770a0051c600bac923a2c1817b55c58fdea1c1a6dfdb72dc2251ead047a19e8cf80572c134918ac768bb10ded461959a83c1e5d6c2f3ef5bed56014f1b32cd9bddf3d3f83c92d35fd7c735162b7d2da16852e0f47742b5994e8a8525ea79cf0b9b5992e49555e2944ee50503502db728ec9931ae3ba9373ef8cf3b7afc344ffbd4005348d9b73b0e86062fed972717e5a67011d4e51895013fc1f71d23bb436c2dbe2daf29ec3dda6590311cc9744ffef2c447466f5248498f725d701e4ba51bc8f4f663e16c76a6a12dfe44bb8bc0b4f328e499bab2b20b6114772f5f7dc9cd5adc24baa6e18f956d7777ff0e27eb806b0209f1c6de2d5f868a035096153376f71b324615713824a6410fc6d7c9f9c2f20ffad7237fcfac68cfb8304fa661626f6f9e39aa1fc6d285b3c6136cd5b7263cc14e440e198e0f5e4fbf4dadd6126fba8086341660366ffed44dc8b6ed4b29d34994c1595912f3f84b1fdcf6b28393b75a6b1c00efae4cf7f1c8da92fdfa6a7380413f9a64af83c2b4374e5792222b62576e0ae2ec31cb5f0078f1fe57bf6ba6c736de0cec9836a58a37aeaae2d0e7e75cef3fb9e1ee5eaed171134415b393dff677d9fb427c110f5f46d9c13c8a230eb26f7a617b16cc0009542fb7cb9885b3da2f54006986cc833183618981fbf776c70c106a9e605df9ca68f87ba9bc5cea16a27e9e580fb040b2fbb17564d8cea38f36a121e969f9fd021290e74fbaf7b69c4c8506a8155ee2799501fd68f8d89fa9f20078246f47baca76e53a3d0f7d7b3e0e15ed0c96ba80cbb3733a53a4379ed3f6aae3c7d4c8a4a1a5ca0e64a278ba16730271ecca6effd9011a1d9c20f9608a7f6e75a77ab7ec7d8b90f6a3da3989819d45bca7a20bbff3f64622f1ff33d727848a1a2cf98a5234d32dd646b60da32a03ef6de66613d8ae7d55873396da3343abb6a7bc74a4ba4226b362a10b34664e73eefaa9819d6461b8aa8422f1b06a5d9c28eee66a9ff35e53551c7ddbc621c0fffe098314562ae75e702a7a81e8daf288051cd464f65ba776abf221078e511ae93d15861e6f0604bd0e1973495d7babdf02b5085d606bbd646f379304c3758d447f96e596d1a9970a230cb6dcb99d014bb7671cb79ab4be87ac7df9252f5f611ce2c36e8c5b6345176972ca3d3764308722ea32b549e9bb4e27fc9c4ce5647f74deb8177868a69ae45fbf2cb539c18fe56170c756445c81da99bf713eee3fb388b05621238beb799db48868d7bc06532fa277ad59ee451c01bf8018ee8fbcae0f517927ed4000313dbc1cf972233086436a4f74fc79ddbc6fd74abc8a8a09bd6c896479daae4559b085f1b38cf86b542027df6593e8e6157def296fcf27b6f4e469e4c0c7f350bdbe81aac3d93238a7cbbbc9ab7708e582a1c97931d556ef0edef7d08d30ce6f92219425cc7bd7e4e96d40a6bd04fc7662e08ab997194f510d2da11e59309a0638832d444288096d3657404ae6a0520fad3294261162a2bf708ba350952a01d12f9fadf07630e6fd3c02b90263dbc1c0d45729e9acda24e6d14685b1d92e69c7639a03c55e161e2ec4a33e50c3d0d4feffd80ebc444a9e8b607ab4a45d8c7aabfcb7e2e3c91160cbe77823367c72af4229f7d4dc0401ddf32c6da9bc2086c48aca9077c41fe4fc78ab1424fb2e2a19cc1d074bb96aa48640d6cb44c35ddcf223cc59255d3c0b1872e55c6687bbea7c1d446bc395da72e1cce7587af1b523aad6851e0c2f83be483e6a2d46b2ebd24e2b818bdc3cef23be2fc89e3e0710b2b46a67e06955f36ca9231d8a32b250b84f3f8057e8f329718b1ce0df08ebdc74a81982a9f7442a226a00d922c199f0ca7fb35745185b3198e58e7f4a653fc9707e69be19fe98a1d98aad988a1e420ddf9f93fbd00d27914ce0fe7b4279969e77b9e4f4c4bd675d84a71f8467adb87343895907415594e58214d772619df2e4eb8581b2f4313848abef091b763f16d93ccde8181a14d3b1ad85b663037852e64ee1fe573928f835f2803f620f15278b524c1b24c07ab5f97ed92465dc3fe82b886661578d2c150ded97249e5e298fcff308932d565adb23a25543ef9d94f75bedf1d65cad8735f69b84a06d821cd4beefc44943dc65cf81946c9ad5714a5016a0550a1dfcab17c391f6ad9e812ea7473daf806f1505148460e4192b7676e5a845c358a5759cf03451c1e73a014ab1bd5aa7db2f6a7247d350f46f8c60a730dcb4e17dc964388102fe2865b5e2bd944dd52248a0cc986aa5b4a0a9f2662ad40f099e0ff976a83240706883a20d859ba358334b28b8dfb033ad8045f8b5dec70c2cbaa94dd79d13b328cc3a32a6a4ce7035791acfe2c6e3725c4e97560865d2f187307e1269899570dfede2f851446657149e1db5102c01a640ceb32febc9e45b821d908a5ee2c04e108736e088856656fdd2810123d5c3f16a3131554018b497ccd494efee0634f1ce63ea92efe2e1f50876413ea8a77e6e47971f625e7ab973119d039ac024caf0e85f348737c8047d35c400987b655f0b29ac772eda87e8b20e01d9cafa979e971eb19fa644e962fcf6efe6bdea3f4c0fe6d14e505adbfe6063fe6ebff06d397f2b9b7524a350746f942aaef65d0cbeee2f149f00adcd0cf3eef8fa911407468ad82e4bc974deb06bafd1f21207dc89005398215218034817a2aafd4ed88e43068d8c89d578877b445476b4db7d884ccfc88bda70f107342fd9a9f628113531a823fef8d9eee5cf3a15001bd7a8828da0aacced3ec2fa95ca5ad71c526853caad2ab62e9d8b7d3d0f92cbdc6893241df4e7b3929beef328906886ffcccb38be46c1fab50dd52fb41b147bde9895e57d9d8c9d50da8c62bd3ddaae694304de0e8b31f463c8ad2e3ec6f7235e636518e11cf9946acf25225738d04be8af4452ae75d377c501ca3f49ed5e0b7e9cd359d939dd647880b2ab85b5aaeb0f1683fa8ab3597142aa5a14d275c7cf3d9c38a8e68a7430a4c351d0afa004d216f1fef69a3ba17c477fb4d5e3abdcf677c0af7b675806c605d903de1b4253bd297bc098e603f62a90aaccc1c49be90c139778ffb6b899e688008dac15038c2f928e62833b624a4490fce0f6508f720844b16c185fd297ccd32b60af4805d9d55c28e80ab72ec153962b1805ff02354d5a7fed4191b9c00eb05da1686343dfe1c7f0c1a4a72ccd55017883f3164f84eaff5d1aca39dbf8c32dfb73efe90330127c21a656f361809c5debe1f359d921b80de683ae553e08ccbe0d74ea790672b4372754db993f0ad6e58bb371632108acc4b66dc1f073a3580307df8815193233fdf5cfa9a411f915c47f49f056c63eb9db32b7174c05c948bedd2354f0fa4034886bf9629edd5b7038f554a036c678193913497a521d395af7b3d1224777039ff9727d39cd4ea1b0b109fcbda7b1724a3af3fc99e0f52e158346906c28539e123c778d24e7de9401e7e9d3f0ea7a349277bda5b1e3b939ffdbccc944d73404a89876c1c28ce6384a29d9353c6cc89af7acfdd2800dda9ed9fb14f32d1e3804dab3d789142774e90384ba9e5bcbbdd818f36487e8b22a72d7ad3cd65709008b5d313a4fb613f5302dd5ce90d4872d8de5a80ffec0b43ad63370deb9d18b628dbfb43b6f3365d0df570314942edba659149dee916c88ac1c25d78a5010d05cae4998738ba6a91a57774a84a225b05813ec7bccd849690f5e5c44625f8c73613f7de1a2fadd678be07e21cfcca1759a5c479bf8f701b4ac9f1e1a526009224f2e20c0f04c779fe0542edf2a1f4186df19ca871f18ec59011e009393f7e74e2f16d48d8d37c75edc4aae922c5c2151a5e275608dfc712fdd5dcc832bd05b5b8221b0ad6939f0b272d83bffc14bb065972f2b33edb7ec6b24fa5c8ea8f9a5512f19b26aa63b314d1b487538ad233a4b646b80a9b19b78f359ef4f98bc92534b0aad58885aefe19cca258a975238503b545cd33fd02f3574fdb48d26e0437e71f9acf15e49030ba196088b6a87df565425936922879e8d6f32a141b388559f790dcf59c8cb87a9fb6b7324ba840b261e6eb0c8b96dd294c1a40eacae2dbfbf6b9aedaf1021f54294506f2849d6ceb9c674b50e92d71adbdb8f64e4c77df627e987514ab9a17b93d8597b521ac4199e7d32c72c45a7b72b81cc350a89393057d1178b86c042bf9b84f511a9e4d18e736dd2ecde0b9a16e92601e5fde0a321a630132150abd359f472803c394cf8cc896e6aed937f13ed0cf2e7b147fdd75411f9ca3731655b6f84e25bf4e7c680ed991a682568063ff99b226ae5ad07ea9a47b23946f07493cadded20f6f8880be68d6edd933db9178c21f837eaf98cf63068028bb86e7be8cec08deed4105979c2371845d835471188f44881a3bed2f3ec9b0d3a0fd657f2ee8b9c6cabf22703783859fece579f26c5e49c1281a39a0ebd61e6ef9d300828bafae93c2adc180c1feb37da3a89629054a4901ea4f000a20d473c929062353dabf47cb15daf27b2b1022c86f1390d9deb03f8efa66e08088416b02a5d55dce38e3dc8bc0b4b8a282353811daf7ff451e48e4b1f509ac9eb0c4bd3822c251eaa7cbf3ae6c6e6965f0c57d03b62f1c7fee0a56afe1503d19195d01d183c2acfad866594e324340ea7c3bffdd12333b77738e4075ddb833bf5965f438284fa07eccae346805fdfc740a2a477f8b85571d5273896bde20b86b8901d002458ad6ee0ca918eb09ea2c4980f96e28986ae32aaf2ea4e16a56785d49838bf9a17c9c0324c4ad1af84570e1b675cfad3f02be23375eca783363b00e1880ff01eb8eea5a479a792f23095cdc2f4b74be6830a6f37b4b355d2a9cc45ea77a279a59516745749d49f0a1cce14118487c4f57c1d35138e65d63d2f5a3ff13fdd021075daf3bc010f71ed311aef2958454e542b04f069547d67dc8b46d85e07edc50a3c670dd49c877554a3a21a4a502c98c1556a904ea2308f140e3c8cd79960b7a0e41a8ccf414607548bf274779ae1dd9af4e7300d06506376ce7fe53b50838e2dbdf29f411588c6913985f6f9ef5c7a49af1b3c4d0c36611671a8cac32318380debf7d9b62a540bf09bbdee70b0566a90e72190b85d72063bcb0fb68aa36ffcf66d88923f844962305f7f7b81b2bdc30d1ad0e0bb61655229a0c2cecb91f71efc5ff2c524486a133f2f4153954da5ccc35c222767671b2c1a459a9ad4b8b023f707c786991ca4effcb7c2e6ba71f142c9ff4117a70ecd9b8b78b0dd7d53c2854625fb3a6d924bb22133900277b63ace091bf1a1d84d667b267bd8292a969a8fdc702878f3714cf8e6eaa8d0abce445069272e8019933a1768f747e320ea6db44950c8d74850243ebf7253e3764bbdd38e4f4d41bac53525b84a40fa9957c55c2a9d489792c1f2e149fa3710577948c5a993fee1a73e04f306c45baba219a59ef1d9cfa9745e506d4fe959103564ec08e2c35f732f23b48653bc6b6544058b9a0016a52438e518ae42c1e2cdb22e955323652b052d930c015d36f93d1772ee864fd3b9ae2927935d00e59e23902d9b7a111ae6719eb7756aab99c97a33d0fb0c75ab443000d119f3fa0007b9b362ac6f7e726d0714c9c6b67594994ac0b8103a8e23a7b6b912e55f10a70a887c124eef188ee8f28ae3b5d44e58389ec49eb3f28fdb4e799a537e11f04f01392b2ed293df2aa5d7d74bfe480a49a48d3444ff3bf2a7ed2eb67a6c54c1670eef93c147db0cee44833674743949720a368e5e91577199f013ca7fed915694370bf1dd10264fccda7dc0ab0f04a1b0637864d740c351402e2c99ec406a676ef203f597b87a331966bc946588a40e783bf51a131317b8e8592b5d2f6a4d0ab57aa2a5456032b1f6c8ad39c864502af11ba1d40dcb2026248f6d9993c7fc223551f45b4fc37b7a90ee40a0015ee8199d90f71fde79f612e055287543de0ecb74c0d7a27adeb4662b7dadd486ce5d6b98c83615b6dc62263df784fae657f424b71ea06577613345e809450164fc31f0bd82e60d5413a8f26b0bffab4884590288dfc5a26c13b75d6daf4072fbdb1cba15a1f382b579cbbcab4912a387b1922035c7dcc2a5099bd99475697ac3a7c8bdd896032b2282223b325ffc6949f7025e91e250613d7299a9e91839ea38806214c8bec3c9564c1e66c33521b8277e1ede1a32df90e78e06bb21bae86680fcd27c75f657bffd3e5be45e10f7b1f1be1e8daa9a4f5a606204d0e45ab84a02b805c805a8633ffca6269a2e1acc300287c62c947ee97558e47e878426dbab0b9ef828972641613da9d3060808606702fcc70896947bed784e927da2eb6031fe2fd71226197425280c5c51711b873f2b3c3348b9d70f24117fdb12b3711cf747a3a9122cbaa3a2f7a62252946f1cb273027c03f0292c8dda6a5db2d4e6021b11308726bac783ed777a9f3dc3c4c42995a9b87d12f079e4f20cc35eb28733dd98d9016cd8079419e6095c47417386be0699994f1d39342f468e4c8fe813a151e6a4e5dfdd2e67a1a746a149e4f29b607e38e1466b8c2e636deb0dfc38dbc2f97e7e5e813a70dace30885b6796e8400a02f3b5a5ec8f54c1ce8d884caa6f385b0291d6c8c35a402f7030a2db1928875a0664c4690c189a74c972ac50c6623c2c42032fe68b1abeaf949193bcb5fb5998f93fb1ef5686ac31c97da754e02b18efed52a0db9a03e2983c40e42fbb9a808b8ddb5355025f8b6c3d72cefb71fa35992ac899710a48f12fedac544c39c44074308967c73175004c068aed919d4a92643005c2073ee9563acff8143a82c606339b8ba392fcb3c191860734ceaf9f7e6436760e887fa6723391d7d2d9fe76175a0f1d8ec144808b59926094c53ee182e4a2253d70f30e2bfbcc3331b6f83db8a8cefe7afa708f3703cf28f941594e14628513d76292a3fd0a0d3630908a56a17fadb8cc37572e64d6878cb1fdcb7519811179a03376d6978c58fa80aed6f0bc64439d3e6ec0ac3e2ba745b8069a8779a0df2b1be9e16f34ad592454624fbb0d34f1c29d9e276172d880633103b71a8c1b8c6f7252e053c89ba6a5c9f834c45ac98d464fb3e3047c6e7b3cddea02b960b87e3cea5f0b5dfe554e1799f5fa32292ce87169e0351519d48d6f9c6c3ca5ce8ede2d94250b799e116f6896751bab0f0da939a826e8279d759603863a85c8b6454abd8067e6827386f00eee919f81a3d561a16f89e266f98ecf9efa7ccede6d2984d1323369061f2184dbceff4b9b36145333cdfd56bab6481c58be48bf79b0d640e4d9e93951c015214a65a5d3fb4d3a1384678824a839a2d82df914981f6139dc146aea6204e18ce2c0a444f887dba0601f1378f4f419cf18c951466c021039b319fc618b28942e07012040f217c18223aa694000e03d49f0bf09ee3fa9418eb7d7932e014761339774dcb114fbf493691d3b9bc07fe791ec72f04356151a6f6556fd5b9abeb5cfc83d2ee449f3ff51ae439fa85106fc8ded1d0cc3d7a113b7742b4f6a169eeebf38d5d5b34b32a5300ab80d99cd23016e980540cdec4b247a6383b4443911ac12f6e71623b245ea2ab979a29b6a548408480126e993cdad43cd3772381fe49448a059dc0d5a1b1ff39e5d1a889ee6ebebf62a85627f8f4bbbdb020a92dfabd36a0ba69c16353bc50069e2bc89f22f253ef420edfb993b8a12c18703dae914a2d57a0f57f0f35d6746f20ee2e65d27fa43e0cb4a1cc9329edae1045dcaaa08290f51e5ed48d638784e010d999481a4bf3d767d69b894deb8ba1ec6dba380d2c77cecadadac6713c0e9b92bd3b9995a2571f0a38a63ed50a6979b0219045cb93ee9c5dbf12b340801f0b713cf2daee72b75030fe0fd57510a6a5dff00ff060d3b521331a9132ef3d582c1ab56ad67f3bb8bf0139569d8eca4eb32c48925d51df7190b69bd4137812854c4b532e7e17c4e4e77ff4c1222c753f8d9d162ca0ea2efe918dbde661b52dc706c346dcb15512ef4eb15b69a38e1a6e0b02a1e9531405e71abfb0b76e8b3ec01ba45c02d60ce77cd60b79948246b7904c80922d501ae60d7388b7f89bc6eb8903e6b44bd457c33c11f52913f6919ad3900c815bef93a0e45c50176a62f420d15c4cbe134c4cd55d2529345551bc4ae28dd26a1545361c96ce673d21d6ab62d52aab4069ec3279c8d7a5f163d2ec919c03fd885ae7bfe2a556a975c405a9a4d93cf08562022a9d9e46b3e27222be1bbdd71c0daad53dd535609bfe59b129bc93857c6a178a6186bf0c65516346173800937a9a4261ef69a19a89e9760ff68c4630c11f09502ab112d05f66312ceda83fe8f764e4d7cc869bf9eb11600d267b6669153d6809e7b253622c6fcb08ce1f58a8ec482203fa3683f0fc5e79469f69632e4b9a8fdbb729c214dad22db9893d69d4d6e9aa143616623d8578de56c5b5b6243cb5c6f2d25ab997910244b1afb04a6f6c2ba02bc61788b9c7690bea01a84ff3b7c638fc9f07483ecc69003600d90ae90d949aca5fd70a966090256d58fb5c5a772a1e670e1f27cae642ee2fb65415334279e60760f9117a3b2d6695a1af886c511daf81988784a1f447059ee76dd247ebb77465bd4987e2c25848378100b470e59d95cb643f57e92f6a697b961b5f8ac5d87a157f3b206acbebdc837c9665570f47ebb546b6a1ff57ff86f133b306393bd585592161b29c0353f1a5088ef30591a5a45472fc9bc74a25b1f501f0cec94fb5e55d1397cd183d4855e084c623da57e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
