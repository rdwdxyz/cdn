<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"553cfd7fd6dd6de730e1fe6732b7c6af3f71139662642f1dec08fae6c8271a7f462756bf99eb440b86460d8f3a50fe2b3308fcd48b9eae8eeb33a046bcbceafeb874f24f457cceebf592f781ede90200a17f90b38677434f29855b8320858e428fa4ccc24ffcdd398ffd418e4a988155ab2a09db4a04478c1f1a1500a722ad779703c258330b7f174763f0de9e1bf43f02ae760c5e7706d4b2bcbd893c55dd4aeb73483569cae1054511d500cda9a50f0432b39d9a392f5a2211049ef56bba379ec0ce46473ab991ff4f07dea676c34722d2145f4ba55ce7057947aefe6386c3cbeea541a4f85db765e6dde189e70efb98160fcf0d48d3c770891c63c822381e5936520166b1f0b6c2318ce5e39c5cb5b5a7025c64c59ec009203c3cd15ff20354ba68d89ffff8d4b96f110fbb0d79451ff652c0513694a658070737d62719bea58bb8c64a919ad59bbe57f8f0db6f35cb3bb09a9e563f8adfb4e73b31a6c1750a901585f5a3aaa42531d76fce70266aa46fe5d5a73a42e40349142bf392fabd74c10af2da0cffba174674da7106c163a72f66736821e1cb64d4068bf3c5983ec2ad4b06b5c73f75bfef39efb00276621392f5f12330ca6b22ccf7480a4c00f142547ec1a9caf8401196ff2bd5c64b24d921d51add7c4200dc3db7f50423e3fcfa8bc5a3fc83f0001100149568c592b8cbcf3f7de69efc39a07c1731dfd4b5d30cc469972270a29108cb1c62874b0d240d360d870f185881dd660d74e35987a6b8e4b59fac90a238138a00876f6423eaa6caa97d5907f91ff3b1d021610a617625a663facdff7e3bc994a278999fcaea8b0a94f82e33890f7987c97a0a657b2c508df60dd795166e258e0a00181d3c128b20068da41f4f9a8d3d832808013083f6466896f112955b485d95a1e92004b8ec8ff4d210779365e1021a62491a125599a2a175b4c10c19127587744c08520faf49373f41df7e8980c11ac3090f8e58a854a4f2cd22951bb0072df08db985423020ddcb29771557a6706a5b47921076880318ef65cd90ec415819fad7225bb17c2290877ee260a791ba3638559e71c789348dc239d05a61a81933d973fb14111da63406371787fb76bee74853d7cb42c7f2c52ea9984a47e0d2427bb9d68988a4d9841efcb22406f24739b60e5ddaa8e8330db3696d4876f6be47db63340e5cbcc5237be112751b15fdeccae813adbc23d56829621ec44725e9a9e90ee3e2313566c85f33416c8df641aeb4f9ac417f879a5352a1ce792e3667e396bc496728af6c3b038d81ef39db48806800ca18743edfbd2decbe839f425462a619a2fefb77efeb8ab75c1404942068ad4f4f8e8f09613aaf92ffae123663cd6933cbc9aad937c1b4e5d4f2a5a1f4dd0d70f8468ec884f997212ce414e769d95256c83adeeead3098eb90ab096faa58dc77d46a4983439a0222aa4c8224e0b63137c48b85d2c278dd8584da28fa5d0a916ab960c2f9eefe3303a7c356c9dc324b12c7a6bfd7e80dac193d8e0aed169462441534a32be9c0dbaa3eeabcf5489afa7720aa187cfed4c529ba15804d75578e6d5b4a7c737eb916ff1a57cb3154c4dbd26b8e47dc4e6f7f460889e8c067e64e89ba8a40eceef5017429bcea47800d3d059219d1eb1b98f1033cfa08477560f898cb445fdde6cd3097c29f62f74595875f21816ee475db21cad8cdf33c37ca00faea43d592f446a2cbe31aaab928b11d66cb16a54cf7c9e62047c66d44ca337f630db4ab222853136f0db7e9888ebb4e31cc7f1525f21899692287369c478670596bc7067a4a0edbba1494ed2ddd131ab2fb3b93f31091d543b52eac5fb789eb76413cf6fb0b957f0b0d2d59d5820452e96edf39e560ef22b3f8360441c0bb525714331baa9c6a48fbfec610c129bdd9e325fd5bef14b6f0b4049eb28bb37fbcda7549858842f78f5ca405be1752a5c1570fdfdac2b6c9bca25e2cf2c2082af86a2c3c04745fe3bbf80f0bce7f087d0eaa1023fab7e1a59d76ea0d533489c116b4439b40ea315af71da0b69edd8b01fdd1c060883ef178264eb26157cd27386329220dc1ec1e280eb94a93f088bc2a4c4f24ee2898d3a833a5c614380175b75156a077d5c34a96720d201432944bf5d68627ce62c15edb9ba5e3002c0b6dd31280de1ee7ee26aaf1d9d23aa361184c0493484310141fdcdf7df799c9631a820fe6b145917d6e6abaff4910cdf74a3406c7dea69158eb351968bc5a25da52aec73bfc78b710360d8299d6a205c7439abe7e2c0cc3cd0d725d15e85cfc0cf71ee916b67427a0b81fbffa3f034e686332460462dc6bab1c31f437fca8de25bc60cfcb60c34280dd5f251832cc4d19c4c62c6782b997a92a6c56366ff9cda89c47013178f266d8565f11a638b0c17103186720b437e4d36fac5c14099184157b1546d9a94c57b1166229d2eef69fab777f5ff498a75895c27087cd20562110589d126063afc709b367cfa36a484ead2e337497a75410621fb1295319a11b1d219168170729aca3b5617124823624223682e97db3b40adad09dcd2c82724c3d7291661d1a5e5fffb7a63e3d6cd96eb8d450f26dd729ba7a5425a36399c86ba9242a2e474e0ea97ce5155033538f1f20db67037a7b3f56476d2069a9107fe02ff56ccd87ad4dc29d938e005fdb753fabcb57c048f4cd32fe759104541ad2abe33a31ed1f34d62daf1c15b79efc5ac68df8d86c3f6c101e9d3003de9830dcccd58be771d904cb462eeedcae20588a1147ef2dbca09c221f752bd5a90477c81739358c794bf3356c86da9b2a9bc62892d6497b53bb7c9d757a0deddde4c9fadf1c51736472c73c5c4c5c95d681fc2787eb6958d6c26bb346a1e94bf6d93fd83c67f2b327fb820873d495242f6eaf7920129bd1e97942d203852a6f3fd35d8fcc9a6fe39ba7b87a95388e0e04dd5fec074c1b656755e457d611cfdc45195cb11cb341ed77f049e287e4e36a51dec03710164bf179e66878b49333e7d2ad41210f478c349b46354a12509f23fd319fa59b7f3b76ac271cff8230a1141a5d14b8412e23c2c7bb7210cd90e1bb94807fd5c4c6365edb925b423b0d8ef326680f875672891f60555a2061b3a4d510230a66197cc89bbc829b17c47ab5ebf19ee72a018f8303dbc924635109edd07990a746ffa7b17f2c9cee2c83870a672c16a51cbdf577ceafb92974afee5019149a4475e351ed3feb887b47b5cae188f182429d743320e3507397db08443435e2624d7be8d44715792b230feacbc8b68d68dd6c7b8de6637a591ab168246bb6c25e222e7539dd1ffac4bfac8910719f6d75bdcb486463db81d708eb23eecea2f2be07031672d0f02deb5aeb5b22c5b465365d200da15b23f23dc437e313a7dff0406f27831d898f36c5c5e7f6eaae47b73a9572d8baa1b4e193e2532b9ad624b1d80737756761caada72395dbd9163c3aaba422f8f5c647f8496be7a3151235aa43425b259a759635fe3f8b0fed52fa30f23c272b9b7b3e03d87e75ba545d25ac34c3e51c3a9e64530d3904aea32421ffbe460932f78e5566a2faf56005c7cff285a8f6138c20c3d85ee1ebcd9d347dcbc5d505dafcf16d19dfff6414c84847b77a6db841fb0e763833fd87ec1407d2ed87be5527008b0770b57b0e94a76e593db83a3f7863d4eddf1e9fc4751c8deac8c26fd79c81ac7eaf221714ccabeecbc85dbb8170ba56808fd49125d47f78f527b1899e26bcb1d1f0cb006a6ecb50cb4fc2b80f9b3dac1327299abf3e2e1847fc5d254577af7b92172dfc9191ea480091faa22b299ab7ad8975ba3afd457f1a6da18be98015f51609c6222e43d61fac1fa4f98fe55a4eefff60417894361ba2279d44ae1bdc4428de297f638d4f09803ba3add849ae91054ffe493d3f5c4699b12a932a8be877390f7b8915e16d44eea775ea56d4b2a9ca4dfa1a4a1fdcf72dd9cf359618b1e9c63b9a1a7bb63397eb1cb213e4ee62c4a75d05f896bd21454c9c5eb3389074aa75d3a1a470575fd43b0b84a3c822b6b186a924f91110852c66898476dd2e3229aebd10d27633727a5b744a0b28703e4fb769066b921d7a31d93112858799d10a7afe7692899574afa4bc8458ab66a0b276a7b41c65f5ac9d6c1d10d8e52a911289b545a5415299b5b093f61249981e192414e2d286b213991d5eab434b132f1eec9392e0c052ce43e4c645a5d18b6cf03e11a5341b88a6532086bd5586c1ed66b8b066dbb2a8b9e1c266a5d4940f6bc37e0855a0cc89aed35bf59663767f4f0a5eaf0f131bfacc0523ba85b5f44ab8c51ced9c1b7f7c049eb8281c3ef59cf638d6c761a358ee561e03a1262f182b08a45ec1ba78f1faf76a1a2815d3dbb54c7f7878ef48c9811c03180d628e48fe980d567519d41a1107b3062d7281f243c43cce95db7f168b6e16004ca0b8e698532dae6c088ad021eec6f0b07899ea1ee5dcc86e28a962f200f6acebd34794b1f67b8a0717eda202567341848011f3f131f916923617873670454d276277f42c2e7df38fe9e0d3492c034ae6a04612a353efccf264d0e165c7f8f8e36bcdda31c3dc3c71285e44c1b3cd5412b8954cbdb5dd70989a555afb69b41ddff7553fc81143508dee4d1667fffd28ab4504642f8c19c85f9ff109ec8d974e53d2d15b7563ddc6934bc888e147d3606ed7a3351a2eaf8969c0b27d0f6cf725718b5d8b0ca1d5c6cddcffec6e2ae7610e45dca48eac41a7b54a329a95ffea611aef2e42e78a1e0cccb12e4126e03311fbfea667bbfa3b9d939db1a2c6094bf4d68f36575aa36dcb6dea27bd0b31bd5d67adb97256742a605a8082e3381ccec23eddf82baa4ddb1f2a2e3d13c1a81a6478815345fc4183b69f31e16b041f2f69d1a9bfa825c0cbacfaa671bfd769a946061dd4733d2af5dafe7f1b8dadd62e6cb08e467a2d647d0899f45a41c042406100eec267fc10e69ba7a8ae45dee11844e5435701330ff8a16d5010d26aa93211b8305617b5ee0382d9b8ecc91b9cc5cebc33ef19ecf7d1b4edc6a017aba2149627420e1ca10ddfeaa4b749192b31c071d5670f996d87f28b27720d3a9cc31c1606e1f985346813e3cd6b3cffc6934104bc2ebc5260edacddd3a7281d7207ca3e2faf08e8fc460af193b07212a0a400666e6f3cf125c532d9df08d6a68d28d87593213810fbdca6b3b7a061b5c0ee2443be2b9d47353f7d33852949a5ac1d0d298ab1657c6a8b1a5e2c7e67a7a7020b5b3421e1c76bbfbfa1756398e86094ecf5912bf43dd93a1818ab639e837dcf30fe947ada0e0536d0e7439ae294721683ef604820d9e5e342d820e89a89ff0c9a9ce69a9ad2211a271537749306161446acfa5ee1425c35c3aecaf5e7fdea09ea99e830e06ad4d5f323afc1038f7f6758d735bdac0639436c181a5a02a9f6c6344f3a7c76be29e42092be2072b87258c2df66c33b3ee7c10eb3dd207a21d899ac045217838f474fcff0c7cf0114d7d4179e9fc58f8087e7f5556da787f2f62fb2f73087857a694abdac3a2e416f1aae2c56e9e724db16847b9264290b6ea2872d13bf2687f69e2e6c7b183571afa84bcdc5afdaec3d613607bff509ba77db3e95206b57c328789a0d69e012e2a7107ca0f83faca02e38627a7b201bbe27767b147d97a4e1fd6f7cd96eda66a622491dc3b6fe25a3b1d3faa939af5c48eac850b2a93071d4e9058a2f41a22da63ef42138c865b43303b9ec48546ca8eb88c948d9124c9d526fd7e37c1ab29fbcd6ce0315dae07fc1f74f5173264658fe6eae0983eb5dd338f4abe3fcf4f50f99d7b16c9c7e1a736369dd848dfd78048012b7a3c19e32a18eeecd318cce7a8b6453a3fc68a9717c335b48ce768630ab47c50c8e014cb8b293029dd87565cb569eb91cba2272e1166200f1e9bdf705a05c70b585f812637319ada31f414853bdab7bf6f77b2995a9bd2397b166e636b950f6c73c15e1e8c3710f3b67d0b2e51dfe202339e55533a901921b1de6de7275ea85c77fb0f0866e343a723cde27ece63dbbaacba10b39b1ade7208dde7e783b784ed20f6e5350397539ea1e03836f08de7e91bd6d37a78b6b16719863fc0d3f1d88165d891dffbc8791ad5091aa87e19572f1e73f6e0de6eba0163a968ec8009951921d7929d22975b0eeb957ebee959a8dfc4975deae6b1709c3d3970792476e29349c32596a820cfa7782bbb533e20db4b44baab900c21c61e806ab6bb442399f9b38176b8161893880875653223d48ad20609cee5fb24c5472898a8f954c0e62d3bb283e6e7837dbe9c328d76a5be97d75174175644e22e34c166cf6f7d127370e0a28938b6e4ab1846778fa4802f540f2491480eee3cd205796b96bef4e83c7c731bdfee03ce91c79957bde7839fc00f93e97346fcb5768bae64dfe18300bd7a18c820304cf6102e45c5106129f5a7a3762b18874bb6c8283421596507a0871c264496bb7234e91dbb55ccc2bcc659ebd56a628ffcb2713ea429f8fb9cb7338275d70ebe2572969ed13c6978c4930e32184cc69b9ec14fa63fe0cea9cbb26dfd414dfe7f936ece4a5b535778cfb9441b6e7c2fa7e3277ec6366b6b16ba066b061687dc3348d1b03c7d8e03ac285b70313258c910e107a6216f3cd990ca3de2c610e46ae7a0c3206e904c21f85fa09b6795366984b691e9165161a311fb0bada4bf572571e5d2b8a37722e49af481756c61acfb80f71795a52d84a3603340d0f405ea88dd62f4b05c6317d0bd8d981591b81728114f4567929659645d77bf4b41f2e920997249f8e81701a53a81f066d7a38c1677986c7af12f77d5a4b6acb6bd82d4152ee5e85b2cf788f0e614e20b7eed50af328030753159f65a8552fd953a52047eec1cbbdc01c4c71542847529ac61057065535b356cd57af4c6f8048e2d81e8dc13999194f49d9023fee200cf2b7b7e0d585c38af8142b71f7f450567771ee402b2fb052fd747849eaf9e0a375a8e62815964e3efe8edc738d89dc79375faf6db6a22f1523a2575f24ec9f4a2ad28f95b7c713fb9ab500fb4d97e1e13425e61127f7fb6a0d137ecb15cd4e12ee5a3162a416bfc4d771031f9b24a7138fe8c1da39c643e7cd89357c9694bfce7d1fb82e0648939eca0dd179f4e884040280588a752c16c9966bebd603e11166065e9b2feb78d6c2fe6ec53baaba78c1a4a1e43ea0f9c141ad1aba8103a3c37a4558123d66bec099d95d191d46f4ebfb26ebc976636fac07c86ef2d15a7801e0f533a66d2b4e55b6944fa5ed8689707da8ebbd034533ee543da3d8261d636296f747d8a2f522493213a674922cdb44ce726722f6734f181e3768c2f26348c0ea612ae30e5f94c9a8a23c4e998e4cc31e43984e7f0d3d472cdc3ab344b737a91be2ba2bceefa0fa0cf8fa694dd1f004c53c6641ce92293b5b97560154d11bb37d18646000956b2c6d63aececfc3297cd8d3ed58f087a130571f1c2a13921ad1b140612b17b659d5cbe3400b79efda7513adba2a344559969a71201873eaba0728778d13311c8894ce0387321c2298b3c75e2be7c1c4d5e51c4b5a8536ee4792b3b9cc9c044b94294290693434cc8b0f2bd74038f3c3d684482eade004bea23e6805ee7906fcfec601a0b622d80f5d6d58c6bf1cabe78822f67ea551f7c7c345eef90e955012e0e086b309ee394b78e155d3ca759c3657156bead32bed44e86a262a93d37c626d9daf9ac11e0aa1a65267ccfd8efd33944b07a693cd8a1b7cd3e4299a8b3316335e62b6f612539e0aafec468aad7806cf6564c2306254a616b6cf6805c81f03030218fc43621ec86bb651b9ff1bfa1a91a31167114d3222284b10aa11826aba5e6d14156907459be0c1425f3aad370992dc4b925caadb5073da2c39dbe3395e672c559378b02eb8da07a6787e5fe4a287626056940187d53fb921022d4efb4c2ac508547d8a8fa64316a7b3eb72710501f351e2f4dca9397af55add186501e6acf2bbca0d8751837458d698e1ba113086795c880b11731bc6481ede4c0f70d8455576ed903814cedf60c2eb0223ce1c7ed3138d0878dc9f7c063005567d6367a0bc9c25f7019a7280c40e6518aca4697a79966f5588477f8e0df22d8c509f0c0544249cb979cdf6e4c0d8de289794415a1f6c1dc5951cd4e87b7f427dc88beabb2778788ab149dfa5d9694d79f92951c4ce3314677cbf604dd42411d3239d43608603ace3a493c547e0892b6ef148946e3882c24c282fde1bb2b7f861c2b8d5857589a6ce62f7f77c278eb1922a7854b40cecff9c0b3c53c805a2d46f8f5468de5033b254c96472f468d709a5fcb35884d947d3458a206e697f8b1b38288f370ffe39e51d6bf6c7d78ae88512c98957bb161138e71ff530835efc838fc7c6de94156e63774dcc5fc6046aaf4fa30f6ec0279ae59ea99b7cfebc755c70ed312dad0e96357117eef8622f323bdd30e6f4b5f6202f309682d3cdaf11b6fce62b492a504a6f0231bb8e2a44bfe267fc2684b168167d13792cf4d83995e5e4cffb26911dfd997f82b0164acfcedd077e35c6b812cec6e726a532193dd0ba1ac3d6869bf8c1ff9b5dfe7a2bb87f4b906b3aecf6fd7bc21c63476155a08681a9fb15ae5d0f3c6cb7242f7a684783d414a718e46cc8469e673d7f096facd41d5f554c348ac50df4d9804a4cadc176f915fc5ac63c2baf885af08e4e102b101b129ea5e5002dcc3fd7dda73693fc4d79ae6da6649b0562aef8ac96d97e5bf2f29ce4aa0484bd8ec4c5cb9e2633bc4b8b26685fc535b8124b9c4f772b93ea71bad8fbcc8551d3c781f2fe124210fc3df45fd7d15b7ff099a40700f5544da7e76043100323c604aeb7f630c8027bc1a774d4c032d970a3e9a97aa01eeb89ddeef8c862d92b1427b57e225c3b437a4d383f8e932bb63a311b9fb3b0c4a63b94114a65dd98f8b4b8bd0f8281b55993687f29aab20ae2ae895f814eb3985303f074aae0554cbd6d0cc6ce253986f5cf4be1b10570d5c7650c2219200bae17a46a0affa37f223a4d682e5b7bc4c297e4cc3eac9a4122dc13ba1af2ff1c6964e9694af1602f62eee6adfe6479d3ea15b5d96c1ca28c637cada60ae8899d0834e18c573564250be37b46cb9dbde5fe53c6371b1f29890af2e305c85ba6132caac252bcd40402e123b7b9bcda7ddb3f30e8d09f3fd235b4ec0b35e55303f004b4914a22353fe5e079e31886e0047e225dda8cd650e7644b8ec218a45da2b06d2bf49739cbda3d23eb307b2d49467d0d433220d7466a8d7c4b6bdd83d6a7ab940ff638d52291d7f72791ff546d6916667909d41b8ff6b152810d1a48fe8dc64b53216e5e13654a8980e6e9606fa56602336834e953ae64fdcd0edc10795384986db0527dce9cfa834b8825c4b8b32ab4f8aac7e3376cdbe88865eafec09f6438d92ecb4f3add874ab3154567a0e332997769f232436f8b58a2b519a6e770c6baaa6274cd4fc8180a4ee0bcfc5589ccfe9426bf7bfea941a1070f46d299802b770da57cea115c3c9eb3c8f758bf22efd80fdb6a73d16baa3fd66b48d5551aea043aaaed73c4f464172c8c977f8f7826e1947b24e307836b9fe1bbca9a68f9e582e7ebe13402c365b83313a23f769f8cd8605d13ad37747376431dbc43baa16196c4b069fef001e316e96f1fcd392c1cacf87a03afdea8296525665af4964a525a03847d2ad162e6a8322824476f1ab4243a44e9cc03a066591fa52f9752d804c0da1539300cb8dd0db44d305624e595d4511de35691257e74ad6f18cf4a94815c4bf0c7d4614f1a9c14e76a7f91ef6c2510cb11f464dd40b11c247add6820284bdf052df5459e9a9636a442d29b6c701c51b235cc62744a8fd7b3b4cfee5ca864b808e36e86d22468bb699662ca61a96140b74500c8c4afd6002765bc0db9a8492a44c53d971ea0d3a84804a2ddffee6c76efaefee47267dd02a1128703d61d55c177fd7baa7b7dad9f6008a31ca55925f0bdb1108525feca6ec582a5e014a315d536856c57cafc7a47a7e5f95bf9b3661d61c1ea9e8016bd12f014e371f80d4f2faa45ab910c341679a945b565b74ce894f3b13d85f2982312313493c50a5f877daf1ee2c463ae2ab2bce883cc433d57870ba64e78d091ddc6c51eed1ad5eb1d78aff498aa5f1bd4ead521a9a87c0a8c38c550f1685faff0a88d487dce14279b09de3eb88350764a10441546769617097d5dffe018d7c7b6a79c9d5f00b403ef477568480713dad169abdc4f93eb73af682f65e17f4868ce82acb1bfa316732e8460578b4d06ea73f6d0016ef01f14ae53f1ce035c9d020a199c7d7bd64cb505d9519614c42d3f930eba68a441a2e110e5de1d337d4dd5acff831c280174d4bc52f8685d6b3e32668bca5d942843dc00a9c4e527a65e346bd7467f392f32edce0e0085a14da40f7d13e147eafbb9af6890e638e7ebedf03f3507bb14ce73fe8a69ce3058de44a612d2dcd682904433f78386344e2ad1555a1a9f51f8d1ba907da21ff028bea6542a9c4d122b3d8fecaabbf1f5fdf064d34944b74a77578d7a83d592a94f292302a7b11c235eefcb3dffd45a14d3905b1854a7a89c9d6ea128244c2d451d17399875c30406ccde6141e6a075dbd1cc3c1f28288974f12724d9eac97f90821b20e0c8eb2beb417e0cfbe0054c7147f64287cf2b68fd52b7e7436e3c6a52042a7fc9aea45e5dfb7270ce0e67805df8d28c3f8652121c1a9c103e546137b9a8129fb69418227a1d8fc546ca01a2cab56343f453f4d2e999b6dc5cf00d9d4c45b5b6ed74731dafa2cc36e615a39aa58c5c9881105274a7a53aa3eb1197ffc2ad658771d81720a7c885282847f4acec1a4ca2adfc5a5c5ee4bbe95fbf2b7c5adb6c279cc7f93d0071bcb0d762da10c3763dd3f850ca012db9f114f1da1ea1c4c5c55f0f6e49d8b766d3b017b3577e43ebd720a3c308f86edd9ce8b962efaa881384173a1250a769d562e8cbd05e0edc33b2efe4541bd67580b5238ad995270bd529aafed0aaf451d850b687844ce26415406585b61c1cc73237a603f3586899286d97bd100aaf21874f69d2a840c7b706b982f603a3be6d1f1ab1ab314f67953560ec28a84601643c439134684a91d553bb2f291d9d72c3e669182572a3090ff7ead50bea471b91562559d983f56ee9e736100e59143bc2c7d622a7aaf152fd5b89127ec8cbfb091ea5ab681fae7ab3ad97b45a67665f18f7059d1f8d7d3b3688625ce67caf97cab65fb9cf1b6fd03fa5df0d0a88984756948985c1d0299de56fdf5c445e5af7f29bbf954ccb31b7c68d174c8bdcdedfedd8b2c0af619b5c161b470a25b504aac7927e644c1250bfddcf074bd409505c169d861fc3ecadd302fcdd888171c5bcf9844766d98f17d3404bf6559f3be66822791a4dd645ea160f9d077f633db223dcffea4f1c19edb595d4a88a2c87bcbc4a8b3768f0d4167f2b7153be75dbcf78f66efc48bf77eea7688154e46ab551f73f07617b35d68363171364b41821e14b683b0e5b615e83b7ffe4a1a079304208f8ac788fe277034bbc386180585109adf390d1adcfbc26fd5628d367f959dec1e412c46720f4e60b34d10de98659a7a3cb024e70dc34a6b6d5cc0736cd511b425f2e9b5b5d955fbe774f38ccf7eda0ee65883fe199fb1efea268cd0788d8b4cacf4af85048569dd23404cce2d69cfdf5c04419cdaf01a65f57fe249693973ca6cd7e347bcd0b66cf4b3bb08f6cc68a10473b36ff7ff76d026f15181aacce67fb293386a3150f989f030fdd37a1a1be3be39a9d48e037af8ade39fd1df2728e1d0ad8b88e20d86893f9f2ef3d9b24439b6fadcd4e1c06ed5360308e86a6841c1c9cbdf6d566bc1ea020a444c57018d6b81d8ad9fd41f04213e708a13a55075e4932ea5833416602961aca52ad6b4141814796ba9ae30d0ef475b26a97253b9a0529e101d53395ae665c4e1aef19bdfd1fba46446305ec6feff8ac83b78255cb786f916438ebfbad790e624eb260aeefad5a2508d8701c41f55b5a376e8ab04af4243c595b89c96517cf97a02e8c53a78637c540015ad3095a59d446203576a28adabf40ad576bcab7033a22b8c8378a06043b67416be7afe36896c5fe7408eee1b7e99adcdd4229a0de9d58f20b57ad1c40b70b491ff0d0ed5ddc0a73fa3bda3e14af35e202b16c6aa887f072a07b38e17c86a11ab3973425cdce860282f9323de38bd39cd96b9dbc1ddbade040ace1f3c96bbc41702130ac5280800ee7ef79ec69f0c09cc8a22e4d9ce59b928d4b145808492d2f10a97faf4d42a03235d52f06d9ed415f94108039b89c6f552fef965bb8ca3795f86bc1f2bed5425aec15203baa6b14a191f3dc3a8ab0353371a5c0e7631ec8306ae0302e506e8b7f964a775352e4f159ae78a1c61f26a7b96dc8e170ef8a653471027c20b5b36511cfd8c9f1bfef2becd1181afb3dcdab352bac0f9d41ff3efe697a92bb5e3a4674c3c5dac7dc3404d06a17f694e23ca2054757d1c5116d119f31ea6e2a82fe8d211ced8a0b18825f9dfbac9e6d0c4debe2339154fce16505858787520e105c40bed3b0468352519d585fdf616da80955f4ee630c8d6a390a5e4b8934950de34978a28185527ec7043a6169a28a36c29712465d9004fda115d25f2e90804f795e171039c3bb17115fd1b457f7710326e86fdebca18dba2ce9af8ba17f680dc6211d37aa7a33d66280a6f3c8235eee2a93dd19815283c4ac24c48650a80d9f9e2073e09849868a00c429c919a695000b907a5ed78c8d6678949f31416d798b29bc2ebc8560280ee1b1527ac32c963244980f47f7645b9e405b4141a2351000427beec2dad550b783256a34fb0c69179c57f368c7a17444e44bda4b4cf59262a576957c8fddaccff3b6b3f7d6c39cace6c741848282a85b7d5f13303c761cc855121a0cf6b391af1bac154e881ebe5ee2afa89c6955062ac5aec32a3522496078bcde21d2e86b22697a892cfa7a147e259dc28cdf3973c9aaab2e8d376cbee6673d67a61f862c07f2a8c38d74f052becfa6661a86a7934d178c3d493244e25cda343d8036d75953677aa8c9b96a28f7eaff390e2737046b3775eefe070a39c6cc670af1309b4ef1490130587b5d67c54923fedfecc74597d869d0dce7f202176f44b220b39e65160a05f066cfdf9e440eefa100a6e548507c65c372cb5971862c834fbcdcb21f75cd0ee0664f819e8a319c3f6b598ceaed06b1f65fce54ea3ce6576fb9d679510e29368f5a4379b06711055ff1a50e9543f8bbe98e03db08a768375afabe4a0da545db32f372e31da2962d94754e8f8fd9cfbe007ded0bec7f1dc3a22aa3d45bdfd951965730d6da355dec71cffd9db31c2b7e666fa702b79d643d99bd3278df308d57985c901ea0981a4205eca48329ad0ace1509b84b8f739e1dff3573f731def1dd891e8990d1147526721c74976bffb62f39226cd1660307e16195d398569afcf007f7f96cfab008103b2326fbf3ac40fde105d51edf89d70bb0dd0b8c31b124ae1e79f266bc802b7c055a0142ec01b721c9ce65192533b1425ea296face04bf048aa8217c0884056e4708360a89e36e79294c54c6e93dd75b8a37276a750f083cd9f5aa349fefc82b5d6217c07633d88b515027d77d95e11b51a372db44619ef0ea78026f78749918c810549c811717dea86677ff2f8d720e19e39313f7ed416256a84ec91285f434ab900a0733b8132fff93e8795c3863c8f8021fc09a5a443c3dbbbb96d577231d4df88ce43fc28ac523c9c298f30a64e8d4c6d66759d0fce1866fa7a2f4907b262bece8364b1a652b70d583bb8ed43dda34119633debb1074302660f16226c081143def253551d8dd4f5a7529c459689ecf4508ad2515731c8335d14219663ab5e981cc4e72d52a8edeb59cb43400526e3fd8f3358ecb10c0fcce66a8dece65bbfec971b2e3922cc49eb3b823c9955c2b06ae15d470cc2db6d5e053db03f43cef6782cc7754af167cbb763bdfe664e8557767bcf88152ecbac7f5f0616f223b3876bad24b110fc9c9fa43dc0032c0fd52ffb5c9f2f6d5a78f9a3aeb5b6ba3a145394564037d75df78a24b4ba48caab5a64aaea15fb0ba8455a8cb75c5b6886b6551899ed894573fa36b6de4347b7da5f5e60ba8616f97bc75a83f7c1509b395b40f6ffd53b8eb3f505574be6524accaebf7ecc04e1a885aff57aa21e8e5553ce21bc61d722ea151f1558f2fb3a2961b5813ee69ff3db5b98cd499363a4b0861f4fb204c27867edeb4435cc7f20f3b8905bfecb8e70f5a5224060209dd7a2ae2a262e5d50582578f0edbda35b522f320cc48fca3bed1cf668ed39bddcbc3e4b747dd3c0dd3f47e09684dd0578bf9952120cdc80a2d323f41281aab38657af3952b567f572bed38960bdc57e2858c85412f85d4c9fdb239df800c6cc602fef139b2139f71a132a3e6326c8961e17c8c900921359c8095ab5138e4f1279d09086cb6d31109423c417acec89eeaa41d2bc75d0e02e3568133578278765c2b9b98612ce6a6141874296e542e59dd1bea846500a1beb5bb7a88195b080448a1cb8cb938b27612b302c4459052892ee04277d74ca30f2c580f8987828b7cc534f8e327545fec96b18f2d21ac67312d21b845a052585aedb4fb4c2ca89e2111926b83dabaade1f804d8dc5605d92203cf2a8d1e83b4a07e3a0048336d7f4e8f11ee2e43900387905167851fae3bd1acd6666f8242980b6b85e94066e4a33dc20c2c950a22c2dfb19e16c590a4d30c3dd020e2f9882183e433c09e2f8f7fce30b385320fd358e0aa986b534e202d6d9d7934d775957b1274d5b86232f50e0c6bc1f2902295a71bfea300ba2b479244a9c24706392407479d9b70e50451401f7ed7319f4ec7bea9593d3209f7096aef0d724f7a9a80c4206573f7d800a469ff775abe1f47002af103238542c16acf9d41cc054a618a7a52ed77b4c7e797656bbb0dac047f6fe5f439d99144546cdda5452282fd5fa91d365f0fa7a11aa7f76ee820703861036be77e69ff94c3fd88f57e77b487acb4b62c6a81f6172a996e16a04872c6d91ed37d01da38f595f8e669fe3c04a2acfd1dbabfdf05858a428a20c0eb0490ede26de03f84f1b1072a907fd0789b83407fe8010924f8a5b52d7ef119b8a1d217f770473e2622b29fe4513901c722be3f4c1b4161081a7d48207b2a6c875953e429224a14e5b5f88e64d80cb1d98c106c64d9228d976668b3c98ffaf1daac5d803d6b5a1a4c829b273234666a4a961b2b94bca6d49e442c3367f5c8b646f275d17abc899853eee5849b2aed8426f9fc11ae52a6192b4d6262c982ef73bb878121fe379f08abd767d1c2fc7a14a3ba261a938fb841413c0692d61669f8c97b85c3365e2fce8868ebc802d71268cb732a10f6bfb520cfc71451c1287fc9b52cc84737c2be15edbf1a09834575b91a32c184ded40aa6ae3d241eab921161efc67846f9bfd5bcd7a16c8529d5be3aaa56d64bc91e1510b6a96c48326296c6bc88d79c2ce5319b595c4fbc870e415cb8e5d80b822ea0b94c1284085eab43b74e0d139f10e3ce59d5bf9bc21705318481d39172dbcf27d9ce3932f15f3378856539217f98dd6c42a5a8b208baed761ce913ab9ccd28be516425cedefaed6d739a92cf978d5a0db92340b509756df4a559e6cfe3582e0905ea0ec6bcb719d25200a71783a27a9ef8c3325fd346e1b76bc3a9bea5262a3f685c5ff698cdd66ad8299a6184c9c62d20da061fbb3e53b34d0653c24b2b30894dd51996bdafac75701491dbf21eb435593e759bc09c8a1977a7f4971dc92217b36e20cc6c45b40f643555c4a0e21dc307831da7bcb7ce38aca29adc3aad3d9d6dce6616d9333adadba77c74cbd90ec896660ec795f382da9769ae7980be4876c45155afe5d16134558d92894658af8e3e2b0d0d26bd780fbe5ca01d2b95f9121240185a878332a9e85b7cf41c3ee1a3f40d1e70f738b0b241e82c18907947cf45a7f03ed5ee2659d99c0adb170a4e92e72187ed58e00491e0e47949d12b4b271f77042e9aa54901969a62daf228081e138863730e0a1dfab19cb2d39a9ec84c3cb47e72bde7d8f6ec76d709a92e83d5d7338db4d74b16b349293cbfe08bba66321210a0567df2d82436e722539dd17196ddac26c0664004f03eb8430dd59982dc3ea85469a2c952cc23400ff6687066c3c3920be25e6411b032d69081a396fef7084780203eb43498eefc64211073722e7e30ae75510a10451bf0dbcb8b39ff71a49e681e07d2391d4a09fe925b86d447648a8be18a88c43c7c8294f182417c61e7351f5e447b0640e03a953c31edb86351a9a824bc86f0f25944f0024da2d855274437d3d2577cc0384362189398ee792c7d4e9f54dcbbbecbeb3f70859319144da974ba6d56bce9bdd22a45353ff26535ce0827ea9a8d3a71db9159c2eb1f2f75d09300498f1c47ad25815efcece52edc9e366268e9b1e36278da270aace50944af026c108e0a950f80fe5732ff70d18c48809cc6303ac15ac6b2a641d564597943b3738ce5699713d584ca4cbe0c489e023492ba15d9f7dff1faa09f87c35caa0dcc0ab14ad4acfa2d028cf248b3b941ab5e971d183e805282f80d5ae820dbf2a19a8d5fcc5a610a0fb599518a3baf5e23c608cd8ec65838ffe2a22a8ec213555aaad412ac71568e0ae0ae7f8e62deef35b1927a79ecb3be4451f40ac583c019dd5ccfeab1513053bc0f4855552047550a4aeb5802ae17d21851270e9e08a67aac2b33d18c40d4fead642c07de03441cef473eebbcf8c21cb87f63c5ba877d1806747f4f94d6cfe1e8d364ab49b0be50025e2452d274219dae955500e88ab44c8f253316d03932413a18c5c25966cef4ca7d1c2e4c75877bdc2366c375d20e0848001cdf5f484535de0c6a2fa942abbe822f303d9edaa9c3e8381efec240a7762fb45e582a00405d1c8fa98bc21afcc6f5a2ed3fef058e54fe542f0abf50c480d634a0d67cd818f6a0433715df496a1909ea512b5b50b997b646ae3c67f4711644c697af5f24bcd5a67855d112123b54a17505419dea05a507d9261871f5f65644c74c069bb90466e22b8af3d6f750f24cb6849bb24ac2b2e3b6168e948ea0c1fa934d2f367ded0b9752720bc39ebc9a164a25f30cfdc639dbb28317b5786f8ed1163e692411615a0cfe8d49e8b1638876a0125065bc8d24cb540ee626882684562c2c95ee01f38c29185d6fa8ff84c650fe55351ed9c034c4d6940dbb07eb5fac526d8ed474871aa8c349ace3094988d2d07a8f96da165ec2065059132f29aafe3d32821a215b526edc92a0fe6f3babee845978a6aee70a7730b77ef582ad8b9ac39a8bd930090cf839023307e5687d2eb025d354a6c04ef7b86dc6c4e7c1d4f00927e851a428e65ddb87add5613be4ea33200cd4a5561c9938e2a27237467ab3b06b865ae6e835c4817d953481bff6d08fbfe6e7cd8b05484a0c41c5209712f46ee927fc34457806bbce8f8d2a0679d86790e94f098b9a32e24318491c7a945f38b19a298407912dc16f188a76f7b5152af8a784c6b4403c247c4a495fc89773bfe1b3d585b1da05749e4fb330025f29ce021802898c1de736564b2c7454e903f7b3a807600c089e248e25cd968cb708b4871cf1cd1ff214e0b6b8d417e7557424b28421400241b0f4ba1cf38f17469abe3473482fd3be47d10f8ec8c37ec26a0943f94ea607444df5cae0d69f9cf1ddc2a068c970990d87058595326645ce080a477610e3fd99c73fc49e893aa050f7ec42d403e2448dcf62ceeebee819a391f27eeb5d89115bd841516b55779d65df074bb40336e4fd5fa1754c3e1a6b661c961d68eca83437bb88e7400e3c0141cd0dc9465aea544f4d07b609d253ae5a818ae3968bc1091786f02ac737a72e629a8fe316be9d53b2e4880df60fa037ea70a7ae298c73d76f601a0d1f6fc31d8aaa3a0bc25928355a7b5865f132","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
