<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0491bea65021a5df2448af0c8135843edfd2ac6fdabea225de0c83a2a8ff71ec32e9815725b77417790aa4ed427bb46710f5211898f85f8db7fdeae32d0a782433ba9bb7a66cfc0d8a10c4f6bf12f9e05640dabaad73aeca429410ee8321efff5f4bc734fe4198db843b584b01c70805b684f9c9336646f1a1b200538b23cd8dc0ba609c2250bc83078e3c0c10dc492d063d0d899e55621a86ece681dc4c344d7fc16fc07daa634367c525e29b0b843a3da7b4bf2d8341440c41cdcc62a3e3ffb908cc7e54f97598e38e5cb5a0863d69cb7fcde5c245ad35f8d12595de643d0a6b0b92e2bec05155497ec7e9fea6f01de408d25c592a16efa1d887b029e6e7654f14bc55433ec4c5ecf7aa006c1ab192dcae88e8d2650baffc46d888ef12894916918a3f99b1ce8d0ba80a5d0a7228f7233f62e5527a2106a9045f785d1140ec1f872145896c1d4b50a4b535ed0eae653e34f916c718a5470a353a3ef88a3d3404d6148c5afba567458a554d9bb07236d112378120c80470cbde9a119ed9d3e8036fcd9dcd29a5ca52803b8e59dbee95a5bb257daca5134dff5b3042d998bd4393c5e65621e8dc1558824503b044e70bea628cc4118a67789153f7df2ea937a5b1dce8fe957ada7dda2bf5982ea40cdd6d24fb45b9eb53e3006c9e1b294c87058fa0851b63aadbfdb8cb25c5e2ec8cd6b57b0e9e9017323e48e215d47b9ea210de38a1514570c6f7a49960054c121e21d8175b8db7c789f8a7f570a848ef38c68e5f4db56276f53f42e2bb9fd557271b347bd38deda5e33136bc54d05f2b183fac9b283f7ddefec6564cd709ebe882094482262ca237193bdc4698f86055d3be930e66e025bf7de989ddad0154af80e14f4aa287896a71b0008ecf79d8ac6937766dcb47c3c2e30c5d0c9b05493926db45c3f1d9fb5e53a5f8da335c610251d3c680f35f365d71223c4b6e042d4d5929900bdabf6f23ececada392826d18e38caa3026bf2e8b73bd352ae95a26606aa4db3cd4717d8016185e0a6552bc4d689a319b53db785b8d6d0f521b15479e9bb35377d8c998f4cae544cf22383919eb16d72e85842fcf4998a9b1ec016cceab42b40f7118d86f9664115b671998b9d7fab115b7956d2b5feef6c9024b6f97206a1c625cc20a90d9c00f0dc8fc78deb870e623b3e8a6c52cbb7290e7cd9d6b7ead75b5a9c909d53656050e16092653c4166a8bf520b3cb2739cc5789dbf39eb22e6a9719f9c9574f2db845e8df8cc375d306dc78aab2423b0ea5697fd228484606012d41c2aeb7c0334ee21630de228a4f6b743615c71aee82f1a5421acf620d66ab2e26185aee2073cb4f4730b5e1e7adf0bb0192eacd4676d46d551e45ee38ceacd67b4ef1098605fbd2606b06efdab9f715fcabe87ddd6d9472a0b47c3a7fab40dc39ebd85ed34d8b09d881a0030cc46ecb07bf6a2f3aa4dd337be79849f298016e87f4a644b196b264ac508652f80dfc2fd7cf1896954caf2c155e96f404501615f353b8d5e4b00dc7c4551c2a778342b8e97706d322b7efb06911c615f7ab2959625b2ebdef8e1c961056df0ea74818dfc28436bbde429f2f482d1ca4bedee18d2265a8f3516a7df83e5d82f7c2eefc8a29a2e8003ad2bbf712080d62e82590d66007ce76101c38515b9b9c325639372aada8e76062608f74f75eadb85055eea6bd1bbfb21814cedd8c2b39729f9b2b7a4919599c6393aa2b590074de82afce477f92bf14ef272e24cc7bed70ab00af8285b589806f6a5336a2fc89b61915d0ef89e1be77912f74646abc9c1b112fcdd367f8c15bf3fd25d3a12ddeb8182e0cbcce0839e467597c413c7ec8f70c4316b2e06662ec1061eba9ae2e9eabbb30aadda0e394e1fe50b0b3e2bc66aa80f511812efff28a764da0cc99cc6d9149ae6a93e3b71a77245cc6c2ae55fc14840f743678fc595c902523019988cf460ab04a24aea82871a031f33f2d788107a390cb5a999104b534ad7772f91fb1d482ffc52e8737359500509258e900c93ecd1f61e020ed33e41f686183745a0ac7b57be1a784cfb1e4b9f0277ae7872bdaffc64d1497c4026fbd9b401d659477cefc734a0fb2c622b38aea94754ea782c9e3b2349cffae400a779e5d4bf2de8000f18c27a6cdd7d9963172500b8bca20e4b491ca81f8cace705e31274c30ca1101d4a0f4833c78199507c68b7583f5d4acfade31deed51239e6e27eff67ccd439c894b65e3a20f1c3338e5bb52f93f04435c118808f8608cebaa8efcb74abe2130a3fc3401ebc4040443306ea7fd90f7b13bb5714a136eef69222d1d8f7f8b0c6fedbc04584c7d7681f322220679e311fed06aa4bb93861638ffdc4748bc9edd5ad554dd382ccb1096fcd2ec7de8751b68cc1a06191053e57fd4dd44b3bbe19d94e7530592e0467654b87cc37ac808d9ab95af314be9993a4380e3fc618d5ec7f5a4a9260fca10beb03fdac850779285e23803d20119c728779e4e2007b142921980c9869b3d3c48eb6cab493651a0f63a5d7527bfb7cc52cd6b883ff143bf5134243c4960faf5a88dcea8532e7907ed1a359cc32d026f8ea4c7b420cf309ecf65c55a37241780274d4c87e167bb1eaaf86ff00cf10122286d20ecc544c89ed6b973690333557e0c0e969c9043dc552d5f555bbeec4b17d33f2ef6c57c70eddb429c6cb174b853f41410a34f8531084ea0461ca65090597c7e356723bf762e55e651a70363640ec2e1e96df341a157432a83c3cf072ea6323ffae36ccd1119aff6e7e61b5f5506f9f8857882ce66ca95f7f798cd6db3d3b53b39794942b08f8b898c788dc6be692fad25ad1845b5af25b9786498765d4225fa097d268542584e73b952b7663c2980a3d2f256eee74d696325a7bda397db7617dba1409792104444cd4fe2eed673085481673fca58145fe44995066cb9f1a6fec8bafd05d6fcb122b5034e7e7d35c9ebc0cba30e0aa7757c20893d15c4760f69f7474a35a1c26314786219a66156ed73fa4b8836ccd00536aa17a9adf9f0be20a6d47ac155b6b7bf5feb41f41e13ee9078dedc136358c802e27e8c0bbe568f0b6956d7be8c378e6d73056351400bc47b1e6be3cf67aadbd4d114e10c3b0525b4e6ea551ac29623b359618f6ed085752896a8b0aa299a66919898a2d6297d659d14a532e3cc4ca901a2878c1106719ebf55ec7a57521646a8eb03dbc20c967cd9376e653e8fabf5ad13c480414af32c85f1610562b4424c53ae0c8a31047ca176713642322c30f979897f398d75f090efc4f97c400828571acc1727064cdb56b1243c24b821b73f24ced45564b7408d80ae7276f1328a34f4c7e237e8e8b165233dd5b9f3063a9f850993919112a701d5c7e74e298c99152e9020ce2a57582b7a4e0a6052e7e1ebd7028f2e55b5c2c8065bd911206460e90b22b5efe38cbd6dfb906267fe963dd1e2442e5d876062f9280c82cfb5361e01fb48a07cadd32b24dcba23b4758d7038da8da70b6c7d743e6d19c032fb8b210148f66e5a0a7d18ceaefd4c0260609a0d44cce5174025ff88a4e48ba453c0af39c16120099d99f1a53e5a54e2ccb0c310beb2b4f5caede89ca31f4476d127d24c80b7ccf244f3ce2fa4ed080bee420d19ba8afce778fc8cdb6718812399244ebdafe143472a7d3b9ea647254ca62ec2d11c6fe46ee197caac3d92293fcd194e2df876fc73ebbb61392ef6eda0c96334903bf495aea7d3a8ec85b6be047ec16cd8f44cb8a9ec700e9ea6608d98cdfde0ae4b930262ed29ca24bfb04feb6e5f8a74e965d6686f3ec37b476dee0682e63a7880b018b09ddad0478b8030719d2c4bfbf8bbe46add2cb8e21a920f32c38dc4911959c905ac4ad588f6f21c8e2c8338c38664ec744cf4ff030378ca708d60545363af04eb988b77bccb7dc705764b76e7e7f1bc3a8c8eebf11d46d85298b624a219e6545e6a027d892e01591cbb2ca0e1d33d2f0479dd45af153893c7e2a396e5df1002c7b6db74fda1c7becc6aae85fd5bb2554dda50f09dc3671ef85aa417cbbb4bcd7625a6a93b62e95d2ceaf22182812e708c1ff0fcaef3b8d3fca49656fd132c50d42ab16c343073ed5a2a5f34998ad898d6b68c629261ec33593ff770ecc4aa03536a1bb3e4e97d41de72f1321ff9b18324606bbcb6ad2d0362d28094c616049d35ece4fc78f493280892f6312a242bfba64b53ff9528336a704584d27188e440b88e93ae1c89000ba8acb10718d1ca0add568b707ca2ebc8b1254e2617ca13dcbf55d83977c1e804ccc1c97597661a855c762922295e776c14237768a3dff74aecc38b21e1d1a611709313a89c472402519010b08b4260ec9ac79948049e49c1b3ac74e650f051e5814ee81902e4ad49acd739b0b5532db920b851a6b3b6cef04490014bde4208357cfba1fcd33622aa8d2c2c6f004ee3e5cccc7ab55caa6e56c1bb6a60e03e4a572680e46762c2c326bed68c44c27b28d10852ebc2a9fdbf96a056c04cdd4bf341e88a5196e2ab72528f218940d04eac5322c0614febd1d93753719c406dac36b567930c57b34a9b88a1119ce9f1948d39b21b971ddfeed3f209f33b8def446d734c565c1cbc097da9f04e7d21dae6b2209b8915250fae6d4bb893c5235687820bfe334608d8cc9e6a652441a977ae8cf3e340c4e4bb1cb3e2d0ac8cc1e86624c7a6ef130c1bc1761a53230db81694835a4cc7d3fb42046e9fcb7910de6dad954af3ca53032d3fd3266491e7d59dce2bdaa32e27768c6b7ce2670aeb01f79b3837ec9c0b8ca542bca45a7589f5b4f784350265f412c134d86b4265d921724d43e4b6f938bec1c073148673e42b2e38f0fb676f26ea951126f23d34ac9659a875238b35249946454ee3068f8266588038bf40aa72a03e2a7dafc3205c7b741cefb137ded79cbef0f158b083a8122e4d826d60c0fd0a6320678aa8f4b51160f1a1069f1efd7f498089d3ffcddfe8cf12e5a14a04b16cc1ddf7307460b2db69ef5f28aaf823eb0a7336d8de6487af1dfacb00fb3ff211a09d84d3e8f5e866ab56a51229821e2d96c1c04d4285fd5183432bc111f2ad1e914330d0913e78c7d2797a38643638d298471e6fbfa908f87fcead9526fa7f22148145a7d32e523fb181d5b3c7a7b79d74066c99fa6c53261ff372e2544972f046204f73449f8d2f53de87feba6b34434256907fc00039628b5187e2068493f3b7c54d2cac3991be4bbfdf644c5fcf8f91604028e8363cfc61a789c5d1a96be1c48ff7ed1fa5b23d4ee0a7fa3224fe31a480008a402199de9f673dae22d77c993b2a907a7f8cdb6c30693d27fc4d7f30c6e7849df4df106608a57626f335dd1d7f4dfaa74677b34ed983ca00cb1d48ec1eebc91e740dc7f7e37465d41bbc294ea20dda5cd219e3365b676dbdfc0d53256ed475434f1c916d7e0be75f3c487c0e31436848cc87bc322793779b4d14799b3a75bf900e0a97d09107d694b97e7013d409b4811d5f702792dae0c974c13db72a1cbacaabfbbc0c7016cd563eec208bc157725533f3d6728b892bd672fb3a2b7ce5c233a45f243407d82db3994a77af5f7d4b68ef6c6a6cfbfd5cdf48dbf8d134e232c7de86315b587d5732fa44dc14c4a7ef1561171310af0a164e60dae534910f3c94df55f6ccf3b9a5ffdc97730e8fa7c2d4c50b5acafa2f1d6c01c9f454f4a998e4159fe3b609931782bca06ab1422e9ac4946f25b0254415d60db3944f15d26f01637d7dd399991961a7473b3af9eea1e9178d737bab351bfb1195edf973cd47d7bf405d83b60541c4f22292d50b7f8fa644fafaea246df887ddc425b5fdae725ccb4ce1569a90a88cbd106358a2971d4a602fbbff1feae92a9056322c53b24e77d085f04015453ee1b1fab2a0d1e1293d1c44e381494ff190b8d4dd67b81db0913b58c19a59a345112c57e95266267650f0ed001f986e89194bbf26a19f510fb54d920c69c6e8c2467f3ec0c5ee637de9b9efd4a97154b8123075193a0bccbf0b8845e3092bce9230a9859703ce7ad11ee2cc27c611708d2030d98ffe78134f9aaccd35264bf1998fd47aa576c359e8e201a23dfadd1c6bbf38ee6f51681be6dd5f06b2b94ea732e35945392b5709240ca021558825975b90ceb4a728749641c570c3855dc127305c6514ec37816f7a31250543fa2d563cd9f7cbf635d593ba852190c5de7af67d6f97fc8eccd10fb23bb7174e5a482643b0d58b511ce90ad3619e16dd2fa62f9e35d2d26f01f95e0e706ee850bcfa7ae5fc9042b3f00d7a51e86da319ed708300fc6d41ed372bb51dc214586f60af04325de430bdc51a9be693c4b0ae0aa19e4eabad49ed946d5bb411c33c0e605bc69858c5bbc7d4236a512fe3b74929a9f500ed6d51343b915e7e7315e240dba8865395461b46a2e5429bd685e128f298c420c4614ae914723ee6a0f588268b90676e6118ad3570b7075c686101eddcf429296b70b3add6297037b9e795696d149885b17f52948ab33753af953677dc9518e94415899b95ee200120dd0e5a6c119087e9aec2038f3afd9d93d7209f02432dc217df357465330175c4e957f544081eb8ba7fff2a49fb726001fc847fbedf0bfb13e40cf78c3994e9d2b5cd6ac2e5dd1e0b6861cd935e7eba3f0be78195ed80083134980bc5b5dac96a3bf60b8e3d872151af9d896b89de6124b1ed2021a646df2bdc2469fcd02872eeab7a995e6a920bfd3dce74b2fea8e1c40bc038c84889cbc9935f571890b814e9f648b126208d0e21f4be68aab4eb09300b5946bda1fa4be967733660f36a864f6923db2f5c133fac6e2527a517a66545c949b1e58e465c3c93c6cf08466aa75867e885309a2c3828b008a2856adf9fdf3d4bcb34eee2b4cc4d1842ffabc300429c50fbba7eafe25ab9c63c527d22a2e6db6cf947d00f1a85259a0e46471246ef902f352ccabb0565be8d9c3bc840ee46348d1f139bf59560ff4cec59c5ec89f0bae631daef5c57e35447f998bf11c863a17d94ef6671f188089c14d383d5a1a31febd2cacebf7b05eded27b0ebbe8aa7bf05ee9484b64eed28dccd651294f4a202c408a482c7b5a1fe44911b05c2f18a196e3fc2c2f79bd1bf9f6042ad49ded0430c9cb900abf3517786d7c0ae0f519d3624e4a6edfb19fc6d79751c26703f1dd22b97fffa58cbba41dfa7a9ed205b3b1e4a7d1f023d2db3599ce0a0392e47c4c533c6766ff571aec3c84e4164ff8c98ed02a49880e873d7ca1d71146ed765418f72567acda8ebc49fe218b4453c835775c6b8f91d50571c231a0dd563eb4d1b9600a21467f55c92963ed55048acb45000753bf834a9cf4451f321891dba9fec866511cba24f6d3f7ce7ff99bf73d59b24fa83a3dd603e8c6c3600a3882e8fd6660bf2e8c3cea314e093e21d58b5af85f140d25aae1cb1c8884387d2cf99203d7c98a0f36eb31431f2bfe1851c496b5fe074d0a2086c16d49e6eb2c394a9063d6ba79c736bdc88b7c565bc6370e2d66c5ef064cb7b938bfa5b92dcbc8f8837bb4d967923c649db88e3c596acb783be4ceefbac2f35af559dcf5de27759fb6357180aa1d135fdf0f3fd62aaee1a1b48d52658cf2b6df020188b9d4880c643c04ee50e6ae01eabe6d63448a2b5031151478f536830c6600acb4ddcd101668bc058ad308489e0c56d6ebfcf05da097efb1a687a50888a704b9daf198bacc71b2c91090d8d8e55ef0b12865f7baf6d7cdfa7bc1b73976fb2771e6b2420c53a4f008b97922c622f6d91d39f46d801c6325c2a08e81bfbabd9cabe55da2d2b4f067b3e97033eadc638c5d3db7bff286ee97bf672cd624f29fdfaa21ac1404cab41a76dbe43b73469edb4f6dc8134710a0ec1a1b4f55fb3a603b63740d7a2cd593ec5d3638a702a4fb0e3c2d2b17858412355551a6ac9b4a6e6c168e7bd1064452538c7f5b3176db08668141199858c77fc341490d7ccb8a5019f2dc3854e80424c512ef88d9831624598cf2d56592efec5d89f620838e0cdce7a8d0ddf6ecf8db79666f2d7454eb9cb37b92814478e07180d90456f35de6d73b8bd77694ce80ca89827e9bc68aea105d1ac32d6e6317721c90ec2d65334c8ab55318757e4eec20ada55037afc4bd9346fb7518e22d9ce6b174ed38c896b44e2061f869c79800d282adb60755b3cfc7593b54788476dde65d8a4cad3be394917c548292bf90953c48105e0cdc8e3eb0b86b49efb8eaf75b3b9ef66cec90736da6c1d8b98237119e275f3a9e89489ab228422e8ac65dc074df4069fa1e2da343597a9da16ce7ef4deb97de371a7e011c9c654def5f6592ee3a98216d3d84323c8054786fd0ab200d03cf96482279f2d559f52cf57c6a26cbeaa9d68329ba32db5b16aa13509aa49b7877fade0f8cf6b3031da89983d4f5eb66e2e273e6e4fd423e5cb94df78518441d5bb1fb80d03ed84afed83e8b8f77bbf2dc272086ef17bc8e96e0f8334e43a4f27fde4796a2503d92738d91ad89368263896481b9babe3bcaf072b418dc9a2264be79a66f4243c2566cd88abf8b5e192af90fb077483dd03b4ef6145b9502dea07d2c679ff1b129b4fabf09c4cb4c260f36b9800f2390d385ffa2981c2e505ecef765a99e28cb984b7c27b11f14c165789e327d3633dc2385cda9b0b2a0a7113c1e9648daa2809282ea4a9d6b837014ab44c4ad88db0fb522f968c1796d20d69b37cf9ded610743659ad3e2aa8da88eb18539b6ab5d0a636d8458124eaaba614e1d0804d4c4778b08602e7ac4592d8c1f538e73b00cdd426185faa6307c11e75ba2fa28bbfb8c93d4a424fe3e4631387b41ae2484b385954db5a8e489eab5649dc9bc4deb1f282f4984dd043784d47017f6e2973bc6ff78439426aea6fff55540046d335e2a7d6c3a3beadef0e66fbaa3a30b435da13e13e9f6da81bb6860605754fc499a898e7405c990bc41a36f8786066536a7f4ce4d5e3141543b9cce26371fcfdab42dd46b47ffcbedb1a808eec791bb5f9efd2c1f8d5872565ee207f130c1a00ef218216cb76752115b8e307f8004fdd195918f54715eb00bdfa8c3bfccb3329c7db39bbc1189231d74f12f019d6d658ea830c9cf244e26305dbd8224cea0a7176f063d255499a8356654732aa2e5ad5d62697251a0c217812dced139bb28688dcf75746873e02f6a1c86412599fa82d3cdd60b86fe98ce776fd82f8e688676a64fa609aba2240d1eeef5a9617cd81267ec422329060642d933a2e45d435da2d6cdc0a16b0103aaa0c05711a4b2aa8b0c68ac22787e4e5b4680e5f820abc92cd0f264e7651d7d5b1c20cb2132811b378fff001ce363327b018a87f7f26f231a5291451b20d262c44e13499a202318ba28ba827d94f3ebb5856bd08484da9f50eaf06a357822c3f2186728f2b0a20db3a3ed04b9e5b2afc9a2d5349eaad7e03b96ff1ab021fd59665d4c8c23815989b0e6dbfb1aad021dc3979eb45eebe80a7d58221700ec1ac89c238aa4cef62822cf61b14e29a0e73bf67d72725be6e930bb5934b73220518bfea02ba8cffddaa612e4012b8e602b0b7384963d8d52d581ac6104aac1fe2cb0297d38124299680605f6408b3d7d9504fdbac56d86dceadadd323655e2d726c60fed62cfbe9bb0e448382debe7b2e9c010335d0ecae2fff169e00b59cd58fa94ba082fc935894ed5b755f901e271476fb5130547a57f57260fa8c410ffd58c04c66cb68a1c203448b0b1523f6c7e30afc7564263717de3d045be874e2c6ce2a9b93f5301c672f1659819112063e2af5420c0b469598ccc85e7ecdbf3ee4a1eb483cd12d502a471f244400b422c02baaad51a83d6d0c35ac45ec433432f8e2316faa2e52b0640fe48acc10e71ae4c4999db8f4b0d7757a14f633c8c035db23bd57f820ec2731dcf0c4fed37f77cb13cc3d663e220b28749595a5086bae0e63e144abaf30148aff356daa4e7e0b0bd2a3afc799eb80933cafb1def9c9e5620f3df15f3aab110fcdc308cc25439166887ea66396a1926d6432ad9b19673cf31c54c6bcae11a095e1585946d663e7ce8dd2905c7570f88069f7422570608a33c1893818ac06257053773c65ff77ea8da9dc8a4673d6205580aef1bec057880f4b90f62476475ade98764d284df3a17f9d44d0e3320ab023ef71fa34b03e0f78751b5b18cae9392e83d12c66f80dc67e5b7e799d41596ecd791a3226bc1d0dc16b0424d4985bb492f7c8aeb7e6cfe06f6266a5863a9211ac5fcced078f0e4f71350ac18412e3dfa23c3326e4cad1ef72d95fef734f3bc3a6000ae03c2eee001a26999e76f4436d67afacbbd3bb8f45db27bcf7f0eb48c1c2d18666b52cb113ffb04f0c14fb73905c16ec1c9bcbd4befccb52c8156448c39aa2ddf6b6239979df9efce79aa3b9dd45f37ed44d5d584a4a5cc74039c29080be164b2e1b24a0c8ebbe339c4d558f154b948406132a480c467d2fa0f8d075d3aa2889b9f9180656eb93761f3047d78049b9a4ca775b657b4c6b07f347d146d8b3cdb04211933b72b73f8bb3dbcbeb1c494a3a764944c707817a715cfb008085d46c3804b63a40d6718e218b876575df3edd8a031557663b8fea360201f5963fa975610d0805974f418ce70a8c3a6bb6c12d5eb75b428c71ae9eb9a6ee7f904b5b41ee8d22141d01f488a2c0552425eabb1ae0964cce719ee30db73eeda750f37327b4fa2f9e8dacd6f383cc331ab620913e35189c561fe70a6f79a83806d630d4ca6d2c109d5e0fc343cdba0c59084c5ca8fea407520a474c76a7c8cccfc97a0829562f75e81bf06e04c4df12722e87b3df2c514b45daf75a78f478c6acc680d72c9ce16121b07d5e337d516069294253a3e075d8f508d73ff322a48e8ff136e94d9dacbc52eaf180f28d6adbc9d5f6f1d473dcebabfa117cc75c411cafc1d772678e6fbaa14c148ccd3520f572d0bf42a4087c01945c218f52c81fdf2ad3236e6d9d90f8169e2df4c63c848abf5806f2868bca527e75ece8d99de1acd78d2f7f9c4a8cc6d78d2ff92829e2728a5b34dc1e4cb66e103cc19eaa41eb52093713356286bf55d79ba7919ccd44c896c4a44c61df3ed494b69b2c872cc099d051d348ecaa17af2bb4aca4785b03ea490ac6f35638fc90b586417e48bb981a9d5de607965981a383f5bc13708bc22657d52331862971bd8e9d8da5ff32c263d668c64216f205782894d436dd5e407f97d8d6916f79cc2d19b91d865e3e016bb14d2e1260e427ea9c7898231e8d59a75e2e1d9a02a500f186052652fa1280b3c0e37e77361e749a5b8ad19f085bbccbcdd962bb63a4840af6815d76487a521e1076fb078a70fae13d00f3dfb3c8681f2d220632ef2879ad79b53b5abdf87f7a9f5409446e08e1a04c1377576c0a095d7e521f738b84034165b02737fdde00c8b5b6e27c4bfee0d5b5213599597a0f087cd4197972d038997ca465c33b1808b80cd4b11cd00b72fe622f6ca9601f60ca9908bd96175887c1df456dd6eabc4402098056b84b3b87b1241215aa30a9f11fdfa38e550c4932edcced28ac56c591325505814c2c28e430eb860cb551c1697ddadb7c6b2c4353b9586e5984860f8d0bc888c6cfcf854d63cb770965146d387b4bbfbde14aa8d3e1185c21ea62ab52ed754244d9b48a954a16e8328932c77270b37d82bd83226233a53d7634abeacb2e1de521f161eeb37ee603612cd730b71c112f9d8ceafcd0f2d38fd174d8282832dba815560ecd2e4f207f3e6bcbba480ecf9d3f650be895d47f4b97e8a401ec5f638f248421ea9d8739f7ea8343ee84f6e4c42d29584e4f19446e467314ee9c73b9e0e23ed44b4a52381db24f0f2a128d9dd14ab7074ffce7431de76fd19f4566e5d3078542b70048afd3135a70f80abb965c41a40a47d73024fb6f82f82cdc9fab0d412b930b73940562318cbe5de7e0b6d1416057368a5adf6ee0f26306734827838282c987cba2cd0b8c9f11c481c8b197c03341ec7f6297c06301657cecac03faa0819de4e5b4759937c6496619d08964f84a090f69d0382cf65eb61e0b9c3e90109bc4bcb71d535231fbc4bb8c9c2b0f9c5567b43812b9c9689d9c6c522044b1ae9d4443d44fc22dae32c9c25f6b6b58ef7c7df722b69347bae205ee65fedda43d4d399631f53e99d41f4b66ba99372eff11a2e550d25ae9c8b2391fc8b5398f9679f896ba5aca0038f5d842ff3e49a5945511e24d39e0e22fc762493bfe672559399ae6c1d42dd63157492d625e41a7c52057a2d25f39996f62da86cd004458645b19e87906bae64850e1b913d804ca637fe928a6eec8a5500f9018e8c2de9459110d9afad525ceda7a696d101a2abc3e041945a3c1209251d097b86fd2a9910ba851fe969ab8a8260e78d47b13f73dc174e9703c41bc429661a0e6e49ef48d9cd60a11e4b305d769b51847faa507d72cdf9bfde25d84f114d6c6284a00bd4fdbb56b6efbb100052f7f05e7d78818ddcf2ce95c86ef654fb04c56a1f6776307289acb096b8f8ee150ab98ac9609374994d0691eb30f3daac43e070aea4095d30c10584847ae35726fa293ede0a590d7ec4ae2f200841c47423a1a7f2f64a0af9724ca8e975b2d696478db1d101b46e799c8b857c321a313eba5bdc9db7fb6f33ccd7e37a213dcc639ac0fdaa5e60543fda9df365b7bfebe12641e39489c29d2ea60057825ea0683124417d250587eff949c89b026a814568fbf7646da041db9e260bb6819029117e76d5256e8f4d7ac538d544d9a5970d406ec072221114af65c9a1a57d314c5abe0aa06808210dba4fcd6dd7cb9dd24b98e1e33f910805d05e011bf8f7fb6faab6c2f27e5e1ed6744559918b4ee64c4e10ed388577c52844575bf61eea31ad73bfd294c7bd4b8fd7d52c207d6f61d15c3497634f7eeac32198fd32e7b7025eaa44053bfa27c2529ef165679a4f4c989ed6485081d8ec80183d7ba7a4f01b863e88e0f3dccc2cb053d0e7cc6dbb811d6c8f91772e8c12faf241e5ef476fe02a389787124399ad503496077c67a53c037cc06b6dcbbb07118443725ee76ced16f93026a056187eae84232ecfba37c0885d2841ca10644808ff5d69bf5a2bd2642a79e09c4a937ae9da171af6dd4d6b43194cb69ccca1051909cb6e3f5a2aed3196530ef2699b55611b7aec9b77b3302f29a70dd3d512163b245515985d04c45e75e057408c85eacfa8f8dec0450c9e158cfc349cd8c4913d09546b051ad6a12325e6219b81e6fa7557a9483a60c44d2d13ee3c0b09ff5e949ef9f29afe959465e0b660eb1f9205ea3a657bd7764f5b99c390bba09a575750660126bd62f3ebe0faca47592ab0d28b819c8b3351146cb934400ca69a8bedecde77d9dec9dc2e661b1225207e606f6090efdae29f900f5378395aacd411382323219060a317ae5e5483607ecaa1c2b18e307915c6d23bb879c972018136c92a2a660394916d9abe0e44411bb66f509d3d6e1c3580906644769f6a2393ecce2dd4e50e5d6b45445e6ac48b6261026bdcaed5780e6251a45a27ebc225b1de5b37ec4f603358a9dec54cec794cb593d012d08d420c0604591b18640b0ed2f33ddf21fcc129d19730384c2ff0198b022ec1dd0ec185cb1dd5d02f113937cb5cae19aa40390d5d959488231f63f61eab57eb5801389351ef13ff76ca9b269245a2fb4fd1740dd38e2c16f7ef18f3756ed70dbef47ce565709a0405b09d7b14610234eda6cefa72936792dc3a60b68d9deb98bc31a7f6dfed9c27d78c53b0f3ac009a29294d16f0828c3be5353c28e272961701562369c9134113787d2ad70338101668d36f1a0bd23047539d002182f5cd10a4750dff42a5df757c783569d73944a6a2bb38fbd58018f374dffdeb782bd4e651630f2e82cd947e9c9345c0e2d9737726e7752f975740b637b3024ff5bd910ec5af6b8ba96b636872ecbe773d619b0db2c26e907bfec94992e1b77326ed0ff3c038a6e2f2138663ab40ff08a2d3f5a85ba5ef4d1c508d098bac7232402b98b21d247f09df9890f8bfcc2cb2f70422c063845e47af17aec5f8fb0abb046bb4f34b10b6892f1b59019aaf267dceb76c2cda806e042f9f9d6fe956f875389f6d7af4dcf69c840af9300669fb04569f1bb25d7e872438cfb38eef3ec6a5d70dbd2b4c5c7758a96e79babfa9005c284e74e2f8903cc7812def74e561da3a939dfa0e391b5cc40f0e493332d24e32e258ffcbec688688c522a0e13489bd69f2c0a3a16437ebd64d6e000bf4f2c6f4493eb35f383d0921f6156cbc2bd3aff2366bd29dc256e8933dc7a9d48db40037d598a63af57f02c15918fc737ebdafed684f9015ae7927b0709c9132636e0d82bc0edd23758ca9749c6dd93aa8699d74e5d828f46b8f2a450dce47b5f905b4c76a8c023adf873e3a73cefd7b946f7192d3f9390d7c48be4785df9752ed36e808f75a110ea32c252cc7cc9f32c2eabe5a9f07a32e34e590db894da772f1582b4be2dad70870d3f5777461d201c392b1db0fbda083a2043727acdc275692731ee6d7200504e0aa317b62c6d1e89e5a2ae5f9cd4ca55ed20af26c1ea3bc2d1b49c07a69ec751f9dcb6a4646c8452ca9887ff8c99fa12f115f619bcea6224627b5f8921c4b4d3fd5e2d8be67fb10936c0e1357fdc677524c15aadc57161cdd4c43a9a2cc972137d22a27b9b64d0f68af3ff61b24b0f7193572fdf714412a39f45684f75fd10833a3117a9a00fd14635eaa3f2721e7d7c23615a7f01f46c42c36f46bd54b6d716d0365a751156cdf75301bd56bdf559f5a8f04ac3e427301d8294508abdbb37f12607ded2f66d5e1203789337fc01507b034f27ff0eeec71846d497b7e901df0e580af5b591ec1e7ff60e4b921e008a17b90cbc10014392fb1291ba37d3c6496892c55a4e2d9d7316d795a474ffe6577ef503affb5d08d16c2233f92df2796fc5fce68a1f0fee0a2e04479ed60c1beb096e78ae3203dd64b6b0a07d448f5782d28ac79df1a2595ea5e37bcd1abf80a056f7b9b2d25ea5a486115fdcc62c4c3d934be6a242ee82a3b7456d5ed50334960dd9fde87bce484b9f4f41e3e494902fc64eb722a5e4d995a26e97d12860736776c61728fa873b5824848f44a00147d0310de78ae122d13aee8a4f91e2a3761ba6c84386d85e4090e09c94581b03530c2d0bce4dccd9076ab1e9646daf9d0a9d8b4af8996aa6d2dbf960b6bc21b8cf23b463d21b4a7d91ff8fa0250dc0afbcdbd2fde38f03682ffe2f1bd280210e9f1a6ef96fbf60da33d06bd3ce10116ab0daf477b50939aad19dde63842a27fc61863492272d288b91a332e783b732b136eb012675a37fd619a5593cffd52c30d025679ee4874b74ed9976ac8d96863dfe61550048b14adcb5afc53e49226879e507eebd3f2198106362874dc598ba8fa64d03f0973daaaceca33218a074ccdae93c1c07590d78cd655bcbf60b4fccc5b70af0685c9edcf71cb784cf426585901a77db8e6c2ef37ac8de7aa102dae2304f7764e4749f6e3d95c47afab501c8bbefbdb5a2c91bbc20b1b38cbd68d2d9cd5a783eebe0ea9b13297ff96ea26e79b560b208a0b924f4149a87f5cabe967595b0033a0cba62db7a5bd66f7564eaea4feb270efb14afd339647dd0fb0fb35f88a64e5732169bebe4ee2796545fb6d08a1a246fe59c70eb3d887ad3482137d882512533338fcbc207312c135dc8e4bb20376e06a3cf320c301b335887bf5af0f6cdf533f66e5b90e11bf80b1d99c816e2e4dc9caa475300be06f5a5fb8dcd9ceeb0cd8be3318dfa7ad61eebba2d67e11afc192e6c3cf8fcfb31cf8f768d8352e24b5a5233a35c212572bba7704de12b22cee7f0db40900dda0142b4ac9f8652e86c1a0d720cae3f7c6ce6a57a5b79831ea93c9873401ed04dc4fa0e1fdda05d03878acb1545207d2d3f537ce5199499b5d51567f7c1691cfe18da8715e60a353f51f138e16f20c8bc8f4d359ae62744be4fcec6157943e824df7b9760725274c9b51cbac0f27f21981622d7e4774613dd1c2c00d146494f3b6752f004a64030e3ca366d48dd03c72b60d0049c9abca3a6273d66e32bd02aee659d7730f93aedda05b9d62e5d0ae50fa403288e626d804cfda58f1604c960114cb65451dd3b2a4fcfe9e6d6369a3759d703ef9ff88ccf5692a42111359c60922a5795059af1f9d5533591baa29aaa879979302c5f01de99dbbb9e395beec4c161d394d6f4b89a2502d3281d5124b1248588efab32820861b36fff43f8b5441f5c7560eaf849bdf65bb8120b91ddeffc2502912231be41872599c4230627f14cc1533258265524ae4159a49cde1f815369266a853907bf37fb392e597b050d061313ad763f6ff6da4c0a100fb57f7025035fb23fa539f1f12af4dc4fb41a4eb3cc5d91ffd4625671367e38efead75c73b6fe843c9b2f7707943171f4f911ac25afa31157545452df46986a00789975442e406543f4c19a47511584d5a16e23dbc771a7cc72fc6ddcda056e1eb91b3debd87163c5aa2f107df9044be7b2b7ee82afabef5ae2e2abcf57869765df4ef65f40ff30e8de2cb4d38255599cf72be328e19d50b9d3e11bc3e12c2bd660c4035b959b8322952bef13d1a93be5bad6f2154a62b88c087ad4e00190820f046d5be5248551620f452607483daaec29bdf20ad99acc0552c36bfce1fd863e48dc740936ba36fc3a6e67fc39e68bdcc4eb70299708a824f816a64b7a19f8151d4bfc327785db98009e7047c0755b68e22db476cd7e6af1498421d181d041622c0548bd6231702738042921686935e168af968c536a4b4fc7283649bd4ac50c72aec78558758c8c62a4b7e06ffb6f640fb89b6c672f5c6b9613ab1c94c5f55c5aee831f2291b6f018261f1d51b64e0b652207b6cd8513907a54aff9825a3d21465bd758c829601acf541ca34f8fcd13017beb5bb196165b73fa8f20193f1baa6eaecdde5ca83cc8240ff2a292cbba71dd2ca635f524bb0be91d0a0944eadd688d575bf3fb74d9b332880feac724c4e8e60dabf31618784c67fa09580483718969ccc42f29081112717fae52a3135d191221fcab31fcd45ceed81679caf8fe7e0b99bea5a65b12aaa6fe3d6ef3210dd62eea799c5cfed2ff476945eec29badffdda6def6754c92ddcad6910d52714e80ab6b51781152f263089fb45de0b7a6d57920090f2108d8bf5fd2bdc0d30f7c5b0679c31b780a96d3b6ed0010c1f81c9128e116d8424e9ccac1ce0c32d2da1b6a0730fc397c5028220086df4d4d1f7ab1ed00b1944cfb0cd852d575bcc89e2ce8d64683d6e1c584609fd433928e894325e31aee5b93a8bf56f556ff3bc3e35769f575c89e50f8c0a82cc0de5e3b9986c1a3acbb3142aaf667f0e0fc148e3d2a932f2906d30814d157f720552fc22c39a761c1f71520b4bc54f3c5eeba92c654e5e3a0461845a7424541e899f3173a036808a53a089ad1c220dd52086b7555806e8ddac83ba7c41418ff3fcc3bc8930765621591ae1f1cd0eb00ea05fcf1d10a3e4e3fd32cd7e905b5d638adcc2a8c11f064612c875501bc9ff55488aba263a76b67ae9518789874e85ff96b2f54dba9b5b625fcf78211dc6ff8782a91ff989660c32451f0016093ab8d207d713542175c639c3bc015627b0f94cad2834b7604cc43b5ddae8fe85424f6f9c9f1f5bd74af2cfe483c1bd1bb12d681013b2807366ca028d66cd97f1a1b0bb5935064066c214fbaa2ec9b27f9e18bdedd23fab8349fabcc27a4c9d38b8d9761050f1f0d7bf04555dd123aca561bbb4a3fb95877d43e76ce7b57303d546fb1267bd37f1a9f513d6372eaaf542f566478c8bda8f88e218916259ac3b80ae0e0606b91e8abb02233779f233dd6526c44fdda31120db994acb4bda091dc2617f8e7dc4a503fd54350c022214163c231eb2499e867f8f2101d794279add59846d25df2885a6598021346b23958aaab26e294ec9ee0713128f57ec422d5f11b0f1c5101f9099c503f6f4a3f83df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
