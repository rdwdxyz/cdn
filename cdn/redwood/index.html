<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4e619b53b4ee0fa46efa9bebfd9f825486a6ba728cbf4375c788fcbaba63d0b6370b5d48b1b428dca000dbdeed95b993888897ec9e2a8ae9b2f378e199c687a211ba33bcc0616cebaae23e9b44ad1b25555ef6a186efad6daf703a1efb5f71a9571381b3b5e0f441d886e06632e0acee138422e1a62a114f742d09483891caaf016880d4bfbc52e9dd936bd536b6f444d25216d443fdb9f5f65fa31e021714b2d712a78235580ee6f4dacf88d96f1195d0647674c88588047234097969dd5474bc284c0e8b94769bf2e87882b1ded983bd53df5b42cb1fafebd9978a387d382445a1469c449921c109c60c50a91dff6267fc033e13467ea4bee0adc1621f055476c805a8853143c049f75ecb901bbbc28b253928b66b7cbf7a45d96a6161ba185b4775c70411f1ebae7c79ab2ce197bcc476818a5c78e77daf7fabd5860ca9b28a21ef4589220da925db21bce19231344430713b0e18e4612df8f563ca12d703bb3313b2002b558f6e1cb3d899e1b02f391d6c12b56443c1bf5db70a69f69f5a64eb3714a6e115cefe8a934b6e64baa9daa242c643fc5cab02c878f2e40160af5866c28ed23ed16e340448ae618858efddbd1eedaa5004e78ad5740a1c41c13ffd5b1cd7375a4dbb2620c36f2db8284f211d90c2d3d02c587bd939cc70be41448c1bdbe545c33dc8fe999303e7c4cd3ad03fc56dc283d4b96b304164b1ada18d4d68803cdaf63a693eb1255cc2fc21c408b1ee957afa97c4334c95ac174d558df23f01f6528127e35a35b4b3824f2bd88946a6654013ffee021c4f895b9637519c5d35de8ef69567be885036f470bbf24620d1ed9590be7547fca6d56c0e1fedd8e57e6bceec6f732ea2705d9bd02407677949e61a25b16a2a78b17d29c5e5311b9ddcc6e660761a4b72995562b184ff1cd404c0b1d64aaa31e0dce195e3735ddf6a4a10d42e0a2f7175059998d566c56a678792e16d0a5465a07dd159340557f6749a781408d087b27bf5ab0c1fe6d4855f59427fb3de6a1f945095153cff05a184df8b546d69f714a33cda4220d7d2b16b19740f5e52169ae1ac8560e3ec2f453c10b4ea471b3614745c733b504196dcc4664f6f94204eacaf82a1de940f34caeccd1f5a59e7dd7f641dd24a540a5308ed506b1ee7f73d756d014dee393873dd22b358f1fa330ea1a1b85646574ba9ddcce6150a06405eea50098be4872d48acf3057ee740874c7cf2b6fe60d81a712769bab785e69491955264f485abf1359d4a7a35f720d035e062c80d0a0e80222bb0e10fc82a67a988bb4be73d0a4ef7cd91a5612e9c08949b0a33dccf153b81f7943a0beeacb40fa90a77fd3802d4c207edc4f45b35833a5ac74347bef9e32507f6e86f4024b4aee1f86e9ada625ec9d4ed8167969ddfdafaa95fa337be8ebeb62c0cb3750058a60d19738e9e381e6ccf69deb3ea1bffe124ea5f7ab911192c89c11889f7d050195ac5a72e546f8d03b970337a7adaeaa280cc8ff9aba71323f1ad534b981be5c82f77c3c4617c9e85d3bd895547baa923245b93087844ffe075ea704a7bdffac3ecf571381beca4e4c9cc55897b4e12644674c866ab776164e1b0154f3d83caa647896c14b0223d80879e5acfa30618c96e03df621ee24bdbba8aea20c7ddc9416f9efb812880e0ffdb7fc106f61dfd9021e3c6cc0ef54b1c6d960ee1a62c0e85b967750b6eff1de9140b81897370086d4c496ac7cac256952ae2b17c2fd67dd6a38f6d25015b6d7d845c5204f4ea07f5b4d6f1b5d96cc7a19d266ad1e40ee1fe18f897ef57d8630d63a1a6d285c3fa8f5a7d34c1e5ed9566cec858f0ee085285bdfcbc315f8e3a9bea6f5fc23f6a8f62c3549864cc6fcb5ba3d4403b350263f9966362959eacead771a92743f6e2610f868f8559893a2a7c5101015412f8a605b832c22a2d4be18a651d3b2523cc5084a59f531aecbe70eb0717b4227ce9dc1af38cc4870ca2928343dc17f639e419c6ed7054c3e1531aed2753827efab9c30b0141183d60f857ff60ffec2ba93419ec70b2b7851e842f3439443288a2c0120d3321bd7c7bda1d68290ba3b0026cdb9a6e8e00bb5e32e37d3e114a52a035d8e9d7f004227642a8b5e3141d3133c9d000b4ddac781b44350119866b6a3eb956890803f9e6a15a12ec133d169206dc9fb124c152ddf41e01f649a0587fb4b2103b2aaaf24f822dfc8a4c9c74ab31c66c7fc479282f4123b1c18fd9376fe46e372b15339ea79372526f421c76f2a4eca5bf648a3cac2c562fe8314f048ae27ef35694a42e2a147356ae1181434da41c93369afd03da1a7608bd0d1e96467350a6eb9d7291c5ad73b18db97f4c28480c493fe1f13bd8b5f45a393642d5038341d157a51faddefd04b483e487ea2523974e0098da07908564bc7c1a8fcba3cf1aa2c67cefa75b819c7599551d4a23e185eb1e4e3e129cf9a2234d7287f6728b18e250e262f85b24fd964acbc91c91122b348ccb0eb2f05e81ee99bf8a84e8b3eae3c243c4c9d8422881c640c984d22dd76e64de52dec78b1cb11d56c299a45dc27cfe44a93dab14f9545e300f13a8ff92845f0c0e66521586f20f695a81111374b1cd877becd1b31418a1f70906de0a0eb297b585ced78c16904656459033b775cca096aa0ac0eb415ac52d6ad5032ea97154aa76ef0c234ee78659c6181cc55a9584bef11d4b0b5a8bb0fe3098a1e0be5a4dcc081eddb2b5869b772e96d2bb5a0d21e2bfb4ce2b0ec04f8d5f282c407615c9aa5c0985538bfbfedcc2d2905dac1589956610cfb281f93f999f5329bea332f62b0397f83d5fd1c74463a2dd962db3a575eb87a1eabc3a807bb040f49c33b8ef1a1ee2feeccfe486c739bbdba59b075bf6fca47bff8f0804dae3d96a75a560c69c2dba82473681fc1e221cf537b537b2e82a26c142cb9af08939797a4a6298a7ff10c7797f75978a836265bdf6ecba7dec13094fec85959bd45964e45a761c5960d2e0116a32837e17cb3147ca6e7726da6ab75f1f31968856e99b54f706b378cc1e932e71149de095578a8c12b30097bcbd135501ad482feb88beda72cbea43245f6a5a59fe069b513f7f6dbd3f62159eeca74058f250e9015015f38ec38c02f0ce1d012544955c5ad55c11388a638514e8ee41035b919b35d694d976c7aa69e869a54410badf58f50a98e39c442a75c7b9832aeef5d199ea114483ef8850458c50fbac8ae773834f6d213c922f0febad61e9b5bcc6ac37c7a1b48a660005e5c89508d94b304125b1897075b847409a3aa156181683d16978cf5b5542b28378406e54d01214ba485117a868e2b6d653d2b473ce1f233665860c73bc6e2dad101ef2cf5542b7e8e166544aff2786f66ee5131ff1187cdc8c9d1815a88419c81275c41872e3986acafd44375f505e78769b1f8af09ffa1f814b5b93de51c9bda7b9c32d777201e4a322cb9c029acb1ab11a4bcf4d94c158e3edc4b48b84dc22181277a9d46349bc315dd304cc94b46e50a2ea6aecc0ae4c6f0016d7e3536a87cfa2923058f849ed2b3eda5cd25ca9a3dae4e9e21f1df8a3765d5a4393fb4366a4cac3de6b734cb3c36ec7ef506db10a44b8c88185d01ca4e185b880bf4cae3b789497926e129a509959fc84c92d953ebfd32ac134e169b17fad9fa4264591a8c4747f418f41f963a7c42d4f761247ce7a11e421e5a0a22af24e96d2cd4f62b76198a4905bcdbb073d059a65b840bc4a81a1e154c468be10a1632baa4ee314a69a2e8701e6e3f468123aff7b7170b19013d552e2bd3228fa5040a6bcbfa7a38bf30945778e206c5a8bb9c700073c6be2d6d62c222ae67b3a74d06d89180c9113e4716e7562f8aab0aa4764722c9b88e5437708aacf1118d71c7c38b0a4b71b23f6c5a6c817767b795546de8d510f129be11befb489673dc03fa07b7db1e562da6bdbafcc94edbad16ec76d0a318b469e79b5500af41894cd7fa28ef32ba004b7e21e05e02b002c71eb6e66d801492d324aecd6fd8e98c40c507079282f26ba0185ddd099db0c459828c0d0b43c0770cfc3579930c8def69b1092a35e53b23333da100b843f375c40ab7963836a369d74429291cab32126a7aff56d752282cfff59e7770a2c005e8edf9b71a682f354d44cced00b438e201b724c4506c16ae620fd8ac523036cd10d591fa9a016c1ce6115cbe623c4bd8cc137e9403396481d005a2e44f958e785ab46c9f164519578be32c99e62d78b7070e269d68a2529e6bc382bc754c13973bac516a589605bfd60e48a06ebab186c4b9cb926062acdc0fe0a841011c642b0284f5cfaf3ad161401fa1b66aa9527fcea07785121f318b31a45d2d840bb5acbcc9c523625fa564cf0caf64a661b574cb30001319ce029f44ed381041b9be9b2ca48a8edb7b5c73e68246bed3e556bbfe7251c35c1cc9841cff75029dddbed0d6db3b0c868ac05f50781d70b816ecb267660df31a0aa80a3564f9ca9a84c135b2ddb227a278962042e3ea5a4dc6bdbc05352100af640d870782734f0ea36899b41211418043dcee3033f9791ac202875f73dde418fa1d012542974403ae03fb51e20e7ff1201e2547e4031d522390e81f95068fe52b110d88584bd3b4b204ea4c771fa476690e46d7d935dbe642745360491e804671fd6b8b4ba106ded344bf4e35873f826f255584a4b724eba52879e5979bdee3a1f225b1387658e91c4f13339637da084de8fcff04494dded1b80ba407809407bab18f8d33ddf07515f23ddb2a4ebbd5b95a041587aa27cb0a9524fe76ba00bab5d0426eda3a89f6896ddb1d9612c6309bf355bf88bcdd77a67fee2a9fd509484a8a7f6ccc18cf2e56be03d8007da6b294802b0d7ffca55cbfdff9c537e253ad8821013e7856bde80ca19422a03791ec2011d95c0e7b2a17227b6055d5bd6ef27ea681afc62b5d4bb573e120a27dda86adcccba90aa95ae92e4ccd8329bc105964ef2f6deeb296657a8b037efd496fa7313d7910f4662e0cca2683a2a654564d3520307b565e88baf20c012e35da2130df97d68d83490f82d1f29963d9f11930830aaf86829e13f4f17cab2ca7d8c1ebc82353e8be24f9ff41caf7e7a8f8f3baf0e3706e93a89dc667c8557137a940245ddee9d07fa7cf403b5d6f527e201394cca8143a062a95c83c350fea402c75476b0807c09e341df8c1a04ccac49134825ca50dd3ca6234f5184b05e441038b86b9a2a2432b1fb31756861044534f24f481aa17ce3375eaa2316a316408a32f101c594c25c77701f7a2904e83375f6c1376169847ec705b840d51d1edace1d39ee129bf469dbdb36d134b73df670c69ff323f22f0a3912545ba4b8461bd644fe5dd5e4c28ba4da2a8586ba42867aa99ec2190ebad9520750b3ad3f5711a5d2ee740cd2010700fa165ddbb01f1321e4ad23e64d011beb0f97665b87a89939666669ec6a7145dc0288da76a0b7c74e3ef7e5befa2e221b555b2eab5d2b05ec5933609e4f64983bf38b51cc72bccefef1342e97fbdfec1dc228501dd3001cf149d7b30ceed5f30d3763a1e880e2cab7716991fc198e5e63014c7ee17b2bc1d460ba20db3c9e220d43d4a46018b96dbc20a69cd7c17987c6dcfeb8498b943867a9bfce0795594ccb1d6a300e03453751d86c7271e02a33906ebc44cbc7b9a00d5c7124c79ce1c7b3f51e670b64e2af5833bba0222497375333844d3244c7a43697592d7d534c3d0fe0f4fdaf8337453ebe9d07d4f71697dfd37905f63dd558a06c921483a0efec93583d193259b3c8eb4028d825fb6d12b5e792f8545c75474232d3f91fde538d39088a02b21804aaab5ca67056ec5dcb0b3bd8bddea240452de3a4908894cc79ae9ed32b029e584968e6b3d63313018d6cd66cd9553a85da562179302dd70ff61d83bc1ebeafafaf37f1db80e7a2fc2cd0f87ff17663b5de26b1cbc6c86048f90e1d45c75ae217b09d9327305f74f94d34c67070f2630b49026da14f84b98f3fa32c0faf1fa3138544b9693e1c39fa18db5e316f4a021f6969b0216ef72438226dbee88a952153ae1187abda273b7c48de22c3c790b918cbe842ad6ea2cb18ec95496662b05cd4736b9d0b6769592495cd33d5695e17ad84edc97150fc10d8d7057548199415a6e5da9eae9601f62e4f1620734e8ead6297182b8a035b50ed4a32069f42fae673820b56da6aa9577b20e6e556048ed504dfa1dbafa15f94489a641f29b0731f8a86621f9b14dfb6a415165206d1d3c2e6c9ffb8199b700898afb3af1c3c078782e28fd144c7abb7f2a54f5c62ca9d6a0ca9e43fc83d85212c96a82d07be39de931be5b40d924b126c743cb45be3d14aa5f8da93e43098d1389d3fd8566d584e4645dbda42bda33f8db960464b8d66d76b9d42166fd2bcacd3ab5efdaea15b7b34a38d663be5a1e3146c6b8d3b9c424eb6e7e3ee525397d5925d1a4c7ad79945b95fa453d61d923e0579d1b16141fc50cc8741b876a20e3acfd7370376b22538d5c94a4ab72d31cc3df861e15147f07ae944a046263110b3ca180ecf70bbeccc5a98e2b237558d4ffb3fe3dd425246907bf74caafd5784ba548a8e1673f58c28d8137e4b6a5f558c543d60c73981c0642522d823679b937a90b3af2a1fb3298872bf553bbb7a56733616ef6af458962855e6b18673d8a696a1fa2bd59f2a862201a673bf3cc54b6c8a5488a67d7b57a85cf7f3d60278fe520ff27bb76f2750d0edbada210f87c61989aaeff92b2a6a1c02e0859110730b2d1734893b5feb91f9f4eca3e9495f34288ef08a38bb4c79b2bf49a579fa92af8b16f1d8fe97bf31e7d55f90cc0abe98983ba9fdec84f741fab06ead4e68d52ef219f256ac6af41ca202a0c962665dc61167461a5ba9bfc63262602d529865923ed90532d724f10a663b82b65db13151c05ebbd17623b39b8822fef960107499c9ba1dd3f53cadf1d1a57b969f03f671ec31f3cb556b7bf17267528d9f8720ca5d58554c05693c2f578a127b13e891ad6f6057c5aabb0e407825df21d54998df119dd964803145665e015fd2839638f7d0c44ae5c4caba5bdea64dea829ac13059933f0a687add53dd5dc4943cab0500f9d68ff5928d6c605c947ee2640c77aed0924722928e4f9f5baf556921993cfd0aa3819bc09aed34c8e7dc950967a0ead13bd2fc071babdaf5e2bcafe988910aacae513176bd9c609076be03398cd1038cb5fcf96a117939f160bb10a44aab53d3878628d38b0d8f2afb0c79ec465ce01903239c2c12c114da9828cab4836bf512ce2605f6a08780e125528dd6c8c9e0b60f4297f376d4dc6eb7a62e3bcf8e86b8ef9e37c084a794dfc45cd3495b52cf20377d4db3d5950495e626951c5505f3779477f0dfe2cd223dbbea0ca400d303ffd534c1637a7caafca0d9a8b1dab821fca424a86bbafedcd53f09fd24349394d6eefee3bbb210e23450b62cb8f093a7aa0f3d1e83e429bbc8e6c56b9099282d9a2e9a4e7ee278f84d853f3a4f8a0ee16c7260fec6817d9fc66c7d8a6c1fc0a6ca9bcf4b050c25f17e7507548a27fdbed6b8e1876e7a3a64f970b687fa02a7e29dbf81dc77d4d779cac8c3cbadf6c5389e1dde66e47dbb1c0cb891d5469b62ad66bb94a295f6a8d95310007612dcaa421cd2ac96ef7a62e0dbde3a5ab5880d4ea7ca86e99c2522b15fcb2cc7906c2e995b9181d874160d76dc22999c269da7bd99d8dcceda65b83c899bebaac0e8f4025790b7bedacbf7e64e4cfb7309713e664cce096c7b9a72f7e444414a8c32eb6e08773d96adb204181cf90c7ed407154ebe4317f81397f780b9ccc59076acc326d8537eb7f0c0d6963bf6b482b465bbc74719272ff6a02e81d4bef819b362e80b5996dd8968598c35ede047107c9fe484fea340ddd5675699c59563b8c5d6253693f076237fc94b703fd39fd2e65c066df7de0a18ba0d984d76fc6a51d68a40ccf6b1a81a8c8f14ba04e16248a923ee98b81fa903114b7bf478e46f35b3bc366793a3b620f8f6b80e566ee5265cc121da1f03b43ef5d752db539427eebaccbea9dc25f033551943205639143e9ac7201a6a4ddbd596d035a07d2b0a93da9f4c1dbf67ebd8c359f6d94e10041c6e187a962928dfac7bf6965b750f6d54c754b011329c449960d5ab02b05130b1486846c67b271158a47fd7b509e8f983991b84e8ef03f15c409ab1ffcb5851a6909c8b031943718fb582751b9231c3f907884276d3d47482524cd9623fa9ef1151ba7433518a36250835dd4876f07c828a8024ba7f287d11873ce08ff1706e9d12430746dd184d352f9d1a57f6fd7a95aa5d0948f989e6f96448238673ba51fa35ff78334e3d72502c5cee53e0d6bc47bf9566efc9aff88a4a12cec4e21ba80ba82f452231854f7a66847ee463abe7a4cb16e37aff4c3dae48db68ca3bc50166fe94b9bc5f9478ef04daa50441b0579627ba8caebbfe955c8f91208f6862b830c88b6010d632cae25d864dd0ad7a046732c2417bf5735e9343ecfd3758a76229decec31ff28ac7c1155a7033736ef0f875fe8f612b32db9d8a70fb66db2becb70889fa1a140ca4faae9b41ed93b87b8334ba38e7af62c731b337afafaf21dfc8908df733cb9bd9e5edc64e1156baaa9281b7fa5d2b784a2f4948877b234e92e07ec410d8a2f6ac0f7e6d0e7c5a57102e1477005afc9cb1e956ccd43f876db03b868fa1fa13e432d7ef1918c0704555812414f98e8b58b42fc009ddc794423ce31407c73e5a472068ee5e7d8e171ceeb5e1fa3074895371b0f2f44e14e8f7387adf32d5da17f3751a6701795ba4a3ffdb75c6aa1878a6a37699706b9e10ec8d2ec64dbe296cb8635dfe997e157d580c21d61fee752dbd7c1345610da2b4a72d008001f980308ed6f0c60292f22068a1ed89ffb7eaf9dbc9f83370082bff82705dafdd37a2e14fb8d1c332812735d3c3976b38ccb26a129adda6198418cd338a69b01d8778304dfba2c83838802802f1fce2dfee679422e3590e4357e72608a758e10d1f994c71dfaaa9f10c9f26891d586275a1742ebfebc900548869dd88901678eafbc850f32758ce5aa3f7877c03f69e82c17fb1dfae6ab0a7dbee55d7abe71453572753c93d6ec6aed2d1e604f0f699856252b8de7a1db46829a2b77b2935539bcdf4762f558d180e6c7971f0581dd28212e809c1707e08dacb395d5035deb4abc2c5859b32aa116017eb03f27a0c233da66364826d8c51ecf661884ee91cc7609b9fcfd9240a93bb4684b74b910c8ce8dedb5cd10b513559b5584c717c9e6bd0483386587aa234efbe558cf90f5f40517e0032f0d37248067501e8cdc6ed2548166b82e462f11c94bdd9fc5543e7973e60bae7cd4e6394e26fe0b8a01c9b8b03f348a256557acd4eaf718dd39aa438ba931ccb48c02f549b243b6a2bceba734cc0e15da8f07956a6e10121781803bb373b3c07bd068054ac32e9a7fe6eb76e1e0104d2a72b7da60460b387e981dfb920513235fd1a34634779332fa534d04406ecddfd2e99a71d36a95d0f2846fd309c470234308fb5b41cc63f6b7f008ed0481ff5d05f3914daf857e1241c3cf0ed28b99a2d37ca38069aa9578028cce2100032a07966edd19c9cb7ea8502406b7335c672ca29a5c8b863e8933f0791d630ea18a530d7bd4eca0bd45141c5f3b66d3bf969899905624810f8949066d10a7825965f65146c03f6c875fb124264426fdbf29dafaf98a126acb3dad7c2031fb86666c627c093af6473b5f2622893487c5b4e1f3a0528d983a6faafdd4261ba2f5e02be3a3a685e9ab669194df17fba53defb8c6844508697d123632896a5c8f3dfce4f32137ffcc235cbda32444116065a7918bfe568f4fcac677289a78cbfe1e0d2dbc0f1875d80cdd7eb6dc234876d8b0a96e90693bb080a889a0f78b55c709403967a300c90c97f14309ecbb13ebed40e76cd710918ef0a0b22a811fab992c6d364abbef98d2a9b6252b3217153a2deb78f463476e2db7000517dd5a8da8d09212dfd8f6d6cd8a46d81ca101da607af62611caaff673ad0a79a6d7920a041a9814d82e916169aa3a080b7b46e1bb28afd2b0d86377bad6fa2bfce0862c5519d4d9d566e3cdbe115cda6d1a6bff7126478d88c63ac4c5ec34770b720c662ba33e90446a7adfe28bd0957b3f1c39b38181b662ea18f04c026fdbbe43a14df06dc5078a9651f1ac31bebd58bad55c01cc31d825708900d814d375dbe40b54bec04eff325d6afb04a8d4b1976899d5eb7551fe537d888f97ebd8f36805f3d3e182c9056c722aba236dc8d79ed358dc478cbccbcaa8761b02214793dd18883913a0ac0762f22e84f902d2724a2b582d5c115b18d5faa74d24809ffc310a1a6ebb8c46ee0efac7a9b2bb22f97e855a60fa3523245cbcf863e2088d0910e06415a821335e5fa6dd877d1af0d8eb2d3531622a0ffdc8a52d2cef5cb69bfe0c9796f0c48ad1155192ec4d40c903cc8f23b0dd9c9ca95042a4030762b1aaee071e806e196586e3184848f24b982eef2ec05b19571902331e61e7959734b3602fdf9d89ca5b33dfedd72512d482ec2d64ad6bfd5c29a6a20c1901bee06571d5f5edf409f1406549b53377d479876a0aa87cc8d85744c5ed92c5ecd9dd73a783a08fd8bb9ec6bd551be058e6864c51e7ecb1efd58d11849fa7ea3cb1232fd616746c6264d0e92b5477519dbe4a021ed89607a644003e3c5eadc33042682289be302c21b692184ac4c30890f3764ae1ffac9b88852cbedd41a7c36c4764dbe729bb1c1499ca2327c2fed194b56e4e12a92e24f8bc4ffb151f6c1fcf5471460e2a4313e808385357cc8cf08d19b24e14c43ac31726162612fe885cd5250b60c50c1b86519cbe71f51fda74f2e4298989e2f5aaaa874a0b87d6f0839f3b0d0cae5195a0eb1ff3b7e131d95b00d58a6c26cb6a6766283b1d5cbc05fe8900225521baa36966604f40ee32578d623c372b6683fb31aedcf7e4e19a3c3228fe1856e301e7ccd53181f10aea753c6ecf815e6da29d2a5937c92e34e7b18bb87959de6d9fdb7cf5b17adf6c14141876baa848df6967cfc02546d2ad7baa339cf9f12bfb69ad8be1894014406eb1c61040a2bfdcf90f6bb7c34a3dd17748d3eee6ae2d9742a194d58901b3b5844829069957de365d47d3db3657f42a0bb1d1ed8a370586d6f8163b5bfa8bc8c3288b4eb5a6bc6a475b279607cbb2dfec1ec02dcca1dee380fd342e099ec674b8555bb340c6a764e59f4c373694b06eb8f1c6deb13fa647d5035725995b206aedab74f60ffc954a88151ab8935010d43cf27ec84fa9a48fee242db699243d224577c911b21ba15e89d622871f3983da5a12f38c54755a59bda6b99c38edbc486b96322737723f5a1960cc83a8d194e95b18af4cf28da28ea3abf6a8df5ff866549bb8b934181972d4611e56340f753ce4658097ccfda3bebb713bd529be43dad23cfa60b8e923f8ef739d891024246ba8492aef80341d4deb1e1ab13d5d649b86d0e20fcb0f9632884dc60699cde1575e3e29f8e3c1ada23d6af2c0b8b11aef0782d099f3a98c9ee37497e7fd39f5de9c447407d425697457e3585d0999d18e41eaeddb1f8095623450480177c2529f11ef7ee9284e53f3c88946ca6de61288f8953ccd6ef102c463e4d29954b19eb2436fc3f2f469931cf7dccd1e276117e6ec0a2550e17758f7c82ab28ba8b96ff8f77e4875fc846be3d8ec8733551100a0ca04b0a1df48edc1d92c495b0b926ad090b3f34c7fed2850916e675acc5ad8b0fd99a8c87e1132c736e02d93c3d6fb1539b1c1b88d3ff506dd87243f92a7400e288cb9fbfb4a0b5d9c88d84b99e8caf5ebc47200b0e3224bedda5ea38f618a0617ef86705d2cfd3ef5cd2c8e866614cb534e5fb7a359ad3d18b840621b059178c13fa59e261a6a64eda4c72d6806120bbbd1326692260bd0ab5cdefdb10f2be17449821e91a9a7fb496ade838b493a06e4dd6bd5cd42b7a69e9c3278e413b9b3ab168d4bcb40da58728cbef1abd9f4a318a2139b7516f9beafc74f11c5d3053aee496d730b1080eaf2413b8d6c1f98f70695cc12204346a41bbbfd366b962b72eed96df04ee6f47f259d8023984227089f0925dcac0499ce2c9156420ca372da5054fc7909c5d537135d9e2691ec0768ceaa157030ad2b6f1a6863288badb6855d04a234757ad4411b721582817426de3c5b694880f4cc9302eb65ab8fa0d51ea284d80e61372a686aa46488811b3f4cc073da9d9469753f577f14fce7df57910ebe2b6ed6ea5a4279c3b94c7c9c9818b9586b1b94685555b33132c9751332e0406df458392ee332e67f5fcd41032cdc7f7c13d890eac3e23f1839c55020e8e74a6b4fdfccf61e8acc76c305dfb462d30187ea7112613e58a633ac90a75ef0fd40e72f96f9728dc95f8629b9a4c729acb0efc66700787011c4fad481e256a698526928405ae79eb2af52191719942282866828852459386f5e16a311f29e16fd94cb16e8bf2f27266453dc7ac8299dc1b3c3c3a9539a7885069776117d027317e6a687262651c365476ee4b5151d75a088a5283a4b7eb3cf22246c1671e39c2b9b0f522fa3118055f8de70cddb23f98b3688294bbd3405ce55ab9b11195ac0945051cd9ca0e12aa5c67b598e4c94c8f10638fa38de9cd8d9c534a743ceb5f66dba227bc05afb77351fd09b0f5aa34361bf91af9128250e8b840a0699edbe819fe1744bfc6736a40e4ec249a428ec97c99d2434d3955b73cbe97b7767aec385e395cef91524fad13628b46b5047d07c2b53d8a7e0846cae1fe8d6f2f62992060af2adb0244e6de9f6e77dda96cd13cdc3eb30f156342cfadedf0788a90b23f28a36118ab757043e61bd81ca22486ca675b94d02a53177aec09aa21f02618885c3b30261fe84b17c01ae6d61f37ebcaa723b66faa5ba7af0ba117320a3a3a9ef14e65a036b4fc2474be218ca2c5d763f290401beda20b45610b1d54d795769252add7017c70c8848cbd0da5a45ab438f4d2b50859dbd3918c82dbb3837c09bbe4665a3de174c783232a7ec2fbe335cf6c8a53ac0034f8084ce28cd8f394ed184c6041eb0afaecf1beb842e034a992d057a0c7f5c5dc3f3974dd532cbb176980792e76a5541ca7858ceb94436fe25a2c778923ad80f7a079e1e74d613c4b602ed74cb96ee763228a4ec3205117913228beccf52c7a0410b1252700ea6548e156551b8a09c7dfa6d908bcd3d7e25d2c14002c7e10e40a02b176f511cec37ba1cf544a19b994bb5d4024d086debeea6815a47e78488ac148541852b1fb946945152adb7d05cb913255b043f937c5a892ef6464fe2fe395fe0ba4b47e7be2f1811ed73bd91ea4a349c58d3cc77649643497697c8cd3d0c4f1577b7544e582b6718be6a3e2e2367552a3e6328973ced0f13441894d5ee9e1a00597334aec69026b5cb1c558d86ab30198a7d2c39280c72c7a06033f9fedca2c111bd5ade8c295ab5c0dbd279526dfcf710393b125a92035e013515138ddd4cec4388c83c3d18b988a5430ff6862e659b970693f40b9223e5aca002c66f94c5b4461f87cf7f8e568e404b89bf45fe9c0f8ead6507bb25e2c518b440fe6db88c4bbc06044ff13b7c11218177dab5eae9ccb6f13d5c1cfa205f5e3ef4728ba0ce0ac62444ff4a88bcb999f7cfd9485b5bc7aecca4e51a1833987c3b7c278719274e29fc89d7dd04a042aa90af03a08ec37ebdac83ca07e50864a79a613779bbeb7ffd66923c45f0568fdd6e5301b6a1b9745c9e72e4022f9713641162381d3fd5e9bfd643a10da7a0498188f87c48f56e5f8eb4c98d9056cebaa92b99e70017a15f90f74fd75286aa3e65d73028ff90a5fe2210cf938d398dcf950fe60bb59e69cfc1944626d6869b72d55fa602af398b049e5a75c4d3a506da85f3199d2dfee815b70ffee9142df3cdf88ee6d98a482a3deacc4662117fc0c1d52be54a7287d2582ce86cbeafd92c95168d2c59c5bfee9b9cb3a08fd88a06b7d72599d41df0b16854a1fd2ed1873d1c8f179989bcdfe15fda86621c59c512223bcdf6f7a7e05b34d471f347c0c98a7f8dec97e8d5b19593121ab2c22177aeeffff2906669380c61958a994367b2d1ccd6b3ed55c4edb4077852d569e247b337764d783966fe87a46bbc54b0c54532195911fd55a87df3a59ee18926bb36f1d42eb308d6619512eb4d7f8667f7de40942647a6e41bbbb33cf9295719fd6a5d541d0bf2c61f531c8037e4903d487b93e9b764264c4dfd46de20b2edcfff21f12666832cfd0dcb406374d7b5193276734978a3817ed5e0b7030142c2042e0a55b09c33c9bb0038efe5b3b5edc7b33a8fa4dc4c2940dc097508731e917a8af6a4e298e7983b45d0e100bdd871ab470467bb0939bec8d703125d65cb11732da996e975ec84c7c5f014b79333c9efb6c4882c2d0725d85a33286143cb66a3cd9d6e45d9a231047471991cc0e0ed0597c7e3a207b5b88e3711fe8311ecb5884ee033501e54443afaa0d76baeb668b47c82b4b7b99499d7bbf1d94fcc12365e99c0cb0a9c216ae55a79d21c64bd9fb14391fc3a4f0e9048ef894c9d9f7eb1d65103cae990549a6685d50c794512ec7c9dc9901ede7fbea4ee5f50f185885b02e48313ee7357f27a650cb820252b9eec5de735e367d72d906ccfaa993196e35979ca1bd614d787c01549fa4957b6a0ae8401a603f6dba1e4100c00cc101747e508211ffe67b9641191c136a205230ba6be8d675ac97d6b490962f9348eed3e9f8eb94d71ca59c7b9664ed9d60164bf2455e3e3866eb9ccae7105b33a8a1fc1a33bff38e4e147894105757703505bf6617fcac74d61828362d11a737c0e076cac34eb947537cf8c179e50e026ff00ec9c3805831973e828e2697149fbd6b64ab84e9fbc36d8dee3630c10ea773a816e89ddb390f60a772f3c5c2a12827e3a98e0941f289301a76d58183234328060ea3f00bd53d24d1cfaa291f7e10779fc68eebc7a0bf391db65edf49837e2f1eac98619573dbff9dceba3c2860186029edb9bbb485e9754c647c023396fd308b8a0e9b9e30c100e65bfdd0d32f7e69750f49b9a38ed7b4813058efb25d6850223dceef7fb4ff69cce1d18d4cc06a2425e1d1fd10b202da5c59a6e891196ca74fe8a77d78d176e68f8ddd80ac24b23a61323f1a5595c0c7bd5ee3aa000c9f57befc7236d00d32d44c9de5894c96b5dabdbef914d5811da550d6c6c4c645544a97922a7be320ab07bebf47ff30f3a06b10ade4568b2cd53c37c777e789d64b3851e327d6de1da1a405cf56dd9a266361490e39a4774bde2a0aab98924ebf9e51c88733cde1e9ac01d2d3b57dfa35bec6e89ac6eb83be55ded0a17cdc536926deef2df09ec62dce53eb27258188fa14821666dc1fe3ea8913144d75fdeaa458133c0441ebc6b3b4379386ca9273bb975f8cb2dbb86b778a82119eda75b7dde2345b48f7e63c042c40bbe28853e5e7f375a67277435731460737f9c0c73272320e3712231b30d6da17d96bb7619f56bc715ec8e24faf2a138a6d32e76c0462759c125f50d180d577447c04364e8240a14bde6109a546fa1982c9aeb8f5ded9094c6faf6508483863324bfab41fc95ff7ff7b692cdd789bf27ade5512fec33c0648086a67e30d515d131b927ff4981b71a2fc0a1de1d9d7f79c21a19c38901c38bc11b015246c39431d4bc04c47cad0c6be190844d36b7e11a965f68dd81e6d00053309789a1d79be5bd497f81d4f890b04428dee14dabdc189a04b3ad7682f042b6e2a191a7d2db3f017ae2a91c15ff0a495ad5c1191dbe8464be98b7c570d125862bfbdeb80dd57bd860fa29c025b65cdf70fca8f7724c11ce2454a7c46e3d85439cb6f2dee4494e35a74e5405192abe44b3521a4d9ce020790397b4471a32e1e53f7388050d50ceeb698791ac4f2a2d3df7345b87ba0ed86c503629f8af91f92b18b85ec68ed736f00d4bf07dc861751a1ff260856789e570935cf397bd3b6efd8b4ac1ebd64c46a233e95f0392f09834b2da8f77bf915ed7ac39e10a8c21a8acbbd31571cbdc187747ef976a9a97e5396b1e91fd98514fa2ee68775dda3ea81083b19dbd4b3423f184d183685186c1f266d24e31f560004967d4a0b49215070e2e2d69769980e79d5a770706c2d1d356e39b367a0ed2835a38cc6fb83307264c6eb694cdfacfe897874568da896ff3cca8f39c9893ab7f667cf80bc6c20cdc01b551439a7c6de5746a52a6bd820285ff07ee4672fe79d7b962b4ad72cf5c22f7bf1936bc345539fb412896aeb38618bd8d864fea302f8b3b5f3d12b15778f2ece37c3cde43fe88a542dea7e5fdddf8706f48fb6caa1dcbc3d431da0541680f085a2a8bd96c28f92ff9baa6d5512f4bbf6d7294f80a6c202d1499437d3a8cae1232a924e0eb4b5b5ef463a5303abcfaaa702dc41d191e65f08dbf32c09dc32a659f48f2d6abd81eb310a919cee49d1a9b91cefbe50a5f285670d80d0677117d34126b7cb4575b58e25ce055c7a0ba871207a4d6369d25689dff7bbf16086eb022d3afab2b0534259c1c0176115911115068d7665ff74a0b619684761a9427ab98b74845352e659ba5d4bd2f3c048c90ec73c73bfa3d77f42388b00672d96e2aeaa043bb8bf8c17142a09b390fd08085754eb3406d25172e67b8e5e75e834a6d45afec223d7721d1d2f709149d06de7748b87b78d7452fb176e87f087252c390104b4d4d466b789b6736de279586fe74b1a11bdbd5c63aef1e30edc78aa58aad16d457321b165d95d9679eec6d82995b912c1750ac6c6c8aff0228b306d58d8fd8bfb63d4aff595c702d1974660055cde01666cb609b366ebaf840d81463a27f0286e7268d1d0e93d9bc12cfe5e694135c1662ff051058f6f16797f990c99b938189c74f5391b381f5f71c294f59c72f1600c05d81b42d1cda816dd352748aba540349e4189461040431571fed92c2b023d83f4c5b4a010ba8e74bca30b56909d612bb7de7e027cccbf8116fc3f62874f24ab3a95aa677c32520670f3f83429092ce2619a18214b0f4fef7500491bafe6b82fcaa21a5e71477297135c9d0f31b96c4c87717cee3a3c586931625710edeea2efe0826714e0fe674f748a01a855c6fc8dbbe8fcdb32efd708dc83bda7cd541c58cecc9663c608c16b59c3dbd4ea5d58c76db5e374c43a193ac65e7165a5703ed38ff039e60584588d8471db44d843f6f026a1a8091bef3ff445cb8064ace9da60773e97277dbe80efe794cbb9112fb4f4e03ab039abc3151a20e60170ef5e739a0ebb7cf3f21eff5b1588ec6d4a02896eb258222ddfec84b017ed0321db7efb3493d5edc794515ee76bff4d3b7bc32939f361c9deeced7f0adc1cef6fb5382471fffba98db50d943bd5c3ce8732357a6a0d10cb5c80752f7ac61bd562da48a1910a5f6533f62fa47adb09f19d987c74d3b3734742a21da87fe712aaa3d3396dda9b8718f13c10151049c08efcba9043aac0fd0a759004163624d0b66fcef71600ff3a61f2440a454c0369c53ce9e0b75e85bc3ad52ba1ae3da790c5672b057b54af83560b3225d433193b35bcee889cc0861a53331eb44a678b00a238e1cad0049dd75dbd117813fc57e5d820ed058a0c244daf016f8b43da00bebe5b0159527c2702b36c1e7b795e0ea08fd3ee7c09620141e3305b71dece15be2adacd547267e5de2a08e99b53a6af24a127d224a9f2b5a64442a0843a9b7c182d3cf00fa0ce9a1ed22436845cf0382fc27c87c6617195dc0cd4bc6485a310120ba02457a446ff7bc3a8cad2456e41b0c1120e17b13683aad9682634337e3ca4302fcf6cf85e359640b55038232c3028896106340e38f271bd89dfbebafbb162e36db58a4739c27983a47afa6849cbe51008f173d5181e458965a222eca669b733676fe6845f736108b383fce2a861d61f6e12ef79991540a8a4e15750820f0b9d9c9c3ef4c1ffd019b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
