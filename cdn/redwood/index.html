<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6200a2ff4b1b0373a0f682c2fef8cd070931e26a4c60418a78d4031bfa4afac8cae79fba04839ccab11aa37c61259ebb669def4da2d32a0e872d0245c058bae39732b4365c1b66b55eb7e97198a27e520f6a8b14d24124a2cea4a1f9a0b816fca7bf8b9da420457701308ef9e9db5895c05aa96f6d61b1505b67968dfcee2d7fd84ff896f5232b58d674f0e7da5a734cc7c153c0932f387c07922f1e53a912d8cea912f36cd0f5a407c3422700c3aaf1cf3b4fe5926c4d576b10a6866551c4189e3d1f14d52377db7e4e789c5251d8c22c9097ee1ee1145dccf02cee2cc62461caa7436a2a2b8213166d3f39a08e7542a5fe9251231d9379208bb1a26a650c5987ebd0b2ce0fb876e605cb3306776f2d4a4b0cd27fed76f42f7beec88071b72209cfdd152f7767be9b6af6af156e948567009de13e6770ad6a81e69e4ebc3644a204c5345049f76c60f3ed404b698cc94223429ec2bbf8079c26e23bd15cfc6d11fb057c4ff1a58c1381c86e98daf8f425d9bb04a406b073e05bffae2ba9218505c6db11dcfaed8407dfd8a8f4da9a8d561b554d48099e02e17192a9738281e1dc63f413fa4f270e744b8ce19d6c26098cb613fe7f1bc50074ad8463a560a9e1d34b476ab938226f308bd2736e9de79027742676de257ebdbd97b4659e3d9cb7334b3a6c7e2f2f26302250b4d345ffb17eff925c4bc32177fc0b0d003e3f2326f6eaf31218b00dfab863b31a0ae6c1fa2e6fb5a1f8e27d2062ef66dac12fc82a0b24f5d86eb015a693368d4bfd11ed33cde510b089e6e44828933f8e4aa0c870a05c265aa3cf87e43929447aa6659e9b95649fc374655098667a14d4056ec15b506d15da56d91bbf7cf6daa6e7856037fa8807e9d3d9bfab468136d3256da1e9b91c2685bfb9d9f18b28e904f2be66de478b214cfcbd363e7a1e636c24b02be12cb60ac2e8e89823c52df6dad54b98b2198389fea2fe4d838e8b7a56e7433629699edce97e8e1a75cafd739cbb590422032cf946115b40a403a655aed71589b5f22fba7c4d5a4714bcf16fb733aff7629e77467c189b622e292bcc718a81d92a4d721622e8d84a2c18ec76cb2143edcf31bf91a7732c3e59a7ae7bb49855e3d1c9f17545fbbee13bb7c5196615a74367aaf4f1c7eb7f5d35109958bfdce4cf3b36a341ba206228916ecb316f064d21166de4df094dd6616d34b29eec01c130a7596e75986a0dc55b15ab46f980b7571899392a09887fe5faf0fb32c9120154277f7f6789978d043b9d4689985dc12882aedb8f38aa50712558fed987ae9bd7b1ce927764c5ce10a2b03cf3db2923c1a328c4c2d02c8517a863cc90e3260c1980bea80dc2ff9365b768c1c3686a4ea620dc6930ff070dbcefb42a3b475d74be6929456c0ce9a1a5565d18b0c98ba0873f5ffe150227391872f9131a07b0dda42caca90af35f6a36ff2f6b1be3f5325fdde246089db261c88ef9a0c1c6fbf1d795b793b3ad778627aec9d39bfc2be383f1b5877fd40ab95a89eca3bdd5494def6e8e5433e2a49d82998bf0af455668c4835f88bc850911acaf2eb98c847acb0b6043ea01f769561264b167ba6c966b13fdedc21df7b7a8fd9e297adfa8f83e6fb1f342a40c7fc593ea2af58b243ebe1b747709540fcc7b16d109986431d89d13d1b63028184ba8ccfc5918ee09c581d73b563b6296ffc883f7eb4ecfeba3e9dab0a2f4932dfe155cca67419c1ad24c6e2c1a78923cb2a38811075aa068efb02d38bed4a6a8a023dca9c0aee96c621956e4c037130c10e442294eb1cd0d9508b1c1873e879a806e43998de9f4439d3c925881a335f89c5d2b5b6af61142b0e38b8740561e0411ecea180769057729d265945178f2903f57de5ceaf3a713e83f423add97827112c8c96d1b9a6ba6898ae5be5857f62bd867b5dbc925e9635354c4eb18f3056cc431a411acbe9d708c23f84418b370346df2242c30a4b485ce616805bfd97c18ef24f4a9b06192e5c652874e4eb0c786339b73a4d2c6d83bb0263bd10c0bafd0cde72400de265028d0eb921538726682b12f18774ab0fa7731900de8925ae4a95274e5d394be41fd1f8372d06efdab087fdbcdd71091e79d1d61dd95b1081d2e7bcb6e034fc23c34142dba7b9bdca6695533157905119aa4a8d04cb02d71f830f55649903e5e68af727d0da384c11fd10de090d94c8bdbb3895c2b03ee4fc34997c52d50b457a6ff6a7ddfec8138719252c1e0603cec917a65e369502159d9942c154df709c8b90fa56a02abf0b6fc740bd7d3395ce3dbdfae51fe2e171920ba0eee737eb53348051204ebb8d6ab7ea0c75288e12dc4c68a9755872d9d514c83c50a1cd6ce14424d6645e4509c27d19a90393ff6c1d41be1d533f22db3272756106d5ce6b55149c220cec2e20b562a33843b2ba879d10587bdb8cbfa600fcd58825e3d67841a65409d8a31d2f67f12130f13f1f3115e024690f715bc3b8f02a2bff82843b4c24633b6995cb3d7d6405ef2db51d738230d9dc746d31cf0ebfd0763a7cc478786d1f6891b89e25f696ea550213e4074bc8f27e83af98f3ffe502e8da9069ba703af59a284f95b9922d635101252f5e0dd1910302c7486af4afaa2ae5d4179987394d6303711bc3afbe63c2b56e810583043edefd67745350e5be3a019d15b688b190d1831d7deb6279e8160902ae266eedd931300bd96a9c9ea6e08d61c8709dc26f6346f0c32d39915022822349f12a04036e3afb644c4fa4c1fafe2f2ffab29023bddd438416492e40e4cd937ee6c7e9bbc218475197e3aeb471cf35ebe4eb9fd1aa06b58a2f121808938f07bc9b00b8cb3ab344967d1c5b02544de92ca0bbebb7adc8163e608577ff47a175467814053d6c56c0eba60386b0e1274e3d9112d64c63b3d7c3e7debffa9aeec074ca20d0a9ecb153d71a85246270526e198fc77db017fc719641d36502553144722d1ddabf34b3b7a2c8e852b57b843d97ba9e15a207a25c7de5144f2014bbcf77f534de44fb2d2df6200a696fad0b1fcd35772860e4df89c35979586923f7e02c002c291a62a494a0b3f56c7b50af0761112cfc28591671277f70d6aec592f6e3a7235f1a064066caed17a6377c121d2cdeee4df4a095c1772857308640c835ca2d4f6666a6a1db0f8040ae27c01b06eecd8dba918fe77040234f5ba90135a020091fcc6d2e919dc0a54954bdaa2d921aeeb1b2abb7ae12901b1cfb694b0d1b8d0318510079bf218028b4a66f7d4a3683b4d54ad49de424853b37b5a4dd0a9e95c77add5fbf88e9c5def8e55df4688026457fbdd89524b9b79e77bc85a425dda06b37714a8d4a8e921b12f6299322a4a7fe4bd312f32c7111068796cdf5cf964c7ddc73e18f1eb6c90e757b6a9ce5c06b448b3462b0e24e94855f337469df6b5ae3b91cc55e860ee9e6c028728225dc3ef7997bef014f30229cd00455b6e230e6eea098349d7b9d5e55fdea5f633dee1f6dff792c9fd0ea59b0bab3350608ee935daecdb1c6f1b22098902005624a22175d1c4938681c3798ae2a71a661db0d8b26b134be317db19741be6d84bebf60eca0cc6809c2452af02f157a05b34d5aa7634c454e5c4545b71192722e9a6f8517d24533383da43388a1ead2a129afa9c6a11df74751635cd19cc76f6b7f05343652cf5e7e89ad44e6b8786dd490686f245033974e7cb45f572a8241a2d9953370b75d1da3851d538ae155361d76175b97e22084a840ee07cced6f07fa24ca24e12f363521bc6f6a958b4b05853bf3dd4683c4143ae73bee7bd2855ca9166c2b643d2dbd1d4cdc11604728e773b98c6252db81fdd86c38077db577428d997663529dee4bd9e526626ec151dcc87d90570f3098814abecbb3eca4591aa7f87bd1636a7221536ce763ad2927cf0226dd3202a66dc4f770644df6256f2ce3ec4fb0eed31ef24dd1ea6b6304b797455e8dc2196176969600985274c42c3b6d1a8239fdb5dfa5bf2742363c50af970e3b1e408eea6bf649dc74eecd55db60fd5aed5baa34b6b8c2070d8aa1269ece7f8ca6ae769ef1f8db15f0924e8494cbfe5ed0279e4866e2cdce2dc827ef87d34fa33825b272fd2a1b213413a9eb39b44cbd5b62c253744512a7135f24704ab7631dec8a2075a5ef95d3685c47f184f64e1a49635567f71ea2ccc2174f19c3f55d7694988aaf9136f1b7a32f339fb848e4cbff071e1d5a6b8e1952de7f90aeaf8418b9481e316b10263aeece855f9d1230ae386004968e78d81221a50c0ac60e569b0f6d55834e5a00a20d4ffa9039c5c4abd8bb0da2e9e7fdc19858754d8fa293b92675b613ffa97e8b75794f58d60461c7e41d0519fa60dfd6cc26d708498e51a52d0b461adbe9799062108cd1fb9dee7de5a0406451180737fc87129aa2c6b6bedc09a44825fbed6b177b6b462ee823f6eb28868fc9f9ce453fa6febc236aea92216a875309fad72383958d8875a4a81508f58611c03ff6b17ac22bf6c42792b4c306e845f49d787fd9816d3e4acb20d88fb9fd07a527326c98f1665c983c61fb2f61319378cefafde180368ab86a30e8634903a4e1ee4418a4af6145c89f08e2b7f18403e4e0b35a0453efca9a50e0b49ad7efdb8a0aa9f2315930b4bffd26c8e2e6b3d8982bfed8c8b2f0bf3290ac6c952f52551c7dd28197f9f64fc4ed6ab12b51674028ee150fddccbc489b978c0aacfe7766603f3e1255fdb47cb942ea85437c42f3ae7d08efbf14e6b7c2b54784a854952680b06e598dc00184e28253416f7b4584d8053b47ef1f5ed0bf279454b75734e9dfc0a1d50fc0daadb06b86ab63e846bd8ce569ad45d1273b7df8dfd3afca2ce94c6a09427eb0448261a562016f4804c6a23c535104104d9fbb87d2a8166671919e5fa55ffb90c0964b89fcb64fe7e30388a0bc4902c5277107f65921f44db4e3b8b5ec8f20e8962120337441d7d7e37a3f77b0412536dc9fdbb49b7448a05a777a490f718a13b76ee4f58b6095d53c27cc98996cf01107fbda4b5a77400db6d0556beba159bc2b44bac39bb02231fa87aa584db28091549f908262288aab6f7ba9b13fa549feccbc34931e623ddcdd6a78f9235acb758fb25b1cee98efebfbc6ecdf02341db26377ba1503ff738e34999c4b09b63d9ac04abbb3966973dc23d50da4c9d54a261f317a2ed6682cda4ea1f5fb2815b1b4a03e83a4702149965c1b08e6edaae308a690977ba6a965aaef64cc2c18e2b7250fda42fbee920f75ae5fcbfbaa3b8b1ea989d5c6b977aab43933b89253cfcbdae591cf4ed29fcad09d8fb315ff9f1385fb25b3227b7a6da90754f2ddd8f5af9f0757fb2dfc3474889896cd7cc874a3fda757c65c54bdddb52c9e3571003326e745da278e4c6e53d3686275d5604772ea154d625f46f5aa683306bfdf1d9630b4d29374aafb91db8cc516ad030cba15c58a956ce698ee2111e5ad6096817e83e6316aca5294179f6f3bf13c8cba374a2e3ca349a5d594447bf6cb457f6083878ca4bc282d7684a00e31f3bcf5281843020c109b2f9e462737c4487a9b7429831fafa76feb8a3f95b2f2d60342de8e8149e139075522c6d1d6575dc85c9a71533d9971115d2fec501b49cd7ab56b871a52497c4dd2c49e2df56a59b83fc538b8de41b11e3f127fbf511c37b9825e0d4dee45e164b8180f6aa1dcdb2b7ec7e35794f54b1fb11eb890c2c08372ebcf8cf3e5cdcc58228bc4dd518ab0065f25d62e3ab00eceecc5683afde27012441577bb7e215d03022955aaaa353a1887ea0c109eaea7779ab1228aa973d43765d6197d745dd45cdb176956f8bc45ab82452d4d9253221da5c5746c0034048fc646e891379146da45dabaa6aad5976e1fc99f3a4e23ca2f9152324dab2a8ecd443197d45cef46d1db575716e00fd17266db55e8e6920cc49a0254e983a87c09679a7bd05de00444cd1c32ab771a1e3aedabfdfcbf5a281370b33abcc56a8072117eb1cf5473f0255378ee0db0b9734a06ea797edee24d58e27fd7ca511567f5c6677301c3f5ec7fa8135bbea447ae155b2f80669dc65726f379538ca3a3100cbcaba1c1d8fdd3a8a3d3281f4691641f30f9201c93b7c765db34b304ef65ce7df8f16c92f6a2ba319c85919fe01d478f2b194d532766e1b260e1ed2e7ebd696620bd73645c24897fc82f25d2cdb58b21d6d6574be2783b71c783de44c87b3da96d056529b831e8171108b36e164d6c7477c993d39ba8926d7a5f25f825931a28705da40dca0a7bfb45b20ae6c2f7f767e1f75cb3c840ab29c9b553cf81c5ae270d581c52fb35ef4e162d81c86991f8a9e4555194f1af36eac2ce615a97a8515e36b5b890a6f706236d5f714a16c880175c929a77ca34ccc6ae3b780a7039626dc9a31723e005e333d17acc691ad795504e3dad8149afdbae562271ce56ad8dabd835b4848c90e92df60fd8b6f3fc47ddf483778c74f4d1342d138c80394854c3baf03b5900cf4b4b8a6062187cc35edbf9604241f2985df5fc7cc801a9e147400bff0c78f4ca069e9bbfaa5791acb7ea79d2218d1fffc1579f6718f8e8c5adf45b269d0bb38f0bd47aa045d3d328482f3368b9d3582474b34bf8f841eb2a0028ce63188acfb2d769562cd543da6a994b37a2c11f9b5901a99890835dee9b887c195135ed62445e796472e33955f11f1801508c4228225b71be1bb28f237927ae3f2faf28e9e93f53fda3f0c1b05371f29352be0c49eb396ae2d1315b140b2b50f93f064e62475bb22fc62d618a1348a5e0db186b2e4e2863af729b5c82b9a72d943cb714da04711c4aafab8dcbc171cb73a2e010dbfe169e242c3192d03002a377c1444fba48d7cf8990f8c1e186e46a535aa397426f4a899956c38306587a463bb69555792f007d9c3fbf60c29047262b56fa606d2022860ebadd48046ccb14ce77fab54e5dbb2c15bbfa1e8ac99ba5a2cf467847a788fed178440f409b4d7eeecefd9530370486e294b7fc708d2d88fd427796a214a8822353be65442b82e39a02159b94feb97d8df8f17224fb018421949790d89f2c5180baf5a08ec8559ed02617dbd705e1dc2aa1757087a8b348c56b2d919673eb2045a2c8a031041d04af68a2d9accc3a65d65a4d0341321fa08cd5da3af7b3110cafb279f7619f55f22cf59124460a0924a0745e3ce783df70947b9245f9979ac53c10d172d6156d2102c1a1fe0e1c9711db6033a13d299ba9bb526b95075bd297edb8fccd4bffd1885e40f6793f31b5406e246a2776873ac23f353cae6dc9438171f848f79254bb6934140feab66405b1554faaa792038e59bb5a84d33b5104203a0a721509a1cd00dbb44b83fe217150831b0a483f7dd768683ada86e29e5d00064bc9b42bbedbca51422d5090124d3b8143df08085a7515de7b274591008a0fb07ddcffb963df20de4fa478dd5bb39d6708f387b36752e01995c2f0ee17fc7da0d2065d6e201896d899ba649b051752f3e7f72b540832cce42731a1520ab8a4311db9949d3d122f1ff7dcf39990620773efa212c761745862a005ec88564c48b7fc2ba76811c1aa16e6adcaf8b4c410a3b67f858eede46a26478436ea1f192b5be4022dba415976fca7b5f987c207ef6f76b2d1e6e3902d687c2fdc38020d0217fb4cc96c08954b05df4aa64354167d8cfe6be9a87414d4db09fcdb409dfa2a2b47371011a40c272ef92cb29daaa601197cda88a071c9dbd04338d81b8fa0217dcde6cebe25bd3231cc9ddc6e6ba39225e4db81bd4234cf84bbf6226aca07a0a9237bc033180b819f59342d2fd54a87d4d2bf66b9d8de554bc7286a2b605a3b494a6f7fba603e8810b82e72ab5308fa135f927f98b9496b7ac5276f672119eb4ac812f6ec4da2ceefd6ec8f2f6faaacb713a344ea6d982fd56e0a839297deb3b31b45931b95dd50a3dc2aa1d4591ecb17eb81cc1d67a1a5aae283a57d3e4175d90b9a80644047a9178fce6db91574777e0bd680842582edc1b61da68d5797198ca9b58b3348ce149da8cff3624389da9a1e8bde966fb4dd8630f7baf750a68b32a67c58f12e172349e43f7d74ba8b87c0c796efec59c431d9425df786b8b7c51e653f5ea3eec22b2367b0c39ea374db163d27497f17306203690c67f75780d2e2896be58138875743060ed7c605399972c0cce0a12a82232143c395c0951dacb6745943b6492ba548c51e908b615c375d8246b4782464b692eb05f8afc9673ba1f0e2b06c4e318a62cb45d133dfb5d6e8c25b9a4b8c0e705c87dc2725443dab055a44256c5a0714d4c4c7a5495f83f74ed4394de673fdfec27add43450f0e180d88b39c7a8201171a877ea942e098be391ffedf4439f780bb1f68087172f8aee4e53e73fe390834def9830d69e8c0e03a37cef3cb48fdb28d63dfffebe73716b0b6e7466f79ba511b17f1963499024178963e622d112d89069c00d6edae3e78e3fb316b00f1ed9d644069f7110ca2ee6e41e0bc384b836a31665ce59c08114382801d1310cc8d28b7e355c420f5cea5111988639a9c77a311001f76e804850cabdca35afc82c3d2d4fec1de637ef6361e268f23612440c5cc17aed127cc374e0c3b43ea118b11e1f241fc7dd27cf732de640b6f9143d66fe8dbc8ec4fdfd0b6b58c355b87857030f7ae3f979b33a23973c3b29209a0dc00b4e801f3a06dd31316e9310551aee8910419ae571fe3fcd60db62d6bb0bb90b18584f595d72af9bd4fd0f58d37134e41aaeb2a291baaee6b72db415becebb580770d156cf26187c8ce427df284ad20e39c5c80e6a382f5570aecdd4be68c2339a7b82921a4265a824a5f71ef398ecd725f08121fb1887438640d8ae1da1c5deaea88d4e6598f9a5e192ce91ff40ad4a057b214ce9f7aefd98fb5f6404475cdc116a93c4808374be7cc42164f8ba26816d5cadb2e349c7a93dc9998e448da6f79a3fbab6f92350d8acd426b94e0732de81a4d34059bf02ff3f2383dfaa502f85a9b29b2b8a6a19712a42e78324c604d291a1f81255e753963bc42ef6bfa67e07390cdbc310e624f406cc60f74be8115f5b83f46183db5010a401e572032973cb0e7530eba05723c5bea1f16db4da80c8d9e3d180f333b6b6732953ba2597943e10c326437d8924f5346b753c418e40ca139c237df02963308e0f301bc7dec10be88cacf7176575665dc60abcd1f4e2fc52121c709a45eb142d9be1e1768e447db564b933e95add575b71a677a48927c8be278c730a4d9a1855cc1908f53efdb48bd033539faa8a9d5ac91be496087096be653ebcad530f670fbd3c8b0d8860f46d227ccb9a789596614e59d8116f82ed9b941472643a253b80fd7ddf80254527901910cab0b28aa79138e83079bd36596034a758c1ee5f7e6f27679190c8f4d726624a3d508246f8445704d362e848ad3174d8e67cdea08b70a02dd89fcec6392900277e7088a8b62b7b0799e35543632cccde8084451626094c051fac4882e03975e9baba43a5adbb5601e0d8a7a21612abd1e76f99f8bb83822dfd5d25d638854996c95e2ee2b902b7a6e51a0176846b997141f6229b8c107d69dff22c59eb50b95c12c811996f3a4051c2850cbcd6ae45f298d8569636242e231ec798d4ed038a5c79567ffd54ab9a30435c59074797f7d643901fb335af84665d288d37c072b6f17c301a88ee62eac800bab1dd26366e89683c40d516e3717b870b7cc85af89e773fce017815f1c9f8ca17daa2877b0b847cdb9ae5df0936809234cc9cfae83bcb299181a253d256d1521533b5e34fe682692dae463e60f827bd24ddbb2532257c3312b1a6d0d8eb69ba362994ae90cce5116a071a27892e255ad60c3051f7f655462503fdd33586b512809ad143d7ba8289d97b748dc2ebb3cda124b7b2c95fbd59222da938fea80cbfcf211b79ad5cc44ac5486d401b9f005b5fbf798dec19413d01b5ced44c3b86942f643cf8dc2e8d2de76628ed34a2c84c3ee50e75279eaab6051585771a1051cb494b7c9a165711ef271f47fb21394b9db137865ea767b0eb8e08fe1f54218afba4436f101b9ffd868bfdb86cd308b6868733ea23fa29b51e32c9560e739fbb0ce646c66cbedd81cfe548ff17da8acefafa5ec4c8d766e9055228c9263bc4dd809bf82141ca5b9db7febb1f24d66f57379abe4491ae208231ee4595d51be656d2d14da58083e31815137fdfed8ec2707941689e4b8f941fdc43581cde4369352dbebf4d670be3ce6b784b000cf095dc0414a17359b2d0cec23d0a7d16d858d86bccb67aa215ca9372681d80d8c343fb1f9635b9c511284145ee362074551a1e41d43ea59dceb1a1cba7a78bf3083c9a6a4c0cd742192ec0ac64e0c93446a04d62e976bac1da2fdbb1dd1e24ca70a26edc52215b6cae15a4e1e02fcb246c1764efd06f99f4880f7d07769e79610fd05ec35a7f7f75d364778e78739905e59b6c221ca8782a5734bb9b51492d2f5da78b3ebdbf4004eb406b62038f3d90540bed23040fc94899181d77c9897620896dd8d3b25309a06bc83c99d603b0e644595ac88fe3383d04ee90c4869f783cfeb7df005dc9ad978f63399536806e4a192cf3d3e0e5e21cdcd5feaab0a086babf88a06f78fe76347be37278e06e3048412cd0b04a22a0059d71301ff9fe46523f1198b570523eb96a3839638cc7ef44890bac3ec9942b6221311a58d745bd17269d0ae563e06453f57ab728335b469b7781cf9fccc179859d904f41ebc73497da40ecfdf11cb2ae1e411911eb6cca07189edeef5bfdcd2c69fa8359615df7c21c9d7788030e06aca9e449cb9d9eba93f8a694930e9d9fcc1e19542c84fe708d7a97e20eb872502c6fc64be2e54fcb0baa6e48c867bb98c087b1e58449864506533e358a4f8988192a849309c91611822efd230b9fc67b9b02d12f63c2ce3ce55d05991f2381750ec31a2ab527bb0f87407aa808721f93aee413a06f3662a7c9cd65a9216e0a570d6ca3a16f7cda225ba3829beb7ddf82c2e2ea422d331c2dc3ffef4d6d0292bf9c69cb883e36659b04f4fa9128956416cdc62ae7eb102104f3b59756b067acdf82555f80033bde1fc0fd7ae2079349ee501119c7cf7bbc504c228665989b53ae777408dc065faa081ffc3f02c41cacc654de122be70f9f920d35719b263d959241aadd7e14f690023921076a1253566fb4fad290c0c54cdb2c82b5e7ee45ae42773fcb2b4d753f6f10e97b6590a6c50faea57627cfb230dea4a13ff0160ac6d2c3fc60428354b57f65eec0104337a9aea890fa34229cb737f6f79df5dda39a9478af284ba6c70cea265b8fb06a097e2b134288de39817271f1589699b5c357139500d4c4726300ac242abfbd168c7d3b8783078d517dfe8c1052f8abc48bb8976ee87640c634b70b1148224fa7f09604e77ad6e1508d98c1171cbb37621e4e4ef4f159fd21871831847d4a14b825eb0a5784b283ea774d0d98e02a05fa5ac4f42525e114a6ea6b2f8bbfa1e7bfd86de91ef31e68f6b8637b608fecba28f9287f4275a7bd933fafce8d4ad13b4fc5a055d85398227fbd9c89e59aae34416d2c8253ba07a0812a923c40999dc73c49ce3dc13dd05a915c06616e419732b3c85010bfb6af4f77cc4038cf9cdbb1fa76986154618682578c15038923b20d4f999b00b1086cbe61585c5fdfdaba08aae2e3664c6cf1eb92523ff284df4ec9dc40b808cf0cf4b265927ea2a671ab309b525203dc4aa702b04dcd5fe64c1992bb234f411581be73a5d4f6cad9769f2571d572a85b8b3494a975d09b31370bd2c775439f30dc61b3a0d5859f646005acc83d66d02a78f4500989b7f9c3b4f2e291031144ed7685b1732584e50193ceb0dbe27415bf74fc2487367cae075370456db15466a0b78631650327518df9faa6c602fbd5f75ab9591911460453d6ae831da0f0f612b814ce0302ca1e6e7ed5daa1dc80dc26e0a595469a217039f37fad5de18c35cc3ea1a09356ed33aabc922e85f86729993d17136ba2acde35ec486d15b59259d11f282e0fd7082f89746733f78a771aa981e77174da1212fa3e9743be59bb3b4280ee3fc6924642251204fdb96a010bc6460004d3e0b249ada50c377c91754aec0528e496e155bcc56adb161bed6e350b2ea22c83a336cb912467c62c10f009cd50ba7684d1773ce3eeac46ad140c50da82d948c179289e4d4a5ca7d2f18477c0e37db2882b9afef489ba3f7172aa9443e47ac88de209c6493787ef5b109344cdecd44ace9d5acde75c7c5b131411ef5595004ade8001234d39276c245d24461c0251b9ebf279cc60f1cc0b674adbd99d45e41067385ccb1c2f9463a95546ab32b6a5bba3a2fc5d1ec844a4c38a76a1d703a1dc0a98f99c3c89a18f994f12f9c250f51c0f389d2085afa4700056692664cf256bee2342629ca0ec3d89b40ad68629939ac4d66054ef1db4d25e59072f1d36452a14408f2a3f69ca35b19d74a04b4800ffb41bf0a00e411305e0d2696d5970c97be4efebd2807ec649906983fe96a975f4c466110074975a23cb277943f0cb139847977b20ec2b3d0ab74b20d6d52b54957a19796a3592a934f4affb0e579601e95f9fd5239ac4cf3397897ec778c055c1e6512bde84300a30840133023388a7eb5f0a02c5ae821a1eb650cbf5cd207af4364755da51346273823fc6a965ed54b19821ee4787d756960a3ab355e493a3314fd4cd97cff92095fd84241e287455c523069c9732760bb6b81b0ec7263b276960708de785381453f14ba05c94c1007b2dd38ea83ba830d5831746f81a470228bdad1d5ef8b5db44d378ec2a8db6ace8d68d11fbb0a693f0fedd9c1918f82007e0adeeb1e8bddc75a479bd2533e2868e3b5cf23a22b5ba659e31ea545e469573f3233cff2cab671b319dc3f681a30accc9790401205a7bee6d2253ee254d6c8482fc2d00c173179a53bc312d4d12191221bc5fb9c0a5d4d30ce3a19bdaaec47903b0c582ee0e2fb90b828c36adea94f23a6e91b0d7b696a069da8b0a58b2d8e93b865783de9203b5ce7f99ebec43c8c58dbe6fe7d091a7dcba73f58e8e87fbbe9852e0bbcfb3c50b0141b63a95bbd83c234c24191a704590c427461df3cb541d7373e5c8d865eb02379652e56e93a9e4c2ed1008d8da7a0a03a42904bf44abbca128451c82eac5ce4e19ab0f2c5504edad54451762b44a8a76ab35dd6f1f42d10f6110593cec346262d94f29f2e2eed55664032be05c0c8dfa2184fb675d8eedff3be9e0129cea19f9361cf610557b429a0e4b18f2b3ac9dd2837af45af3c5fb5e29b54d1706135d4bf2cb5c588df2fbfd64a9a762caf44b0cbcdf0644c82e7215996fcec9cb673bfa38401e5ffb72b1dc3ebf3f70e7f544dbf055c5987c4f3c4a937f7dc37bb12b3ab209d5c88e38520f3bb6455d6010e211a66d3b2078bbcb2317e3a5d43c2b4727949bb1afa47e6bcd72469067c505f72efb90dafc4f2a25b427e35d68ffc74d5ec420fe85ca10e9cf5ab5e08e760efb73002d519553b581d6d79893d91e3ee99a8b286efc145b8f5284e7a510455ef6de544d3fdda7908a0560a21bd6f5d9c5a1cc22b152c4436ca2ab6cf9078ebefaf7e89cbe8de591dde7229a070a68dc4d70e56b9e73f8593c9fea8ec3674302151c570de3d9b1b7ae6e2d480c04053a4726e6940ef9d9d09176aa690070d0ae65cf5a980b3606657506d94e336f5bfff61e542559d7ecdfe7a97278239e4324bb2e0f55b17b805a73fc9a4817aaf7965a94e31579abac66aed03d73de5196395b0bcbdd4631d901c13bb38f35f95cb796fccd52978d5a4c6e593114a905b94e88f0a2e972df2ae04801a37988f1ba62bd7bb381019e5a47ddd88c6f58183afe4bf11b1f0fd098fa074c04fac468a561b626f9001dd58db354aa00f69b6d0fd77834705ee861a0f8a4ed8aa28fd2745b0dac59abef7c2898a3bf721116a1889a1dfd675e41e035c184852d5cccfa3030b105dc0eb80bf6546259255bf8fe394143b7a06206ab050db9f52a5e963227e262b1138c4fe985471866a8088a3ee55b436157e51bac4d6f7b1acf248a01a93344168ebaf4d366d8de850cea4d28d7f455bebf1539c2b279391a50b49b85cffcff7d156ccda2bd2d26f4092b75ac0fd8f1e4a7d4bece665da451425e06cfc62efb6e5a24184239adb135ab2199edfd2109bada392ee27ed6acf3b67beb91b05fe1fb4631a0ec5e1a5409d314f60c183f8ba2253d419097407d3dccb76becfda78c88d242317d933671aa91afa9f67839288bd3a03ed9263ffbda2be433afd3aef62b9ea550f76ffba2308553e5e5634b8a57c12333d26f19e189019c54fcd8e023c4779f9306a22fcda26c8d106135b0e33a81c535d5d2e82ac2c244f7d8d0d52a0d72c07b1f6882aeae2ac956851b18b2f7122cfcac4e3bd6d288c6a7e8a841003a0fa47a4ce6e2ae624a44f3eb09f66f8077fed74b84ad488ee8a5e3ee0c1d7b08cbd802c3949153c447649248b930b094a096c413defe31e04f0f7df293bd28a0cc0f774cb9e26f82486cfde54903180b3fbfa7080a06a93fdf5478dc01009f19f76bd9080a6c6ff3a70b55ab9c56f53bed455f56c8a3165ec45388c6d4f9f503ca80c77a037a8eceb73a19174a5b4a31ec1bc2e518d08589924a7ea78993e39db6a255a614e0391aafe0383d6e5c5d8068e401b000ec03d1a5e0228b5080e178f411eb2de6b49f271083f22ea0a9f579ee82c131aeab9c7e4f8a1a0d2e467de4375e015e60e8c1511f79cb09eff675eedb3e03579e693695fc51862697e3acd93955a6e6b2c7aa035c7b28fa9d2d625d4ad7d1d1301ada90d1e9c22e4eb16c1dfdcd78041e921de1b2d397adfb35ac859624c8c7e9fcf219af4a599505900ebc2eae64a25ed8350d8c60920be31898e3715f9d5d95fa4cbc493922a2ba1737048c81b06bf804da79024820eff137ce58b18300b67075ca341b8cef3925075c720ebb71c9f821f764aef68c45517e31779619da5e16ec1ed9beb7d216fd498e76aa40cc4d42c5e0600a108d92644ef4c1e21b2494963d37e8f5057cd7e69c077edcfe38691ab5abc3173c30faa7c2f55846f65be36c2e2dded060263d68173b0fdaf5e54158095a011faa14c4b5b207102ce392cf28d66c344708f20316424bc9167d68028c2b75c16439b2f63f0630420bec10c997d9316d26bbcac9a0d0a94828e4b7554887f4ad1da6240e62e44e6e02400ef4723c41b88fa1660ac9d66eee1d4df873186a42a7254e2eca45a67347bf2e3a2e2d37774e0dd0aa7dbe8fddb80a92a9a4a77442d8a234be22ab6ea9ed8dc1f5344a8f432cd0a5af66fb591214cd178aa906ad46752d0473d37d4725195d5b2888d3cd346ffe39b557d804819e5a52f3cf90096bea3e2bc2ad2622f7d7dea94e448f2468035cc75db92adaace7235050ef55c6b4ff96907c12742c9ff3816a223e347b5a91e09189c0b5d4456dd0e9be6316898b052e5de8aa7da14b5e4b68f6e7cf2787d74d9eebdc4eec2e10b401040930fa0e8e90f104f90ffaefb0a861c204cc973050f4e409fa21365dc4c3c22f3131f82edf34473ba147b35e9b51a32f8e60b2760011200b21d88a5e15fcc5fe63b5b3ac01a6e47d5a38019f3c27bc27b06dddc27e6a890ed85ccc110eb714654efc883bfe93c5382bee9a45bb1141d4f38706bea73c0c9780f59b3b7027c8ca5f60e57681ba36262d57cda0b78c6eeb40441cfb540cffd069d1ddb670555c18f03337862a73cce0fe114565606343f2e452d5287e7872edcd471355106242f9c288c6aff0380fcd066377e56bda0a8bfe5b1d52b202bf4b027c54858f2ad6bf2cfdd89a599aad000517df254b701e8138684d00bab398d8af2252308e9090ffbb96db1f3935c06271ef7152b102ed36e7254ea727f32601ab1394ee1539b0f1d94d993dd7b8f075296cc26ec61b61c6449e1e4b4a2fd7e17e254f5d179e528e75b2d15a2874743fe37ea52f93010472f06caae9e5e784e1ce20ced869746a4577a87311b35cf122c44261ded0e8aeb69dc663ea4752cf638ef9fc8c60880dabf0ad22afbb93f6107589e4729df6ef65f01db97acc9606b3327c9992a5712c66824f9cf3a9eff28a0a92f9c461611b8a0c3fd25faec898a3d0938647cd3b248061811c71058fdffd626fab4158e33b82e51bad8bc1588b38c594db7e71ee89706e6ce67025fed1c181e5d7418fbb422de2943bd46f5925eb4f1dee29dd2fbbf98718761701cbff2e4e0df0ad1053860aade10489c6e4acdb49d7a6580b7e135685a22cfa60d7c69c9b08df61463f0f83602d44e576d5e561ec67e1527fd7c88874bff889f78b67e1d6cd2017bf3cc8c836e43a765eb38ed0fc1deddd1b196fe25b4a67e27ef9bd7c4b13e98755b0f34fe40aa7030d320c6a78cf53f69c9b5e60a3a4ed1349e58fd9631a228f1de99374f267818fbd19bbdd26445a5b25ae8904828880eea7ce1a11043b0989108a4fec747943a14ad8c77262f220fe2e03b5e3b7512f4771813e5c13856727cbb5bd918a8eee8a7b4e351aa715397d679207f885ec3d46a27357485a690649544024ccb1f0d4a47895561ee7b1ef5ce23f68331f42cc4247fc42d9c1ea2f3afc64c39b850bd058a854e935b6074de6a4d0254563462e6c3750d3e64e4be2c95a2b0bc0d996ed7cc8921ab96089b9fc2d52c7ba4d0a344ebbf606d434f2eb3fd7de758ad97c49b923938b723470be04ea1b75680622b1afa1bae924acaaf821bfc81e42887608582734120a13021708958d75eec40b61f60df05bce986afaf5e2458e5cc351dfcad4baac100b4625a42d190f269c31854b033883abeae2f769e2430039180bbd4177a247e6e07241d60eb722dca65667083b596bc9ccc1b31d6ff17478ede4d41e9ece9a7829fc9976ca5837a2e98844ad837d8038ffecf8c0198b8a1c13affb80a0cf49e0e6ce5504b9d6e0f7bc43e3482e627014e98d296874f7d8e00b8f56e9eb847fae8edd074fb7ffff52a57f90b27909ea484e03c432e1bd8c6ab70feac869a3092198e0db19a6b24b60578a0eeb2564050696f02ccf526cda04d25d34cccb08c3ebffefefc4a68b4084ec2217591e1de9854f052c7cd23b93ede8eb3d181f4e022aa408ed961e4c294f3eb9ab2de285fcb94ae0795db02085a752da07a4516b8c3e1228618d32add88074341358f3e1ba3316c9f10492baee4e34c61d569aee124d244e0a8d7f71635180e652697ca4ebaba98daca1907bf679646187877d977353aef1c6e60e7b8044faa866993fa9aa86f91be40c76e8be645ddd6055262bdb0f2d91ef7537cd718b80957d7c2ecd9395e644e3048a9a33c0116a2c551c36585cd515cc045537a4efb54d3081bfa11c0e0c8ab864e91e9386678cdea8d906af70947cfe6825550157482d826ecbdf9ffc87aa6d4024f04f396fc5330e98a4ba053d849f891a5e99c09791d269fc52862735f8ddd817771e9eeb8d2ab9b38fa8db43d4ad6c398228a255f190f7324377397fa24405a481d428df80e0c7745a069bd3b6ae722fa5e27d4fe5e235dbb941d0f47e7623b074ad0ee7fccdfb6e6532d6a036ed35ad9f2f2c3b477a1f728679b063dc5138b5c2c8d79e4072d480a386da258e07c08dca978c7da6fdf946339ec59919b275ef14d617539f9a9317e6a36dbc1391a82c446abd3d5ba7a06093133b85d27c2d3a872d31dce47c09f503d21e3f174aa68fbff88f137126125192dc8cece764c7bd9c733c221a8c9a601f08dfcba8802a9320cc5440c52520de00e114680111aa7704d9168e3ebe24cb064567d30e0a9e11b7d62a12aa1350197dcac22ac03fcfddfea63741256925004a9d6fb4b7b3b17b2fc79d23cb6082683f8ec378d124568e66f136d713d43c227d94eea58e6cc8f6c8cd906d2559dc104c21283107a34bc1492b4b0ff0411e28273ca2b4b94ebb49da71baefb8d72dc5fc65ebc3b3a75bdf6b3fbffad5089f77a168cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
