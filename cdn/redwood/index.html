<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3473dc72c9d13113fb0cf62224f0b8816aa3a71a95dfb471188f1554defc219d5a062b1738145f3df7b0eede86fe5eff5c7b02c6ffbec61784fd70e8de121fbbab9fe0dce32f4e4074be7833d07198f001d246ca3fb0cc0a9aa51f7279df7684987e840470023967136e5d718e49ba23058e75a25d713c8bf8ed167c8704cc18a75668645ebfdd22ec1d08df631857a1f9bd40bfa8d92ebfd870b3a0eef82210159b822754ca9fce540e6e09efaba02f00ff1da8757a54100525f1dabfadf5c3e44e2116365849962476e4cf0bd77451e1a36927cf1ea6464ebac54f1b81021d9e89c589bd5fd908389a3d9ca3f7c3f523686cef3f535cff7e0aed484e396174cbc0535dfefede92dc52562c7ca8343ce59668a197ddc2eec10ff693c90d18534578155ecaac698b064afcf49a22476a52bd219b7baccb53508b7f7ead65879df4f05d1f4864c4f5a89a9594f6e7a38c71ff94fee53d86a8421687019306eb054109345f3ca6c9131cc1a58fc6658749c5fe63394d4a63e9c8e1e2e4ad17386725f23f4a49d99f2f47ad0e9fdc533e10ec38421632ca8bdff424f6be2a0ccf9bd7cce39ca0315f684c5e4fbecf20bf10897c4cd9232e972b5def63f73c1a6cb0cf3da24304af1736a53bd860eec1cefe5681b09776bd752a7cab6db28ae1c7be67b05a77b8a38aebd4b57943049a36391bcd4b944180cec30019655f86512a0dd8df91201a4882a8a2e75202d3a407bb3fc4a2c00c5df9402f81750395d02929979c39a6f1ab0e725d9eb859547bcf2a0f7235429ccb99e515c42d76215ce34369bfda6b124d939d803880ded632c53e15e02ce191a671cafd4fe3cdc6509dc2c16b1c036d871e1f0500ed1f4d9814c0ec18a1a75f6b24ffb49d46e0b909de020913b5ec2e6a32b3d08057fbb08d42ddb5afaaab90c8a3026ee552d112c2b17a4f27f0955ab97b177b6cd4c790f3bc3f3027bdf67e49bd801df76107b438f867efc4d3b6c8f9e4d0424baade2b8dd2da0fae44cbc47345101397a4335c0c68f015cda50bdfbe22d77c09db4d64daf66b2c5945677b6c7421aaeae48bee8229de63c5b0e6d7da3c7244ef9da803a86210245933012b2f67174a674ed5c6cafa3f24ea3f9200c6e4a84d39e04ad301fabad17e458cb5c0c4033a09122876cbae0719440d06d547892be4ae6349db41280cc519d2471da22a1bfa069eb17f79b2d31655535e716364a62dac55c671800fbb1b516467dc31b4c46edfe53507f88c8014c172f3a895bd7b54304d6b0979de0a10cabf2e4118492196cfb6879feecc1a32ad382898cb11004e68b0fca4a3b0a0c990e508e82f8a25f755272cce30d30467b30364c6392336b1748c079af31c6665c108477b9f216d9d8c8ad093cc2b54de5e5e400ae78f88b15c366f572914e53938a82b493d42b0b05af67c36154c01044b7ca5881dc29b87a12c6ea6c3a17f954d14e2c4f5cfa83d00a6e270204812f1df5b148e7cbca578af5baf1c72df52e757998b865332af63cedf5e5b664af72ce6b6ab12fbc071f63324128c8f051b84f275922343ac98fcad5afb775a8df3eb96cffb55e68062e47f00bc9b0a9fcf2abce0998b752564e9767a2191f47c91c0907f5f3328a8bc629c910aa53ba274ea0cbbe9107ed2785394fb17627e9de4b3a5b4f3beb4cdeb97a5f7e4772eee4f6f7b69d8b9c40714afcd70d11f287c6f0230c26a42855b963ed487bbb8da39a3c3ff76b414d2ab09da2b14aa3ab9c4c94dbfc9fa27450f592e1e29edd8bcf3db06483dc25a3bce78d689dbb19a121e769d269f33f6e9ebe800a76f0beebcea9198109df01b90496e484a4b3b183bda79fee811084a8c4a98ce87c1a91f1ba7a2fc14cb418127c178cf10ec2b3f1a6623173e0f5735e412a9521fe88568efc3cdf2ce72aded84d9d5adc5c5f9df0978a0f7bbaafb5b20b0a3927c76feed843014841e5d5bc254e35386badc11ce09181e2d507407f291fe595470e5f124deec8e519923db0f87f706b258ac2b7cb3abd87522a2173614dd489f6671f70900a056fd74c53bbbb8cb3b2dd1644e702918098dcbff28a52cfab818ce98fe9016d5a7b3046937b4a872af3e82edbcb51333ddaa42540ade801f6add19933989ccda51b549da8fbc5a065970a1ce361601ac826250c97ae80a59bc002ccd61eb106b83c6f1c1380f06244b87e37d5dee9cd83a4010da218b4ed7a8c91e665fbcae4f1ecd64dcd24ead1da15f89abe5862b4494624171924863fd4c2a7d48acf6b578d260252bcfebf991ade67f801026b53ef8657459b7d11ba8372767314a3bc49966051634e1f43cb106247ccc90c5b358b4f4949b6766d53862bc3d0e4dc7b8ec987fb36eacaac4f24773ad6d5feba79140dc08e12fa0f786df1dcf71418edef107dff11bea8733a5e65ca323bab3b63cbb464bf5c55322f3cb52f067944f607a31cce013c5ef53342463021b1be4a5680498c796d3f3a5fda80af94d3dd9dc1e7a03dbc4e7dfdb37cd1b9590adca8a1ed23af4be1c7a90b9b489d37afbc37864d6f86473fc903482130661ef9cf588e6f30523ae96c89be0ea2d9a9f1843f110fcd28bded64be370f73cf9e7dfced5c9056924204438daaedc74dab4231ddf2cd058a6bde68ba6cf7c03a280bc724202ba8e2d9272a032366d26a647f926e0aa53c777aee0bc24edf27422f00e2e710effb2877ca42e2d0d10f748d18b1e49257c9eba8dba5f113861466f851051fda7ec1ee3b40513d96b268ca939fcd8da840205cbea47b4be076d92117cc83b8ee86ca5b310cf6549a67265be968a707495171e719f37dd519b24c60ecaf3e64d6378ef1f1b1571a7b0deb13f0d41aa1f01c4d25789cea1144cd938ee1b820fb42911a1af6430ffe0ef9b67cb21b8f998204684a52b7f382987da8d10107f6cb8080c141be1fa7bdf7486593c3b681227964ec20c497873835c1f23692c2397351b38007bb99b48a55acbb4102e5e913fd1870f32c12c0e385531aba6f3708575893bf9eb4d43d20913e03fd2044ffc3e38baf18909d9994cc767bf9c89d483e3f5a022d4bc43bc4fa44949baca5607a117991410aa2c215257be887c9f7c6592952dc3b391964177b854aa2c4f67d39f92fd5228b6ebf39a12e99d3e9b432be70b70b8174679dbb6eb7d5fc37ec392e9db00ee085ea61869935db9b616e7cc99a06c5411eaa801555d58a903cdb3e71cb06bb9f42c6006b6b47c89ee3368905b4426b6f6c072cf08fe0e2670b2849f46147fb2abea91df730b7f9697fdff46d7cf83b5467981ebeef780a36d2ae897947f8fdd6ec4e470a7e607c1c7f58e10cf45fa382b468a6ace47432395f2179e7f326aadfb7a10ec54cbb43f96b5f387920b93258bcd4e6b7fa38b3af04d7b1265cad23b2b234410e7febdf1b420382ae9c684c7dfc655464191c0ad6abdac5c044f05195b7256e9d66d56f1429b82c80549d8b9f40fd9477dbd90456b4072262afcbb66c625da31c2290f7ef5177f96a6b52b54bfe58dae51617e3858c3525f681cab7738b32a390b909911ea7af844384b861f51b34425d599db7fb71d3f89c569bd7dd18b524faf6dd7c8595b4bcd14faa4f905e868faf6327d9dad5016275194c2837e76502f7e9984a6e544053ec340f156e23566e5930ec82b1e8b15aa2f850e7a1c9ff7ac7d50410a3476259989d589ab76b2f71f933b35850f4320992a28dd8787898f27ba999befb920699d3282a359df50ff00718fa536dcec025b7f8ff66e46f165b2f1fa5b6986199f38911292bd1343857993c8b3ecd9b1946826f3c1db413b754e106a0b45247249fad1c28596d39add417742ed99bc89f5fa709a341b626821d260db079effd883ee3dc03552688096f465f10fc3d0bdaf51f40cdbacc612fb79f68a95b968447da05f4e382ad649ad307e3a011e49d5effc6fe5a063a0e8f47c9b0707b63e0d1f9dfdb8fa0ad577235ad1048bc47c89b6baa3f22641a4df037523c02c9b127fd80841d825fe2cba32237393283aa0cd5de6807fe21323670a8c961e4bbe1bb2ec28c9175e3ab30667684ad35a9c9c65b56674cdf10383b67c513de98cf4ba1dfec1fd248de78c3c0bf855afe8008ae55f383d121590a6a6afb4324f1b1f474e21ae8f08f7c5853fdf39d010b0b5ae581f4b5a46a5e2a9dd50e44425a65c7850624075d72a90b05754c8b0bb046e45962b99e9ad69e9f28d8ffd7a7dcac95a437e6f13151468f4e3cc8e9db7c552a0faf27ce0d70e0d94ac4e4fb638f7567247cf742c1264a4dd64e41244ea30bed17e81cff35d628ecdc7edd72a26db2955eeb4a5e3786b6f6bf5b0286ed657cec806f216d2978065ed7b8a890f3ccbcfd23f175f1fe1ad63688d1e3533ffc100110480124939f7d3baa31af9225379717bb8138248b513947a9e93f23ecfc61be44ddf6dbc374d2fdabeb2ed5f3d3a948935f17293717e3208ac41875cf4ae9aa94ff3816f1851d52688a5d0458a76423f635c419bccd5e73995bc38ebee2ca64f0a86fafe4f0f1b610e8b2d2d993bd1045be6706a769d62cc099d2eddfa97074198e951a6eef729837fe975f2a7a282a9db2e7e5226bdb60985108d83d35069fc2646861e697f3e3811d9df5a4c3cfb4e5cc0684a4ecdb8d30be0d323aa7a66ca669eb6a43ba74eca5aa7b991a808afb51ced4340d7cb308f1be4eca796f3097c1bc754fe46efa24b807e4a8505a0262b105b848e34901215cabf818296746f58accc4360dfbc79ce3eac3f5e150c2837df3613de9108c30a8f100565918dfe71e3fbbbef364f8e9b2ae0df7af9feb47bee6261626b33fcc4fc70fb39d728439678337092ee8d3b155f50769f3ec8278419da468e9521bafcd9e77d88252e6c09304f79c983fc8e5c45e95ac377aa1a8242948753b761451380674130633a9cb2e0e984a85db15119890ddb3ab9f5c9a2fb78f35790b02f174ac9f69d3e91da1d16a569defd5cf21359b3d71dbb48ad69e39350b50983b0fcb73bc778fc0cae8017aeacae77417ca7ea811e85870894c91d5174625e4ddebad67d2166fa2f63ea027a530ed77606d1d352078e474fb1816d24a1935cb451e7ce1fc1970e0319222500d1d4c1b81c029daca7989bcc0696e847248994228653f3a6efae7c85060e321cf9244af001f05407754c29164b110c08e81adbe1c8d599b2dc9b8ac741ee2ef8bdc2dc88d31a0ed717f52f58a8109fd777d19602e1aadf2af4774004220a3cb8b15a768503fbb5a46f414c6df191f9221fbacd618da0530f89f4c552d5edca2b2c17de12066cc3ca77d2689889b903c01c7d2631a29508c4b4c18eae0b0fb4b95f1e87ccdea16871bb117b62c13b3cf31649d63c57835ff9b403559d65b6dad039c01bb7c9698fb52dd749f03298a991f6aff9dbacc9757d05f0aed3832ff5cfbef703dca479ff1c03732a293c585033123e49e1db292c6fc3ecade07462e9555ada51c73b37a759f74b0b55e676e20722e0ff7dab3fdf85d7aec824fd525830cc1f8e0ed2cacbdce14dfbee4e526ad8f2dea75aff215d38b058c5e25012c78c92983dd75fbb6768404b74d2292cdfbcf09920d4b9ab8d6b277c1497f58444c725725825da938b14a05046cc757f25d1dc5d18d0457c94ee97ce0aac07194c3bfcdeea821b85beab86882ef1fecc4cae51759959f608551ed637926e7fe8809ada88aacef783d8abf816f9b68494037219160f42c44610351ff5d661ac1e5c28cfbef9b653389db3088da963d5f868b67fe980315e9ad5a4f95847db5af17aeda7644b74950cc27fe386e22503453a415bdc3cf7959a25d0743f125cb6d7d704cf8716c2d239644f1efaec55b52f860e4614d50508392995e4de1cfc7570e91b28533cb64dadc3ed80e06a6c8039fd2dafb7813d4eb3dd51213377753f294d87d4fa810c572dc5a6229c273daebad44e627b01cba3cc1d57df2359bc82db53b18fa7fe9e79231805e16d17fc8a49559df2f58f3044bb2c7e7c10e7396c53b38161ea736b2e6dddebc78290bac08b2f28948ddd8a06e8c93e3a181dd538c450f387b8d21ee3d16d2473b07f446f079d1cf92b1beed2a2b4aa603b80e3f140231f5f1f93a386fae7540496da68edcfdd2ba887344c84e3043ec580635ed832d97d961985baf3d97f01a9e3d9f774f8d7e5a1a3cd020bf7c2a74b35f7df9293c526888e793b6b1c410856d0e330a6767d0808e2e30dbab5cd835f04def9f7583a2cf50779ea33142d4f64157013872a114b7af256d8394964629668dad6222d6c91b50faf0ea8f6e88e1264fbdfe0c029073374438a169dbc21965e3081d2b056b17120d9c3b0b05c51cb53adb8e019cb0d99fe351447f500e860e3a6cf0d6a2aa4d0b6d9bf9f345a7ea6ffc65aa8fc45dfe780c834089f8063a38ffcb7d42befe3ce34c1385976cffde77d35336a06c734a2d0bfa90726ecfc76c867b3bf2f3e145cdafccb0665f0cbb229bef9d0094902bc81f2ec1062f6464ad16dd812e166d676072eed8016175b83a90b4ebef241b0f2555d02342e255153914202d3f18a421fe011620277635f778702e5ac9fd193236592ccd7bbb9f39e0b8b20efe884f8a73a1a525e1928f54bef039616035c96c16ee43b4285d7ef46bec0b45f866e0d48b7e6e74cc76ca2bf932203361ae3d2e8dc541041661134cb7d406d5d52eac6bccc8e748946256bc031ca9a655881ed71b3a6abbdafe3ef2c9b3c72e905f7514820d4d6c6bdc12d3ccc0ca57c5ed6525c8faf7222dbe3ba009281afbf1ced2cf8ebb11c7ec2e85650f20e016f40c08be33588089e35788497ae4865b2c3eb304e5d4a4dbbf8f987b52f4108bfbe86b9e506121f76482eb989f903b271d8becc94ba2ac6caa3c570ca0ea61efe81d676985d82e9e4eaf1098e780b369c479c9b573961ff51cf40c0d6e83c675d270310368c19b35247f298cf5d5fa6cd0fb3ce61864e1cdb8ffabd7ac5d0bc6b689cc20c3af36380f704c56a63212afb28a1a3099ef69ab1426a85fcd0718889215fd4458c28e69f20db3a2e9fa326d9debd6dd343c1d81981055eca9d212fab63baffa800f4119d2a964dc000a4197d8be23749d9fb23b21978caf4b9ce513feffef7d5073808c3e779a5d623adbc2b756cbfd0fc860fd52598ab5c721013c5961d331f7783f82320640fa5756f4433f3cadac2a1a0fa7ea9ce99148d874f0380d5fc5fdd9f26354873f58d2e6a3dc013f007db077070ff12605b6f5bd15fd76e69b12a49301885abd103a0a4f56af15f88af42bf606c0df487e76b72845c7b28ea749f541c70b06ff939ddaca477597deba2c85cf6fe32970f1b5241fe85170a8d18b75fa1ec5eee58be725ac5a675df5cdaea2546a7b72f476195a4890c05250f7715c24e313d99cbfe716970fc3816e5be812bebb0587e6a164a93616458d37dd4cc4cd40c34b13be20146c9cc3a408a033c90754be86f3d1e612f89b10c44f6ac6f6e2aea835e24283e3db40d5e8ae86801508ef41a8c1b4a9fd9de08b6bb0c02d0c7526a8788cc2bdc852a2d30b71a9ef31fc32f9d1ad89871107c77ec4d0f7633f6a7f3b45f5eb6426d0e4b9e484ffc4733b343b307ba821697f571bdaf7c1a24c4fd142b8e4a6f03870be135dc8ef476b33634c2715f8bd905b8139cb5091863b9d1c2faddeace1e24b3bec42afe49493865dbe95499eef02b442fdd539bb1246300c9d3c27e2ddcdd6c7e403c0582b3b724595cdf4b4bc90c764ca5e8f7f7091f538c13bef26ff3f0eda17ed65b3b6e354aab021b1bc34ca5f0b801f3c5f99bc62ba5134825056d66b94693c2cd8010ba5f645810f9a68bf5390b475be0ef0383008e081ff17360ba50068edd774bcc536d23b38c04f9f28011867d8863ac951b0a4f96223b858532343e971fcb4f571bd923cc119539ff7a1f597dbc0e940782702b4069a398f0a512f7821fd74d7e5bc90dd05d88cbefe45d02a7a5dab758c4ca9401e6747bf7d1add33d7ad4320bdf2554390733741a7ad36699fdec19c00271638f32a8fa0773ac864d274403de36669a2199e4d9f86ff3d93699c5ae6a415dde17dcdbe83c5ec0acae393b3ee3bbd7b8c15a41aaef712021f78db6d423737a3832143042b079b521e268ceb5b55b0f3c9045e1424d9263b40bde798e419edc80d63b4898483ea100a97733fc212a515b8b7813aae4590963c9c579dad90d2be6194ee76640d12a82be9064538e0ad8924041768f22d18d94a34e877c28e3af5d303cd87f3bb4fe624c6e7e3cbb119965619b43493f638dcb954dbc92789e9d759506242b67a86341dd08347c2c6feb552dc44e464b1f65998c74743af0c3775dffe37a4684fcfdb44243698c2b3e6a234fef462549b412ba3ee8b6cb2659f10540e67d8e74b4b69e9d09afaafdb24e7f2b06d4a8f13bf32b5c7f18d9316d97bde3bd3568ee4f681b6124edb0249cbe839f950722012f63ff2c0e351f7d62bfe3ab663b8f3fe98c98aa499f0825932123da5bbd70899787e16d30ed90a462fe1955e3dbb9537aa52d9ac302faee5becf9eea7093fc04d9a1c87466ce2d48fcd8834fdd971848e86d0e6e8b9189199d9f3511967abfe0cac7c2eba768b6de614b4fc975c84f33cd60cfba65766526c32c5a3e1a94fb2a92b48e20db722cea906da60a8e783838e08523981f09f41211be28941525b42f11652952ee5e4f0d729dc52deb2473357f3664cf4a5b03494ce793b96d61280ef97ff57537ee6c83d25f9b8414162959cc3e180b9af375bb35e147cc224d9ec8005e08eea0f8c75688c07c5151e809843a8f5696705f5163d91234f090c21ecd2c5e2ab802467c4708a52176ffd202519468bd62f84b7560295f0e9b288e9fd65b33f687e7c434fca1ccd233c0367e491d72ab0c11f298a628e194bf658b798e4fa757a3daf9cd9b2c154f33b965509fcdcbbe6e18943f9869b20b1343cfbc08dd76cfb3aa70b462a8231427d033eb0887f2a43bb8787c73998d25eabb0f6e7772f9f9b2c829da8d1aba48625c44122f9ef9491f2877a1255f65b939e9e924b91a201b9c5f99511b550b43be3d0b1b718386c98e701ad38ca85169f55819c6bf329997502283bd4d389b76859a9f2268fa95998f7357ac1bad951b8abdb9abfcbeca3b8bab417895b38f9eb85783d596b8842ac8a7ff6aa6f50e38af4953db291f19bacd8be45e2090f13aed45c8a703511a1a714ed306fe4279f4c7e03b9d665a6a8a117e7d9c28d7df38f0a2bda2b1bc7395cd1dc028c2431331f3261e0a49d86f777504c5d8c72e06859a189b8c2e1476abf6fd7a4b1b637435e3852269d7ab2de8015a5d275585532f089749fbf22273b48844f5e0ab6647785b82d70be33be837b388cfff4bb97d511dc311f8b49c379dc9b74dd3f8db22d575aa2b2e6f2fc6131b177113a62213206db3cd137ede6a8043beace7469dbfcfe07256ffdbc9e0f847119c11d85e16102a516eea41a9b9dba27e9727a90d85f7a2ca5bee91cf47eb32dfde03b4013906a538df5f4a5f6008156e29d19fae7531cc284190b3865b146aee2e31d18fb51ec054e4c52502093361aaea8b40f15a5fb042be0d004cde54441c40a9fe0999e8dae37e8841c323d4593a548b4b77611983496b6923f2df03cb65f8bccc64445d886e66cc4725c250a819947e90d689852e936595b56b6a314ead1f81774b4498fa641e85bf53143268adfb24086c01cb063e5b9dad1d149a131aa1fd2b0d7fbeeb212d920a711ac8a731c35faf7d5b53bac64747cca9d7980e8f66164f3ec3488971b8294eb7a05e9ed057aee42951ab039aa53716b68799da3bb76daa6eed32ee38da44a8aa0d02491c5ceb451be65c15c36d5dc35cd258cf05c2533fd92d6dd6e3ad433b72b746e034f2248e8b6498e5b560fdc516bc81bd496b20dd483f170b74da4cb8519b01c8a4c21c8dd3f99c73b9698d97d9f80408129e44e92f1c81ad881f34d97c7ce3e38a6f38bdc22dfbc3d6aaa4a0179086e0111c28703ab19a8acafc29a4e798148ed12d32dbe082e37173f4f71b129f9c531f387160cfbcdc7a23ec5cb74ad80579b2ca2f4f0f051b0e9c8f3c80a7fe8b05233050229e221e4c342db63bf199a19c1b57a764e9d16021797a16889365f650a4d3bfcf05695c091bde161923b8d38b08f5816b04413b492e64e4acec3d507d4fa84c7e98ffed39a98e87a034d34f908d69e225269f7e45fc36080d4452e9e0f9ccfbfd7bcc957bbe7f3dbec575ec3f328aec45c069456940014ce6251b5866b96840661b5a768afdf226694f2837666206cb9c0e6a81fd545bc9e15c8fe3b93e3fb57601a2ae8037d94523663ee5e590385600858dd7e815453184636036459e7c4fcfa2701e1d492142b045b072909a35530ac5cdaf42e398ae11ac0bb355cef629e379f94b06fad069a9c3b8db95e9a99a5f4c39ccff9e63700ece7248b3855b81ff0e5c507342f8c16affd9480a6499adf298ed53e3d149d3b562b82964812694b2bb48b4f3639a91fd65f9a81d29bd48e600a2e547032be08cda1cde9d6a8f5f0a4b10e9ed8abdd3bc55fa50e6f0f19f7f7b833054400bb1247c8ccab47b6f3407c1d92abb5037fbd450efb0de836ebd86ecb8741f2ba05735b61deba1087a5843fed02cb452d1734270fd57a26be9a7c1955fdf08431e99e3ad40b1bf803b00eb39c99e4f020d2f67d5c2fe6413f1738ab32c2fbd1328c273f6ab4a05aa0ca65f6d64c5596692bb88236a882f783e01528b2e9b9f2786653cb2a3d090e84a6b7ec5acb5cb129b5f415995b802b797605cf38a3e42bb7d540c6de7b9716346a080a32cce9c9b8d3619da795dad5dcb724c2f4ded7aeba3351053c577d36f596c3c82089b937c48cc48652b4af8db52ffc4232af9deaf4d0eb0299ecc6d3be72f02f2b4ae5f9ded7f198d9e19805a50de3ef8a3c323e87950ecc9057d49da7fe00acdc34bb89b76c72067363ff0405c31bfc6dd418d71806cbeb382bd0a8b6816fa6908e9617b7ebcd74a4b43de52a6e3003605f55a442017f7e0ba5e035381c8fafb0ff6772107122e5be61f1f324cdb4837e5f0f28189d53dfd9803531de91fea4b9fb98f436836d0d1a653ea99e842879ac7751e9c4852143d79ffbc35e43ac46d57074cf5924d848e71e39648b57f8d8e9413fb2f28a8cdcf9b0c320ad098d0bd026500aaf94a478ed9deb14bbe47f3e4674f282ee2d9b82fc47e62211e29c42039a045765024cd2052358b4f5530cd307da89184e05b6ea292529eed1a7b7e9c1f3b60c38149dcbd7c193660634e0019bd42bf7c367a8c865e870c2b6d6e17e1ce8b8a4211a095431a237f65ba311618f5be5578a9408b21093be1ff9a66fa948842c39c699f4c071a87c76b0eefd0ce0f271737de39919ec470b6c89a85e7fec87a5320e37e1d8da01bf658d008d3974206d0ca51f719da7f2db614c34981ee291941a7242fc7e5837a7b8032e0a35111df96484c7c84365f2a95741016a0777725704964d90e4c34dcf639a65ac96eeb406057a4ee0731a565ecd67db4f163de98a93146928525092c67973a0f8eb1c349cf324e70f8e16ff847d70e0ff4b8656dd9a3c833428c47ccf5a5080de64777d903ccb9ae3c6ab979fb37ffcce361cedac33a1e19dc6230981cecfa60d0b447e78792b41862a18086fb8e2fbf2980d4f31e9bc067c96b8782e9519fa8750bf3577b7f0d01b0fa9fcacad5aae9c76bdd75fb2254087bfe7dfaca4b76c7d20876f306015485fa5aeb03b61064db9decf1cec80a51f1e5e1f6b5fd3f25108e4813b294e5715749764a5098aa41899a47d6a7a1d381d1d04c3adc0052cb9219586929f282874dc50b93f3c937f52dba004608ff142d713da2e2332fc388e66e64f0bf4b45b327a017a55f510bf1f0f8bd93609e5fca34cf1fb038a49ca60044684de6f6991b43768b198b58e9db8ed7c8828c000d17b991e6bd63c099bb8c2afd8ec7403ed38ce0ae640b61a570ac8d63d8e0d373bf8cb04233b4d783f645a5db4bddb00f7c8b18fbca8d5a35594abe4eaa4b31eea79fea7c1f0d71a8c8680b379e4b15efb2edb206931e3c9f03d154c8d64f9dbabd9e0b6d545ca9147d4924f5d2901dd1a3ed5917b96ce1e26d30fa2cdc6e29fe6e9acedc7f52c20d9a4ea2c2f8716df43564fd93e919293f28e2b32c5e72474c6dd050648b2e2bd61576427ff192865e555fe0e67bc8ba4371d9d36db4c222eaf0d60950cdc88b7180fb041103e7eacc22236c92f8a30fe143a005e8d5aa99010fe0759cef4800c0237d64e4494950bb12f44fb1b9ad6df7d9f1be739458f0073274f0c7a004712f85e20aa4110da438234fcd99cef79dd9b6df2733eea789729b8777de1e81d09f491de3bf56e65546d9d0b340b66f21c4273dc88493ca145bb640d3f3e20265f0f4e33455b6108dfba9b0bbc02054c1c89b43293cf8849024224dc53250ec7035f5a85920f1f82de9b0166c1384865eeb64937dd80f8c89bff281cd60a4865ef107809dcc62dd9911954d2e2a0ef40041e11e89ff81c1b8b29f0de14d79b5ec044c6af76d9d71ab3fa8b710e163852771d74583dce7d5d5175d74c30b736a9dd0d5ed189b1174f9ad963f4a309c648a48bd1cec5499d796f56eef7e5d91b43d9a5d735a0c3406003a6ef98f4c8d4784b37f5c8d3802b73d038edbb73acbf7539b5a7e7f1bb136718e114d79b6c4995738e2d5ad3a8295a2967aa6f39424070cdb7fd4b8d0b5e6477243f6868275e933eb51295a8a36d5b4c550e812f493274593862d4870e411c02d711879dc2d16f4a8da25fd223d0a85fa864dcf7a2575b2acd142be96bda7bb5b23db00d08e2d39661766bcc898620386df8bc4c8e50cdb994c89f9d9c512368e033523e892097b2c2fb4b26e39c73aa91fb77d8d4d36127e87cd7ec4488520db183c5d86a4027c01c3c425d1b3b263e3bdc6374e9bcbf9dbcbaaeea7d55f1c23b32098f15e47f41f693240ab40b042396acb74bfb29551b24a89040f21b41b0f1bbf39b5df366cf9eb5b176df1098ffd64bae7f227c338f5058aa3e2f4c334a5d3614401d21a54060581c16db647ce051dcee53ac31207d2992c4664df4af5066cd523b072242b7809af5ffd5b46b6e284e04be6df32b0acb99f9e5b0dee0980f07aa1e33c099beae537f18f233ebc613438f62cd925a2d4252b544f3d095e7c89074b687cd57a728d5f17a6dfad19002c3813532de6fbcb8941d0abab0fbece8fe83b3a6cdb4da5cbedf5ad02b77ca515dd2db5741d6c1510a7b731d9f96a73807fdab169c865b1d6371cb756c9e506ea873cb8270691f95a575d2286a99da5c884daae972312dc68d97756a549ed96b93e147b3ce1da2f93fcc36b40d7fd11cc033cfd9ad3c2be0305c782a42b39bc0f176e5c3fb379db2b3210b8ff18ff095956d6cefbd29c453cb70f2b2ca40655a18e9dd54a61954a3e722cd5f55f525eec580ff5ef134077e8d28006b0d176347101cc15215a379dea90bad336a861dd68ef5d315342f73b7c3d4d5221abf6d167c22f7f5c2420b3c3c2c5751e38c0be8093e9a5edb250165313fbfc0219e919ca1c3b4fc9b0501c80c2be36f965ed329a010b244fa172e41514339ab556c5422bd73e3a56a06b97515cf5eaf696e8b0ff843ab9175950a54ec49c604fb5dc616040131b79744961db0db382e4bcbca457c60c537c8dd91772e4970ae4e244e016809a1f6f0c4ee32ef14abce810968f381443b0410622a150c077cb1dda0812d7ca19e9526986f9a8a762e0c297e138fc84ba5db2ca5b57e50bffe587c63e24bff6e7c085a12bbccf3889b3ed20fa6c8220bada9fde73ce5717d92b60c7dbf29c44149320e96206a441f52e05fb01cfc47056cd41e008c0b40ba3196fca3c81ba42f9639027ea991a66daa0c93d776787fdf8b959123babc287e86e3a0bb9e4df06649e5c81dc879eba34a45ecf4d3d22c03c2c1fb7aa20881d4c09002e0758eac18c6cb04ea28a62b462ee0121d28092fb7eee119dd38d4e0080ed3986793e0d0735459c68109c32e8c9c6cc2b8a4c564a3197a7792496823cede36b91261efc79f37279cad642219adc8d4cba0614b0c9a31c48dafb8dd4357fda91ef4e1cb8db6987e45c7ae40438c71fa988a2dd6d440cf0fad4656e2ef86dc5afefb092d182596c4cfddb63224397025471f94b1fa7a663cd6a2fba836cace399f31e91686908b6c6af253c39a6bb792015eaf9230c42730e6357d37a7480fb5b397f5d64f5cabb1e028452911cd0b190b1cdb879e1ed11d9f814c437bd458729981e4b1a836a2e91337eb5e3d84654ac3bfa3b196b93b563f89feefb68f65fdf095ec1855d2d151ff370676161c4d3fae42763c7c9d548e768cae360b8405f05045f36ed7564b83560e5f2847bd045463793b2729275aa7d0638289ba0dc270292387d7c8fd34bf1578ff50004c57e92114ed66bc533741161c47ad8c7ce17a6311448f08fb0396d6b1dea24183da644d81afa1ce8a1d9a5607145b4bc14c49211bdd9c5a42c6b878a4a3957c0b28e1b4dcd9e36a6c327e0ac473bff637c1d240d65a2be1213eaaffe20ca867f873f6d6c4f67123d263f3f96cdad401b810b952b47b572ea3f4a7f11dde9c04a3244a686e93935aa5dbda4417b8235b8242015ded909a00c64f42a28bb00039ea649eb6609a1587100af01608975817851de5afbffec58e08469d6086aed897bb359f52db97e050ce8e4b611a2315f86f5a42bbbb193e4aacbcd1d3e7ccd3075b1ea41ae28c9bb615afd22ae2ab5de78afbb90f47dbbe1938a955b8810ba23e767342a43cd0a1ccb22899ce3be596977e86ebe456c7a5bef426c71086d6afd675d38025c871286c10056d5cfe13a8044f39ee3ab5bfc6f2a34acc7a78a2eb8ebf2ddb97f04d5f891f39dc903f01cbc35d1f9973b66119c7728bfe25d4fbdc1715b9fbb5bc929a6ccb5d07f3f18787486c5511220a7d2f24739341036f12f871df5c786c182f59be276187316bb81f6227fbd61879432134f1dfb3c0e7387cbd8913383c23d627b75a8df8a30b47571afa262ee5ecb4045fae59eeec9bcbc65e82bc7dad10737e16b6cd6af06eca40909f657128d80962592f9d475f730074751608b4288ae765d78b97e00b8c4dc78c9b8f37a19b24ea50d844d30494d0df8ffec0c79e0014cf9b8ed871c02e5e3bc799f6a528fc75da16635785dd5712368c3f86cca32ca4540f54693d70d2cba90b7a3eee012d80354f85286ebfba3200e6f42c72dd5b084c99ca9889f651f1e37f2d579ea8ffc4e2b73a95d7a6d3af7c703b903c1782d01576e450f11f3220cf0425bb2f126bd3b9c652fae65159bb489163bb7a12a497003d82b2997b9bc6f7586ff102578ced91a87f15d99934e76ed2f4ebddc39540a9f5dd8cf89c924705ba8683a41f1592b64673f0a5905d40ec4c6ffa6474f2630092ed7905bb3b99a1ceb94f2a79103cf3e0650db312d33f962551998fad0c79051b5d7d11885f750dd8cab9b2a948e931632f93a7a1740cfd2f6332560e8f112c5bec6ab7542caa3b146afaf0ad38c151ad426a3012511eb51b41505cca3a3d3a4aedd1b510b8ba5bb398bbe414b7f28240a56786b415a7a2bcef2e1b0447bc03f0ba3acde425b32cda3497528340469efdd3f8acc3a93e9f044df857b95c50001afc82eeba1e87d03b32bc9d3dbe2e2b724901a0bd3e8a81165b313e7c06965e7e904b5c675cc46db606276d716965a4248259a5bb9c26eee043ee4ae0a3ba6eff7953bfd0ee781a244e8d0509f6df2f704b7f74f03663c4af4cdee3d10c0344b8db7ffb9d765efcf6bc476d7154e77967a73865cb95e6a07342d3ab90b2ce54b0d16645de5e03ca1702caa9709aa1797127cfe0a0ee3ad1bdfd35c39272a111416328ef7f31f19b086594fc2e6e4f3ad107d2bcc062461c8cf7d6012ea0f4000b04216766e7fdfd99382a50fc63ffac187785b89d805466553c3e31545090d9524d4e28a4072451b276a875bf2491983ccc4b0b3648f4387be2aba78a034d164fc4713f50948fae9335d439d34b9048b2e83303c01536216dc172d22ae6b056510407ab4bcb6f5a0dc2d0ddc7456d08e27d7a15ea6bfc5db0f1a8f7f51facf28563fc93e925cf34faa7ae47056b13e76c7cdcaf112218665e1d740efd7b44da30b9c27f1809ed63388bb708458b8aa1ffcfc4ad15ddd26a9b1d1a56b4be73f4dfafdf4db3db65bc40ad6bf9d4f70b7a34c71fbca22b0db36aea24372a901fe583eed8baac855c7be4427b5098d953e95f6c3770387ec19b3aa098626eb6bf054ddfc1212af0afa942dda407602fd87b0b084d6b05f315cb46a44535f6f0de99ba995c07aa48608242df4ff3061c412b669805b66722ae7d0011edd0c1d7f1dfef87f6fb03409ba7597ae53ff9d591fc544e12c8adf14966c2fa0a81cc53a919750c9b8587c088de5fab9e314e509c58c49d39e6b4832fd3c7217caa9cec6f4ebdd26dc0cd85b596d7ed89d5b55aab90915be156c850e64e43288cbacd1c2142eccdaaed15dd20255bcb00b4ea83381c03a8e31662b6ab3ff5b9359c8d3844184f8d11d743183101f1486c885b127b4d3e366ee05128246ac3b11ce1ac9d087070748cd75edac766c13f7eed56a3afd16b82b6e3f65cf8786bff50d25b4901550da9ac8bfe8a0001025fb33f298365af283f000f3038b166e37e50a65e74feca048ded3aa5cb49014d89040bf2aa4042ede41d34cfbaacc3f0f6925a9808045564b61c880c14e30dedb66464fed1ef295be4dcae3eb57645aa2fd893b5070a2da6652c1edfba041520750dd284464dd6a41ab75cb1753fd56ac489f2134a36f338988e5c8d0f574cbb1b433c91a4fa4580bc0f6b9349d630fead96049be6d71b684f1a179680f226887b55d7f7ab8176370e641f53c390e7ca69201ca7e96d5c09c46500a6b7463bdac45c0b8c40b9f0a3fb8585a2dc93ebfc0ec93724b350414a1d789fb039fc1513de60ad7a05e12a13554dd08827f916cc461e6c8e3715fd483931a5ec1a50849ac55e772e01e07f4fd4cb30a60d7b2fcb84563ff20f848fa8fdd1f7e1e3c7000050306bf6fa79da0664857b4411b1701f3e9e50ad6be561ea6e3c4d6136fa83067520ff0a28f94c93fe359697de2545214b38b2337b6e994c4a7bde11172b6e6b545a6b9913986c55a90db07a0191da9f7cc87d4759c8d38c0214c7441e2f93f7b6fa62da6730da379659bf2c18d9ab91075a2ed5cd81066bb69f4eb00a46f41be23fd272f39f9ab8030166934b6e56c5d43e4a87bc91a9d64459d9d6529a5cb29acfefef94c037bf4e9f17626986a7612a937f20e8d990bbd8dbf493d2f939977af7d0e95a8ef9f38220bf2d1f45036cbe3f473ec33ecf030dee15eb744e334f334ba73ba5cfb4e9f267950fab83fb15c6ee524ffcb3da6296f63a57b5dd6b73f8107a759cd3b0dc760ad3b6742ac2dbff0eeab99e766b8d853fc012b1bc3a150b91f536e4282f52b2d8295415ae8e7d423c2d68cf3dc7e71193e49eb9319299e7fd3a7a789e78a427e434709c6539b44e04f795c1b175b2b62666d4e8e5cc9ecc62cd7a29bbc2331e4ccbf97f5e61ec69e69627f0ca82a99c1a14c5eae192a6ead6e48154b5720f644a90684d1ad8f8885c3e6b00569349625895de563e93bbc755bd0664388ad8d6507e940bb8dd0fe05561b72dc00969e34b139e6b3f495574636404ec5fe9dfa5270bb1817e3c0a17403b4634765abb9dc94562967137da40578ea9299c775242e7bfcc3fa59aa5a229e481253ab12e2c0c45a11f1a49a7541e657fa71c45de220112f7deba37631db8ccae9e58d4455d58cae9ac8f8a8062d91f215817ece9c5aa29cb58f82bd5a1481da66775b5e06f7a2d44e0c2213a25f279ef1020f10ecd3446586886af4aa399820700353f956b25a0e32af0f2bb4f55ac2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
