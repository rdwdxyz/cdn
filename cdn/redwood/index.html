<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ad1f271ca0d29a298f765862e137cbd8588357bf3b50bfe86d7bd23ccdb07dde4ab4749270ab8c01bd9b7ef37e82fd143562e6d78257bc7a2317d62fead20512c5858e71ed5a0d077451d33415fb1636f589d6aa24d69b9c67810ab06499760d2d282ac8d0372f4cc282c4627bec0287f4f31cf1da4b4858f3f3817c7e13a740aebf0d6ec95f8ac71c548b78baae221a21095c109cd4cf6ca016ef2295f42e9f2049ddf5fb703c7b3bf4325825e84e75b8035f0dd4fbf49529abacf15f1f659c6f97ddb317d43fdf222ab0bffb6be4fa7d34754316fa45f2331c18a8b51ad171bfa8f93cbbb22e87878166d8dc7a9aadcf2e8695708f6a93f5982e1288d8328af534236c3a196091504a11eba71f124eb64b6ef0598ba6b18502081474de2c5c064db0717a24d3a4788d63e8b568992151104892762b2e0a1786791813892c5cc4827cf4321d5bea3fe517662f5f39c20757fef1b417eb26fc8444e95431b8bf0ad51a098ec6fbb351ff9aa2e1cee34eedd10a1014e27daeffffffeada9ece762f9d862e7ece1332e54bb6adee526847e93b9ca3b332332ac4f3d57a8c7e6b3ee34c354c4d2b31951bc2c1650488d8f38d1816ca159ae1c783356c00c95aa286501ae054a8dc5e096449315fed6e62765481cbf2710fb201d0cc59d314a1906e4d9517ca5dd7b67c09ed8a42e0eab1f8276b1605bce9be71685e5ee5032d88d1740e25a75d64d28e40bbfc442c8e79862c9611905137a415bef1b0bc90d123807fb7e701921d96205556d68a3364d4a71b5dd9890713cf080bf84220e94c28e753e1eb0f619ae5f6b3b060defd17d8972761315e8197ffde7454cc79f25cf19bb18f2bbef487c81b0d5b138d60b4577b1cae835861f1154c43f0e7622c9df470cf1582a4842dc9282c9e2f20bd1b9524a5cc3bd75e328084d11478f7bd20b00c26452625a8caa8635b9e9957546c240a99c787978dcf89acf00ef27bd9b43648c52872c61514863df5763ad0c93e0b5d44f32b6a55c9a30eae8eb1c94e7d1a4d6043ae5893b64877d7fb135b7340041de75b1fe70a154a518ebb82de7b73b9da688e2ca69338b51961443670870ecc6ddd955c604410455858268c7f9c32cb577177d1c9d7c0195be5a6bcd581134febbdcb92ff7248fde9884fe425809d29a799a90c70dadbb2ad4be95ff1db9182f0749a14f2f04a81ebd17c6cfc46d08ced75b1e18eff2eec9310fe0247916a54089493b9c56a231e6917fc043468fe8d6ba92d1da2c4fad3e423b2149b834613ea29bfc1d36ad2fdc46127e8e3668a4657606b350f747add28f814909d666247de52defe9f46976fc480dd3e5bb165081224afb004bd4f4f119649460c91a8e42ba353ff3bee027f3298517333b5ad942a2020d6479ca0d229351633b50e08d53ee6cec0bfd8ec215be621bd36f14d1a0b7ef23815ee0da80ea867e24857af24472172e2dbab6d2e38510a462254ba7e35a131e5fa4e7a65c3c1494f6d8e265e58106bd1890118968b1e5f1ab69823e0e0f2e7afdd2183ad1aaa1f2588774a5502f020a8369b6cb6fbcff731c332c2bdae4eb60d4733e6d5a624ea74e9e8c3cc80748ff3d0ce4c07cf8988829ce4de13e4d45a98f279f91cebeaa0c2f243e7a8b10f0d8448c8f8db522aa8020d832edeb41bb00b5415a024550cf7ccc4cc08f877eb31036d7ef5ba473204157e45d46f0cf8334cfbaa9ed1173e709461e2136b6d896e433e38de68c58eb6bd5afcfec1ae1e0100e3d1c17b2d0d83ee87d22f4d3f0ef1905cc56231cb13ad0292dc5829ec958d936b4a1c39b00b4992b0b91dcffc7818ab072b013bcf2685f6894664cde396aca4244e91f6468cccfab69fcf7d61808448fa753f663ad0d99b0f2361843cba46a238d2aa28eb898a71a2f17dd8701bb295520c3df608ffbfba1530af4ce2d151d19995d048015ad79961293795dc01585027f4102616f846a9615079945fc10c87d87fa2c0a74e461ab286464bafa23669e79cffdde578bfcf357eefce2a39e5aa5871f34ce1e791b38b656d5f3cadf2baaa0b004f02bb4fabcdb2558fdc9d59613d52e600ea03bb28b8f31928e9146d9ff304d584cab7a99cdaa3f5937872776000ce0dca380bb8fd324c35797f411bcbcb73bc5bc952737f1b2756abf6aab6fa7743a1ceb519d98e384f7d3296445c07a43a9ee18170650185bde7c81897cdf9605149a3147eb8b961e299310d6c9cc8b06c5b03dd1975b3d77484937186d175affd2cd55fa67e5f00ddc8363c62996d690500bb477567ad2c58be304c0664f6622d2265131337684ff0430c7373a5ffdca7425bdb1f6c9c16b7a5debac88d796aa08ccf001a2b54e65d6af7dbfb677c10868bc4ad7fed3dfd0f6f01c88a05628b89f51ebf7f5cf5b512072ca6fa1cd0b7153ae2b0cf035290651e3f235c8adfcf1e9dd28ffa02704de5b2c39b80ffeb0ba2c2bdda43fbcb4bf6de2ff697a83334e0fc44dba90f6ddc18ce5d61bd5ccee31a0a14c05da63607f617b69ce2530b50dfc30952c1b9a0055cf3890083907adec3c0a50f95f9a2cbbe34fd433272f56b8db966c2e867122f09c981f2b8d408035df18c38b0749048294fae05054a2322b2145389997d22caf4c8cc93d4894000e5629d1c1a24006c27f3aeca35fe55ef452b4fc5aa2feccb3697a74ed875f0c7b3a335300695b6d91b471233770be9a96da8ac5f156b1d01e8959c8f43750cac5e49b9cc3eb7a716bd9d9bdb85deb22614e36995b7fe877910265f26f98ac2ebc0138f4259edc118452087abdbda7ea1e545f4e09177bcfa69577edbd134281088d1eb19e6ddd61cd13cd47e9da823bf6d98dc48b75aa4964f99c6cc3787ec7eefadc319f273eb7cacdb1d362f7e45e3f628895777f4f56dbabd64e22505579894e67cfc75f96c071eedd312574e6ff8796956d09dda5e91e697a747fc2f96843fdb75e5f6626d7905487a063fcbb1d6e8d79eda3c0a5297dbecc9fd80ef57322edb30f955487f5bfdb6fd3c38536404e48903522dc116131585006de6d71143b211f906d3ec984fa0eae3f866ea4a37fb6d551a74e0e6cd27d61a210abdd7bb857fbe13fb8ff20f6fe6340e746b0cd613c8d55dba0a073506f835b4cc17512503a3cd883042ef838e356c3ce9535e55868920d0b61346a313a6ad0ab4cbe0fca7b369ba69d9c4c88494e5c6e210f35d4f0f83850ea87fd8ef31ec5f1ab0baca7023c4bb3fae797a91f4de10d142869346e7891383d45be9bc004dcb47a252effca276d53c42febf4afc0e2b38e7d8af9fbee575870b2fccad16dceefd4916bb7cbdd9c5a41ef1dd1267cfeab9fa6b9ed417cf58700e86c58e96accd77ece2c638d0ed6a5745f2951d3c43373d26b33ab1c945ee00173b0348d063c2b5fed9c79e9f43569779976c42b50c15e023f8d253fd74e171b1dbf09adab0190f54a337cc23e7173f336ea7b3364a1d685643c6aee36ba30cf1f742f9b6217f70bafbd81c6bb5fd813085d3eaf8206b12fd82f032996281259b07d5fe5cf6182b23d6b94d225f5c5373f2abaefc4cc3527448c8e9ebaf150f5ef1c1f46666e031f37cf8d9bccec2be11ae215a29245d430f4a3fe10252d03573f415386f5345854eb475d567a04d06b87e67ab0f174380c9ab35e43e322c78364ba5437b251a0eb920153d0d251164df88a94438b898d51f044eb9cf3096da46c2808bd6e2d1059b338f3694de242dd0701b2df5c82ab63adb8cbddc34446d36e38b9ccaa656d761578b9d492859f4af2885a7e05265f62b05d99048b725e29d5f445d44b73704279d97d3b6e16265c2440eee8a097da49a911f5874a58dc75f60ec1412687494ae37b4f1b784553d594a9dd3153107d178cf1cb20e3b765bc1a6c5ba9aeaa6639cfe17584f3bc25f4afd49ff07ef910aaad7cbfa009deafb865b942de599a09a6853e0bea25d57c008c9e628fa6cb47db530a68c52869b282ab1ed87cdef2e24a4129b80fea5a4a44785659cc1cde352fd57b585d10536fd924721c47283a3c65f19eb80951c189d4e709d53bbcdd0ca722c42c3f4076e0b4424e6af1c8d11e1d51b4334451aaa9de1bc4dd49a83cb655fee563ae19a666e2768af67ac6bdf482f65f01377988392469f6add3c0cb34565000e40c01e3d6d513b74a1ff2cd1d7b4e93fc3c2633c97532b130b4639b81af3f36cfefaf097b8f025a1d146b1cd713572a57c78fa7761ce78323a77120b4e67385645b0d3397e4440dd329dec6a3180d3827808e03c8a6fe12103a18457e91f025b3e01fb265b37be9dcb1c1fe836a2b047532be414d1e927c3416924e3cd48b577a1f6bdb61b26c5818c1ed64b745d234980e122ce5f59a9a5e44dec6e06aeabf8e4490522b5562c311f35f54602ff0e6feffab5f2e86b617403accf797e8fe0ff0edc3e7d5d04a69729f280975f71487e4fff3feacd129e359d606e1e518dc7b7270e5704ceb549ccee1f82d6c314d91113bdf9083cd0eac970e3319f65ff953578f7d3baef50c4656f072d3babaf5633a4c48258aaebaca58ad2654af56be50b6ba9cf84f5dde3323915f1bdc841547accfb324492bffd642c104b7877084ed67c731892cf5c7a8c314852a62fab97749718e5dde5a2eddd0e92565394468b8db278fd8c59be186357405d4a12262401e7a834ae4858f431822179d5cde2dd226a161251461e2fe599544667c796f44889eeb69be15b2a63c54bde21b036bd13ae82a74b831ca3f9c220cc09df49f8fdea811b7e259b8add1126b7870930629a7be20238c1f22bc0a1638f539f190fab18a2e1edc66b656023e001780f3ed0999b736e1fccc7db7455b228a8092bf0f24ee6e9faa74589a4dff1e6b9242b329b42bb77efab379f6d728d3800f6eae118d3728051a45b80daae8753a2c40ab728a6765e1f0277f9d9a3d87838de38d987bd14b3ef8130e3f73cc940be5e9e43e88a139250764e06358c78e2e2864793fbadff378fe7b8d2b4cd1deb911259a162e26f8d1305e95eedd86d1361c287c919a80c0ab76a862eb5595ca1ba2fcbaa8767b8226317974f62fac48e9fd3a45d3a23fa2015b8899360cbd5d0be4193c1f27a194afe81c72650166cca50ea926bd5c5a8acb4fc0bf97737f1b0c3264d9198472ffeac2f3aee1727fcc7b9037a00f6e99013e8ce3e44f0887e5f46a1c0f43006e1818648832ffec9721e3ef285963df0496b441ee936103fb259ef731850148fb64556ccb16a06b16a84abd6d5eb9e8c8900cc1faf3678cc001cd0c46b481604281e45ca718ce2e1fb632e79cf1c8dde4c0073927070a5472c719cf2c952dc5df194f2dacde945527fd559928af7b18fa893098d3372c6f3cab0af3566c283ce2f21db7a66a1d109269ffcfe240f6b18649dffdfa91ccc862f9e7d127e6d146cbc1b208830593076c584b8f18b134a67a431c8ea106c6710f72c6ca043c38306dca51f82ba06c5eab5a986f5b91808afebdb853945d4673bd22dbc9219cb720b44c8145d9fd137062fe4df319113ac2cdddfe90b1ea0886fbf26eb2ff9c248e6fb7c52c920bb5c3e84c7356792eb5e42f6a74860cdd0185dce3624376f3834e9459873441d47c6e64512ca475b2d1c4bab0ef96cadc3b0457c2944faefa0e7acc9cd8eadc367e615064105f0e66bb4c5c5843bb1b6aa69db55b2036e9c530e778843f14d0570cdcea72796ab1631f6096c10f4d3359a60b66f0f2250b646b97e7754ca65386acf4e39c3355f6426c269f67663e74a82c38a09ee8e2a4fb80aa11e2a7941d8732a64b59f7a063c64b5a384b605e4d1c81f213df39fca1795da584d92cbddeba0a459ec90baefda5654a91cc46155535f84543d952183093e1ad4257c9ac04c8ab5522bb4d87dec8d94cc9c0211740602ee9d5a97fefe6128c5a7fe54a2f21958c69b52f8889df43cc8137b240cf13a444f2cbea3d8ff4475fd0c7e7869c3b88837b6b3e889a9afabb52fedaafb62c38d70e14a901fb73b9c4176ff3ca8b9e1f7194610713420120e3fe6bf9cd664831bbd7694d3aa7beb80e536165dfb0155e931656698443c4934c6b76c0bff922516852bb90c8270eef02588c2733f40715d931b8d0bb601739bd16c84ec15966a0187b9e07441c11d39c7e9e98d8de84fce516bcab89db2e681f6ffe38ac4f0afcc992b9a7aa8b12f5159b5a4ac23fe073bd1fecafaf898438373de0cedf04a5d3e46234b790744db6308435ef5a7b06487d09138b53044a1bc0bf00acf5ddbd27ccd81e76eeb8c59c84915e8d8cfbe149a46038559ca9df7f31c6d6e8985fa511627f542e9906eebf50bfea2f0810714903d2f0b8b02db748491fde5526cda25dfd0e4595fd9326d6da1995a01940c6990a02fe4b2725af779da79eafa538066fd2972a38118c5bc26d1afc19a18e65f97cb6a2976de8fd76b9730b1b9234cced712770037975afd8f806b57803e4dba90576b7a6b966dae5f784982b708eebab22eabd0e81b2a623d15dae8f62850582b62dc73bbeeec79aa4be7586a826951dea2853534cd944f69bb7e3036d29350aafae1b6f5fdcd8c21bf60d07a24ff85d1cbb3d551df608d4b4ac8e8cc8f20596fa9a063d3172d4a4096bff2f033825057a03a97939acf83142e36a521fc985f35f8bdd802da5780ac59e1e1c90234739c88a0e3b73690e2714cc3cb0376dc1953a7b6363da4298038c43bf1d5b28db59a1cd5818b465f2cc6e4bd5b4b5960eed426f97bd15c12f37e0f938d5522f8f301c24f5cd68fe3d2d64c69977cda0c402cfa218ddb13f4ce8b9bb50baf660c4bf12c1ce43bc01a6f5e9ebc504b8e8a6fe7ff5bdd4fb37c4b8c48415b938fbf393b10bc6a82be9f2b4baf01d9ca04995e28497b6cb41f9d75c630c95482d127ff9cbd6e59bed44a76c248086b824359f7464461bc6ff735aae1461684443737689ccdef1d815ab50871916183693a80192dcc3332bce167fcf619cf25e60f61404ee9225b773f2a22b8b9f40245dde6b6937bec4daee797e7a716b20b366b7e0620ffac5bbf30fd11d481133209cd8c37fa9fca17eecfe01c99d3b0df3248f6823cb1223cbd0f563f6d95aec5f9f52814b293c8ea48e21a1ef25649fc1cf9bf4a3a0a3ea007a0b8f15e0b0780114d896ffdf49a114e18afcd32e0a332fea6a294307be0f9b3dbe2124788e4464bd1ba79f6f02136afdafbc158bd55ec7d4b84a2d8c6152b995ffa2a3eefe3b629da27d7dc397764db25b8728cefb5b550a85e4cd1f4734d22c3365b6065589fd6d3c7abdb7d37772164d47363e719dbf727af3e828fb62abf65c468853289b3dd2a3a2f7ba7b2c93298bb873e7ed46707fb3f81558bf9abbb27fe9dcddd709af560529a481dae525acf57e1b2afa6e03ef386f121857c19f8a428ed991dd846a5adece09030312b156875be18cf348706640bfbc8b7672d7523ab66a3a555d799f0e30adaeb34a6cdc872319a101752fe1ceaceb4a2f417251615cf7ae2ce4c10298af2896fe2ca78b2b284a913f019eaee22195d1c97b1a9c5886d5686fb7cb672c4dfca311b78371f71c62ae4fd6461ac050a6bf335784bd1f6df5405bcef664d48c341d2b06ffb49f245070c131ff82b275e454c76fb86bef318a0895a8e83f258ea7ddc084d74dc351edc63cd75e9820981329033dbef4988e797923290f62b1de5c8115f97cc094ed7c17fb68fcb206e62616308339c0aa80bf8a39ec919ceaf76250c938ba1ba7c2618e7c2dc7bd0608f01749f08fc8ec1abd471b8a0334fe44b114d0b1b9a0b79690ed761f7ae88336bc3f5af2204d4bf3f89618a59181b00954f5816ea3498ac548e42f1cadcdf9a55a3086caccde6cb108b89bb8d15552f1a7f04cb3a17b342a6557726bacbf2e9baf31f823a1952558ad1351108490fd2a12abe2e5a157af2e93c749b594b21b370f4ea1ccfeaab13ec405c26920d1b8e8d19fed45a074eb0ea14509ac819ead0b2afc2160c5bc323f5c1bd6e29b7dd4ce1f823e225ec3c6cf5c4c4523e7eb3c9bd109e39e41eb9f0df21b4d72e8c8f38cb054d5311ed26579e8e064a6512b50db5200fd189b69ad8b7d90b3a833573fbbe6af88ecc7631148b61037a61d4ce5c0def859407bb6ad284990812dfcc624377ff78b7b1155b988eedb4d94db6905c7220b72ee08c7c5903662705c81f39f724280820ace8891ef0d28112a9c582b7ca0981401f7108b8cc6c692c531927421d4aa668775e389c1ecd56eb77d738434af5f707e39d1f5e15982222820b1dc09cca5095bee7fe5f478a9fb38292110de4577d96316d3814b5f3bb1a94f22766392bd02c482c5527291a086012e3c094bf6dd425296f39d290fe8a3924c16c2226495458f2687ad2930b47927c6972624a69ac464c2ee995346ed51b221d842e91c90c76c17fd14b0bc125e8ee06f8b70772a74b854617aa82f3e43dde4b7c8533221e88011c612f54ea6e3411f6eca7c69f0386279ac114a89ff95cb0df34c878adb566db67eb4cd817d411da63bec4b71615f3c1d2f796d9e237bc448355325f5ecd8fe6d702c7999fe7dd3ee6c0a5b9fd096b960f1407146994f89f0d27bd0720a978cd76aa1f701a68c5536a5bdd164f339ecacb2a4ef3cb5838b94f7efb5b977cfcda4e93af93266548c054651808445e97978fa06d078fa4e1a30349f240e201ff6b024b0da1fb55f244fb8d4b0530e76706ba5cdbec0b4248add8740b5bd5ed4eb14bb5a3535b6258ec355da06e1258299ec3f18f3bad884457bcc65efd3d423b304220a020a770a565e60ba049f7a716ecfedd494b55b17d826e310f4aa7bc218205ae538147abe96768a55e1019cc3f68313d8f2209e3085d2a108e9d1bdbdf03c7b370e65fd2570c72b4f2b42f60cf47967099ce236d8fd2be1a34fe526d918bd2ab5c57c14ee23495d3b71ba4a6dc501b43a2d36de04999a4ddcce6a3ab9e87a254ac6079699eb7d5257e81f7933fce0c488fead1f64a6d1535e4a533e31daf7e2a7c64989d382a43928cf10a9cca4e4a3070afcf191167cb56ebc0f724cbda67ae629b5fc532277316206c73eddb7600c018bdf83c291dfb2263ebb319c202f4d5e04a2b309f9cfe76717ff96ee9c7fc3bdcc65531cc1f94c5bfda07bfcf398cd63e76cff4f6b01a74dedb52344ff2ae9f65c9fd5b421fa0ae7601335208374da89e1db685a793aa7bec0f44a10c5ca71150f7ed4bdc95988bd422354c842340eb180e47568715fa3060115df410ceb5c91f5ca0ce112387ae6701db19fd315c360f2031ee9c3ad66d857ad39db75cf5c9fb57d80f4f1347d7c420fc79321bfcb1fb729fc4ef41671d7df3bb74ba2c8391c3c9d87ce695482c21c51fc6f3b2bc55e84bf69b5071f1a94e7a8ade78b40e37a1fba0f47ca12d5d6ca656d46898615e7edaa3077c81b29879b48319b05bfda46c9b11680f80fc4a5bedb5c1918827582d260ebbb64981052c30465f383fe0ef23f0c35e36a7236b36f2d8c268993895440ae9fafa55342742d054eb898d1b076170f6c70d2c625322241b5499999c95d4b5034eca6390a57bf8ac9ef2140c8963dee9c7b329b4e747c569fe6941e466761a45d4acf43c5b3fba04a17a1c9fba14f234f21c6a5e9229774176407512836c888e5fc6a7f90e6d0826fbbdf2266da6034ca6ad27f098f4d26bbec44399b4b3477e101cb18299e3c1f752ca26524500fe9ced7f770e50710537b248ff4fc309d71676b60e409c59bf86183d1ed7b687161cda44e592a4ffee2bb74e28cea598dd9556d93413c574d65c14e5e1f413081f4389478dc6a77e6a1c6f4d32519643bd285123fafb94cc32ea89a40caa20d258482b0cd7150e638da7bb5290c0fd4f4fc31cc0bd03e3d0cb384b6501f0ff111c6f4a29a8ea9e09533fc2f491468d77fb4381ad7e58cb3f5b7cbc8fcd3fe60ebb9b560cd2547ca82f802689934c11840b0c93c98b9345ac8c38e91783d4d73cd82e1b4416470b411733a2a512afa2bd0ebc456e6f316f198e62449529383ebd21dde2b47cd9b48e0ac610939c095220ab263a6c09862bb6e1b8e8bdda357e9b9c3a6f8670c07c3566a8281762a842e543805db6ea2e443e2d9ade8e01ff43104e954d076d3b629df2604548966e36485ac15bfc4ec0a276ba404d5276e1eecf28c3ee516209e6db211a4db82e90b00b852a505f83eb1edf9008c8db9051eff81ae3ecfd84eb28b9a8cf62c9bbd7116d92bd598644089ccfb39d12ac7bdc71d3fcda8edd9c2f727eeaea6dd8b3ea34bbe29fb943f4ba873a136fe95b26edf0a37f26d68a9945e575b062eb710109072d3a35e1957006984945b05509652d4b58e21a22540c16f7ea5b21ffcb183c8f7dfc24f7eb4e4b86fa390c104cd54668121e3ac05262154f4f8ce1cb9dc2710118d52d32d42cbbc03cb61eeb035e58bbb1be342065ef16bcc610bb30c6a390deca317e61fe9309126c9cbc89c8cd16dd264afc321c617a7e26c0cec6d76ebfe6179cab99745832e3c2a32d7df03bddaaffa6e1304a4f0cd70106f7c9ecc99098ce1065219ad08420feeb61995a9d06462a7cf6546b27fe8086f004291c592e58a232a737f2a21b47bf72f9b4c758e4ab0214c66b54c9b4c5a9ebb9f27e27d626c9c6fa6643a1691a94fbefe30d3b5fb4daa484454a20bd13752d76f2abf5ff5ce0f69acc8b1f34a3821b636eb3456469a128c3384e2fd9f940862c5b9985ced566b69fe0597438c32f14fd11a1b9052bc08532004fff323a5ad9e3d71be50e65b89fd9c388846ae827b3f47c62c0bc812e3fd3920a4fbb33648ce6a167967b00a070e21dedbd624fc17440d3bf4263ab9b81c6e2de8a83885d2f7477956033f3888fb9ad41702a4a099365bd484202db5baa0ed06b453c12d9dbfa678d566e27da790195d20cd877af5cf50e8879a2df49a80a4b7946799e697a1272c8eda53493a3cff559706b3c5cdae1976e51ab2126439452367cbac9fe0f56164ec9d4c210f6f927e718c7a81a65f1364a43106c1c479ea3a921c64bf08fc6245ed6e7a1266505231884e1940d66cb97c9f8f4a0eb20f2aa0c369c9c94aeb786ae021996d962f3047cdf16803287de118d85b44ac46fcf314707132848612bdfd7206da8d95c6a20364dcddd36bc7751ad718493453af77bd474f8786f8093141f97014925246748fbeeaeac2c029561e4da287d556a86fcf09cf5d53d070875bd1447568f0b14ae34298d2abeb2674f90cc5e4fe78ee026a0dbc9c5691297260067b307d6df5a3d60433f415dec45296c4ee0cbced32df37051f89fbf14ffce0e105824d7a71151a23cfe6b00155e2cd455a9d4ae53647a6e44fa08d3397d938fb8e10c78647827f94148dc8ff2882c2a2ab78d7f2d310f5f3fa3cfba63fa0f8fa9ad5797910fef8af80758220a0de27c6b56d6e4aaac18678c2c4d350403ddadbfca5d38b59c82e07af284c32fb5b971e2348b52ffef5e57801325c912b7209293710514ea4bb289ce9a83fdcff0e6cc17c904f3104a60279fe1d1806b007810d7b439c4b736b76e013763981181352c0c209cac99de7a60a25cff8ba49c904f7bc29cfce7fd285a130ad5def2c9eee2e7de9c055f36c01d22f32776a2a7bc679caa96216e804b6f1f4c4cd273ff6d1b7a34534ceffd9070ec6e65b3ed37adcc3b62e4bc1655b863d5e0b32d8e855f49e678c4c2fd29723e45d09c4ce0c8d35607aef45eb68d4ad0126a2ee2632b5e7fb6d8712b3e1b36f03fd8c9c8c91b033cdc004334b56f3814dbaaf6505b3586deeaf3b020c030826f74d84f659e9353b5f3f25e593e4501e907f5c6d24ff7db536cf4c421972d1e2420ae94ae2cda0133c6af4ed63889b141fbf7acbf4635ff645668c25e728e8d2ede1cbfdbb22ed8df25c1ecc42f6c35245b397d13244e42726993b66c195419f4e4c593372178881527b8410156b46672f71b8226cff94256a16917d62d1a6d7700b1dd148b8125d44545d460fd0f630c9325bcf764a4eda237e712ddaedb27fb900398e262af9fb98d8d8e3bb4f7ff0484d827948ab27f040f05837082e3726382fa4c0f5348d8e79dfb666bee0f7ac27418e5586fedf5f86b30effbfb75fe269306c4bcc58cde828ea098042c871bf112eefc481b07889f77777dfc691fd9b717a8b4ce165c1bf3572b092b7dad675fb55da7c53fbd3beb03e29be760d3131a922e786429f53811e86073aa5080c58e1f9db44c621dcb1e63f703023a882a0eb725358774c711f07dc430f7d4ed71d08c3802a55b5787a6bf0db3a6c6e5ed85674a75d751722a6ed07e5e50e676f0f70466fbfe938204e8b138f47145ddb9c77e4cf83415b54711b605ef155b2105b23b78516aeaa199e343438dbe73618304c0f0db3feee822f7adfdce327a40857afff09fa1d0a47be3898d63a98faf455f2d65f007cbe6db31f6fee96299c83c708fffa3cd4e24de12e5fda1698f785c2ecb6ea9076472f3de5eb2aea675df6a14e5a516f993c61e1a6ea2d86f868efe48e4257c279b9f52baeee35ddd9489a88ad2087066191fae4836fc01cdd26ee8f2c9585c38a93171c50809889247e52af2e3e772523853f1f9bad665440173b588df7730cb8010d0f917797ae543e130b9ad8b2d5d6cff2c3119daf537165afc64df972e951640b9c1dfe8c38bb3915d2d93459529bc542ab70f97ba806996ad1c1c2b717c40f8e0278c2347311e7606b5e04853755517fccd845b529ead4d4e6e2a8050a6d49e52e752bee5fbfaa807ba6dac86b38123d506f00dd0d6cbcf0019f4d3a190d6ca1b9e65e611c7fe7d140c02ad9084b42fbc91bbe75e1a8b3183bbeac650cbc5367be54d2082f1930bae44ba5ec7b4cfe9c87cd7558dab03f83f3e48bd5a81e548e7e3b3f3487dbda955e9de8b5e31a974bb77ccc26647f1adecb8ae31191be17f9d3b36768c7a4d796ddf68f7af801977092431f3e9026b55c83f669f028401350bce7f0159d4daa67577ab838db07230fdbe1f48cc5b1c708b7b06347f9fdecd2e1243fff29e3ae28bf09becf14d337bb85a8df4789721e4f1dd26bd329eb274d635c77fabe0b44318c52d32f9d9ee10a9c4dd62c6a81f56b209af0d56073aa7f1e0eed55e833d39f4aac8ab1e5d9024e5f158238a798c3a8bd4fc69b3277178bc4e63020b202ef1d2eb3d0673bf886a54c8fd73930e9b84030ca57d2915f42f9c0e69aa0e5a1c02c74103214c07b33d455f902389f6459ee4bb40c250fd686fcf7eb93d76a77c6bbfd2f554e0ff6091b8acc30e7f13962021e52e8ab2bfde4b294c959bea5d01bd4405f1aba2d69bb59a2cb77ba66078210444904f3eff1175fc1ac96af9c094959976395a4994010e0455f18f56b6613ed836e809186675c2b3b9c50a7f25346d6f2b58a8155be7b8cc9f85e45d94682b02fa698f17ebadb614b3410890c29d7af04e6cf6b6ee3ae9fd0b69e2843ab713313bc6bbf87e90bea29d74a26b68359badbe260912bd88a3771dc05c1095eb06920601010bd7ca01b43c0a5a7c57d41fef44825fa158b6f180546fecd2abb99b0ae16e53dd8a14befa93ce68d8c602478e3d54429a49fc74e4a5eaea888f78bd8c3e78a6bbe9e8582869df4a00971ab162213a89b31c16ba0e8ce4a7f9454a20afa05b2272823a94f9e89b32b6407bc1d355f77157a9b929367d1745138c7bbed0c9fee0d929c125008ccc7455c81fbaf96c4d39b965f1a8f071bba703b7d804bf8557a094076c82d53170e7183c32bd25adec58ee83e89dd481513a68e4354c616c0a0cf1cf4d324dd6df2a573fcc091d06c0e70888be9d336316f18482097a1efa432a177e050e7f319a0f825e77b8843de5e92f19f0f4cc21a7a1e5dd7bdbc6d79209a0be8dbdcc52a1d0b66cf0a244aa02233b28708af0e0ff9245ee35b6b0648e60d264dcb85b469244148b112e213077102cb41653d7adb12369921b13cee8a5e6bbf63bc63a4f2169e2c9410dea7f273e587a4cfb858ecd839bc0f3d96832d1f317778b300b766fb2fdee89d95943265e22cb2c3cd38708743d8366620d43fded81e6a51aeb13692e183c02adb84d55c117932ae703e7e805391bd60de3432840ec5fe06a829f9d7d1a8548b537056a6178aa8d299cd28f704578092289b5aa2f4c814054c0703e178c3fce8fb03d5420238c96d613540d15a09416ab87a2826a64cd62ef848e0240df7641734ce0f9c2ddb45f9f473abd8dbc53549a54418c18e1ffba8f681c06b1d0c8085b1149647f6fb49be24675b00ad183b60017c3ac38d8caad504886c2ee52f38a135b321e5d471322cab103812d350a2af9e838e03cd6bbbe7a22e7db5899cf3dce01adcc0ccddeb0d793ea6d91d2587168834de414a841b293ad67a57f5395a0149e3dd8533bf38e6d1a5b587968a3b55f31e5f189dd6d722b2fe82a78e4625251cf001a06fdbc7b4bc4b0ce4e007c527f12c31dce7a05bacf57d3765bfa00934963ab3e7cb8b3385f4c714ed216cee3e9ffc26d22d20985f46df301fc39d2f376cfd06d82ad560ef9a93065d75a746e78b96f79c4538ad2673ba33e0e7ec2aa7ee3a2ddca7a4c23c0d28497a2549d1e592da0733fb99a686dc236a441a9d76cce87c7254946b7918c5fe90bf072cb9d690fb8e246d4987443cd79726a573a2e1bb8d511311a4603af0966ec2d679a2706a58fec66665617a2bb1951e8eb84cdb7229eeb1b8b386167ca18719750eaad7704f13631fcc26a01d04e0da17bab6ad22535083877a3768e61f0b9d94c5d6c80505e2a02839c9d62c6c06d4b83b7aa48de1774dc8c5f8fae9442d9217871ad4c0731d767d0d03810c9d14fda3e0f447cd7d7cef8eac240e492df446e74f179a17efa99d236315988838087aed77ce3d3372f3d9dcdfc7c694d3f373f31de3a37f637073629c8cc9b15d60dfc56cab00e3a6d6c4b781fb3552a6f518774ed0c435437947d8d65aad10c04368a2ff1765dda29a855ef0ca464efb4a452f739ea0786d0f7007d36fdf47eecdf406f8afd501d88ae8ecf5e55b8f5fa0c7a43ddd0ccf94b9a0d05b94376d8ec8bc6068c12eb86066c787b4d9d9a2f5419ba272158d2b03212c04b97f5d416593c50d439c3eefdd0c99ab60bd7faf62b960273723ab11115ca9f1eea937897e07302ce0d29fbc467d81226175968b1d2c12109910c4a9b93a8c84d601b8eac1bdb5013e2ca6cde6a6c285e94accb36e60bd01d6aff315faa7f54a5207d844cf041054b89603d6548cdb26b7a154874b01234b351df07949ae6f6a719b812d8f9aa892aabd6fde5c2e536286d672db8f9d07517da628dbe7020e0e421352f8daabec1bdbc01042b502bf85a50343633a8e0d46bc5c2031d6d910dbb5d954db4d90fb35350175a5543282071060d8a0def52ad69464a528f504ec2b7a6dc6ad4ef335c01d296ca310bdc2e9721d650fe469db874717116ed9e580ec1b6f3248f0655b4ef023ab19db160b03ebf15e223b98723e7f148e705e96f6ba57d7fdc196c6585a83fe3f7fb3f06f3dd6778490b4f6641c4de8b77d1781eb451737d8076b93f3a5271903b61d96babe641b3f5520af79f255fde78040b6c6ab6a1ef66d6474a7b38cb44fb54e8b72563c4314354cbbaa39f125eaf373a2d76616ca575de42e08ada602d2a21217e928e65213ff991cd2183a4e923424474cb8675160b9d48019a32f3e8fba40ea9e60a35bef909d9a87009bd436c70b5bdfe463cef3654720b38a0b493d0082e49755144559c388e8f1c95ff5798481021ec0a819144370e7c8f73bb24ca360a63e3c134913116f41582bfe22846299dd5ac439a771351f523cd9b39882a34ebbe3b6ff3926399709e4ecbce4f52d415cd12e5ad1f93802aaa0cfe98da7009f2163332e7f70a93f44d43a9b7e6c0095ed3bc7134fbb320f024c9c2ce04a2fc143fb4666d8ad1e4f7a26f2dc4467f8e18f3a0f2baa85b3a08c5011f148ac7afeb71704f836e53e295e84b27d6ac9c4a59ce7ac6f0b0ff8890ed06c95f8aed46781260319b18b750d7c4978adb6d2aaacef3ad2d1e60de8d18104bafe1bd96f7f5e659153053df45525a21774070118bcd0c038b77f9e50a180c1dc702a66fb26fff7107f22270f08d0edcecc333d74f1cd8089ed801b0c8aac25710cafcc75e99a154c4a979d063ab924059a6a8a6693e2da978b702ae19c297cf297b1ff295356e131ee70ffed669565867c7bd87d2c6a56adef852c0a309586e5ed684d548d595771c4630f60f112faa19f13d33eb39f6d43b152ff05998ea0d1e50484ba32b512bbe6afc789016dffeb43ae7082fd2500e1e1888c018f38ef3a39eb1173df5144ad16dc8a8532aec9316ea0d7b26d1afe76f4152c07db92dbc95e073620c3a97e2a932ec8dafcacacee87107aad5bedad65386593ad18fdc6896e51a34f90c5d921fd5bfa370353dd4d72183a5b4377381b16bc7ea26096c6d6bcdeda3366bb85f863ff6a6d9087018af80ef3fb6cf4f9b74b1269cdc2bc830b7a021ffd616fdac0a12d9913933fe04614b523c54add841ae97d9659b54c7ee01b34b852c6641d1e4de3120b1f8364faef372f1cd385d56ff99de40d04c861fc2c8c676b28c48c94a4f473fdc751c94d314e943ff3d7a28ea08de187c53d0b057674e4119478d3b9b5a4fb3bcaff7324dd761342147641f85ee394aa5a30c2dfcbb8af886906caf2f72170fc89dc4e1b5da54035fd7b0c55d1ba048318dca3c1f64999b30069c3188d51cc190e99741b70466662ffd7ba8870c4b9a23990784ec071980f1925e89b6074da18d4bc50f6c8ca79285e07522093497d97af2c3deed5ae57d126d8ca17f7a70abf9062453e4e1d6b823613b1493c034f4e082606c0a37857085aa37b629c91d630b96e3454809e96c3b5b3b9d63f6e618a3efcc086e67bbe6857c91f094aec3321abb820f1c03308a1fc904e6201d1580067fa321225b11403c481c65f4e98f703cc6893c39b4c23c2867caaa7538c14903d9d50aded4cb136f95b77eb21363e3b03263682153c838ad6b82cd8b6b6af17a7d295a25834149903c301df0b8a64a964a4d9a878d67b76de7beb1935ec27deffcfda7bad4afbf247157bf26f8ae4496695338ca2b7b3b59c0667b79ec917657cbddefdb24bd763cbbda14b3ddefda3a7bfa7e780103b4454485edacaa226bf6d66c3110000bc149d4855b7bd481a3fb087af109b356122546af5b9558f2e4d260b5c53c9428355876db5bf90eab0a81a57d29887c0a2ba9a01e0789a9a7d14925ed7955b8ce17182f5b3bf7c42e418983f147446c19c853e4ed73a38ace869d64db9551efcb28b3e5418e7fb51452e3bdd232b89016c9d53488f677261e848747586564e8edf3ac03d5f16c0fb627d7196f188e1b25fa42cb6ba8162feb6f99d89ad1de0a0ecc458038848ca6c50f640eab99d886a88c8fc4d50c2dcf37b20497cc0c9330b735cd112277d3ccdb767a9c7cba5cc508382ab11b3de2ffa8c2ac4aacdb49f3a19241844297691a653e4305f71812124d3071334897d7744e280467d004ce76169cbd80671e313f0a18f3e53a6e6e590e61d3a63ab7eb5811b00fed3b04298816b37fddb53dcc46058d6b5a7cafe25f1c43d06d91d2a51f5618678cc87f941d63c67caa216e896ca3819c8beefb23d2cf3cb5fca1c243bf206d7c558898d9dd8de816e123f8cdf011b0e7f1467142584d0605ab988598e6f5e0e018809a0f5cf727532773d050fc225840d197d3a88b2b221b0be7f90aa25bebaf4a2cae5d164b54132b5e30270adafc0212628fbb24f1412790cf4efa22b72472a9479064cb177327abebb7b389a46f3adba1406308fad09c24d5d9974ee443301c01e98a2b27a58add4b344756b89b7fab51f31e525f620f3d72da5091fc8fa39ccf38ec028423ab3105597364be18fef3ef9bff08a3eb0e3f3a3ae2bb9eacb4a1afd76539b2369f9b1b49c2959459e4a73496c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
