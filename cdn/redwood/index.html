<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d277cc0c2a29f360e7ec106bcc356046ecf03a16785213fd9a7ff947f42d4354b45c85b70a2f82860e07ca1100e1b6ffb4b2314b0e32cc9157374d5ca15d586f6ec194cbb877b61738507b8b0ba4d07727c28e673b0cd1a3df4b29e7bd2fd56cea8219d547a403e8533178d238e622c67d2e531ea149e28240b387c33a54293e427edb8a6555b4a6d76d49af347a30f6d77a97d70fbd23056f8d4f680a9b6e8cf95f190a601e5790e91ba9b9fe1a0ce9a5776b6ef5c152e532502a05a23922c5ef8cac6d5b678d8fdbe91ece913c63eb334e0e7c4f54c7ff83e3ebe2619863606eb83576b4886ac92f2cca7a3278d3bd25ff721c20276ade1a81d40d993241211ba866f814cad725df28feb1a9ab6a90250979c17ec3d99827fd76b75f9d2a1700816c1883873f7b7ee80e1da6c0facd8f40716d90bd97ade42bd38fdfed3a3f06e67af6b0112a57efd74e7ed36038d4ec38384af73db7a5d3d1179a6061c16cccd491c829add76a67938653c99f950f0ab713e2828b823a26a478308dd497312bf74993ffbfde65e7b2636e181d6623730212d48c4e1c71906772611176b59740ecfcad240e5885a449d8cc8885b42f5ee035948e4751d17c6905f2b15e032e6a67db314f2509273ad00cb9b6998244fe928218de4032cb2ac45a5511582a599106150f54b3e2aa8123aa03c01413fca5c0d14b7bc751af8628dd8ea7dbbafd0efe703e93ed4402d37a1e5ab10f47b5c15af6f2ceb671c87fd1dc4be23317bc6fe934dcc5c81b5bf7a0f6121d1d7fb3a4c59063ef9c45fd1a802bb68f0453be54e2990a0fad39d69271600a9157c0359efca493c44f2d45e4129747aa01675b0aba6a574e1f18f8715737c370f30b1cd2b41ecac6c9ca84437660f3ef7433f971d76836ed753606f10d75042f94c85a4e6dc5e6a657bb1a3dfa8905a0ce3eb697988a9f56074f2bdffeb64e20e1f09ff5382331857f1e2820362751a74f789d58d359b1efb23c2542e4a18ea57c1383f02525ca5568e2cf3110b5651e6bb7214b130db1591c932272e982fb0bd234cefbabdb29d28e55cb4b479fe580a3093c9c308270f6d7b0d4f59c3ff72b2eb818e8140e5b5e54fb4d4b23bfda7588707e740c8d132a8de5cac2555361404f73a54a7a1914c762cb52a5018ebab3b9e02525e9617bff2bf6713ab2f0757d0b79d9e369d76c7c49ca042c67d9ebc5ede2ad4ed916bffc9662d82135585c632b60779e541605f0b8bae4a9cf477409a3dd617b4a79f34e1ac21b5b1529889bb18c8847929df0b748fcd65eabdf2b72c1bae9fb4342bbe7976dca41e67933db2a9c30ba169120ee425a057a8b5eea3fc70a1c3b5af2a29ebbf7b5ffdf46dd1f26430a45b9b2516809b09f40192680b751b80c4c3d2c625f2680e74aaa72c928c142679bd67bb1c97e9cf34600dd002a061cb3c012342a093cad6b228e09c032606aed8a37ab115dafd59b8d30cc0bc004030921365fdb223b9a95531bc41265d0f4c6a31e8d5cabf01b6ffe969fe0660e84321f3a270d6a42c6f5857853f11ef3d7c8d8185659959a1b91c1f231adc43c1307511184fb20d03240e5f3614cbc2b8fa508b8ba3e326e8f159ef8022cdf49cb5a6ec7e23b63a6fd83ecd892b97281fad19218c27c7751a297db8d7044c41e9f667883cd61c894fb49061b9eb3f6a73d56f849f815d5f0259ef051934d96dd7aaf7584616a268003ec696d4ef1ac04cec3239e709a474e5b0820773f2b3038be4d2426bdca13277d2934b088e73c1b0a8798ce76e76bf303a05be07aa797b6bc17d5e71092d6913c50421d8ef0081e09708e456045a36537fd14448568cd5a774c6f5a7edc5ede9f298cf2e188a9cb465901a68be50c1cec54f09b87668c69d6213525407390e22c68a3eeaa954766f588ebacc3384730e8ded8b048dd0dcdd352e2f704cb406fa7efc7c192ecc18bcc60312e3d035ac7558009f814368029220159c9b2d7c4717e14276f1229c442566c095a9ce0d93a649ec8d71b4ac9b37f619c34b8a0b71a7c60937eea6e233ea66a457028724e98b5fd70cecc1acd3b96cf89f72e3815d54ed867afbc8c1cd166b30756302ecd746adcbbc574f6bdb19eac5ed72c681edf91c950cd3e672f04f4c42e44ff2f160671d391597428ea568508a29234e5e9d524ca934d6f42a57f69eb277f74314e1553205705de57c7434012de9b1d12a30da626c6e90621ae77c2473db0cd24517f0409a22c64d8b5f9be5d13bf96fd72e734baff0f3e780ff0578fadcf049220a43cfc68c1959938c2af3b7c22560501d6bf1519696440a527f0e0b809bf1d48ed846c9d2fabbf4b3a825ef025acb6c83cb7fef1ee82688527778992ec0fe9e2181f5761679bcf3626c9db9d93a386e73e9c3c18cd50ba6866eb4e4084851e84c62aedb3a3ca48b24448d675f5ebeb19ddae529d98c7fb5b233164d4e474279c3bb70d93bcc299c95c5b825738dceda89a75b002168360be9f2792799ee5f1ab945f90a4b9f79a32808dd24ce42f285938f19ea94a79ea4375a126e5bcf44b5950676a2aa84f2352ce577c88de83ecc14bf62da19a5deac570fc914cf67b10b6a1b68b5bad3989be17f27be9a1e147b24cb6d114b37ce8c08ff7461a53bb70d7e5c4fffaf9bbd19df640631b553ab067ecdd8eaa54f9d4096f5ba043ef6de350aad64a47ff720f4e4978a993b01f8dd184173af90536b054b45c92181c11297e60c5a532d6180995f2da06d564cac66d7f2f726cab790e967851c3768f2a711080ff4e597bc0511c0ba8ddc40ed4ce5d58d8ecc6103795e9de5aca6940fd6061f6b0643e36cc88735465adf3542935cba660112fd08ae6eb1407ba38ce030763893a6dea165efb49b6f64273c331e031da5b8b802e7886c4b68b961083fed2d3a1f416b2a32f94abcbb3e6cba367e5e18b7a90336545197cd7351192c61b6fa5b337f29e2fa70e9a5645739b0ca92e1c3ca231e03b2a6b439a005ad5577dfcefead8b67c14b7124adb540d536279b247170cc6af254939f9d12693a34769f6c7141c8afbd1202e2febcafa0f31a6dbb52400eee5b9c13a8a0cb146f329d74cf6f887a229257ffc3ab12639cb1e852307a9ff5f99eb139d85756e4252d003c1d9f919a70fcfdb333d943d27acf3b4276db6e252eba4d1d04570b9a123ba33614b69b747d854f1b3603c03ee833e225b4e87ceb5e6c5a7e7a76c2748e3dec32503c536d9d9ea073b37d4f8196ec3dd8ca3ac0f860864ccdf4d993d3386b47f7dd9dc60c1dd517ac2dc98701ea42967abc916aec50d593c733900d48c76393c3869260039adf21492fea9d11aabb1b5d088a26c688e90c82b0f424e55f5bf3d80dafd4287bf898b5c872065f69b6097b64a4c03189e8fff818e8cb2356ef9ffd553a7dd038b6ed9cc3997b8386b96f9c9e6974baee99df62649257e463b353116c79c7c8b7a54edb39e5d8f08e91ca4456a21229a5f1b3a5d17821752b8fe39b9159b58f093a6a46babd26777634c0fb1439e2305b6134667ba293df6275b0e15483b6e2a414575f82eeed8d1c52d9a9f72e178605740a82891f65c9810ab61769dab7471016136d036ecf31ccce4777aa2320c61b2108c6c65e0d5b4359ab22b5a8b7012457fba78dc31a6f66c63e91f7835720300042e32a3d3a20509a7ee41a2448ebc7567f3cd48bb099a8bbe4e2adc4faa25c5c01a48777e688fc18f717f6351dede24175cce21288886a080012b223fe01e400584111a595d659a259476399b098560c7a23888cb79a15875c3b3e82aa883bbbfdb14eba38803fa267b1d7b4c2123e1de1cd2c805862104a127ba74a690010000443e5dcf9b32c4313267dbefc2879016190c83388abea800741e0e213e6c00c05a647f3a0ccb7fce96186c3709013fa664f69d1fcb37ccd7aa4be9c2e55dd7ff659b4e9296b53f07c7828fa463e8a21d50adc780caf1565c59a542676edf25440f83b2549ddb7b51d4435250dc2131e5f979e0343dae93f8b162cd54ebc10e69fba6707a584f6f17e385d6539f5a3b5509bff0184150f1f5239c25a0ec20f01deb97b9760b3f8625be7a7f72c0a4c65fbb3e5f5a352713ca8d6bdccd8ba1b9af05fa3c5b16b0789b7840f31cb2b36a447338bbe102ada4a6c49b47a3ed0d751242b21cbd860bed50bcce029b137124aa05d66f9112dee35a8e6a50cfd4fda1964866b5a42efe7eff31ab3c59bf508f1d640d715b4ea676ca050f8281c75cb56f7e0393a50808419a87e766e736ddd23f603afe5d2adbe4e8c15c9cc5b69da82f4ce60097a09b9d7dc9616025d85ed3405492551e4975733521b94653fdce1931672df507ba67a0a5a58c55ab195624f40e6f513738717c120896c28f6e22919ce0dcb0d4fd3aa38d37f1c6ae4ecac559be2c0aa8b9fd06a871765929faf3e74d90741508e8686d288f3edcab47df76dd5e9be1b81e9daf64bc464368db8edc7a72393e2e71da9da0e674aed8fd907134c230fafbbf02002945a16bca27327618fe01df5d0e52a8de542763e044497fcf0f59fa70b47a403f9a66aecdb0b6e1c2757b094f81095d8cfc5fa7c677218bb6607cb66f845341005bd8fb9f8483e66ad9ad53f3eadb3c08596fd06b90de60074dfb2148feebd0561e2a00f929b33e478805f4f1d2dbee693d63d09cfbb37a50130e798585cda06b9def2eadd9f6691ebacdd3ca2048a908c9cfbab11c400778e9bce2ccffcbd52e2af878a817cbee6012cd77a2b7a73cc507c71db789a9a576bba2c07edcb77108e9494fb1192473e3164d89c38666ffa5aaa0f7eeddffd9fc74422d1e8afb8acd620c997540c98eb1b152a2c641ff2785cab762acea7149c77a9e10844d783e5e22ff0499bb515ab75eb8aa9113441b1610eaf1564c56b464317eb97dbe75beff9fbc95de11861de397a758aea782ebe8547ee12ef3293506a7fd7b8e7279b6fe012eb5b6354e6ca3d565e05cdd65ad93b98d3afda0fd7180f1d9d4fd233d9722ad21c1e3c3d2e80d3c2c3f0b3b6815e1cc94337a6128fcbcce4486572d1c541c54c996a4879b3e2aa93abf6f39ca68f5045abfe4823f33c49563cfe0d7681b4c731e8a8d172062471cd06576c5f1cd34c7f2b6c2c36354b28fd05bbaa8ebca6d1ac1dc774346f89e2ab6230e0dd3cdb94fdfb459c42b50338495d2992821e3d89804b833c6e60274cc09dfe2a1214e29022841b449ef2ae1e6334a933a49d139aa7917c84b4a936701c805f3c1090d219a90f8b8edee4f8e8a386bea3b75ed7653108367f716f1c4e700b4af33a7eab73bcd6a38ace6f72df6ac80adb8a96002192c1bf02514c9522a65c9582bbd9c654d93625ce614ace05899dc7f3f439522d920d2acd74c471a25b327a2cc2c6cd5d922c7502ef840c8d20b776ad5f741018bfccbd276d392831bf74fd8483fd6d9dfd8901f5732d610ed52096e5270abe93a840c4c206323bff40d731016742849415d9f6b4eb6bd11f1af33b6709f1e28b32c308acf29eb37051bfacc642f0584f5d34d147dcf6f0f8176231186b5c2c88dcee72a591588643c67e75dee7ebe4f7ba7b8a8640677e64b7291bd24fea8e76c1bb40f8bcf5f2566953b9c055ae662318c8d98f29fa3e047b64bd84efc1c353385a4fcc5601613d51a199f6ac529c279630a5503c26883c747d8b3c9494d894044a7a71209a8256bc1899bb3ba5e9faf0de61f85e9978ca3b377fc8502c19e67498fec85945827a4b129df8372361f252684c34e8c7d5ee54cc5fb9f94d251b389c4bfcf2acce02b14d8134b96fc4b84137be4b33815e71d55875392caaff98b814165143f8660b9a080835d021f29c122806c66d30353ccd16e7acc06ad24a28742af9ac2ca99daed38c283b7c9e914e80ece4dc189e4d2bff78edab9d84a4a8161210fd89a0818762f63a6a511823c104cdf53a2e62accbd6e29b11aaa53077ac59dcde9896a1b1d7f1e6f46b33d26b97f04da6bb8b9159671977c051a90d8c2ad8cd78a9a3a1b69a0cd4b6cff7181e2dcd1ef3460a661f1278042e027a4859604d5908585def7fe5a72cd813c162943af08ad851115d47e112d0613a30ae3e557f7d2b6e5380dbcb9a6c0290ec766c41ca3346a6526feb2dc9af9146e058df86c917b134fe6c8a9d419f095f1aa3412580488e690f3b372f4a32e8cbb2ab24b37919861d2ab9a115d96644b86e2fc12555d358819242f016ce2409c6fe5e7cab804748aff922dfe6e5065ad082109c1456fbc251eaa6f89412e73da2d2f3e347c9ad83bb2662e66bc1c9ae917d62a21bc94c5fbd82c7aa9a5152a0ac2f459aba68ee9e1d260c23f5904d185584b93edc3ffc7e8c622be1996ec2a62a44098b59c12c3d121acc08736411548bb309f3c5e4860e1595695064dd696899aea410ecb3d769f6dedbae169a2cfc95510dba15fa265b095e8e34a6c5482d8bd1eb20c51eba21900645162928d6908b53d696ae581d368e096494a3aee441d2e7cb77f3e22994912872552b4504d9c882f230ce5e0df3bac2e577d1049294b7979bfda2ff1d10ebeefdd398c158670b58affa452bd1551208eea2a880d64c63418f50faaaa22d6ac42d963943e4822446e6d43aa0d4e67fe4af3aac14eda175e219e0492b5e2780aea4704f89533c1b55e8aa2795421648a6bc894f2be719558242f19b5242449fad0173c49d8a9469d22710990514af4a164282b77a9c3114db43ae71fab0de0e632f588a7cfdc9a590dffea3c4bd217ea50487f4b0ae6f678bd992955dea8c12a42d815b76b8c558769aea63c739ac925386c87dbadaffb74739f3e5411fc24c558f197a342492ca2abe4fe262e715fb495eba7ea5b7bf996653ed9b5ef3272fc6bd7aa4208f23fd269b97c74eb4611d839de8c44923ff4a47358c89de86478ae1368f727546ce4914028e3046261db2a7fdbc542b6e384ea5ff5c2aa4ee932b32264f3e1f17729bc4932a36e205d82665804ad1b17775fac13681b9d689cc8938529f64df1067a5e117b22ae87a8c4d3a8a1e3eccf90cdb191ea789fe084aa642e1155bc59360d756310d0ef438f1d9529b7e389043134b4c0f7c2541a320edda26c1a220bf7a32797ebb6c15b039237a290a15e4067c2769060d39ed3aae9d64fa36b4bfe9e4f2f851393134730da1c12bc55523ee503fd11104590ab3c2996ede5dfc09248358c12cc479c79b168f509014bad66ab13e6b85ac6469e730ff004c9fb9564139c4d54fdfafa78e6305840b8c504248ed51ebd0f6814a02658c69af2b22cdfc2eea34a4ea7b88428c550bc24c382f317311b66bb89e11ef22f9c54c928db027f11c6843c823def149f95c91a52e07d2e807558ff77ce74fe11bda6cf770a9cc8845b91fc24d7d06df32f602a65892e5f479945edde8ce398443d49aca2a80b6048fa4c78f2368fb1e8bda69647e8dd39d8722c7ad79f33c43a3835406355b57d3e81b6ce20d57e7c2d9f31cc8c8478d1577ccf8ef3d59192eaa841a39aa15dcad3ac6818851695025f0c96d0fd4a4aa04a47277bb899fa678f46025563581fde7a6d54699d6b150db62b6274df859abe05b47049f05e298483fc25dfc467f8a8bd75c5df23955913269a4b4801691664f98167182ea81a31db077875a81ce26ecd3fca40153d921b8f7f7770ff8118bb3e94f6e511995e7ca8ae9862aeecbd13e44b4a55bbe142e806570cb02dac0bbb14f51b989ac0b9e97948b2c2cdc9c2547c3b8dd692f87f87d132f2614d74720097fcd0abd9d44281974370237119f5da8fbfc4f73bc8c72cee576b82ca100f86b1649c77261e34baa8af4886097d944e18b030078ab71cba0588acd142a7bba2607194e3d7c78464a6ef53257c59f98e25bd251da65abc0d573363d6ed47c845812422682cfae35909ffc49a8da8fb68c72a93e4489d0b8abd84f42f9e96abe76e2ffa8f6f422eb53a27fe2808795d038523f750d42317caea67514ca3ea76993699f9d51baad10c2663abec6f1a34645db2b5840ff6e62e4aee5298ef82ea3c1bfbed20e6c6d78e6d929feebf06dbbe21193cedb0f261ae1e6770460d9e910d6a2007b8a1ec7a78f2d7a783eb129695ece26cb1623956d8368fb9829fe3046bb26a2630e5a23fc3ab12da6631b02b1352ff5f3dc34914a6eb6f781e348b273c9be671111c00ffa6bfa8f05dfd358e1a2ae4f0c02b952ff8d477fce9c51a0d518e9bb082f4b77f0c24673689ca52dab1c9f5d0f4cf46353805d6bf35841c93a8d4af480d7d902c49c7d225f663c5aa5663744f6bf1337c49ddb0fc1022bb7e77ae3a47aa6ff2f318031e939420b762b772538adc940990cac3410850b914cffeeac576fb8579d3689880bd8dda0aa2efb17e89788a09d4f5c4d6648be2670104bd6f49b63610fa0fc8502a98f4a91d6c12e24a04dc537a80fbb8d3ed45af3867e7970b8161f5590062ed18fc32f3d87ec16670b6f9e4644b0845daa689b50e4fd6cfdc714da9d0dc410db046f9d9c4624edb60f4cdf9ecc13a2c1cf2b71c7c528b210f7415b8cdc08965ed9abfd1841bbbdc6f66eb14580ab7ee888cf6a85e4c7193ccff37c2febe55400f7a1d5d6e0c416a3e4a44095f450f2c1d5caa67ee3c471dc3d017a81790fa37847bbc697972b5f7783cd30b2beb62368fecee3f8da9733eca6b2f0b82a4c93d3092004b7f21a9604d0755d25f11e4f3c6c2b703c59e007970a67fa8b3b9454b02e1a6fffce13e6b43afe36be720cd4320bd8923ab530b9ffe0c94c9dfa2bd2e7519e14b36a240b935b286a7bbeccd35fec3f675da8decdfce18103118019c87de8ff9e4ddea1abe3d6ec4ea2f0f497ba4d5e4b572cf7f2f0cee58682c06cdaa42b080706dc08dd9b2e550bf54c7028ff3b58dc34615342f303999d5852b256fefc9e471bd9b382bf4d7e0b5faf7b5ad229ef1448821140ac634904ec56138640a6687a51691e485cdf717cad54ae196d3395e9fa4706d108f3a7f09fb867cb1dd5c565a63ebe74bdc9dc908e65e99130796abf852d398091a5dad3634dfea48f7ebcf694b5b60ce5071946043c6fc9589113dcb737c0110ccee62f6b5c01cdb447cb37a23333c2b3121499f3e750d0c60ade5e925c826771ce8b0be528b6e1bb1220edb5af0ea35173c93177dc03b0d9ac8612e8f431c42f8af844257be814bd2f9a40d3563944a03822ec1cdb611b0dd1bafced0eeefa3403f0f422e2758eef8730cfdb6d60ecf4b94989f18fcc6c3cc4bdd6e4889342f4da32081e7ff0cbafe9a1a3696cb6b3d66788deddb44bcbc4bcc7c16ae452b38717e4fd03f920f6b28d18c3069e51f9c47aa0fa070d1cfef6662d5e51f67978f4f8690f19d00c87a130fec1b7c20e9d10d01173b024a39a81496c408f03923cedf1997724403b4e707ff1059461038b5e818aa691a4c878a9940a378bb05b9e87d84be282bcd292f09aa0f684ada657263d442d02f8ad75edc8a82233446c1861b6ca132829b566715522006572c875c2a4a8d78010f11a0202eb4b7dcb2e13cdfdfb10da552ba69e392509a6a714bbbd0c779c9deae6ea2b3627e3bb483ca591848cf7e5dcaaab111160d03a8babdf9e7c56a5e624e415a52f3368749d05558b1aced45326bf62d16495e828a3859ab9a7df8eda15520d85c53b0a0d62edc79610aa21a3201190d3ad5c43da60fc7eaabba9bddbc452964ed4f91cce3820ae9fc92727ddca7506c3b48ccd4344d8c6d88f2b776acfda637c6b7de6a4092e7376be92df399ad480bda3aaa4947739367dd624cc853b8da18b9efdb27096ffb5e0267cd09a07fb718d11514e6a9c8acace9abc8a77c0a5a684eadd81e1eb13b48d8cd680573796f3026867332efd609de8326bd78bd60d9f4cb336d4ad40ffc899ad0bcaa9cbf65d2dcd487142af15a858ab688d308757058ad8fcce5eb22470c46b8501820ccecf616f6ef2050db8327ae1db3db8c568b74ecdad326cc6c824aefe504cda4c362145cdd853b12b6a691ab491538505d6cb1da0cbb1534429bebd205da0aba43af18b04875e49a476e0f0665a29fd01e45e4c7364529609b2b65e5236feea709245f4852423807d1fbd672a844aa5dbc3625aedd9daf4297f91020e6aaa506345cf5b692aebc4f06c4e581776c3414ba43c490ea93ce80cc41479a70e12d8ffdafb350a4378fb6d922accf0933b9d4406893172688b7084e6c8af95bc08da86b2db645b07eadec7a4bda0dccbfd665979be664933aa561d7fb586e85601651ef5b6dbb0510dc081fe9faf81a9389676aeeae64dde335dcf50a2cd6ec85144469a923e9cb8d4030b069ccfc6b17397aa4ca664b85aafdf4ae6605e8906102759e0827c5ce95d9e451fc3fbf2ddb0b1fd26f6115ff604e99b385a09d2ac1cde350ab1a08efddf642e2a7b6fb1bcc3a04fe5ac023d3c6e7d0f6267c3927c13fdf108d5fde8c49c7bbbb287ec03d6896bc1f38316c5d25621ce4633212f329f283afd3efee8654db6bdfb7e5675b562e17e589982f3db783bc01f52640cc7c26652700a632ac50d397726d5016e18ea82632a2fc6e3c5268be0768bcd692e2df9e59052bd7b5d591ded9d516ada39bd748f78fe152f231950ffbe0896c27b82a9c98f4c5c32503f75a0ba2803b557bf9699bf64e6887a278b39029e9929e3501fc9e7c6a371dcd4cf1357a3968db40708e231fb83b3b9e2332f7ff1fb36f6d2923eaf0aab8727ef3bd6032fa42d5518cb5b2ebc94090951bdbd9e6932730d1b1f4399f139ee630acf6b9bdf4019fffce5f0f51a5f19b45ccbaef4e1e5639ee5eae73ad68d8fa294d0be7f9c750d354277295b77cb9b70262816f4bfed6830711b0634b3ddaa4af5339c6b19ef2079bf614180da27fe2be83fb281895446eb785627927770f8aaa9bbff483e6568a9c979aebd796f837008cc8a793d609f94aea5ffdd38f5a8a041fdd350461e9d9f5d5a674b1d8731bebb8c3a7647583a74bbf6bbbac1b50ed045027f1efd65129e98829970237696d1bc9ac601b1af356542d7a95e405259cc6b4516835b943ecd22bf2eadc89c1ca83753aa527d92727545585dc6ffd1ead1e9ac3219764e99c4617b68576c26f5673d0db8fb39c7cd62e3fc36f1c7d95baa44d3ea1acae7a786eb625ce39e204136362f249b238f55d6ec47f0954e0eb65957ce8ac64ee6d3033610c7c39ed501a10e9e75f3a77178e2406fc5e6d6f5caf8396769ef64f294e099a5ad4c19692bcfcc41db934a1b0524055412b5c5283905fc41c36f3dae3cb6f30c4f82e9509201c7541eaacb5de8e65e13b0792461dc345d31582be8a3a140c50202d859346de3a26a374773a40e619067425aa071278c7e3fea7ff10cda9ba0a33ed9ab7093f03fd58c76e8cfcf044f1c644564781d8c9009ff2e4e0f4cc79ae225ed3a46225cba69e3e687c08413802ca48f2b4877a8ef8dc64da48da84d2f220333473f389b1ff98c798feadb48156e775b99e7043956591b9b1926c4775c92c1dd7892038e6a63586e28d6e3f26e6ea24378f57ffdc2a3dc011d05bd26ed036a42a42c3570899689f49f1dd6c0347c62b25c0ed2e398bd88e38bdcc9a678024887031029287fc3c56b39e8d67b6a46515b8c8bc17d37008e043ebcbb118413ba99ee112e1281d561372d73233b1933181b83143dca42b3392b17bb09f166cfa714a7ee75249a6b732ca5a1719d0e741e3129a493f741ee939978351c27939b08c3aa90b1464c38dc622b583dacbff08484bac6f4b1d6fd467ce4145790fbf6ad3cde41b3b53b8343fde9dfdfbd9e0148afea9b5fe388b49f97a0c20641b6bbcad0772e356cafa65b8bb83dc86307e6990c77ab1ff99a9b587625b9c85b4f038875a38a106df224acec6ac346a82a9d549ec93789fc7cef7522c2406df7492984b4d00cc935c73f1b6732df63777362ca0550307b65e33fe7b0593fff4a0d742d7a2ffc5ff5b18e0ae1c37b1f2e644c6f270a7c6f2daad8629d16409f1111ac308fa25b5caa0eb77e082f8189cdbcc16ab3436f5723ad1866bd4e0a204bd69410695fb6a126c4bc0473920ef2277ad42ce981bb1eb3ea28e5ffc99d4ffee6db68d7663e5ec655fe182d1687a7de54b84fb9397619ebdfc533bc9acbf2863f643005fa6c99e37f104b405e8f28fd56f5d2e7e7c5673ada8b5c5f2ed2a4472a00131d3db75176acba14302109fc124e6cf41a85f81a09e30bed87091a3585e7851b81a49823762fa52304261f4fc1909d7095ef0f4b841e1442cf637cf93956af2561b36ee2146cdb9b62064600343d845a618154f131459735ab63ceccf92a62954b70bbddbf4e4fdd8b018150b735c135b42b6470720105869cb507745784ee467c08ed33e10afb90495cf90b1f37bb9b35f7ba045751c4b7a7d18619d91fc1800bd16ab2efb3ed19a87407e164c822bf79301002235c0d4020c46030baede614b25d9a6721a29d57f2692d1408fcbd65a0a0efe9fd58f2edbdf515b9ecbf9812b3399beb3153e2b5944a74480f67eb0b85fe010b33cf4f37a1657a08ec174afb632fdf95d1aa30708d4a39480cbf885afc3caff2c25bcd20397d7a7ad74e6e6028e2413033280151f4187f7dd7b48b0b581344062c7d8b95f5c35e7a49d8da0832494f5ade801ad3d85ef47eb6e10d7ee05f09b47d193db5d834b3732a25df41c20f6a10065de45b9527f98a1629aca2c7d1341ed499ff13268ff435c5c4ce67454373c162d810516dd20be089faaf3b1111c9eb70f0e730cd277d5fd512958b1c72d25c880b04a0570bc8bbfd31ff004657a96adc27b1591119ecfa53879f3e9e4d3fb09dc8aad0be2a8ce5ab39f4a7dea6e2234bc6bd0b35d2bd0b031013b3cfd1266d2aec559c56705fbfff3589ab5a5b1d95c3f759763cccad26645f404605fef6c6902e8d149f449e859dd915754ba6aba6dd18c1fb9334a00781be8adca36183417c8d8e722a3b6325a8ddcb59b33456f62cbce19d3dcdfdf05e909333bf8e7ec2cd402d15d9f2f81d0ead54ef3902edf80693e750759c6ad784a8906557650d4856d23a26f1bd34cc6fb2769e7e343d008d7de58b4401ed0b7cfb64df7874743e660bb56d24852ba83dae3b6258ac5e14ac491c4d95ce47a9a8942656851d94ae72f116ce826a09c5c5feab578fbf4497e31e996d12c0f2e1b45211c5d2b04959ff3b9bf7ee65a9de7464ae27a8f0f39aafcd4565efcc487555d03330bb544634d51165ba7ab2e9100a530311d121d62bcf913e523a11d20a096e857628c59387963470923665162600644a6ea2b2c3059313910cbe3e4ecba2502bcc9cdfb22ada669727e7c51595bf62fa79446d248f9e2db21f93f53645a968237039e8210e55add45bf113ddef4f23e2f1e918786bde534b6ea3ac2e3a8ab68020f601180a52bb2d10761fce3039dcddda5a570557473e8f1ecf4c1cfb041909256a6ecf17493f6bfdcd85d0940432a1ab9384e52e68c77fe1c01d4e9ddf6fb60e7d4dc8889b61f1192a2795f06ff5c5dd4f6e5c057a63c2ef85cf309dc5bd289e9285b45f8a1cc2b45463af1b75ca4a6f0d85bf42a839120f5153f57c1a51fb813f8a0c0a300b0fcfd24d9295ad808ce4f362315e49363fc9b2c8a983f07381aa0b037c9c8fd1c7507d72e34af71b2db2459a0acd53003eba7f09d4c0f7d91210de3617ab3b82d21a6604bfdb03fafb2db5df0b1176c79a283b9fc07cfad44e18be9c145942e716abce0cc78a768e1a59b6647cf6434f46b01df74701f2f9b8dc8889e7bf7f9e17d06068855ddb787232ff7015b43d3dd56cc19a5ba8577e60f8dcc74f8bc2d1de85bbcaae3a73250edb0ce03752d6c56ef594c71eaf7582f194c9c3e1ecdb9c0bd85da187771e7182d40f5ab4f083bab57b0bade8d9fa993cb61056369dbabd8acfd5733ffc586a21fcbd6cee9164b59c892f5e3a9d4c73664a143ad9071939bd16e2dc132c5acacbd120ae5106b82a4c5b4e32dbc8a5a42d1da7ef6810b70c3db9eb34775bab7d5044c9d611782eccfd3e33cc148ff063000ed7b496f53f2ca046d0159a31b4a80fbb1490c7afc0211922a1cc9b0bd53ac3b5e43b78d610b9b48f1c6cbaae15bac0a168681ef424fc940ff372ce7fb01b96f460f975ebc6f321ade5be20c7843944490746ebb7ea2795e3f7265edef5b154d1d59265884b3500723688206ca8ff2c4723110e182aabe54697a2491fe91b0596a4f4444e7072d64931bab3a3089f762e39fe35e1facab66f83cebd3ba0394cb0490ec177e748fa2e59f274567bb58c2aa2e1a781f0e8f31804b3f1919a443b3ff9e46900b689dba0d0d40e7a97b6bbe78e8cdb2ced35c77a53aa57146ed0c3761f9e1176570acea54f1fc00e986951645439febb48359f8c627c702c428f239f47a3addd6a505f5a9302a7db54f696906cda84b6499f770b2c2708e2eeafed1d38a770061968d9bb440cc2393aedc1dedeb23a6d0c7c8bd2dd1ab738007ccebb948b7473ef1d3b217a0268bc1a0985fac7d6cb9d062af84ad4726d85dfc224c7b8eb25da8216ec6e9abc786e817a390046aa0df5d041f07cd4afee8a64a765d91ca3ddb7c7d033101f37981e224cd72959c7d8676ded2ae3af124b3e4f599178e7f6606bd0d48c7a34829eef366697dd05de23abc6d6d6e0713a4e706cf3440aac2f4857a9012bfd2fb953ecc5239bbf271ec05fe7a8114d31c0703ae673db917bd38978741a3d344583a2ac6a663c6660b910b43f911cb029c077639d044bf7e933ae93b3e57ccb3789320f0ada1353101689903514cacd0cd2f3a9a52c31fb6dbf95a36d02a22c431bb36fac3d9f73a2096da074f96e565c71993165b64051b9deb0f057f2c3043a09e186ed4c42d9c90b8eacca3464e3a314397803bd86fcc518e94360f56dedad7d0de51a5f83ed6211b3db97302ae65e76881502649efa57222076bae6ad34e70e57b9d6495421ee871ce53546ed5e9e505b7f6a24dc8a64d8669731fc0f3b75f90c4ac70265d83d206d7030c54e7ce7d680fb5240db0872f576d3bdacd3f2fb77234b764ec7ceacd09b83875aa8aad14","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
