<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b9c2c1910b420aa748bd5f9bade61a6f4cfef5aa7c195760e2d3f2743c0d7983e4385650d902380b724e9af2638d3bcdfc8dc681df6e7b6e75c10d702ebc1d674748f39c910bb7ae03fa714c9d84d662ec72b5b55cdc49fc294be464b5b355f41707d8a48c0373aaa47f5251c47964e62841596f4b71e6d0b4c91df3c165fd04ef8f1d8969d97e66727c8e8c5a3e9662c5490e5bf84b29161387d6712a8c4229d4a55cd3ae8f8d3f1b51820409c8c8ade2bc5bb0feb9c49b06536ee9973fa3c39acc4b6e4ecbe889899caebdd21f4ce4b18490b2d69589d5d49c229ba18f8c4a000a61d8c586459e9db52cba426b52253fd2e7b5cab3a54a076e943ac712405df12d8c15847207659e7e81684f8345b09fcc9007b74504b094aca32c48cf492ce2785d1d48aae21ae4a8f40e8034ec8b38a2d0410ea9ec06eff3802a34def47974e16240b4701b2006cfe22183ee4e35cb2c894687657f6526b2934bf859b9e4640bf415adaaa0b3de1f3dfb038e770ac4a8e56d11f16ff0024f096305f9dfe84fc9b933f30f27ee158aba71c2a4f76e5350e60d980e8d888bef48b3c9beface154dff281ceef21a8cfafaa76339a25193175846c892c7135b72ea9bf2eef313cc76fb4820be96b751f9162d484fdd10bef99afbc9e0a79bbf115f00327c17f5a6eddbb2073d03d5746a5e668a206f867d6e22be1decaa089d03896b50d59cde8e9554bd0da6d66c63e7467e14f9656c5edd80525c2a31e00e6ca6d46fcd07e50cea56398b28bd1441c0faa68d8e5232b6914edb58f49663567ed4a0f95c6e78f635f6e5f2d36dc021d309addff05db106d94e5375c76a6aa36b653da0829c6ac7ffba3bf7d1aa5b1963a431cfb66418fa68e29b3bbd22f82b89cd9530fb24f3fe83002be5e9ac22f9062f8c6958aea32c93acbaad0c48720e3402a2fcdc533f37325d166ec94d0332995f8a99ccfe91b51e585174a26cc70511dda7ebe558b1f8c3ef1754c023d8c833e2ab6e552bfd05998d536927d36d159b49e5c76384bed07fca331364808094ef9de6467731b7886931e33dcadbaad8a5388778296adfa937efe9eebf415c68cfddd4e0757f839bf65a8953d6c5b17ee911317779ccef482db9becb186182f235ed2411b87b92d73f90135a05e302a84c5960517549514cbe94ff35d7d17930115ba9bb9ecbc2b6a6bac3ffa613e6b1ba50fe05bbdb1aa0c43d183156e910029581ea906d766ffb428f3fc0ae2f39518d5a0ef7920a8c5352d01b9b2eaa0332d2efa3ba4b3ea107367da8ebb534bb34a6565e4c93c166be82e64c9a03dd832dc18e3c7360dd9b41ad8e28061e8de456759b54044a09a091f143a4a5a384d16dc859af293566be02e1ea21e7bb2145136544489cfd55cef641ebb0a7aba348048c8cc5d801b8bd8a5cad71d199bb5a08104ec6811b856499996bee8a1d08e59b06dadc3d31e60b7ab46586ce43de7a6c29c410d3ecfc70e16734911fcb7561422f9f943f58b0a137637d3b3602cfeec701f1c6f5b92e4974233fb462218aa4d31e96ae5292a3f29a5a0769b1a2cf8513037500c49df92e02cd8dd85e3d48d47c00c1a375a4a818308b51cee3451207e70909867d90fe8f30855a55049eab3ec156aa87caee193b9af8b0f079791745110b64ddf41ad601f9e80c713b1d61be5a54dcbaa2228b54e17ec7f48844200799d62893b0db3bb3c807e315ed7c25679e23a029b6f357bf42b214f9018b796c88903d4e4c089d0b06fb6f6e6f01d04573887d6eab6041abd6a60c2027762778b742bfdd52771a9838cc71850a358d20d6b2585e90f6e9c65de956be2334d337a2285878bd7a4f6d8fb93716f8b0b8ee985b663fbc53ba21dc34f5fd387ab64f95bade31d11f5001013eee0e66eb2b3ad0a592ac932781f0005ce9fddf60dd311d37632b8771f3fb3e3429a5065d99de76e16bca8bd82651c80afb1192d97bfb923623e14b8cf65467fad4a3d3621b12b7cbca425e637327a1ac3c64951f2ad6aa5015f0a022b5d54e2118812bcaa40ad47f19fc05bda817e59ce120c88150ebb33e8e922c8a12568039c9c55dda9ce9ea59c79ddf524ddb059714cc7023fcb66146c15d103d8cb27e8b6b7b80a90510b339263125929d36f553869d8dda0ec5724a6bd3fb401c5c872ff2aa45b614178828be761fb3296a16538542c59b96df7396f7f9325ff76e4db33b15a770ad8e1e61d00e6dabbd16b073676e618f38266c851070226e8731fc6f8f1a21fdfa6c4da44de7f1b15352ded13c5254768e5d6b66af32057f2cce9c225ff7dae8e0221b18ec3a1f352901ee14aff299b882b96aaeb757215318dfdd46c9d52a11b7daa0ca18399d41150dbd363a7feb3651ec1c8f5c38b00a9c86b8e590039e21f520d4c7f5cbd7ddf07fb6f16268b042fbe0fe2526016ce2142d549e5690acafae3b32b4a7096a2035e74b4ee8394a1c87775cdaed572b94f5c590011032f3af06ffeda77c1f9f2e3a1ddc01e8c5f28611e9f51872db0efc353a01311e65ad3de974d4de93437c32e515a80be2a2fa464e714fee2d86919368dcfba26bd4398a59d7e999db34bcad1cd374c3e86f30df7f21943d312c199402bd11d223fbbed870091c1a46edf4efd83566ce5291dd5bfae11a8d0292d0f3d990d74b65635a1b78b1a7b33819e79b66b46839c844d725d37b1e3767e38dac3386e8c0c4f0b6bf7920cc79f617fccd3d3e372f0dbb0a22f5eee31476e7232a92246c241ea5b856f5f3d3cc5b626e416b37e095108c6279ebec5728608f7b6dd362270487b33e026977707ac1185ea62c2cc28d32adf6588c94a6a69a81db4a329f1350d0d6effec9dd445377d5472b3d4c682d12aafed937984b226118c3b156288d5f1db46bb780c9143128a759b35b48791806a2c8fa91be831e436d866d78ccf1290d2ab2453f4c9d463072a4ab2bcd4a918a5ceb44e02f496c04f44cbcd4efbf3ae415178380d26a259c6f021491796942e5e94ba549a3f393b6b7e46d33e03f852b98ff54db29f84ffb0255c79659a043f030aacac50068f3222870e8e4d66d3dfc0b1f3f916dd5546282cd98b9b7dfdf4c7cf200bb7ecbf0c750a71ac36c7465741a2a4dce86da512bd2fb4f1325203d68117f2284d451b19290b24bc7120075079222eac74f4144fe1ae4a3472281b294efb93622c4229d65d8e0b8c1fe6feaa99bc81ecec287009033326b91c6bfd6122e9f5aa402f20719f36850ea4fe42aa1602cf39335cc275043108fa26680a339693c57572f216a3f46e7127c15d6f7adc5bda4ab907b95a39ff40bdf71ce10189c00d75867804202f457015f0e9d812c8ce664645c7a3b1130f3512dfef956a26dd45ebd662f727b4fc0d13bb830d6d5253e09f191476e6104f57e515271302d38a6be13800c4c78f7f5593464dffaf38b071c10d26be8554c920e8a39fc91843fd8d44778a901201a80441e432737b5f37059cbaba000f2cf17162a9b9c7ca8f2b41b373446f3dfae4f96576358ae098c737cb77a5dd28ad7e61960928fa765f95b7f91a238e1a23b3e863337e0ae8b8d3a7bd46ca0602c19f369c98e56551123331aea85f139c9174df64bbbfd823b55fb6128df948d18266647f2d8c2a17daa8d5acc1787a7bde842c6d1f758576b90e70fbb4e38f80b8df0e17ec8d4154ff4660929e8aca6254aa362fc0b21b7be9f3eba5f030fa69887b6d17ed06dc572c6f5399d687490c941772c4a2be0253730770eab79bc527505e07bdd5c1ffd97324120da277fc7a16d852996ca04ffc4da5116459ad5204de47ba61cb9ec6032cc98820722286753092e8171617ab54073efc7f9b0436a3e27cfc16663330d8eb9f9a79c09263f22e1835dd1b08b08f95e07f1812b7cc9364835100945ca1a815bb5b74670c90ffb1206e3b0295d0781e87681d1a0a89209618063776bf5f98d185065e17ee2dfc90e63977b43736b1e6739d074b181b4bab43293d4157553d39037e9cfe7ba423605282fcbea3f6753c5cfb52e1a0ec1eb0e99be4721bfa982afb6e8e8cd067772971c0d3b3fa2e20596273ca0bbaaf95f7cd138a62a834e6021210edae8a16882a71cf57fbf466b315805586f8935ab269034960ad7fab4f65661c6f41ab4e3dc5d6c628f5ef4be234bbe21f214a9d282b6e21544935bd06a1be77fdde0318a104c942627812216288f796daf6b24afad466bc5b31bf273dc94580e29a1927642d5019a98922046813bad1a95dc5ad7f2e9345a0f91bc77586b667993109c9c94fbd58c98bceceaee49f0a9aefe9787beb8570b7c8db9b73336f4205392d80b140618dfb6b288b1dd6446087841b174f2ce8c5d1deb0486abd4bae343ad668f93fa784acb69629c9989f7067624e052cdba84f83796889f83d72f4c4febb17f5306dc5b82e46bed551efb76c62f07593816a343533309028d0889019b46056684010f65e0a9ab74cf13ab8cf2212e4802523d3efe49604e91b6d0600f1c16e05fe956936c8fbed77238bec09bbeb887ee47d7fd71078e9d9554d100fa04b81281102f769009c6c2a1f0e3554306a82da0b2a8be64c275b6e1358693d2eb33ceb3bb43791b9d97774bb39d9adc0a370a88bb13d1b9dddcf24f5a2cde87ebdb5242b767739905753ce4333702632b2b9b7530a97a53866fdfa131086ccb350406cbfd3295be40ddcc58de526552300d49b406c6c4b4dde4947650cde8a59808e028c071ba92f46c63e89386b2f0386bad407965055e98e58cb40ace29b5496cd55bf2c44e6d2a6c7e191b1149fecad4720d24a1f68dfd742a7913e81303e6f95635dcd4fafd173c84b09a3a94423f5ad39f6d192109181e65d430b849eb3f113d28d014ee55786275fd105505a936ed5a76f1038f4ee131cb8f5c5af4abbbedb5f0f42af44a4b7b732e63c593000ce43ba1bb12e5396916b74da5606db199ced92f3281a9d1d1c0a07ad7923e0abbd81c5db38d6c5eaa6dc55d4919f232ddbd7e39bfdff3f0eba1981e9855f8de88c7c737a7835a289fb824b5f028d89e9c9e12af2c313933db6bddaa4bbdd9700c3ed0621bae40901d9762bffdce2217131aa22862862f2703dfdf947940453de781cda32adc422c9dbfa8a67ed2bedbbd4dfea8f57a7f881fabb5ab9c66dae6dd1a339a8da6a10016058368ad702feda37be6013951a0c2ce377884fafa8d33392f3f0085637bde8b8218084bbdb52ede3ec3b13da775a0ae0db69b463c779d88b3c9253fe23a28c5568c82af64315587bd80e7afa642dd00f79a0f036fb25783ec2edb6f2ca6d25a13601f3aac29721e68ff92f8c58c448c69f93d71b3899c2911d3fe10803600c422e2f169aca963cd65b1f70193e83ef2b09f7f01f9a13d2326630c6a5585dba4487cd7be932837022a743d10a3c9c3f1784370d01cd30b8b03936c654303c0b76e2f7aef0ffd84ae805c903525d820a6a9cf7b22779272c659ace960a10892ab9cc442e679f285763d9dc836ff310e6b83baed2c734b4209a7dce67543729a6b4ca1c4e409cdb8c833b3a6779213640f4c465cfd37b101b46462fecb0c4c8fa03b37db0b8ee7422750969acd5c7a63824f615baa3546db61ea820dd8462b37abdaf1ea0148a56e5b199084ae19bef9b53f03c9149c938eb937c4b50670ef1bd941c189e12488bee32b463c61c6f69c5099e2bd1266341afa995558d634c399dd61127bbbb5802ac49977c4948d70f4f83ddea51fb45b065918b84736ee1d237f92756dad504b6452f0ae28cbb39e0f51349bd21471b4875eb670d4710d672445327244dd93a2ce81cd2795cb6e68f1724d9248fdacf8f7023e4e630a1cbf9b78d170dab995010d95a296e76bd509d9ff8511d63d6ca660bf9f0a6937c19b2dd29f23c87df68ef1fec0b616efad3543b0fca16645ea749ac7736f3680406b4278298e5d4be827c42717fd82342f6e68b0b2c8f98b09b14c611cd86383856c63d1832bceed8ded399115b335b44b54bb4e0235e48b8a0511c2a2d9a9208cb9c60053c6a5a5da591f65e548ac92b721535d078cfd3150170346f1b7d1f6b49ce7d6cdac953b76341c6639d261eb2523a85137c01306548f9be56fe3f9e92e2c289d0aa1c2e15284bbed4c5a2fd9eaafa303abfccfd8d88022232363c805b55f77f0bce4315c14a15a00e007bcfefdc7469362d221590a42fd38949290c995cca5d377d38c671af72d0362f930b7d21e629068a3ba8f45ed1cf58162a308facbc03096f97833f9cf7896e3479b694b78929ad18afdc40a6ade0c87293c5d42116155a14598b82fe1f50d3640206f074257189e0cc4ec25345b0de57c0cb25bc0ef8a88a578d32c43605a0e0266bb6685b2db3f1332e6b1010c8970944689f21a7a318ac0b0f3be23e00fe0ea2aa52d93d143f764ad7de1babd68cc0949c9f3d303300577840a00039037ce48d2ac9efe1ab87c3ae24f710352a125fa557996b234bf8414f3f3e7c03e0a5627d2343e480abf3f3a7d6ef760b4ab0c5dfb809cbf7960d9a7d90915a74a5b3cf19b46d053b4a85016c2b4cfd45f61eece2b9bdd68020cfffa3d0d0a7fa6ca02ce441c618aeafffbda9ff9749f2a9d905bed6095ce125f27112229e6bf2430ba4bce63bdd841a0474733e5356a6de0c1451b8ed018d5469f7e72b24a795ed1d90c17b20054953c93e072096a98b0890b92e5150d0ccaa431f3e21abe1a836f72f4e947a4b5e5e85dc1a5f61490d7e0abd37e94eb42346ac06b3150b5b618eb94a71b2dfa4aa116b1e7c3e6d843830a01d44f31c1151ef9dbc1c4012e53b6b7d8d2667901f1a5057cfc38f5657b41b2fc804a2ce76a70a6a5960e7cc463fe2d00d991d69e27441b33a31d35337aa06037a19c6a6c2caf129cb041f635f32b646d081a8d8ed663ad20424d82b710b6fcf1b0b1c278508c5b75f578d7a197c3a37e8640562ca1b94d9f30c749e8da550ef73e9ec0fd99776bf9be76efbaf9caf090cd5ae435a86abaeea72b5f25ebb400b7227dad9217e894aea9e45b23f2ed863b7e6398d32e49d04470406479d553a85c531e7be910b58f58c77dedf089b61decb00990b035d68c075fb066424188c66a5d49fe66c81bdcd649d56ad56a975c08634d894132d734f8b63d4b403d6abd68771779de963d158b74fb49f73b3773d60a2ef5624cc56757ababfd20b259604ea710ff2b660c140f32bf64a260e07d91536bfb09147ab1c7bcc0f4c5a1d76cfbddb46afba0feebe845c779d45d4888cd1e528f61c5f6e760c366f0e8b3b9eef989f5da9357984744d70560205c5df6642b813edf224d03f31f5048e7439f3472ed564fab7ea86e6ec8eb6ab1cf11ec6d32ce7e325ac5649ac21382c7a39b43f27e35486b08ec4cb53ead2624844f05027a1805acae1014b1832ab2858b3e3640c02a862c14808024104e810bd3c7036ae90831bb75bbc010815462e6cc86e54db99820a5d03e3ec484079c0d760bf51798d8d4c146050f7cf5ec3f410f19d0cb1cfbdeee98431474cf9de64b45f6b996f3fd581a74f05bbb3c1819db08021754f5d2ec98ef5e0bed078dfad1644713314dcfb661ac39554503b2146d7dc35d0abdb69987fce00f6c5e111e2081a49fce3b0c1b1044f43df2b399d0056801dbc06a50283444c48140d55e2e38f10392facbe33d19b01e0ddd7ed14c06531a2952f20b2844041e5072cf9669026116b5fa57a5eb861229abc0073eb4c5bc5610543b4e87d91b0af224e119b6ebd95df3872c27848968ae7af8113b5c0ef647ab3b5aaa5d043473a79de460173d608d68a34f713610745cfb8cbf05977d3cb96f293f9ed0b3c414c4fb1fad487a5fbf8de4fc3939c733e700fb4f142f18a771b7fbcfb0ebeda3a380ed3a80535d9bdfb1d3db4b56715ce8facd60f51fdef3f7c38fb7e81a26acad7b4158854d7dcdbf9aec43debc33a6f6803d54982c1394010bdba4c296f8b31e381ae0fc7e7884fb897bac2519ab7847c70349ff6c19c4fe2b7980dc58c7be796ffcf574aae535a220b511547ce80dcbaddcdd5dfcf19a596b0fe22736fd45afa008da89df4a5b9a29cb023de18d6b9f1dee8925d9fd63c6d9db893544b238e481d3d1248d5b00473cc26e538418f3b53ad89d0f87470d4509a5eafa8f28e5e107bc576566ccba40d7dbc469d4bcd01b0dbf1093b69568603cfc557746bb2101d1c3d915f93a2bfd369f06c719bfba710078e32de01247a2d1bf8095a8e2c80b59e7418104fe518cbaed19544e6e32c16b14f32d5fafa68191474068d08a8aaa8532077cabcb9966bb53ae85b2dfa5253eb3653db7dd2e78a767a1d3fce6dc48947b2f735a9adef9e86f58e7228d57bc02c0608e4b005afc8a95a566d3cc7dbc40325c02de8eddf56d7798b04bf41477b9d830391730b17b84326ad39111113530c932420ccb92d622e9ef589aa10eb3acb433d70fc14d507a406cac54f0a79dbb011cc08f6f09eed93733d0a38301d21f870cc7849fdfb20dead712da4d06ba9a6e82067dccc043fc747637d6eec3fec048cfa619e2be06e4e12008a1655ccb6cd424d17bc1e001f5edfab3940aff2ae79f98b66bd5ec4a4ec102fa1a676b123a09ee85e06e520deb09c2b90ffb27d52d2e281ba46d5aa550267e492af08a3dac543c0694ee1c4bd2ef793dede4f237afa012ed1cabe3d382a5a979950f1d2348320070d1c75edac698d6c06df93728828329c44ec8f05958be8f6aeae0bcd027b13731abb6201d1ff3d5a2643f270ed026ac47faffdfac52d6d89dc2ac9775cc91cd45d13a02668772e3a7cb9b67be3fcf50053297e8e3a779979b391eb106d3cba5fda3e6b7d6c92369b5f43b7e0c05adbb5112115fdf6578097e2dc026ee6f6e689215c833aa112892100e47b935d362cd49680287e27e25fffc367cdce284d4f45f4886f7a9bac7a6b320797a1ec7cdfe8790240fdf48e36bcfb51637fad241b047db72886474f265e1ef3b75c39a161be154703293e6aa6ea04b7d1843b48e434f8915bf48f56d7fba622e3ec9f00a90b2b3201d9d3ed56c7ec412037a73c84da11cc41cbd364945895668683190df01d5fb13bea1b6607e56742d6437ec01b800ea39d334e46b163a5ff6e3db1e6c32b63cbe900727c5f1f87dbcf4fb5367b71e8486b15a621c62f5098d658fe0d961a54ffc720b797ef831e63f639f088446b02d85737205561e74a8fd5a9eba56b382ed536a9192c43d5b2494b7607792439812cacfbfa6c2fc3829c7cea87777c60f7681ec039dda6f13c8c900824fe3bf9f2ba3046646247db5674d4ae48d900209d70cb3ecf761e0fa174271cb79fbe646c44dec2398f4b527eaa251a86f18848f5e46ca0f4081c1a1dff1956b5146f27b5f22ff7aee2a2bda7a80a5fc5458ef7fbdf7590bfbf78a0c2f2ae067ecb1be57cd99ebeae14ec43b28d462c59a1704696b1862a8b6361d6577be92eb09b8ec92c2c3aa9933cc2682d3654ad2589401789d63b2249658191c32e4e51eab27345e5af99e754ffc18a4c11b3f5335ec6bb357e2b78bb78cc8412b8ac85ab3b63e6faeebb164fcf23cbd6fa112ee8988d871365a083e8ec2fa6d94ff70969036d1515487abc5cf1b2ad9a478009cd2c7b58433ad0bfbe6185aea1ded46da8d2259c850590d9821b47d2f19efee2ef45272b88d0e9ca699470ebceef224168671b743273e0a6521483c66080a410b0a10d405d14af6311e83f90976671cccb61c1d7c83be8b879b999363c4e9840e113db81bb7729fe68bc6f67bbb43df421aaac2b28d5666739f1e6a4e557c4809648901802bce12f188552cc05375ebf74ff756dace20c04d75452eb3f01a3606e53114617cdb8ae45062e61118aaee4843014b1266346f06b57ebfb217257083445a221aa55539435cdaf1db710ad0540e1a91d0723027d8301bbc578a02c1b5f8de937c1240ad1c0053185eef1c8fea4f4c051011e150948fe188a03fd8629f428690d1e053aa3f26c997f0bdb1e91d1c6af6d21c57b1a87d7abfd150e80d10b2afd71b3768a8c6b03a1f1ffd71353413031ac124432e8f8344b84712844260b32243cfd3aab33537c310ee0fdda146e60aa3bd6f5d57aaad6481825b8508defb9fa0bdbe2e44e2580d0033f7c648d6ca1423845e7214fb93ec1c617ae5373a9834b919a24183a96afa173103454850ee237dfc749b88292935dc584f0a52970e5dbb3c57e569953a9242308d77919aba15c57efac58654369613d9dd9af14e27eb180920f0aa928f47690311cfcc84c999570a910677e4b935db11aab568157d96bb28b95bcb09da479ead4b6bacea2a8237022f78465e17109594db0b9484b3c899bea60f88aa1b9523492138d6ba5bbc571f632d6f66fe7b61bd4f84e6e1ef5c41619bc826e61b78d16a230512969bf1abccce704bd4692d17a7cc9bf47e5d8a3bd36930282c3af5b23ccc96fca51a55f42f02100bb1e5f0f1071d35793a8da2abd63e274dd839898720c24e4919794ab1bc2681c73bb47ed03c2e02ac641b6c0f3a570a86ae0a6ebe1bb679dc9eb6b0229dffd3bc5cfdb1320ccb671b8be86d1b285ccc04e4930d1c7811859a7a83e91ffcd312bcf23a1f55e9485b92d72a33ada775aaf9442cb38535542ae0904c26c22d4f216f76629ec710ce83c303d7cec59504347df2de84cc4dc974355bfde1873b38563b9bfcc55f24f68005bc6c30a5eaea32d7e78188b49ef89a494912e4efaf5581f1f85c54c990d26fa6ae7ffa1eb9d9a0e5e5999cf24485e42ba6d9405c164cbe2badaffd5c4d4a3aa01b9a650bc51eafe1362026e1ab1a5709186fb27122609c896e31c181128100a9b5c32a4338516f29cefd038de19daa86c7db482b1eef17f4b5fcce4616d86a7efe504653588edc13b9d9094961c9ca4b0dd6cb55fc86cd22c9e93ab1c7cbc47c6acbe288ec6f3bc17c3769d70be57405090a01b2073831c3bb1c425102a4ad0bef9a18d58337b810dbde21475980d2eb6b96cf020243f662f1a9f26ec635e26e44821dff11a143aec71a13b668639603699a2d62539a8b0bad8bb7e20c4e53cddc32aba1736fb8d1df3795f95f177ed0789760c63f576133f47400720cd7c24bf0dcedb74b36fbc996262ec1299abd02ff9268748fc8a67a47bf10e212928c8b1e5151a4764387e4ec47170824db793c720a7293d6a82c33a3af1d6ef59b93ffca44d9f26e0dc65f87de775a685ce9ea06e860cd97633a8e621ebd3362dcc278d7d6e6ce84bce8dcbd0897d81936fa8643a3db676abd8b45a350d80b62248108b2e04aaccc2557ba6072e2c6d209e6eda2a11b01815c40ab6f3d7a57926d93c6b4548ffc31a6d5f32aa1695b41bd4553b7291f47c0ac3753287b7be855b29ffbceddb79360f55afb4144bf03fbae5f5f9b1fab5643f826e74fb86ac2d5e087c1be1d5a0e8e638ee9ff10f6678d9b436bed951527278cc294fac67c62398400424b94bad88d77b4ff79bb71434203136744e9755558aab0aed05c99678c77244a645ebefcef697d27aff33d12569653e2c8e90dc96a825f3537758ebbed482a0d8b20f5891e86d813ed71392b47d9f5568d24b7ebcb762e897cda40af0bd810c80f4cf977d43132d10732819047815f0af62a5879351c1ad8c4f5555cc9b5cbfe73b0dc66e21b29ae70746f3588b777928ea640000cc9ed1e2c52936b90b15dde3528483db0df1d0269ba34ab2cd0dd6112515f98023684e97a7539897f1cb9af826b1975420d2c211a6f36fd93e055d3fd48da3e4b1137e1ccbb0af2e641f7dab0481fb186d84f458eaff3d3bcdff7a8857decf07b01add1a99c39fa77f280ca333707ac2d886351c1508a9a2bc2c7b0ede70f8322cf1789c2e9b330415fbbb6753d65e0abd3101c1317865ecf7e140ee26b8058036b11ac745d613ecf9e7ef8ace8959977b070c4c58b584be9f1d892d0123cf56778e7f5cc06981de06c116a67f8e17e6e120f5389a56c8548deee6200da60f8dccd9a091462b5b52e3d87115045dfce7914dd7b6440ca6c170f84b8cb5253de4f858fef5328c07d360436098b0ad6c9cefaf0bf7f7ec9e87b4786e30ef04ae5a884c649511590e4edc7ae1ac6a63eab73d98e037a3227515ee9ed076b4ce5d47ab225134666eb0a63b79ce79685396ebbfdac63975dde01104503e79cfc964be12bc65899a0631ee3687619bc9b16135d21e1cf3ca27bf7fd706bf05d9b9126b5e1ce50a3b1ed76c28b5a6829bfa5aac0aca0234737cef2901257238263f9aaade9d52ce976644eb01a585028ab9e31249ccf361989ece12e2647567211691f9903f72ece75ad15e5b35ec2bf1d4cce534e70d93cea0e9e75b35b29e9dcee0a715e6c8c6b2c94b9eeff46c2cffde774b530f5aa12f107942abaf181af4c948c6c38fbe44b1b30049eaadeda95496627089c973c1f269a05366ce6830337985dcb84eba9449bd7d9e9c4d039558b0284d76d0a938911962b7f93570291f6818f16416d5a31451f0ce8d2a9195df5a5a30331344d49ba1bce7713c9f4593873514138ea538ef9daae93f66a25784f18fe24a11ae796f3228062cf1f843fb9b6a30551215227881955df165bd89ad1bee6fe5b3c1d058e3167f7c8a758685a31de94e2c3d58514b995131d1e47f80e169c46cbe2180bb43028c73a0cc8d1d6784e9409fa60c97602e2db8ae5cf84de3b19f33540472c5c9be89c098a2f8f6af01219753f387392c16255b3d80d249478bf98462bbc0337ed14f73666a48012de05b539087fe5e529160666c814fce18d12dc4e1df7b07c2febbb392789f36fd09bb4ce5e5683e426751e40ca17ad964b775e5a60fc2ae429b483228080ba4149352f6ed32b5448f6a0ead14fbe12e42663b0cf7788762acf392f446366222b3df29e549c11859377b132d684131abd85faca961c9d9a0b62f9e80d582799ca030a582ee8f223d9e6acd9f44bd7164380c1cc51e2d4ff36001a9eecc7475d5eee1bd656a760258a6f1bf1ed7add4cfdfa1658932c7ee3ddbdf23b85612c9162ae8d32d4f692d977b495ac2e300aaf515e2b47f32e6707e6d145c4350c56c3f6bd807707490c187ec60b53075749c03333903e0fedd83e69bf1fdf861e534da0d54a28ab7d851b966e0e940e4aa21f675f4331bad4ca8a224092b662796827ba634990ca0fb35ac01bd3b8a5242338e15b29bf5861451cb49636aaf5115de5b583269cc706b924904ef8e8a7249023710caa525d7003d6c30eda4ba625e2cd396c40a902c9ba2d36c6bbfe21493f131e51389306a5ce6294249b102e54077bd202518bf96937b8d501c49044ec3cda89906fe8944a003d2f2ce33ee82e353c007e5bd8eaa61b19801796b940841623cd588888301081aa44233122471760908764adc9da409f69bfd1acd07010e0e930da8d0a16734253074307a3955e4b7da0607f76fcea0b873cb421f1cda68d1852b1cacb14c0b67fdae5c5ea6c5981259565473e9a72428cf7cae245a5b1d5692ce1e6f9b401d302c0a8d2a8519015f645e5807f381669be7a9c39404fb9a537c5b5953830d248bababeb1a06d7abf84c66db21b095c2eec7e27677d65dc7bd7da0a13270be2da4d3f9860177c8a55339a774bba4bd7926f9e919479f5697145eb3f84489878d8cb7823d9e5b5929889948ece16797b64d3286db898301e0c32e3342448ae60ff833949ff1574ea45aedb0f6740045d6a401ebbe275c2d3d9148f100a83f7f8e1b7b74ed6a7cb17214a56fbeafdc6936419d611ca1d4fcc915ccf45d30c805f305f46cd676aafb1a3ce5c95715bc0bfc43066cbf90aa5cd89f75889f0b1c90cf2b755438944d0559255a7c54777e509bc8be98443c73f380daa85fa059345cb45ce1605351760333cf3dd07cbb3a859f45d6823347e96e74f4d535d853bad33e62bb780569259f34193f801e0f3e842dc0dc31a3a5e7f3b355112a37da1b32ae2127a9d14c1fb4ce641f1f7fa7f27c1198687eea1aa7c62c2a3f1332b6028b69be34f810bd541333999f9e3d1566b5b6cfe44a7e2dd04f7a09b239190a9ce8a0ba976a867bcdfffc2508884c2772255b05d1c0bd003c7196e95a1ddc22c4565773dcf763e9367635375bdbc521692ff7c695ee2b7b658d817b6da8ae1add1cbb5cb432df38c77a6fcf352eab9803e4d85d81f274549a1136f3ef685b29e30df90d151904dd79fd185931feabe801f973faf53741f8094f1453883b880d5ff2e0e4e2341343555ed765b1b9d03354d9a57ff20f6ba292fb62818cbf1bb395e6d24aa886ae5fae8305eb56002a5dfee0f6cb5845ed8f398b59c7f87f98d331e2510f1710eb7af1f98eb0de7ae93c45a3025e39a7115a1b9e0f626997d6c1146d0a77f180c16a90bede416bbbe3ea0ef35db087b2263ba7d25f6a19174ec00572c39d891c010c9ea0a16f176eeb77bb961517570efdb254ad177c318e8735bd5da14dce5ae1c6722c58a193b7166b6214085d2f00a98ff34e8f5179c7e6eb08c4c866c7c2be674a2bcc898d7afc1e6e7fc72e8cd53b33b46c55543850d65c8b505bac2b8e184e6a6f6038732ffe95f95613d0e112d948d2f8284082d21c33bef76fa3533cfb6d5a6c495ec40b46caf0aa94a4f8bc3d5dab17f3cc2d7695924a81fe31f6e9d7e72859498f2e827bd06ad433da8bc1bee6b35e19d49cd8cb2aa6541304de7435ad18086ac53e70fd4f084f1e23452f527fefb9b89c4f99ce7e1d3707250245574ba791b6c48a8c3a721636790cc0b41648e31c44895b3fc125264651f72da24df936052c87e6328a219a943e6e08e03d5607f9fe124a90af5565276e7bad8db05b708fd2e8427f2482a7de1f11370cf8485a9097bc8a231dcd6603eef400f283e6286acdbc337468c2ad6fa767823d77f35f2d88fc06143480afb0d32fdcabd42073b2151bd57333b692c33764678c1cf9f34fff6715c1c3a87386239c4a4079b00bee3947fb7307d78620cb896f050ce1f5d49b65e8eec90be889ff54801947feb764e30cc6a75029c50078a51f94291a2f9066549ff2f509324d5df66cf740a45c2216df84d7d6b54b0f59ba3de3b96f7021aa4fdf1a88742ee506bc8256879b10d46966cdd65b8ea080e4b25c50788e0ed090e3825f7477205eaca619015134838d431152deca651be4315c267833e1f3904006097de67e9295645e27f6db06434736e5deaa5fc1973c0ce244fd7250dd1ce9cd7ff9a761a4a864496dff1d22727e7e391ea758f1b2ad91a46ee67ba87f019047b5d1ef8b22b347d01f15c97c01b406f626d469c2bc12ba394d60440828654c2fd5e66dc8d420537ad73129c5405e0836db8023c6bf1607785c5d6827a0d82100695d2add1f9b85355b17e15b46f31ab657453d0368d87be4b0ac4fdebb9bdbb97eadf8bb1478f18c6c3f97f7dbfd4a001f068b669a187573aa9934da53418ce19f4324757c78685a3847ca5c8d29591e058c5a9827552b9f868f3d5698a31f6d223f78738c96c5467faf6089d80ac54df033a1d2e650ddd66fcc80b588f5ecdb7acab47bcb7b7e058b43c36e6b3ad0adcf3cc657c16864411bf6e69ac97c6b1217216a64766cd8f1fbda0cfa89d6584c5b5da27bdeca4e11f185adeace31a65da737d7afd2d2349334b08d428c3af962bf69bd4ae7220002fdaa4e789322210c76176ce05a153ad61948e7be2100ed868e9cf266b7948d25045b21402ddd65a471594a2f4d399c76ea23de80fed9e1ea1d4c083b8e62f86df5efb0f4f209374540acdc7a991fe947d1be23064ed187d5c3709b8da15630a2219730f1139d8a52a8cf6fdb125aeae43cadf3a7a5311c141d651f3b87bb84aed4c6237db46a4eb0b0cffe2266dfc650eb912871268bfbf7081bcd32898bedb68cd4f113cf7e91aee967c18a458111a36a42ffba2de1bfeacee42aa891e045daa1423830d995fd3b1884e28fb9bb9898602757b0901b2b00bd089fd80a2db5d37b18e1ec5890d392186190b4e8f4e15cb31f78279aad84691de9066dbb64f4f184d59cc375d8d31ace8b5a17ecab2db9cee12de7403e22454a5d8a6e1fa7ccf564ff7e5aed3d9adfaa8e3321d02265da1eb3fe9e47b59270ba7256969a5b79ee1e9b9b35dcae0aa4138f433d0660d4df6578d892f12c81050eee3475fee09c50452de968f322f48a40e05896a1efa59cf210cfafdb873c2a105269b981c3cd0855ee12f62372247f464c8d520096d9787f9c5b66f93f6c225da69ca0f6b4081148f72a222aed4af37b334a32707fbed0711105994ffc8ea81abef9deeade8de9db46f1dc064b866436841075ffe1b6c2b449931a40bc1e937770631374e64661624dfe69e811d0be357b20e113d7afc153c242dd026eb3e8742bafc22e319bfb269383308de9c1927b5d8f639cd48fc7bcacdd4c0043ce683ecc123cd47c04b35c2a0e490a015c74d06eec27718e90840d98c64e4f9ee92d5b7b60740a4f1eb37da1211f90b055afbac0062f02e0da020b58d145b2c8a92b208e418fac5e680339d13ec4c82aad6f030fe96ff857e46b20779c4640883dd4c4f24d2f5339f3c9eef5cc164c979159ba6ded20477a8298a8b7a7fd3ec9b908b6b25041af2c06bf5fdbe2a70daf37d0793e6e6542dc36df2c5831b720e7aa1e37cc9cb31d5f0354ede92cb61d14b6a01658a31fa7246879cb13b6eb865eaa3fd26fa8012f19a9d9150c8db5c8dff44818056a3a7895e1f07fa93eec9142f51702e43957e105b5308879692f1dfef9b7e3ae8a30d7d5df1e5a712c0d6e82a154407f7abb5e0c76ae0ad96e69a672326389b15f7dee21b3bd44dc82ed94fe0547305828c2f2b40c2b783bbeaac286cbc51e8de386ed1f66e8afb4755002d60e36dc466934f190529aaf0c5b785a0e97e335606ee13143336c5da526ba71973e82f2cc671aee92320c42147341406c14b0954404446e50d6f3ce22c96088eb05e5cfe6047e89c9972ed0c854bf9a79e641444df018f5a745dbe62dd418f44091e4fb91284ee683acfb12fd7f4f0b4b75a0351c58439644408314f7264fb3903a3b00c7ad8a3aea508aa1213e9c099039b5fe5f5e8339b2e2ca34b39c72ffc3e608f40f6a168ecfa9c8aaaf868408cf1702547739933d3818c59ef55a17eca9bf0dfd5a9e527a870c67f6efc238c27e5211a84c34d49112ea856fe26224b6c92254a9d23bfad3c3d3afc1453dbea04d50f7f00b0601683e14a5cb47323d9a7affabe189fca230b2957f0ec5e68fb94595fbb6cc33cdabb36dcbed5d4413153984522c318b35d052e00c531c8d81d07c4f1dd5b12d80ae6946f99adc23aaaf68bcaa5ded4caa458065bf45a9f7e1405a1ad441fae3a445b3c49eb17877680f7f6d48738eba8a24ea06bd1bdd00db02f1bb69d7a24a8671b7a6fcc76c10880d1a367c058d389a7f9ff9284bd770c4e9e7b5e65ed5116674fdba26015c5f5f18ea4728f8ae3208cb3bfaac521cc7e66d1b595675beaa42d4e36742a2b56edf170258c6762235c66b68d677cd6f5356c32c84d333c3ce897466255aeb369b6765869218a4ac6a3a709f0d27a774ea60b32fbd7a43387162db658404885103b7b751ff66c9407badeb3f30600140a52f77f7574db15006160aa489805428fd9cff4e01c74c0e8d08ec78095fad6a6b99ce8485b52444f9a2c4805d8c6afc80ffb00598f068b0e564d3a71c06fc34bce6d247bb619054a7c941e36f365ea452a870e6aa1a28acd6c6c4934d7da9efd5f89330a56a3b53480f007faf534bb8d73b9dc1ae860744fd179d86f8629f3dde5f271e4c5376369f55081e3f7ab8e8a1edc5c08a7b145c2bf01a1c844e2ea3d57a1b780a607d63eb0ef4022a0ea11f7dde4396ddcbf44d41b683bc2106a53cf3ebcc10170ede3f2b451488185f10fae9e0f95eb34fcc26ed81dc44ce292bea7be963beeb9b2bf65a35ac8ef414a15f2303f75b0f6f8d30efd29fb2b3d69c245709f073e7fd35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
