<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cccd6f160bf2d4e4a03f237a5f1b38523c32e44b603522351bfeddd8c9545310b9913f3b81b47f92dfbabfec23eb64c9c0c48bd2eba6083ab93e26d0efe8c38b3001283d19be06077d8b8a27c7aaf38b054f2f5928f8ca78da6e06e2a28000ff1ac927b64dadf9a4cbfe882e57af9baad26218a403226923801c5414db700eb36ffe77325fcdbf09e67a614aba72116a46c2fa4cfbea6fd1f3ffb74c373fb76e340d1ddd71c4e78a48e04fa0b6c2b6d7c7f0dcfcb42004ece906b544d5baae64e35b30f9d03f019324bcc45fa068acca94ee239fa20df2002ed0baa22639ba6d3e976e1c62c79cc0c313c84e6316fcd5b053dd71f390de7f581d88769f0a3f63d9ac71fe3259ab284b72956491393e2806d8c17bfcd372496f4327b505769b6248d76e6e6b455e973577add572ada64f8b1e856a9cb586b715b1f2f1cf9f5578c02fac13920d171fa31ac643c118f0dd5cac504c48582b9193b0ef5857fc713e142cd040761a21aac6655a0cf327a04e9305e06e032da26dd4da15f72413178ddeb925291f4bc1ba59405f492e0de9b6eee5247f6119e0270b3a3b6a363c014d250aae80f0122251ff0d856633759fc76216fed291293d1ff92d2456bcb2e32e8390794e075c702d061417432cd11c1c4ad86c0cfa4c55275a3c48c880abb9cfc7b7c16f39a612cba1664030290d77b3b5e5d86d96cc04a0a61f50144b0e721ad96886a032a0a52f081bd43d46eaed0ecb3a6ac2aec8edfa67c797936e4259dce2845ecddbcc710d6493d2bdf6b12ac46e0f3976f9bce0d0e5f1357478d601a2473152d176208716b6f9ec7af4fac4e1dc3d427569fcc2be82f0986ed629d040c1e676f131a44e19ebb6a6a8eb6d18723dd796a4a5e11a9bd7175baeca89def9cff03b48cff2ca4b1a9698fd6f5ad362ed161a41435b01f015de2fa9b48a5ede49784a9e0c0450ca37c4b32d757a18c780f6967f3b49b8a4c6dbcff481771e955891e64e0892e9668bab651c7142db1c8db35d3a3a6e9493610173db0ee4ffb895be238ae1b0a83b8332ea42a2ed867997ef788a8b82e5f271130698c2b12413fe4c301e4a7a405bd0449fcc35df618798c53be52e0de8d7050b358614728252c51242de001c3597799bb68eb402b15482ff06149301be8d57e0185c4a70ab0babaf0ced767839da159062b064bb21749760315ae95e197f4a4f77945a40660bef5c5a14c0264985d4f7afcbeeaa52e30963c855e28356440f7bb6e221e792a9b4ba74c18058ef24d7e5c0571dda810cdf95bba0bdc594a78d6b9e15a2149da2c0f6afafd6b154b291af82d1f226e50396a90dd5b5009ae1c870e76bb77f8a6fa3d2523c701efb518c66922952bb6d217ba33e08ea24ee7e2fae3baa210dd20fd6966a5231bc573cd3286435b1edcac17606b083ac16a5e451c7accfa09a5ed9100b89dac158aeea6e6ec1f39d2416a283b7b09461ea688001146d2b4fc9d051b501e9a021810584a75c2389af866ce0a0df8d3b77adf5255368334d2b8c09c34d8010def8ea5cd40ed1d8db330f99b6579fd70309b793647c372300ab995076d3d29fc2ba2fdb0f42ea4763ddd810898b48775aa6b62146546863e396d7e591cb5fc3ce162aac6bc6bf0f16ad071adc5a0c54f4a3db77482188f9b10a3a68f18f6542d6631005258f743c60a7f0927e07d6b524065a5b0753e523dfdf1b0347952078e24ead97a01763db3dede21f4c1ff516c1890dff7cf659a7e6543d5b8d7e9e43ae885a643d153ac26697d68ea992675fe64c709cab48f3d412d083c32923a1d877aeabbfa83e68a984f650133fa34a4888f6db21952cc70b0cd796ceaedefd128024c9fd8875abb29b335a545979e49d91dec7b1f6aac09ce1345b76a6f4a3a645d212100c86b14506c684dee7e30500f42f294689383c646ef181147946d939137fa8279812c80cc1cc7101163cec919cef7c25d72a9fceeb44a9c9917de9d789e76ecd11be8bed9e035696326eb43247e7a1df40d8ed94fee0317792e9132ee617741dfed06bfbb28c69ebd1bf890da8c623ed2dfd4595860cc6d7005c8c15563ba5f579f7f43792b177d0aaf280ad17887bddc94e3398893004520839b884384ccfbce0ce1c9800da8c5463d56a4eb7f7b14f3788ef74a4eea584aa20a3fd5c5c493c6bf0c27b6c0817e05acd51e2f2ec0a87907b7380b5df791a06b990a56eeb06239db8c1cf0de8eff9ed0c66fbed5fa133d105e23f467bcf11d3c89f2e88b7c4b38d996f6fda82bea7bdd168b9b9cdec25afd924497216d689e566bc11b206de7a90f3953df1eb3689c2844b0e1ac528e5c3e906403bb8208aa41c92be34d3d477efcf43db234265d924124120481dfaff6b4a65da1271a0df5e2850cce795ab9d0b6e572da8c03b2a8cbef3d4bcb78125cc6790da863b3c98e486f29ab696606a0859c385573e6e782d788202ca69bf1aa95612a1242006d396008930dbcfffb1e963db07c98c043d5a65af988caf967b4e414daa151fec4a58e4edb22a85f50fffc253fe04f114876d5ec0e21c9c484eacc50565192e7fb9799d9a6be2dc931b954ccfd4ed59ece629b18eafc555598e635a51fd1853bc333bf142437861137cf500ab1191e9faff9ab35147fef4a2e8907baadcf3d60e586a8d6d8f57c110fe67d295242731ec3ad599cf643e388858b7c88eeca40dfaea9e6e9ecc331b816d5b119a661c9f61c1db013a5799d0b0e9a9854744ff544a2dd4a6adab11978a798787de918263e836803f40609b9b3de19ba88d9b9e7cfb2453d1b8f66e1d19c2b43cf90fe8018dd2494171829eaad33939f2b11010027a11f23c4eaca07036bff62a6acef84d16f2752eeb218d5a590acba6b802179df02e962fbf15faeba44be01b4e3ecee4b798e9ca9239b099a97c76fa7e04274a3597564c94a2053d211d78d346d11fafaf1a1badded1f5371a12762c53e557d00713f33220f0287f45b0bcc19a6ca3e8eb5149e4a163a64ce7293a784399af7b340603827d2e745a76da28ee110ce09cbd6b3316d3d3c887bf6e7cf2e296b0e754bbc890b44347830186971c1e275529a6b040e7ec6f08ee62caeee6afa3c46f6d97fde3f6058dd393c0dbd26f4b6fdf8cc14a377bd158df1bf5230d5ae09685b990a895d653f71b6bdbfcc0901c5a6e3fc8b1262a0a251e1bd2948d7437bfeba1c81285eea3f9d7f10b082ab5ac33b0c9df560716d8db4cb25858a127d66865564e8e6febe2189a162ad969f76a9dcc38c23db42d35a779ad7f3ff36cc1d7ac68660b8ff850698de96eca0b131b17be16bccf341fe7f804b0abd8ae858534624b2b6fc5d134bbde591f73f2c6dc4a760a1460ea9167f9e86d2d88e454d072b1a973b379b26b3a96502675448bc0f16ae3a724de546d4e64d64a94e02603c4403f48f96bd969eba5e498ccdebb48b93c98043c9ccbaec6a31c9eb9d78fadd2741a4f408eba333373e5475f081a547370b2bad581ca8bb8e7827c3df181bf61fbcb9f2d7f108897c6e28a2730ff99615544876d7a4bf34c49863ee3826f38018cfcaecb119f347e899f520cfcd068255362b5aab24dfef50d60bd7780d0b10f8d8f23c72ca56424f263e79e0dcd1ec59781295b954b776bd46e150ddb72899ec97b742536b20e5863d0164a10924f3064416b2f50358b0fcf92172a9dc6d3870427394b8d9d4f3b30c8bb75932fc208bccbd63b01cad8f53b5bd6e8686fdeb189c9f811fee536ad41b1ae60e659f32dbe94e6573ad42aa5986e40ffb719f0f0d52f6f7d03a3a529dfe3b5e83045691f041eb012c53cbf21877a80f8669cb8b0b72d74a8f31eb67a025958454ca63697f5c3d3266ea9efb46974fcc919b9eb5258235491d48fbca95e2425960b65b321cacb171e7358904611191f5083a6e53da5efe6c7518db6750b589f7d4f3a7934ad76666b69f5bf59fe3bbc1aac45075b82e8b4bb18afd2b0099bd7ef6170aa7beb21889ca023cd94dd39a6c1ac96eecf8a6e94ec4d85e4023913ea9a44b1dc9dc2605f3457344ab7f667d378fed3b0269b27fac346e6596912d76c0e7ef4030942302e9ed6e76912bc5e20428faa0cc125eb120b8bd2e25a9bb0af36f97e4b819a33f49d5b23c3ac4b6053aa8bbb02bef1b410b138226e31d554e80e96f226d080c7a996a28f44e1c41283dd98fde22985c0a118611d19ef0759d0a4d2f139555795c1a304968445ad5a92701df1afcac44fc8b353fb857fe46cc513be34c6dc117da6d516e50878e5dc51ffc8ecec25057e50a15b56c7f280fa0ce36e01f2760227216e658ecd330d7f34571c076fd67bb34404dc2efd3c026729ef05478730c2d03e3f1507a3ff74927132c4c7745e2a1561895eb180bfe5382c350779c51fc781a5dc9d3bfc762ae31f3006a9979f96656f3f3d33bb28ac8636cffff5febfe71b168e94b3bc63a1977659e256d3aec7b09065e439134ec14ce76109a26c3bdf8c004ec34f03facef95b3651b794ba53de3899f290af26045185aba0cc51d282ec3902087f7dab54c0fecd4262634d289b5c82c1cd4b3fd5e37c02a240f9557414ccbdaa9dd82479635b2d2d2862e990be929b4a1684a8e6beb5f12597af1db6b1d3f65bf378dceff87f1b6fab5f421c1ccd6b8c8c7eae0cf3a8cc97aac458f82757130ab10207b3fee986386e1c0c5f1e46a48b62a967900ef7e80f37f465fbd0c5d4f4de872df46d56d3df06da2b5ce9ebd4b800893625b9ad50a3210185a172336f2c21f7bcbeeb259fdca93c9d9e43c96b24bfa498a5985e4c34b5af85be67ef47587828519feada291738e2f4dfb1bc06b17255e39bb7b507a2a0310e4c7086592147684ae12a75788faabaabe2ac72363cd5b9e49e2ea20704a0b6326c25107646efd4c6eb3fc6158439a9f04aa23f8b8064ad2d35d8314bfd042883598d900bea3bfc5c129dac70fd7876e4a67e908a409f56f5028c526221b29d7cb8f53f5da477d9ff9910c22b939f3758e017e7908cc27c58ca8a2603634c3de90d5a037340dcaff566217d2699024eb6c476637ead7d0cd50fee3d3f27cbdb5e215fa5800d1f4f1ecfe7993ff20e98edd9314d903b1bf2018eda4dc8c826d1ea477c7284c9e052c2ecd25ad5ed7ba1745e445e9f27c57caa9f6e90ed0073dfa8f1ec602a906465e169a617a369a2b5254e36639145cda9ce603ad44dd7f459a7ac4d90d2cf26c4a0962d9e97a054fac9ae84ca52b35a15ca66ac2a32f6e54d0411a1f4b19c59e55d4a300134b76e20701553dcc4a05ea9b60e2003ad3f074f7a12aaa1510c9db8fa50b996eea7730d13756e2d0afba7009204552c6663be15a59600e255c6cc2adb40bcb5f3d21ca89b962ae3769442e88e2085e33dda2538e89211ef853e96d23e0b44a16dafac233a23b2d8381afb829459872e7f79f88876f41e460e890d1daa9ddf6c4b0e4cf69f831876c699ae335ff83e9b5eae76ce69475784a0d27ac0f5a3d55bfb4a96e70a0e549fc300c4852f5e1a142292545dbd188ac572422639e0399c6927cb9e7803fdf1e5db44646245a23e822857de2e0d1e6a1578aff139f688ba6c696da3ef7a7b986018a4df85052d9e8eacbf73478f86d758c2c8f7b04b032785dcfa1ba726bb5f72641c55b7376299a10c8cecae69f3de38bf37176bb44c471bfff9c14563bae34877ed859bb1209aecd7e7e463a19e07b5295c60b85b09195f9e1bd7090e6a06ae5f200cd3f9d75504fd29b5c6c41e42475e2686d534149198861bc5014581c39ed0ae96200811e9293c05f7aeb716df22a6c91a1e23da40a79babec3ed87c2ca6f75310ee1ab74d645b23cda4085aef2e65cde2aa95f4a9703bcb60429ce055664d65b0b28b549e98001577b0340f0e078b097c3b27fb6a5300f7b1cf838d410cced830a4cb1682e9928ca08fb579323bfe171a3bc5327eeeddf529c2c659a0f62972c31febf72b145bd470a8e8451022b6d5a87d65afd126dbb1425b7a90b4a9e0c1df7f3923975df61bf2898610bf2d416999c7a3ea217ee04b98785206af7efae4967205350c8cf3ac9d4d834a037193d5696063fea3a87be0a826bc90201e82b9a0effe66fdb1fb1d284e6e258df346fad25565dc554fb8f56a902c783a21e8cd16dd2a8f7c80aa57c9a525a5676dd5ef8c5183ca2e037a6ffd30635a4fedbc9429dd80873ef8b65fa777f007700ce10469d16431fc079fbe904f1db64dd075b9d7fa444fcc21514f4b4d3e073cc7ebca94298d81ba70b2b0d223c6f734c43bf2952eab410c269d5501f354b9a1e72cccb5c6e4249044b525fe0d3991be0a2492bd0829814943d8f10bdb38689d8bade9cc07d9e3857e0768fb42a3aea60449982185b0942475db59e87bf108fc252f8671d45eb51fd68db4a660829cb64bc413b34649ba54134cd21eb5a92b89b17d99ebfb967a5d16b0a4afdcb16d3addc8d70dd6781613585d9e083b610c30a790f5dc271cad33a191c045d48ab518dbac55a0c66be4131e71efb78620bebf14f0cf32f9f0b44eba498bcac89ca8c16345f17706db65187e1bbe08b6b2262057ae70a61d890c643543203bf0c895e7a04be3de2ff700e049d559cdcb445b0b145e87f3e4497c36d586dc61c510abf2eed0ee6bc77d59af5b2ce9badf2fbc66e7a86442fd6c755a47655a80f79185a25467c9d85c3bd318f07328370ec3a8b4fe9ddb10768f13c271215fbed53f844f64d5723032b44d2a7f3d588e0dfcab78dd5654bfb4cdc9b1a5cf1735fd648d5d8ce8032193df4ec0aa9619dc2e2c1a46cd9ab37281f62a236f8241bb49593e71da799d0a312bb0e64c0bbc59b82ec8ceaa4c7315e1f05590be132f04834100db441c35996290e1a256b8a6284c778c16f0f9574c9bd6fdd66794c682aaf82186947694770144133d06f50988bbbf2383c0c4c820e59c92efe14c532afb27b0fb852860929b7a44428cec26fc74185f4b699c3d657f3dd73a171b5a8601ba57b0e8aca9ed1dbfb6fa8231108c3f890fc71ef0462d7b515761e7129d924e39941832cb510ceb5028ab7656b687d9e46050cb7b8c124bd68186d2a9134c24da7b7546b9843b20309523a28978502cc5b58de01244df2f91822fbe79ef08026535c331ca06619143da06f843c23ab7540ba76c27b25a8611abfa4ee879f66c186cee2ee22f3892d48229fb4afd36f6625b1810a1278883b26c8294270abe2f9e02aa9c53599abfde36b59cb1a95a64686cd5cccbcd0eaffc8d2cc64d06326d9fba52f9cb361c9db100d873562714b03cf3a34399384389c45148f1cb9a592cc259c262c8ccf465f1b21ff2c2418177fb3cd8f7259566acfbb78097f4832e1acbced89a9c6dfb287edbe8ba677bf4c6e1bb348ff5867fdacec1b49ae009dea0ef012f1c38f63fc2845343829ebd16478ae45b9a8ecd6d7ec66d24b0d98eae5484cabbc9cf1cccc758e463d8a3366894e467d68fa99cafd05336270718491ee9c6b640b9cb07011e0c07f4e3f2d8d50354a8e7dd313e33acacc937f888d4be75fbf08eed1b051e7746d43cf57aa147272fcaae5b57dfce6f7fa8e74e4a994c96959708951df78b659055af90005486245d11759019a322bf519bd3410cf92d4d68f7e90f4a8778677052de6a71d03ca9ff2f6be11565cbc6bf7ddf5c941cb1597ee0a4cb6bbc78f5ce0ccf1d99863893e2747be33aa36db6f85bd54124c6deee967a954db75da1655de94c9fd54cbcfb4b3276cb0251eb6ed6d4045e1846b1c14300daa7b08c09929d06c1abd8344c6e8c4ce1a0fac12fe2977f6ca196a89deb6fe1e6f1a690f748c090c1973acfe0c1ea2555bb3b06e52995f8b924dd51023e2f5d5167e8a8d7764daff08258110c7e1f28c58334f2af4850b2a50699b6b6a5a39dc14c394479576bee500bf4998b77fcedcbad790c8bad1356fa0f8f3a7d59361881b4e0fb773938d85b174378c453f2a510626fd77727622b7134bcbec1983f8d95b922ae8a4b2bfd96871435187c46d3efe0b60914c73b83dfd28a305984ce3cf3912005a0158e03066b092380531bb810be11691c0108b097a5c63a4edf884865e357668c4f824d800bb446e926448da8956c14601bd6539a78ce0bef2d92b345a6533ed443f8789f986da97f222ec00a37dc309fb7cd53f48f5894428e16cc106965f87be1a45bc5170d47c578bff4caf64711367a7f684d66c86a0160fcefdadba80ead44fd83c7b53465cf62a8324651495390924cd4537a52e8aa83d4c6068ccb34cb72347666a7dcac2e7c98257989d5ffb2997f5a40188f54e38ec1715d0165fa1862a49d94069a999b90c0604e8713b342e476562e6c579e528ba2479a3c7dd2e7db5f691874c0b028e573a4e9647f578defa263ddfccb9dc3d7816bc17f8579a8b2a1d1e91b23a8b315482f1eef88febdac2373377d7040d46ebe5faf4ce57cccb9d99178853ee612db24c481fd768f5da12d59e39d10a3e3ad9a85887688788f7bd6a17a3aba90bae9aed9492a9e1cc8de3effaaee291bd55cf6bdc4bd52adee38aceca7a3c4468ce4ba8642e0f564953b1cd7b125e15f43a1254aee691af61e796ced3a443e7bff5efa162059a74eb651a4f690f932455e646ad84a6aa439193706f2709a49954a8d2a7f4fa917030dfa2c3bccdfc4d984025cb8ba2f7ed9df151f62368669a68b2f52a4806525bc8f3eefac82a8cab165bbea9a38cdeb7c363bae7b5ee687bf5a93ff13edea49351bac1324d618c452479671c58321dee1cd3fee0177ac970b7e2251727587c0df92cbdb8957e477225ce357c6214005c87bcd1e176ecbbbf758faa19181a1777fd3a692fb24617c85a0940390e8289a1f26f393ce085e7f6bfa7b846d32c874761836dc49ce0fe37fca42932e9c2eaa8acab7136d5fbb2c90fe75c40ba24bdd38c0c146366f1b8b2ddf8b39c2c7e14063384ecf132ad1cf408e2e8b9a2394de03731366e8986dfc0c3fff821a740da83e3f586426efcbf8b312db1a4297874fcd702178ece2a7f57f09b3f11b9249af070218edd94963d390e36e88c8e8d03eaa02736e3e2f2ff4f863b32723a9e034e9b640c9529b3c3989ee94d25bf21749d634041f13fdaedac1fd227eac6ebea8db7e19aef1f4f93596a8d66e004f1abf4b760bb8f98ba2775165eb05fb34ab564b39047780e62670db0ce21153859dd4bf031180d8a1c89a87487b465248cb2795f243d894bcb4787d3b4e71d7d276b39e36562085298cb6ef839eb310e99a2b3ffec950fc6c578e64820ca93281ce0f9e4c80c72f1d8710b5d24de45d39353dd6629e09f2c1583726ff2c4ae02340b29023f5b8d3582dfbaf7a672997d6648d31ac56d8eb021f10932f480d923b947a16cf912007caab81897e82cc581da91c38506adb4f1092f4a8c5a56b78e3d13414f43e8722e50153caf4431602eafeb21aa13f104c70dd0500c570296e05b121f02d165b154cabaf4a9ca0782c252f77d9f86e84331ffed004ae97774b939c490668b36a095eb39aea2b53ac482e328af416a0cd054b74e0ac6b6a12d32a2e33f1d4f21f6630707e5140a3b0fd508a35057ea33f1e927987bf4283573ccecd0598b7b6b22f75654cf3a15c75e2efa388b73edcaf2db9c848787ef02ad65bd23318acfd7f0bf3592794110250873ca91924b40725514d06bb95e18776dcd1fb6509158e55573e07d865ccaabf3e764bb808ec4bf83a94fa567a489a597348be654b67accf27f899795a5a1b8097c9be6ece7e2ae1127e49900af3b9137fcdbcc4e516e91536d857f55f6bb2f40bf6db35ba1f90873105476930a096b2101a77a71e9f6b63c3598ed154b01f47dbf4cff4a8e66827204df2d8bd0874242b9ecf32b84138d7cbb31e1143310f3f926558e0567bda1d7b0b9c2060f013f5264cd1fa8768352eb4ee9f367a3d870401db0cb7d410dc216674ebfc282a2115f1e6a3643e255b59a84609ab036e2e3dbd7db98b3dbfd9ba0abd7c9b16ee71e48f42bf86445a5f11e4c3d8bd8e2008c738507bbc2bb600e89c2d116bfc258561dbe7b176e475fa05d0f9db2145d7332ba775c06e53748d86c5186b20686d2ab14b0c988d329e9a5c139a441489e1ec37420975f4322ed16c2f5ae9b8f9e067e784f650254a2fa9c715a52a0f793aab3c44ed679fc8aaba0520719e9e8a7eda689863264e040f9520a591b23b16706e51c18a6439941fd235de84e000aa6adc63fee83b97dee5369596f61735e90016c8fc27f951fd0542b5d75e58a302855cac0f9972ff210caa25bcd58bb4b212f94bfc14b4ec69bce3b349d7bd67e16a7e45f276623916cf47d9c557c80db9f8c4ff9ccbbf4e003edff720661444e8f1e2852465850a72f6850ebd39ac8e9e311c3f809eb4c01416e60b915cb07423e832c1320663a22fc02be4607495aa0159bcf79a85e5f296afad1083167183e50c57d8a0d7a9063f2cedb65b9aedf97f61bf09fb86cbdc677faf84439e6140ca26296f52476393e1b481b34aad054a59a384eb92a87af8e02c530c4cbc8371887305070362ead95cd9e0c71e9788e7161c280ff89d56cc181d2a7e05c3841d2e251527e050a0bd0b8f302a29ef1cd35d208285ed31fe0b0dd05b5c25505bbf3c488528fdb2fbc2a7d4a0260547800bc7d162d21cb1313aff3039a84d0cb3321278fb56e8f0495bdd20c8ef5d15b9f391d8a01cdaf62b7e75fcb01e9ca0558bcfd41067697540e491d4ca947b969b049f1aa82510e0979d8373dff4abe4ceff72733ce3c0c25e64f270aaa12a626398352ce91e1cdc9df7b04010f303d3f94afcb705d0e1c461f192996c832c735f47c73f8819b649717f4fadcd371261606c466b8cf136e94dec42602337d91e631d2b5fd88b5d4211c2755d7709fee5e5d03ded6495a80daf185b6c4dbd103c094d12024ff57ba67165a811c2881b7436ceb762cda88ef7615514d91e1e096d9ac3e058bc7dd35727f2c3a30c28c896cfa0c11dbf18f78571e5eb1a19871ff538220f0b5ea0793d288975de5426d089c14c12e4894b070cd1899cd3cab9ff2d27c9ee4838744599b8b54c01177f16a7e3e9c61b1083010b30648337308dad968f5aa7e2556c70517d8c3c214d0434297e0934298d33f80534a327c80bd7fc01e4b1f8786e77a96f6342e15bea74f036e5e4e2be7079c5fc91a1384287f965f388e27d436fd457360cf0dc895cf210f14b26b30e08c93f262dc52418fe52ac1eac0877d3099b4a252c2a28e1ebf1b94a1783e9620438a6d85fab8a9aa92a7894bf1a7aff9d9c448f22e357229dd3ff1122859c7f085af815a8b15ff3927d42dd3fa5b32bfb7af7646c1d34e77847a6a8c54cb9d9e7e0299973cb24fc24d2e8bfddfc4bff5d0c3d751f5457028c4a43dde185ec1c277114f37a24dc129c7130cf88266063864b3dcb9b304cea9a62da5d16e22c90bad7944e4d5ad9c9cf4b9d254db6e5ad5b1c08a188f99b43f17ad5297469631b32a1c4995376c5984a3ae49ce05437415202343eb8e12727a0e3511bb808ab612e4063ababc417f46bf46a6007239cc9cfb5e1347dbf748876d8144e183ee3fe7bcab4edbc527d3bb071a23cb412c7c898062f9e361b2e2a1ae888c8cf7e09caff68ac1f399d5bf32c1392d28bc51aa33566476bbcd97ee635417e23b723f6f3740725090d839d3914bf79089c0f3e2d8ef4e3ccebfa677810fffcc03062a9c6bb18d9d41ad4889b0c97ff6f2fd7835b8459543c6386cbeddcfcc2aa21b36dd8f726b0e305d37bcf7154a8b7f89aa7b2e938f6fb22249b131850ab0d0d6c1b7e960e61716f1c541d69560456d2f3a382b2c3ed2cba529670b85f0e853865a01dfc39a7e5485eac8c849d37ddd844501bd00ea033940c681489b4ec8b033eb8b4a6d1504d0faa060dac8da60dcdbef771b7ede00805c8594f6bb41659a493f506e791a8a5bc37b1ed82d4aafdf96546c9398d084ad2a411514a2bc8e0a324ca0383bef6f56fb951042ff53ea7d56f5debc8c83a208d0ed345ce09c283d3966ccd70fe8cfa25ee0c4155bee2fe6ebc7c3528441a7e8a6e0c1e198476b6ee0f23a8c499b5290328b3084d5528c29a70e1d273a5f889ed923f0ca8cedc2ee0351e6d054c4b077dbfbc844c47d05ee9162abf5e77dc3f2fe2d25f454be89347609abd92736074533eb7ecdc73b0e70bd2e88c990eabe140610ad12af6198575b0fa2afd627223230c83bac601c54aa3c961f91ca5927d9487c2c2f81325154b5571aa0d43e667ba715514a2b16024b761c2be176adc42b53ee823fedbec222d941bbf79fd74b68a164fcf7c99d30a52155427c8173bfddbf1332a7013bcf5776c236b7b68f4e81a06502a5f10e9cd21083577c1c8fc2e3f6d455a221582ca5d46b319a556b782caacc2b536c350a0b1801628a21cf40f8e95b49984e5cf2f10a0b7a01f128531428b691b190eb788af9c775400b8b96bab89a12fe3b63d95808e9b8ce925c690a9fea8e5cc535d5dd78167e925d5a3c6a546ee9affc57d701c24f7d1b291db0c99f010707642dc6e55239e25d8dfd897b1545f05c88f77f3c8fa30b7a8c1964292a01437b3b5303e6816e230b526bebd8dee399f799ed36d11fbf97cbb99dcebc541b0feef16f365f99123c16a422d6f5dd24402d27adbc7569148719bd6e0c55533c84a858af423674c8f066f714ad097e0885f8093258525e2ba83179f9fc001a7cebcc12597141647e795196608e86986a66e3f762fbd97367e92762fb8f63c7f1d111c4544a6d253ec3288d1e34eb689dc06579b0136cb0885ca4bf380004faca202d786112fb7fe538d69a35ff86278a1284b40bcbfc5b71f74a93ec568a45c01b22d827922866196314b30568159275306111bd4ca57af3bc37201001a909115f81c2de8018de797794aaab0c01f1b5dc1a9ca561c7cf89a684c8b4604102b489441c04b7ad53f6c222fbde4b12dca802f4391f17705b223cbaf5bad9e4849878cac430d17a07ab0b5465215676d6e6b30ae9e566f9c199b51fc2dfda8230dd629a2fdfc348f96831b7ef24c34b2582a908843fd23879616123d050130db468d24962f8a5affc028e7f5d6669809ae2bee4ec9c80f3ae21b135cb40607edd61b0b9beb1b22c1d3cf3730438fbb726725918a90fb0799c1a0d8eaa9004c933c4eab51300b123b50763c51234f8f4a17db42524c1b55c94e8801a5fb78e8657271d5bd42e0d873ff57f854bfe5cbfa1cb4ce042c58f2fe117e525edf06c7d0bdc3e61a6d816bcac908ad2b63861e8f3bdcc4f75abb0371e8496a11866d149015b391f2d08344a96b57a47960ae0f1899b636c86f09f99248f5c42083b5684b7697c98db7b48c38b5e9ac8508c5768a177084dd0508ddb04374dc220bf5a0adc80a567eb6443e7f5746004a405b65666225538c1ab70b3394ebce3a03ee37ee5c0612c1ab7f5356a8d4f051feca6ad1d7e1967cfd028fcf27fe4433ca34b5062b1239e812eff9e2e6fe767abb538b1e52318c419d66ea56e1aa30347fc5affc8cb193efb843f5c9367161ed1c8868e6410c35b9f0501ff339b220b1c073c893719522ce6b63dda3ca6f0c5ff83d6f1a5ffba20fc4be8ab196685574cd78f78baa4effc0ab380bbc4b7f86842887519a53cb1928029d046bab12b4cd1d33b514a866c20f4be612205578cc3dec099353d324f9a80f1464b04edf4956fe59b19e4957b4a01ae798970ab162a013cf5d897fdc892e3644b285788fd834c530314927ea0fb5043b1a1586e7392c1f44aa19bab8c17e540cdcd40714ad5025535f725903a720038bcf10b9224fd5f5ad47c1fd8ee0155816aa4aa196419f55652225d805d5fc581cb93724dae6aa9b7dcb45b30dfcc48b86617078c41d92611a5e35817e8b3d69e834af42b238e7b9cc5a581671c7a7b5902b38dc02be36f2c9e392efbd6c52c67a0d70e44d81cd47d55a6710842d142d429b178dbdab210c3beb530e70ebcd24c41cda1c9b7afd178025f3bd1afdf14ab075ed709e4421b864e015e5e5dd8afd0b8ff4b6282cfe81183683b843b19f677ac37f7bae306743671cc15e254b77e8ceac30843868c76cddc6a8d355b9b779caf85b7d627553e8c505caf1eab55babb4c599862e712afc002450720b7194100410397cc0b960088e1640f3d4467488688670eddaf5ef870a5cd0dcc6495a31068b05db85cdbfff179324b1fcdceb2d23d2229ed99417b5f1ecb8c23c36b095131a671f9231304c06c7ea8567cc95235c127eb4af8205e287d90fd339d33f6f2f9a552000db20fdc7cfa92d07e878622a2bc1f5a48c4b0012d77f51bbc60d0bded122a601ab5426d7a4ac830fc8334c0764bfcd474eb746bc40df65639cacce7037e99e3ab12256a1ddff9f0deb1eb37def188103fe50838db240d65f565ea2bccc074a625e7eec2d46c4406fbd50fe2d13730fcba1bdbcd3e440de6a9360564266242878b7de865a347d114cf731c4ca768aa08c37a78b233c91713d7debf91019dc6970554f07a3e0502bd8a8614282b0de42799173edccdecf0232c6c71bd76df1f561d66cb4b020c285ff725efb999a30f8ea71ede140e48766348f3bdb9faea5e329c8a49eb6100efe4cb889026404c5cb2835734e783e1a1a6677dea8e45d18313dea445a9a158d762efe2ada6e1c678ddca3a132ffc06005ea20ea6e1359af4a1c9360f5fbe8789f0bb26e71b52e00ce0f331da4c11dda33a71d30a09fd9b97f2b73f555d0d84fbea54849369b0c452fa6197e0580ad7b2a5ad8c5d1b37142ad2cf41dc0ed7b188ba0105e5b9562871bccbdeb48bf65e7e6eb3270c817c6757079f7a2d23f75018131fd2b80280300a34074b3c9549c1f8f6cbf4edd5dc16ee858f1d2f3897f974fa05f3e724990723341ff275809daefd4d5471189c818ea079b3f8d9fa1e6fd1a3500da17fe8b7b5e904914b95574d6faed0b9125df05ea027eaa1fb56eda28539364120f4178efe02f469faa19c7ac448eee20b208c0180f21915217d2740de619a0cf98db15cc19d73ec705413b0a9960a22f1cdb611d786da29a025c7f267ae4f0e99926e356b2aea12f31091c872161f70663791ace78720eeb10278f3946def033d36b2943d3d474d37f929ec1406911320d297aeff35c843acbd5f3b1003e8a7a9c75248ad9191addd0c463473f9681207099acb12b4e2e3ab3da992627da5649d44610b888dfb57cab497acc1be6c89b0ceb7d445f6ec9360f694ea125c59433d34780addf1eab31dd9a0b159e453f5bb3dc67f62cb5c59355c2c4ab5839a98bae833d188813c1d9fc5c5e012959436164b69ef43d2dbd6718ab162b04fe5e69a7f5bd20265fbe2d2134792b82464f783f1a128218ef57d5ee21b1061d03fbf8170d2b94f9eb50ba5b9c600f440321f7a5291bd21038fa3aa46afddbc266a989db5ae337f7d087e1f7bd9662f6d1645302609789a103196b7216cf9fe76295d723bf6905fc36cc8aff6cf8178ba604a16a4ac55f182b3bffa6ef830249a3816f2ccf16cf5599b5e0475137ecbb6fa7f67eb47072154c913c0028b2f155052b3d2f84a3969f9f2d4783fddacd68bd43e047f6081d50158ce2f092b63487485928bd257cafa91713a521e495cbd388469e2b53abeb45d9baa7aeaed46a433ff6688763ba67f86f0eb5accdcddc0d41aca62b41a54a72055d201724d2eb308b763b28cc3678ab25f77319aa21f8e4d6d8143be87ea7643d51e55fe3315fce492ad7dea919b355758064dda2ddaad7fedb50de4e6f8c8191354a19d13a99c547939a65039f3f98b09f09fb974629767d5392cb022b42782a6ffdebd49354880a457950ff58f4fd8d41a2f18bffcd22fa484f0dee44a6e7d904a9747e4d7afefc01d910dc09b2fdd093b9e1e494dae4f632b007b760c9867112af6f8e2b8263da1bb1a023aa1a51529aeb7dcbca09e97cfbd04ed2ed884806d0d06e337c3f1e967f2d7021cd769fbfa003b626915c7356b329deb947f05f4494c739953881b7d139689f033c8e4c6760a967af4df7917fc0b7e2707890e615f77d6ec2bae6a1baad9c29a988634c3410da4020bea0adc5e64bc3c69066d46ebe65b78f2f413e304a0d9a662157b85f3cdbf344ec39cb21c60c1b17891d10c8115140753d55a17a8e9b86920590cb3369db0ca84c2c17fa2de838e1b2e9bc19a9eb8615d6b8b6da3842d428ae581738d54cc144faab98cd0369e5d43e42a27846c80188600cc43f73dea870ad2e2a6d4658a926df8ba35c8a73846ae6b915c4d91f16ae65a553b2dc84c542c761fb367ba4a85fa2c574e9f9f03ead4774ecc94eddd062dffb8a4f1338b45844cbb3cda296f8e98b1cd96df8860fa46f4aa9bf09ec67077043ef3bda7810e37bec0769812167ff0bc304dd089672ef12ee7de6a7c3f2205bc10cddaabe26381f503d2d2e8c7a9d7f12a705302b0ce656d6cd4d879f7cab055cb1bc16726663ce993f5372146c8b0e7747837a4fdae25b1a4b54c3fd4abb00afc462c2a5529d85a608354660313052a43c1b94434e473e5584cd78c5a757ba05923077e72533a8644a5990f8cbbb4e1f0785908bf6b271a10bf5c25832c26b3c614cf44c9a603fedb9a36bc33bacf26db3ad75bd67a7c28799e04e623699bb8c3fab48ecea0fd3b678b50a0d9f456288b5ce214f5fc54ad015c88491d1d94347d0dd711dc5b51354228f2b918500ce89b3c1885afd3cdb7ad7fb0681d1d3c0d7eef67d71708c3e66f25897bd6ba5493eec37c9613d09f665773469e9027c9c85a39947fff81bacc141a61021fbe5a9b699794d464e3901828a36c82126a5e9cba81c92f6af28346443d8647796ee1aadcbad3b4391e495f244198759ce54e58f98d9b8ed0500226b2877bb2ed85c4379586b655223580e39a19934e063842318aa9f35445ee141e455ca53f7840739cb2dc8326581ab7cdd706051e2e3a743cf4ccbb655aaf57d6fb384e461a4ddd6b2e4d9e9a4e6b67201099e1caf22d6bc2aaa8c7c7c51d87ed90be34547cac90e772f8b90b363991e1abb423e8407c141fe9f4d0cc7c5a7334f9b3a5dd1280bec9ca3656387a93229a596ed10a2122a3816d93d93fbbf67881c6f009437cf0451612ec2329302c486efb5f5b872a0b921b4fba3f8cecadb47269c5ad8558b83d4f6f0a38616003bc1a91145a0aafcd3035795611d4d5a1ca25517ff3b156c2cad551fc762a0ff456e49128eb238e19a52fd1b335844b313fe3615990ce26d0b029cb9e631c2a69277c44aa2918df5b0c21a5a2565f2335ed1fd3bde85914bc1964cc200b363e26c4e40d392803a2c5e8816452893637da3583a40145399e2febaaa9c0fa33fd73c6bca5bb20cfac3dfbecbdf745a2f37f12786b0d9fa08626438165bf0465c4a9656bd984f5e1a9162db6ea0d9f5daba5f584cc711610f81fa2bdb9ab1b4cb9b0699bd95fde2365f3cc61bfbd3bdd0a3b9e888ae3fcafbe184ef79aec6db94d995fcdb48695aef6d4a4054fd41b561773db411f9535f3e2372cbf0e3e790d02e976e7d02c074d71e29aad5341c747c750021cf25d9bfde9e10efd0df3a6db8e7bdde1ca2d45b4bd9d87200ea3ceb2aa3400f3c4a30a292ea1acd4d018875de36e82870c3858f2772501812706baaeddef84d69208c6a72f2aa3d5730357230c1d72b30fbe4c113cf47c5918da78b85a9fadfaf012e3df0b7252125a4172cef8b2a3eabb7f19c1241d049e362da3d6d44f33ef1c64ffda733fcdffe40f74a54ad60686f50a17685cec7e55e49a7b9d6ebe48ccbbfa19af42eb49d805ec985b9aa24107fd0bfc8eb8034ce40e893ae10f4f4885be75b10a9ed4b9f4b42385f2fad3c5cd670ec74ba4043b8c72e1e8b719a79637af1fa7ce6647f1d85fab0ea9f14cb6cb299395b6a5cd1590eb041e4a57bf1bfbfa50fe33984934c3d7167abb5dfd4d97be039dda4b445fc00ff06cecff1beb4cd92b7b5adc049d7c2f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
