<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b90f7b8ee14d14d8caa644689455f301fc8dc21197f55a68e6e195e082104954a14139b9c021e6c478f89a0b4c8aacc5a6fc3e401bdf50ff52aa3a215fa62a6d7b6fe34b99e9afe5ac8a172ad8cbdaeb3b3ee70e7e34494297d2161470d0df18d26013b6e8cc9f5617eb4478527a9cea4f03e298aeec831f84e04f0e15ff8e7d2442d785806f071a48f92417c6ce0501c22fa6337e4c6c40fae3679122622364f97ee7a8288e2b1f43cf5831a4d74b107a563e2b4593f8cf82785700b99d92219ac7f6b585307205ab968dc12f1dd2577331be1abec8a4b07de6fdced0489ca2de90ff12352e1a2b4e995b5a82ba3a65e414d93faf692eb8b270f93b81481466f181e6af65b2e2ac3be5e2bd884bf39f1b88ce7a63a26d2b51c45f5a924b61fbcd9c3393ff1b1da33ddcc1642927527d4f4e226b8d3df7e4aae4597e238157e0a7665a523fcb81fbd5a324ec19c3791d9c7f73968d40fa75331a5a77889c875b61c495777e15107df740fc4d872aa99e1ca1e8b11ae2aa90000768b0cf43d856848490dbbeebdad4a64d930a74c1aa3bd2d6feb950a13a923169bf9aa2531e9a873ee70ff3b5865b39ad3d4209daca0bb576ae863ca1bca1e94132a6bbca6366eb36187e3260bb92f23e5498bd4e93e59af4250834ea6b2341c0b069e8c46213c71c2845c55c30d91c28bfe6a0a334fac2ace169e272e020883a2e0004d16d70300a0483ae085867269bf9434110fea7449dc5fb0305ff8f27c06703a9dd2343d56334b021a1dfde6d778126ca145438bd7dcaa2921e60fa0cad138751dffefffbcdb73c39002b03af5ec649ac559937d47e48bacd19d79c06108513ff437a99994f2e2ccfbd8e30319c83a301f55faaec7a1c8c413fb2445cc5935f5f8d44bf02a12f3ec4a5b5d959405c1b6a33b14d311cbeb33c426df3593f5f5a6de5b3095e68f8a25fda888769dc1f3b371f6ef6383ab5720fae639a7395bce4b2c0a5bd963111d6336e88c3e42b530f65d18e44bdd0069dc324e94e535c41d91553cfb28fe27c0a528c69a6b83f911dd8a7fbc0d31bcd307060e43d0cef58fb9c3de4c8053e06fc6c1073520599931b289031aec3802c748205db50d0704d27d7ae55b236b1f580d6ade63708b1d1559f1c08412e14dcea12663e32631f470160a18027e7616957a19089d80cfaadcfb47e0ebdbeda030f98cc2d263066b73acf222fa7c20e35dfd74f65d3932cafde4e8f81e97df3e54e4a4a92bff6bda75fd7b4dada27b8592bce05909ea5d941fa2d30989b11197513478cfdf69ff2d92d1b6b271bce78d56c66ef22a8e2de39e1998306afeb8f7e0a056b0c7148c44e9a62c71d2175cf47f1c4df57b5bea309a63e0a6b3e682e8bd88fdde49b086d9247ea1994363a87aae67a13a7749cc83d33d70d50f914e529ff800b3c38e5676b93a39b7463df175c7bc34dfddeddbf96c132d63a9a66d451ea8156750f788fb503e6079fc2f13368e80b9d5d7696ba4a6be07b8557ac7ad5085739d0e6e895c7d3e417eba4a4ef34c29c588c4bf5929a92375e88c72d8e469102c487f175209c76a05142f385bcbf6b850f55de89166806451220eec64dd46e8a399b12cb46bd79dc28014cd57854876e7450ea83c89bd2e326b57359225b2aeb55c7e2fd74bbaa17c42bda79733f41f1ff0857a4f1ee18ef50cdf91d7a08c5db92092a417c8578945b24141cbe572fcd96217627b30e1e42458cfa920828825312e7212f003ab353571cb53e1660e94105297e5f522186109714c448b9a670a117ad53ca37e1c1ce972583d7f1ff92c455766564c22617ee3687b68afb7260b9c2006f51511e0a11c15a8aea3b4b54f9f4bf531c1cd9698881fb22556d58640a653127a923c4220e030725a1be215750f4cec38b1c500cd27f7176453cb9361a0211b7c705ea055cc0d1cfe623b1a20f49c1a9f418967a537cb6981c6a7f7afb5e8f6b2868e1e5e3365bc1d9371d3944c32e5b1efa741b89ca10c3b50a889515b4335234777a98272e4af54ed15a82c23a71f39e11406b2969025698c56696131e35dabc983d146234379ced1d6e62381aeaf0f2f795ca2425d9e960d597c0c7fd73611ad5dccd4e0022968e8078b6b12fb32c1bb50bf96fabbcd2cf127cefdfbad5e4714f1c3dc05bf564257c132ae6bb9a410d8710c71e10d32a8fb414eab6393f7fb02372a268ed919845ef086b80dccf35109b520002f2c3a65c08e29bff59a23ab1e6c3e9b4972455f1444e9bd68d3bf9511ab56f4229f1a713c9ce3665f40751de368cc160c07e3f6fd714bc37e4441473c77acf22c73fbd24bab85ec6250a98dd22975c324bd727ecc6272dd228ab30f9feda703b53fdb6258727d920e995765e2446cd7da6a53cec24eec1df928d77c97af89941c73fb716b6513e23f13b2f772e33f1c77efe55ed10d9614093caddc6afc06edc130bb2d5778510f179cd8313ca8197de584988da9043ef4977104aa9ddcbbdaf48eddb6316dfe60231d3b505e74fa61f9a6a0b1e26d0ebe6cc93b45b3148693786a2a2ed9f200f52a83bca0c98e618c9c8757cc0f64076243d1d229e2aede5b6f57ff418cdabd804afa65c95aa52bd0d1ed838f44f17f526a1475e09c829c613875df36dd9b57784d560b791a1f232e9957c18f02044403cdd3729b809444084f211355f48bc2c46d615bcd8a37954d69a237de5cd16cf9a5658132fc8815f0d8e9c2dcbb221060a8b7dc4d6bb47b23b07c1944d2556e4893c1ea3d498fca6e77dc6c6decdb5ce84b1d219e5a4fd4ce0a47be9dce2fcd3a49d1f1d9f71006665e018af4aa18f127dd00aabd59e7151323e4c6c6cab5d6582241f53c68f9d1d25bd7ebd3774ce4a4f16e9130778397b30316d9a0a27a9fb6a09941e6808f9022715f6c26877223b1039013e3d29e0ae5e8253524cebe053f2e53d922cf40d18a0bc43cda4d04a51251c02a83e8d2fe338a0c23de1d9df12f76106af3026e4f90bff3448a0850de72a0a8f619b6463644ff1e08b5e77c6d2fcdad6a555eadda1db5b11b6b55e91f51cb3743d3b2fca4fbc6ba17f0b98f311a1d614ea6518ccb3d0b86406539972d2e8875cecf80ea4b5ba041d0efd6383b02742834c6f5c19c5d6b67079de52ce2bdd4c57978a802fba5ed878a987bed0e26600812ce9fafa10921a86416e59f063002ff3db4e9ccc6786ba9f94322b6f99e143e94123bf70293e0dbf2ed348abc1f74495f7db6ed754b6d654d9f5745ac84bcce765482a522507e4a44625250c88dd235d4399af5cb0a0b672dc3249372d1e1e42127623c22adb6e57f0bc5d1f386a7fa8f75f97ae2520344fa5a7a9572fbf354c4d979897a27d37dda27c9fd3ca900b39fda0561d1528b9da5084b587ceba5b7cb529aa49baa1e58411d756a14199756a13ccf969cc3dc8555e674730c1a5a57587d37a59f9e8902a8b91a6f5995affdbb8536138faf6cc2f8312d9a1274dfec5de63ecc86c77b7184e4d91d466ec0c1545036340df69f508fbe4c5be4f744601cf96298859cde48be62b49f87ee0d609c5495321c6fff13ed696c3da31bdc2b6c68966d08e688e85cae569c3115a3673dc353e17db53410cfaade8e204f9f655445e2625229de0f5e8ee9876967ce13278c184b68a07ec21abeb2fe345b88454e1dd7d577a8fd99e6b14b1e31e6f215f1c42cb98f50af6f3a5e0d1d3eae2d92c6ba4ea4a5f5aa187271b0a963442fca1173bdc8483bc976d7601d1e8c537241b939f469bc0bf4f7404192a738f8b489d6e910d113579c6114f3ae5aed1dd017d616d92ed327cf56d557d106a529e41adcb6191ce4bb1a54622d203eb557a311020d334a72999e5d0fb10edd9bcb73b41794b3fc992b385c4aaea170349cc7b5b263f4354acd654e5f2859d05c1a7824fb42090c2c52ddadd1d65af9a2f7cb2c364511f2f8855b4b646ed7f2e68fc978c58a45e3ee3db3615ad632b534f9b4804a1d2c84cbf1b89552e65bb57b520dbfed1e729309b408e5f426b3d72e0d4d4f1aa1916f91ed32ebaff80b90e9960698ca605c57bc1c39b5b8609e575d7e2a010938d5b28fa08fd59b4d06882adc6e4d4ad93ae2ed557eedfa3483ffe56646f64c572fc586e8f18b927c4970eb5746f9d11c52ec2d45089691e01a4e0b3e49aa336f88b42c597fd6bfdac7e24795574378a4d8d8c80c5b4ae69fdf16a9ba88cdb09f61614b1d96bec8ff32b534c6447200ff6184d3310427b58e837275764d841cf17d89a8b74db22a83126109e03c8e525d9f0f0e0fe2277ee9b46f1a64c41e7d37379b70e07b5aeeefc6e9ddaf1d66aa3401a835fbe53bb54887dd7e35554d888dfda2673fa2899ac600519bec664ac30b5a10877a814afb5539d5e2022d51f983704daa5e3bb01538c5a7534ae959a71452556873b16ac2c480fc9505573624e984a0f24d5dba1c50340c1ee312c9e09ecd819bd14554fe0ffebb3b36a86f1754ef81527d4442cd088066ab111c7d5641215b89c9c4f885d777016daed2097cf24f55ff2cf839f20aa8843f9076cfc6f8a9793e56a6e1a67889f160bf57598b1742d9c288e438b80bf50b630f5a75ce4fab2675bfd776c200b1e5a8847ba11cc3d9cac6c3c322577dd91637b827d93b4009761b005505329c496fa8938430d9e1f35f9d7c13874f44b68369b4ba83464450fddc0c5280d1b97f6cdaa27e6c4cd43d5dd5c6d8a10e48e1bc22abde4a99463d7744dd8bfcfa0bbb84cd399846b091cfe90be9b94b942619f61b6c90388ce41c625fb80433c9969084462e71fcb69e323490ac429e6667ffad495c5c463c7b8993b0fe40d4e67a3e46aab78ab1e556dcbf73f407ce69414f7c2a9d1f17decb3e1a4782e78f70c81da6330951fad351b473b811e5130fcd8094c6fa11985879634c62f146fbaf4d56b91120c249b8f0f52d26aece66395d7db2d77994234bf4602a10565bfae2d48f895733cbc024aa76f032f5fe291b52319acc63b212e87c20c6a6591f9ec0637e958685ef2652a489b9e182b9ee4c5225a03eaeb98b5dba0d7c82aa8099e62453ddc3a960408ac0f0b8fec569f1c2b5d836c9fadd65764339de0ec1b7defe7bbe6aa3a6b2e0fdd006155ff8cfe8343b912e2e0e0e2292d3f5680be288116fbf993d47facebcf222c76bdaf75cc14e4c9d0e1d2e281a240d22e76635dc302d5139da66ecac7b4e79898ada682e09f977af51faace6e6363d517e969406d2a96d6c22186327454d69f6f856d13cc4f4cf59d7bb357773f09022d0461a27509442317f9e97a42d971ccd21d692b9c9368728cd47cacf8a2d35872617b06cb96b043a0b065f006eaca1a593a3e1ccee6288bbd93a6d1c45fdce36823ee443aa5962dfffa2a715e4488f1189aed4fa41b121ba2f7ef66e0d63db135a80745ba338fa315ebca034be43a52aab270515c7c44f3b7ef82e784706d28973bef6774cf61951dfaf21d7dafb6212537586b554718a50ce209a38bd8f71f292c8bac57303faa39602fc3b9472be9ccfc1c953c62c5329a22749e89d0c95f32a570905ff77ed0244aba4dcd61647168dbdd2d29fdee0611605043c0c48c6a239dc38b3fbe63f307639a55872f4c1f5a60ac77f0f74dc5a7536bca28447f8ae49aaacae6f5958c3ef904c48fae90adc23ed961878c0cbf94126b65d76e7ad8e7fb720ade7657a10874f495bd71124c14e69fed63e3d5f1e98c9d95659800b6a5c00f3bb435cd3b1f3e12f6e1b7b3ccc73a63f1e7af7bcb7cce25235785e28467a5f61f2f7383da9fddf6a9474702e4b890eb99f9802f200ecf7de14c0a6d869364513422ed90c613d5141bea9cd00f63ed280cdb04fa9dec66b1c6ff9d72f661fa04bef59ede27936ab030d801a91bc577d8620c0e8c26e210f186830a66b4331980d2ef0a09a8dfa690409d99bb5e221e8e0e2176604a329d947ff1892e0560206fdb5c10955f9195af34cc555e8034ead291b9437ba41c989222df46dcee3fbd611e941449b18aa02212717aa46fb54bc7335f31bef9884cd45a1d391206f4f0ea1c7c88c1e3598923338006b3675ecaf5e548aa6181bf91be30daef7e18d25497d138ba374352aa7fb195d46de113581aba35973865d96e15412bf45bca8e6edf4c526c84390283d0f66b2c6381b8740ff2ae98debc1c67fee25afb0a34f84dd88a0ae82d0d0f4d2f07101c845f682510931cdecd43565ed9d101dc768d83f2f3f40d0c9e90c0cb951777d28d2cf6a95b6bbe3974a4046e92809e2667de2c335e969e41947fe7a001cd8b6d5ee354df36cda9bc8d9d5d023c6f64e9d8a640d34143d5482376a21a789bb9c31c2ca5792f792c0cd297b06d6186a6774a9ba455d878142594817db79d0fff209b1ec74370178879b3d081016619b18080331021692b7e7b4411a2f131005d3a6913ec4ab729e8b5f52eb692f6264e2f135e43d4e6c80cbbb646cbda45e70ae840feb26058d26812a4410a6377dff62f37653164f7df20bc737edd292b662bea18f63c1cf151ec88e60609eb0ce96b2bbd6f836497deb3d49d8076676995ce9f50bb6312dcbb3843cdfa5ec4272e9299e42281ddfc9119f4ec4f8613a97ec82b5c8e916d91953edb5f08509d6d918a7f3615fb15c54405f68193c85881a413d318e36d55fbb800f94fa3e80adf45f0a5ea575fc61cd195f68fe42ad9533812445a701d4e980a68f5e7c7a19a82f88e7901f40e70054012f62a5236ebba137d1055b843c9d6bdad0abdd6fdbc36fc3a51de5a107d5c48eacd58f38a4e3e49c5b7c16652d264a077d30de0c39da00a48e0cfb97422386796b172ce244773783050eb86d22502fe87c105b3d84c37b343a95690e600b4112fd7ca9ffdd7ebc454e65b55d8da6f5c641025fb6b5173c8ec7cd36947171cecf2e7b2e3a3d74221c895bdd4d5c5c36129c0214eac2d74d62c7c0f28baa36c73b82c67c65aa8ce08a1e7d8b6d66a7d4ee93ab9bfc54c6e792fbca204c7b76762e9beb3da4ef2aab76563bf12044b5cb94d8360cae603386771582bb3f3ecde63c2f0fa9d36d061d5abbebc95e79cf93f8c131b35c81d9e1d4281073499184ad24096b6523786abd30bb426b9e1fb44f763f09ab1d2d058825fdb8194d9bd460f6cf6ad2b3c17a85e99c4ab1f7732bdeb644d1f5a2072ef4ecca39f17fba319bfcb84363644de2999de47350c453660e01645169fdc3e2867b2dc213ddb51f4bbecd388751157d1baefd9692d636df0a76d05d6b2af33523b061800cf695e60631aa413b229c1575987d352d89d6c8e48aef1ef4d577dd212cb43f2a71542b8c1c438123d3f3deab9c1c528a452d5527e695a8a4c87645142d4d22ead03eca11820ae4c3dcbd8a70a1222882fb86fec26babf14f221ccd122a67705dc1846a1032f07934af1ec8596eb795cb2fbc8f67b7132d895ae323a5e2c6a474ef0fb57149dc8679189b9faaf6afb4b8201ce49a0d893f8bdabd3ba413c0abea324d89baf8a25c83ee07bbc644c0b00f6e6066594a4c5b0533e645c7d855d53d2b51b1bd18c2e8768091ab945410d99a7f42d7676e2f09af2dfaa432c7c7e83b8846bd5cb1af5152c36bd88536bc6a65fd4bcbe13567eee2decbdaf6381c19d91bbd318c3b110e523f0f01488ea1c4388b5722c7470c5c0daa1167d227a2373f04799288421fdf0217fc717c8f8c55fa662a02d3ce4911aca9d5a0fa9267c541c265b5456361f726b3b433341c9ecd6c9fd72dfd50d8083a57ddb3020b16a296a33ca5542c648a698d9b9b1454dd95711347ab6b30f5f668955e68f2abc8890c86893a017e20d23423241e0728e0ceb62bae992d36288a7bc64546a9ce853da3ec5e391793266c58b2d55b145657d2b21cd2ff26d513e303a8b235c1bb7f3e07cbf4838e541508e35149d70103cb41876db340e02847b82ddb1c0e543c9aa9ff20825c9d7a5cfe2e8b07aa67de656685430007534c7c27947219c3af79789492e8e626af523decfcd6177582936231dd4597363ae9beeed74422addd55c236a5372f6d116cbbbf12e719c6d2c5744e735e0c368986961e8935bbcd65b1cbcd76dfc2ac9d9d96cbe8e2a1c195a373231db50d088f1ff73c11085727b037df1d7fea3b20be9c7ee80236cdcd0ec271a32f4bcc74d018484a7ca405dd3ff572c6da56b6664f3482db6f2659f76051c38d38cf39d5ba805a7bb78f376503d5af18778929ff93ffeb9309d529ff31b7da5721e0515154df6ba9d8961e174e3df98fac2b1ea59585f9434443e8568800fe203a5bfcdc779da12d5486dafdfd21296293bf69e724a3ee9d4e065ade525c5eb14a4916eb1f68a84c45447bd3b58ae0dded935b1bebe5c773ce2debfd45bda57ca2642a850527b947f3964cdc02cfec75829c1458db89d0ad5d54959acfd04f2b32caca574e05efc33477ec342a6db31e80b334dd36d5f41e8ae3e6a2b410bb291ae4e6fb22cfcf83cccadcc27d302a34978bfbf175f22e46896f46bed23dee7409feb63259bdb6801bf9c1230882f7dfe97439bacb7ead8697f043fd64cc7d275ac2dd74aa39b25c0df0a0662aec5b49e030012ecb0e928ba360816b57199e405c57ee55af39b9ec65146d4a6b8318eaeb8a42c2851e7478711351be60ff577488ec867c59eb0b2865c4d379b2c399cb48eb5ac965b9b1afebe940e87d899b8d711e1332ef2edcb6048b9e636e6c6a9aae19fc15c1cea045efbdf41a66bd281d31dbf0f39261d37e0e2cbca51a46a4d54a6313a83a48536ea9dbb41fea52ad8bc05d14eb0890c36c09426f152dd01b113f366795d6940ce59df639f606e049b4f4cb562fec4fd9079decd03f28e57dc1df17aa53e2d1686414eeb0f18d8df2898b4f79f9745bb20cab89516ba0dcfd02e215dd9e3a39ab2f3c90ffaa0fe6d0dbb1e9b4dfff4935c33512ed4f1c33c48d8f276d59a71c7c5d5ee9f89795afca918146883757d89be7e8fe20f85f08867eb0d15b6f278cb188a8b2b146e4a26035a9501de0a8fd4bb45b719353c1ab467717b6b9a1fa67b33127062126c5f64da700ec04ab15671c3e8b83e33fa91b8d9edb71bd3af1e50f7f7314b96f2131815d8369d42896b90f515297c7af340e169c9e0e972d1cfadf10a1af2cd1f0e717b9cd05d00ea6de5277128e409a90fbe0f80ce98eb690538021fcea9d0815f572928a6d5d23d50d04eb71304305ba22d436c659db084a17a80861d46a85960334826f16ff74517cd78e307029f2bb6a1c875e9d4555536eac300b3a74b173e1031b43454ae5d5dc433fb7fea8e693418630fc745da2910ea1c764c8706c7348aec7ce9ef3f05076711a37e3329f6cd96781ed61497ba8cc378392b246d3014f05a902ee0b7790d85aa2e920f3e05bf4da29054e318ecbd13d0242052458db02d1a38c9f4e74beebc165f65af3a56c7757e3bd1bf9bc0fa26823728f377ce8e4f053821f1ed6686973739c27d179ac52fbd963ebcb1641ed43ef88b848e34e3fcac16e369013bda9422fe2a76ad3109beb0cda5913b59399acd664096d813e431e2e15800c2476648817bc47d4aec98a429fc98b282d4c9c08757cf0074407b80b71050d0ae9a8d481e8da3a457b2ebab4402c418840f84be75fa33ab2932ea77af6e4866241f385f39c8668e2bd42d74469521e7dffb48197ee5429df832416c4281e888466dc744e160105ecc6ee1a586b6165e4136e6c597b7a794939731fa3aab6abe528e4f93b3b6ce05062460c5554cf2f265de96b70ddf056bac489e8b9e1dc0218a8085e0c0b3ba932cc3b7bc15ce7b113727a55d28a75ee608576ba9ed36bde3a00d8984c2a971ef1301f6eef7da8f94ec19a413a37706cd924e111f654f4b843fdf4e7d489634bb31197030231c0f262609f37382e60b4cf47c556a9e7cbd6ebf41ed5c437da23ea5752c44f5ea11eb855a6bfc048ea8ac7bb8022a03c8d2c4ab745ae77e508b09fc6a799acc8c14104266a030394da9274e4173b3ec88d6c18a840fed78d95e2599e1a9a4f8e1159a58b20fb86c93386bbf3242df5c7d8374de99eb28eee7b165427c4a3543b6c58097d7180abbeb9445ec43033b004878f475e6168b6cb14b1cfad0e2f99f09ecab6b471176eb492d95c4c7f494ec3d64ff18578bc64199b10cc880bf41473f4761e89ca7f2577196fc4dfaf33dc6cf8a62295d8d6944789df2a65216e560eb2e0e1614c8e2ce55a4b6de9f649db78de0b95f0cb1818753a32323d23891556301cb924d37e4f65bd7128074c30800bd4ff80bcfb8947d41ff2833e453e371f17187eb101b875fd198679916276f1c406dab4041cb3971b99ba7a0cf63478aa0e8ac640604cdefa7691ca1eb170ea04991214b7ab2d44a6b0883c0faabbd45bae59003d1e24b5de6768fe360e8ab7ce8193c9da183bd708b0ea09e2887c8d7db3208ada74a28747e13e448a2111d64e6cfb75ed57fb0bf7f19974047d9460f44a76f0b51dfed671fbf7bdb0df82393c6155d3b7bd4727e850f6c3e45fdd821a0804e7881ef2bbeebe5d7cd53bb6981225784cd705db5860e17096a8cf88b8e275e36e5f937943631ee8ea5bdcb000146fd0021ce54659ad229e3ab992db027e6c09e7fbe544fb7a46dfb2aeb85a9b872d7848cf08c6b4b48f0508b0688be2196f0bfdb9e3d38b29cbb2043acc59bc006783553bcbc95079f54035c3beb6791bfb3c5ad6adcc428753fea4b1fa299fb2abdf2c2e785dffa266505a925e96e664f8b4479b18132111aaabe7d13b5db78c52ee4a068aa859ebe07a85795a1eeb686d4a8c924d6f8c903d5e157fef073e9f45b590aae82389a7803f6874f63a8f33ed434ba6912fb6adb74f040ee6caf45b76384afb16f3a251df45d6d0ee8345e8102a5ed79418bddf543ca7629b7649045332cdf4193a23c24a19d9db5ef62078836a7da7c6f20d131560c2b4e25c70ce2ee444b174e972bf25846561c4f448457a34ddc2a9a4e02877e86c5942774ca686af87a28e4145d4cca2c91a6bded1caab5e3c6e7e572f4c9c92bbfb2cc0d6dd142e41263c9bab01e2ea2c3f28cef1c0c4ba62864e0f4a711708f8a9a9eb197ec9c67d9376fbb16240eadb9938bda33915d3d9a8506915c394b733e3487f7cb405a6a59aaa80e35d19d684ea6a9aea22d31bbdbd25e6af621ed3f62c9fd43e88c412a71475173dfe61a4505a0693b3191b8c7b75bb62775ad6a5c68044ca5b387570e0c942bad733c3aa47b0fd7a2761eae702274e47b39a6215c37ab49d43eeb4cbe99f3deb3328d048eedf9fc339fdf41cd466d70497f6154f4b174724530ff6021f6badda8430386b3836fc391ae8cdb11485f78b0aebd7f009f14696a976f07d5ba000f4ef4467021e55cc0d012b5a5cec84da4b3e8d29df9185abc0a84cefbde06d39d74b8e158a81dfd54a9f676769182e68c32bdf17e9558c30c002443dbbee9ccf38f50b6e56569432619c4a68caf0409c536b4a905703e77ad9134d8321643cc73e562f6a6031f21a553d2a0422fa0056bf0e081ceccf3b12be76ae52880388355b350c4121e507262f6bb43606787180068604c19dd2ed44fc005bb5a0c1e3118ced280810a1a06e29fe8632d7ac526c1271d323acfaa4b8209bf186a7688601b07734d6b850c3a23653c47248bb69c33417130c32405c256ea5af5933fa70cdba9c13c4302dceacd4001de52ab0edd10d19adfff0ff123cd7aa43c426ee97b6a080eb2ba88db3016d2f7a2d771996a74e6732ac8a2ad3046f294b81a66b7c841b2ea6f009f51f63c1441a73a6bfc06f6ef81dc803727c10f54c3901028e39ac1aad956b6509390b32f63ddfbdf7c59384b4dbf148bd6f19212bb36dc576ab6da12ec8af1feeb06ebf5b1faf5306d6f947e8de2597c5bc683fff5892f4e1eacaf294a29bd3d03abb6b541ae0acd35188532abef04344a06d8f6060a90d0079eb32efbc79b05d42414f60d84d8d4a25d41e3971325edbafa53a8b283820d4bd5995b86e2d9b64214d8127dbbe500a73634bfb61cf3816ff940f7300d423a94e239dad8450e46eae631efcbf2c05403b9c538ab7961450686fd8d7fde252586ca338d68ae91c949385ba0b9baa35589d9010963e5de5380636c7e489f57c57671da97d1114c710d8aa64738a390c4eafa68869fe6aab61cb1a1c9793eb55f3bb0ffbf4eb27aa25ce5dafdf55eb0b35170ec0664f240426a9ebe3931ef7f3f0490ec51f451d8a86187ed270afea445fc44ad555a9538ec98b0d305b3c3b9150af6542a9a94af23c3eca14a2fab2789b38baa9379e3afd51073944ad951309494c9052bb0824611be01661dca94e82098225b7e515d57543082eb8b407ab8ab569d94af21f511be3b3acb0ff9b17ddcb742f09330bdfbc01f6d06976ea18edf2137dd87a6740176799f05938ad4dfef9a900a55ad71e5e3d127e2e2ed21ce1ea0bd52486dd1d7d65cfc4cb59bed5079373cbb8ccc389a1ac17f8cb23250f5b85108ad3c06d674a60c96437f1fc3876e53e2cb6180d7edf35d67e64aa156daf06fbcc234dd1cb207ed429b97cb0ab55659a641f64f1e3274a644a73ef61c0f907364db7830142df255447b766dcae0a86c74481dd722c14511ca80675c4589ccc2fde2920d4b163bdaf5acf9a9cdfa0c908c4df2d8359a48ff826fdf082d0ffbc3c66d75071a6d3aace0f0fd15c338d66033dd744f0da8c539fe4d7e659f3d68272398f2f14a139c17afde4e10ab5549852535b86254927d020b4e91da8f6bb693736bb242f09990282e596dae2ca9a8a2b3d68a2f54ce6d3c6a6eac8f2ece4d7cfcbc79c4022e3c174ef91c7439870b05ad4570baef8d6de9fb4589df4ffd2c0a7d80a0644d121f73f76aef331e87fcc3956089cec61fc7cf91dde0fce640c5455077cad487bfc4d9e18b50d9df92021a340a4e3a5ce0af8ecb2439af03a314f0bcd43ad8dd2a3c2859bba28a6236c9eb7bfbcabeabce680833c7e05748d229647033717c78b5944302574a9d11c42e0da30eb46af3e956ef27b9ea80ffdb067381cc5bdfadbe7180cb653ed77b86df44851d46fce314b5a2e5c19314f8090f66984ae62f77fc68d5c0ffc8c452caa009a81f95eea8718941d39c6e5d2a2e7d47499f87167952a3900058768faf63279a2a93be55650c8f8ff106b58f8ca89f035c79e54e53e7bf4f6758de1fbade8221d218ec621c33f503060bf44871603ccd0eb78eefd4eaca79c8a80d12c15577b0d14083af55fb1b237a77ba984417dbc76bd81b7e2a5fddc48d9e016516624756f0bce2e512cab496791bc5165ea83277dcb345da7742e7eef452fb6a64e765b544ea84cef6b3d2ce933c2de9bca8989bdcb949fdc5656f1f59e3d1d7daa31bc614bb4c1783d26c78b641129a0610a5bec95cf0ff814b2a0453284bab016b7b19dfc501d5fce93852d5e7e189be9e8c0d5f327e01dbf501616a79db8ba6e05df9d63e0b1d70b6bc51ce3e2eec326fe590d0607c0b0e535d23f8208a08c06359b82519d5245a36a57936675140a28c47ab4e841a0c65f7e25cba3be1675d5a2a30e0aec17e798156a90cf5d877830a4bfb3fb160a05437457b19feaf49b2a3f99c6ab7888136de3c69027e0428a77a0532e8a8adef76b6d399a336307e64a9b5180939215df072ef93baa0ac9ee3daf8e78a2a041e44f023628d045aa6d73abc37924de5b4ba977e9a31e5357c2a20e345a0a32884652768ad0afcb9d463b1b79888ad1d14696b130c07b007659eb22dd98435e766ad04501240652e892e7d3c0115b50dca3789e747937dfdd7ee0df877affa3e9b0cf424ca40cbd534062808f1b1d19fc9ffc709f251b9bedfa9649daae9e23130fb86b8231b894653779f5f1345185f90a764e4b19601d8d8e1025bdec48931417f40fe0068382c98b55d08a5ff5f487afc50d2598ed2315bc567883707991224001769be1e54091c29b4f666c1f935b79d14b4dd53518542d082baf8cfa9a774680a507446a7b52200c9b4cc3e4166350bd2ea9be16738c0aeb45742c8666dba5706da181dcc5476fff9317e8db2a7d386448db83dee6131d7e98584bdd71dcf048cdd120be6e47b39f87a87b0a46f0fe3795902da780ccce6751f4ef1edfab67b67e71c821a7c9860a6cbb1c1e1758f845c83309d5ad0a56e4898cdd8290101bf566a692fa249b570c459f08a23ad3e55dda1650623cd35ef3d9c574e9fca65eac5bcd1a489599463f2dcb74937d6201c001e7d105db1576f5d462031d23d1a0a548c8ecad4d0a14e5e7a8a9299b0d8f1d39f9701ff4927c6a9180f83051844436c42c0286bcaa9668db92820738b8e32fd2929028b0097fea2b9f7fb8eb29b324186ce397838a5858a15fefbd10cad06b073f7b8fdcc7f91f760c40308565102448e5217f6e1fef69975cbe6a356c85adaf1803861048f184e26e5631f5e1b3fccaf22598ae6cdd2a3405b1bf5f1d6138959cfee13c3ec633e413375597129f17700fbbb20d3ac85164b72c533ac5ca929a7bcd09450ae5c125df97fd4a543b7adbb0eb800cb74a70e8fd24b531c19730f898c3d67f51408742bcd193397f3c8a6114cc52395ad95fb2a7b27f3d8406360be712bff7579bc2cf582608a537ecaa99ef2c24a4c438e22e375805c5d527f14ab3fd62bdbe3187e33a6427cffce396f9bee9c8d6d76ba4c496061a599db6383e76c80cea39b5aa0d628d56808b60f98a207f23e51c169f8fe5e1700d6a75985890add6caee12e2c8e0500e056849f97971d495bcbb1589fb7d5f0926e47941f78370b7a3f829231f4745fdbf04cbc0348fb9b5831ff7bbea082ed769834e4d1bbf90dc9f53318c6e1a2cc285af4ba91baf5928c884327c32cc73a854a21483c61505fd567b3dcbb104a5aaedaaf50739c04e51353a18c3920e9847d1ce58200ca1f296cbacc0cf315d37e03140d5c0585b9c82368da9809178ccc5104a8b79cf946f2a17d26da1942eed35c52e82b7cc91cb037c74ef94d1fd55716289249dbd60226ca934f856d5a96ef8e4cc66cbcb5d7094689548ac3af2f704ae9c4335c085109e334a573a733d6630e3e5f8beeb84db2c4395a408aa49334771eb18411dcf5f76ef15634c88e76186b7df8420e511ebcc03a4b9bbd96a94162640b52184998de6987a1f88bb17dc82376e4495c42fbb9640b31992b8c1aeeee8dd64499828498078454791519ef741886ea3f4ec7dc61f372787582a2ffee77a97052beffdde24a8bf060d5b45348a1d2195e630a64c311a5f02dee0cc9e30f14233356186fe88d6dbf00c6b613e49db806432de841633f8c14a051640eced48fecbdc20d045b823d5dd7858e3e1b71b5eb2c4dadd804ed5082ac5bf278cf6a92610fb98eac5d2bacc0d2bc7eba50e2be6299427a968afc0276059f31e2c3b995443a79719e0ce0df92e7ca2c6f5e8033fe7fae525311056fd989804edfa1148ec199a302e5a0184f38cbf28eb34de3f3863b68a18a7054a201bd10aede3f9f211d0854afb6210a125504470c79d7a935d24b1658a64519ec445b0ce4d708a8221836b01b70164f3f5b9b0a364b91a294c8049d8e777ae43ba35e1bb727af0381c660ce3543b0f3f5ef32c6d2ef976a0693df64c8d73a91d86c6575f565e8f0f1a27e36e36b62548439eec9295a35cd7297e42125eab696cb4c4ffe61955fa623acee52f331a0a5e241b1b4407b435c94f6dffe581d2d96b17c5733c965b9eaaefeb55d692ee6b0a6723d73d6a0d13f9ff61176f3e2fbfc5556fd3ee6ae2739047af9ad0813d96f08efc18cb4e0edeb98a5ed9a599f69efbaa803b89d428608b49471ce8c269b721817e31f080dfc2bcfc59eda874643816d28cab485922fb996f46d47bd41f38f2ae2c18ade6333d03b6f9df69d99280753d5bab9ce1ae992dd1ae39167e6a1da6db2d74d83455c1085a0b2d41b6a687eb4f156b816a1b471efef808eac90cb40a70fccab9f80c360a7a05e69b43c613d224d8a86de754605361b50deea074b3b2c8827ff6a2cdba341f59cab9df8e7aad30351db058f6cf55edf88de29d0d5c8e41d89b6bfc7471f594eb0d9d9660e2f15793e9bcb5f5b66d63d6a1b38c449bb4cfa688331a1b823792a19865380c0e774e593cfeab3c1356b809c9c5353987b2d0edb9deb54d96666d13fb5ee1c43f61b3330f44d91ede0d3ad1f8c2eade087e13f49d9bea98d0e9adb12aed6c6d627e801caf129109a2405e25ecb30b8b09fd163fa9282b71c7aa4beb2d093bb6de51bc9bc927b43eff5dca80c5de3ea0c27ce5b6a24a3a108151b5f2b83e4515de932e38a0319637ec9af07136b3d4788e3754a4acd18a630f27e463df4b81e9da34ff0e4b6c511e36b9cdbc1dd020c1be9dc5e2f1a5c72ddb6b9a2630652489975d1ece2b2526dae25ca5274665fbe00ccd2d7b1ff2119ddb32f6aec961ff56e42563c215563d3c597241dabc56abe7b0099d351fbd83ff8d8bc05f4072e30fa0d2b6ec56fcfe9086d64fe23fa34b22e70d5170f620bf9cae2bb6801b562eb7f1194f42ac2152a7cb39d7dcdedc0d149c373e1c3a8a75cf284eafe3d807437a58d870515aba273069b611607f1e36a6e4e37f2c144c6188004190e327b763ab395ed1a58fe5367c02a57c543855e198059910802536ff9f41530d41cd2e67c5d41dd96e15c3d6666c93532595f1789e33e5d6a1d5f142bddf03aaa223fd40315fd98765a41cc3d16d00eef9e85a064b4e0d807a5a81ee82557ae64b0698ede65e2478e32bfa8d0ce9a14e412a79926495933f179d667490c3fb598180f75814a69b9a288355d6be97c86458f4b5b53f55c95e4221deaf602347f4c479580d0c8ba1901c8a394a7e9cddba4ca842c31eac6c9141226abd4ddd1ac091bbb0ff3af59baa9d45932a3c1f76bb0b01bc9d14700f2547c22359ca9f093cca6bc8edaedba380e5b962159fd1f6e206c3587ccd3ab47b1f9843c6b81fe1bb848cc6f153a75710f2483312c1cd9640d546e3f924cf194fda67b605ef994fad689d49569a339cdb72fb0aa8ad1b107f217e1046ad5bf48fa6169d529b3a95f9a2a8b3607d9663f255d2d08e3a3a0422e11d16b526cb93414ad3016cb75eff533e1ee9e414e08a3916cc597af3a2b31f7e5511468d7f02dc76bc50575417d399aa756e42a7c1a439691271f5a91b453d0ab77c59ae487bb5093777c5553d3c99e98696d315e1f49cdc77a5b160c407b8e4f65855837286f2b8197fcb7cddfd6238b9549be0d5afae5297efe17967c62ae3009e353125f183108468c9451f3b4a48e18c84784fe8b6c2eac2b727ef4b1d2a8a6a0944a089e2238184fa644edc64c72dbdfba94ecc850110df157eb2270abd1ac72553cd95e84242def0f191af59e8bde803372dfae9b17f8aff50037da4b2035b354c96ceecead6ad2f2ca47f4c303f432adccfe205835e1f47889d50cfee4cfb20adc42e22413634739ab91adff0ec4b7ffbcb5c984c0408de1265ba187f101c960271debc56da327bfa9c07d74834229bf1a538718c5756dbb41fe3a282ae990777564557274f9fa44b81af5fac3b908b1920bfd33b3687423b63f031be841132ce3b74ee376fcd320202f9ac41650bc68b52083da63942afbeca77bc758606b088f2d92a6da5c4fe02782a99025945d837c3e687f061cff18392a0b1b1a0c61b03becf188afad2b998bed1273bdfffbeb210be8b2d73d77232ef63c1ae826d7cb4675e4c22af0da525ec05c70702ffcfcc6b9939bcf7fc4ba0330a3c3741c8346a855ab9ad985ecae2551319239fcbc59cb81103fb07da5413569b4102afcdda444dd2e1e9d747389a7e9fe4fd18561716a4d2454d169814d09ee5b24ceb34ef9b0cc5fa5baf1fa922cf6413de237dbf08315ed042ad98bb3618fff0c795854e9f8c6d1c90399196c6206a66548cf41bb58c4764b708ade0b73d17d0d313330009e28417e7102c08a429929f296f63cedb14002edb05f01c34ecb451e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
