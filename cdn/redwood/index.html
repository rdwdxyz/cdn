<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e49c7f262de250c7a33105c43cf99c33dac2eb7187505e04301c83f870e3a639f678daddc46f2e3ac8323a519cb0bf0ddac445b1e1dedfac417e0d49e43d887033804d198bf88883fda6828baffda5638d6e40e5e91e7ab261a782a3790696d742a555b23b1e4d1682eb879713fbe8681ef3a5f4121545ab518eb558fe00ad374818c8cadde698ee95d2ede6c6bb01c151dd1c9ba6978acf29f5f8c5152382c681b66e8f277497e13fb7f8acf6841edb896e64ed04e0c87a6e2c52d894cc336fb842c1ec765d94cab310b884a66db63409b1cc0ec1173a7ee54043375dea4ee880ddb431ebc4d750af34757e7b615cfc2b692669b652332c3a2699b11d28067d9be1e37e2622797d3e1afe92a88ce0f91e6691a0bdbce44d51756066522a22e4e1e49d9d71881f60746d25c44babc2b73b938db3240c2ee2903bdf6cd389b17314f2aa26091ce673d6713979d070f0582de4e8e61bbf20d063399046bcebe7c3a877d528ea7d4354e47d735542933b3f2880ee003d9b7a76bc69715b217465142bdd872ca54f968361af0f294326f7bdd10dbcf6721baeecef981ec6d4d390619d1558d0e75ff150b4279a4f6d1b99136c068acdb8de8792af5d873393fe4d6e217b529d0da06f1f08aae5c7b00cac91f3716af39ae310001e32648f1edb1ddfe7b11fe8d59c195f571f0af43b706750172f1272847fa490cce5ec2d924f86a29043a58eec0c388702aeb29834b47f5190cd0c26b8240606820e78f1091fd14867bfb6e9e417e3542ee5b9473fee62f9b97368a35b6260c900ea69f72dff7280a169d56f8d3ed4c001106b198168a180400c57882c60d35bc30180802fee9af7174214f220373a4a6133b47a04304eb2f9355d7623814f01a06ada3c30a78d0c4af29e5fecef75cbd7613c0addc1fcd1c6b18050a2084d1f22a1d38c702219c8abd862fbc96133dd736a8df09f3cb792e91d4fcfbf246a15f7837332460bc452bcdce7fc33acad4d13e5687c4e14b131d13ae09b8a292d3fd6692824ba11455199676c14ee524bbae2e073a883df5c6eeb99c507314c31fd4203abe85d6b5f70dc2c03a17d0642ef36b1d1d34816496e1212ca5a7bffef5d2caea059e29f3f4ddb97220386f5adba288d0a5f8fbb74be3b0efcc356a8c0225dd881753b25b092ba0b63054280798b55f37165cbf9203079e43675c1f71516974fc0afa04d0cc5baa60c680dd3af6115ba57a7382a291c84a5224d563947734f6b4ead9575d653366bd31e024ac501efc5f16b845ac8fb677512dc9ffb7cd4bceab78e6bc7b795ff0e189eeceee0d511752af777c169275900fc58a9c546160c4b765dd5b4439846b965a93428fdc436f4f5b69a9c7dc083b43de01be10b07e988ab803234ac606a1c23269f21881a342a72e21323a964f9d089d5d7a0d1c6ea358f301b9717b380807def484f8767068b78e1a95cf27ebc508524a6505d7530a42a0c9dfde9b4cff0787ddbd2b593b62a63d906be3896499d8b57f9e8af8a118115f61a70d1ed39bf1b4f21522538fac61ffb482234e4e8d487a4601ae73b2c74be569432e1969e9c09e3c2858b5229a730ba351ba1a6b336cd91f67e07637552cdd03d3ebb930cb2be72de85c4c8812c8c7fc9220fc5d86426124985cb7e0218c481139af7c4d699cb984ad22ddd95fca63a470293d7a574a09a2b21e29066f306379e5eb439249dc6b0723d71572eb48934f000bca85d062792c7c93b56da769fe7d4299c6b5c5b6e4c92e56cbc479ad0243e7ee86695ce15af3d5c8c2fdba089b56f371528b39c72fc9a0ff5c03a1f811f4ccf5fe91e89b2a1ffd4b6e306b23fd83dbcac668f125df4e0d3cc27cf41859cf44bfbd396291e803ad6ffd9916eefbf677ce36f823a0fc1057d2abd9dcb7334db1b41c0f36c6ed40ff0353cf41f6e46d10939a96e44d4046554a9c9cd2e99852ce403da0c23a90f0190cc29e0e118fde3ad5745d3e976e73238021d1d2d68762e06add241b60bb4da4fc7b24a5140c76c9ea1babbd9924b57b1e46a6482961b599d592e5cbb9a8a9ed5c47134873b65efbd82faf23a048f7cc88dc9e5b54da531c7782a6a9f14e1712578562a94bbfc9d0e60ab3a58d0f2b580bdd305f77b6c8761f7cebe89927f01e45a038202c0b4003388523c1af1a3fe45eef1f9f22b16725c65b1dd0b65be673d72dc0415ffa75d4ab6dd5b2ec922310b78ada591b79c2dac33d0e3c80f066ade81f7f14215701f2451200e840bed9614446bcd699a1ec40861de244229626f5b47d1f34221be3af1748795cdd29b11f19713f14b799a1afc34f94e5e68b28aa0d314b8a45841ea6133d1764c5f8902811ec8f906cec4aff7bd54d4fec20020c44a265d96e4629e538f5f61445ab6aa4a42c444de0d5e10c4c1fe38aa7dc280b20df3fafed6bdbe62dd92845b6c337b5cdead3552f03e687cd33765e04f9d84178bc997c49680a4e9b4d94f9e0fd2c5a2082bbe4b85516b45f15b8a8827d344fd115d6e1cd2b5041b019ff08219049583e605beaa4f844e577dd68fd84e4b1aaa20a85afe1930516e8ca69dab6cf03ccd26dc69928aad9c1d2cf6649a01f404656378318c0412122e1fa2fef5f00189a99dd598db8e0bb0ae74b31584a886b6af1752a0cdd88989aa4493721612afa56fd45778dd761480f66ea04a6ff5ef1bb43b7e8d19bbebb7d7f5c40f7a994ff03ff8f914bf8cd445b86d684706791ee0f670665a57bf13e874475a35924daae7753d65936dc0b3e73109dec868535962df93f5e7c58b7303107237b4a08bc2d72b6d94142839b86c20358fac4e9fa6515934b322dc1a9a57136f4bc73515e22330bd58bb66c432af3298a334b201d64393cc1f47679e8e52fe0d9564b205669ee6908f418179850f470aa2676c43e80349394ee2baa9e24b7923b428bc5297decf39a4654e942b063c1e95e1d76fc4a5bf603eb4f8089001706e679ea7aea53db44664c17cec49752bffc1871e51298c3736514afcd3c6aecf303b36aa99a70d35f3cd4f7f8bd969ce992998a7119a89452a4ca0fbf89b96d9a2613a35c1bc8e68a93930469cd5db9d1d9a92f673a28319e5bb1bf7c356b228269a1216bbd91f487cc89b297fe046cacc15dad0f34232dcf112e3068c70e5e10750e33cab3953134a8130e6d633c1827543e784a3fc71114efcf4971ea084c945e4545768c4edd552d183a1434bfa69b72b5494ee4225f27faf586a4f54f50aad697370800bf92cbc05cc5685af71bba39288979eee8f7ec9a80892c875bad4a475fcca9e4d4bbfc7fbc853506ccfabfe75c0a2102cfcb801ba1c1af08e104182e8c1493e21c26262fb78a803f83a23e9780f7c526817c993a12fc0a610b3bde46e702c9ddbba50e461f6cba97cfd49dff96b29f3bf2a514869ddaeff7fe57c0240d57c777d489d756d00f2950ba31a7f557a0e523a6d8eacb835d2a772986cb1eecd5e1528b5db26b9454f6358f73a4c5b64d2bee4627c450e582390a49954694a4da8bea592f7609cf7997eef805b187b511ae1c0c1abe0785b6705b6c56a4e77f506f6ecc50943da12811bcfe5f7ce8bfaa2023e73a1f9b6210dc0d50dd96bdf948feef50a5d238a9d9f923d75c843f140b0b8e954ea0182df1ae3766fb23206bb5a7b6b55e6213e3225dba9b93dd5e4c8f5880c3e3e20baa8355ad5b3912956d08763d538549c8c2158f83e23b2cc4d4480a308ecd3cc145abd18c4183d0dddb7844dc412ade8ebd21dc05c9494ef953a5e4864f02ebe0ff87d41d52ee48a74c49ed898cb87ddfc0134cad438c6f3a45f73ebe5ecf8519ca9cf8d479c84f638c38c3b549ce16be676f4b30c38947a6767934344bdf721f1b40be7dde58dd8666413608f2535faf3ba02c355e126e7bff0fef4c12fea118e6e16789badf6642f23de4610e21004290e62f4551323ad3ffd417956f8a0575b753e75f75ea310cbdf8e5d5e44f52aeb2c9f69789094e269ac7c77681a8b0c831954595d1426ad24ae43e8d037c0358235005a91b46a424e2708003675726a3f071a1b795324d2e631205b742591bce7397a9fe85cd63882611d295928882d5509948566ed0431245922ffb5a62818b2630187cf7b66b30a86bfae8aa897d988da6838644bc357c6550b79d0e8234b5283aec07c5ac606528c9b85c25d7f23b2840f0615b0661652d295b43d01e85618c97263363a86fcf4b7c803d2ccb536856d0f31d89df10e0b29f8d84adf074431f497dab18a365c91048bcfa23f917739944b2cfdc8b4352ef3fda6ca2ab12fffd4fb29155088c33278600a4210a9568350e28222c92798680b9178c1241c3198a9e9a5493e8fff9190f19b9776ba8e349f1d95e1443fb8ce16fee21f32bcee2e88f7454c3cab8de5373752aff07d33dcddbbd154c1431694de573e5abdafdeea79984e84f01c5a5256c908d647ea1b760251db4824840ee6e92eb0fa688b656338b9cd3a356efad19e37a1165bb3ed3e7d55212d57f2f548222c112c6663b353693386d56e9566aee30267aaa45766017ab1faf4f09500e6548338734bddb7ec4d79bf1b61e0d50bad542ba195a40256f5faf7298a15321a62d8de28bff2d5a2244b356479c225267f70e1690a0ee4372005704b15acbd24ec04249424c284144c1064626280d451fcbec4fae96ea4157c06518b9642ce3555afe1de488524cf3452594da55d45726603fc304d5293e93bc397e2cd6d609a86547c6303a11dd91d5172c4083a559f012b12539eb97a27f3f0ff9fb1d3097d5eec28e7e1f9a14f2f4af71704990d06d5c745b86c1adf27fc2dba9785bfd4c31ef2230d1aa568df0e950358482e99f74767dccecc82e776c6094fbccaf667f07b672e0d89876a8a557af215ffd984e98d1d10159fc7348bdf81ea59d4d1ce980fe8b9ead0eb9c38c97fbbb080e6e902ca0a9c7803cfc2ff5f9f10b375a05a13f979342533ad2e6907d26fb34dd24bd6a6743c20f0f16d6e529ca953beb174993a211cfedb8e3d9e4680a49ab48ae8279dffd57592523cc44419e31f1b0bb2794664e8e06a7067cf1807d66d0cc9e8e473f95e88afcae3bf53269fbdb105cfad3608be288fcfd352c98508d0bff0322428eb6f825b60b40d0c661e926d24c307e19fc8d2f7795e93dfbd1e4ef8ec9d5f1f22ba62003ad95b4db84aee2f535740b7d0e232c5910d982dfdcca7fad59d736a1b6ee65e26711b9be172d982b37e56f5661c2f7ab407b2726409c8a0189f96622b28f0fd7c023d3cfb3d4357d36974fd7709b336d16eccb6ee381a40f6a7af01a53bb6029ae3f149cbf12bf2dca65734742556ad2982bb99222a237515f7ce0f1e2e5c23616b152cd7d663c521bf3b94ffb590c9beace69d0e3e00c2a084fb3fbf2392c36bfb39842336c9f0df4c84aecf1183834bef6d0e8935fe6915bee23596b228e106a102d26834486bcf14b7f4e4c19ff4bef3db31b366253e985855243061e153e6d13257fa2431ee6975f3cb8c1f416e47c9556765230b56794710b2feb09b59419f1276134070123183ff6876de19626129e1d08c5993afbe726f062579b622a8afa30f84423b35db28078519e129d3bedf9564ddd9fbabf5b38e15e4d5553c65df7b5072de88478bb0359af9633845fa8a2710d99ee83df4be6472244fcd4e7188bd4a7517259c9da30b1f296b68e2049e940d025b47184c8e0278d11838edf0925340e6e0aee7db97405d365522fa63d7a25c3a71f4a4b9a3ebea7b92699374d1f8d9c99c27847a1512dc652e2638920b305c13211bd921a047d67e32b00642f9d4c216c391fc4f9c48b743c78cf84ee9e3f3801599fadbac4d3318cb300655a4fbdcfda1b198fd469652ac27bde02043f12a6f18eba3b5bab48d2bdb76f870a9bedf548cd216bdda67c4b1d5e40c8725df79fa07fbd85811eb7daf6e6a40a5c6f2c0a25b0711e4dce17e955f0bb448ed5892084f0abe3bab3c66df6fab910d2009fd9344cd6f23bd334bc6a323f6c082a3024326303d268f6fd114fe3de89c7663035810ffafde4a39c0bac936b4901b02ce6c035d0e31f23cab35db35217ff0d5b575ab62f485d7bf4ce2321c407e1b30c26e23ca5507ce2e275ed1d4a8116d60984274683da26e90355e0fa26552f03c41965556f5bc32e696a114af0432dc91ab1dd1db40de5fbe3959729554a888d1e45bd44b4767653a34acd643679d6c601116f6127d27c53f29d6a5e1e8d87f7969c1a74140217cd38d0b9de9b37c2c850551452d0ef6ccb732a64851fda833fb472ba82808cb8444387c3b9f4672027343d946d708ac0937470db57cd073d9a2ceb86355a2029e1457bfac3f5a33dfb61feefdbb2f7b69974eaee7a84f440c204418a5a4cac4ca59a2decb57729ed3b278a557ecc28eabc5201f5bf21191724d705601c6961c7ced3d2c4fee3f0ecd2fd8c3205336d2479912aae870d515635dba752e0aecc43cdc4304b0a4fe7f76d785f32e25fb06c8488dff0637a497b187cd56080be5e1a6334f5886723798a745184a88f18b5d80c3a988329f28d0437d9ba2781f1ea98c7e4a95ff6a79eb27c0808b1869fe3758a5831c9b1862761a8ea4c2ab7b8e6ff41bc0eafdd68e4f4916f929f724b8f77d7a1900adf4d1af04c93a44441c510e482006a3f37bfc409d7c207e82fc3c363ad522d7689e00c8191efddc1e9cd9bcfffe7aa42f4793e8854ad6d813defdcf05da4fedfcf95d1e330e81155f8092c3466ceab7c460633f5e484a011fd459550bfb483bc1c513150723f0545b2c9848784ab9722e9d9e3a38ce0755c62d328a4fcf51b51f68f64f6d2a7fb88b6576213d904bb9a539b140eb49674b9879ec3fc2c779969473b6d21df557954ebe20cac4d55d63bfc7b74c01e5c2b0de1662d97f6b88cdcda58bb97987db4fa909b7c8113c277dd6649aaac351a977ab194cd8c5e8eb799a25d3c79ac56b875753560035c2d1ed158e178782be7f24f7cd3764ee95227b30d104ac4fa612b8390c57c2aaaf767f5904ca747cd57482491d67eab03f76f664bbaf2d78cc5210929786ed85be822bb35f617c662664abded1cfbc9acfdf501775831a022c4c62f481121b96760d7726412a9ca42de79f17df59bf4f29a56a033aec10a2191d50e6ec4aad7bdbac0d35aab6356c513ce785ff1dbb6b9daf2953db4b0a9f6085c210808683f4b4ccbf377d96bc65310445e4b8fc25005f7691c6ac2a142ae929b5b4c7986375497c02729685406d7baa7a8724bd1858c808121bedcc6f6a8d7a9064fae2dda46b3d49c005028b9e6f8041e12fac89abc44c4bd09aaf649b8fd79bb78c26d38e4fc67857e383069455196c9824573567dd7d7e2db04275f8fefc968cebd8360070d6b848574e5884226da9128d10e62314fee1ea3bd3c81d5b65ccb4a9c8ad0872060cc99f7cb464ff1a7259cdcfa911990c12bc3bd527bca1c0a4df7c6b788281bf1f9358769cde8ea192c33d0e1307dee00c74729beb1557104752c7d94db11c45fde810339030b18ff533470f5b6b5fa55636765658e0abefde44b11d525c8d723589be7ae242ea6e44f4056aa71a91bccfb58519a6d2636e821a396a35793061fab255de347b2560115dafbd021453b53d1a1a151870ca39d5e02fcfcb30a3c93390f2af23bd793e7ecf95fe65bcbc6c744de3770801826f0dc433238f38b022876c54dac442f9f01628f10340b4610d7acf90832002bbafbb9869d863fe777b58093dab5a676fdfdbd2d9dec742d543435dc31f31733527c1cf8d4891f62a1374c96de32d12b9d356a2ed7951dacbfe5de6b1ed7030a4dd8f18332886a709b6a4a49e906cc1d737f7b5e3015eeabf18551b4e6c46ee357801679b9c9a1dac9d8ebf3c337499b4c0c5e128a8aa820fe8d99bd7a4fa5b3546949ce9b5d3e0018d7feba78e08e8604f98befb5a3e68aa949bcb9608f91329c8dd530118d1b0c3283c49dfe90e90836ac143e11cc8facd4bdc20df9cc71d813ffd376a4b1fe6568854a19ecd88f9e468f007659f106e8df684c56402089a0f46fd559c38fd83314610afbdbc23bbcc5c0af0b92233ec56f18fa252d0e48aa04e21cee6a94ee892f811fbeba76224fcdae1db1188dec6cea43f1bc080db3adb69434b65ea9fe5ed171a83381c9220d2f20407e22201c1a6e042c8c52c61c346779e33f984d90103705d445d1f54b6e66d6c5885783746de79afdd3972395094fd9462ef502e801a8c406a04880ae959c6bda860c451648dad08930b78566d7e8d26488778f99a9201b775484ee235a6d490e235114310a49e2e4532a8458a177ac391d4894e8de9a4b64b09e0de0798f23755ac43da1a2a5bd7ec3cb230c16fbb5effd9d44d99121e7fc97ac63d80cb70b3c9d14773f587a410e08191e21021d9514221c486ada14fb6f04a7304391119f0765ff130a7e71f48d1bda545c3f6686985bd37b4e9aee8620c8ec01bd482e7414ebecf2c3434cb3df836c42b872f452bba5c5fe775ffe31c883e1fa9aad98f1327e485a11b39afa35e733235fee0a3b359dc59c70256e0d20d7ed7d36597bc1e512799cd071fbad2d908e03a6d0340ef6ccb93310868dea3542d820cc6eef69bbd7b4c2b26e46f0441bf5cc478588a8d23c34bb7c3d99d5c0b9e80e12c0259bbe134540bf5fdd9aec6e171ff2f428db46f8fdac5be377aaf880a0046b15e9bbc25573875e5c62a0b5a0dea7fb5b5eed608e999ade1b5c9e200b626cdb4d7107727ca2937ad5b838b3a13adb04dbe073030c9b1e182ad39eab8551b210b8a50312069adf8827d4c73c2db9e6c338c4918948e8cc0f3fd1b8fdfd4a5c914761ca77249b69847468d13bfc7532cfdc6e388c086e947a9f80a5b49806e3be3574532fca4ede180842fc64e39db7a04d53060b4dadd33bd2418af5b1055c917d954931ade68e8e6742a509f775312ee0af8a85b2faa006c0ba084aa8a0a12d3e3e99d87280568cddeb449b4388bcf5019112a091b18bc0137bf4f475e126aa0a587fb8438e8c2e13733166bc12dd88c6e3ccd8adfeddd0fe2edb09988c8b75b10deec8949590d56604b838d37cbfe9b046e95241d9be46dc0ccca2a69c8727dafde7d3f2149623bd7a0b976fd5ad30771f8bc019c002b94e2bb037a75dc6390fb42218cdf03ac0e7f26a870f64753efee816d0705c10709ab53e3c56b8c1817f85924ba224b32dec79d62f8d98ac42bd1e645243239df6cee30a86f130b289946a32bba270dfb896aedb0808b0f89ff1fb4b0be62a22ddb6c98990491965a11bacf172139b16b1269892596ea2e438254e552ec2089b147b3b6e6173857bc981fbc439df53852a8d891b6d6b508cc10de0391823e8383531d89a87a870b0f8b4e182a885c09144fae3ff1286d05754130399df5d6b4462898bb2f01e0b68af94a67c43948f8d157bfae22d32c4a9194f5277d2e52593892989bcd2f4a7575159aa3f3c3a39af0395772f92eb6aa101167d9c8e84ab224cca1e23e42f4ba8480cfe7693f2560e558fa710ea4a8ea02ff7fafd396448825a605d884f76213ed019429506dda16c90163ddf35b35333a2e8dc03eeef116e281d61bb41ab714c0fa851a336e4637353e3caa03fe573ff46d162d9f8e7373e1985dea2a4af459c3a9fa7d52a403e48420a4e069d75f7b6a5396f0254841caf84fda34f332a03c0930108e3ab625cd4ff31cc51dc7654681ae6d7e0f1acaf633024d10256704657ecba0bd7f730076f0b622731d2cd63a4435f8115cd04ff2752a67a7cdd24c7f5520a5313575c314c9059560f5810f953835b5a1513c46914e5e197d993031a94194433fbee025c56fa24dcb3de9c92a46f59b2d67d31e7866ffd8313fa81cc969707e65b63e16751aa092453de2b4db7eb2a290815f059e93ad6b79e784673df7b2a2ae9ca4a82ea204595f7b9d5691c48a340336879cd7b07862369ba7581266f0c47aced273c94553e682e384d8b8de771ecb0e8dda99cbfb2e041e4af8b0f1b252fbb13b87df9aeaa5f5322f0632fa80923639528aebcb2564f1b0568967c92d362388ec8ef4c99d0f58a60b3d11af00664f322bdd0eea3e35816fd21d2e9b00815a80f2687ba098d9b27fe7a9511dadcaec52f6c920f7bfbb42e6814e8fabc03df8bdbeaf63a95a89fb90b9d7d4d25350f364d7824450ede62f05bd8792e90751c3f945decc15b1afd23fa9b3527fd47d4f27904ea29a5ca13d57326f34e0ffc8acdbe5cdb84c8100d8ef13f781b4e9e2479acfbd4a5367fadcec178f1c8138e6dad3a1fcdf56a05ea54faa54aa297190c8aec7070043ed91e1f21797ede5fed332cc74196291f19827c6d32db6c0bf739907608b6a76065114f1d3e731219addf2ea6e6cefe747d0a16d9b999359afdd280457aa186d05e07a860da552072a64495c568e61476951de3517441c9220819658b2e1aeb12681cf1d589afc440accb65a05789ba8b0795d6d73a0208797b09d63d1460b770db20cfc89e8e1ce809feee4789574cb8e01030561092813b5fcc0926c4a735b762279c92e1ddcec52c8abb9ec4cca7e0835343a25a78a1c4d4ed6b0f6cd4954cfc132671b70d2efaceb7de6f06b37e89fefd1f44b11dd057672a0261330c17ffa6481611dd546622c3012d53ce74bbcda48fda85987ea4aebcc7468601c5bd5d8a5cfc27e96bd5803ff9ae462a1ecba365346dc1355465ab845a9e12eb834d9a7bb23fcd5a0a5dfdd3428309b1007442e3337c46dd613bfd9b0e5fed8bd960a9b3bdcb3e6c50f347aca34a743f48ddf578427f6775087a95a19e8ece7ebe3f5044b51c3c49f4cc7067e9a80d08ecbef5b2539b253040d72dcfddc5032d32c35ff9fc8f83d7e64182535c04075cf4e644d5abd9870c59512f918ed60422448227e737ce6302052ff7a5f2545250cf1b79a0387f5ffee3649cfddcc2c996c29efd70e12b102412711b18bd9701522bd074955f4aaaa6e18c2e807ce78681eeef3711ea3af2252a22f35580b885b86c1125e9f1af8b8ceb8ee30f06170738e87ee279acc0aea1e73a4825972d58dd8ee797f094de5548f887b8d77330137ad5bd4a8f051065ef9ae20d27a16eb0d7fdbc191bafd029eab56f353e90864bf10d4eed275ea91b76f1f8a4015e1caea893489a5a041dab3b6c405d0fb7d964a0dda14d123f086ee7ad07003f57ae42e2486b478466fe31058c81abdba5affdc9f1abfac306382baf896776dccf1429b94b31f69fbb6a323f7dfc754a0c2a7260bd9712bc44c3d940186a62631a4938a151ce587e9a3dd200505e16d69d31f4892ed0a9b6a294448ec516f7c83fe4a6a56b5bc10833d4e209c83775aa0b3d8a2f6457659b0f6c2a4b675aa55e05ae79d8f5166cba8464f91b9eaa2d0b2f8c22a3973c9ba2302ee3040d335d14d46e09544620293e0065f746fd90283e19e7e59639e1152f60bf71f3124f080fd1e5100be3e661e62d71df149ccb3599b19a63bc4411ba571aba9931a6bb713384e2ccaab413cbd6c307eaf6fe79bcd4343dcfb3058202290f6ec09b3d3b8464a9a483fdb22d91f887917dc3d2d94661174649811d629278608af8b00ddab5d830047aa6e8717063074185b45febf1d703a86f9cff37b920e5b18fa82570a2ff7cf01cab11f794b0237d4635b5efab04f328242e0cabea6f6788715fc23722e798052e49c72ef959f9dda4595c9b0a2ef5e287d5d66d5b2af26927c8571b3a079aaf5ce1d7f3a0a3550c70741babcf1c4214af629c201e82d982b94622cd9718ab07ae4541c7c7dc8a940a6f48beacf0bb0b2ec373e40ea8a4679b0d6816abd62600360ae72d28fe2ace49b4ecb801b144eab0091508fea29fe8f1747d972a033ac3623998e24d8a65483c86b7d9964aac9a1af6d3abcee13bc3811fe7480d1ee5be6a05aaf0d0753eef7c712e74df6f8f32b8ccec160ec2283da9036d713eb98e6add674cc71f79c0b87d294694f8c3098ba8a2168ab645e063c660ddc2c54ebcc604a8fdca1b3ad867bef036abc94a737699bfa4cfcf0647fbae5fde36bc892f0decd382c086f2ed33a72c9dfe7adddc0bb02ac5a3451a8123e69525839d8cf2647e86025dcb72398fe77ea4a2313dc395bdf348dc438c9e345f060b3830701bab27a0d2472584afd5c2a12a4415df52bbd3fbdfb537b5f9d241dab2855f43a64f9ea3d90ae40eccbba04d4c5fc85405256724917296f79c937a2a1dffa9a1a6192bc7503911a45adfc3210f0da76ea5de1d4e898d433196289935ce919bd1fc5c29334ac6ca84ed28c01dfab7b79d4518bc1d7171daec954ff0898c6ae92b004d3804d721e9b6e2580aae03b735cb0b517ce06e61fe1c955caec57c337939e578dd427b20172c83951412a9a073f4ebc395903ffa8cdba547028c6384f5c4a6f98d861851758f8b6223c2227c512130fba94dcc4fdf321bc7470b29905c292cda51aca2eb28be7213b56ee390e427ac802f7d0bffc55a94257ebe968a6643b846a5f0a38552b43dba8d12e5ce5a7a82d8e9ff1dd6c5c3cbeeb730aaecf36364e826076d91987a2a21863124fa1b9810630bd4e8a499e9930e23105a5d0cbc59a10e7cc74857231a428f69cc57331836903c258939444403f45d1f66f7373a2e8aadfe993f48bd9d5ff4a17b2663e068bed03c8f79f931c6c593c5fcadb126fc375003508d389e1523a33d185f4b99611fa6d1c36b6bd4fc5900cfa039d3dad218ba429cb92d1c1e57295c6be71747e71393aff5b9f1b81dd67790eca2a508bc2e129b8a9a05023f806a1b9b1da713f62b315b63293ec1e6bba4c7418ffb4a64be6c595001b46d7567cebb228e781d875527225de2e33722f6285dc13ae4e35f7454ba46f04cd90da2d5f8f5e0f43e23e0dfecf757f488c4701178573bac7c89af0a67eca278abb0143687cfdc5e7c2d2b74c4e8175fcbe38e60cf4c7a92db95769e12f745e9fbde910085f1c48b1d41a2d0e785b6621f735e4841627038cede525a0c7b71ba72f8d202f901439dbfc768cb121eb5eba07992cdc9a20a2618e966d0a05b7f7f498065e38c409710cd031fc1cb8116b6343731a6b90030a75b30dbb61be3cf390ad2e15a0248bff8d3f6987df0c27197f2670bbd5f8c54c3f93bae730b57116ffe4b3f363467f0d00d96e10b1a51099c13e05db2c24062353bb4976d2f4f02451d4db7ff03b4baea1fe9817e9429a48581bc27d0fe4f9529510752ad514055bf85753c77bb852802344e46f5096ebb5a3d63114e40948574aba5d91280387372728dacf6d2551de490b152a3bcfd0c6d222ff6926887e4225e5fa960d57eef316a95838395855d342fc8d68add9478cc1b0c3969c3d4fd49baf6a18b331bd9c41a7cecc0d6d5c2cd070fc08b50bf99e479f44f2bdf683ad25780604995aaf1d96d348970d5355826a21029cc62e5a41f47265efe14013cd67568b697404bb47330ca4c86ab8c004a31b82565022b54eff79676fc1a46c62d50ab0128e8d96b37c6c4ff968824c82b9354825a02331d8e19cff4b976c68ffcf0d1358152c9f90032e6534644870ca78cfe9bb94aab2eb00c6f5c3334acf65a4cd817b09ec4727e80014ae23eda68129f5301fe3d5ce348b9ee50dd60ea41c2ab02ff540f4dc61a4444d442c8437986caf0229d733b7b7ca747b500c73357ab82d7f1c002a5ccc5992f8ae96e220735494ea0c53cd1dc27ef67a4ea1a832598198b5b40c0c23c9d13d140d56c5034ccd852a8caf867c40e34cd1b4adb3eb0b4a3ab7498b06db4c53ca905a7b76c156fa3397c2c87fd21f424cd8c26132bdb107aa2e0e1d88f4a5666bd1d8e6fa8a68f2a2cf0e71d53a5081afde613efa996439df05b8fcb6356c81b7706b2b03de4696ffe6d006a9ae001ba1af5a350c8bdeda91bd158062a4d452de614ff8bf74b71ab7cdab9f7868db185e1e040a5184487e99120f864b17ae6f8a944bb5fff914e9dee62ef62c605d1551585664d7dae133f0323717b230f4f3f04a2585b417aafd6ecc1a605016804c9f1b64e2c47fc8d6c767b3d0d8e5dff298c3af291442b17e0c489ea3b8dd20f2ee56bd073ba4ce2f92aa0f7642dc9f40ddbb82882df75b80acb90bb89315a002f739808ebe47529725a0931bd62064bfe8a330eb582585cc37046c180e2d4a618caac800d3fc1011e0b00b094421f4e5d50bac8a268d34a0f752e004d7c2f88b9d304e8e4c7e338fa84486297fc6d73ee6dcb9650cf2f76ac85c70dc1900660f3cb1e65951fc1d1c95bdf3bf4f32b2f912c2b35b9492b5f7c8bef87e8c6e91eae999ec0d462391f137fd429af0e55020664c0fd7355bc6f55989766704793b5354160a565da3548e67823939f44b34a84748f6120ac72001aad6c54cc31fba0d64d20e06a172aaa8c021845c2714cd42237caf669328f4d7ea6f487c79bd2b05e6df1d55b385b87f22bd4af5d79600ac9a473c247a4bca7b03f8e5f34694f9b5c8aa2e1f318e1624f8c05e545566099d9a3de4f3b677bc7c6df5bc68e02571c11b19070073fb6ff23329bfb8f9742ad6292dadfa5bac9e63dd820b88c392a3e73f802674e171ce192f778a79b00177ed5e010c54ebf44b6f1d0737453cfe15f8a9eadb013449f09ea08b2d14878fee5323c38cb61cf5d554a3e212f13f9701636efae2a3d02cf08e80834ef216d93ca30bd352fb010da52db9ad495a6bed8e31a2409a0b422faaaba6f746804222b762bc974f2e988002488b699e5a7333c3ea11c662e3a9bab232dc81b22dd59690bc13c1e47336b3d62ebd106f845a2de652ec487dc03e8e326ee87804a9c34b67afb78188a1fdcb3500d9074adc84388d8f4ee860f8607f11c609b66b584602ffb4a086878c3b3cedc681f17090e7a18a10b792344dccf7d8a2a7092a32426d26662b2561760474f6c680c04fd20df191d7e8f73f31e107c7872981e72e2419230363962c57196c7eaf3b76e461a68e802546d0ba790cc369447c0b08b4f8f62e6f3014f2f0da5c6fb258ef567d9bf3b4e9094574619a3dd9392215ac428acf7ae86923c3b97c2fdafc1020d8ee75b20411ca6c3f0942ac42da1c69ab18f2350d6e77e1ec42d19793ccdc1b2dd3d26dfac814061d294b8a05324650b801c797939f973312fc58ed314d7e66b079e460fb58924c5a3e4f09df4f1dd34ee238ba8c8e87eb63259f281035a2ff4595c0dad90db94d1b29f52ac4b077fe1191a8bf4190eedee853286212e83cd1a465858cede84398fd4c91127299b475bfb53eb0377bd4f55ed01dcc980e472e39c0abf27606d2b61932c6ca37601e15e898567c5ede93d24b07ea1601e6549950960db15fc57bf889187d65b58555b9421a7759c62edb18a68fe7d6273b602c0a29af98c0bb1b01de82ae300a82507081b7cbe1192e9ee47993e96a80d0395447d04b4ee2dec6bdae6e2426ab2b0d1f911a0d3ca17a92280d3c152c8c744095cdc01d92a85eb6b2256479a7eb017f06902a4fdf87134dac296ce4089a6d080acfd9dbb3088d2efd037242f09ef3e2c065e35c466a139bad1d76a09bed8a8fbfa3c054521e0c00e2c2b8fd58a398d32062349da18f10d0869edffa2017347373d40a2818b0b22e1d70376d9efdee8efdb193eeebe522a9afcd8b2b219c6b7d27da8c6c6eb90fd0baed6a9aa6cb09a3a86bc6882420578c46ea0e7ffa4ecb2555f0e95982a7325bf112ae49b9bf1550368b2dd5b8ab203c9fd981fa9bc045d6a280a4b7348166fb55dc8ab3bfff7c7963591cc6881cc01d82a995ee6f824fe3d42be6df96a4492178930f581052dd45f9a69b57e75b911a3d68ec3324b269238aef734636d59eddf81731b1fa669da036e41e278b4b61b636d727edbd6ebfbe526bcd7848fe3cf87f77af53281f859eecb5a11d6207dab79e33bdce7fd2452b57367ba86a2edab4a6835af3bc8ff8f09dd1a7d2e6bf1a7807a976e1ddef7c8311be56d3b7e3148e2d055aef550693b45319bef6ec54635588f825d36821842744f3a08fa75295811c884e02a2a2e50109c567406358b473b7720a6617b6b2e6d325a62c41ef2ee2376a4e723fbb89d986d6d6fe3df5ff6331eb4122e95dd158fa5c810851878c11fd3dadc5c16593030a8004b7de4da24f50db342af1c32c648837c0b3e26cd0cf0bffe237c01d07bca40d7ee83af547a864d04fe3b6e90dc5a2f1aa90c6feba9017c27df9eafc80b7d41d7c3623a333f7f8e0a9861b6d0f2c3209304adaba5a57b2d49e7a3ce13fb5301b7cd6c929a5f9bab9b1fdf484fe41c22701fbaeecd97d53898b165bbb17633f025581d43c216df2d68d120a67e900b5e16f3316405d176352e61361be59b759c7c4f93cac4e036d57e45d931dd6ad3f071148dbb5e235941cb6e2a2f886e156737f5a4edf666b31c40959a0c3114f08309b80d26a8c1c3ebb7b623ebd0e017913875d5a5d57c38bf48d63473ddf9d0a6484a5250b9ab0b20ca6efa6ab728306172b58fc32b052cbca6942918a8f31f33f9663b6abe658aabba1f856144c4b47466c47f1b302f18effdb62cdf8c01d41eb3ff882803bd41eca8d09d1befa7a68b0d0c9d401655535557e4d4281907acc74e9582486d9c287b27677fc63fb863525c3a9edcd0595fac48f5c5190b49d12c2820b7366a1c9e2ecbd3e91a89ed3dfb3eb9c3a689cee2af593c041410f80202f173e52cb33d9d97fcb1cbe2c0325d44f6ad5fade3c4dd748d2c742f6e322e6b185926ba4ab48993c4c86f01c3259d2b387c53571c545714c50558060f57372a707c889cafde01c05e29ea2a0baa0c5e7b43b1a35502c950d9c130644c7d1ff3ad7acbcaf373c017bc6a25247898d4daf4dc3cb248b0cbb65901bc91aabc6a3e9ce16fa3b861cd32c557a33d2a74d279e828b7775365a5009ef854b90fb4f5aa2fdc700921fec3ec786bf5704382cfdae9fd7e6cd70dca90fc6362cfe409d558aed845249932417dec313059d2c01f78b9501f2c3f9d3f110c01ab86083be447cf0cf5a1252acd901bd4ce0ac3530ab76038c456fa3c0a24ba7ef6ec667095e53cd02db749f339239ccafbfe02b43f4db413e0561b3a5d953f63429d0462a9abe8371baf41c473361fe44a708735403adf0adc961b0d7bea8623ab452a79063464d745811f74dd5db1d90d59e701056fa86190e01a34e125ce19bee6330b2c20186c9e3158b6cf8d96b49f1f34acb323c64e343190f8f21479419f77606ea4fbf792ac6109f0fd1c2ae7f6046b32de976b3974899196ecdbcc49068185493c007950b1b71913d641ca3a6ba16aa6f6720fc7cc531c6c73c4af7ffb84aa026f8507c1d3e62345574007086410b67cd812243b697352718de41cd4237d4706f0d9b8c5f3c7c3eb2353ab0c30388a00464a0578e6dc76f30d75032d1631b131767a51f0f69ed2dd604638cb1a7a3c9280f2c078a79f7a04787c7998a64d1ff1e5e5c4b7ca664ecd17c23c43b1f3d60dd33abe5d60b712e24f9d5a9be546a4aab3a8a22e5be22e290334c19e05fa98f58dbee9467d8b0717250c011b3aeba3a23cc8eb0a8a7e88ab8a10aa7346cb4e39e4bf4802c3cb4928aaa0668e14bc03c1d298bcb93c2e7e900eefa8f5410e04434a5d5f87e5daf6091e7632b66214ea83d1bb4f69ddfe39083077d8a0a7fb81c0c565c16737df19a6c947ec444aaaac0392642af5868912c0eda0437e02cda80feee30e219de0f4b82a2c3f007e468618fbcb089c932adcee61dd3ff2312d7809339bfec8c1b55276c61ea8e7e12be85484d048b924b79019066f03398e3c7b3af8598c552ef8fb6c97d7e1cdcc6b8e710dfe4807f36bda97941d07ca1351eb6c1e839f788a2d665a95a7f5353201587315d6718eb769c8f82425daca31c06be87d37e0d5cb32f3a1efb44903253ed7310be45da3a45f5d1f8a56bf9ee9d2bf5cff09cd5eb8dd0b67c10bf95efc579e16cb7c6a5c344ba37cab4fa076bd237599f375312853945868","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
