<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e12d9a30fabe11b17436b06b0c0b23364f77003ca9a514d8498a71d1cd6cc9a8b2d2007e732a5ae2322e2772c42e3b2cf99544f4b3b026df5cc5929afb7894a4431d0d1f6473c30a065656a091358a0eb00737eb0b4821fcbf80b57c68547e1691e35302fe57d2eb52886daba774a82257c8b384b1e5fdbe4170d5b2048530150afd64a5153c42b63099ee42a44eb3d4f69e7af2e0bf7510a44e4c58c0e46c5e6e10a54b9ba4dd902c268ec8d9432f40b08938b5bc18142bf5ae4031aed7f477007d3809d21d8540025cb838fdaa2d0f09aafa21935534ff6897d01cb96c4773643a49e22ede42847971a99c3a6dc819492e55f938e41a0255b5e3be94c57113963fd81d8ba6d017db9cfc3c44340c36f8a725b4bb4e0a94fd51ad4bb20614fb7a797eb18a513cf3a287fcaec607a991ec894c9742298be6359f080f92a5c19c4abf3aafe3a7058b4d45cef798e94e84460563ebcb009ba56f59307756d1e0a4a2cc1a06df40ffd7494f90bd04065a9ca6bff7eefe54e61f06b8828a749de4e90cb7dd843bc98e4b94f6acee13462f48bb68846bac68440c4f59564abb71f22b15a86cabdeec8faeab3341ca2272b2a8ee9e5357b5081ea565ca329e21eca3e53ee1106c9dab0376c463bd8e47f3bd5aa5f4bf49ac0c9c078993a4b0eb3be6375b03b19f6b8273fe0c3c5429e2705f6abdab84d2c33af8e1904c22d5faa8c5955071742038753b1a911ebcca23ac6cc0c2ebf4b5c4f5c29a5e15f8af0dbc4604781f91d2ee27671280ef4d4c03859472a814b519547681ece700f97cc482a701e30fd5238b921b257061fc235a5f78fe4f2161c29adf10b9251cb669a463159a92fded075ab7ebe4a4ab2b2d31d54f8249aa6f4e31d4d4e742d721f7fd1ebd8702a5eba3693b02640d87f219a54a5989c330d5d04ed10f4fd5a67e9bb03d5f24c6644f84e23bafb432415ba32df2a4471c51eb786b09c4ee7c028dfcb9192b5830076274509823b0de36d1e6884971993ffd8273459458783bb9c67d5e17d788d16ea38e183cbf24acad9aab1c0fb5197b92b58a8ce6205444503058e16c7ca698895ec24ef124232df8254d6c14f2669f717809d3cdc6f1e3948123dde70c1536734c6c621645e1a66da0ee2e60889f3662949a17c683998ca68516d4e789a2abcc3082434795b7741af166917a02612b36c57f29b967e219d88fcd2a62ce4736449e78448ec32924a8aa20d70c9baf4293596d29b3460b8f5681c568c91929745897ca7e1e9570663a55a92bbbc24f532205aaa074a6e3fe28dafc43baa3e566b4a9d918d351552b06b703daef132c9e68e6099132f03b21d96a44d8b6d3bccb9a77df1f2a003b17ae63465f15b9c8edd62757a0c6386b44bd5793e5bad3bf34a738fb542eba694bc48d86f4a5e50745a9424320b29d1d72f01163d1fae2867ac3056f9369221b3d846aef62a8e6965af43d78ce7f636e6749e3cf985c92a4e7b96b2ff5e23f229776211db74f683c3d6c250117291430967db4ce5fd8147232656724526a41f9f22a36466f900b0f04f07cbd50fee147c306e93d6f70f54786da8ebfdc0d4c0608aef363367ba7ee202596f936ce209f2a7b23b94da7bccb61cfd4ae4a7ba8fcbd933bd06cdcd3d8c2ef2c13e0fbffaf2967119571dc2d31c5f09217d5b4c20558bfc27690405c84b16c3873e41e4825f5e7741d8e9bb5dcfceb93a44a544b97f7d74b4821689549db105672e72286e18f8a1c5e084d747707bbdd7fe831b63820d7ec5a1983473351a4ddb385140f4ce36f0fd081184c1bb7a85c2816f756a65331c67e753f6244d160297a2958d86eafbe94b3d43888aaceab90677b937f6b241cec5e08160c08263a46da1a14effd7c6c2352eb47e18ce676b86e1cc723016cb7cf92c409509f7e45e8c47ba744074a5d37dc1401716ca58561b7051eddecbfa795ae5defc7528e343b185409a7a445df67b84189606c49257fa499eac941323a9dac9e8cc68da66952b02f39f6d2856336e26ee24d2f211614d1d7de7ca16535eb387078a4b67c43fa84dba237624850c98c17429c3c6e58f13546d129693753887b765108e648cad9170fc1c1fca2dc3f47accfa2421538c383c0603cd45deec7e03c5c69a98ddef064321d136d22335677435d51e22f76b00fdcd8cc148ea37f7aba3c34d2221c2e78d820793a180e1a2e318d284f95b536733c0b846788b99dfc155297b0a460fe993e78e8c016f6303c469903c23b6d623d5a8b99f13900e551d19c1d526f6a6310ae75a1e1ec31ab092c2d1f8d5d7971ce4f62fbeeaff627b3a31aee3324b3ff1f3600824e50998f9b008cabcd2e77cb6a559aa7320fc554b7847d38d7e9761dfc978fa85ab52e55448169ded152a0d57bcae4abdd2ff79b8f4d0d3a467509112e4b295aa0c4b1210130ff8678684c238aead2b8beae68cfe6f82e1e7dacd176896cc554f93486bb44b943a1ec5b28beb2cb8c795ebcb85864c86a138c8625771d1468a2ae0d1a6766d67b4fe720f5a7d5387fce155a69a1f00381658be1f6b7ff21e4cf1473f8ae5d2952aa5566ec50d212a0142204adbb4c78d4ba6f64700ada7d163c5d2b48ddee7b6d0dd4ed66e1168188ad0acef10b65f057e050e421ed9f5e8c535b5724c7cf10bab63ed47787486bdd3e8497a034d617a5f29be0dfb27d643dd379b3e5df7c5b576e4d5fa129fd690fdca9a79b21a5c96645aa5b8cb6881d808a672e7521af3a306e5e2c02b5cff21ffa214c8ae50f30f4c93fbe6a8a5e13d556e08ebeaa4a4113c4aa52a26ffc2e68a9ac521c4dd3581e228d2fc77327325e86e2d6e1507ec5d61b190705595d23621f194919d5949b572aacb68abbb47601fb469ffc64a7298348a8bddb54e1f382c83a0cdcb03d356e8a7c60c7bf64be63c37811155a32d40d28d4e4f6ca68b8902ba99f039d4e65054d3efab62e256c6328b9da112942c47121548fcc8684213a2441891220da16b651e4c7133cc5b4f6bc490f525b36faab534b12d65516fe2d01b84388f1fe4499d61d87f314cd55808247dcf09ab77a0aa1bfad0331668518f98c77d5691f014ebabfb2ea14152f291524e51cd516959d93b51bca17e58e077e66f389a937ffb9003a1760f0bdf0e30f83e59ef3e0921b55bff1a7de7a5c9393aa91736f961b9f53a9c92e9c793ed2b080f57d4dac00131c8caa37c937449eec17d78f6c30877333577c711d553c02fc226e7808f07d00ab5557349f1c90f26786ffca86058065589a2cdd7cac1a65f8e608dcbe2913ceaaddf5947b6d54c99e9a57504a7d173ae4ce877147bd6625c0f68597b8ffa85b0f28baa3ea66dff4fa72dd314ee12a740dd9e4d38339a6945baecd73f2666f6cedb5b50cdec34f63ecdc46e26f9e1e154468ee4756242e98ba0d60c00377617f31b66a56a1904c335a08f411e56339112ebd0371a3aad64eddfa0eec6da1bcbc69a0de4f003faf7aa256df4778e07f8343267a6df576f2b99173f0d20b4525f54cc251cfdc0e7ad47907e51a299a1a324737c2c11692867e0a14ddec1472a5c8996709926bb32c680f143c5a2659bbf6e2280cb942345e94c3e1714edf4ec13950af1ae1abc98b7bb969f7961b56459b905599dda1fb9c538f315d5e63bdf54a3d3b5a0e9b125aac349bfb508517c315b0aaebae2ffd7c3a1e287c9beeb141226ce60da713fb89639c07d26e2441469efab0dab485118ddcdbab78794353e156dae270c059b08f757c59543d8db3273f2a1511235e8f8c745d52e96bcdf4bba55d31019b9fbba3ac8e73e193efe113794f43244d608fbb8117e72bce769a964d273b96076bdc7dcd257a2077a493f4cfc47768cb1315a7a3516a952f8305e6ce7ea6aa9a5e457a467bdb5b05d4b4cd1ae42582fa34eac3b7150234b691a7572c65922522856087d345e494cd2f84c624ce8692bd04a0968036b0f7f97323353d14e9115b35d030a89078a6c4d35ceb04c4dacfbfbe9125812b2255717799a5763dbca60bd8590132083b1248cf6417893916822a5a0325dbd7c187aceff7745a6c45944f50b2ff6d91874321f00d4ae8bf33542df84aed5c8bfcdecb74c373b9681a06d059e1616356de5bb8e419f187c5713474bea90a026cf5b931529758b94b232577494f1ccd2dc2ee5187e707b4032f2c3394b8e4502097d4c178f8d9367e1fe9d97ea63cb58c1eb0dfc2ce12a36973c964844f6258425b6f3883db62f85809ce22aa4ed8ed9e8b81142ecf789bbcb233c45807534910d8a1dc1eabbef767fc4cb4253639270be667505575c984101374e9d21f804a382fe23529521a0d12f702591b312f0ba3bd3e7ba6210faea6b2d9819357d95805bb595c907903ab510498fcbb9b11146307d787c62f0e71c6d529d8bfcb7494fdf17c14bd233f3022d28e1f22ffbd457483e895535c6f400c5b5351684b19b17e766580b28b1945a6da5962f9da8daf97763a0bff838cd12cec5759b5c87d10eb954fdec33847b2fe600346517364d4808a04eff58f002a32baaa9ab4e1c8fad0f3f40eff482279d6ba5994c9f714f661835bdceff5a638c99a98a947278ebab3fdcde07254be2aad2bd5df822be3ae1b41e611fda72f1f6cbb3386b9544b562435044ac5dd7b9e04076f1a4c74c9a016dad10077fcedb6876102893b9fe335c1e13f56184d41e482d4eb56a6838a119d9d636791ef7edd9b4b2701a328ebdda761562d69362a26d43ac15cca5e994109c17967c29a9c3e949acba3219a934cfae31e181c0eee47cf3c472a3bfdc9cdb79f9a105294c71fd118b7ee8d3be4ce61fd00bbc08697341f96ef81767fa1bd06d6cdea64b52f1b44774916efa014d383c74097d41a0876c79f6d9e1f7a799db0b0888015ecfcaa655e1d4baf76dbd4fc4ca9eefa3ee11ec3eb0d0238a5f8e12fa5bd52e10fee472f292ca680309cd25b96636935d3f8813370a661175efba37aa4ebccd4ce81609e40d6ec13a1968f1e4817d758881cf168780a5d2b0b437dc98155eb1ef9d26b648acb5bc7719347baaa982528aa84cd3ff50a1d0a383593dfd655293da7a4b0d916c63617cd7f23d7e1769f03c03cf83f6a5d2a48c9dd729f267a225deec6f9b43552d8c5572b4383fcf06090f15864284b6a24f6957dadaa905959841aa855e30b54b4e16c1bc3572bc0224b93363bd401d1fecefb54c31631c65990544951f34e168a7cf467f65425c64921ce976d7f58317a87afa68e2183f5149c380275f303a4f5e7e729289aeb3d1be5181cd08f09bbbb6935568a1874a786bb3e0d5deafad455ab32c87abf02a1a0eb91f020b9ec2d641ea21942d4a770a4824f2e5c0a1f7ae3a7cf5b491dedca6355372767236a109f1e76d5763814eab2268a2f5f74045162e5faf2ae5b7cdf1cf5557a5926871c39e946314225b01c9bdf63a18ef7413fd3aabedbc96edeb759d5c29257bb35c276bb83cc12fe1558329044ecd748d405e73c04ea80f54e6a90797b0aadef3556258c2350d117d3e232610e854a723c721a76a5cffd588236a442bf96e0c0dcb5a8e1e7a94214746cca7117a294934071fbfc4a3a22fef713d22dba5e2986d346834195a18eac501c25de1ac16c2c7357bbeed0db54075fae7774ca224338103ecf85e28441dbbe2bcffecce3686e15163950f916abccef041b3963a05e68a28da6823981a4bd8ba9f55aa34e4bd4c4ee9df962a8bd8af0140802d1563697906b4311217f4ac483b5693b6b5211bf08ea7969c15237b8d3c71e9c58289925a4ee81e8f3e89738f334c44ece34a003b7004ace2879022f52e936312cb21d406753f77440ef412a05d4f3f7c4dd7fc63f9a34ae2aa6d3a14c6fceb479d3fb888f1ef473f5c4c790f689a37b691906da88417b9f194420b2216230def81bd3a3402deb425f81916252ee9e6f22737e4d30539dd51139679cd5495d8724e60135305dfbb14b57241db1d65655a95a147d81b0535fdbfe6d1f6d1db9300c7396fbb6842968d3ddcd5ac04380d7df11b57e0570418274fa0acd358845c6251a42241f7038c0d8d4c7881c07b74aaf56ef905cdd42a7d1475bae8a441e0c848c4c02b0a65c3e4123bd3875ee62dcc607fe5588a696c5d127de65c15a76d1386e182cd1a61b7e717fae7c0f93d53ed676f07feb37f0a5e632133fc75337a2297662b35201a610ea2923f2e7c226a3f7961e7a8729f851f8bbe83fdd3e9dcd224ca7fe24728fa4da3c08beb3b4325b68b018938c84be7b1b86f12c90bf97205acd37fde856c395046e93db67555e422830f06cb68548357d7b82839f10e558a4542ec0bedeed5ee0ba44469fe9d08db0b7dc5f624c5ba6fd20039d3ec0cc894864f68314fc6ebfef5e558307c9740c1a52197fd99ac40a603abcd954becc43335a57c8eb8a14ce20151b2848e0bad62f5dd2967ba62427373f89014b338a98507349f4969e6c885a73e34cdb87e7b8d88e6a1ad21989745bab40676f6689ed37a3cc309cdd11f470155feed72eb4b4bcb221a3c1243b451a8465c713030449c3c8a06d685e97b026300426a194f29aa6b2758d346c02a5b9814ebe8b82430806cfe8bfbeebf8ebbea0c1393adad2c821b39a2977edbbaf20a7997212e70c17d52c9635b0e0dba7560d822fbe32e7fbf9178dd0b06915b0d4a80d8376891af29ad69884df3c727226dd723066b3e08debe37a461908117d8d669cb981960315a6dd730dc49695cf4de48abf7f49624e552d5108680e03d1d7ba8ecc9a85a4580457df5b238f1dabccab07837ab1f9ec90f6a95fa759b4d03cccc37ca8922e8f57fe455334165bfee5578ed676c6c00da61a5522c20180c5ede4adcabcffbf02caa0433d99da6f0088a4b181fc2baa9c4916a85e127da01845634a8415ed8bde11a389516bbb67e8380ac930ab248576e0d6b9622d2cc510158f6e4680a882b4349f155d95f9e095f6737a7adc49e81cfec282ca7aab27330297682e5818003fcea538eacc7f50c9f979107bee07a55d1bdb6f9fcd7a3686d34c0d288e2010cb9bd3bd4d801d5e856b9e034427eaca15ac0ed533b95c7bde21c7febdcc7589e906b64369676a6cc2b2b4d67a5cf5e154930ee6e1f1afc82eef42ccb2027f118349463cf339ff6df04dbac7ea8e80f8c6685c073a396efef008503f85b91854a3039eea34a3914ea34fc5877baff82e4daa2f35de7d4c4e95960e6c4e8a8f2e6aae7655eaf7966417b42769501bc52aa6080b5cbd693221c381eaa9cc3ac7c0494c3cf08ce927119140d6b298c9315008ea862d68cec0ab3dbea66eea5ca59fa72e3ea0da62b72df778cf7863d5b76a79d62c76bc31be5d3c83337367965bd48b2a4c015899b39660928b26abee4182b6deb2a6f1d9101811579885afa8ccd5dcc77415c5df68321560c67a14c2a882a56b61e3061e4491b129ecbf27067a803dfe6c16b1e39526e58cc3cd07f31c3cd78a4c48145ef78d99438057d656a4d087c8c88d591eab1f36a60bbb857a8fc1b96108da34559f0faed1ca152490a2a7cd9a74bfbd34c04452b7b57c0a54bb7825bcbbe477385b1cb8619d67557c4586baac2de06cecd5a2abe67d0e616d40753bce1b27c6b250b4aa3fdb2ece5764beda09548df96927e4ead9213897ef141daed62a3dcbf9012e96c781fdfce88a3f9a8f2e03ada00bf04f515aeb789e68a1fbcb8ff6a62f7fb8368696eb0c1c89b82fa596a4f224aa8fb8d532f948d4314e56c83f23ad5a5c9b6302bf342da6ba75d83436b9f5bfa2c77180bcba080b070d00d1075bf88d8fb2cc0c07915497b62d666afb2c7d807d971388c3255e15945c84c926188e9f06c939f296347c23dd19d7909818f7ce698fe1955e42db8630d946502e90d0afb825ddcf3fa62382053ec94bc6e3250bf186798b48468b66164f1b9f1ea298afb5c57ab821cfe7e172953cf7f7d43280e3607780e9c7d773a8c1a67539d6e54417e35d1f0ae821dcbdb93c2569f241a8b217f1ee38620cd568c05cda608bd66a5f00abd9461c80c5e87c10cc1e19c92682ce45a96ab22969f4944b8883de06e9c0176a8b04682354e6ec6c6960e7a94dcb8c0a55f9bcb2cb76c465dde5222891e4c58fb779ec5894afa5137ea677b68625cfa96505b63a975e69380dd16afe673633ff7ee19210832b01207a9955be37e03502c31add0efdb99faeca081241eac46d10f8e9890fa596414586fa5ac0de8ed3390ca6d96b79b6cf541dcd3fb118ec46907104156e09810799b742017f962f396ea3eb41c698bc438ac6cfb8b4c2c949a513f123a8e4239fa903a994e522e7eddcca52a9cc620e33d03cd11d4675649978ba71a7210b9f21a93f18b68e587ca6f738920f9ceeb44890d6cdfdca076c1266b175d9fb2a383f8ccad12b6502d6d5bd90fd2117b9d8904eccf71d20b5e46de9c81d8fb32c9c6a3b8bdc33a176f34a412984e6f85fe73e6d9c92399f3cc1b73bfd21fc29454038e772b3dd3c476f12fadf4d1606bd62a686f653208d905e59faed182a1cd8713e1651f826b963e970a5ac5652431b426c8fd44b033f23fb1cbd3b673de83365861ff75b5048c0957837c97909e7d097a573b486963c228550043c9f747c25066574c2da0de5b174e0914d4141f2bbbae26872d4129631e6c164061b8309f00e157831323b37f1b6a5756e9efc19c8d96195c65138ca762ff7ce7457989aee830c5f5104525de9dbdb29fa812d64be578d2aa85d3bcaf97a43255c6818e028f14c27cf4598fb248679b4c3df6b7325a19bd4d848667eb3a2420f9df1eb2ad8ab1946ff111f0782aa92eb5fb9cfaf59a11a401fb33edf43a8b878567a2af00b6d5b7e957e4adde5aa02e46cc976dec5d453edc96575befa2c5a865855d1f4f9d5b1148de948667d16728b6794cb4a9607a917162ceaccc3671e18a43b1a8b94ea375ed559a5815b77b67b592c529e2c06d5fbb210c7a22ede472108e08cbe990f377be469f04082bffb5a947438fe4bfc291ceb8381c8a362e07747235c16369c7a78c84d59511575032b20a46ed2f35fe23fda0c5648ba2c8a913d4fcfce697401c1c0aa13981dcc01ebc3f508c3fe22645d8dccb8750baf5b1a6cc2210dbc367a26356b565c111ffc769113b9f8a7d01b20473ac17f0f45a7d1d23a60fc26b1d49e89706c477824e935b40b99aea33742378fb2b984aa26a786e30ab8585797881189ce10b853dbe363b2f1a244410d5c8227f25053f790f727397a614cf036c83535b54a78cb85709634fd8507ddc1a67d9eb177bb3d1d2a0a0dfc29835e859de7453a4d0bb6a1d26aaae0685d62aff9e20dc774f2f486a1c4b1aa32105fc9666d9dab1304ed6229eaaef9d47bb60b05f898468344968b7b4861c260517a82f1ef2f741c8f656b000315b9f7cc906fa753270ca2bf1ccbfd12e4501c1af74f6adc19fbef2e132e0d79054c275b182842bfabb0c6e3f8c8217f3fd541058042ee3915a39c02e9c2648d0712f209ed476b2ec1ea6a96de4dc70d53ccbc973ffd0548f2ffb6ce820baa2b5817a1bc1feafa1003cefc134faaf82296021bf6c03a5dfe4fd57b4a8da549b02996f77452c19b7b9c19e061f518fa6bd88dbe86af074860e97262c938047b3c86ee512e7d07bc51566a94b60f96a14f67d7df74c991aab7dea2990aff63a8195c1f520710f7ab8534ef2b7da7e570c5ea7d62730c9a82b1ae38e50c183ac49ba5374117cc3eeee98356bb651e847c5444b52304625a8869c0a1016a118be092e88b1c7df6a5247ed2fbfd5fba9b21ddd87b8068134d1b91418133d3c6294e6212e1f01dd332294498a4d5a345e1b3329d39493687cd05c7297dc178e43eb109c40a3b9af120370548d6eeb6e11ca98b9d6960fdf1d8aa1939355fe6f2d4e684e305624dade9e73a70e884dbe6ffc0ab93d150f0a23963bc5d9381d8cda1886c18393ebc0fc28423752f8784785b09873b1dcc8a7bcbe7ea46f96e94d7ca5402cbdc2989926ed5d34eebbd3cdf3a3dbc34ab4a2500db7109779a451c9fb636dd22395d9d0f18c3ae76f33eaef8de15d14ffbd1be5e870f503efeb6ef3f4f6e752718ee0bc11deabbfb50e5ece16af668162b405764500b5919b3bc5e77d9ffd18841b2e08cc069420e536038b6358e7f6de3201bf1098327e0b901c37f6fd0228abf69607af769f23ebab4f25939237115f733bbba06d4c9e6b4e377d7632f3bb51c89882c099b51f68a7b358fc137fa92e4c88a787359009fc521e967ee1debee8f4159d16d9069f29d6e328d80261b01b9e9ffdb46205e4909786e0ccc1fbcd1d0281a958e47b94701a226910797f99a8d98efac49216d286cc3569e76a6dc8881c69a28be839bd0a119e18125f8f5a29d6d64854e6b5703bff458da714ccc002356a836d1769db0bb73b17c662260482f7a354dc0c760e3d7639ab12f66c8a6c6169082377b99a2a3b5d711f2102546b14697a905c32751efe1473f3d6e9ae385284f3e64c26462d1c23bdfef2fdf177ca120e45fc378389175956ef7644c56e5c74fad085a1236a146c00ecad70e9a26d876f7bd1422e15e452e8dc44d42b68b482f0bd7165646e96312670918b0f2ccf019911e868606b709037d8edc6221b9ca562632af6d3b9c9835bdc2865ea418abdfb5a32a49e1caf31f6a599e0f77177ec5e2b3247a20f156f0f5d9b27dceaf484bd71ddcf966c92a7434031730c930cbd134a4b10e04a927ebc9c10664e88da50245a1ce0c2a0196f79dbfbf42b295ff6a971cef00143425af383552d8a9ce3ef2889b2d0780f648d8ff537ad41f02c8dc2e4adc8e169d5fd6470ad0c3daf27420296ef3a15d6fccd987283406d747b94b013aa4574fc2aaf48a68d384d76ffdef253b2d32fa6656da5d554920c075b3a3884c9857959d376696c9b3cd23ad97a5c180b73830bf6a1653cc1a5e22f997fe66fc9ed0712b63e83e92ab90523e64c86fababea4df4947229bbfdec9146e568b2eb2fd2ff402c83adc51e43f0360576b4edb2de588d744c81dee0fce4e16c403d33ffee774c116a17c81a0fb2838b37143f2db6fc2dff768e3243cc1d37dd1f4e54f89dccb77563585bea15da6b67dee9cd78d28156aaccb271fcdc74efdc435b99173db6496ed460fafac173439571e969c046c7fc1a99f16f075216ecd4bc260e6f21bfdcea1c96addd3a1e014e794489f282bd9f9b2c876e8104ff45a70a19cf49ba609e497f2908898750300c5addeff6be439fa2a3efe79f35c2a3d60efd216765fa0a3e928fdcae7ca91a370b1c24fff96cb640942ba939b608f9b3cf497b564191c7c71c1e25fe1e824cb3c9af5d9ee1767ea89d2a1c0dbd0c735a73654ac959b85f399f47f6593fafeb6a2dfb9b2bd81193898012a48d541f73997e7488155732c36d1e3f52230dfe1e247b720b25897f3662afbfc8a8a4b51c24797fecadaa302b50c8346180d613c18ed98bd080d506d105ea4e1f53ab704e3a35ed22db060430ec7134e5dc69ba7fd48a189b46108804d927dafdd11260144953a33b5b613f94542da756174b7d1b0231728d8e3566a6f18cad5c2744eaba8d8af08aa4666c6d810f31c25878f2b7440ad31a89e3fe28c3c80d965fa2ae4282c39807d8a7518e6b88a247026f6bc09adc63a2185e5f5231a896c609c48f815b933b6cefabca69d72e0f18a7e0431d494ecf13eb60f8cc5223cc5c99b69696147fff135f91b3e80ac2f84a835e49a04d00036a304c95ce198d1d7e0ab17396fbdd10e026404768244a18cbe91f6102746e4f4244517cbaaec88531f9da005491cc52ec8f33d4471d70c0362776d24f247b4c81e2941fe9d1059eb9d87500660473aaa53751d4938975c8aae331d0a8ba63e10b3523a6a10be9ab097568cf38db30ab6b72071467bf4cdc6425101cf117818b594ca1e84e9d00921eaf96a7399174a5457963e0dfe6d99938b6fcb4f64f169c162942710998e1cb704818483dec46a3699c138543789c99e74f86b9baf155bb3c0d0a43a0969d54fd7809605888690ce5e9eb3353d63480118ef540c8164ac81428157d30f6ddb06880f785efe39ad1dedf351bc41a9ece38cdeba252427e546a2033ad024a6735f1890ed4e6a9ae4ba6964d7e50f4bdacb5d2df845b7c5ff98fdcd33fe314ab266fc89b27ac61207d7675564ab3f8b3cc26ed4451ea24fad823aa3746538d6c9330ae5b283856165a52edd2b9fd695ebb088586264f2f124defd4ff6833265b333321f362f5efe4ba98c929734f522512e58a3a6efd3988ff74f82b25d864e45a7c2ecdf2e33d1d951f92b445aa3e61e0cec007e01c71288cc971681a6ba5879625fa42d4139344012571549857a265298196f486ddf2657d9bd350507ddca2c84429009787ebf56885128a452ccb522e00ec96d36ecaaf034a48681b93e34806eaab0f9ef437c7af3b0a009e0ba781266c9f9fc7bf50de1868b564b509b8676dde5d85d3f13103c94dd6bd850a029a49fc5d7bdb27e81cfee59660703c6e2ff10f757c362f6ffc0388dca4cafa56b2f3961ab39031ceb8458639d73723ff33ac9a5e53f1aca5d218e5b58066adef33da38a4b150bf2f39c2526f9737fc1c5013e66e8007e5b23f4001d19a83601797e6577a66c1381a303e3a794d1acdc0c5a0c03ef5f8e34a5d65e7e41500dcc1799a1994f2b1353011c664be2c941e9d351140d42500dc81b7bd04e6f63720542f8c0f817705ab78dee5dbc309020652ee329a6d829348f0bff8972cadc6516862ee61c2fa015bbc6e60c82dfd3144a9fa89907867e7f4d2a6587912788e92472cb6da889b79d0949a9c5bb64c2641c717019152296c71afa26f309b0f23bd03061fd03c918bd17be12a784c4033442fdab8e42696ea6f061690d3b45a3100ee7ceec8e0a70f01ea753cb9550b38a3023cc24230318843c7493c7f0479646acc3957a2376be3ce2d74d950d96c9c1980fa7bff626832853e0111ac2f275b0991bcfeb4c694916f420f6394660668501d7c0e37b093954b7c870bd5585cc1f1564ab57092f07c9adaf8683264d1931d3eafc75fe5c4d42bac302ede7595463447464a390317170c4119c6695054d229d7f22d1d9e0153243547f2f33d3ac7f4145058ddb1ec1960d2eb779b11f2d8ed13367d6a816d356e9de5775896d4d9a02661582ac90ebb73cc06f8b62537ff1ca588f4ccd1b1caba20049b1ac4948fbb49e4e2724932cdcacbf9adc135e714de352a24af5659e893ead9c078c8c27168df590849b37d3dc7471d2bcc78f7ecb7b6138ac86b6be0f720f7f54f4e735ba9a8ad4f3274e1bdae2817275da7345dbac531d26344c52e3494b8880e38ad00a4056198592443faf387e7fd5eb3d568164d2e0baf4fa5754eb5f97bccaeb804ed1632a2d0fbf040082301ddf788b1b27751825475c89d985cec18987585c46159ada0af6f60248137c200c458f52e853be83e858071733d7911096690b823f0727353f42de1dbc642bc4e7a32af8c87dce5952ae9f948f57c9c4c4f580db537f23a6b1400d7394a1146e0d84d128c259a3d1492588f453b1ec931cc2dd2aaa021fbd5ff669e7cf69991c1b1ba6d1040c1722906f4d135adbbbed24773db9af7b5385eb5316262f566621c7ffd6d2edc903f788c32d4312e9394e051b39be328b28e09b055c2f76086b37af694e2a474bb10da1509c373350867e981f7ee35fdc715c1e6e3e40a86a6e0f6326768e30020aa169a2b0343159e42b82cb9a54936f2643bc5dd4a56c22f51ef15a9385a53b77e2e00a9dbf8d90f3ea3b95233f1e539e0d8049efc715565a1cb44d9d25d3c6fef1fcbc0190e2ba693cac56fa4847290b27f9f705e071ea3ae9bbd91ec2c870220ed0a528683ffae7745654d11a491859be5d6640773df30a3372a2d512e2d3324858509adf18775174b32615b2b4bb95a69c7b3d38b70d8f79605eb69e67a74b711b502aef5fa57dbb14ef788b4bfcd90d2167bf599247161ca270e9b554c87bf31ecb78ac81e57a6b06f359a325fa8e60ee5fdf03dcef94b9b3ecfb3dc5f8b7f3bb4de093c836f1f83ac344f4ebe02a01ced5dac69ca0e6078069efabce9c4104b629f2360abbe99917e5a6ee458d2ebdcf34347a80e97c8c8133c974bd0004c46c6def34ef7e882ad7808f3308103489b506ab4dab53f0aa8d8e866d0db51c1baad8b44ddddd5d2b1525166167fb2a67730575d155ca3717713fdea0de88bcf0b4e5341e9aae159bf65152d328762d341ff18aa39d05d09c573438abcac7863e1fc69f9adf6c2c326563ff2f8fd37b5d6739b657aa32683ba475781da53651206e83d71a0217316bc9510c4dcc84159ad55a45fd6b05dabddef1127f2e6a314cc29d1e403f305f30e0a2767e63600c4f3b2400e641da1d3e3e13c781d4f6b396cc4c83f5578bdb6aafe1d803aef2b6de0d5b8f897b8b29d1f74efacd5628399760e7693fc5e7b42556a8c2557322c8fe0cd7e712022408335e53a0ca18a510edc092ed4f43abd991d53c880ebd0e1db5c352f3cb1f6eeff09791ce36663da7fb13e651b3c0bd17ec6a620bb1ce7ea302766a9571a190b1042421303c9cced619edc7f2d87cb7b49818dbc4e00eb015793000c594ef329c05779845611598e024d3e2ee529f3ab83976baebd99524231e0a0359d26b9261d4e61dd87547ad6c95ee19b9293ee6e393d7d019dc25d40c3df1ca7cc837ca5b345284269c69e7808ce672e9ad8bb7cde29405d296236369c1ee73347bba0267e369c9288f5050384703aebe696377e2e24886ae2a7efdb2ec103362ac9d4219ce44589d1657120b38753d8db963864169dd15b6f34eb2440c00ff21d4a549f34c293c575d5831e433f7ccbb5b855d0b6a6e5893ecf08d901b8e73409fba36967a7fffcd09d02cc090e8d741920b18a8cd4812fa2657dbc0f4ee8d8dfaf457d9f24bf36e9d916396b194f8c2bfff84d0d3603adce3772eb3d32253c5f4a90d6bf921ebda2599ed8b9e00ce8716cf1e23d9e7d276f79e801691dd90aec459e6f2278c910fc5289bbd76f782a6c291aa5aa7af69c7d9193fc8a0c152071c263243789e2d385736bbe2ab1dc943cf1648af6f0cfff43b3bd62002de4af320f91b4b877beb0e2d4d43f0a9c6553e7bf0f720298c6488031a40a5e61ea7e55717d27d4bbf2db2a028b885ce912408423e36aa23f83d1235af91bcd230ee79f759bcfef34a370811372398b0fd0f8d307b6f1a9f3f56f22e18b11eebfc5d1e9bfa6b1e6fbd093c0c6920a4c2468ef99977f4a0471fdf80cf2bd2a36806364674efd29c0b3029e5f3d34f6a1c99f5bd743b1bae70df551748564570f884cc3ba9ee2485b3360f0540af6a32286b50d13f571733e2dfeeaa9f1eb5104545195cbd650661481ad5114d228da2118668a60cd0b04446cabc687bd0052d755640b707395e99b0b9f141ab34e3995d64ece0758a86180a1e00c1c9ee77b9e3f629c4216896150d6882ad67ca433dadcb9eedf1bf87b9e92c2f31bfc9ae9cc00d3afb098fea2aaa132f684667108042328fc5a4e45b0dcb1b84665744b63b5a24fc796f981a4185b2f895ad4e17fe46a4a4a3cbdf2206b2266ade3c7054d193d533c75fc75000bc289bff9b83e553c1d02f0cb935be725d3f34bf1fdad73a0f9e59806d58cb74f3d19000675ab6846fc1d22051f89bf4ff0c63ed9f1c4ce886f8e774da1a51eb71b89f3bfd32ab11030e55b17d64e80195a303a5e77a2e9eecd114231c9a038a975621b7f00e44b7808f58b5e5164ea622452e42a0dba51900ab547ae6bd2a343497821c8214eae362d96d42c04e1838f5f2fffce8a08a94822c2736bbebecb6c5c0143a71fe4ce333885c7866c34e5435188c093b09f35d0ae8ff94c34061b4e84939dafbb8dc49211285ce76dafa50431c24a811906509c2346522a7b2d54d114c964393a14e97e492398cba4998183ca3812ff4bf73f3c7e6afb7bf66c12238219b42b42c1c033afd2896227a64d72fecfa6a02ead430fe51eeaf677b9aa9c633ff6722ec6c8b96fb3f0c20f52da9b5c02cf868546ab208315dfb4de600e85823b1c84a780d5987eb4535aafecca98d8fd499477f9a1034390b96897900c1832a8621971bb78a59aa317458c1df9bec3bb12d52417e45baf2e4b5524329b7c93f2861d0e87f01d20d7544ba46d6e2b610938f1053dfa40d42dfdd30d0b2a0f4aef9d248d7c2d813eae9ce3b65e0707449db08b98289f956e994381ad96997723d25599eaa000fd2f860d2ae12bddc49852ecc99b5517e055c0bf00992d7d0f669d0d21c0adc57285777fa3cfe9d60059aaa90dca7c6b347c4e84b8ce9e4f177c30b4b7aeedd8a593ef4e2034582f9f5be31892053942d4efc5abc47722bf6358108d7af6c7c5a3dc336d5a8a3b001d0a2530c61fa6319bc6bffc001b3983131a27577d50f841a47894f76a0a1e4a8a9d7d19da2516c00a9b555f8d4132b1714348d4e071713738bded4922dbc57c0a5bad690817972dfc2f4d78729fd64807ab79dcaf210ac40e85bc7933e967323ea75763d3b7398534d98662486674605abbeef97e4dc0769cb5db105f2ea56b06e09f495fea366935ac47c9e123c3cd98b81ffe121d9600971d30792773857f8382cb6dc5575793dd503375d63fb469433ad7c5bdbcec057f6d0c393dada6f59ef28a06a9b1ea88239035e359375e1f638c73a69d25ae49bd8cf247fb82ff553e9c0b3c1fbc12cf1ee84850987cf40cf62f1e1bcb4934953ba739b82bb9c2d6a9b992dc48ccf7b2c64a8a66a0a716fc5d65ed06132fc11c1c4781ea5edbfa477d077e1dcb4adaa1348ff117f019e5b284f8ffbc9551f7427de95076e7b59ba9d3d83016e316e787ff397c68fc8f53aa7a66ca33996cfa5fd9fd61fb1131132b841ebd99949ed083a25f1b8d223babb245f4e94d13868afa7821e902fc21b319b829ffbef5778dbee5e6363bfaf236319d42ce25e0801cdd845523208489f35ed9fc763c307d63414f96786f2b76dfa1d1744a46ba3fd1a06348037a0eeddbd1ac708e88292599341b65ed73b276b664a7767e23f042288d169c5ebadb5d50cddcb99456df3356954262b5c8fea36d24a3abb69411fddd7cfad42fcd0926e73e20d9cd271cbad7304dcaf513c544c19fd8e74b28258f20f31129e9bd4267dca8a6f869d15efa0b51b3745d7340a9a014bacbe4721f50e61af0eed474dbbf30688df52a09a6fcd85451445168f9109078d18dff8fc12fe5e43fe443d7121251cf8cbafff575d4b1ace7bbca2a3d6755e0145836743d740d3b5276ad87443b17ca6c23d3761bbd38befa197a03e17d7777b95f9cb9ba38bfa9d92dcb31d15e5f526040497952e72b80775e3d5cc32146a2c114de210b587277c8ab40099468c764635121888e7e3d52a87477844c993514eefce727fb37b4dad2d8a360f51da2c85e68b793ef27ae56f5da838573c6bca559e60b031d00b4966853f02f308add3bb8d6db091a163cc815da86e93ce040fb8222f2cc7d3a42dae84bde3503efd9b5caec5e6da3f738b697f970d45ea83a5b36b179612dadb24d8921ef47c99b1f2a599dbaa14977a5687e62b6e1e85ea8229f8c9664613c2f0f2b93a87725fa0b52dacb680ef8e5fd904463a5ed49f8e2f2cfe3144dfc5fb1007ccf6dba6933e4920fc511d0a4e650bbf79db5a621c7fea8de0f96e85d11e13427df22f24819b31c583f998905a9b13854c7176b2aaec7e0af361c5a6d682aea406598ace81affc137152b96c22a0b9a4c54f8191dcf98f1ac4a9a660d25680ed045b2f6144235be40299cba9f2f758505256fd2fdea85a7a041492c6781514856616ddd9235a2d79fafcbd880c28416ee40ce0753007e92294ee57918bd8cfdbd9467789bba9154aa4b4dbdad0390015321dac4e9c1e92071f92c20510725a5ba9ebe2fa852fe1c156917709407873422a7ca734ca5b67fe6babd36a8922c34f548f6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
