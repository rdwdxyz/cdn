<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a736a4362ca7dc47c5bd0b8ac5e4fc9de97d9b981f27aa44d8bcd2a1243da54633ae545eff28c3b3738127e750e7c2ddd77feee27f34d3c6b534261eeb408d95f4202df7ebc724c23c9e105c569ae12181498fdc10a1faf687aa2a33c438bd2ea87374281e27bdca0d57ae413ead32c3b7ada9808805acaeec09e34dcb8c5bd88fc339457fa2b228b0b2ba9d8b3259d45ce93485fd62c0e7dc5cd332bf2715ae9c4308be2fc532f16d50259883c6ddd8fb7f3af5215abd5808fdf219578eadc0cf3fb521e6c0cf60b034130c048af8be6f5298e68141f717dbc0bec8aee5945077e849f05310dd21756935c4c3e6f924ec61e4177a5895236968fd9c51d9608665dc384b6088783df5de2e4a6c40058ce82612c084159c73f5443b61f13244cbc01f8c725deb3e8416116e528e51dd44d128d802c03904004a2a6034005a57773b25424f3e8bd939778b1e20176ad6cd350a9b3af9ec166c589c284e38e4cc17196728280a41f43b8886dedc6350e5b76dd04b917c0c9a5700336a6574aade0f81bcc2447181e85ddd94b826ff4a765a27b7600e216bd6739f5d4964713a7e5678b7be6ac46751da1f98da558f10c558d2b812c7095b04acab2ee3ca3756c8b5a288acb280339f478a13a2ddbcc170c7eb413ad822c16ef4b334722f2e753cd79fb8d3b33f03a97e23aa1430084b5611d811328a3346fd34db1ea982c7bca6e0a16b5c5cee5bb54f34ed5d66c8511c2aeb67d06f83195e299231b0f39aa396c59e6d40a569171d00a2b335d6d7c82797123b9c914ac04b8e59a19397037634a45d3f0485061963778fbef171b411f24906c2c90cf1c3bd7234bd6a0db0a84cdfcb0ce7591082d9d635057035b644d307e0aed28f72d51ee9e496bc359e7cd37dba2883dbeac4da2c4721fa7fd745b465139d06de17b29c9db1292e570078e2f2fe861e13a1f91ae6c04a7bb3a97088c5eb8a6df7821a010105e5cc367e94a536067b88c929fc2c56e65895aa342446971fe5101291b4219b1e11cbd71f5fbb33508c6971c8e34d9ae785a15bf5d7474c7901088b90564b6909ad756b770e3c63ad287022eb3d052b40aa5a8a280ad4b222c595af4a1f2e73eb8fc6c9e50d4c9e0db8ebd7a91a56f08f36f55d028d15c812c9a3e7664aeba4e37c6454418fe14eb38a4be2969f08559533cf2677b8f70d4e78d482702dfb4a4f53e02b34e01f3ab990b3999e77dc1689f633e8707f689ae4194e899d01a68800d20e60c171a52c1ca84f3a864ca3566be9ffd05a6077bccd29567ebf880a8d9a2ba769c6780bb9eebd9688a8ca1275da486dabd97f4c067ec14ea8741bb9281de4c76489c537f68bbed67caa857d22160b919e0560316997c741a92528e65d8d50c8cf28852f681d6fec3d07e9bfa3a02883889d3a99a39401103e1fa5806227bac8841b04e21d76e7782b795e4de9e72a7459c2cb577d85a648d7bca8bee18ac6515c280b5700111ab4639a07e79b943424b7a987b7bd431fd050678571e068d86187809f4d9035e51e6fcbdc56c11baca427d0c050e3ac614ad51fcfbb2a45f0a843d59b3d42a8ac2824bbb9cf530143e4799e6d34d92ba8a51b595c11296a2916404735e5827859e87ede338e5ad52d5515863510ad8ebe7894a31100927484bab23f124a5793bf9b4fba0f73d2d8729b0adf68efa81a2edf78dc89d28706003eb23a6ca90fbe67403e76919a464c0a2531377e6cb6d831948109f944ba19c2208fbec2cd12476ad34ac63a2092cf34041d023b15ba544a38ed9b5b1460ac38b55a62bf12852f8505be3c3d2a6129d98ada4257e4ae2bed2282b2f5ea6d6fec30c262a22b505723a99d5053ca646861afbce94c1904cc2b22208bb569e98626d2de9636ea523cda8f0db420c9b2c312c60d70d6afe85e7a21aa797b0d678b290fb0feee2cb1498e23495157ac3e769080d2f313556e837534d6a156be73fa19836caa00f98ff8a3345e5f15f3ce7efecc338397308957894502eb8dcc6906fab3742a59e845a94c96ee7ebbbdff00fb5855da85cb534120db08b3b041eefcbdbbaeddf66e25cfab32c0379078a674c82515a6aab75818a751f7f88233784080c78863e6975f42682c7929eb0fa364f97ce2bfe6e0f9cfe1ba7936683b95fb6d69f727d43833da782290ed83dc6de38a6643791ffcd5142c7b3609e42d5ab519425bc111ae1aa317a5291fdecd1a186ca7ab6442d2068938825fa3e0791b9e5bb3422b3b8aa20f864ff13a986833a0be6ba43768561ed76fa1dd9f2a9183ce00143589eac365f22b053f8324369b4b84e3acf4d621259737a3ed20b4812d3ac0264b258f46eb59a7c8772a7f1fd874a2556a9b5716bdd9618ae5bfe60a0440ee0ed38f5cdfe483906d7ed62f94aa06ba5ac72fa8a2a5389b250d3af73a31c0bf83d5385adf5bd43ca745fc6bfc08e15393569de4098012a35f63b383572c5196c412b698d1b8333d821be220a297bdd32ac942b1f5ffd34238541a3f9147c815305d522646f35e56f37fa2353a0b3d5adc78ab611a1e3325e98f17a004224bc5108824eeaced8acf78c0f3004dee5e5133b1423bd1c665b0192bc9cc6129f5ac8d8eb2e9fa1c4cb5b0973a10d3e2935696e85f4cd101dffdac7b4aff6778e67dfee97905a4b5662c457678ee1e6ee65d86c16987e2e4e832d1c21bf401900e7445bf374ad0b475c3a6556b47304d053162a851bffd51b7225b278e5991ae0b7863d4afb11d89fff98e99593eb2e93050a9c04157f5a1af3289c53e4da09de4d349f3bcc4dd5d09cf8c3e7d3f1017ff323a516643c29ef48a072a9bf5b448611657e92ceace800f67993f21c56cd31ee21607ba80934892f78415bf8ee8fee36ace1426f0745549e34b55904c41f82ad254af1921cc1c686c7c2097184ee86f5e08c59116d24ed5b1b51cd73b2192ba26265c9082276b562d22c478dd0da317a1049c6e190a9cef987ee9cabe9fc0a13ee51b9411aa73347d029c4c06ccc75b65dd7c9cea23407a00a2c315a66e5581c13e83b33d5803845b7c63fd42db8927956e6348c6720ed8690d012facd69f9aa3a07fbab4b5b80b8ccf3024a69a574645ea0af76de753409883cc7f9531072eb627b33605eadd7758fc458e9594c78ba936c7a53e106935d9719989a1a9198c44ef45f8e972016c7ab7871be94d47e7396d8d2a903905b8c588bb4facd13b0334337827006b039324db62c26952368e1c4e485cd309f0585dbefcefef2fa88b4b0ea29e7b20579a7a2154799f1923caa8534fe980048778ea43481c51e043caf12641df3e22d4ff6fad42213e9ac84fb3a90e13832faeee1b546185d6526a71478b8822dce40d601f5d356530f15fdd77f01759c6a4221fb3072384b9d405eab04ac2c64499a47fb21bb2af14ad58e6f996fd587eeaff9cd4ccc1fb00ee1f1e7504a5c92c50e258ee5f46a57da714a9a6ff8431b7e13c941676636a503d77b9da1f35c68993eb64737e8cc921b1e68589138ffe875292045a8cc68ee18436d32eac0486053f30a03282b0de11401f6b6c31c50e5e22be1dd5023c593055ddf624a6ff0b994d2ee2075c285a48e75d0feba0ef2ecf8431dd5a60dcb6bc89a8e0cd25f624bf96741b6b20b334aacfe6592cc885d012d2d119d887c46597cfa735942dfed08f9fab1e170dde09c8bab8e07d229b20b9e37db930d8c7e4bfb5c716a01c5bc7bfaa8d916a14aa5727376980349ac6ea3eb10a18dd87babbbcab6ab578646c0a75fd1dfd7ddcdd2f449c460d84092d002cefaf7f97daa0bf5b71a8ca2e82241087f9a38b44b9f5a983c78b09cc965be22c3008453f9792179a82f984c30fec80b118d5442dfe9990c12425802fd0a7f66a20bfde37d78410459404a0e1c84a2ca40cee48a63bcf2157e6029f4f04a203bc872e6da2bd831a03c953765ca33b0551d37dc005b61fae0ba640166bc947db720dd7f5b41e8cedbb794fe9d21848eacb1804ce9d4a593a9166c651012a1b123c5156448240f21cec7bd9879c83c2b2ff0ac8f1ae390fdc16997de3d075514c81afa79189cfec5cfb1035dffe37a096ec5d0d46a43c80945c1588d71ae1fb40493f8f16e5bef4e1bba76efc1062dd44b75ab298000efecf0316fdd9e9fe40d123bc9e99e121524c7e11fa2f9fd8fb0c12a710689e4ff2d8d6ccb8137aeda905715d0447d9c45a24c11ac8a79964d96ffe2248ffad79edf22ca0afdd1988f0dca5846de300c006d078560b38409b2c18512e1bdf427be3f6586e62511af3aaa11bb210223e8a6c5c80f4b4a643c99bf5922bb7ea8130c707f07286f1a4101f5a6f91af4f170c04e959369c30f7c3d3ee5e983ff4dad25746c993608f19de3f157553d6d21a65cfa08f3f732f2ff463ee01002dbf16db3db680f3ad55743323306a353357629fac80b8c4d3f7009264e47219576eec9cd798296f3f9692c2865fc30e1dcc0afbb84a395b618c9f3e27463b01f7f09fa1ca37df32808d2efd64bbd0bc933b1c120f55629710125ec4f8ec0b89bb96b1695c5b1872b78a3dcad0f6292d74b3f9357f00b1bc59539fc3c52e1392eb10b891fe1c91194c76897e43d5654b38a9a5547bb82314ee6924c90a2fb9b7e5d64f6ecbd57850712f2b9fdf1f0cd8eead86d3a4576b611730c5fd0d24e611104a4a6b8f1d5abfcbf3e0fb95b5954812fa9ca7f0d571bdf01e65352152e6390bbf67ee60f710d997fec17af77f75d165a24a1b31b38a4b331631039b0713db2506348f6624ecebabc6543d52856850f839d0febaa66f7909c2d0a5396f8c7b2cf650e0477c93a9beedb12ee37ab9dd727868aa33175819f6a6d80119fe80488e22e03f65762c1e1d1e18b3697d6c03cf2c4bd04e4fe2b94e778d5918b8545e2649829c708fe38ef664e7fc3d54018f732e13d6b50c37d7a49b4f31dda82372a8548c78e8189563f9da8b2ff3666642711316455e910009ffbfd757f5edfc1283147425ed86c64a4467be48d9b2a7b2be643bb831cc60d6442d67a3b2aa6fa73e58492133dd18ea09cd9152d1e51afb0d42c53710cf7c490fca61dff0fdbbab135b9713e688b68b6b1e26b49747d490b030b63858b248c25e35075a7c042febe48fb8ca24ef5fadcbdf8d464ec87e008b8da5657a569f30877c30c2efa2f2139c48111bb26945dbfd1b78229c4e546f8b35de8c7d9f44bbade05f2d0e45c9d2c9c4e2156a127412ad49f445b13ed69758f17d4fa83c93d4d9bd3cbdb950db27abf380524a2a5cfb1241ad8b8c0fd70ab2ff8ede8a771d6659a652006c6d11a9eb9633b77e96b1d05882be406293100261cea6ee3470f875d46b79bcd39d57d43c3022fc44be140b04007ecca8fefcccc0db3f3ba2182661fe6e780dcc2e3ca892982e1cc5822f0e6d60d3ccc2ab0e22a124fa03524a86b790b99bad4731695519696753899f8c512a28dba77ee9705850a35db5b5ee02997e138d3eff2c889056eee5b3ee8501333584dbb34bcb43304455fad38a55057b60521b519fcfcd8d993cbbc9c05fd8b9a0ea9d785c24ecf43ebbb20141be8012fb1b197d9267665cc86044ee2afdcbe5747b924ab34d7af7d1cb9e81350c1403c757bac03fd662c3c76e89325564723f10b621a929cf16a37779250d24aa07d73e7495a9863530915a44feade2ea02e7fea0a2a608d98585ac3df3964c4dbe73ed0a650a26d9b2e690531dd7586994ee5c634c1714d25258c59849787b21b1259e3f243b4855aff5c78d37df3dfdd0d301e49472bac0ead71b63cce07edadca29295a821dafbf583a7107030d04e32b18d1cbf522ae28d112b7729ab635a8443d1cbe97873436b3caa95ed086391f698d50d0f44074cb293c4913ef5ef68b58ece8c553718f734a613b769a6199d4c0ae8819d57104e2db32484eee3aee56f8877ceb7c7dcd06464c993febe736a67b8e9939f649662e0771e569086ded1c3fddcf7ba0c79559e53b18c386f9b1ce5144378c257ec84aadd2f18e3cd0b6db61175a299db75f5ab3561e532031de16b581e04fd2be589c1a1bd9cd3bdb07c65dcae94175baa51fc357937fd55a414cb6a4d7292c4c2432abceff6aaa22ae73b1cafd2d2836ca109231a57adab8861f3f98cf775d13c1c01add168abfc4ea146213670db4a2d8581327cc0d5fd14374a6aa546781921ad1efab9c0ab3f2c4e7e4c5ee6b45da8e67e6fa0342edbde1d5621cb4ee6c92b2ef9b4f26d23e03011d3dc6b75aeff718989778d47aa4da9a52e216646495a15d6d4a5550baebab138d95073685a04df37380b0cd328f1851a71cd715c9bde42cafc2c79ba82a3e30fe676a7205643be0415375b4580c8210a58421e2df236e592c0117f1738e323862c65cd2dfc4396e7e1523507d561e7825f5bf8d486e0d30226b3c94344580ceabb0747e2afe7705de66a82800d3ebaff01e0e25417095bbd2bd1404699c0935c63f9edc23fd0c273b95ef365b77ebc4eea35bbccdbf3c453282098f8f636a2e24cefa4462b49e46b8637b75add8a1b2670f5100bd61ccff2a0572bdb72cee3d915ff04b7003771ee6bd69d7ba00b78bd463a383a2f09c4cc14323dac3b10591e7f3d8f381623b7a21902718ce9c8b520e6e5dc93bad54f3cef1a83926bb5e56e437124ccce67a7df396ca7a5b459ad164cbecf6a44c8cdf88346381aed2a76196864d68529425c4623fe03d51c64ad307bbaf90eca70d501b938acaa10ceae1242fdce27cec41e2fb98c01efb84c8212cd378949d59ff42294b9c4f0023b960f7ed54d1470a1a3118f0f216e939f1fe539712d0b21d36e139f11866404645aec1dcc890d4e38056a23dc6562a376399b8a5ecc23b682490b36f5c166ec279f720627ee9c77b60f668af97d6cae86524775f1d02807df00fffb2b83294a1f22036ef4b77758d3b90aa81896ad281afbf44bfeee082f946ce02343246db8c40fa7c897335d1f113b026da593a0d3694ff59996778fd26bb3ccf47695dfa22cac283ffbf63be8887f2f193c1186113ea775f0e6f1ce93fe1cd9d770bbafcc36a7921ac4455510d6f510b06c4b4fbca504d29b772fe305156a12ef940569a2362c19b0c85a308274407b3f32cf1b14a50933c214ba4c223cc1eaebef2d46314329565b61e808294669173d832c008c3b89d925e61b141cb67eeb6be8600897786670a9d89020fd587a8d8d21e05c0bbf854c74c04f0543cc0622572f7826bb39dce9b6dac59a61f05c8ee1875e22bccb364030d84ab723154575977ef5ae1b11bdda1e30578ddb7549d591221d5c36b352a5ad9b383595e9dcb73fb951d05a93cad17083079b3e27d5a16e449fa53347e13926413450a62229567468c99d99f03cf450fc1eb4a878f302ac132657021bd887f60469c3d8c664b88a69b144a08300e481400f7b2a7b7bc1a47eec159ef9c8e26fc38d0442786f345f9a598fb06364df693d80808cd1cee0bf6d6590130787405992f149632f83630bfecbfa31c17458c7f73ad0677133b3456f3ac8ae1c27367cdd7fe33f83ac4e0468092e4323380a852454ccc4761dd4e7f8bde4ab3d8b0dedbbc249df77eb33b7a72bb60936f6761099b54145ce0195f2bffd7fd9e83291478defc5953842b5195dd5fa2ca9189d16ce6742b97739c985bc26653df83d2c8494e79372228763979521b9ef5afbe3602d59a077910aca96b3353c7647ea83631a16b22b95e4c473636aacb73212c052047a2b6e7924f1bdd41dfd52922fab88b53c42edd12184a8dbc116289dd3511451324b3908b1eca9b63ce76e8266443e199f4049423fa07981468a1787aa9ccb13f5d6c753da198ccbe441a97edad63d34710d63c105ba75b25131d890a919be583842acdab3ee3285793a68818f9bebc8d9b3505b953122e9ec4c965aa14796357d1297c48b458c04e5b04ee1781d5d65131b38ac9987f286f5a8d2c8db03f0c57231e33ca2992b487f4e22be3bf8e0dabd7f35c9e8405ae37d9facc9ec3e9fcbcb18c330e60326fdc57f269a47aa6dfaeaac68bff73dea14f5ef4905251b4e4ef44ea00d4ab9da847aaf54fef9d8c4a4280ffbdc668154fadcde5c6d2bed859f8ab2b33461d647de56ed651942546dcf3966d9ac23516e6a4faaf2d467e2d6ccadd1fce40f30a57cd96c170dcdea7900d4183bb177f5fbf1cc8921bd4b8ec50ef32ef8c416db7dfeaa5496018f89ee67154e83ed2f711401e0220c263f0dc73bb605539376785b019c56b3d28e33d9a1269abb2793032f7f6efb6e2e08fbc4573d1bd59e7fa96179b4cda3e8a4612c160dc9575f14bf988c522c9d1ab68a40b8c1268d4c7d84e7efd9d6fddcfa65ffbfdaacc52fb01e4758a266e8a1cffecacfef932b4bfa81c2e009c78e4b4efa7c389c83a303e2514a55c07530325eddf9507fbed7ab071a5f20f25cacc8ba1f5b4c564faa788e84649e396b26e45cb6f2e495bf267bd898dc2f4c9112ed23923c3b4c416feb032c8da98f6214d59ef3f6174f581add448ade97ceb44b16155779b74ff67aead1f3e8ddf8db4474e350aa08e46238f561ef5cdab4eaf129f172004edf80b1799bf9a95dcc752c327a1553f25ece3e1417cbcbfe9baa90f74a6a36bc174747591f997eb6410132b718df305be7da4868a8edd2a5e5cab5325bee3d2eba8c77671ea3b101fe5b6af9dee4ca37033b9340fc76fd07108eca5529681cea9d1bfb4cbe64f673a15f9b6e183f63d81020001377cd77dc928e220b0a0a2360f8cfbaac0612b5180080892815820d94f19958a845775e82b33719a6d82015beff713a00c3f6c3d11be45ca9e916f75115248b7399e913cfe53d9a8b5788868c691c6cfbe0f11668bc3bef1dbaca558c0ea883e75b67931791a68139abf371aa3c3232952b6b2d452c857a52d10399aba78ec9dc96a122e53b740f2cc3735872ea619d11da9b46c18cc80e5b00c1d05667cad5a6f3adf6945c65baaa2c7b0e5dd29fdf71fc26d1e71f851644c9366fbb9ba9a06b100b272699a7b218b1df79b5452a798c393dc07109a23777a801dd9ba6a983eaaba6374aeb2052d3bb3bfb66cc9ed93ed9143f3ee4c25c8109cd7581893fcaa02391abd14225f9c6e9af939e32a9363753b3248d3f4c1792a602174b717da3df4f7c996c867173dc28e3e88843b6de3b8eaa328d1e5b31999e4b98d1a20a8e9a2dfe1688ea434b1d057d80228fa726c679359f2ff9ea5902d748d3823aeb9600adf23b873c0b64491233f87af364ca26b2e1ff30ef2cd45f79d7d300782bfcd0951bfd9a7cc3d236f1c3a9a63a07af4afeaed9ab7f82103fc7b033cc8b1ef9e9c38fff272b7869241141d424590b94ee9ff42c9d8bffe854f45a28064c1f4d21053e5e9cd4e53785f3c05ae6420dd3010a1cade65b5a187bf11123c3a495bf9a2ebd5fb214bd46e559a6dc9e545022de90ac01c391bdf20190f064b7e6bb8f3ef0896d58470bb7f57016926497a8f6c577c35b39e80313059b30fd20433ad9843b2d507a8fea98ee814be5add4c89c2813a1e8cdab6fbed6db920149da0622d04df5de569190cd333ac3c43bb83e849608f76fe3a8431872be7ddb0727a721ae850fc751560047f3316521d7cfaab841029d5d8735184e732f29d857cecd0dba407d139e7bfbdb774f984375c358ebe319e73733fd7d5f24658ae7fcd06f1c15d2480706fc7e396c12efa1824bee43582691389016a70255e6ced1a9d0918f01a15bbc3fb85d788ce9950910edb469abf23b37bd2711a5412dca95d9919d07c493a296d654797cc3af9da54c117fd6db0cd3d91fb8385eb2f40dde3b1878c61b882c9a1d7f59bfe2a835e7874b02d0871a47c4ef3dd03b6a6bad04e20d929d195b63552c12c437a6fe3e766736f6063db29082d984863f1c6dab9ea13b54d8d9e739ad026ce605909830234a780ce705f61b654bbdcc1b4de00e7870e73dd497e78af88222a5d0ad0b3ff9318f1553899d3cd444dd7d9c5886b2d9862466ba738114db282a5929f67d245dbdaf92a8b952fec7979f0d425fc0f1e09034cbf6bfc9e05c8ce884bd7c6d3cc5c2a7c64def96f068349d225ebd017f2c3fc90e9a46a2576bf462b7e3e2b5cb682ce3ad2f2464c3793a3d9933c52c0cea1053b85a5f2173f144ff421b0098860c5e9eb6b425e66fb4f3ce4f68bbc11923318ca92f4c53448af1d1f6a99c8fc632e1d34264a3a6ea2b9c88b6e358c4b7af398a888fc7d053f9afb6a716c0922e6ab55d8ae768870e2800a5b1f2466a6f99b14766e4694fd1cd81a63d985a8dac97f2a0d920050ab315b2d10e3910b42f6039f9d164b9ae2a98fa2b52480bf8ce18355a3f60bfcf42990ee8e59758995043b61668508380866241f9e45e1d5a86fb61c5ae17514ce03ad0c2f2f3198a5ce92bb05310d4aa6ca5fb1de9ee002c9601402d3b8f8034ecd2d13cca837a816e6f50effd172d86638c10188aa8b7e27eeb815d02f358eec4582b566ff04ab184bb2fa1ad21f2861f98ab5e7f56c990879b2bea76ad6e55c0b858f306b6f1a3adf1ef1e7a09a47530cb6c22adf246f159313865ea4cb2891aecf70c5078af4d6b0a76ed0a19011632985db30e595fcdeb8940cda050f6bd0cd7968c871b6543e085e233fba5e9acda7f6363bc9b7fb474311afb1599e45367dd7e46243ceb5490d00c2f161c2a04a99316dcad27da4c43f3c6efc463f120e5d0b9254f561e40f6e00a544c3e2789e40ed43b6114c1c5199f3e93fc1f20b3d341c01d1aa9532efdca5b01e2b9e335f95705d523049b24f02b78b1867fe9612feba5036708541ad9ac78ff7a22734639a04c435e23f65a01dfd842ceac3b36fe4bfeeeb98017b92efbc69f13d60c1c27cee9caf021c2705b3b81a4954a76bd2550eaa6ed177b69d93a2b2efb847d86159f0d8ed96b8a97ef909258478c6d268fe9e7d211a38b0b12dbe0b58c9affd8abcc88fba85d56cca00d6eac32956d2769fb746c0a38465a613b224d9ee25958d0f9448e162ac79dbf51ebb6752ada01c3df8abafe1acc44337848251c6b937a9a5282e26a28b8408672b8a03d3a8ccd20fc7b535c0b01f1af08c245a13ca09b9db2af8482b67136623ef5facee2e49411728c409eb6d5cebd2f33b9a4977e306173896b2544c70d1c7e716f363fe997157a0b41d0508f045704f923dc1ea6436c3e2377c84a1cebad3f73bf192802d2bc893345843dd4e550160d889b73e180cfbb61acbd5546cba9f8614da1bc544ebba81bfd20fad37fdfd6e3f424cca9b216969cfc1fdfc3ff02d5fb83007565ef6eeb4aa613e46a21e948f0a6786dff81d66cfca56fb0cda96e78727aef027a14c3e52fd23e3bdf8c266504ee2dc4d63411ca2702fcdaf9ee86b1414caa0d601d74dc1c0b0f763e3b3b5c54ace500ce63a41daed98becb298c240eacadb189aea5d1a6cf2093b491d0f822b3ca475ad0f52abbbf8348ddfa342cd311acc5a39c08ba598f24e57b677281e058ba21f08a64e1b226063407e3e71635f5530934d3e8a9b1b1f3ef51beb73d8e2065a9a691a0bf7d540d83cecfe31c453e74c317f300df8890eb25b513bbf3b7a2f97fb31108fe347f350628f6444a922308883321ccf408fe04940bdbed4eae442f9148ccfeb498abb58fa4eda7a850a18df129b31cc1e2462a3692815537e48fd9e379af6f89aa92ba7ded0a5f15258e3ebaaf49a3be91d01dd5490d4b42464bdc208d946717082ca4e7a9d13dab6b8cf53fbeedf3eb405a81b27f2b64730d73127c4805adfdd7bacf3a7d764dbe32a90856e780f52c298f363c793c767b45d8905163f761bd96d532814ebf70ce61d09af79ba527283eedbf56b09667e544312d80f8ed672050556c23044e5d49d117a75de8788040529c03466d59b88de700e44e7c18c39716c3b2fc045f7b7e3b443effdbfa2e2cfb9d2ac2b63329adf7e1a1d251d9251c162547908749a2509967c92f773cf454825401ad81f090ad4cd1aa92a9d380aaabef3549bd90b0342b26646338d509d71d059fc9e67a867f4673d5f39d431c268e4e93f87115ac5607d8cf3ab31247597dd58adca29e8e38c587c6e7f854c5df2eec5e011741afd96130122d2bf3d66d4084b30f071ba78ec842b1a9abd39b7ba100c334ea4a2f423d64195ce2c5e2ab99516c78ed0c9a9eb1d4fc6fade0efe0a0bee1d60bea65d0866a9ece6c3da980d9b1050219dcb327b764d63fd2ae92b3d316a9318ff5e77a6b86e415c23c4770f02875cbf38b6b1824ad58692e3d6705319eeebb9adb7fe15708501ac056e86fcaf785d26b637db6ce7e4eb7d67a2870811c182091cfbfea095d799f774e9f1fa8ec9086e5beb1e84e19fc907e6ba07a92eff6307887634519571ddd907060756f97b645b73b1fddcda4cc1606ad5cabc32b8abb8a4e9f0de9898e1a06a6a58d44cac5100806c56ee3c5b3ec822d02ac0c7435531985345b9eb95259531577b9ffce810bed9c8c05b132d8efbb4316999bebe1255ea795ae067b21e723d772d5d8ade8a11ec5b662906155a81d9e541b76b246b7a741e1483964bbbabeee52393fc37b4fddc4528d1b3e78da9f3c16a09e4f34d77710449f92e7ff2a518ab722ef3b40b69745253c15e9b9e8c9d2c335a29d0e38d33eda5a36d1cb41c857719396c6900fd55b1d8d6a2e7aa0e255d4472a1fd71c9fd943f0abfa565d2edc6df5a556e7403192d348070fa7b542e60da1d1138cbf0d8dc9549b525c39112d955fc86413a95e79bbd9e58bdf3f8f50ad40a6242661cef842fc38e640f305299cced93ebbc595ba5f5782ba85fde820e9a00c49372b389951c841e5ee3cd5ab8f038d1423faf8ae41a8cd6a3301c16c270baf0d52f1c49357f9b559f9a9d768a21ac5481836a4b89ce515053916d336ab09b8dc39cba11a2c33632397e45d39fbb7cb5a543d6090268f26d36afc288bfbd8695189950e1fa0fdd5efb4b9b2d878be3250e6385da5e42e211db23d5396b500c0f35a080d1681705b7f822bc1504a85cb5a08a6807c6a1a45514f0403ba1d419c7a61b232a11eae3118a01b8e12383deec7df46d1cc5ea1028c8d7796caf3c6759bb71847be4c4add1a7b361339081c83bcfc64254377c780ae37b64636abd6af469f5eca6887bdc14c0845830ca0a6bc54142e9e6531cc5e7d4f0b9b4a2f63355d63fcf201a5b44483699242e0da27221370c28c04461df30c5a211527ef1a193b30180eefedf679e72086900cb223af8c9ada8df16ae137efcf2f091b0a63b9b7255389010d42fed3381cea44afe50c8bd87b9453ea2deb86baca16661a14dec8de9367e463c99e66035d0c44a12a685551d31e08c426d17825163a1fb2e02a388f06ea186d3fc779a8114b31ad3cf4ffe5941347ddaf523e2226b80ffaa6bb133750aebdfd6f2c2ad7ab7d6dc44afdf455c3f7ccdd7771b874f1e738cdfd3f101d26446fc41d27ed2acd28a24ac14591a7b8a1a0cabc7bc39c15941ec7ba3f9beb4cfb2b59fa66078924c095a118616990a22e8f8cf4ab13f1159e4496612e6df81aafe5ce53142809081e3b40a9f303ca2151ef166bc17fc1c1d84868bdc007b7201be5cd41563377498d0bf0b1fef96cd6954fd1f9dcceaddfbccd2033e4c7a75a58397da2c3d08e863a547dc0969e4a61909f87ad10482b9944ba3e522325a27de62e8171248feadbfde51b3a17502b909195bde1d27a584e390ba2fc995523cc7880aff26f7cd759aed716e6d9c5716b59d4b33031c11cf32e92732517bb8675c79f5b71c83ba949640c863215f603774613b3fafc29c65e00eed10a8240dc3a524c7d48db3a89574d04b2b209344c338c065a1e7ecdbb375779009986f92d2c552d8ea71a589f55c6e80d175b3046fb44c78658d1358d2015fdea8d7e2ffe6cbb64e069e9dbd7fcf2b4fa00ba724fbe86ff6c253c767162dae8693631c5e2f47719d7d1606a0c253eb901ab9203585c004038d9270ce4afd9072152e888e2ebe0d0eb34bab0811c6e6b81976922d1e73f25c2fe34042841b0e2ae50ccf676f7564e00977572542ff5da66e38ea71d9b60200e21ce2b606ac808220cc9bfbbb1d3b3177fbd63367056d373a764463b712ea0a0fc14c1c9e3209f2b1acdebf713cebdada57334fb0d352920f9ddb29588cce9fa5248ea6800ad2e0ea8d5b29a6667dc9b1c8a72fc690295a2b2e955993ad000bd765dabdebee86d7e2dfaf89cbe3cbce939dfaa34690f415412882d7a1761017c25637b3725713d9f7b5743cba9c1e68ca793be1661b308eaccf419edca0f7aeb8c4462e354ca67dbe3ae8a2ff92710235c4394d71d6b2cf0ab39452863d326ffe830734920d70724b904032d1b47dcf8fe1667e8668e3cfbdf923aca62f55d0a918dc69e8be2151ab5b3cbb9d93c871bc1ec0083dc5d4e09e1171c8c39a5c85456dfd8243a9df7dc210062b75baa83af062996e041dd99394a41fdd19c39b5da88c73b75143af5102598ce469af9422eb781011daeb45eb8667b073752386393b8c333118a60e6f1480081535111e76b311ab808ae4fe99a6964608983c2adec7443a052153394a9de17b677125d44998edf98885ce34f1713d7dfa95faf6ec276a8303c75cf79cfe18e9cb578f1cdef95d29c73b63bcca082876fa2676d70f1c30ea5a19c71509e7668b33fc993746cb3a4c81ee8f546ef0058f987fce46dc8a86757da000611e2ded3582a3fb36adcb28d9cc2550788a6c9fffe92e2650127d2ed664535afebac172100c2040f28ce3e802c8831c65c14d70024439a2c0a133a3acf24a3e24b5c5e7b7ff6d18f3c502104d271e52b9bd8eddb42eff5c993487939e7d993813f2c42786f28e98f1b2551c0994b1a450ad10b9a178f9d09fa8e2da4235cbef82f11eb47a1d015aec09c7ceda1ebbc16ffb9f589d7336c36b2c926f71c7cc600f265320c99c25b55688086d379ba6624b216ef6b67173f9d02466ad766d9e2d05b806422cf9e5c21c9c1860f78b818af3de6321e73fdb7c72362983bbde96b6b3a58c9384e91dcf8446cbaf979a2a78d6bc78496ac6b06f699253f9a6ab5a9e326ab5998ab86edfe5d062aee9bb3ce7cbfbca88c0bd309a9ba1f52ec8e421421b9dda60d29c26b2f7bed96d36178319d9681906385d877a90e79926cce1a65901f8e4f9246d70702d59c911eca84cacbff86e8de7bb9f57b3d6e5139be293fe705da724c103a887509159fcc47fb3ccccc3156010a0c85514d4f2bb6e5c4cec0ca463057a01163df0a831bb6e5f86ac9d36dcd60b45082368fac765a4c4adb90782928c4c20c8599fe7f30b1178c89037ace448cfe0192c6001b39708c6befe10cf2e614ea2584fd116f9e071bb2689ad3fc18d952965f2e41988d929607233d44614042ae1217c18f4f98081981f82be0f88622208b6c4e9adb9e0ff2cac04708a7963c0e85190966667e0db2c2423e8ce5b4012812257d66e19a641a5e8a9a4a1539f51a980bc3fb51d00897602277149933161cd278de019a2c63da301f7672cef2422ee560a79b6bb77528bd63301632217626ef7ff2e7ed55610023a4b4c58dd3a48895976e8a56c874c3b02411095a3d555d7186d1573aeaea5e8614b042a41b92dbf748375e23dfb99a15fc432900a34979cd031d7c5b9c2ef3b72de677c70bc93c9967ed3d49788bc70690d6867004896bc41de6e13b488932b2d93e6ae91074cd47938cf76a64b28f547b8ffdf304bdf8cbfe2fe9df0e5df440748edead01a9b13dfa09fa97bf79d0012514d12a05c5d5eabad21688e194bf96020152e780026aca7c3aafd5b965b918942058282e11dc3efb7ace256cb878fe5bcd32c7bce84d81098a357c74e1013461a4235dada2c6067151b8374ae9379358e57e3ef3fd5f6235101e10a6a6db99b384e58a106ec97661a4c48830ea2e209089edb6d603807df834ae7b0759d04e8d4c5394cbd3bd41be0e0afa573a99a09a6cea8dbc4ad93d8537c6560f99905430effb1a95d040643d7300e31b8eee9daed30ef6cd6b1bc4be01c394afd9b57d63da67bf230fd657e183f25f7a185b004c7e2d2b38afc50f3a82bb1336e2a42b4d1ef6a88ad80f78e59c64782de940818a91f34300b7145fd9a11a8222bde4b6bd9fee88b3aa945db95907dfa8e59982a9c37f6e3b4c64572849f4e139cfc53324c1fa893b3fa2c093e5099f7748ad58baa5b37be24c5176be8428a281fe2ccc7820ef74aeac7443cce9c5f69f1b5fe2f7e44afba6c7e1b74f3a858171286b72a436c2221b6be126713a1e2ad143736a041bc284c18218efe8d5c9fd07e67376682b7767de0ae52f8a7635266afe2f9df994bb113ca74689ad3046393b16046c73e5d6a886bc3baf9a8fe43cb68abac4f59ee103c28bc351b5e06ed578db7f0f3c74f7e68f186cb64291ce41b33740f1a2c252eb0d960961a2b331f789ce5f16ed786d435c3423ae2ca126de5446a9ac3a86039887dfb435e3670029030caf83c315067c63353e240af3d18091cc989f5053b068b256b2cb138de435fc9a83efb6836d24d57cdc8f1c0d011a5958459c41d96bb54a59fcc39a6cc51757340ab23a2330e88e53a50bdb9c06165ad86a6606971dfcddec3abd358c318304c379f6949b79985ea69740e9aeca5af1dfdccf751d4aa960229ea6f05e77c873dbfd356218d31231dc1750580e1b0ddec2a5a391acb4d6a0f8ff30e684f5f3fb51bc74f6b851fb7ecf1c4e5889b9c5a456546c35018798c388b0cd26995068d8bfc75cf54c4b2558023e76bc9c634ecdcf53c2faad25923bc2ee6610476337bdd05cb9a43b87f42387464727308694365aabac10b3691ef8e7a8fd2ab090ae2a435360722915e8d33ca370dfd00e25e35900af43062e3d07f2e75f8163b27e45bc0834b816aefe71671ff34f46c581c6dc67d6d7f9a64b730580b4cd2a651d7c26f3494e29ed95a93fe2c282e03df32149747311f70c94d22107165642c53aaae4ae8906f11847f2aee1c8c7efac3d2259855c72985b180a215ec801f1b9c71233b9fa9a1f642c0bd059dd5273f60c2b4bf872f05239c02d342f514bd94522c08575e806ec26e494ab09a4e13e01a4b5d44d42346a552fece8228b6d9019c9810c4183038c06dee0dd66811706e280b03964d78663a28a974e7a2de746e8b942958d5d517296fbcf4cc33cce0b5d3b5fbc588f6785743ea37eb1d5713b26aae2e2484ca716d7da4e53c3c223f99c5d2439546ae265722a7a165dccf8912d6be72fc31ad08f512a8011a9357612e370c9c9137a747661840388109203a91d4c4e7e2e820b2b25289d589700b5a0956f7fed2fdf84b8ada3309a95a2ec51184dc4c83cc19d351c0df8b2b51594b13836088c35db2040933e068af9577864234e905352951aa5577d04c6a9c05f52d80146eec7c7750865b59dbe7021a7ab98811df47de84d01f82c67f3205d3bcfa76bc99036d047c58f733c9acf68bd169a7d4000809e795569fa96b2fd161fa7ebb225ccbadb962093f50efa22b498bf479e5c16626fb22b9bb9463d419002a17cb39b633a3e497b52e0e4ed4fa7604939d83d60a14c82178aa4b5b521d2747423a967b721105cb10dbb30f8651b215f2d7902cb7c09d0d8c0ec76ec7a0adf34516a3d7505f4a00c7e056a428afd8d3be6f826995a49624bbe755853e7604cf7be206f44adefcb330481511a65acf2f3e2e8903446cdad6a33e5fbebca31fc89f70b10f1f0545f8dc0f3e063c0aa6d83551cc0ef04942f87614a91cc3639144db43a29e07e5216a177760a17b3df7173f538d418d4ad8b86bdf50090e0fbb62817b8c85840018e13e8114e3c1c956c563239b185375f2d583f4a01abbf341e3e74e85031c15a4e6da6510fd3808aff23660e958fe6edc79dc4c58ac1d77322141b2a5cc25cb3946d34ff4cad5751739f2e666dc398a7a4669d78479e5330752624f57332f230f0aa3453cc2959d5b4bfb9fb45dab904e4431a34cdf2a3b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
