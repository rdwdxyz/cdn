<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6bb7575089b879d320cd60e8b2b1a388d907edb496c1f5507467142aba2195de633642db17739c26601e5f98700849830070d8cc0f453d71374ff3ca143075bed641ac9576725ae113ae948824c89a6d52135fd79756abbb73380a6611223db4ee630e4b66aef73c7e72349d526d163b8a292caa9b0a148db5b799d0a918c150475637e94118db34490512be5ebb935435d1688cb79717a08547fa127d4a5110b8cdfa5b72e1c59374499833868ccd064f9f7cdb37cafd6a4f34666f097003470c1fe22976345f6b491d59e90b11e01cbc65687dcbc652fe9a8b6567d3aa93362a45c882b7a83fc415fd1a9270e2749929068c15aae992f638706ed49a2b98c469f20d12f5068aaf6e34a21200c57a712071e1f2696f826e78a69f7432abd65e52e44a465badc87ed16896369747bfdb1ff99957e883ec766685421e5caab307a5dcc6a2afa49a0279b9ac7325e975a5bba79e530cc47ac37b6d2307a74dd9d565fc3199d565ab2b5b47fe6b234a3df80175c468ab5c3b19e1056608aa1e85401e38457b9ebce9cb27f5466270cdffa7b2f7e99b97d9f6b9d5403d12b9cb162cf85fa8585d46359c6214346ec7e9756ec71ae42b6fe751a84219269061d9ab37135a6e470dbf7825f10266fabf2b15b26b8afb924fe65e9934a12818a8fed652d49d8ec984cc425067508783f467dafc3cfbf89771023f7edc1fc5a27b41951d215dceff5032120790770e933b4c0947ea093ab7d9af96dba338ca6d5068d80fc331157e3a3cb72b70164a682c61f391d2b54805b3c63aa8bb252422a014065ea20c5a360e3c137bbabe0f32c5ddc4b5c106c5b2a7385363be1589f7c76321b2517bd6aea6ae3873df4bfa30817d6fed4bc640f622774ce5856ba8e755557994234bf58321ab14ac07fe86ac4ee656b70a77aca6bd279ba0abdd331c0e92de9786dd85aca5ad152b97afebfc58d53dd5d990eac4dbdc2106edae212d0f6940794f8cd53664e2db198a05c19c0518cd932e4d07fd679a7f56c53f018bd53e642bdb31713bfd75d018a382fe590e5a83e5be0aa4c5241a9ca95a59a7ddbabf1176f683caa724c31818f4cf04348245e519c44c03cabfccc93c9865d1f95ec9f48058564333c19f2419d6c8f318aa6070cd15c50a21e955d4a9c96382f42721aff74cb4747f942f751ee880e36debfc081b7ffa999a4108c33705532243df7327106c3c0273924a9b0e31623fce24c415947c1a9d072dd9df2824c8b60a9c39b820b4f3c08dd8b79f96dce82acf5828118bfe14c5f84ab26cbb1e219d860fb31bf980bfb0bc2f42d5961274ae2c00cf06cc547a23cc1a9b2b4ec06b1d6d8460f4f09d75b99cea0d6df92cc2df8c0005bf77cb1c64991f39c1ff8587eababda0192a6c8fca0180f794983502a07465992868e564c93934341a7595b6e77eb54e252e4c3459a090e6f0852ec794792380a610b8df6627057a1ada2bad69a12d02a22f837dccd5070e5bfcc74969771310f6b862ceabb83d2f35c6d28f3441a1b69e502aa91f0c97332d0d86250acf3a161b836ced16ca9fc011e49cd23b2c4ad5a705e1c358dcd12ef9ab02d359baf41b2b47471c23935f8733afe63865221efa20f7fc41b513328bf5d12ec059a8cf9e4cda72b7119f0e2136abc5944fffc29daba75db973f5d69b1c06fec99bbe4dc7329d5a5f87ce0df01b0c55abdebac02d6d19243d0f1c83366ed8e4f88f71473bef0d530d95d1c952470cea81b9d81190a42083d5419864014babeb56b34d7b8571f8a6c0e7b962ec18b7eb970e71db2cc06d7f023873b6e2cfbf78f5d29a063bd71157f201776f145b2537b9f776317bd7e6286045eed3e14db9ff846f739fe62c6b89c2e840dfaa2f363bbd558d2a9dd6f57a4b86a39a484c89f6f94e9ec8ae30c2387e08f956b40f2b962ad7367829d2cb0a8f8199a00c13f1d1c8ec832297739dfc63ee00253aa8f632f04d2459027e399a6642471deb0b7bb9df32d3a6c0e3478023c7908e53d12528ff9857f79ea216d92f068ee0635c02df096a4063294868e7ab15342fcf499636b8261ad7dc6f18d18f4a974fb6c7c7bbdf6a48df99a97db65633e6d134d49b7f7cb2eeae85ede91e3565d8f32911c0fe3a535bfb473c7ffdc1f6d6b314f5d3cfa7d20c29a094fda4dd4156634f7f1a88dea56127ff54f67e237425e8d264b173abf5f28c1362495b915146309ea84b801abcd5d72649b5b14848907b17fd3ba2b7514ddfc43f8a41cf8aa273291c34c098fcc51fa247ac07851a16196f966e1e6ebb25ba2de51f79f8818bc1db06b48d4df536b9592dc09c7d578655ea42148f7569f19c091b658f3bce3637c004707369c7961fae67ed4e6d176aba993329a4f0aa7f5d07c58e032b545b9f7c643015dae1730ed66779e70f1f5161c4603a814d7073d4eab238b6b356d9f6ab7afd4d6434ab61cc496ba1683cdc81d2e994324ad7970ebbbcfdc5a3a2c2f84eb5b07e3e006d3cdff46ecfcc6cc0501816d0c720a0f7fb6c7fad78d7fa2c57b5b9dea70d7400de392f8f1a96a47e03585c478b3daca643993bf168272406e386c41c446637298518ec279a58159e3775165bb7e5b52f5183360ed989fa761f94589f483d75800240aa805379d57e15c97f4c00b391a7cdf542dd501d6f2b95e6ac35204ccbf8fc0f39b17b8989c9a9c2af7eb5fcbfc0662bf4b215ed7bd385a6ce4efca2aea83c733728e87d5f3d8826c6314cd25d5cb3364fedb21df4c5c8cc7ac78b4d42804765669bbac50be30a8d63ed2305981532eb09d57cffd0f5e2443e2602d6641c93dfe0a2d6585cfb09b3938f7767c623ca5978351d1542d0c1aa6515aaafbafd1590763be7a5ff292b5927ba6812bf668bf672239ce663120be0f0d308ff5532be3fe2239cf1e14bb271533002da8d50f47d399932a5704f7fc8d549d01dbd13af7bf69bbc2690017557ee7faeb694e673398a25946143cce0b04542dcabf803228d331ca268eea4ff7282b9abc9d4333f19e55725674c2be818a6d55929f6c7445da933ab99bb9f6001d3a262041ef92cef480079a534a6985120c007eb3ff6609aa3c0028fb5b33ce73c7060d80013a3b711890fff813216f56f07fe3b5af1e6f56e0289de280772399e6f7a35e816036f8d224d1c97e521bfa474283bd15a8789ff7c650323427a8842a055912dbfc6ce2d65f1da6ca5c9540db9bfe9c9edd7f1eec9e9738e40ea984bb45f5ff9a7b337061f7c9110a976b106227bf1aa0392f0f4a210d9b098a845b93002a946f8eefefbd5007781ac93f91d550cdb34416b9600dd22ccc03a570338bc3d4d176ed2be6e4ada5b4695af4ee8e0364877d2ca8a142dc9b3e893816a06d04a689f0bb77e91a0607485705688ded54361f3b9713e02fcef689fe31029982fc3fe3fc650c7c47d5fededf35f7bf34d37c644d8e578b151acc801612081dd749ec289fe5937907eef1a3ec8625c744e1dfe7737406111cebca908a14af381656b28cc581af6338c1dcafb5802e2ed3304b1350fd8c63cfac83557a94928cc058859384b8bfd4b8e3244c9d73684f4f8aa33d6a0ae0d9c5b87bf28e66776d57e0eb9abffc80419bb6f88914980d1538439ae0e3cf9a351842bf420679734c1a5d195dbeef539dcf46db0b518fa375d1aa6a582a2aacbc4079a0e2b2c5194b9cdab0bc44a051e7364d7785bda0ef0c19ab744448a1cf05ab38f1cf462574b61a2cbb554c728e5bbfedc0d62eca7cdfb136a45738909c601491562314c89583a454399054e9b8ff3fd6bb978e45cdd387d8fd37fd4f204f6609233d8921a22b477f370bd78281d5f4e284d52d93a23b47897caf1ceb11eaf79409c530b7fcf82d9a973dc0a6cce32f6a1014f18bd46a663c3ea6bc14aa706f5e16f2773adf3c7ac1078b8a22de31a025f8bcabe5ad937c9fffb24c49f941d739fdabe704cfb545e1cd1f7528128963de0e91d281d31f467dbb7d4ab62d22b8c8c7c2ec47092fb5960209d140561c77b3cdefdabc275613c9e7a8e46fa96a98d847b02c068b4b73708764cf583cc92fe3cbbb905d132015ab6e0be7ead5afd3f5d93319206bc90c337bbcbf91d325523480a5b5d69bd07c4e7afe3163fd76e5920d95e426c98994a828a9b5d82befbbe50ce8732ea625feb2f5becb887884362798c18ac57de02d583f5061dc0470327b13c6c063e00ea1c3b2eb838c70400ae17b95695103fb9f3d3fbd94eaec1fde52e1802efbaa1a1283375440a6daaf4f1537724f36f85dfc2ea49da456697357bff52c76d939bef437b512882b8cffa7fc3d29ae67dd9b1b046cbbb8f0b77f0aa5dd3a6ddde620c20a568201f890923b06ff5489b2f4c64153f44d13b6b52b5d46f029811c34bae3e47ee6ab5962da79b6dd9810f6e7dc70ad130e6cdd36b6cc391044c08af8fdb3499969a160b1889cd33ec333b905b54be8e3351460dc6a225ca188441ddb34a054473ff73c1f65b76ba44fadc6069a9240420b78f9c934237b014a8289701216fb1a2545a07e501a3b87b0ee1bb1f18fa1eb32e5acc62fa39b804a22561c67b87c2b607ac56f920f21e05ef4541d1345000eabf9302dbf0ce480a0d58f142ea76bc059bcaaec5e20e450bf6fcca5782afde75cff8714bdcd74b3bad73c7cfbc8cf39ccfd6cc3dac8dced3c30e88ca2f965b746ee2593da13d5fb816fa9eee55f6e6ef70b53632a9f02d7cd2cbca03e317b78b8a542a1f5528189863b5d10e7bd8929a195cb36c4cd0edab6ddf6f22e007f9928fc1a4d94f0e20fc5326a1e52f441a92d3392eabe140dfd8c8bbddf6cf04ba9cf2a7c9d28a4745a54cb7fd6baf39f6adbc4f5127f5c106d96e6952a35f9d71faf56781c8a358e0f6286f60bace005645a83e49bbf3154b64867f1e116a57248a5fc3c19147fbf00d4d732d17d557c5e9a47d3eae1c6554e6cbc5203068933217f36a8d6982a4ffce760050ef848d45be6d8f76b950db1658aa92f77af917ecb9f92a52fa40465e2290ae51635bf8b8df55c6fbebc07064a1eb2ed6739a38c2889cb0918270d55cb7bdcbb3f64ed669d6e7c14b3f03cfd10ce68ce229bd356229471f1f26c27d75f1f0b84a84658f93ba386285b8f0919415b012ca3dd61c9b17e54371ea03e91c10ecf262708e554f0313506bb8eee53fa9a8bb52648d6ab6738cae5c61697cdc458ed9a474367bc7745e9a6e3e063919ef1c0060eb1aef150318f066c015e0fd48aab00d67cfce609f04edf1094b077418685f3fc1a87d3ca29cfabb961a2475d9f146099a0294a15745f7174b21da5bd1a402d07b54075f0fdd510fb7d35fd9232268634e2d43d488e18827c27774c725d5f02ed28bab93a5a9a1ba674405b792b18e7c8bdad851674611c99bfe637b62fa8f69f194c202338f061fcd47dffeb8442eeb0bc31d3253beaa3eedfdcff6f455c556c8f1e584e6c7a37a17440ff0a2e7dddb993583040a009643a23d0d6dc59d22a11db67cd91b17da6bd20f6a56becfcac7fb9e717455f243faaf6dbd95fac6f0b3a9ba19583011194382d324bb5af0b1a645442a85ca96a579a52b16aa08f9f5573f15542d8d3f53d73b02b53d9a45237552e2f5b7e4a795be0c1eca27577f8adb6a46d6ba920ac061997bfd0f3c0c9441b8f3d832915e0b88f433c44e8faec994b89bd05209397cbdf2bd663f850ae116676948320cad1d54dfd97b23d98e1dea3d7a3f2517be48c91be72dfe9b0de650dc1604565d91f202d25e4a1b4d10423df6390caff6cc9353d868f97a8d99085a19fcc1100e3b7954330bb885b85002793a6e6f158cb967cb345a4972aaba1f1ab3e35ceb71a7e8bcab7df9839949cd1a515b1c697fba6f223a3029f0f30ad59452b6b28717d0c369b0f1045eb3f60b2ab9974b15308089f2ed0a158a65a773c2c94ee4a32ed55f3fd0bfd4f6091cdf8561cf4cbb43399e9fb8bf1b5bbb9feb745055fc4e501eb318269e75e5e5c75ca7334e42b61b81e6b73d977341aebb81574ed49d78d20ba9aa8a0340aadecd0b6ad48b467e9da61eff6be49b146500f16ab2a31dde1f37ef5cbba18c19ed343ff1f4650bc55ef246fcb81cb300eb0daa67f3783eaa5ef284a27a901533b7148b16aff9673281d4ae66fe8e1ce86b9b194ca89fa4f0897b6a73b7fce1c89a06f1c16fe1302d5adf68543425f1da05860538110603bcf8bdcb16418a741b0b1e95479e45cbc538c1e1a0e9fe742b323fbc41ad5c5a71a66566c5edef42d8735249a9f7ed25b8b9865a6accc625d2304096367301bb28a0761714ad373b2287dc14e5b398d826017ef673ef6c2e1e869c70d688078e43d96fb69c35eb0b30cbb6f2ccccf53dd1a55ebce2c4a71b603f2ad63df6f44925d770863fe599ce0d0f0348134f4383386a137b860da5e37b6c8bd6b1c179a117db5ed6e9f13d1a8d2c0a1d2ebb5cc85d143b0b5b63c8a9ca28ac8686510b16eb352b394049e0d272a6aa594380f8b517e3b8a9fca4e4bc7eadb84425c61ecf6da5f3f1e77821922914c7c5ef983134a0d436e59776dd44dd6f424eddb68705db49e75ffbfe60a0a832d0a06ab97791d7dfa8a15c7c06745c921cd40066d278e5c2c347fe037aecfab80ae3689819845ccbde032c10b3c9e09e5a9329758d2bb4f921efd123580e09bd1bbe101b67cd3c07843c3a37579ec50e3561414e72c38a4bbe5cda64c37eece24358e4e1d2b3b33e0e16b27e737e05c820ccae49b14a9bc2b1143929dab8c8f2dd25898ec85a4f9a7777eaee4d1d8fa215d200bd2c61a1a58bc77bd8e50f6967e5fe22f18899c2db1b95334c06b24f9e3949d3ad5bd5970aa2a82925ff9ccf5b57089188c8e6f4883014b61ac249f15ae220338cd36eeedc47ff031a0e1214f652bd73d17ba51fab342e2ccecc567a536bf9c004a5a5cf3195313ae4dc07b9e0802b2f252f28dc8b7ca905b79c6f203684cb41e9f4c6a10faf4698230af219ac5753606314f8df9b6cea6b3d112f92c152ae8392b90abac74e77f4e79b93fbe0368306fd6fa39cd360af39655e0230f1983da151e5ed3c1aef368b59b14529b268e83271033e1e34bef90589db7680e304f73513c1297ea16c18064b75618a48b22d4e876b8f118da8a588adb29cc5f95dcde1f0816f4ebdf6c2748662d3a7a9980b74facd6e03045abd4076c21b1e93ac97fc9da70bfd3c80593000f58f1bcac73e489ec024f1f26ac062087a1b1025ad83298292303c2663525934d850fe815cda7e7c75fa3663c52aa9dc06922b515700e612f31364f21d83b2f004467822819aed13cf83d5300b61780e733105f17b348f71faa973ec8e68f414a17c8e9e1fd447374db921d5a0e1a38e7df2987d3ca9d46b7559f478ff5fe1093b83f90fe20121f255ee45dfe42405155f165b4675418d4a28e4882be6c3e2b0d01d77dada63af484bb87a63c59e4d37fa778f1ce719fb0a06aa3d526fc553360d83bd67025e5633f38ffd08753a3e6f45ee55f4701c1a899c3b6bf14297c87055e0d8c1785c4d4608d8304d111807c5f5f233a940b14da4c5749c1224e1e323f6db6aed878dccaca37a02e43a391ad1a63ec00094b6850c771f69972c9e4fc48d2426593c8e9cc2c6746b81fab071430ee5ed3f9710f06ed4f2a3dadaa0e6ac175837a6975c5e408364a95401c6ee35f8fe8c59c14d80fc9bc38158b9182714be6c7a076a0bd6e228fbe15109ebf5c09f1d24b2206cc65dcd4f768626926b81b0494a904112abef3dcfb6fb88ff951bc7acaef462556d09a28704573326bd8fd5a1f210dc73a5f22344a8464ac213a83dd3160fd24be69473ecdd4761e3c8d4b444ba4fc32e158743a1ef280166069919bebb5e8f2ef36cb4663e3854a57ac782d510e00deff55452d09f250a4e8dfd472309830e72533342515766150718ee6a567ae576349b0f5882a74905c58c63dad19934d622352af5b1590506184baf2735d4e88e81cc4019328291f364868942d97157fc03245e1d3077e126f94ddfaf4617f47308d1863d3a96564b694b345ad2044539d2086d19f98de2c76c861f8d98533fa4bceaed1417fbf52cacdeb4d7e872536bc0dfe7da61fa4d5240ab0e3f749f3ae4aaf198068881736e3042b05431495a83b9d9685c58978a99348497a2e2e9e45af075990e01509769b104a10a79f6c63599bbb8eef4772813402f9becfa448590ec836644cbb638b88935491fd1f36d1fd29a82c360cee995e489760db9922b2e3bc48b0d3ff23ac37952c26b95903dde8d92a197d0be4988a374b1af3f9f1d40f68c42fb3d0fac0af6dacb3bac1c765a9263904f25c3cf9156ced8c72faab020c0cff4d680361bf1685b511addd68cfe1c08d4f84bd82cdd866d66f3472ffddcf135555c431caed157c34d29e0cbc9cfde7a9a43f27d6dbac927741bec9c6b50319ce6bff57f59aa5b5d1174d02804bd399dcec2065127d6c05ad81a8e34d0f0f964ce25cb126d99947e7a55ce3299f223eae5a841e56c493bad8abb08d8bd02bdc5be3aca259f558179432098bbc041e8872a2e63b4a97cfdf70b5cbcba911718093bc481338a4f5462f05c0dedf627a7603d30914ca612d59f471d290edca494769d0f69b43c89121c811b7860de24a17651df1fd11d6529fab108a138398eddd7d952ab41bcaac5b25440781c332a80f1a67288fed61cede95426b38ea61cea7a838984c8f40304402c27d29db16ad7803855bc241ed8d2c18241cf3a41f9caa789b43ae74175bd84b3553468f0bcf354f002352d5c073f21cab3f717540c99e4677ba134aeba30a59304dd50f688cce3a35f888daf3d2133b85eea4969c3e32bb0454b38293b8087349db43dcef59c75effbea812770ebe6350cd20c27b571594de1107e6cbd813d9ad6534700c717e00f2a5234f8df6fd18f686b036e3bba62afebb2556a7254aed9d4d6ed41d22b1362c7f7c263b2bd3bde88f1f1257b4209f4a7f141be92f200d9a0a5929967ea4760d59b69d3b769b7a859260dac8adce5ddee37f802f8be3f19aadc662efbd59b9a2ebbb1ab06796ff29d37cef8f9d6e39cd8ee5e503e782231fb040a3b5c8193487b586dd218605b5948f6bab5f01c5ea0300f2f616eca86d9fdb95e75b200a1b7ff76cc6c39242af53634c8d4ccc9fba72bed53ca1081d316e47f94695dcf6b435a0b4af0a194b7bb9326f955980b3e3e3ebbde1b03ec66d003201a1292ef3f0f9f6c6aa48b14446aac43bfefba864a17c07df7d7dfe140febe71ad574ddb98d17e38219f676e2432dfe837004b1acd2d80c82f905dddd545502d675cda0f59ad8f614f4219857aa44049f92a016df3fe9d327477dab232de0909e727812eac4743d7612b967f5cedfc741dad47b92e3f880641eb41484305f0a532609c49ed674e43492b9075b70f0ef594e0eb56a51c855c969c0b26751a94db8a5182934a280759feecb1fd01a7b5a2776da7bc9b76419ccdc85bec838699a5b932e247b71ccf4e61b8d96fd13a0cde5bfaaeb6fb3837d80076d635248c89d20ec8f6e0bca654e6a78c202d2c1dde79cf1ccc360176379e60f19ed57ac7a7f98bb3e08e8ac70cd8979a0e56213b73fa9f103b501354f99569ff2b6a8035d37b9b68a50e54b4e582c611f65cffdcf3835382a26aadc9fd65cf38d61d1e7c4fd96ae85543d43c5b18b1c0fa6f50f54dfcd6e696b8feabd12b52175962afb880daad02498c0f801dde79feb31da165a1ad04cea89933ae4889b7dcf9927e9fe536bff767d83a5532ac8ea4cc4e4787dbf506274c4a1cda676841bfd5aaba42b4245fb596913e9647bdd663b37b09d797860e15b47c42bd330a6f8372da3acd9679decbbd757ceb9c0fc8c4972175e6b3652ddf9bea57a35d6e7443f266cbd5fc31f613413d86124b2fa3ca360b50929c887b31e717e8210a498718aabf1506c2d1470e2d50dc1f9ee8d06f204b24879467e453c53ed430736245655a9b6ca6656bd6fc5885e2173567e9ce722abcb923bc197cd63974016d59088dcae447cc897542acaf7c04dc7555cc1f31afa93447fd821437ce826e5c39d0627b12598a9c67859a221ad51203263b225f572179cf5b838746ae4237552091f810e07a0a4300a6e3201a627fc6472c2252c30dd8d10872022b091c2769f13bb6e1bfe386fe195f73e8e93143311ab6723f4dabfd34c5624c09ee53a661c1a4a0ce9e8da7e9a5cc9f9ccbde76940a3e5e9a983a5198cd7f4265b4b5ee687e41fc71faf6f6d0690ed119ab6849108cd18df6c0b311169edabe7bce6f5466d74ef23c9cb6421cdf73d40a56844291e7216fda8438b9b1e430f0b9e57e3182e2aef7477f99051648ede16b91ce054f00f145c6575443569e90fb2859a5f2e3a439a7628deb4232d78a8407a19449d61c5130fdd1695a0bc895cf1ede06295d3eb96334941ca16d03ecb921402e319b5ba380a3c9d415976c1a4ecc0c1b885ad5832fbb031e66c0cae6d681dbbc5b4b0b00da8ea90923fd5ba9490dd0ac882f0c50f06b1deb5d70139f3cff03ba0e70135e181502215d2a98a3d48131b7821068206eda7c6b37180d7efcaff498f362eb7061564e3ce8c9f2261af144c898b84cd15d56f9abaf29a1d2e9b01919dbf6a9b8b27fae3a3dbc35f7c495ef320e2f79955a04b61abf138e5cb1457ddd7eb15001d41acaa72003b749ae1b5258661f60046ac99ec9f7c14a145c95516182fa40bdb111639dee2fccfed06456d4c5926190710d28f701292cc2e8533a522e9256ceea63fdd4ce25e247d7d93b05ced1c3eaf8dc5f08560ec0adb995a8a2ecb90eef7a63895872991bceccf0f5a2c1ff68228ae101d65fb6cd08954eef271bdd8cad2dc901fd0fef4ef43c2be186e263761f4d48bb51d495460b614b9eb7716c636ecb4992d21aa834e774d5ab66bc7c0b58f9f0f673fe9caaf00eb2228255834bf62311a548b6c72466c9ffe57f49d72f9f4515540b17ec81f44e1b77c5dfd1598310d357e6850aabdd93898d62f32509308454394ac84a4931f80e8eda2b837fb6915fc8e74302563058f91b436fad484c6e46825e0c9ed2d81b02512f11dcbff1c96039f1b798ac8841836d3111bf00c2a87f8ca6282267ac870eb476cf83b639a2cf94348b297d970515ba266cc54b93f54d9b4be6a6a0295b844f7bc4225592198bfcb8bcbfdac2980ea81a94d1c7d49abe0cc8dbc7e12aedaa28db54eaf73d9e1ff258a54d593d834a39c7a1d998bb720e018498541eb2092509970ea25e16378078dc4ac677de040ccb36b163badedf0db3f3890460681ac13de283bafda78209c5d21fad7fbf143745fa514f057bb958fa548a00f72c8f01ea8fcfb70d230c768fe24d918f1fb50b20b14c94581d163e79726751f8832d1a16dbc10ddf70f952dc641de6a3710d8ff581a4a377203e6674e95b4cdd2ff20890aa51c820ce5d08dad7dc732e0188e79bd43bd928fe7296f8f312657852e88404c7b1c00c3ec56e9d81aa08e8dab031564d3cc4d5ae0e57be2b601bfa4bff118938d6174e31bbbcdaae56066752c8b0e13832887d56a7e80ddd96ce5177f3ca0243ef951fda26c0c5135c907bb6b651034e690a6dc2ab5d13f98a3fc5e4da6b3ea099c9fa27e0723d8b81d8f7d158bdfc69f619fa327d7af555ade9007e4f377cfd7b70d271329f68211ed417dc0c9ab6a4f0d09487f49c47e2b36fc54d3521032d211bd41ee70544fb260795d178668cf86bfd9e846738620aae74903a152201e1a406ba610ae0f596ceb1a46c22a635d10ea0e12b9b1aff4f17498e28d7a2f1b894b6bb2a3b42ceca178dd721dc4982de61f03bc5cd11ced31fa7e3c847743ca2f72ee291466b55488c14318c0fe6134bcf206c70330376a49ad22c170389bf837d88e6127a6c58dc59e51be08a9b47a5c90fc1147e619c55c7a41addd1e5b9d4be9e5c3e45bfd7595df5dd8b89bab45057b459e058891928408dc841d5fe802fe876378838e3590d0ff038446bc0ebca493b0f9aa8e1fb99db1bc7db93cf17ec94148c69e33caab62fedb18862f967d97672af613cb3b9d891be8325c4fcfc654e3967a716038b403359de1e0da6daca7eab6e098eec1e92df37a4ce01eb9c701bb9ad7db9c87d468bf4a7e168af065b181394450daca734c5681add19b5f14e3e8744f0853fa0b2c2afee3ad7a0be4326fc728b265632eadf28292c91f85f30e7c762162113a0b4a873ccf39fe1e5946132ff7b0f3e711df3758e970b5b896f1965992ce5909bc70a6bb1d2001867d86f4beed6f1e946827ef6354f28f371c13a3a935aa220c9c1b05a33b87a00c099cb6fb2a68eabb5df5f3e63da189a73914af3c648b5a0f1f61f0f8f12cd9ba99509dcac11cdf1d608c7ce903a33fda9c911009d45d181fd05f97260317114d85be8f9d3046c7bc2df472f5211582ed14b88833e3a320510e64012fae764ccae2d537af9f0f3a199ee7ee68576b8477cd31652fe4aaeddef297b4b3a5ff39f0acfc5d1bd87149f6d1a4668c6febca783f54904d05dad8f9acf26b8b46f44095251489e9a41694737a15376fb1321846def45a4de4bade539dab57c5b3bbafab77f837a81fc449507484152809ff1f9f772cb1855100e5626f90f2b4a276ea8e4766a90ad2decfc28e4c213d21ff5d52c09c9a7854b5f81d02b705704a4ed2f0d733c12d3cdba53b2b0d2fa1486e5e70d6d7e05ea4dbf11fe73694507cc79ff4d042d45bb7b0148bcaee126c8606bab12db57b2613a8eadc2071b64b575e918a443de41a582cc2ad650fcad821d83cb7d57df0c07aebffe6e04ff331e89ec4c1be2d17264122005e46ad8e954535476eb4c8f590c0b6fe758cdeaac266f2df23a6b6ef2da997237bbb18e9b929d1e019a93d695a3fd827c978253b75238927de28c6ac2176d7e227177798041ef128ce5fd548d4dc3d7e6216b03e498cadae9ce698987393c3602b4e25a0f196cc1d5de2afc62055bcb63a51b7b2271725a7ed73b535a59a0252391d4bd1ec2757b445c3c9f5d8d574d468d9abdc4e3df6f693f5d1e7e1ed18e1928cbaac25a3ac8e6a401710d4fbf909508e2a3717157b8d017c2f7faa82b40aff65c8bc1fffb004689fda8aca231cc3ae9299a143a44cd6a6152f97cf0b45c2699d0b927b42559b1e9342af14fc1cada8dba46b6a3d837e239859eada514e5f4cdff685802848faebf2057552261ef8e8c2140cd9aba5bd01f181fcb279fa481bb4503063ff44db44fd4a5954366a680528443093536d0fe07dd61ec697fe8318fc8e8606e668cec9a339a2c98b3d8abbb68a4352545af1f869db93caea7e990497f0754c0f86687585dc97ac3bd117d41ad2c86a08ec36e1c6a797b58283d133c1233f9e8cf0a70743acc66ffabb5e89537dcc14126a7f82c6f2b1da1cce297ab4704d5bb0ea8140db798eee9961bf594da2968761e5024e3a33a53986df6967c2978cd7a4612a72a8d685d4e5bc39419aa72f9b0da415652270937ea046ac80f5153aec014ac046a16aa207ada0a18fd48179cf37942e54be417b69593233017bcf2c91c2546d24a9f6c3d580c15bd17230b08ebc4ced81249d37d561bfd15ddf72e8a220c18120e0ca55f9388389618247485a8593c18deec2171089369a3bc2faf663187c79e05900d27039234903a52021bc2ba12b299be5b6f74db7efd2316103c6e96162d9dd2b9724b76f0fe3e80073c9eb8189429bd05660f29a20a75cfcf49bf8da322bdc7a2f0d2c17cfa15d10c32034a2f3d27fbc1d1164ac48db2564679200b66f5dff9ef98c4be3b7415aa22691d36c38484cdcc22a6e4d08cad86ed03c5ef0d8310eaad4842b37d53c18f6178d14e9f6088684ecb6067feb7d4910c88f9421af95c293dfec2eb1ea1957d3984eecf8f5f7633f3f89ca98da359007bd18215e904cbdec61ae54ff51eb390e31efd47c4ce18d120c73f018c0467fd687442820b7d2f9e4b69a7ecbf38b790c7dac9a8ea2f435bbe2578af9e5766207aab1453e0b23412eb3c513e4a32fa8849d8c29560e89a1cd0a46542ede32379d6881649db0d258460987278fdab8d207a6193cce4dc24f5dbc2562302d75b813625750a483869986252f260eefe26aa5ead1c68c005559a5b4dd2b90047f3eb5241fdb25e07eba07d86ef838194f5d15d8f5ea1c00b92d1107da23fdad05c23fc6a57af1be881e2c51f8a544f1683269f81491e9c12198321e7c93464e7799771022ab9a271697e3aa0e64657ca3a380531960beae3dc81aa152d2fdf42a4b07f4c524626aa2e479500a57206d500225b44113881a9ee374c8705a9b0e5dc1269beb2d52c4c858b1a58c60f422c91b5ee56d6012bb7ec167c2a71c3dce44ddef4971d83aee6ddcd3b28938195d86b61afec5812bcf666670aec707b69ff3a8d35b70e20b41e0198537ad16c182c5046242cfb18db39ffd9b2aa327a0debfdcd8582dd3803a265e070e26d3fc39327a338250f6e256e4b8b6cbb688fda43d048ad17449c31fe6570ebc61cd5b43a53c386bdc4278814ca1410b2d7fcffcb39098c1229e8253a83bd17dbde33ea74537e28df53acda2af0661d627cec6545037c378150f8230a8433c60c3342b701236ed702ce53025d2b9b963281d0fce9ecf808c3934e68da293e0da5dbe4eae92a4dc2fceadd05bed983576318aba400f983f4bc4f09ed5a90ee08b623c758bd3f063e57ec7aadb8be66c7af829ab8ffef384c0db4fe2168963e159b1119e1e421b6509bc1ceb1ad0971d4361fa92c56cde48a36c02da7fe71b33f4f2c8c4d8836158c52236a1d159dc1f74e58621905025da4ed4d077a1651c4fcaefd4b35bac48d8a1186a92bedaf2ca118bd25474e1fe205be4b36ce171564bbb58abdf1d6bba3a6beed6a7ab8fed81ce2cdfed618e15cfdd4d285d0e22faa35ad9cfc44e8c3f19e159b4c29de307a3c4b790ef4a89fe744cd57b663a4443e28bd9c0a0d7285e3d7f06a46c2a720816156f92baa98628cd5290fff58509b4a6d93e47f882edd07ee095ac85de4ba07ba07bcdd2a3aa192c299b04b20ba8231c7ff76266f3b3e59d9622a61f0719d03b94b179a0a0a825aae61cdb86626ab31d3714c833c0e7d384e895625baecff61bf5b5a02b49e957cea82308accabf706da4e843debb5dc338d0fa796d87bb3802316e680d26bb1f85e31db33ac0e43492d80b5ed8fa469055a0e09be3f2fac1ea1af1282dfb95f94e11613b7fe65ec808503303d733b639d5793baef2d0a000cafe3cc6c7837b601b33cf62f5fae5c725d98c8602714cc2ba4dc9009ccdd1bc8e28c79e68fdaabdc8c3a002da8f97b6795e0b5fbcb630f2f949791fbe708f55923d760c3fae7593bdb15a27df249d0002586246e2f2af745495627a79c7de0bf725f03f878f03308b436cfce06d7c362e13cbe35f1f5c946bd3d212ad0980461912c7c1ab82b0cc902024dade025fbe4f1e574845985250743d3d51e7f09bdb5624455ca366eaa4132126910565babea80a8d92bfcd39a6376859f43ce8a58587f6933cce74782b6108292573252d23e251f7b28ad527d448415a4110156ff9f71489577bcc1d1ae96fe9af679a47687395d86735ac32f494b4749169a4b3924e0bf0cf6ca91d94b2864866597fd71619330551560dda5bbbcca98e6b8ad1e00722a4b5d3ae1c053e351ed90d3f5c41c2bd8f89d3581840a99d871be07f82f48fe961675a5930019f91adbf4118de11eb178efb39697b3bb56e61ab875ed0a9c607daafcebfb981aa837b9f5ca48d21b8c858dde84051770e3f3f5ee1cdb7cd1cf3058542b912a7be1be3415f31a636b1a5073cb0d141f4b23c44cc26017c10be7c6a0686f03ba91fceab06f2bb5fd9884efb44e443104bb3e57f41a94d1955869cb2ec868097c1bdd3fa2905215307c439501bf50da70d6c0b2a77bd97bcf27720b126c1e09abb0251a60ca5f775a55ac9ee2a23d8b002866978daff9a2e8fb3fd1521d86a25f92b1134b5bb1100f161f2aef403e0a39e0dc5ef6d305acdbe7044d7c899aa08bf40e02682aa4e6f2d620f20cdfb0740ae33c24682beb246bed9b4c9f7d8952c2db4194f112411dfe661904f4a747e83b1eff624ba3546374c45d5634b3b89aa8a9a47e790c05b242d3f9608890b96728ffde14972d4607c70f58fc10e4792bb6333e937702c6f464aa9292ec622704c75fa7da34103ddc74a2468f70faf5e186dbb303f874a0f8c7cf2391f0bf3175e72233257e8315fffc90e97acda7751904f672cad4b25db711a50fb7f0d3c587d62da62aba3bbe5bf4fd5cef55641be04e15c2a69826eeed3ed93aa7ec7c316ebd2f9a40bd4e8576c085b9f1f96193276c5d512fb42937d5410abce91002667aa7589d4145d85a02809a26c07556cebc8939caf0de1db66886ead280ec7b454833446f1518aa64a4989b01d2f7aa4d412c11cd7290139fa4f11bc709aa05859eeb0135704cbc45c5b52c41ba4ecd04df31cbd2ed11697ac346770705545ec8dde3c4bf9a30832651808a7130502548e6fa9a441e660dbb69b3f962b7e0a04ce656a6298a83a6460dc88d138c215502c47b35d9ce7454bb017555eda192411ec2b24b8b9f19630c75f4b3e7c13a60a8cc71e878b7f9b6c1230baaad00dfae3c8c593dd2fc5874b00a68041c264556b8ef77648b56552fe179faa28c580a2f5b46cc155113a88bba870476461278d4bde4907941eb6915542dd68ef9aa6ca8d979d4218250d15a058a211ee110fae59ddc280d1da624d8074c38cdaf1843ce666f8036cbabd3e94de8246d8e57edacd92e0f9065ae55c8167d3151b39786443a731405f0b5ae9c1bda6c64b33549ea979109500b2e97578fadf9ac32063c7621501870446bdb08f786ee33ae9d6c34b696f2e41fff729b0f49c6b292816b3aa50897db0ea3cc88d590d9e4119a6973dc428e1ed15a5a728b180fb687378325fbbebf0707ebf0160299bcc2c9f5dade3f0f2deb3a9c644d08c5fd484e18f202a3fd8fa7c81cee5a91f995d1008588f4578503f0d3c5473156e7415034664a7afb2e45adf3f362881a4873cf228c5d679b1b4fb46765673f3e0458cf6dea4102c1affc04132bab1004b6539daf72b5517d8be1bc1f3f94f8ee2e68a804189428460b8c6a52e566265dbb95f1a8b798caf04c28e5e23fe0beb2cd3f058ddd9a3dd728d29a48409cee5df27336f5d2160536b1165b1edb1818c7138e5c0207ac6743588d62b2920a8c7869b1ca74d10df82bdaf910dc18ea42845dcecf469ed33f40a2780875043da1d8f89ab2f297b18a697c578bf637edec7267329a48558fa82676ad5ee08d4373649956818328beb29b6a0bdd85b41cf9751cf49848b7561a6cc78ef66df3345ffdc1bb0ee57a34c2d11f84f8e8e5b75e85ef80ae58384142f8c44e0194639315282af3178a660b04eeb9db47d7184329090cd44268c16fdf7de08d39e69c383b8b2060e2246310b16306638330e199836c463b7771453e2939467350a12fee23faa0f52c2ab3d86ada1a37c9b7dd159f05d587d6cbf991dba9a44bcce2818fed3b3ac7dbb4866ea46ebe500b54c171ecc6959d8a5b8bb80cbb2dc0cebf22ce5166e595d3c11ed907dd79ce52a300b64a074c0022dcf748c489e83012c5db316e0f038ded3308564d893e336411e176fcdb022398d29d6e067fa346c95fc726450f850a9587ae476c02f3bb94fc304b897f986264c82b4c7457bda0228033857936f921dc5f23d1634b642484a71789bea0326bed9b49edf41034a4e40a712aef1d26bfc34b19a2b364760d0019f5a0f24fcc40ac0fef36ee6bd789a30d2346c089352b313f42515776672cc9149c6635d95994978b82e199873c4f45302fae0c9a6314e791ad3b5a425af999a76da4acf5305b3478b742258dbc6538e790ec28e5ff7007edf1bd149201b53219e6c16e48f74aeea78633f44db3779a0e218948265cfd338e41c2abe51221a6e29e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
