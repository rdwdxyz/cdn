<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef0657144a0328d5240c6e4647b18327f1d9e26fdf2804ba93a14c701e89d3225ddf34e99d4833f5df52c8b27852e684656d17fd583fb43c049a03c590db1cd3c9513daba683e5c308ec4d1ff43b0f82e442fa3db9f9bdce65bc83a89984a62903153807bbeab009a4940b4bf1804e7256c8787b80f724ef7e545135fd8d529bdcc50f9cad486ab2892120dd87d99c3bd705ec3e331411abebf9620a4265adeb00c64fcbab6ef720425a1a444e8b80dfd67393d14a0267e1ea739bc4a7df310fdd83a735de47204a8ed2d04ed7a86a669af09e7decfc1da79440a8f2a1c3e0af711daade6c171fe9a2d33705b6f1862fe86164e357c86bcd8ebd69b56fb7f89318d3cc76b32ff8406f28fce9fd13308a994a9264b12f9b0b3add8bd01d6f90bb2c61a5c60c8796c35ab7874fed198212553e09ff1ba3ffff46aecf76333e8e584f4b5928f7581d50ba906be0a4bf8b42a11d802f6265a6c2f9f42ac66e5677e443a52a7ac0c30ee5014e1f2defeb884f79e9d86bf26e56eb851e5d18b0e7acf870f9d0d9d8037ea2dea07b5c6978e388ab19a7e9de4bbc8f4e6dc58cfa81c94a5cdc9f1bbf73ec7bf121a94a6102c6c8a070f354ee05b903e20ffc69d73cd8a711fac861c37727e72ac83477b613419d0293fd1647d4397498fb670d97c10c2b9aa68a8a9ff7077085bbef7263bd8b8714291e0b3c23a8ca46a9dfa2bf4bbe274ffa944019a23e5f570786df2340521dc2abd309f6f007e68e4d1d5852c2441a8ce8efe05a2181b186c9c3af32043909bc37f926a040d61974c8ce4fdfa65b3f104016a65e5cfa2370fb21b3496dc267144d381ab47b1f953d0818fc422494cfb9eb3d936b48d7a7058fc316fa37a0ad1ff654f75b71657d4756e461990081da5169d71c25941f245e208b01aba2a7bf28ac8eb9b2ef33dafd9f77f64c2512e8616c6fbbb41cd2b1b40e4627b317861df9b7ed0fca55b7c0bc06b4bf34dc07742e4d21efd84e2b114c2e26284347ea3a33980f6df4948107dcc79f707282a28706ae9b5013037e254c6b177a46a3aa109b91308eea2aad36b8f15e60c678d3d70d72999612b53df1937755e4da7102bda6afa9da78a5a66d2fa2775c1c319f2046ac8bdbd353db0f26bf6c59ceae3fef40c351ca59471c864dfc72443ba33edceee3aff7ae17f8281e6f4815c67735cbdb2fc5ece809d5c97b23c99b4763baa9b3896199b846103789bd7aced25332b07f4a1531dd000232f77ad9c8bf3956b4870a933cf24dfefdf72d6756b5a7b59661614f581b7fcf8ec15cedd69660da4d02e496dc8c85e647e68ae92eb00b74d91ca86bd36bc44c53fd455b179bd6b18815692c2b3e94e2e34d338406c4ad5bf72ae73895e02d70faa7a2264e7f046e021e0871191236824cb12695d3cf9747f5fb59d3f0bca9da1e497c193fa177651c213bfdc6f1d60ce3599b55be2175015fca0eac232ee5aff3e103b24e93055692943647a2b449df4b10a0a9df1c2c52bf01be142fa765e1dd4aa2fc0c440732d9c6d6addc8159ad02a9fecba5d26c6b57806f6f6d8eed70a319bb0c3bffe88df84adc365965121591335a63fed09ade680f20e3876cbe54d70c165cf96ab177acd738a75321a32ec53a32c61daf123430d655b34671bbc4e3d75416229ba30e0d2569b1df52ee6e91e375a5e385a75b137d19b4aa1d84c585231f0524b8f578b12e3186c9b0fb8b79fa336ee7cda0d42f257c6f1906cda157e68e90f95ac84a37594e5875de840fff91748d20480814d0f064d6c3c36399c82607db47912e1fdc50049b223f8a059993db4190f6a11ad51b92306d43224a1bedf16df80568a7eb0e2f9b4216cc68f29a4a21c74dd44c6feaa65f063f6b33e3368f36921f9d07071140b21a10fb50038b1beaab7b75b876eba96f0cb8fc20790a61e2751ba47ca7851bf4bc9a6344052c830b277ad5874addf62311b750308da560d58325dbb09fff6406e7910a96d377d0b05510a0f664140d08c762b5cbcab6210cc0fb856077ef315a1a8f16bc6dc4c263eb1612b5ca2859fdd6d4c64b4927399d7743ab2e9420fff5fa3338500cbf4fd74f401ea69fc08d74a137f30ad327bb62d940f4f682e189c62f50927da3f58f533de0d7c2a43329d04c6b7a51d67ef392d7acbf58fc2763b330b7a18205e5010e531d0231d9b1bbc658e351a24cb18d85ec749db69bc5fb999c477b177ba6eb02c712b25fc522da4792742dc8eb966888700b13d6fc922c27c84aa427d7192450822ab393d3989b979ee686743bf9a9bef53fc2a8e090102e5578ba3e8e1d17b44c085bb6a0b2577c6827535cedaead76e1c322131840590ae38feceffa55efe6bc400aab041f20bc58a0b9f09c255b574227ec09140f95916b15fbce0959b7087b4f3f3fb579cb29b33392640d3563d7ab219b3fb74b5eb73d103b5bc727a68d6246954af1358772e8f0b7f6e61fb0058260d5f73dc6b485bd263e140c056e48138d7d7bbf03b0be9461a371a9174be3fcf10341a045d44d537171f5f03b0f2b171ad579a3a99b3baf59ac02312a73f31eaa502e9767437827a7786e9c8bf7cad30490636b3999fbfcd91e22f0a6ed148c805483d746d0c43149737f532d2716e8a4a2711434aa6472613f94821ae61c5dbfe08d298a54fc8cb488bce5bc88fecae05a5dd7490b1235a720a3510385bd0103df0b69f0962da669caf158910f3718839cae6382ef435a307538c03623ae21d5b549d662553249b50f136d3cefa403852aeb3f26be310a97400389d7de6ef02b2d3b0b2ebc006e95cd58196f894bc4aa11574edc681803871e70ac5b7f0d63446527b0a244de06b37b2600f89de231d6c32ebbcefff870dc2565c9d19f0595943cccfaa9e7c205ffbeaa542db95d978e9a934e0e13c3956fc0a0beecbc99f58b4956591cfff18d45be962c6cce54f61c323ee8d56ad54279c66bf08505cdce6919a673f472b41b6422b93080c4284139719290b2e79a4424c95f8d718c33df0f39b42b0a810ce30213e49b82428155f93b4cc28cf14161b66cb317852570d130e8be3814e5e21efeabef3def06451a91e0cc3b8029288f3975f9962aff2974cfda44ea4fddf0e83aba3602b9965eb0fbd1d318d0625840368f70cba7d30fa0a4b6e5b48eb9bca7836eda4b311d2342061e27530e68d350dbfb36878026c615b9efedc4a4ea5dc60be3385711bf7994b9cb0b325d0dbae5da3227a9bf621513eee64c8f0ec6d7d201476a506932d1ce2f67698702383846af0450b5ab3fc3c61db754eed1424554d09b0da43a33f6b78c205d217d95c4c1c1e3b219d5551d1f98fd68d39f94ad03d8a1e1dbe5946042253eeaa212f70af1b32f4144991910e1a3a61c900bcf0f9c1a593e7df03e2a1fa4df9c9512893837aed780b41bba1a331afdc588ef5f50090995a0825497acf28284c525789d0e8841fa57f2af22bfdf8e0fba6baf9bcbe78c762ae25bdc1378fa800f216a5b59ebb18fc726d23f8a49c50d05eed2d4f50863c101961a099859c0b2c92fa9fff92cfb86ab40e2d0c3e765863255ff47d90334c5b72fc089023991e6ce5d5d6ea092a264b3c9b8554eadb41e76da7b1be6266af6653b4ed953e6f7774a595e824202417cf7b96730c601cd6da32f3498e8bd462af6570a32d714d1674a6d663745092ac27636257c95b5b938f84928b7bf364f8ece6b40f8f80ee5e86cd6ba63fafda884b40e945051ebaa6432b84fc19e0dfb699dffa60b96533cf04bad30bc34fe1dbfc287c5edaeaa14819bdfc885a61c9a0ef54d713c833ef66417245519b75404b7b89a2785f0b26dcb4668318ad59d0d30f6f0e391f916170a7986660506c224e0f4c0456a95b23402b67ed5f8757ea504ce2576c74d3a28bcb8b176a5e2079fb93e5d310a43826fa3ec275189ec665b9a6af3e103c2d984237965a9dae94a423644ea3743600204289eed87c795cbb1074fe50c53252b6b43862001c23cb7685dabca6196ac1bf74ea86debb3cd13064bd44d12d27fdc73a264f106545fd5cad640a57bee1147766d1a16f0a985323a625112a052a926d1235f0179dfd17a73d77e9a57b9932d500b6d4e331feee81a74022654c48d6efbe9a802f50eff7cd3521781b0336bc772783c3e3c036a5d50ab9b88dae1992b6045795ec9a3908a11be0e5a931abebbdc48644f03d97aa58154530eb7e0c8c9f62cd7f7204de26cfdc5128db71d547a9fcf955cc25202ce2633a40c8aee5a7c79c8cdb41e0f325f89624639ed7b6f988e1e718d43b49184dc847dd93c16dbd02c90b970261811c934189b20bde032f57c0dc131a464ebe20e7e2b36c04e602dacf7c79f05c7cce5391c58992226c51bec8db0e124be77108fa68d02fbe354422bbb76912653df84d05055ea91653fb2917a42bbeec01c8ae8b7eac5e419604e444ba75c97fd3d1881a797acbb9b83c29a323f3c4e6452a27360aea359a40e04a80b26e57e863c2d0017d925d1e0bd88cdd00fd3e35a619470c6d1999044f90d1a7326775d70bb27f12e02c91c10a72f27c3ecbcc447cc1f5fcde773619ac6d1090d2c7bbecbf3f012f32291e4fa650281fa5c2c2fbff1d8a9a7bf13303ff09a097b632baa7c1aef118f94372c76860d24eb455b50d5beda6b64db0adb46b6400d4a433464c36a698e1b1ea98c8716ded08ad1c18c154ef2155f238acb19cf6cb8bfc388e5e6b0195486a622214f4a013eb315064c8b2d81edae320194b546ebc8a9388802682841236c376035ae8fb665474cfb2037b647ffd0124a58168909d362f610c20f56589eaca36af528ea0c96b4332036ef75dfc55ac58e235d2de82f13a177856f3e689ba2279e6d787de1ea1025d13996298c375e5f96aa355b9119e4be1675ecb95b22ec4132d425fe58c71df8627b3a616c1fb76506ab36096b979fdf9d697606e65a4223c48f160a1a840d8b3ccc2f2297a3a9b47c9bba09b652d0b7a9204ab2b33c4aa6c1a77b33eb8ba50e55df12d641ce9c75eb9d0ce7b3dcdf54e26bd50c9b1280ab27b146c354e0851c9a208fdd96f0fab2698210bff0659703d14124fe0a6173ae298053943f08db0e656133b3b55377ab8b8cd492a3547d2f17736f4165cf04f58e634f9baf96baebaf6a89f9921a98b14c5bb5e7d5469f8324f8cfbe117f8e7f3834947202e16bb9c8bc08002f2fbe0793bdac2769c2b868365ccdc935a7e196d340df07bace87b6ee2da639ad1e331dbfd36dfea474fbbb5a1fbb8685e3a4f0037cc32a79b933ca9603fdbf4f576e0f5d99ea7f07d869f8943b572b43da8eb17d6d2045d6c4acc0d80b2811dd7b563ca63ea1871b2bb02ab741f40ad53a90205d4d116e038b8000d0777abd7e40b559d216911fc21a09a5bdbe72d223b8408a01d3801a64de9ccea587bd143ef4437d42b8de4551d4e41fc1d1ecf61a0ef67bb831922ea36956f8d5d5ab340172e400410a8b81a7a41a1aa83c5f50ef0b6c7ee6a5b4b1368a53c679639232e66b5e70ca47febd7dc70cb4d2fce6e056023d36ea7e36cbdd5e707697fa1f11cd39d3eb7fb69ba0915d59d251a8291f8f8ad12ab77a135a19561192b394c138927d4609220dbb91e3c0f798a81dec6e7e0ac23eefe39dabc8bb1ba88f1a7490822d4816f80f0c4cca0f1ce9fd3840a36311572f859d3898338815d74512577cbcaaba7145bd67947eac75a4fb919e392eed190fbb71c72953340e8d80521a4b0daf1dde66e94f6457c012d4a9709aa9c18b9fbe4e537bf8dd06596b755b1bf6c9a1a0cf45473797a1f99706bb4ed0404fd4d9030139f91ac437463fbbbe2d3413e041bb406853fcfa47b9dcb84aaf43e2ee88a23ab1e02f43da9e9e4d68eb5d463ef195a966fc929c04d93922392423c9296c1739e7a3b05b77cac15f242d9a2c8bcae6a5400cb6f9691c9e11dfd0202f2b39f8a8532b068b7b4f0d1378ffd95141399c7c80e5a1b7c0a5f887023e24254de5e57609fe22c91fd172ae22b1831dec90b19069ce3f58083d841acdef57ce6c033421aa0f22079acce77059a96ae43d75a0dde22880007e7130a5942cc3e798ebbf5750ccef370cfe308e85f6e91e2e6896b549592aa7b10d090fdcd2747202ad939c658763dcfff8a4530827a78fe9819df802b7baed577edca8b5c030068683ac7055b8b41e8c73f891baf0fd446b39de236c1c5b167bccb431e5d45985b6c9c5e2e0bdb0c6507c8223ad2afe13444e260d45e5dac33804c0123488b4580013d5d580d8344aa5945717a277ebeeb955c2ca000e9eeeded18c0c58aa9b7a794ab5e3e8e3189e6554394efe657e58b950c8abc88b96340a48de65c1db3dca90142c6cd62f1b9e939d4225c9e2e253862cdb65dd4f8dac58e00ec3688a400577e661961f808184e84a12aab89243d66f2b69d2086123d0895a012c5fd36850c6622fb84f93ad3703719e5b0d94580fa8d3c433e576f2074b38c37343e94037b32ff3cadbba366783110d640160787e5e6acca1bd886eb8d4cc21ff2d579e0d626ea255d83357b1106622f784347fd4b3b640ff9813cc95dc739a5ceca39580329ff43fd2ea3936c2e94cad05095a7bbf71ce223082527bd1c48be26183395e63eb220234ff1d07f628d571bf1ca9dd0cc3730d473b01fdf6ea8a629c573b85e426e4a286353c61114c8c44b3dd94a99ed48e277227431b90c308f47a55c196f2089af3cd2848bcbe01f81dc53873b8056f62bec6a04a2663477f7b844f78ef7da99f9dfedb16e1d94cd98420e7a1393fa66764d4b2c74e8679d699cc3ca0090a4a364cb86bb9b2940e26c628bf3303bb31ab3b15708b7426fb2a54735aea5944b3c33e287a21ac05f5e9d9c65c6707001b9e24a53546f2f82977ff93dc0bc6d84afd368255bede305906048d1d7237f56d7f3946358fd798c8abf85c17e8078c5e47e0f2dbf89c1627097418b4736ca0f1c15535b672638f648f25f00a76a8db66d9536e8efabe0d930d5ec5ee1d9c56e654b77e71b52d464b68ad486c89dca6f7e9387d4c85e1803e8467fd2f58cac403151397390979d2ebd39a869e28da4376a4e3a3eff074f293e1ed0fa340efdcec7e812401f576bc175e1e642920d558bbe3102654d1e766583da919529eebbd0272a158927bd79907a8ae0c87179d687416c03e905139698c1ec970050883dc3172fe9c7dd06fabdf3968515cce5c05ab9089a6a98593167fe3ee28f9425a6485fa86155fae1e378ac84159a066ce02063cd62d5df08179ae2744ec6876b7599ec1f5c25dca76ea0552ebd1933fc9963c73f45bdb19b642779e006eaf7324eaab03fa64d68271997bfb2b5b5c4a8c3fd802a59c5b4923e1788e7d3e2338c0116cb6290248cde3c26857f873eab4a2c6d7fc5a3486b020a6f02cfaafc17200f8b827bdc03f4e86cf12e5bc3535527355a21d0c1b25fe4a609a60da519e7463c0224be8fc4b2edbb083c4bc6d2abb56bd091d7da417156e8d1bc9a61f2e0a00a79737377340d639373b338aae6b8f4868fa10730724cad1c8c69b8c58db6b4c29284b16eea6be3c5ab8299d5c0fb67f27f5d1b7fac78a307d6a17167920f68006090a38a7acd24634be41a2b21694b9540dff50741517c145e80e696e1fe9f99c09c069cbba6220c5e6d314b4dfac87d65fa266642ab6cf17615cbf7fd9cfde5a253db4f2df9c8ea24121321e1d7e0c8038dc977366796d5fa510df944c8ad8c2191818c7a5a33c7b7cc3b4b183dedb1a61654333b90a9de57a00a0f6b1a5a18c554f516e52a2cf391e3d28a40d7155779213a3ef58aa197fead8bee2bc2d90844520cb07a0abe7f9d9d7594052d416190c42d74c19e29476b2a4ffe731b8e1e4053d4718771b730f6a25a542fd6041bff99763c4eb476e46108373a62b27b49defeb4f36aca476019bdbf96d663cddccd8455195d9f64ca5e1bb3644e5d3c02ff8a48e536733302fb57fdb0a289130919a2106dc9660af896d611fe2c8c2abefaf7d735766a2feaba3b25d69a76f9f5961d70e064a66e179a0a6aecc7d3eefb77b40a9c6e6cee079b7c464912090b0ce3a2f771715a2fe1cd73fb27be130aa09218fe504bd9a8fab5a5803cd1dccbea5df14c45d59c8afb10415c3be2f3e2b66fb327f54e524ec8fc4f9558a469eaa42d03cd81fb135aa4de833a3d55bbf7332ab4daa6fc71b0b2f1080c291d3afa91289cd1cdcf9b1ad7dceb05e0ae8986c33d6225bd33457bb275c0d1f31909df6c4e1db3aa87dbec3a6401b83450776f2dfa816ec3126ce17e8aad9887360db2f8edbc1004a31f3d4d4506726331388c080baa25b5da012ea8c7c959c0435002cfb5f4b3bad121dec35136a8651553160fe0c8ad54cfaf48eee608937258bb16cdf1f6c1752c19faf15ff065088b03831c5ce7c113b644f9e167295ae3bf9463ad59ba1ff553446d6b13a1da58a724e17a039cf693cf49646e7c069284f2d639fdc217b83e751c99d37643c9b178df1898120860ab5b8fd07e6bdfd8e0a80ba061ee0e26bbd894c0e57fec683d73e97130631c8bba3d07ab4ffbb26bdd384a4dd252248115a8d8c4be4949e400b833ec2caf20b33cab7c2f154b01ef4a50c6be7aae708081ee31ab6611d0637b3dc0753a85cba6df9391ce44167a6bb1c58298ad49b97d265a4d58814cd6019e130b5d4c8658da08f4381291c0600ba20a127ab79273082fedcea1dfbc39e7f71406d3fbe800b2f5906975051ebe7f5ffd5eb49f0cb9467de193965cc40ae87a228a77db72c26495dc7bcf4c706431c0ea6a458d0842e790bb3bc6576269c0a4de5c15b46e939a4cc8dcadfe378a301f65c849899f30f6f5e9a0e6f96c6c5d42adec803e879734e775dab0de9ba358c6d9ac5f867ae3a6cd6c236c3be6cd6acf07f2fa6431b5d92af015808c58ac751dff37bb8730150212ebf95bb4a04de3a69d3c4aa156ff633e161e687ca31326594c753242a9de39842d13ddf8a9f57fca490c1ad8d589faf2a4b3c60014936627993d50408551a1421492e469a0ab19b6d21b48625264be120c924d10e4a5b1c32c9dab993ad16bc08ea2ca7b1afa44c542d466ad9664d2b1ad6ef880f3c4b85aed92727d15281b32416a8ab9f26cbd838466ef2d130b139235d062d7d67df8ca432cf9adfc463401c5d351229b665fcfe37d61d289bce3cc51453467ba645d3d155e5468429cf5f7b078322819c0a1240b1bef1e630a2fe1828100a55292c41320eeaf6c48078e5fd761b2249b6e86387167a13f2506e98ae9e95f0bad04d88ad718f3f5a50dd0ae7fe69de6b9135118e2fc872fc98c59154e6f7cad6fc6aaf401c6526cfa685f90b380760ad4e2f488757514dca9cec25e0f7848a20fa3ea2c85fcfd62aa7380daed76de2b0dee0aa160ddd0bd42005f3abd4f84c72b26862952c049054943c7c7a73c97195d1ade2d99d8a29de325a1410fe02e65ecf7f244e978da0895ffe932055a906c66c19512a85205f4e75c406260ef47b80902159ebb73f652b7dfb597abb87563235015ef66557249942b16bc57428fec73e8e2d5fb342f36386db41bfcc6f167224bac06c588714c71a8e9ca578abfa24bbb8346f7dbe9da1a02fe46fbb2cec11fbc2795c0b2dfd291faa1fb8bbd2b9165513505a22a9549694198e311d219cef9dac18b333fda05589e4459830035fc820f46ed3a1fdb407e239bcbb40f33c67d486a73b51884ff4a5efc5bbeac56e83caea39fe1ee344c6b66cca477cc5d9da92a0d0c1d95fc2e2db2b8b1a97a4571285db313e4809a1523da51d4accfad8feac0913e82b7962f5d774f25539b98db61ca0c6662e2207c19e8b7470b1038f779efa75e8a1ce628ed073f6ee37b49c119a31cf0e5d80dbb71f263ce3d9266148fae3c3465a3de1dd21f241ece0efd0f71aab5639d299a03ff452e85e2788fca070174acf598c22772a0046f32ace8d848b6b4643c11e045a840e61d5dbe440ce7c8993e4f5c26679b4fa2df66914b43c5311497062e2d1656173b129ff1393d5bbf44e351968bfcb23dcb5aa72bb6f9ae2a2046ff4c3b7879d2c10fbc93bea96ab418b358f9b5054b54c11fae75f5e4efa7317ae67f632cfd18303331a2141ddd74ff61acbb3f0734e1dba05c498659d489c4ab92f46a3c77d12a7a898bd0ad59f85e3391557f32d423b277d5a85ab01ac62789bf831989d4c6653eac9d5698ddc9e86135c35049e46d2727943d1a567fb5239983a8ffddc924ef2b191f18d0193a62509e0cc0740847f658d8b646c0bb185a61c6516ab400788d05106364ade459492a29b8f9b8b8c1c78d9927506f67a3242918231dd463d670e5b2990fb4f2d7ba6fafe3cb64c7aafdbfa84dd779ccc381ab0422e9335ae86c4e6c1582e005227ceb43926000c75d277e9e4a76cf87000e9d81e506d5995f881d4d80afc7418212aec54c42fbbd3989f97edec89adb9ae7ebbcecd8639cf660cd758471a2adb48f9f912cb144359ad48a0f92795eaf99cb2962e4aa03dfa5e16d41180490185fc80251cd2cff2550f514139600e335f08104f15020813880ecd3b6d897ebdc982ea83b10d92c2fb1a4870dc8a4254a1ed16c2b6f76fa596b8000cd64b05780f8e84c24f572b1b1f616f269801446a444b7e6de44d047c426c8eea6c30fa4253c8b3900eb248b307a4029c2e2b509d135686720fed063bbf61033a5b6b59fa0ba750f5ccaf11590c83c1438a0645b3dd99a7a1b4d3f34727d71cafbed44972d88b55309c5b9e0a539a30733b3d91f6367a65a523572340edab11daff1698ed555d9dbe248438177865f8340b6a8afa11eae0edc4c7793fdd534f00d75181fe50c76af7ef4d34679e44a00565bb08217405c7c0a13df333c52a801668408d5879eb0d426c958621631e4911ceb9991c9d301b464dd2f48a5360cab0d8f4af60f37b6870792f3643409cb7cbf1592d727e77b3a9efbda417a0b4b72ede3382e4ea0ae8c1dcbfa0f45982724b3ab3d585a96d75349fafb2f024ea95388d929ab65da6bc10cb0355a40b9957aa809caf96ec6b66196426a4fe52fb0409802f8a0f40ef69c7b2400cb8bc5bf00efd686e57bb72aba55ebd09eb222036bcbe0df7eff27d49cfca3ff02ff447244f3f34cde2906d5470cd701f46c36d92971e2b5ff7fcaed4f56cb1e124d861c5a2dcfa575b4bf8d36d29857d188c3e8d5672f5c928cc877319a9611d3054896975bb268af0e312093f3fd27860e4268d3db2cbd8b958502cf17bb6d460664ce59e239613b8f7f5059cba7c192bbc442985a9659a2c376bea20358b098985cf3ab81d498bb1f04340bf063f542f9187a346900b9b2c7280ca697b8d83002f461c1693a7dc3c961e988873988b69eb529b0e6632d4ca39e52404a416d47399e5a4073c76c7a921c5b0096a426d7d8f810f516a6cf39af260abf346530e72ad0f75aaf6216f8a9d890739452fca63e03c7d44bb3ad81b3bde560a27d5c077a1a3ea86629792e7887788305dce58902138a24275b5307bab9966e099dda658ef3c69b5a4a8ef386b7a1927172648522a8c527b7835518387a42390359685c1582f0ef1b9de1832ce82230ec2ccce0e9e2008e7219aaeef24c6e55a489ed0f3203d85223282eb0122de367fff1f1d81ca74335977f6677d49107fd8487834270b9378b66bf0ee5c6acd9db9c03bf24503ce813229cc0334761a151de515470f62ec2fa7e76641f3b7974f202303b904e446f152e41782a98597bf6a69666a1d410fa98bde63ca1eeac63d14755b6889e99fd48b71b831504afcc9d3f2e8a2c557990c136256ec67970771816b053129aa9f1bae3066be24c6aabda736d3376c184fe2edbbf515aab4d721f1356ba9a6f4033a3b1bdd37a32bf76b9c623e0fd55caad5b823806ba18d8b10e70fec7e82e7c9e869832f64db04fe9b69884355733408d2b9e4a1d06ba69c3b8e2fef33ac61dbf4025a82ce2593f974b09e521b42bece39e67c05cd9dbacaf9e3b01e156348933d1898380a6f2310db897f4de2e99d7374b5bd9b79373e9439aef4816023099bc5c1ff20e2c73e5cb9d9608cc2813f597054b521189e709188b8fd8adc431379abe1cdf398fc026ed65927531345303c4dd883a78b219cc17a9c03125793d57c2d1f3b4c23b2bc77456c0d5faeda3ddc57e49f5dd1cedfacbd08356ca378b5d675a868ed531207894596bec18cf65e7b7e7dc483596785e21a1df7fa4810741bdfb45b2256d5db87081c684817f840c9dda0108d6dc28922ca29109c3ad5f3919a42b2f8b629a6e920e75e10e91ad712ae7821df347556092cd11b5569615e80bf5d84b596536c3512d54b6cbed60470387908148b4db9c71508a7fd3cb5bb76f17ce75639c6697fc448227e1408b1187e66e50901638b9988a8be87d82640348e17f193b9c977502d647dce20a31ab22d6f245521ff8fac7c5e7b9378db9cea12285f609d0bf368ed1e95f71582a0ae43dfc4bbaf068812959c62733df2cbf9f7b726d75137038488a0dc5b76165b69e44ba0b17220e1df4f930c53b2a368de512f82110f84fddb45cac545b175d84c93e5e258b16c71af7f3e58863e91ef6005246afe362c8a564eb46affa71d825d786ff2544d44a80e83f33a74244b625411b8c10fd9849d3049facd90af1538945b58b81e05d5e7dc8572fa71412827b0fbbf858413a0ee2a7cc57136a6f26c16695961c4433a11c71fcda4b5b7075602b3b07960fd65712f50152d57aa76c5df4db7c1809512cf2450b0a66dc1a18ee923e64929afaceb754bdac2fb3ffd07545594d7aacc850d4227b320cadef97e27d849d930838fe4d87171a98cfac288cd015758e00c2da64888bf9b7050414d74193142bc2527e7e5d4ef9667d1f2049de6677ec119c86e3e83d08a9314622e0173aaaa5c8b04bc63cf2df2125860385bb270a20501e4629ea709699585235a8a637666c4a2839ed813cadfc92db733bd1505af4a7191e729eab914182880748d44679e6442c28d3f3b69d562bc8bdab0f8bd1f31367228ea868e7515a5db986e3c4fe586d0fc62f8c6f534f26ecb81a1eef131c9aa59ef45f3d7aa12eb25e477681309c6cb22733285e5ad2800f83819dc97b36b76e8a8d2f03bae75f02bd51b0b093972b24e7b863638148488243414e228b9f4f8cc3501e72f4370a42726871c1978f3728194349a07ef5b5ee2f5835c8af904e00f7a35fff370bc3dafcb1e259e77f87982885254671421698ee9854dbdb34c7962e8d80c3bba1778f461b886ddac32a84dd9a12a431f6a98c8cf68519aa43c4ab264a7aed9f863e44025558592e0d69d0c70419b4f318c643603e7d3b3e076557871f9128f0017e7b1bea19b51fcf3acd5daaca901904f3fdffdd0b60efd3dc630c0ff9843b98cd0da1d88b88ba6c1c4439dfab7aff67658f5c11efc3954e3b034a45967c3d3b4bee99d774e8bb5bfd4121f889f6f395047e43fa1e8e623e921c99954d244ef2c140ed3fe1371cf4d9cf5d429f067d9aaafc9499f9287d94e75461eab38249f4c4512ea0220418658cd3febe25c012c33d149136aaaa8961aa033a933dc25fbeb9d207573828c8affdb991f47b86bf87f6945cbdad94fdcb236fd9de16d164f78b1212a3267b53af8d2eccb0282234f22b8afe596515f4e704f42f6f1f77dca8b3797b36f0e506db97a3363addc9159534ccd4780328fe9663d3218691ab4a1694785d3f46fbcea8c2da378555518aac76104d823ee33bc4eb54a630c1d3bc4de4321b7d5d3571752051a1ce12515708153942ace6d4f9ddc6291f7a190e1a00aa0fb723e7b305ea3bf216112bf000c7ea395435bd0271f2ea956a443af2b5fd2819bebcd7f5b8256fbfa043fc8283207c97ff0617dbdff5f4ec71d38f079cb8de3d7b724d1cef9f594fbd50ec8d059c2149de7826ed307528d00d8c578d9bb7efca6ccbeec5697e50417fa4d223aa4dcefbe3b543662d916199b74bc6215ab7bc68876c1c72a02d45885ab0256cefcd6193b8c355ab4910ef844cfd91c6330016f27fc9e55c094a80e3215fa1248dfd9af6d4bd3bd396d0cfd9fc18f708eb3ecdc9dac9eab4f23c775eb35faa07373c9b46d823df7e6e000ddf4b3f6bb8e616530747c4120bb8953e86b23fd4e1f1bd6f052c41cfe332f958244072793282d72a4363508877cdc4783bad0de1888965d89ae550ecd5a07802d58084aa649b42b5cddc3ae8cc2b77ffb325010600621cfa9c952658dacd153f0230ff318378e8adcefa02d050e0a98c709adcfb37d011fe3876012f000fffcee162d96347edb9cb11675e6ca42e9c7011e48c72ba712672979ffee0fb108df21874727cd30bfbef191304d6e7c2e8ed319bfa9ab052bfe5dd10a332a3d3fbbb97776bf67f20558cc6b4a139c4bce6a4037a8d166034aca5782da920b9a6ca9bb1aab044dc7f19de9bdef939deb7c11b6522ad679753b91a47abf54336ec333decca1b65f167d8f4fdb9580a289b42b21d3dc5a841d7e3e953ddcf3a8f90167ab1351dc3d7544eabae4f350057220dff4f039dbff6e0f5c16d56afd24221d2583d8558ffb4842a53a2da68188447a9e3983713be6078cbcccd41bc7a17cab154cf4c71447a99119743db73bca205184a4557237b22f748b7eb1dd8d7589b309431b757b8650ae046974f610447c3b95070a910f73898ee105a5a9ce62849d5720858b35072578164c43d5c220c757f35110819664bd0ef8948737531da84776e3192a784bfea2856fb66efa403afed71e9c7bed032952eef31d001d0e631c8d6105952b94ab2ece304b487f751edf3b58f7a8a661efa2f76e00502a28c435acee148e3bc0bdef461a2570fbc1ce10b22d101a5e11d521f562f350c653f4b985d4967123d848fc9b3e2c4c1009d0209f83112c3c4b6226605c5a158250b46c7718c83fb12788f7a3a9b342809ed4a32f1f0bee88d8ea43b2f524e86b1bffa8da79aa1a46143785135271efa17118d149305a6d5973be8732a4f0b322be56447651181d68384facebb1bbe361a23220cd41ff96b889794c1eeaf7439a88fe70b093543df721629d8bcf4c231505b078fc526a6a674a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
