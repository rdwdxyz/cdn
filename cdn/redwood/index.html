<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b7b4a72ea723d75316d6f97753faf0140c3e8e737e88e91f91183b7f88261127ca90de89a6f329b533ba417fde9f33f88c821437af8d069de7be668f5544d99d958ede74f7bf75f4750a9c07bdeb0fa58a72e4a90a5f4a820fd943bece8efae6b6743e211fabf9c70afd6ec02e98aa50a761f013a0c8c94bc56a90f5e3308def2830bb702e7e427055a5e446d65c75b64cfc50a673b127e02dae3c2cb3b4e79f8a1fa1c258439705240a02e80feedddba9ffaaeb5ba29ad809ca9239f280471422533a1eb4c554c600b1b27fb77dcc1d64b078e5c1f9eba2062dc0923eacd9e595d07efb3bdfafaabfb00e3521d6834e51286e73ad0351455c84ceded566717d7a9a4e473d52f061bab90688a3f5c2d39fc1c653204b1729c0984bede7821bfeacd93c0c518153aef30cf2c4360e7f74bf265367672f35c0c7b734420705fa78f245fa666a88cd70e77792bf5ffa02cd10cb019b99964c0380bd333433387d36add7f9d0d461d72383cb88d7d91e800237ac47f78b73a27577b190c7adbd36507b49580935aa6dc72d872ca6f8775edaa4735345b613a59d1a7e49f247d3a8cfe04b5ba55cfc2a4dcc05c4d84d08ce2d997223e23435b6683c5eb69aaf6214afaa3c7f00bcd16bce9c4d17aeccf9d7186f849c25ba39cc12dc106282c377d3ae4865279b6ca378f40f1567d998ed04b49273682986578ed946789b84738c4574a0522b0e4382de75a74360e1f8c06166414f44b4d3b8f32a0b4614cb1ef25eaa4a5ae4a50af47729edd680000cfbe461d60090e39b55a6042ad926078fabb37cecadfe9c73d46366d570e397efde30ca3aef51a7ffa6d0632f635419fabbd684114a8b3096e858d7b7bcd0f0ac5cc5fd4b308cb7cb6372f74163a6a5b0183be178c7327e921765029e009550d7fffacd1a54673dba632db578b94be0b69c83761ff73373217164de01ac58ab283fd20f7420b5221a26d1377ec54d329b1c1ea8a6f32bfc7426b4ba8174f0ec65a404cb685a024c3cd52d6552f79c381cf2ee0c8c0980e41de4e19e7f4da455c68e84b4ca7ce3dec81740fae0a2106f06bdbd1d6d716baffe5e5317d549af681f319d494210430c91bc9a199328d7bb027b02d072ed472e354aa1e364d8161c153b29b55f78b9573c73b63957145e4fa014d706c6f73e320d37edacfbe08fe07ebba41aa7c67d5cd27c95491b0d167669577515b55930daee12a9f37020ff6cef1a4d84868a6f975075b1e038952c85d94c7df684b6be0d62ca53fd9d44b3ac18d6faf7f3d3c5fa94fbf5809e0620dfc8811cb2963b623b8c5d7324ad36c4bccbb6062c10c4e64e7738ddc7979ee3c029975b7e94a4ed08039107ceec26e1817f93d48818a0a30e3b3a2ee68d277196f80f08474c7211060c91c603cb98801559e05ff244d981938506c8b3292778d17a503ba65ec3733b1762148bfd8cb237a97b4b2098cc17a044e72196e9e6896f900b33b7686319c0c6f7edd9c84931ef1b1aa801b574a99759fc5125776921a40d99145a358ae6b6a063f535d09f08d7daefa0a3025336d835f19f8bb3c6bf527e7b083c8e2bd91a915f777f023119613c9f31500b365c767b195c6dff93ea11651285b47c92f943b47f73769c2fcbc1de70b3682e31c5c1b1787e3a8c7fb7428366c0ac0d4f11d16a3292b9f8c5dfe6fdf60d2085b358c3ca6ce7e82847167bfb109ba21dc89a91b19e01b3e633fe5148f8c970ca8ce446c7226ada542c8b149c1bf755de122cfeeecdc95e31da291b9757c8503a284567ee91372f7a2a1af2b0f9eb4131c4bcda0fc1edccfc93508d5eb7b4b4dee26920c7e7c7a9ccb45b0aad12e63c87e1c9b0583cff40c70a8845faa5dfd4e55b6a876e03b713323d1b5131188ae7870590d334a0513d2196234ee68df79c7e1af9a735027e1c9c5b4011152751bd105c5e054ac2f52cd4f427e000d431ac1878a0fe513678f61404fb38c8deb34cc052d8681d3dec16dd8234bd8e75542c869188dd4b34d4957bdd8a1332c93a4a133b0a4519096e84bb79ed40b93fd381ea6657885ad14b85e45f0a50dcb6beb1e7b1023e81fac968e33e035c67fcccaf5ba0a2fa92ad5b0e1e468503c5e7621fb631bf3f4d68db9f68a69e21f7c45720ed3e9902ce022a19f5d654113bcd2321697b7297e8edbe051207a3f0876cfb0a31ce360c3a0d3bf6ede2f4f4a24088ac8f7e6dec8f821b1a893226f81c619c2f73de4b15404f59c1faf5a91ee1ca77fb96c5610f274fe4c6b4bbd16b7b4c73908991b7b2bc7c2d57462d78ee0a71696e7b0195ade2cf81b4cc8b9addcb68de3378b1cc85a64d329af30f9025a34e67b1cfb1c1832fd67c8e0f5b36d6a1be06ddd6f091d9d067395e973236fd904477243c8c360f74faadd3a7be14d97649c52bcb5447be3fa244dbcdd8b3a8a455da5409a212371e460252e1e75e3dd817f3a14bd91cc10b49a3b9734272626b127b2e7a46a106ba50c7971149c93efcfd974bcd8e8ec9b86014590e9273275b865fa1debd4818ee017b17a08039e367780b098d3d838e8b568327a5e47be28fedb43eac4db4e32bc89ca0d11b8b6e7adf0ef77ae86a04ec7b049fdccd54171ce2f63572f481b6150e2c3aaaf8a83157f7ac5f97281a32f05e7e956df30fd832a7afe50b29c16367caa5eba17b0df2b70f752aa3a898b0b81e0411feb228d7706657905a86b7153f88a69efe444c35c37d06eb1ee16f8b86f5be1c03e414cc103bb676f1f888ab40a7d3116a4faf33e377bfc4cbd90584975b1b6c51adfef59d9e36f4c0740d5b3b4e2efe67a50c12898e939fede9febdefe0bbb2ff8944f9a2d38870e0129e929f0d658e14e75da1ba1d0f66ec9490564b770812589bed4d4d9844cdb339a74153f5ec5621dc6f53df64a31e8ddf71187a3967d77df4a6232839becfb9f96acf733a05a0d1443beec035157ff1ac3a6133096033c7d18d297a088392b5130f2457fedc4ca2184cb772efc3bc5007b7f09b7100a047a4669f2974b62ba88f7300b6d89ce116f6f6c72ee5d8a3673784438c47a6a3ec6f7c476be6bbc8f0c3ccac3b9610468ff78e3e1a492878a158f43b0b6991d3756cec1b2cd911c5a1e283eb63b507d8a2975c4d1c3212990f6c131b6671b0bcdc30e2829154ed0bc471987dfb10f468e2abda5de384ce228b00a082a5ca3e73c42c718446d48482da27f0a10a940e3620aa4953a0f4955383dd54bc417b3d9e7a35df24d869fed0196f1e92cf920ac0aef63e02f6d44d03b83f8e0e9beb85a8f5db4cad417d8285d6a909fe4c687f5ce41a74e1f91089b9b6bbc377b8797d1e449c8e5c8488071c6cf156586b0117b6cd2af9c55507583e7229363ac039232e1f3935223932b83655b223bbb22e769649058d87d27d67f3de9481dd158d048b7af2d6ef3fe29514c0f011a4e80932bc790d701f1f8060e9eaa6c62c52db589b5302583024579b68d69506da2c721bea5f70b0ee5edd7fab4e04f876b8411a35e6f7e2acc9bf2e31dc9303ccd9299c67a01e2140e661ab60802a6cbe6b7fefcd18c1081f29a99aff65f4068a762c20b00f434f29e65925f0bf737a873eb45331c5567453fbc899cb162231e1d8aa295741ab503cc33713e7192d494a7fd4f5e59069df2b4b51beed77cedd489bbbeb24eaadc9f5575b1523d7fca5e10a2fd8c4018efb51633b971d803e8c9c12aaf14eb305f9b17ff68369874a5453f263470c67fdebd7433b0365c51ad5fd57ecfc13d6646ef558f36584474343bdf03919a093cf8f64e87c5e68e7c5f0ea2d112a411a06becfbe8bbf0c4aa9b06a1b04a46ef6144d16cf510e52917bd7d7108a3330f9c9da23cbb8eac011c03f8e13b0515875121a29e53db2a4f33b7c68d3299e93e1cddea31a5fdb2c3ab57239b6672ca3ccaf666a6c66a1258acd0ba4f91daceb1c183789b30f82aa0d296c4ab4d4fd0cf95e808f75b29eeac0a19b5a2992615e80ee46c4522651d0407fc7176b05261e2c17b551d8cfe34f307d2a2f61e6f3b3ec646de7b9ac8a6a88b08c7a18249eb6612146bfff19fd32f582db92c56e9d4f7d3d797256fe5608f09fd3ce400f79ab46a1f243653e58456c7530fbc2bd6634621b5407e3dc660aff5473ec8df308496f2c52ff817a1323e1f19acf173cccf3522f5a53a9d0a33285eb19d4cafa51ad08874e8fc840fc16c45b40313cda88c0d5be4cf6e168a44a9d3158491e8e0be29d2c59c5be0089d6b8e6931aa0316fb127d90aa6af03b206ec29383083f5a58cb18e6bedab1fd22bf3e4d8b0bc5edf44bcb87632094a52703459f2f27090d1629a69372bf610c869d9b1bd0c083023c633e0d56f021199f6388cc8808263239dbaf19746a50921847b4143574535efcb5f15d04d8ee344a5a38ce55676e59ad411af2d63fa3920a9319d4a85aa7f6fe1eee92ea2182777b0b71f2ce6acdb5ef1f5d03b7dfc495026c32e4f4c990b921a442a52af73589bbbdb25603f334ec069a02c13a11d2b1565d5b7001cd9ff7a69eba0500964766f8831b0d1d33b6835f4298c9a5624b35f6ba78449a70a2ff60a742eec23e0efb009a469af2211ed46d9c0fd692eaac08d65a7bd844732d5e1973b2e0b97495c0ed11910af9dea19c6d6af3be4b34b2d15000cbe01071c00fcbf5d155667fa9b62ff1056cbef7698694c0a616a6531a6ca7c068142cfac2646282e28eef24d8c54e86f91e1edf4a2e7ffcb725c639480206e6e63750784d3559a9901b8ea21ca0758b4ebecfc143eea80b0ed0a50163206823c6561031ee7391f29ca5808f7b6e284385f9babdd86404c42d3b4cb4e2ce555093d50c6f4e1a485a0ddec00fe4999a6886cb118d78286352f31624ca032ca5d4a114c89f7b95951bd0ffd4ced7616a6e350cb4b2838c16619edcaab7861575fad42fa40a72f0e8cf36ed7df2ddff2c76e576d00abd697e03b4b32ab647ab7018376e0556efec773a46d87f4945dab50e8b17365c35aa0635cc7cc7aca3b87988df5a93acb55edbc662253b94e6ff0074b0886b9cfe6b631d8719a117f948d6cc1947ccbe08d086ceb96b6063f385aa07de7bf4c10614f9548bc0bb1c70aff9a65044a6dd65e6bf7d8a8bf45da03c4c60038dbb5d4580df51f841a63e715d85fe235a78ddad3e0d1b95aa7981b545763448dc51ea3ebf11e2e69c3dbd086f9fc69c721b8ffcffd422abb1641ad53a9e591667ab3dc5636ceaab37a5584d9faed2e8de42e376f36fcac35e0a3ee1b2f223e4d721e4607020cea0763f5c7c94f3765a26ba6e59f5957beba35d1be74eda6860ae2ea0b556a782d923662634b17732c51b09ff30f23d4750163a5d79ed87236c87f1d9343428916220648348ea66a6fe0b1ced7905a783b8057780ab31c677cdc3b4913294d5576cfa903749d4d9d30ac353c2be3f5c730fc3782e6759974ad74c732c0dfc0f8e52f48eae4323cb54756c6a2e6cb4fdb2e908fac71ffadd0c1eafe9bab07fd8566ed7e12b7c3216c7a51987442608b3b0c39b492e2c687d4b43a89e9a32512a9b0a7cccccdf28bd5cb5fa0730b80640e49eca54805b174e5db3a123ad3e95edfb942f280a8995c68d0b6ed15ec2e7700472c8af83f4814bbe05f691a951d4345dd4e903f8d44472987183290fb143f98baa290d4ff5788714d509fa022d32826c5303d19b644e2f13f94dc5dd23bb1a52a9c8ec482dffabc0b800c6a04a8053e4cb4ea0ca0d2012bfc99d88f5b1e8d97ff22c9fee53222a3ffde6a64eea147bfe099419ba1a99ae508891ac1dacbf30e02921e23be40363d383aecc5a45b7babe84f62c25693fb174b6d5a034218961069b291eda13f6c5685e23ddd3e9fde23783b4c36c25046565168d0674d56f5936ae6e544d9386e2afd6fd41fe0996b9ec42d5b277f58542e9f91f10a9539da55fca55d29fab5009e9026788acdd38092b85050d60d3e79f5b3b31e86462f9c75de33eabcb93893fa122cb3efb67b705106710479757f93269c42902ab49294b07fbffc593dfde1d3d2efa44825ba8bbfa5322a66764a695e385c71d37b063b122617ddc413aa67e126f9f70fce16cf0c6cc921078375e32bb10a5a0a6ed7d90deea6b39e1c2d4054bf5d6f92f19e9032fb83519405dd78a42f7046fd7b7fc75a34a2cdef895a2e9f70ab8735f46e52dea04e1d46467deb1deee6c82079439b22826cfbbc263ec14e8ad8af3f41397868ea7af6941905bd259c9471a05522759489ea341edbadee2c37467bf8a55e6743d481790e08ec614f828ecfde261fa445f11efbc5f2c5ee2ec5ca9b389e120d39e05aefb6c0e901e3c209c5c10beb26bc61fa0aa77b92ce5e2dcfa6a9b0a02148cb378a4a5d30f77989b1a84e7bfe789399c64cf35991892722fe956923186698bd847295da6e57b9bf9e81b855b9dbe91399a85b12db1adcdf5c836df9462eb45aafd28ee50d1aeeba1c257ad3592705332dca30e7f5cbf216e2cc2d87a285f531a23906703bce12acc04cc1a927d1cce4f3aaf1f4c6767d14e64405ef4caf634cbecf97ccfcf912cde154043ab4577c485648018286ce08fe4373c762b0399f4bbd9f35f2d19ccaafd5de4d19147fccb3889bb37b7df504436b866392fd5d7937c6465ed9e79a6e49efb1a6d0a5eace0201d137c0b0217325efbb8dde8b0ed94d2d5bd339ea1436e296c43cd5a66eb89b3dc037f4476d5130d879adc3c59e937b6a76a4a22a1fdd9e7dff3786ed9acb6f08058b8cf68fdaa5240d060aa3b36dd653203c2c16f78af7c2d029613aaec48e48d035da25ac758898692f04ee3d759e698b577f2f39e1c45fed553744f399998d63eda5259f09a1fcda11c3159afe7128f125af9a420f903173dccca06316a3a5b2420d5028e6591669a80cd97102d1c3cfaf7bdb23b1c0d111d7b4be376e986902cacd7163276c98536777807e24d28f89e4084e0a84320d9edd9194814a9cb619e8e3ab9c05cd917c2de4fb50d5a379a3d91ec6349289afb97839b673ccb5102121b1dd8a805f127087027674b36b6097b86aa710773972715a4cd13ec51579ba72aafe50a0c410d9a2ea71b756ef72ff235ae288d3bc67a39ef4623dbb674fb4fa064c19350e090fba937fe88e8f28756d6461b3c002f82b18be9c0f623b35738de75c5c6143a09a343070f62eaddf5e5bb7aec9fccf205de32fef2dfdc44816b64c3852e00f21e8dc165bd116e6edb11f585e55b5fb9ac79378dba2a30d520a0416499100e09def53ae4adbc964a9a26a83e6fbdeb2700361b4553966f3854eff86a1f54656a5ed6cd7dc2de2d2d58cf18862c327e63847408513f60cdfd25f2b41da43d3f2468c8df1047f5c9f0b2e463f9d7c600c85c9749771dc69befb16c16b442f505f091174366702cba1947396c2293d42336b9a50ddb78f18e116f81755f0ce1bb1ece7a3323d2be8133a0f965a1bcd332912a47af28dc1eb6897a99a9e7caf2e0b1b19a148e64d421d3d6c727024c4ebdedf087f5f8a57e3c115ef2c3c6e1e28603a9bf809c40ef7b55cb593e13af3d0b6c26022bd5a67a5fbd778d8e8f21ef8e6cebca87c965ae90c2d1b7eea656affdf7bf461ed7b7d7aa0558918f2c9a5714bc3e156d7a4bdef77379e70c7de7d4474b06d6d7f386e45e77ef93a1662d1fd8017e4a60b1efa1b7a12fffbb5c39a21f5bcd46f8efdcc9be6a614f722f9e7614126801f0f73f307db37e740fa20c6a113cec8537823e29470261bc40a3bc71c8349159588d346a99df8cc1163b97da4b7af8f1e5318b857cdb2ce2f97695ed16bc413e30fbaf70048a756811581cbc41b57e1568dc639a035078e48d07f7c3488fd2bb88dcca2e5f3063816a8ba5f00160c1b4276ea6e832135279d94bc7d1a5b81008f27e1d29230a383dc5308460bbef73c12aa4d7a15f22c3efd85f63a5772525456bb036eb1ae59b8f990432fafe46a767cc1b8c24aaeb7fc4b7f9c450b66e3ad0d191e93dc033abacf7aa4419780962c16b6488648e6b32206b60812f6bacf5ba59a05642df88b828ab6154ab12bb98e0c5b04ce4305850df09004eda4c434c04b25df13b188c197779811e3042f7e38f6b571ba5b9a52c7cb3c87d5e276b193362ecd25b5a1d7032ebb2e39a9f62ff4a91bb6edb5ffdf6ba13b8db133d8e4c4733e73dd8f857a0587af711baee8b4e6a9fbca9908db8287b9749f7eea2b91437f0a758c4e053c94d2e420a66ffc01342b0c4f68a99b59c4fa6a5a338fcfe1ae2d4747558df9a5c79b6c2b57eabe54e01e383cff565100a693c2051484beface87cd1f4a15e98f2e8e9161eff96275738c831b34e89b1a2221321d237251983773765af0625bba0a5820a3ffe73ea612f89747117c9981eb1425516d0c0a155cdd1d5471cda88333f6502ad1a112871724440faf3ea24656ba1dea22619f6fa1ba73069ac6f1aa8fca117079620b962a6aee53406e346678ea6f64e8a35196dd0a106887590dca034a1f797f029c660cb06a0c0d1b1cc2b0c186a7afa70e3b77bf20b9e38ce875a6acfcd57904220fc4ba02a7154c66e9acfd6bbf995728dfbd8b7b13c15f4d48a9238bb1bee1408f04ca681414d05cc357ea1d15314b4eebbed736d34459577a0834e8e4428b68c39145011a778af4ee997eae13b16991d14a1486b69359b392d1010f47b057dc2d40f7af35f817c20dfce5c251065fd51f2d0f4fe7ce6768eccfcb84e0c0944ffd0a7c959b31683984e560742f02dc88de26ca762834bc7a84aff951a537e3b256036d874282d1cbbd2a3fac1066b22e692bb8e544ce3d65f233cadb2083e56bf4dbaa8385177062bdc90cdbcdbbaf7efea97d71fc9a384234f46f3686ed98bf0a6ee12de44d1ea12d3d094109664fc0f89e1dc07ec9ff730e702d8ebfcf4d6b19c9eb9849d8a46d20fe113952e5f7b98721cdde3ad7f74867fabdb8ce29926d283d221f9e46d47fb16861746a38c03322f1005fd0d4c0297f4b3d90cea859f69f2317ff1e0e4900cf7d673e5dc33e9880b498e52029e983e1f1b90da704acd4db5969521ad05c8e91245983382dee33af4077b7724993d61d98388536fc990c9ef0dbc3f4c1efe0357445a443138d3019dbd0e234cdf43d7a6883a5e1c94d60949c0995f352629c63201f4f5631d27eea5b417033c5df07acc5ddf7b4d44c6f1bd3fe5ca7f411c8d215a7cc55a5c74127c080f15f1103e835729aff2bcfc02c3f458cd85931b7cf45614c1ac762278085c1779fe6e7c17e6c85bb98b45940e86dbee6fc17f2c79a26b34b47289a8951f0ddebacec66f4373589b203bab4a120c3c790d921da07933bec95f2326188089b1fa54c5f3d61a2e53c9d346552f0a5752cadae03a6dfc1af15cdc189cbd0bb219edce8ad2970f12bb67060d59e2314ecdf337074fc852357b7e4a314f38a5635bcc7a6cfe75ea5a26599bcc66678a4e3862e5e5bad834a36687bf170bbc813cbebc7469e1500483388a1e3fd8756f17b251ea277cde65b8aafd1f62328437a82d0fac5863f34590a4ec6c56678edb9702a56a1b5f65d1213e99ac7a40d8bd9112858d07ce57f65e092270d2b478f761d0a8052454d6d498b9bd650ef60be282b2846f98774683553f5cdf0f03dc3016c727ad288ca21ce2b22e13f40f468aec73c62d0ecd9587c135cf99b790874bcdf144495b6cdcd60d6d321e159898b37bb27e7cd5acc0435a43aab40b060eaad4e08029a89d2f14ae464d2d7152b6716a710553a12be1b8b9466c7d121ae4c401e20acceb19ffadcbef93f48156937ae27a217e4a0f5bce630f4f06b17e66f90deb509a1e1d6d1cc28ac24564780de40a1de1422bdd06a74a63c4c194342fe60402e715dabf420f4b9f644d210509aed5049595535844a86b7a6ca1c12af7caf6d10404c749466ca13dde86cb59a9fb958115058b14ec5fb71ad8d2e6658be6a78a703a2311216002568b5c3cb594e3b61056b6497496db995e227057ebae495f3a92cc74360499db56b644457d3d8795d49ad704a82e8364a3ecb1d3bc1e5acd8a86c71804ec650468037683100998cb7eb8ae6f954f68c65da7f8a2d6f61bb043d3ebe77554eb5570718935aa25e7e3d65c3e58bec28994743b125a86287fc4e94a1f6e159ab8419fdc02831a7b4f1b3a335e6a55e56fd29e62fb4615207acd3a27387bfdafe5a3ee5c71ed2952639f0dc04ab0320caadcc0d9408bc7b1f1248ed575125b28608660784beb29d407cf3e0e0de9358545b35534e307580699ed7314563bf75ddc152520a4c9b5e0ec43d7d1152db89b7d5252e0b430c6fdffea08021f4483fdd728169c43cd9dabc728a160bf728593efdcaa29cea43d6ecef5256dab41282ab02f698469613b4b5d156d98a39bbfea85652b439a07462a480df20a8a962cda9d3a9ab0014e56cfea4cc1c862e2e26246b0a61b8679b382fd723811b882b2b87ebfa5033af1dc487928310bd994ebff2ab9cf1a32a669a5e4273db519ade2691753115e8cb4213dcdd80833f799a047e66178fa507fb4c604b97dad9043b30f1f09c3d4b7fd5f893edba78355bf6492b4e31140cda39aff5c37820e21ff44fc72613ed44f2ed33712ca072ed739845cada816510be2ce457c39a9dce604c01c5bf76ec574e6d92c99359aefb81edb2d6100496f40b94b6a91b9b1bc5737ae776809a3698c453616a82a4c464536bf9a644f920d3e22499496777592752734bed2fea646cc5d1aa5c3088fcd8585e811b0c172cac6bcd0f618022e131a2c64ab828f8ee37fb45e805594961560faa2027c8fce551859bb4d76407611f8c71c1ff9ed4f9894f844fc381c47a4cf0d8bfc75b80709f8612fbea12f25c2dfd38002879026d65924d9c73b837927cc6c4c57e67a5292d7f627a9dc079912b7fb6c0834fa8f762f3a94ee07d9ebf7b55ff83778556a60719a157ec836ba0103fcc624ca48c2ce9413f912db9944962b7c39382011671507fffae6c1287baa4e6588300992dca85861f95d0beab84951762501c2ff2b56ba45d212cfb8febe191c860dd83327fd1959f8e2fd5a05bd7edf665aef4780f7bac32ad2c9188fdfae88332901a5edbdc83e1b2c337dc38bc67275573129ab1cf86c309cd618b0b4cdb494adbe4c6408aa574a52feda290e20b52782238ef0d1a5e2f7ad0121687d91c41c5671425f3a15c98784d65c84771cdf0c999f7a9ddaabff7595c24f043892f7ce92ac88475caa8ce985787f8557cb229c543cbd0599d9a089df08771eec4b8283c13aec43cdea319375b2efd6efa5956277da7f24131c2f822ce980e74c1036faa2c90dc3002591a8a9b4a1a393eb79853e3013002d169859c37722a69647d1a8f4a628dd7c8d1190ac558512e34aab13c70fa6dd034361d55efaa5da1820fc7d418f22fc76ff002fe486fe66cce5e46173767469760a2089bcbdfbbc98439a32ff008b15649e9ff41fc645f7c144771586b343808048565f0f5359babae5ce3dba6e2501a07a2f03f8667b5c131b80a851170d2b2f4696fd6c3e2cf81451167bc52bdca53e6362747235b9a1a231530ca35c331758e896e328bbe0dcf1f6d9ed9954b1962e240bcf00edc95ec68eedd7a8d7a71afbe543920745ec979905a871d7ec65586e85a6188d82dc89b0af59e7bd7e4fc080ce94c1b9e5b22bef9e52669e1cd653049b38661951d4c32769266e7821cd240ea2556840cf0fb68e448f6819608576ec136db55c7b904a1e0db5f3d2ab5ee21399aacafadbdbeca0f5137994060a220f69b6c1c0c4b5d0b48e0244a4211353a62dc7c19afd3b86e3b947d8bee79734f9b673918ccfe186f0cfff0501b284c05d87f9d7c5f289c7e91a3018471ca8cabe0cec1158aad6f0d65a49e9d93b2ae7a91b876e89856f8e18ac086dc4eaee48a4577ec7b16376871ab5fab4dc9480cadbcee1ad207c258496254f78084cafa913d56e9c2d989c5726bc04f6e532b3d48e79cf2fc91c64c8ea7e3ba4c1a9de6a5fa6603584519de59bd2ecf3c1c4df463c7d5241c9a54295062a987161d47d5089afa322a2f77d25a17e36ba208199e0eff6669a1c5b05e514c39fa118e4d2ca07d2747460895909ef28b4bbda18511286f729f5d6c1a4541ef20fb8832d59b38a6d5051fb7d1d2b5b7e44c1f877d8fc5d1d1c199d33a13187df8f48cc802cbf36c6b8e1550535253846228702396493927a1c453026e5f937a366bf598b8f5e74ed5a17015fc4018ff6e95ed6eb4aa9fd83e37841c9493999670f4c7a425556be60ed6f524f20445da497e482d22aa9844a3d7579db47d13b064384cac9ebfeaf2f9f627eb0273643aaff2c85dba9f43000d787c5cde429158710391f29fa344b1f09702c8d49e5ce1cd762830e6cab1ce257ba0a1e03b65a71c42f848ae95a8aaed3268dd71651eae4b9c0c342d905500798ba03ab743de7ef2fca7ccc6bb0130b6058d8bd59a0e4b3d43c10e0ca7484f4b8509ea32c5b69b0d0bc8875a21ac3b5a17009f6464c73b5554350ce2db6d6312d7abf2f01be7aaedbcc5022f52ca4fe5b4122450ea979b7386797f8e1c08c6de091586c3b853c0c0211e6e19a3db570ec6573e178426f8874bc69c7f9516472ee8efb20b00bfe4c2f6ad3d4a1ca61afe39e4354d6179f6ea0b93e372d6edc352dcd9c635a97d5d8ddfd6f4dd4194559f6e8d524d87f0a0c7fc22ba9984f5402fcb0debdb0a62c2c082c1157f7b3465aa250f39770fe42d69264eef0addd3c8aa63d2e76ef2351f8a9c59ff4632ca6f8cc728453cd886763e554cdd10845f23e85ecaa53c4e2a31fa84e467957da507a211be0128132d6f3b7c50f43fbd280a72b7e4c2b1832b6180e38dce7c4f8772ef9cfb8bad756bc47b81e69e75bf85baddef2fb46e9fdf22cde5e0a4b7daca02bc42f32cee764a9511f734752f16e7e04e2e7db794a0d4fd51ce32830b853113cfe8fbf06be63cd73fcfac6458847d380bb71bdb92beaaf9fb6dac004d46f8253ad8df680949cac6d270947c63fe0210ca7401830ce46ce9935a1f7889c6928c2f54b4f83912388cd98205b92061489c6449d88f5191adcf30c4fa1d7ff16be58ee0512ef36376aac29f633b8a128066b53b529c794750b7b5dfea2483817695dd8eebfa667e93dcb09392ade636df73f067fdeb00a2350a260926f32c19be08344b14ca1203371b46942614cd2a678f9d3fabb4d993a39296da18a31bdd730845be1f232878ca9e82cd5abd0612d9b1d266bbce7d4571dd6dc22804b97751d76abd0d0077f8f4710a469e44173289437cf51c46f91ee3e6c30210616bcd353bfa6d340288c50e16b1147e2245d9c374568268719abdc5b4fdc1c45797bf28c7fd278b3f1d2cb501cbb1b42954fe02067f32ba2c3a1708845f1c721513a3cda549b771f7f1d95703e5bb3e507fd8aab00385caa14d083c964412edf99fe86a168f03fc61fd2bc15453b12aba5c884a1fd9e94032fe445e62d1281141e07a3c3e747ce284e0fc5e1dc8dcd20844759a700960f34378809921e56cc28276b6eb3055714c4dc5a48fc35c14eb068563188bfb4fab4b7875eae0cd5f6392355598f55b6acccd6be9082f18279c2a01ca66fa0d854b521b846d4e52c8f0a0495d47b7332b1b456839751dc65812a63133e7213270080f4fe022ded52e6d09089083873b528897d16e4695b15710c7fd7e09a08ba65880f1d447ebdbc29997bec04beaf7db4d86c25959553bac8a71cfa7659154f0e9588bdea5a2943193dd2c989c4404daca090f8f153f885ca4f425a83d183c540781e0214fac8f97a93dccb4a48b04cbe31b3941c56f42b24c13039fa61fc93e00576b412854dc7b8387bd330436ce4defcf9df9aa217da43c3f56e66903ea059ad449a964a1a70aef88124b973a21c05d18da0aff5c6b826af406f79d131830bf74e31eeed7408205185a47f6dc41088ad1f794f68deaf8507d3524dadaef39ef0c6d5a6c90bc25b02c5a6031626fcc78b38360ec3511f7203b7fcef003985415009992547ad0042681ae123895d6ddcf8043b0380a473c7351954142ad1d73e641efefaae6da9f02614ae4022a81297dc9ac11422e45f69b133fcc3780c994579b361ead0160c59f969139a083bf41985ea0ee7f102d0ea739f8e419ccbc8ae037406c4167bd86314086af300ca4263a4be275189ee10df3af0718e362580159228ab7324846d383d6d6b8f2e9393241bd0142d34b9e947d7cb88c1708b323fc39493ed5d9c8caed55e6562b3af0a25beb585dcda117907270910717a9f8e0450bdd3bb99e0191aa326caa84ea87d3980be97f0ca8f7ddc9582bc2023171c2143ea5c2550d7840d95ca4d05d8e04482d2a34205467f200041ad52c15ecf934a5c912f3d7ecfaa35710d1337b61c17db9a0fb64fb796601593afb26325d7a49333763b5a0f4d546533fcd5277125cdef7735780a9d1ac06f17a9c1c5b781cfdaf0d9e20fd40dd234a0e225e37811d30af7426cc620abc640335aa2e0e2fcc79a1a9c5e0504a1242bc1af284e157ab49d15b5e3b3fd8d7c709d693ee846ba34a6c1416b63761f4eb832261a34f8bdcb1fd0c6df81ccc05368bb146b9230ffc9677a78a01cae2f9735d4211fb97ee5cb5d8285af129cd5ec83c8cfc3c96fed5b8bb42ad5a66428c67569fb5ac52196fe7dc79aa9722e323c4849431c2f301f4dd56a25c82c7cba31567b393206101ba69488e0d26cc327cdb35155bd17dad53d46cffed4dae0234c6a33bf67846076bbc2105b845b539bb41fb56de5c3cec4b406f72a97e363ffbef1b4e0340e0d7347b5583324cfbf2bf6293c24bceb53d7c42f3126851fdd7f912444c25dee09e0c790ae1652c6251e338417db684cb7fa56636774bae7b1db28aae139ff9cd28c4ed9521f9b49a3bb33e6d956cef2eecd54884841de721753b674345791a90aea835fc930c864e1352af755baa003c125b304eebf89fc1cd9aee59d117119624737dd8dd6f1df6f1a870c7387b8d060062902feb579b70f68c7b4deca293846641abf3cf28645f642d83eb020bcbbcea76439094b0fa643f8eb5ee0deca8d1ceb2657511476eb892f2ffc892be77fbeaff479b55afffa553ace73d3d3512fc18a98712b1f9383b137164bce653e009987daf1da25880a6cd42d27c98110313b4badb3506d8f416b0d982c9835248eefcebc9eba97b364fdaad1dc2b3dfb869d65d468a8a41a82ea4095ec47322eddc0dba0530ef6746cd87fd8c6ce432e64627d1a6c6151a9515b63580503f3b774389efb6e9057950e0ac898373356f471c4aa600ccb7132f48593827d69c2a4ce0f22a728fa665bba69560d96c94ecc3e88b0b2b9bd2c5d6aef28c4ad243faf093a10718de3c2b8306a9203236734d1c56f9ef61563b046a1427cd1be5570b7d814363564eaee69708d74d18c9ca51e67b50ed726a798e14ea560e4d4b1d496f865b274b3d830c8868535efb035cd5ee6a37a927f55b120a1c9f7051326ab7874f8dce1d51db74ef91d66357a543c7b712666b9558d10467065f0bd9d5e51ad38df06b20b4727416fb5d7ee5e66d4fd673b686353fbc9077562c8fc8ce4e6e55be3f177b214998f2cd52ef4029f47a54b0ce6606824211c1fc3b9c8547dd56bad2f85545e425de8fcd6a47d5da00d12ad83930b55db7c81f6fb26c2227b39eb99bbe6d323877feb547472bd2ccde793bc3fb01dab8ac56c1b9e1dfee8d3034c52ff4139c604307fbf0572b7de33b03914908fe58ee964b6215d82ce6d192346e615e0ed5fd596e7f6ef373d42db276c8c95166ad3b432f69230edca2cc5831cafc04799fb5f802b5f0691c0c7489d24112f6a942ceb9c1f5072d26c52f69dfca37729a19bee77397818f73b18f7e2c31a78f3a3dfdc82b97d118a15a37daf5c6a253849c14895de52a25167d9c9bc1f7ceb76bffd6d5c8c9e05d73a829afba26ff160bc49bc75943b4955042ed39d6792fa0f572d801e7166e56ba7eaeb7e85e87b2dd77d4e08cb004751a3c57b413c9034e35d2ca5ff5ea6040a05a902001d4ba7d64d860e3501e1fb6b9719c413e2578a8714d85e5befa3bc98e168cb8a34e0c90f434d2ab74ada2adff1f41ad694ec3aeecac5d14f895b8d8945799e6ff8049a06982c5b693b1b688635a5ddc8f556632b36d8563898b284358483bc59faaca33fca0da766b4eef369a5df520e6f6df81e06ce2b27ec5538c40db2504d79adcdeb330f32107e03aa2fcdec651064d09ab841bb77f261bf03a709473af0cc93a8eff392e8bc8dd4066e6dbbaa94aa39cd1110ee48cb3fa925a804be123c3e7c52bce600b49e64ce39404f5709abe881eef7ac0a282aeeb5ec1ff68bdf06e7cf2897341a725211b893837213bd2a1a11b9582f04f693d3285796d86f67e6cb526c4c3b96645e2c805ea67ec3edd97f8c7d8ff34c094d6e1746d9f274a65865f9dd0a7519b3fad53bee4c712151e17c58c82bc76abc817105a9a825130907301aec0485ec099a4f2241bf7f44891ca02a2aa8cb5e221ab98059c4fdcc42a3e12afa81b6b6dc20cbc78837469f574cb88e5584a11ddf4fdd5b724abecac00c0d482950ea1dc501a188757e35f6a2bdaf1609aaca20cb89e3057d4aedff928bbcf4a9d9833efde8f3d3418f0e038c73d83a65e99a1da794fa1f25bef567bad17d749428c2733f580b30bc42393b80c229218f8a1c7c517dbbafd3f8d1e5866dd5e3f0a6d2daa2618c1fc00f30cfc3cdf5692102826ae9f6be702ca910bd15efd2e8a14ba030498ddcca3e3758a31fa94f9848372f793623eeecdd375028765f578297fa7379d0124db13e1a0ba219ca76d27849a442c34df40886c8954913ddc3b06377612ed1cf94045a482febd4d0156355c1bcaf71f1024cbb5545821210c6ecfe08dd40afe89ac3f94c1c1ebb41d813d187544ec830e2439ed8f8939572bb2a45cee113b78e9cb5528c91eca31fc31d2b423931cbb685e98031c18671deaeb4cb4e413d8a5c5d2f950e2d8babe306a61f76bd36ab6bbe1d4daa8c3ec0fb84ffffa8fb2896224103e30cdecfd42dabe9d2c5a3fc4b1a7d16e6d2158e387ea1b3772fd9cc5889b8aa11f93b919d3c7afb6d4440ed61b3530a5e083781417f130536ca801c4380da8d26258469ce3a601427e4bc48cdf58b76f0a47f552ec0e9b0763a5327102841e15593f80760ef164e7054f503a717e44bc7cf59c01c54f7c4bfab7aa8f4ca2ec2c2c35a9c773a9bb3d26dc6feb082dbe672753b6dafdf7569eaea1f6260610cf9d4b9b6cab3d3ab0a1ad1c22e26062790e7368442e62aaa6ab9a98c629da2d4a8c40b1a2675a19abc938bab3f9096eabc98da84daf4ddb37c1bf2c4969e253bd1fea8b5208a11ada3143097630d302f8f22ef87333653ce7b9107cf23bbb13fdd07b08e03bf4ffe98567236fa1f70b9ee2696dd0ad491593c7ca577cda397de7191faaafac3ffea064678a15acb76178dcef908fc74cf9a715fe252f6da79914ccde10d19442164eeccd1e9699ea59eeaf5c46538a0f112381a081e24db90789c68b9af71189eac9dca2bc5635c5f95327c2fa9b16ee57979c4de1d67af28e324f6c8c4ff711aecea6e9b459bb5c3be458cfffc3922fd2037073bc12778811d0b9f30aad2340aa5f2075fdb62c0e309bec10d7d3a7f9038478509a8990d00b520ac9e48309b8ab052c6144cd030c45300e3fce4ca5daf835473e37c8353b9ce0eae2ac51281c308efacee626631ec4aa1b5777bce67ebd85944e59d846d3743909a950867508fca8986b96e3515017ac87d4f6d1bf51e2dd38735b3ccd6cf91b343b95644564445b2ae7826a075841eb652e1ec9b13c469d99645e748743117ed20299694fedd68c1e6c847dfffcce0569c71f4c9d8f8a2e94bc60be6483294b0a534029d00d6932b342b70b0a597fffaa53350c18baed01e01fe6c9e98ecf122a0034ff7a4f1139d64add24867b653081553bd7c33fab14e598f855f97","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
