<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17422c881466852c043854ea86e63af088b76939c53fb81a2d44995001a8fe0fe79371be6ad11ae17e14d1b318d0eb143111f3c17b5991fc20cd079e698338168fed0492c3f112ccba6ccac364772451562b5d4a0b90bdf2b9663e18e87febf239d14bc03c051da299790884e0503c193c90bf17de159547d58352799b6081510383efaf36c2d49f9e225210662b8bf8e6239d64e04783bab921ae893dd48154c9585d33a1fe68e36cbb70f0c56c9f514d71f7f7450ff1887c0b68b0352f6c8f6c0d7fd750a2fb1a6ffdf314c6f133f48ca7581372d3d812ae042f8241709bab6a7a808733798263124e2500669eebc0c1cded4c51a02d466a8ad6facfc638c5e49515f0bdba023010e96a70f7d2589731352bc28c2eaada6bc78fe14a29c2a998ebaa48e393805bea94fe8cf0a6da3df46e6e2ca97d7af4089afd809d82aa5451905372183fce4fabd1c09b6d49ed811e428b4d5df7bfab6430886d3dd2ef99a93bf5425f8e60b8940ecd78c5d95e6a9bd2d26989a0ad5dc0c3a6687c8f72d120506423e49a8931f0015ac6b588d6c40ef1622e043f3676b23ada93c96d7c44de76c3cc2d3fa7b4161232f2232ea6e66a0dd8d03f31f1b8be90b0fa6022fbc1c1d991a7d28e67466ac7f75a12c606c7c557212bc784c023842b9359650a3d771f2bd5f61c6d5247945c00cb383452e392b65ae7e1d156e8d92f2f1808b68269cd87523be995b517b39f35abd47744c6aee4bcd66370ddd63f0ce7a305acf9244c52067459e55525549d7fcee880827c8c2cbe4b83ec6eeede7e256feae37d8a7856651e6f266ffb5479f203cda6857de2c653479cf6919429540254e190de95efd2ef87c24dbca487526149813e299b0336032def31e63d36b588771de655abc1fdec02076ddf27fa99534c2c92f482ba594559ec206afe1904493aeec637c1a4d22237564dd96570e7a6fcb7597b77d490d231e414d89a18fc95d87f4faf6ce638b9f9f461fb32b47195b39d48870285d637e1065add1f3ca5583b1c82142e0fd61fb82ae4c430a4dce892bdcfdde8049f0bc6c835540b2f7ad10e8bcdbd51733ee29b1efb8e781565c9a6c3bd39ea1fed4c0a9e0fa7567244f515159924a90302a3c897b7ed6d45c899b383d0bcb684e95c360aa023b16858ef3f776715ff05d43a8613938476c876d323963b9dc29f585ed9065c2ffb1dc52f081ab2f38bdb0a7d2816cb264e580615690ee000d8599b2e722ca2d7ca457c41ec2f581d3ee7bb9096121b654c02d70512e744ab0eb2a747143aedd9d8f532d1ec5cf154754635d4ec01d1455c5ab8f1d09f1d1348af2cd6e6c1d22d81a7804971952e7ff3a44e51904b3318fb8c583bf0429f2efa2872f1eb853be63287beed6976e8f022e7ccbdae05e3d01ecd125d7254f15fcad960a7d19c0a889bbd704d2e62b59090067d25f13be5b728e0bf78f4b5dbd6da62a9541f410270d2b85444e8dcc1b141d3480ae8dc075e0ee4fa211dc8d4789befb4df1c96e669140f5a98297b73e4a6266655373b91d560c4162e82cacec96cfc1f5bb389b773d0d01af3588e99bcaa176e364d34a3efa2fcae0ce89cf5b3fdbef4df12d1368fe52e273e766c3ba902127738941d04b10fbb2a44bb07f1a7c9fcda81bd4f35b991fb5166cfc7df620e92fc726218de234ab77261c1c599c0afc642f17587ab8f556db2b4e616034b28c81cf80e8a7d4e59e191de813ffef60faf35633550f577b085091bbc5f677dadba99a765bc43ee59d7edfd6e02113b6e3441973b7bed3ce41089b9f763a30a3a81f82489418ee93c3f55d82ebaf67f1cec9ea2c3f6ec3b8cb412d350fae189b9d784cbf7134303ebf3a58217a2219c5367daaa22532df48d4a701a6b159946db2f82dddc2e243bb32ce86181c31a3c8462c695332de5c51a26beb9a69b19de13529377bf0c7a0b293c63f7dc1f7160cb8d0127db631423df085a4234cd9a41e183999c8c76ea3c6a011bfedffac9cf63f702e772c82527465ea5b01293e79d15794cc1e7c8b18940150cc1f09e377039155bd6917c4a4e84a7269a3a53c1e01f741d3913187bf0360d1f40e19f8f34fe0d12009cbdaa9494379575b80a4c5e29bac57a95b8bf2052ce1c5e3d5305bf1d86bd0e0ab5c4aa963939a4b1043b48ff6176fd93c6a6a3db55f545f12cfa1f58ca80ddf32509ab89304f05a089f73df0275e5a327475e5600bcbce96839b90b3e09483de9799c741c3e8fba9636779936c5d2ceb9d4604773b4f0a0638d16a0fb71ab84ec50b2286e3e7b215065e01a89201e292a4392808cb001baa32554c9a4e47b0ec90ec63834b5c2b0d03588e75022a73e3476884b30168153a3e84332b62b672969e631a6a622614dbb3af3dc3706baaa08521adda3a11b452233ecdcba66fe17d97c605c7be5c1d073399a48d482f1343a484ef5856cb42b56a83d1c05708721e1123c0f3b7d2f49df4debfb5ee93a37192023d06133f8d27a247c7c4eac8706d9546344e4bb697f7e04e9f3face87fd80d913e0ea606fa03f4b3ac2656dc66e4cfbdaf418ea7a9fd36795a4860618e91f5470932dbdea256abe5892c21c7be4fb91e62eb3468e86e8d9d41cf2cb88bd7f36d3991933cb7c09b03c5e15f0546578c064ea979410493eb52435e09086c41ccedc45ccc9dff6045e8779f6e67d5c424468ae4ec9ce37968601a69bd9b95374e3798ce4e0ca7e6f813eac5d53785836c2b6dd4cd871b1a439bfae007f9c4140aa4defb4e51cdb043d7ddba902097bfa0d2e3bbb2cbd9bbacf7b75bcdf7d10b3abd492f3ed2ac4562efc56b2f0dc032486b54539f5a76c219ffad48726e289eff756aada999c402b70d7fb92d58c88b1a3302b2fb08b8ced2149a42525231e563baf83061fd07fda5db1ec16508faafae1efb265804cb80d1e0070b8a28d99123a11adff611822e1456cf74456962c59d1da8bab6e06e0c7da7243908dea264af6d313f463962173b9aa21678e43700d7940c03fcba4dda27c2abfeeb115f7fc02211c19d8b4c387b87300d7001e83295c1e5b9eecd1a06c764616c6a0dba0ab387fab4a3c0c7ae2236b289659c8cea7e1299c4779da9a0b54c84fc8d8fd8c5776b7cef7b93d856255319f096a461f02c9ac81b5f11f1b5a1f92d9b9eb95666ef4c91c7ace6359629fe35cec4ceda432ab1994cf7f9bdee12dbe7a17b09e57d7d992ad6d0de1d21623811f2b2d7f4b5b5f1f7e1da2a262495e2a6241839633823046c174ce32eb29086f8723a0edd3d3700fc0e0786ad9dc87f1cf4ccd6ac9e48ec872a9558ef0c1d11bea147a294574a33646d1e0a46df2f437a9bebcc76cab98a2a566cc7bc24cc52aa33c8dd17301c5a2f08ce86369866586ac99d7d528b9dca9d66201fca93f1294aad4af88481c4c0f8a45bf2fc0d42670b5736e5f4b61a934f6d925d6a9bd4b62bb4f7242717410f41707499675676cd70f535c693ae341fec7adc169967a1e4414906460b142e0b05d9c661030382ea105188f57b36541ba2b0082ca752398aba7d1f94bedd9049012a4135056f6152c9809061c08b7796af959bae9a94ff7870bd7447dddb1ba6a6ba0627698ce9151032d5a66ca0ffdbd85411cf3fc6eb7a1f359c97baa30b319ee80799583afeb74af518d5aa5c5ab4955e3122ba21437fae4def9f726ff935e851eae8a30f5e4dee925d7918432588d3e5cb046d37ec80e56121b519a93874d1eee0ac697d58ebaa18d519fbedc2f0c7e9f7648e5f8a1c51001c10b46f46ead05060a6bcae7b0cfaa59418e223431159c01830f2d3aa0c785156f645e3ff35845f585d68a153c9025e48b713a1b4a94823766a283ff62d24d645bb49e2c70ed7333a880a3ad57122e05e75245f9f3b012bc4df5f10f63d3835a8799228a9efe235c8c9fea62f01ff14576dcc8260054940f2b9775482eecca6d7a772d928a709e3301d5521422c5fb21d594f08eebb54013e0abdf28cad80f1d7faccf3e2002b4a8673d296f768ec897ed191d56b211f745804e63f12642f3349361d71425934df03e5b9d2a505c01a5f8e575f8aea89e23d90b174704e45c42f2b1cfb7877562a1fde8d736c3eed640739013fd98f62b0710b52b31012bbbd5dcd53651e8497efba4844a9a7971c6a67e8bf8cfc19a449d0fa6580bd0cd1ecc30f0bac6453f8c71862d6c162416528ef78c0fea3f7941efb6bbdea780369d3e2c884b610f31164e0af9ac04728efeacc4a1685f5b649f521d554d5e645b21469fd5f9daac6ce90494f3fac5313b3026fb00d321e7327325d7a316393e2b9ca44772a9d6731037cb285e8a40ac3a51cccff68084a05a145e6bce41c38af04784ddb71076b35a1cb2406dcc1fedbe573ecae2649a1a9f4bc34f21d53fa49ba545f1692b36794972b5014c1b5a9a953f8981e19b8c639b7e397aa353e413c1a248bcb6abacb62add5cc6efcf00df0fd0c03aad7784cf7c3758ce36d6f4f1519c9fbcf1aeacc4d61465bfc5c54e8a43238c77509c5f40559a30a53af007e4815fa9a3f2ea98dfddfbdd74a465b25f7d1f595cf24e664129a7bfdd07639b2c88a8ea39202f2410a7935b700f1b8e7f5b0ceada913d532f6051608ccd563e15a233c6539358e6a5bd3b78e46eb49f4976d3f89dc6beefb9557220194b300035e582f5a79b5672ba0b8a1ccff84b890aa8d71aa4ade6a9488dd28d88a16befc387c7f22ad691eb98f9ad07e9fb3de794562b06d23e94785e71116bdd2fbe86204cb82606378b2cf8ee9a6c3801b7800519bb217545f0d33b420bda5a40a0db90161a0e66d325792540ea7964d45406e287acb3fba2dc3f9c8980f194c50a37bf3f423de89982b29c1bda2b97f3256c3d97e02276fd1c7e18bd10536a60ede39ef75f0077fc0326e28292f8e36f99007f4b015834599b9a664b94a3d3c4eb26e5e1302ddb3ac66eccdac736f7cb30f914a63bc714b9076bf0dcd124367bbd58a22faa554105c166220f7599041de64cd607a1296f37c58338932339afab8252da5ad2a25da5e289a57cde5f9e729ae599ed8b9f62638939cbf093ca7e2c82fb2f1437726a9f58370b913e0b8c2e15b90d8fca1227fb51af93cdbfd554e9c91e959118b2d1ba97e157133c28ca02d89d7ee09fc47b5c0113c543b35583914b275d9fba5f7e96a860a940b954b2db372f5fa73efcf40290c452ee57257199fc00e76eac25599475f3cd86e1a5631163ef2fa80cb29ac644c726851aba1bf9b1cca726692d460c68abd6a5201f7f9c97c068f907fe2b1ef77635a0fb48a7bf898d60c0d3cd106c7087fcab95802e6b4f3236ce43033480dc1be107636ce182ff85eda3fdf105245260302d493127baa961468c9deb41b02e1532f0a03bcd75dae05faa7e9ca3754f3dd336beee1e274f8807ca42f18b879d37603110b52f61451a68a96b5b6bf92647b7111790fec8d3d71ad4c752ba91845286d0015e8187c0f2cc7739b88a110e3b2cbd1466dda2df63a68b64f2089a2cf67abff2ec1e48da645005c4ecf1c9dfd6f6a0a306aa45ac0c92a0f424837316fcaa74e9c969c026c69b96c2e1565af1ea79613db38de52af9bbe8edb0d1a773b809ed8aa11bd6668d8fb389a9dbea12f3ebbc45d6dd1bcab15286e3e9b2708d647329bec35bf8f7749e93b08403f6b8392ed6e27f07e66160ba27a6d5f1b8c321b80043bb1dd2753dcf3d38261823fc807eca2c0e8f85dedcbacd8f9594f114862c6df0b23309dd3eefdee859085b8b33f8939664179f575502feaeb3a98ba661ea76b016feef8054500fafe0261bed7567343103417282e62cb3e996d717ec66a599587fa2922bd70854637973a69a4316b4bd89acb3aac1286c5d30ae4c9d5a9e641e84af217775942e509c42accc39fcc75c4a2a9292f8da1fd8ed33c54499e14798468bc8f587bc965de01d110e9628fa04dcdb464d2c3dd3f0a727f1098d2d4683cb863a6ae3dffd2bdf6c9f156bc610e2788d975023830e73720ec8a82909bdb09aa148ced5590472ed9685d06e56f986b429e99f86b954748037cf4401518248f0100684e7ef0ca47ada3996173aa49ab5ac7e3c743a1128c4497658d5ede4ae9f1e21797b71d41a6e554ee5ebe5e7fc6a33a35ccf8464a53acee095c7beb208cee161db253b176efb7244472b9806aa56b27306622db127b7d0e1149f860d8984e7ff52f8eeae203bd1f3b0baae2db20c63fc694807ee0ef06627bf51b6bb6b12b4c00ee546768e1ee58c432b56469d61423dc55c83c0c5f6ceba91dc9819d6b603190c6923d1354897d9e90fd0f4be68729f5aabb130fea2a326916ae87a8641436df0c914cbf3965d37d37cf9313400dedcd54c57925fffbab2b97373edff63c4b6a5c7735e0bf84095038052ccb1b4a574b240324cdd94d827f05574613b6543ca6a1e70c22dc50fccb6064fbb31169da9f1dc826186c667ba5e9f9096f0554dd25a5a9491d0a8a7ff8cc5113502c0efc2777113c2730774b02b22162efecedee4fff91a49fbc9e945bb9d531e7c79b32900ee65c849b66650c952dd361a8602a39695f19e3786d10e2d03e5d72e6dc6ec8d651d299636326c10788f36a6bcac3dde7156b032f3415f7b4a0cc3d8af21e3314351a1bc71d021a4f4d3ebd309841b1785f1fab99c6373ec5bfac4d986050698953aaf381b28d7969503e12490ad36f50753a5c3d487b6fd3423b31a21d930f0e7e590db5f6d602ae629339e608767270840a0d314d805937b3430050b90f0c9cad6ccdd3189c82639d3dee43773846d44c54add73b92ef13ca9ee47a02f434be426bd40d85635dd62081051bf8c3cedef6518be982a4381c4275462595a2d5e48ec529cdb2bb73efa259b44182daad0f49f1e543176845dc9d74d80108ae5bf114b01786d669ba9b9c5edbb19948b7cbbb92e4a1e50380818eb75a279ae037d6b30190c23618feb5af1451d850510481923854d14b0830599f4aeb0d462333267b876d06c861858c639661edb1eeebc4372e471d3f740f663fe413d575b1306e195f4794e7dbc8aee5ac9301cba296884fc91ae0e1eecb94977055833a962c624c92eadf8fd70f6d913ae5ff1830562b2fdf8c21447a598e2820725292bb243156768e5aba175619325b42271c9c25b73b420c9eedf11b7ca31319f474d2d34656dc46dd0859a78e7fa18eec30976d15d0dec3666fcc18bf86aa9efe153de2350242faa719136544cda2046438190d20763e0202e13765f073f4c2b18a35b52d8812f7e3cfe9f82bf1ff0c5128fc5fb380df7a5cda6f5986f995d28945cb3a84334ef5ed6fda4ed1ca9ec1102d6ee037c3ab950c46f258b11b74dd0770cd754425f3589f3baeb07296b776a81d0fe9dfaaf75c69da84709c0ac47764ecc1dee7e0946bc45abd8d6aaff1993d7d077fd168676a9428aa913ef253c8ba6f3727fb8bfe7975afc6ac04a780948547ef0e9bfffce0ec56b31a85af7ee8cc6389f55b8512aba715bfeffe5989ac544899ec4cbf19a9a7350b8b03b34b92d969f83c521a7b402b11e900cbd1062995b25baa221ef5c01e869cc2cf495f7b8385028346c6aced4979c69dcd0eb2812c98cf0df3cbebc7c344ca1b07e5acf80f7a934ec4c3b7d504358256480977c212ebfb66d0c2049dbbf80669da05e60a161fa06a7d01d297de78639fd5dd22a4f3a0ea31749b47f2821e6e110a5a6fe808332d0dc30532f4954ecf955650fe8ae553830b6fb70ca301c11604a8c7adbfec0e90a3413e50405b23da473acb3c003abff8313325c435874074c2a26202517280b21b31ef0ce2860eaaa8d1622edcef694f149f38b0a8a2a1b618145299aa731a56b64237a89365df63cb5d63ddaf976fa1c3f7d48fc1abdf58f2c0946f83280eb1bbce503d591af60b98ddbf79b34df5bbcd448117f908d67e54efe0740c778bb59a194f7dabaabb0aeee51da8b937946970cd8e9d755674b4c81063c384247ae2d5f8e42a37059771798b873a1108e8d51aebf1a55ee3076bbacadd69f10ab491407fe4710635e6088613023b63cd8f86883af39ce8a6c5c64a489a2b646cab107b95e8fe68fde196e9eb57807e17b93db5b63f44315f21596ce4cfa390c8811b6eafe86bba0f8a636055f7e260cb9feb652ab4afc4a80a1250b80b06bbf175d77a7a8c8218c627b27a27f23e860e02f60d12cd2a50569ba297b440ec4f2467df5e04339bcbb20a56b6777d9bb3c5a90830fbfb9f3864eb9eded64fda817b68e2452ac8ec56a7fa2f0974d7bcacaead6ca2cb675f96f8349d842fd75c01431970e74afb2b2df3eda230c6ae98035f4196efe453d97dabde5c494b24501adeb227fb56261987f0a6e08ed56dcdad826bfde550bd64c4b329eabfb1b5eccc9f711482dba5000235835a9b2a6ba631fdfa13733a7cacd25220bdb994d2cb838db077b3c59f5cd89e9ba70ffe3d8b0d1c152ff1b89885246ddfb65c671ae4b9eebbeed52920964df2304b66872b1a46efc971e64f40b032629dd8a208adf361fe629e5800bdd9f75b784fb9859576214d283fb50d3bfb08aaa7f8d3614baa3025164375fa828126c5ef9e8b9afb731c249ba159ea1bc841ceb5333baf84852f1514b9fdc1f410b8808597a1a1f653d434f64d4cd8000ed0e0eee094133add0d74bd4b7155bd06befb359ff3b757374ccab35e41ac4c8063a77eae08ee582e1d9d399292c0183cbf51663c2d8e5b94d0c7dcd89014e0ec0fda11b4a5e79774795563268c9c820f997b0ce47aa55cce71efae97d32ebd59f52b518dfacfb5eca1cb4e62ab0c1b067f530633351674b262edc158eb1065899d67429b054eb057cfcc2e3c21ce67a76ff0a43bf2e569243e628500eec3011fcd4bf3bd4459f4019a748bd70bb5fc59eb9fd3df8880a696154309c2480bb05ea75ca3b7da3fe70836df3ac17a5f353f0cd24e996b6595e9cdafc2fd9cb5b3de35209e25a37021a895ae18651b0c06886c941614608a2a56088c01ca342d88d82e424b5131c9eb5a0792af39ddb16b9a98c8dac8b729000212d2803dae44512b6baf1f5554069fa4bce169bf2bf924cb06869bc17c56967a1f6c36a0e07b9386b49827e488b24f489963fdf84597a866fca1f29791568539719d72bb385b38097b9a8e2296939a8951bd09c273ff1a869272293cce5171fca8f8eb40a70395c70791516562a06a76cb707f0a3e055a97919e66b2eaf123d450a042b344a9fdf48f4e73b7ad4fe7f46e7de8c51f8e0cbb675cbd2672e987e1ff84f6f4c2bfbdc1d277fd5e01c9cfb7909f6567ca1d5b867fce2e0727047db8bca75d3cec4086f47ac1c0f94f275d6cbc13f01dc725b067387b57dd0f86415936ef508c5fb30529e3f1c8af925cf477b6683134c5a848181bd45f6d01c489469273e64ef9832edbfd7d53ef4d6e8cfb7b27b05d6d3d124c7d5ed414a900804bca3934e606d99d2bf8d704c0a46359a6f1f21bb54c32cf4137037382a535a7f32a13516f7f5833993b80da102b807eafe388f98061e035417d0f93290a471256fa835bb6c3e3dbe2342ce797db1a0a698f9a51f0e133abb9dd59364010ddcdc45a18def23e974040f4f14c0721b357280022d7d0a8f1c768f5f6e7b127eae1f05b92ef4a2dbbf25c84a84382700f6646cdaee32c7ef95879438239787aaeded72f44b6b23951a42b6dcd44da8a32bf913b623b426bdf162045ea6bf4f5185079af30b820afa7fa635cb0c8c92ca755b381f0452fe62d9c837bdeedf3be6ec47832c6458fb6fee6e0c4a505608b8dfd7499c59e7f2aba7604ec9cf96768275ef143a33b41e20c50a4f2879b4c5f917bba4603b8963d3ae05fb5ebaf68d4ddac121fccc64470593171b29e698c1c8056cc5aaf4abe808baf1011ec6018d1a36e98ee32b57f0f2ac308ce2158d66d7693a0b6142b96ee10eb2b99479c891fea08b38f18a228a41415099002a5ac42b9c93acb03fe65941b4ab2b6b06f8696aba075813eacba575741f1b1dcbc87e426925fbaa707a076be327d721cb2587ec0670429fdaf62fce333cc5fdd4eff00c4b74cccd692ed870ab854c7a1fd2e6b0da4bf5cb042e0a6fc8a3962f922ff91440a812fc046493711e96a0112eead4ae9cbd102f429728532b0bf21a4e58e332732c88d8ec0bab0286c117586ffa1132b4c07b29decae70a05e492bb52141763059e8915281e8f81141d865bfde4a6cd28af31fca44445dec3d102fb86f54e58204eefcf167bc0cdbf1dc451a6554a221765c0af64a7c9971d6e199e8f4278ec0638f7317b970407b165b70936325a3f8f7496291b6efaaacdbc28fff3937194cc510c2375cf77f10d216a3df7d7fcd0d6c6f9133c19c812c921beba7ea74c99c0d06db936587a86d922805aef0c9102a56609d7600c03670e94f41db4762a01b078b0fdd6252555ebda3ffa22c2b14610c6fa21a82b7d88bcf57fec2664ec7aecc9148f27db826ab388a75d186948b2dd30d84853e998f97d884f99b546f63c5cf0c3c0488b7b01b1ad758cd126d1a3a9bd9a9d351b40cc42fa5bddcf22cb5194b714c101158778cea425b6205b1df17973eff550d05cb95fb648df8eee2c002b732a1df39f818a275d8115fe50e66a374a2d6f2dfb8e3a1dd93e1ded3d1686db7c7b1cce50540791bd216442f88b2e3e831f83587948c904d4d626b8aff6b05e4805aa853f7f02621239c68762a3ae2bfc5837709c16306f45967864e25e46d9c0d178f61c0e0e359690d35a4fa2645f52050e1d845bae996765fef725d4bc09c25cfb35950ff4fa024b49ab8fee66722c1664da6c48fbf7542a5595f8dff9c0e61f2068e1bdb01986b86f207d4e51eb8592562ee304575a1d8798db1a089c51af50c200892d990b492628f62c533ea89bf8cdb6b09ab346efaa20de0a3333f7f0c1d7b61eb189375ab81f40c14d02f3148e75db44f2a430055be73ffdcb04ed246867ad4c252df5c21ad88312e5703aa5cbfef908445041e673ec8b8b60063cd90016bf6a357f7f7f88e7b6efae297e4aef0519780c5c7fc475235c6cb9c11af7770de66e6e434144f8e970cb330f89067fe482456fb6fa0cbb5628a24cc1b2b2c5133b899671607c193a19b4aa67e253e11abfce409345e149d45ba99beec751c4402063b66db9e2043c0cc17082c67501f2ee81b7d3e8f8e9239e8bbddea6353ad7486df46c8a86df8bfbdc3f902215db49503128c3ae25f1d05975d7757de42f0e0d26979b55632e6943a91bdefba59b1acc5bbd4e242d22c7ae005406dd40d537c2755570f02fdebac81c8c6157380af67c39723fabf82a46fe91d42207ac41becc2f5ce92a24ca7d2d652b1feebe27ae54d50e59c8922355efceb9e9a0e162059485a1ce6a8cc52a9438b4c193ffe812dbc473cbca55858c7c7cdf88bbff9f1589ccb59025e4b59b9965a43e9232c49c6e1ea9ad9cf3b84248e333f8d6df72c0103eae101e686ca1e8a7103daef4b8d7ae0a3485c39b157cdc25d541bf64a6b483e2917328516a4de519fa7bd8aa9f3286eabb886f232919fa25b7cd346a6d965e26956ef6133c30ab7aa27c552e3386db2bfd64ecba83bbb0245ede80d0d363017654febba3ed7cf93ccfff09ab94afd46d9ad3441403441753dc048686331beb286e51b7652e3fc057d01f4266fda63f38002722af09a9b39b6acaefd35f560d9bcf727faabb2ff0cf2ae75de6bc78a40497ca118ff9edab052ef36630102be01f39d81c697dbd7da377b3de4061417b8096843c403a198b0d5550155fca599774730e03c06fffe4ad7fabc6d7f2feee6debf98feb82946f56020576b7f561f4e8e95cfdfa1c56c46f8604c725f3c04f504211cbcb920f139cf0da215ef7cb2d8015199c5e6842e85f6142e1d1f8aa7c0b49a1a4286f819d770746295299f701b7659e30a658c9199c975d0c2f3e8c3055db8cf52f51c3c9e4cbe813a11438b9d16eb8d88744f184ac13ff0f05536485d10604f2a5def9a844f1a7200fb4646655d9cf2a7e2c888b4d9bcf7b1bdfc5ed540dfcd74e5d8e06813b84f4ebad91d11579298dd06d25b15fa7323687fff8df5c3733e9ca7cc5df73793d5c11a3dd02b3b4fa89edbc7542b3f82d5693a4e56d2efe0aa87088ade47b1f0b113990a8f2794788514f7ade0a7ef592007a243450f5fce3de97df37f0d6f97b957c7ccc9c070de5aa4b418430cb956267d1a1b7b63e4692acc68d01a527f80a3f6352776a4c9b4c46d1fd3c08ffdeb55e8a982dd919a4066b3b0ad9892eb316be45ce1567f7a7e18042a0bc24932889a0a6e977b6b85158c1ed1774b239e38c3083b94c4313d67e2d6a9bcb16d80cf2ff4300b97f8ea75cdd404d894c5ff0b8e61a4166c6ff57b00e7bb2bd00fc794f47484e93da593f56dedc0a4490c3d769f3b86415f792f1977f794420e3b8c06e3d6a316852a83dc000c4e926bfac9340eda38420863a93e67b24b1f1d9b2cecceb70dd5cf34a87e3fff75606b04d42dd0ca7e97f4443295b140a5bd147b7924e7e08d1cf7cf2d5444f0dede573a8d0ee4fd09691b59ca34bdd953da5b8f9a0781a968acd3f2c086431390913ccd87245cd287f8d90c05a6b80a2f7820aa265d6c30cea58354f6212b37f6ff615a633d40fad04e4b1d800f6eda3aa0177999dd44fc902aa4504b387717cf52b5c689b4524d393d124f1ca48a50c450cce3e4ab7da5a2be52a5d81e2394a608ec4049a2af7eaf53cefe72928e37db255a7ef3600c2618ba2a4f7f5a42e8a1bd4b2213890bda7a6c7b8f9b20f3b0b3498ac272106df45b4eb8332e064f719d7e0db64b02e29afbfda2c144510059c5fc6a6fe1b6c4316c95c25bb42ba81d3be8244dec7512e689119d9880790b74759c8396ffe6f6b4b93954a576091a107b5f7e8f4a6660937e3e6ba97fd9c96c1824d5e497536e10d081934625e3748308a404cb6fe4eefe01440ff252b26fb5e3acfbf3fabaed9f3d4a725a78093528de637419a7e3e1f50757fc8a3066a5e410fcac15eb9a9f5b77c6af8450eb7dbf79a35ca274d2fa2d6d11cb9b921f8206213090810e693b838ba33f0be6377e56eb754c6150948a78142710791994ffc9925c9afe4f3351acb5068961a9b2b818bb0bea8159fed245ea8025f7f7a00b581b492b6d84f73b1adf816dab1bc637adab69070cd552fde475fc0da7f6c8dd53ebb20cb256c9531c4e51e6ce0eb502eba17632489919a75070c9db7d3284e35d0653bfc9d4c414edeca20eb6cbdd195fc964646a71b7d34f83e24926ad17bb77668c4a151107f5059c22b194dbe4476b1992d7fcbcd20c4cb000e0d9e4cd42b4195c28520c20b789ec1c3af6c5e8649aa69ceccbf94d618cb0674a721f9d4755c63a45327338da063adbca87c298ecfa1ddaf96e58b3e7046acb6301ffb577957473d6cfd0506f2734d01f31832ebf0fd365a95bf58d4515962593f866130c073a2359017c765ae37e9fdb043569de84c8ddb32a79c9ee04c226154edd50c50b6faccbc372745b49576ee41ad3da99375ad7b4d012ff9729dc7e117c0c6cf39baa1b59b3ce888cce768b0d6b74ec064eb01b2b7d39ef12de6bb8406d15889e02485cd2907feeff7014b325239de6a7ddd9ded553a0cb420a2467c39f17368f67a49fbbdaf8b057e528ba0c61192836779e017f659a530a56b7508fd0f07569b842841041c9220ba09dbfd60b5b2ae1afc769fb64b704644ec2446f70e27b2eda16ddcea0fac55e2b2f09a31ad386cb8fe722c32872d15dcc9cbd510e60be669456e09f590fbe66dd85e441e04d69d96710a0ad04be7f7f024f0934e86c218390132e6e6094f0800625e736090ffeec1fff92e48fc93437e81f4b7ea9f14f0c5b8a366f197e21579dbbbac2f4f64be21c74817c74cd7ac6e9298fbd62363a39133ffb81663dba9f4c4d91ec6cf9c7f1fe41a771cce5acfdc3e382866aafcdc7e3a03955020aaa25f975876713842946fc446d8168fc6ecd98c14dff4956238cd98109ee42d59826859162bb196912a54a2f79290e8663dc93cf67e0917bb1e9d5504365fbe56c1814fe6aff65a9fd3d35d3eff0156d2a0ce63cd09ec3753acd1f78043a14dd644840b7e96a54ac1588cb4de560a8b6c465715884e063a8dafec6d03ddca2e06c540ba439a7029896de9952001fc1dd3b05701c2e1efcca37e5bcdabf31d896527f9089e7a0cf7053444474c2da89624bb258f2f52c9a7573f1756b01cfcded47b29ef84a64892a38c88f421b6ca785db669aa082bd9cf208856825bab5803566516b1d6046d745681fff9756007699bbb1504ca6f03437d6447736fa3e510756fe72dba83f4e0a3c00ca2f9c481704712308140f59408361b97776d135874f72cdf13bb1f5ca2249646eb49523aa74afe61f29123a428f84961290fa6f12637407f175ab58f3236acf3f70aedffb31efd6b9c16ccaa0e555c35dcaf4d72914751a13e3371e94a5371d72e97a9eac32825e284446d37205dae7644725a09726a946d64e943a652bb5b6ae90de9875f39ce46a79b6353ac5fbcf28d4b16cc0ce99b3f386c0255ccf06b29dba9c412b4da031a4ad7d39d2ae5ca9d05f7b35646eccebd0dcbebc7d57e975782e2bf5095da0412749d1cb5bdfb7fb14b69fcb268bbf3c62d45a82f2cd6658818f0e3acc3731ade7b5e06c0bac73b60f9d6010b776849bf38944c4eec6dd5badd5e29d42764d1ca9b457f809403ad94649bf49f745e42739dde3201437bcb1e9b05e808101f045563be0512e28a09e42dbd18d15b030fa21a1e6c87000e0ff5348d34e470fbc32234734badffd37e43be7e5b5549e7ae326f5c98c2bfde9c30237a22d4cc7a717068baf4ce4e9b48c057faefebc61c3d7315ed2396e7e46ce83e0c6dfaddaaeb659196f6912736fb5882889e76610880794b9c8875666893a99f6b13f7ae27ab4a8ee8b90b551fd06560af8e7fa4f59904c105bd14e8d4b9acd7bb8de25e3fc1dbc7ca01b132cb9f183d8b1833f6ec37964c8e9471092855a9206fb6a2cf000d5d5c5e7d16934b7431432422e8ed2395519f407c259c6b608e72b6b04adf8e099c3fbde3bcdb0fd2a158455dcce169b7f10803f55301ee443b2888d5f9156dfceae0b3aa827692571ac9f5ff430b45c15e6dc2f0165f6616e2a93025e650f687fb23b3b8ad3ffa57b57de5474451e9d1d25b6e275cb4c991be9ad5e9614c97afd40622534129944cbf94b03e75c05af4c52e2af616c4f1aebb0bffaa0da42ff361b7dd2d7c87f3b3f1b4aabbf3bcb9c86b0ed878d587c6a899f5eb89178319b8d7cadf7436a75342ab67f2de7d3b4bf898efbe76c2e65ee626ac23375d3c915bb4b64f0a34ab20a8848fd67ee250fa00f16e239553a3b67c65fda3276d9a0ab3f79a8feae595d306e84e2edb55c0ccd2960bc2d74809b7c30b7f8d85cd29f467a710f17db312af7128ab3f1a4124cae0425c790094db5e59f7bf7ae787e9c3cca363ca8266e682225a24e41a4cc88bc73569e21bebc6b528786f7e104f8cc1e7ead259bba3ce11f285cc51c25780c1a959fc18653c0891b100872911442a8a6f4ce23cd7dea0c427a484c6cc56372e84bad7a7e6dd047a95ff43f4427d33822dc9c7b950ea71f628deb5cf8c4ea8ae3aa4ab63dd84b376a552d382b28501f1176d8f3ad650c02b5ff150d4a2ccdecbb5ff525fd394c752f9eb10afbc50a85fe8c81e90a9505310d87a1f8071915fb1d6e3b58e1be3e0b30a390b370e96e885cda06bc4b93220ff93b5fd80a6bdc92ed8ce152d1a69df0a52276408ef8ea7ec162ee4534714faeae6a258d43e61dec95f8b24822315f92eae939f77eb90cbbb4f400f1e07775d98b055939fa3d475a2fa4c21656b45a96c12165d395d8eb07ffac1d2f7d12e3ed92d6683f70ff605331caf1c9f88bbafec8d7cdc8de0c25dc8dc899613221f9f02440c7af6b8564da9bfeed86acb466787923c2fc3f01a13a55c68413aba563100d9275d7d19d8ed6d5c0cd436ee69828656fd198379dbecfea6a8d2cd27fcc3d9a3716084e08ade8cd351dfe2ab80f83aae108b59736157c2e4ca3683285e70d31bece4130eb83a4cbc794c9f41043b9533d3b0af5dfbce4e6000433a49c4013afe85695be0dd1eed4b7b0f91ce941213146ca8588180056744077fd634a4bd781d00bad0b8a40d9f728720894fbdb166c2879ad0a624a0c0eceffe0f7ec363d499db27aa8b2d8b1988c1c62796d9f5e454c4fd355cfd20b287370f1b7fd3f4cc51889e00147fda46c5330dfe2c9e14dcbcbb9b293ea442bc2f31425a0f26e3eefd4b0e19bc95c28ee8207d3fc487bb534c9131222baa23ac14ac25312d41554639ff592465eb957438e115d550cb43f27e5f56d137d9e7fb7fbde8c518bdd450a546bc5d955ea8d48bd3f86c3def2eee02ecf608ea87451e68ec27d5f4a35f649c93f3b0623af6677e1ba668fcb39a3d2b071e84866c03ac8095a85b7f969433b1a5f80d4775d6cd5136880eafdcfc3479beef59e66abbd2f3c6ca7bc3b680543b65bca7e68b60cc27d09db8fbd3de9e9d0068984da5ad1c381e6e71ab01da7650c1c7e7ab1b20875ac4d11bfe02c660d9e865c8e9b7b1e9292f697613ce5b959336fa0a1f4a9b22e43d4a31d5cc096289e36d1368d54a0432a326596f69fea9f6e62dba5b5c776a14161ef355b45c1727e4bda36f81426da0233606e5a661b64225a4e8c2e620519fce0f630f2fa26b0476a37458b81be24ce1011813ce362e8e007b19d47e81685aeb4459f06cb9c4b5d0fb7039289bf690569fe4a6cffe8fd2a09dadf45a29e68bb80bf085a2ff8d10710853223c0de53e701c09d7f0421b6ae4542a1e50fe7d471cd15cdf1fa36b91c22e6093ce2febaf22b3bb14581367906898e9946cc86d5a8d506e7fa1592a319e8da525ff6cc7cce5e3a700fb9b161887be428b62c6668d868ef976b9e3a02a1caefba30c4b879c64c75cc008ab9a478753d6bf4b051f4e9508bcc6c96e0e83ec838809213415c625f8ca089088458fd715b8627f2a39eb0eb8b1b0ccf1843907df613489fcccdde188717cd5140032400925eb393afcfbab3e9401f891b53ab6fdbe769ad41a3b350009d3f1396a818ede449b5d7a85e53ac6e03a322e0c2bb8816b0fb2fc61d1430efc26085902ad7716617f926bd2e270718329f63eba80d8bdba6fafa3d3bbd364cc9e95c3d06505643cf1b24ecdfcffbe7d8050dfb428f3765d989102f0b8335197133ff6ebe372c00bf72b7848989cbb595b3ae84a5303f04374d9d15c10ad51b93eca8ecbc5530fca0838ced70e680f7aa521b8d22a64a80931b5449ce194668967309f7cafba4c924d9ba8e15b3af8dd065b98e8d9dceaffa4c368df2dec778ef2e59ccf9ed08a2c91bc7199c571a13f0455c12a165d91f759891cbc5a1c930f20c5917494fed6d9ec5c7ba6bdf2cf66bcd15c12b2fade048d07d3fb6c170d2ed694e183095c9361a9f602fa6554bfedde92eb607f234235ceca2262f197ab18a0765d56fec70e0c7b72a049c5e17cbb11425013f20caca575bb7abb37cdf87e8470fc522864e03c0d6de6098426045bab61b753fa417b2a7fc11b1540d6bab2059188877120bc0a52555b1452703a9056b1cc91bb33e48939d8094d1e0693c3c90fa3f4207d64f9d836781825795fdc2905af680023c5253f7b479ee92ff41e68940b0954687f21e496f8dc0f247fc7524ee2d22fedbe4bb0858d85733b1632e0922834da1a86ee824c7a2834aae86c6597c07644b65431e4724780ea4c54bf53cc8ac6a745bd9989b0e2d6e1905d37a59ef3fe69483ef77cab7d9ba176cf2692b46dbef09c26f78b36d1c0e6ad2d484aa2f99fb77e11dedee823cd83d44ad1e435f1cdda47ec048721d2a29a3a65e0c0dbd2594437b90012c9bfe043c6df2b03a932a35396263372c9950645a744f3defb226916f02b9fcb8570e8ed4486e0dab9e6a58163a0b118e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
