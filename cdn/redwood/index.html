<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"273408b26bc68679ed7bee98e037c28e5d652d75fc854b673b5238cbde7e7e7356374693f92fca42fbdedd49822cf0f1037533752176c3f88d6ea86a9736abf0b012026245f3547fc72fb64a92fe2afddfddde7baec5c195d7c6b33953fc22da9835482fd9a866d72dab2713b930e32ef0bfd74765cf254ff55fe27dbdb1d0def03278480d7d2415234daffb21bee709e8d1d0510c21a27c7f9065f660d75cbdff319d62ba78b284f5cd1dba63e3be6fc3128828549c8ca001753d6af7b5834bb8574db5e21493e0ea8df6824b97b93abb47d8ff2b04ac88362c8d21d9e0ba69f84292eadd7df17914200e22c2a3c79de84bdc0aefaa85bcc785ec96a9eb2feb737e147d746669aec3b1c6770b68c31f3a757afb8cc43d80f304dba1009f843442e7cae5ab419f8efd7f1e5671c891329a89cefb6c233f8680649037bdceb74eb0c2abe986db3d1f53be0815031a2903dbe5ef361907e77c06426cf839f4e636ccdcf04c594a196238ff75603c9113630762b0e6c9bc5ee410388a542ad075f4bc669255108a48383ac6c03864aabfdeb36768cc547a43b21380269d7331162aa862f33038443d23258081a8af54cdffc44539ac8b5ab76f3a2737b4fa1fed8d9ece6c87337dbbe35e91459e035ebde21f896b169ce3f9875e3f302f065e40f1a69cd5d63a1a948a06beda21643c991ab11294cede2f4719a4a5eea8f770ada88dbafcd7600fa1d15b9072bda10f74e0775a9b83fb3d6c9300f41b8d3b48a313d91fd4bb321522a64c9b1615772988be192190a868edfb2438a9797419fe7c6253224deaf505ca1d10071cf294b406dd3f0046d0e5c2eca66136fa1b49e2d6b8ead3f933dd7039387bbccc175c1ad53703830e46d7b12b623777f92f412587ade8652455457cd1ce27581f2ba3ec8a1a5d002df06ffd6838b924958ad65bce3992c1a6aa572d860f21d128e246688fed089fb7f2ec4f3fb12e99873fcb5550e5909e980178bcf7fe700e29224cf7825119433a46d70f324a93ad03d5cc857a846ee334fe7540f46a52b384a1ec1ab1b38e26d323a029cd9d62530f55754d7fefeaf42d9a9f8b78d743fcc3462bd5e2b831cdb2ba8c7753d480668f8a178a0d4a4dec68c20a178b73c20a581c3e0233b34dbd8e2c60948334564b8d121f213e7f668e34cc58de9f625356bbb9676223e37a99eb4937985f8d6cb6252ea95d1ea1ade84095642e6af764b4efb377e06b0d20aecf65efd066f7cf8f14c8908fa269d7b5aa4146fba5a8fafe8331d88abb1a885965435819f403ea0e6dda7ec9f48e98d9b67c5bbac3ad515ba1c76c39409580168c91b9023c877eb6c592f45ab8e8d9394954e2895abc9bd3b574068a300d58a0224c064f46b71fde3750a3631123018006f78767d3298e46e221b8e5e8df20683a2a513f4bcbc58687eae2731d8563c023067d3f1d2be4f237d71d2d264122c6de8f408917b99a2021d424c9adeccee603e7b58b14206cbf36bee140168eb8ee790d913a98946da1181a7f143c6dc4db31afa088a278290a1b97761fb0e435d3fc393a42cfc31a7a7486efa0427ecbad38c9988b0bcfdc1fe5691881439428e62b688b2a8f53c0735dcc13f01e01d2223c3ee98ddcda4fbe8528574d3bb22f03ec14888728da619cb903f69ab74ab31ebe715065fde9b87e9fce373a71eeb9661198e0f950c197ef5a21f2b5fa3fa6aef0f29e38a15c35cc1488a00bd581a52f030c1eb55dc8a07edcc5faa11fa7c3ce0e687c79ae0dfeee558f92eeb0b1a060e5073a0d13a0d8fd974bd6a5cf3e2f7ad6e907d0551b9faf0662ae17fbf45ec155dcefef5f6ee39a22e1117ea93cebf4c109d1d6c5ee7a1d097cd7db1669131dd33835789710d34849376cdeb1c0e5b11a628410850d2821933672f3dc6fd80a75ee056cffe910362d065c00eac7829851d97d08235311f34f1638f9c944ac4b48b07a0e578d16ecffe432029d9c5b6a9cdb2bbdde7313958a0bccbb98f65acad10330fe6f8c52c93456d9976bc124433ba789dd73c4656af76e410cae64ba11aa004975d99cd4bb1aa04440069b579419bd97d6e7259e850d74c1226b16af5c66bb0294b0e527ded248a22755fcf0fedcdc536af1f9ef8ce5e74044444c74436ec7857d9445c56373cabd34e241bf5ebeb4105fc573e9387ada6d3c5b5e066fb4968d98d63f0465f0a22ea1240936aa81d2eb80b0c71381e3f97e18592fc269fcbb722f3cfac6652871a45a8da2bcf5471ed2bbf38a92ad547654488aded01d4dec906ba094ffceb84570b9190f12a5fc231a13d486f6fbb56b89d30a038bd47a022bbbdbd6c8820236f09ddeb858ea7b2a5ef131c83356df7a5c3ea29cfe9ee17d83e8ac560c857e4a38a4e3975d62c9de92fca5f0c39b37cd45b08751215627fb67f1c9e8fe90da0626072cd8601524cdc941d6c89ddf410b5ba8796a72e7f03311fa1b64cd369a8e84c3a908ae6e3c65768756b5bfafc70e0b7e6f832f0e7c88b0ec6b886ae6dff28a0617f95d7c19ee3c4e1e9ed5d6e231d3930a0891225451b7c3123af5e1b239b4ebbca66c822f8007ad945fba4b4859ff6223f317528d276048ca6bc4aa38c4ce5e9702969e66b6dc60d10f7473818dc8448804449e3f89df79edb8bb4ec7a04e017f7994d606fba5534dfd7fa52c8e887964c08536e8c6775267862f4df3144f145e1da1b4dcacd7d342066eab4bd5ed71d13e730047cb8fa2da240400016c789823cbfe2dd347a56be6a701fdc0eaae5db1a6397c44844870f09a9ebe6ff4a85160ef03c8a4e2f0b888809c15da2de58214c2f3ec0d702ab356798edc400be11107ff720cbfe4ee01cac213d35ea7e75734f6412dd04d6c3d6ba38e9cfc0df0d3b3dfc4e0ee80b3a0d9899bb3bb3f8179676fbdb2ac3796dc5e2d5ec7cdb3142530b725e63728d8caced4ae434229a638b8d2095a80a29cf25355ab543a0af712eb35bdeba0de07dc7c3ebdf431a16e6032896f387584840c09ad5f464e1ef3c676d0fcdd600b135065f08fc92168d592cc65854b2da739d94d4fdc20d4e2216d94ff74ae6c53652c4952600949a8486f76ebf1bedcd3deb4bf0e5ddc1b63221e64f2c0fce974eab291e077ecf7218062b6fad08b58d7c78dd3c7176b4d823dc4d60b15b798f5de6d720540d292cedd9bbf492eb56dac8804d35162c06ca2d13365c8416e959792816c8996b644e69a79cbc079711c40f9f94e353773161273b7ef45fde009acb0e6b87bfeeb00de8c697aa5014a2bd8b9da62e880ea7ce15dd125ae815b577bd28623a501a191ad7c1f70bb8003e2351bafa3d9df7cc74eb03e99444442d291a8987775803caca224fcab763ecfef50d7eef1a258055f9de3c71913c43fd71be9c7382d59a3a0b81609852e1651d9fde9b3c4468285dd2e07d073a1f7305f0ea5c9ff747513bee9074096fbb6278dcaa4f5098b75804f76a8afbbba64f39a47026545c605e055e8bb023b5085d429e52a3711ce001f053b7bf9c5200cf5b89e4adb41c52c9ed729981ece3ddaecc09a293c59c77ec7e033ef01cc4b058e15c19a5824bc99ae1734135b85f2ff2f32731e9d707f63c2601ad8cc9ff8d89f2ebabfc8eaeaee7b6d0df33c8eb6d08913bab1f81c0c004979ed94beb0ca66faf45ce698e185ed67fab8d686598951e0496d464bab80efa135baeddb99aea41e30fd1d121255af48831c7831ee512388732ae909585a7cf9fe20d730c28ed32857b10c972c1e4ff92724c92f474aa51a5e8b720dfcc0e4c1d25c407f3ce34365389ad8da048829cd2d474c32d943fcea79c50a21d15e599ddbc8666ad5b3619b556148d6799563a59b68831288674bd2a21946442c943b506a3f76d797ff906581da296986e933b3ff0904e2c534eee2ce4454d8602fc0128f97184f952b5ca3b7cddb1ce24a430522347178d16a2ca8e60a6d4c942caa9634eaa92caa42ea9cf62199db3d4b0fa59b5f62f4d33d18e0412ce317869d4f05e61c21246bdedf5a7248f0f9ac95759e2950cede6bd3043254cf6606670798fc80f078bf84af537815b8a9c0ee90f5b01f7b177bb5134906d09bed1e2fee36577123fc2caeae74fd0dafa83bd6e86ed3a477380f7712a4c2e171e533f73644fe5ee22dc3d1a4d4f3f3938451a29c1a522f8831e1c11ef13dfabfda8e3ee7b32ce17df467faaf6d1ad243444ce2b835425a242ecef02b2206101992fc2b872d085a4f2b599a037e2486f2908876088d942f25156c1da5ada300ba8ab06ddfbf6ef9a0833a47965c93168b5d1c789960c3540fd484c6780a28b0599a55e6b28d7f3a95bb04a835b2035a2d5f97a2191372dd7903e9b922ab22e4e7d426ce95c050631656bd38f26bef889b78cff5e456cff48bb0a1078c8f5c82dac40af33220ab0913a54201be5e89fc3c2b70086343a5daa6dbae4ed9f3f54d58a3dd29668293758e5cc15417541969c37b2eb492767ae53bd24d92e636a7e081126d9b79676d06db3b9c03a43144e1900e3caed88e140bfebef8b72a251f46e65cec3c880e6e4ca08bedb4ad37a966d3dad304bc68a8ddd5389ac18800d0e115787fbc5c3bebb6cb6525c21a2cecff063278d15aeb4d27430fba0d5d6d7629ca1c4f7651e83f9a3256e351c34faff2e41f8a495df5fb3644f6ab26f034a777acfc901ca604cac2adec0d88b9f6ab4402d5b401a2c96de3add559cf8393387b957f8df23ecbfb52d0b1c234919b7f074ae1d199787ed0fc3de2cd3d646a2330fc03de2a33018ac3a6ea3b7398baf751c32b1b2d7101b08d1248f37c35fcd5a91922146787d3487d050f63bbe027e50bf21a09d3860adb65b5fbe1f73fd9987db4cedbd0abfd44920f8a3d755e90a38b7e4b21da280373dcfafe48ca504206246a8932dc9e07667c66d1911bf2ca49301f6c1b0c9936db0eb92630686905c19ce2b3753a1aa9334be0516adb7fdb5beea558b7579968f66f3d5499bd915d4ecdc978af654a3a81cb36a17c39f87d9903da848441b9d94621759e3a1cafd0bf69fed954e5944d58890dd4b5569275fe80d7d404151f48afcda279736e07b1d15012638a2a78d48eec6fe7e49f8b5b7f0ada9eb6913dec4b2760ca4b2209e814cbf776be9ceeb09bd26ebad5beece95c659f5d222378367d750691782402d2cce8acde700b3b97609f1b3dba593f090f46556e831dcad595abc00331d79c988ad11f5b31510d0060413af7a839e2a19cc5e2afaa2b6d0a8f01d3f952e7db3a6cd203984d439236aa66286e004ba8f5390972b9f2b18ee1ff471e13767e340d36dd6450b97546797b85264f94510bd267cee3c78c086880f51f6062eb4e1f425c9d299501e0af4ae5f1fd59d6644b76e8e77c1535e7f190d384e157a1dcf37392f22c14de1dcbd688038eaa8b81e8af1c3e9167e60ccf4b552d5c233e10fd38d407bf4f2ce295def12fd6742cd4ef1400b137d85aa857122d6db0b4a0c8e70115f1c89c42dfcc9432c9a83c7fe4fc5e9bbd90546cb04872bc5b8c9c4be03e5aa382f50f281650c1f0fbf8ecb4c3f02dfa685e9bb5ec48553eaa7545a2bc33295e9bd7e7ccdf8cdb359481523976558c4fd1cfa6d1544e7eaa9354f1317234bb7cc5da857d8d7665eba1f22e600270eeda41ecb7828f504ceb41b54595ef04fb1741a9855218fce3d03106595beb2fc3d4ffa441d3268f0131886b5d35e663aa7484ba9cc7b10d1b069b9e70c0691440adb6918026236fd0cad14fe6311b71fbb15a43d91a6be49b9213892424524c974c3a99e423d3da03ddaf9d33cfe3e07e79054100c5a1d9eaac553b44d2379de1abc0014d71103e07c8534a3fb8f903e546bfdc3879910a1fe91503392bb102d3f709b485932b27a47dcb050316e5ce3d14c58127a05d181faf347cf9e185c6bbe248a8eb51410d862790e74779085fd2cd11610103712e9d5f15c89e235c2430ed61d39dc6db20544270019979adbd03c5a23a89c0692db7a3a6da594e6506092c4774b9226e6eaeadc84c22268046b4c7a69cdb5e55e18cc64f3e5a29165ceb7d5396b6374e1db67c3ae2ebcfd443683d17cfa8fc246d6e33ad2fadfe9df267a52b97f201cbc0ed33a6068062676b5f29eac27f8c5614a3f401650f5ad349f8dea1f0865066bf2979b0b6230ac4c683ff4c9bd0a2ae84d2946e096ff809317ac3fd9cab7ab9c720f7473e976007b1579f84c5da9688da12341d808e18940f9ca89013a58290b83462ee6373aa2f4b707aeaa3f28557b0c9e91e6d491aaa7e115d0a2e3830572d48a01dc39746970f599a250d4636be99a17bddd016df2ec2d4db5aeeb506cacde2a81398fde96a1a1a820a90da86493945cecd18891b93bfa2b03d57ab622b8285e5135257e929a935112f3f7656d61bf4e919dc65cc28570558da9fbb96d6856acd24ecdf10fbc597f421b64206cfbf693809c322b1c2366e86b05420625992cc8e53026af8f1c95d55703f108e8291016c8efbcde09e535b8025ad16b1810ac5511d72077e85f3867247e31ced4f48f3eaa8d40019f017b4fb8b75dfc8273d5cb1b41be4e280e435b897c937275123467b974a6b3bc9523b0d3d8e82c430f6c24213997dac612e62800ae1ca0eb3e2223d341970cc0dd18250c310b39802982880893a294252ec24b9dd94f11e9f9df8fe6352cfe067499d05e76d5717477bc6bae8aa5cfc9509d90c8fe0733bfab0662422a7334d1665c49b110213a77d4c9b51179a49726ce62529e0ff1152006182068a58d81ba0ebf8c139f789c8362c8c3b8da4f91ebe8f6a6e5049c998ff42d2a85220925ce2bad966dc5223942862576db9f164dd50bb35a3601e023c6b200e3a21afb385405d4fb1ed5e3b31b8f19f4a017de9b4c941cc6e6c90d98b1482b0c679486a2058184182d678abfcbb11f59e62b59f3baf6f32f93811811ccbb94f3340a2b753d3a409a8966bcb894cbeaced123b50f3af60508bf23cd9dad7bde7a3d18b8cca72dec805edaade930038a748949b697fd743d8d3450872efeee0ee9f3f7cbb77cb76ec363052e0e351269af8a153e7564353d61cde1ce8a53b6817e845483c77280b0ee7d01419927ac83c3a15691e70365d3d327451d545219775011c9cb481ad4e1b3bc118a2437f5c230a8604667161d38750b2b950949ac7610921a5de52579e0e39a9f49c75cf412e0d3263912dba47449c33452f32fd628be74def5588138970ae8280278e6442ff83ef6ba69c0d9894bf6c70dbce08c05f68469d18df61a57ff30071d475a0e8cef3ecef7c740f345628760caaeea3f2045ac0ee5ee5ae70124abb83d8a12790c1d7089a08b2e91cf8a3330ba5bf1fa7496713d7e02749aa5fe4f45c8bf780de6955dcc0900ceec76b0e3f3fd7885add305315d68a985a777d0cc55454ee8e09f776d2c5a1b0a732838e7a48d80071be4963e1254cbc3cb46b9abbabbbbd7fe68d00b75764d14d81e5224035aac238b756190615bd648c9457c71d9de467dc76141f7bc0db23cd727de40632c0f90ebad8a306ab1355ab5c2a95a968bdc3e26f53c26cc3f55fd383ec35e8c48580b06f6737700021088d2b9412c8ccb5e62773b628bea54580316f11dfe8d399480964086e39f26b5bf15597ec5341d6d3f22d0d1c33683b8e92a9a5b3b12a00b87c4ce986777f5a82b108384ce53d4d98603a572ea7ce4ba64386e0ae702a6c2a1a43d6877b5db5d2f83d671b9b5f5e682f0056eddbbfe29ee922671c4660b72bdd66d95815351bb24d515e2171521d6ca22bffda6f930fa90c5e5acfd19f0a247118cc48319dcb415b31410884599a2e2dcca05ab1aa81d8204b4b82f0a6b0526bf21977805e447f96ba3dd8c6c0c317d59a8d8568671bc1e067cef745204b388619799cc4ee7f5d69b1e1343d6ecac50c8556b6df83327283590d2f029d41ffe923f4fcb1e0d75e9cced2579f88dc028f9adf880408d0b04b5d4594faeb88370e1ff789d010197254e1897b709a0973ab9b3c27d62cda090f21160efc70828965918a82332247d89eee6caa55a52495e62c20796a45b30db2a747423004481e9a71c33b36dd3b13b304881d6da4be60aaea14924a5072742412df3d105cca21a937bc67af4b712981938f4558c03e90033d1072712321c55c82635bcadc3e4bc3f9a7986d83f51045e3647c8e49a4db75400454d747a558f94afa789f58b9095804fde991e707bcc5c46c3a86f5920f73fb6ece2f28c0187db50c2bfa4914d9a217b152360f5188cbf78b61f8a7b6b2f6d4bd4de66b8557330370bacb04e8f14b3af75e6362f5693a97e1a3e503612b90ef9813a0f7d66ae958c8ba288e415e160ec8584e86046f019b546f50d050ee257e06a6c828f881e9fdf9248431f917cc4e60cbcba1f608fa4f15e23fe4673859127514f744545b147a64afb04f970306a3a371e0f430a2ec7389732e958d3dc028cf07390a4a786017a1a084d9c6c30f6b0439fa7acbfc9cd750103048123d5935efc32b953260c69b9da5d3335b24d2aec5a46e653d984e07f8dca139f53deaba1c8f020e04057bdfcc8e84012f9cb111061ed8b6a32297c6c9bb54696cfde102980fd9afae09c73cbf87dcfaae485468cb58ea796249a43e8ae2ce49c245bdcb39d6154967e921ba22827fb12ee4848084f09d90268ddf03166bd9119263f9786479550b743aa4f0fa4e4e5d33c0a6c7ffb6184c152c9aeeb0b6a8fa42f4b96bd3de4a6ff288f8be353dfa9d38e81a62950e5fa63c29384e2423e33cba3e3900abdc7388144c6960bcd1520351a843575066cdaa057fcc7cc128e52edd9426113ee291e05005a9a6bf80b18444ade09cd795b7e127fd5b5f3ed72cf06dbe0f1ee316e709921653aed623faa6a743886553d1cbb6f7d79d44a570790b4957efabf5fecf481201678456037ecfe904deb0c7f1566ddb4cf41e788232f0903ce849d5a01aaa2900546f011e4c26879feb107e8ec2a1357db1fd231c0347e0a07e823dab593084df3b30f10113c9e7573c0d68aa473f19bf3f3b996866127a7072899e628fcbc9f82f32b6d03963e5cbbdcd02ab9a2f3dd23818665ebf3fc914e40f321d3216de2a7948bb867959367f7dd4d591780f587b0af60a013d088bd85ad09eec43a08242e53568815a812e81da3b750eae48ba81413d7117f6d3f642e1281e0f784d36b97f15c6a0a2f20d414fcdfff6a2af7ace239b4f8e29163edfdc52338103306c802ac5c62f7ad019c345ecff917ba6b391ddb27cc928904b602cab49f6b21223ddc0402ea046ae5bed9730d1a2468fb6b2778aa801ca9238d997f6191bb3d977736d1db299153fab1bbd3f7bd06d3a3f73e52146ea3ca29317ce85468a13d8aeff6fa94aae8e4f4189189225984a5f81cdbc25a66af28437f2ce78e500a38a54ad65ba61a3016a1e063806ffbddceb09df28a642bb554d7f241a9117eef8e8719a5be17099b4541f2cf5f2cc335f5a5cddfe43fe34a9dd7d3d352fe0a9d6ae6a1783a0e931abe5b0c3168dbcb95233d762449bf7717d4e2eee90ae61e43df51df61a82a31efed93205f57726926b1e73e3000b6b008e40cb3822adb9797fe87f86b7ed2572f0d9a7d71f6025493d7ffa03190c2b539f76c9ca279e0ae555d7405b6209b398bc8d3be90e4e12486d99d4a69f53bfbb51cf822e92abadb3bca59c4610b39f7f668c835c0aeff91502a9d530d84ab25c92065ffb75e44cc67d0abc00e1b60d7011fa36443e06893405336e27b4c78cde5e57d047076212140ae2f8d525b77b79148ae4af74f835ffb44c70b1cfb67fe5404b655479ed2f50c9f4cd8dbc68a9383d3ed4fc1c70ed15435b2de7693a580965c23f272b19fa4fa7ed8f645ee6c34dcc89146ae361b4f90d8b840cedf5fb831a608710d5fd6fc68d655168989fc729d7ca8f98c40f75ce4571ddbfa28408eebd1b0a26cc5b52b4c6dcb1dfe4a3788b65e558912d889685f3bb29a5d547a4bef1c774ee1050b78f0896e37f929fcab37ac3e76c4ea372f88f6be8793a74fdcd237d6920354ecec347d41f1d11e350cefff7cf6f5878cc955da8e801671919094bbfd624a71fd3126d663476c325c28f56a724feee4df312e25bf50d80652204d9e91e6a13fb0958da5d0d05121bc724c894f1f0cef351733e3c807328ddf0404983518d0c071892f52e8872221a8688822cd691ba84fcc875919f5a0b6106e2ab9f8d92afc60dee861aede77678f31ac07ad3f114bca499f2c2cc86dbedf0ec47bba1b218ab4b2a943945b3c4d04a325ccb2e357e8a906ea2841675c4fb849710f2d1e1efaef7fdc24a5b44cfde8b07c8e7bde862d9eef8275193ff9ed00232c9b5eba7a38f3ab4fd61e2c23be5d231d8c34d7187bb53671bfc1632aaa31d111110558f72fc1a52c882720fe227d2e93d55899111f875931e1f8208f94168dd2b1530e85690d5c1f1ee4967c8a651deee72346515fcbeb45ac145ce9e3849ce00d3814e448ba3b4130ecdce9cd9c012d74e41bdf4a7396278ce1052106db60c11efccc2d1bd6c6e4bdc6d1ca3574ba2bbfd18e0bf9b2efd3a3182281967b61c8b0ce0cc4cda965aa5116a87e6265fbc590a6a7baf723336204ab341146ff1fbd2427388b2f6e3b00d4b85c35f2b74aaed2d312ab757c186082587e8dbe793e0a871d9c7895f1b40b819e7171e4ad13b7bd32e01da7fb4c5c194a51b7a6681d092c9ce318de93a8033c06f42e22030eefc4e3e250be7954dff5d20519e99b52df9dba63e6e46c47c40c34239961caaa7be2cf497625f2de6e02c59613d81b38f9692530e78f57c5c12d6cfdbc984706a69918acd54c3c236889b5ce147a98e69bc72378daf2c0685f823477531ed10aee57adc977193c3207cd356d93c141c35ba9c3cb9c141c33a9bb256ee3d8a95d5754708a73f2d860d3e3dd077c4c69921c439f6e354e68b0ed60cd5db138fb3c46abc3707c86c7e37d18dae61a65f489220cccd2da43972854b0361decd109632f3c44a8907128044011df5d432cfc7006ad893bb045b4b14a923a7845b39e219cf9c7b41e44fc29a32a1b0546fa603600cc008a0804c566f92942c246da1c3e93bd580acab8503c650b68488ddde1c4bdb006b178a93869d697695f15361e40ad2d94ca4204591b90457b1f871e9d8844014c6a1f2c7586b240cb8e41c526c0eb37919e5c73138c8b0363165e88e4649e7c16b6c11bce869242af23f52122615ff9c4b7e1d7f5cbda9a7dcddfae0c1891f116a5b8847e079686123d50004c998f99fc421f5639afd93088b24e056ba615a2e7fe0d9a9fedc208488ef6ab190dc6b407abece7b984253437084da262b933c2a5984c5f1615941a306337aaa5fbc3b34656614d3cc75ad52659d88c0ad4acb00a675a11f3d35489ff9bfdd0e2ffdb1f22408695da073c93d2bfbe78b04a139135e0ee6f85b5ae1fc7131a25c2b8e067abba7068dbe0eab441088210e91d87bd5a029397333a6bf4ccf2625c01a692c321431c20270334f7f046556aa73394bec7358096547f8764131cd374b80eb6d28ab0f6489179fdbd9e808f79211836075f4aa0a748fdea61c80034501a54213986514ffaad339916dd679728d479cf15327161bb73aca3387017549aa0eb6d8bb611861f592451a48f207ee7c6087a493ffa3cf5a259e7e7539cadf66ff168f8ef22029eb1c54083fedd4d85058f3f6361fd4431adc7501de7931144b50ddc271f325d4196e315bb2c0308aa64261c529bad6819e856b505dcc6c88c32c4ba0c0173205055765029d920de3245d12a46d74fb99eebdd687fd63362c7148b2f356cf04313ae85e4d8021f616e22456418244ce8c3519db3b8538c6e33c5b63896d2517e0e452181fc65275ac545d89d5619f6fb509a95f1164e36acaba0bf8853468156a2b61914b6906ddd48195358a4ad58873f10e5c4c757379c485d22e66ce9ab4365959acc48c53464de207dba7633a5449187b1970bffa2d6d8595dd914e5ad0663fe16c2ca196f585601ddf00720aabe0fac14da20953d3b78d2fdab464042a79de31e0e15803e517783fa53ee00ad3c7222ab40f9ec09bd51316e490bc418ab0a9339b31df943d1095137f856fa22624c8ca40b9b830e693eff14d84d49ff1e59e8dd718418f52361d9ea1ef54decce5a2974d850040a6b515c082c80f18a5bf8c8b47ea64e8c6ddcc1eed0b0f0b21f94f61112b7503b45ea563d0373241b26c94ddcd594b253cf956c7ee60cc38a6d1c7b76bba33b91f888dc7fc642b8c4f25aa6b97c637c449684382b1aa58173f796d41118ccaf9a44de5186576c57f4e26166385f9f3065d90947bd42d8bc81d63689ff761780013067e6ea0cc5a0eb3b170820ed6b83a292ceeef650da359ea1ad08f1973937f94a263fa2b235dba49c0dd63098791facd22451af296a5824a5a8340cd0e4193841310a2baebfb57a459302dd6f661a16ef30a25fc005ddf2683cd09badf01650bab221e9e4b56089274eb87c5ce973ced3b4d247cb6f4d707209073bf28d67829738ca06076e9829d5109f429a5384eb652b7ed291e6f66ce6439a4001a878fd0811fe85e0c720deb490f840ac7f551abb6fb31c921b4cb2a1970bcd822bf9213b672169bd402b1a0a664f57cdb3c2da60449af21cb5cb1c0444797d905ba4a54cef9fb85670c1226df5cddfe86617f23319cb2866406514679cd72a23870e61a591f3d8e2d8f45212449f069447420a685073fe52d691cd2c2aa43c0902e6e36a9244c53d045493330bfa9b47ba76daa122d46e5fb40da0df6e354d0f46f76be12e6d5eaf84d9c5540d523eb5ee296bd52edec0338ded7208efb446e02bfe23a2de9b87a0a660a346aa1e79bdc414d6c89ec571b87cb81d1c76e515b54a3b48279b762115477cc828d1886d9ab7f9f9117a430cad7e25257e0f73da3c3fb222ef5beb22a0e1f94b8e46cef015c8cd043e22822ceacfef1c13185c9aa62246a4659b35230bd24987ed5c1818b388241b3cf0964cdb284e654a6c08aa6a89c6aea25ab3e29ea847e35e0140c5958efc3e8aa90613afeee1768a94ee1ad30c7b536a2d6213f2cb17585e86dae2560baaa24600795caf53f858fb328bfb6c3ba33750fa752b3181c3b336211c4c29a8e57a1afefb69ecdfd2eda45629d786e380691801ccfe59bc534a21150c5e90ba79fcb3fb2493221dbbe0f4e217961be73ecc4ae904247f186fd217ded7e4d1ec89278c53245ebc28ea09e97e72254bc27b4ac69cd97c11fd07b99d4d7759eb3d930bc4eb5e11a533daa007937d8a0b71d441ccceb0b17c7fedc6d14de7e6b052c35f3b527f77ceab275862e4bd30adfb3de55b26a88c330c66467a272e70d88786cf2a6ce13c1a40a515975e81136b03bfbf590bdc184bd5ddc31a1bf97f01290badc781eb599d68fd3386ca54d8cadc3d763f86a614a7ad63bad5c884c1c159f910ecf39f0a97040da688cb23e7cd193d7222c4e3f1c485f1816bb5ba5393770eda05cc3917c6fcc6c34eb3f262f90adac1bb7c69c16f01f82397f3a9f16218a71f45e9cd48a6328ceed5a1de29e8a386b2b286a182da538163962b646755126a972609687857fb76ff7d8a9a44a6a8b32f2e43a66b724944c7a9851c0fef1a4e0dfa6d89eaa9b9f3f806c3c60b2ac489d52bf04eaeec7f9e8ef411be44ac2308f84cfb6ad815cdc7c295ecc18ccab6bbda02a898dc104e2b458732720b09358e3fc37b4e069c44ff61cf525a11b80ac84d9e8cd1a94661ccd0234e99efcdc5f770029cf7617fb6e1b87d46bce17a5c5605720cce9ce6dadf4441b5d899e3436a1b29440745d2caa522863b1001c1c5514b497210e4258b3cd6c811af869b38a6344b1aaefd56e6037bdde374b4652bbddba814853bb54ec3f284748083fbacafce0e63585150f6f9063636fdac8613c505592c2431da7da2415967f97db76537c8218a427e7f0ea8272031bb37931c489f3c507fc3ad5a31aad0d36cf396254a46468e62ca719a47de2e3164c9c0b03daf818f496a58454c0e63e4c8e358001f98fd59acf2eaacaa4a81f0eef37d4b6a20e5b304e85b6c8b6d8e007541aa64b880440e467adbc7aec2f26f1c4d0a1abe8dad426194bcfc28eb2108af6ddbab6a1723d52afe8a6027ee3b90712a3bf437b239c2f6b0222dd11221ce05e59d6237a6a825c215a1a743ab3ab293e17e508a4a1e6054638447f1af5e2938571a349e884548d92353316da7c35a2421c49444c51289aef212330efd416c1b743341e763de35420a5c343279e38f17c6641445f7f178512c36ac90e33a8e128e4039c0880646af23a4c46be21297a3b25cba007a174de1cdda7beff11057948c3e4a9a7946c95a399d1c361c2d0a3705d0c4a2e076f97bdbcc9ee6be8ed16bb3ad82094af17d0c41e7fe53f2c3382efa875e3987533018cea478053a43fa56c7f0596e870953e62052744b1d7b698531ed14c1327de1c3436a5728d56229cc00f7ee6b31860b412b5d6f99bc244832ddd8dcae9972dc2f0ba53132b14167c067fa3fe29abb60f84c218c893781b266143c333d1debb5cb548827607d92fdfae882c25e8ea8e46fdb872d065ed38940e3fb614efcc65afdbb00e670a51f1c96346efb833913099e5ad6d19778cd862888184dffb036f0f0c456621ac2b05cbab3f8d13d0529f5890d567ba55c6bc1c6792b1694d5f2ff9fa2a843e87964dd556a01e46a0a71e6375105ba154108f6b63b8f03c0e679c3d14515eef4cca31b1b9b77ce084b170f9097f4c84abd3266b0f020e5546856eab80a0b899b983b406b9e243c300545823980ef34bed06e1de89997085660483d9bf05c72efff49eeb709df18c36a4f52cf3621797bd4b72dad0313513773e3e81c4f75d0b2f5d0bbf0390f0029e5ced85fd4a3bc46e55fddd6cc72f801780980098f9eb0499f690ed61213e547d2ee431ad718b12b8f0c4e01874e7d2d7579eba8375da0f5ce1f44f2fb1b3864f64aa106128805095c04da9371b929259e7cef231238b49912292c9aac301b09a4db8106cc24e6b2c271e9a322ab5466c272cfd2f45a60106eba60b429f071f9ac306f213d4d1a1f2851a9cf83c44cd5b02f61e7c04a2608a810265f2e54d4b2beb554bafb01a088d5f19c15309b5f687988b1adaf21999aab196efe2bc956e3bc6c0f43e6b825044b12fa72fcecd6353c1a0289059bd3169190be1e014f1253689e4eec2e976e63965bab53e6793ad0d2d232ed60a0d832110e951dc034cbdfdd669452cec6266c31b41ce99f0ff35bb49571587456614d9fb25a5f4333e9130a1c4d148dc46db2a94a7e4e6166372d6cff7a15422d571b2dcf995c30852d54f560445c253c53379f1254b538d4247bb989e83e6f33a4ad44cde3ac2ac63a72ce03ea4cfc610b7f7843ad15149bd6f295d70cd073157723da2477beaa2e9dc22dae5773c19dc49113ef6f954da7a5a64711f738dbf68495e44da1e56630e0ee379426eaf251195b2f95648975d8d556de265e0961908b6294471e50b5ff74bfe41259304aef2303c74137b4308398635dafd2bddbbd6d5196210f45de1bfffbff20d9a5f115713f08bdcf271c1796920c7a079e28e81dbffbc1c1d0c84307d11b9583f1b89b53ec6f4e71ecda2936b41428d1b820de2305693f71c2d08722e549b5d954cbce73845d3bdefb87916c183e7cffa6ccfbde3216219b11c49ed21703604a99ea425077331a37e04a829e7bcc795b19e2776049ce1f0336b0993b31f65254a4ac108710030146b8c0b6f89012417717d084673317150957b202c1cddef5f0cfe0c193595dc103a64faf21c49eea51f53dd52d454ee79599bfdbe59b7d48bb6b4bc65dc1a38521423a2c212a8b0edfa97502ce8d9ddb2963e7aee9cec6cf08044b7229d16141280eb4b70f28cf804691e2dfbda69c7bba995b8bf000bc84c239deaf47c73990aa3bccf693c997978c605ce266a7075e89b815afc257d924a4bf9a172ef7d5112c732619b43ae9c082f34b306ac22636e80979828060543b2ef7341761619f3c3c4a12412f5e9d717cc55b4328c01ecaa7457746fc8bf812bd8715aa5cf90f0b86e8f1ae935bba85a6a5e474cf2ed3d6cc694ae8af98ccfe66be438bc8f008ee0fc851f43f88196003e5c3861733db9a464c31e1041c700c87dc6340cd0d92f56fd4601b012902d8e5cc29d3adbbc22d57f31368bb873db9a7ba2bf98df72b1b68f05fef30a70489f9f972e1ebeec757b91f8f5f75e58ceb477963353b7ddb2bbd6688531f952cb5e8fbadeb3af6577557fbf8178e72c3f3b32dff74528d76a1e738c1cbbbf44b4b93db866aae3914d583c9360c45cee764d6fba7b1c755c6c90f466af2c41f70c7ba567bf95e49aff8af6a75024435cc2f8f27b54d11cd4e7b48ceb984bef6fc1ca502aa1327741cdcb1a3c933e0a7888bccac542655b13b23c8d9a34886d795b8356967a4bd6acde27144afb2c89f211f57131be179d888aaf0ff0375843955e7e053522fa1a31eb25ac5cb5b350b07fbe90ab3e6179aa0c266590a4afd192670b8ca51ba14cf3454747d4b8cfe7fc849bee02a3e96a107d0ecdf858201e4a6cd152069c7e1f026a6eb47d9343fa929366989e54885001fd4181a9a84ae5677fb7dc6461f2519dea44a0edfe172396fa09e2d99c9f81bd19bbfaa96545efcc93d2f3e7fb32491bf87dfd04f15158c0b97180ab809f74135755b65eb84825be2a5c78ea92e004094e158f9705262e90c196eab913058f8fa498bf6a24141788762278687665e6da7fba62e5f382776b210e7f56109f033c4352d0d7cff1af1efbd74b2371e449d91a0ffa9d213501e2532d946f93ecf908391391d12edee613099378e3ce1ed681b3acff3ba481a55fcddf0be7287065948ee3495953af0ded452e7558e44351c6bef001e15edb4eedebc011940a50e9a0fc98cda81802f3aa7bda53393978a53a9daf151c8e22c9b578e399bbff8fce8cf10e26946e174b69bb75e5c39d4af0aeac06d292de019265086f642c7d7e9ed3e61f00ee72d6fad36d9b1106cb9b5aee744e23165b0f8aa94f551a0f77b0913795836fd0c329fa5cc5f39f2ba748c0112e70f0dd4294fbea1a979e9c2af50eb64eb6048c463edf155addb6be8f37e92a389773fbb5462a36a7a507e8ccab2218287dea479c67d800bebcd8f1f32d5da0e7c3cbb7c0a9aef4be0f9aec254ddb1fa1481d0f8d04e8bfc8541159f6f1b0d345674910c0b96f780270afec736cc7f4edeab2511d73bdaba6476e2edcd3ff4dc0f8377f1d91b7474d83a734de885aa4a5e1f4244476ad015407992752988c3164002aa3674b793af2cc1d6119767e88ecfdee6f597874c7f41209ca8b2faa696e45bb9c4a0df6d17d7b038283cda49e490d982a92591f4f4abf789044877946055f8b3787398393c071e9001265811d75a2503840c76c21b7cde1d1de9dbd500ed37cc7d32b46e53357b2986d124f100600eaaf2b7eced99882004ddf380cd35aa432ae6d8313256e609bb386e00156ecb8d1d96d31399fa2a9c44678e1ab89442f4534772f3e16807b5ef7fc094c25c836db820b0c5e369eb02b8dfeefe48f6cf86e1d469b8d6dae9e4bf29d44845fb7bfaeebd7e20adac2ed9a6ca202e9679c8676d2cb05eeb023f91e560c95c3b16bbf078ee8bbfe1b3800150d1c403028bab36fa52b59f456a4d5a5457e0ee6ea54d8c8943c64c6ea4b4213f3224104fb3cd3a48271c2caae7f47c7f3618f9e72c7256f3c2ad4f9afbddb3d3e15c8853806cbca33966c2294bceed39b22a8ca45fca54c1ea36235212ec6090225d20d50bc51d7e6fb0840abdc25a668ae872fecefe0e60de4ecb7e497162683ae9b97d7009f24f335caba92449f5d9907a824fb81199ca49cf3ff98083153d6c19e57bade58625ca89c4518db3584bb27d2d727534c0320422de3fc811ce7f8b0ffc1c3027928b2033920f429717b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
