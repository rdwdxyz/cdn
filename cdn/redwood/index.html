<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"517f8693fd36dd61bbcd750b5c34e19363d76c555bc01c66c3c2ccfa17d60e9f78337defe2a90631e9f5267b1953f0ea042a6b1f03dbb8540edfe05ea6977d2f715cc452624cdeab1f38dcc0d48f11a6a74e1ae5ee98ad852bbdd0dfe710b944e8d5c658144f3270ce44aeea875f4339970057632d5cfc705d7c93f29491a0e91c6e47450c44b8319ff037a8bf074cd11cb7af6e9af324045a4016a3f0ea6e0979a5481cb172418b2124e9ba764e5ab25f177f59bc816f2d386de16b809f5569dd04298c91f2fb95f083d0435c4a6eda6abdb03749a1603417c8db8453a5a4703f6536027750f9eca28b5af722dfdfab64625c681aa58c1259dc5475498c96566f190c59e1ad3d3821095d123c6db50b9888684441cc417a159e278c6138fe0e348945a96cb0e605d431a5309c317b556175279e63ac8ffdd823ec4b2c5e7d5482179f1bb19bf1fa340986aa068ffaaab93783c1dbf9ec288a8c02514ed7e7647d732fbc96a22842fb09840be855ea88442158e627b26fbbd3eb50681fc53cbd7008b8e9a75902c62220f1a340af957ec631378a99f1852dedd4f79c22eab9f01f64bf5e0270e712790b73534f25a1aa78244f78762a99583211a41a1569b3139d7c4cb6cb216233a57b8d593807151452e3d85079f95e25c0df6b9542b5a83183e90a583081283f0a0adcea92473c28f56b1784d48b7eda59b4cdd7b02cc72b755e2eb15f6ea5bc0cdaf543710c160ef15ad0d4038968af4b37bd1cbfedc57ada4e4600d1bf745e58c1e679481a5425c6c6d4eadfc8186faf9797c49f71ba29b7c627c40e144389c4f584ffb15630e02d13a840ae39e58c016f31078fc3b029e6ab47702c72ffa145d8f4d950dc5bbab38237113ca8fd7492d59d31bec062e1ddcca063327bc58a55b25de04949673b76e227a138007621ecef8e62cee68c35adff68ff30f57a6dea767f89200b20d31b9a40fc41ca431710931fc8c46bd44c2c92223bfcb238a8634c431a4ac61844e2bbf7e35bd3b72b25c8de8a733bb32bb14f0729110f96f9e96116cc284c074dde6dbeba27cacba3e4089a78e89f676e986f932915e708fe316c24716b162a1bd9a2fc9b92d8e78f95342e48ce31bea7c8cb1bedf6d554176fd9e00e54134b528e7f45374f0f9f9c44a32f0b78c7867138bb5353b25c80533720b9f5819dcf635435c8a04f4bdf873fb52189a8a127a0289d69bd98bfaca15047bc43227644e6b620f324f8910f60457145b514d02d17d8b9018f0a9aac5f4289952042a4c6b68b5918c524ba4d948bec4c2de6226f6e7e16ac96988f3924f9581acc23a72bd12cb7ccedfaee20702b51586db1714eeb696a40fbe2efb7586df7ae2dc1e512250f31ca6166a67c7ef001a9f3e08d5eabd1d38c3b58e4d197b361a89322f5e62d5144562a30f1bed2db75132d6c26339f15c5e9b87b4c78c7353e28ba61b23159d972ad07f74d5a3349992a98de56b735647dba018abae6c1dad3a17649162638ca6c46b5733503232a6d89e9a791d4fbe7a5d6d886d056a02b2483b80d9c2fd8936185fa374fbf9dc5c8a65c93aed7b5993744eb096cf2d4321df296d43a51080f4c7e3dd826537da4fd9ed7394f98c8eef228c07b6061b124da7328d88c6a3d70e8ee6589fe8505acb87acbfe962fb431b15c60cde09986dc417850fb888f75df889be215bc8de69a29214bf4f297d1d66541f5549a3ec32a51bf58631e6e026463dced62887f23d81adec1419146ac73ab236dded433219cf6234320f25f1f0aff2517e03d235173582d0ad95b5050312df3091a24e5b3e964d5fd06b279cac2ceab777a22b4382144005923890b6f61feaadc546f9de93584e38210b0e5320177eed5a0a4bfe6719dffe27a08851f697f01e86696badf544f6280d40d7d5b7ac253643e1f352021972064d94734d4c6066160e3d5200c6cf2e2062a31aeabe715db214b56c064033dd00e3116512164c5589ea9f42e7f4d37037ecd6307f0811d7ee0b86d7db71741e65353bd8afe7fc69f05b5405a1ced1bbfcd1e4a0d7733c8889915f07cb4a79a98c9f8d03876eb55986b137f3fda4297ba4e5e5a7cedafad541d3e9c1a8f358574b2d468bc82e6c41ec4978f51176c4fb57cc6cd135b358604f65ef148a276daff078bb3c9fb1a1b69af8461a5e8266c4afc62f509e9b130b58f033cf2558ed7d37f5bc2130011c533929fa3596454a157415ccb53a62755c78bd5ecaf0059c87307ecc766b4409865055cb89c487b7dea1e101eaa44ae56979913b95ea259c66424bfb14c75e3cf16faac74834a91bbef4b513b6aee07e55458794d057b5c8037db19def917f14a05be719b025de68fbee7c00060b01b3b15ac21475e49777b61a2e3e127e9f4c6d58d98fa6a517994a316ec8a00c977ed2a3ad4bbd0971fcc1513331c592c2514eec4051e7c0eaf8b6050d39b8d0beee70bc0be16b551201695638b537a24469b10670333683a7d95a06e3426c6841a7ce8b5f4f8914886ad79517324ba8ec9dc1afe838c07e77d0924dad170d577835e4b12f9a347d0642ab36d792d906534cfcf277d58b95bad104a9610ed4f4ea750ad36e178ed94f3a812958fb17d5d52e8777b2ebb3f480dfc91c80473d8cfa8e01e6d955f45846af3cf18564599d3e985d39627c846e6a55e0310a3b86523890cbfe765176b3f5cd72a7ab9f38898377294abf65b7a7ffdbc11b0a189604b2c6dd33a31c629fa01244ca55b642f67a37a1d238de7370bfcb3c89c03c8fb2b09c45dc0012badaf447eaa85af38fd96a9a739d76dd119d89e6e2db9c510e832cc9b40bd80f986143d0b4c61d29153eb659e3ae9af1f08ac0b9a6ec49db44e9a0a91c3bc6e81f6bd9036dc1cb236c07a0722be670a4a7d79fb76ac2fe19ec16166212b08818cd552b16b50e6f1b18d3e2b977ac21693377162e83e2ed40fbd228428db3d422a421904178d037fc34d5f01c23b39dbc5c5a48ff5502ad2cdbf0e589ba9483b9692b840514b6da078016a14b4d106783d2ba442c050a462e595eb07a1086faa5aed756b64b40d3dc8667833689ad43e3fa3ba97edfbb7c041380f29c70023902a8d5c66653300635504be776f4dbed8230df9fb2ff4aec8f7d0aa06f8ba93f3398e37cded6ba68305f5c1ac0e3071abfe511e9f9087cd59ed41574d4b0a0a3ff3a5e4a537b5703779ad9d6d08f881ee5e343c96d4c2724fd2220f355bacba14b213e99ca350cbe87da99909e6cc744631eb67cff0b1c28415ee6de0aae65f97e7c5af60c98e998ddbe56a370c9f3cb3bc3ec112bdaa222f8a5e5bd43c00978b7118beae89ba245e470470644b8e28dac3caefbd1d9e90bc7bafbfcbdbd11022c8c0c3926372b8653ea990362c2e4ba29f15c2c12a9266d6269d7aa4e524a2d98b402e4b73adc73e6d319b40f408f0603498ca8c87de4c13b75668933804cdcb8791060bc1a023c7da0543a8405cc82cdb76454ef425936296881e6fab0a6802d5e43c4373323cd042d4d3564d375ed138a7232187ff7a0e80aeaa967554f12df9d284323a401d657c5f139036d649f2cfa67d1b275602f5c248fef32d71af35805023167a166e5a9be164ae820701e8f1fab32204bbfd5b61db9da037489f5538ab6f7b07818fca3106b2c1c2ed635249fa0727c630bf5387af9ccbb445a380ae34d653ebfafe29c7e1d2e6c9a7b4587dea9e36902a18b7c2544dba8c14ba17ccf9a2a10303d4a368e17f9819dceb09aeafd136d2e25b24cd82787f7029e8b5ffa9fed9d69247257c7ed7796187d3db5154a71c7201c08d4ce046c9c2e4a460b38cd2fdb93b4d61c0cad0deb4f3c61ddb50932ab23891a1555f8943a678361f61ea85e67901803d8a04cc042597734e73331be4c1287295af2e12c7a965999f5979d123cc4756dc4252bedd72f47c8366379e5f2d670e38aa783b4c1908bf788260bc810a27ace7a9c5052cb1da2d1ef80e25cbfb80be7768edb5515e1c32b0c9320db69ad17f3cd1f9d382e66e97996619c8da136caf2aa4ae04f430c80dfaee21cdbe8d493d94dfc890f0aa3b9c9c5baa4e8b1fed972bd899f791818f84d4a76dc49c959a26d238d0a1873934e6cb12847e275843e8a19e39250318319ca81e59f69d95e178776ce8ce21686a74c3b5c90d8a3170f823b3fffc3d93177ccd54592dd4cd26c39bd8f6a7bd3775b68fcb3f0849e4133a4bff84deab9b1869d339e4816c42e882e6f5cae7cec9af6eb89e5836815d26dbbde014d7e7d71f41c8f06bb8d805ac24f06a7d18e55c1a4d8e930dbacfafd18f144483c6cb370e5c0e85a0aa85c0bcb7d0b1a20e2d4f256afe39cd0612720856be7af17d8fb95bf5f13edc03941777191d68cbd2f12ecf9e45ed5aa3f7749bbf5b73257007fa3d9af9805606ac4fb796a8fc9ebd04adbafeaba5371054ba1b9d5232b549111d6ecae2cbad116d74ad964b9855ee050bf916606f6d59523ec90205f83fcc9e00849ee06cb6a049016a5d183dd79a8d84dee357afe10286c04972dfcc9cf47503c2653c6d75ded8b351809b006158e6d91d7b614caed04ad360caa49eae4438298469fd93e7d29c12a5d6936c9753f9be05f5eb2ad392202ffebb7348014e4f7aec9dde7694fa2dfcdef24ae4190108c923ef8213c5af70eca247e69e954b3ad72b4408974d8d950e28cf1205edc48d29b767a5dd4ba59ffa2611140376501eb511abe888ee34b8f6ca3a7098466dc8861865cd7061cfede0e9eabd1e6a290e33590a442713a5021a43c3b93d3007b7f849b91fcef6152bc658547b88e7d345eb1476dc246e119129ecc5f2875b0182c991ef5ffe539a705227bec9a6a8a482e8c19bb86325432aca8dd0c54f399e70e5a7ecb0fb52cea5507cb582f91a7d9c38859c17d0eb35212b9ffa8b644c022c647ba2b5b6c5bd8b4a3521d7c18fbf8de9d53f1857f9d7b109affc53092010fae4a1ee3f778542a96c5f6f9f2000863c91af7f77625997b015ac22eab157ac93e85126c9065a7562dfa98981418b5e17129ffea921799186f976df9631063c76877c78b0fed7a8bdf5d281aa92cec013595debb6937b753877b21bb177613e33485ed01839844704a373261386090536204c1119195b28eb8522862f06e9533a54361811a334d7b4e5e2273ddea7a4661c7c776b445cb6510a0e566b46ebbec01a9f79b4427b8f4ac1c4ce1e4a5b075490dc3b703ee5e950e80de2481de72a9be4916624bdd2524483dcdbca73fc9e167671f0e69c44c4f2fbb52af067791a89bbf54bbef2684963c86e7de046c40dfb3aa51aabac6a81fb5bb6095763640017cfc5c293921da7f1e7a903414eb6f4e0c753956cb97e465acfb01a2b4f66ab8975ee002f374e28bd6d68eec82af93d9710e4444ba89dd9fb495b0516c7cad7bb1c557920b63d6cd64b57ddaf6bfa437a2548e5c84d1272328178db02683fc8145f89dbae81e7341729005f3f7aa17aabc81d4c74f18bc3d05c162e0ccaa0bd40d18e62299431d1350ac43b72e88ca7aeb000cbb72c2e3bf776acca176a0b7300778c15bdde4395125ff1e903a1b1e83ec05d1e4c15aaf356089926fc08ad782aaed86ab286f500c7b5403210f6268062b282255f94e904b73a74c8f21360e445389abf65587557b5af238ad6514a54c47cefcf97d1facecfff488142f15d92db662fa400a4a9dfeea651d876975b5b7703f3044839ea7e3a85aef20b137a7155096abe16d51ac7482447c3bd9ad86f33c52f2625e7871c2ad5a24a1242cf0879ba5a52c221f0f549fa9ddc02f801036d09d5c81cf76c850cdc081bac87dab2190a03872efcaf844ab81539c3347efd8bbc9c46c882c6b4b0997730c6609fd776a700cb1d780dbcf81e97237c0b78733bc4a93e4a016ddd20f6a2ff278555a7381e3d50b8e4d50864faf89259790aa564b51c6eb9a8ac95f3fc321728eb0e4f65e9cfb134807aa3fbe5e10cc9d19634f6837f3dfd066a60d2849249b64495a4bd7b83be466d8d4152ef571d8ffdfc3811b7d3663d6ef0f2351ac31ca039e0c20a30bdc397644a2da9bbf5b14c5faa84d440fc966d246507a8123b1ffdbddefdb51d58822bccad2e0c03c405c2e76a62e998798541230ee3e045302f06da55ace4d9b64a06ea072b052992c276fcd72ddc1556b1834c6e9996543aed81fa8a08dc93fe1ae70b896d032a5031339c8cd31b1b72ca8bb4a0927ea55311070da7ceeb1d1dd490c9f51a2de24007211d0841c519b821ec3b30b8fc9e7a2ea31b31502e50b0d9aaf0da2d5ba7e38dfd354242684595ff1847c6783a54f2eafb9f55fc8ef09e55e0e76589d5dd3bd69587fa80da95fa9f118382e86c2f24643f9f7815d3146174473c714f11c63ff47210d2b0f5c93dd3a8b19b962743a3e8dbc75d9ecac20c9a587dc279bbc1828c181d85930a566fe05b6548fe6183e4a7d501363f2e7b39ea1f882effd53e16e7a120d802a13a7413bc5389f417604f1bddb356179eb20ad3d8cb7fe151c7e027932aaad2b88754e06b96fd1810e435e850ab9b51a865b6f4f911e139d20bf7e778a755d5fec6b485a762faac5beec1e8ab7d5810cfae855d579bd8c0305213808c27c66462b09518f887491dcae968943090b48d1ee01bd3a1d37164b89e9ca8826d75b356c5c0d703697540dd109f8413e0b22eec92605f5ed938f8d25dcba1baf3d0708cf9a77f6ae303f00ae5a47d2b358733b881b1408adee3efc46b1d71985e4bb2096bd819cd8c9c54be90e51a5035b71ec22b522ac756a11162a49ea0b3cdeccf82eb78549a62438e7010d73ab976a1cc9fdf191911dbf03bb025c14fb53da9d39fa87cea55034033c16c672feb2ef47d4d50ee800ad1fd83d586eb013efc656a7fd999b6a045fc9466b3b266ca1bbc39d9d06cfbdbfa1754b364d1e3ea1c932745c38d77252b6ce36faf621a2c136b14027bd2ade0634098a3c8958d70e138309d79f4f0ca1829dbe395cb09ba19271d4c112968551e4b1661d3f714846b5b3aa1e8b72ceb17b9f12c00331b8ffa718e734c9c435ee7f28dcccde99b81c4b6ae670de1bd7e6a398855da624163a4e577fb348a8b036976e7d756908a2bb7109e8ee5c30fb7a081fdcc52a10822552d6ccf2f53a3c9707d351b5adb79eafcdf1709cd24d7840945658bc8c8be3a931d69655f7248e0180d5429113b0283a4eb697fe8435920f55072a1f9a892ff504b940a9f10db7813ac2325214beb5b9f18a2615391bbdae1af6abfa1b41fe18b9e1360ee99438eba1bce595d1404b30fa8c5b21dba795b9e65b52760edd392f192c023be805e966ffd6bf9eadc016dae644929af14bdab8dac52f5e0b58b8ab447c17e73993aaefaeb2db95560500bf5dd69595188b3525c3d8e5791371ce33977e8ee764d130dd677bbfbb40aa0e0ec9afbf5fd0f34d8bfb780583f6b92250fe1dd9ad8a219d020eca2e528b08f33247f9ba4c8d972201cc0c6ba2f00e18f3c70e0abb9b028b1f6488dad4a5fcaa8f98353eb6599239672423301a24892341d4f2ca5d061cc18feff5ea9ef39ce5d7c12fd65e26dd0bf942d2759de96d8e7989053774e51408b03446997bc1ffad4fb00140ca0da10a88a728bdca357bce73278db87bf1c8715b1a20c555453a4a4ca05f1da4ba544cae528778f85a95d1afcad3f9a6f82a55510754f45aad92f16f1780601f7f779289fc6fe8125039fa6c8216e06b3227a0f49c532a6ab2001304172567601b4e3c36d67fdd9965b69550533e8ca4aea38cd69268380c61e18b18be2b53ae926575929bbc29a65f58f93d3a7c1f79cf03271b03684436375c5ce3115a93a2c7c30129b1ce3276c3b821eee136256e8e4772ca998e3596ac5a80e257cb9253d15fbe23b1cedc992be10f8b25ab34ea491ee27822dfaab851520f4a4e8f230a4a5ea21694361594951f57f49c694a9b2bef8881cff18b18bd2ac5e111347f14ec656bb1f2b98049f7aaec61b535ab10b8efeda1535c6ba6c8f2f9952973bf63763b85e78f48db0e13871cf5872bedfb47852efef928665b913bfdd61b8a830c669a0bfb26abb020f1596aac05bae7c1d633ce1abe2a3c5759bf94dd2dd7aa7efd3c9557f46b6eb791f3671a1ba9625bf7a2b6eedabe16a06970ac4c25e8bf039969e1bfc9659eed18c7ae53a7e58b1845afce4b81b52dd2890b40ead3d767c511df39147efce777b49e8f80ed52ebb13b7b0358b57be344310ba89c10b01f9e9efddacd4a825a55641fe5437070953b94f502322e8af621d8c92abc09e1e1a1dbaec1b8137b4cb5e317b6895edfc21eea83b5e61d5db2581f401c2306332aeddd4f8fbab1c55a32b9b06bc6a2b6f0a8c57cae6c9010bcc2e76ab9aa85ffc26a0f90b3fd14b3d79630f31133afcc423dcec5a67832a1fea0389ac02ab3df1f8dd200479dee1b749becce9db36b017593c840bf1add83c96aca1b3f3dd445717d833fc3df031b64e0796cb491cde06ce698d7d456f799af4a441c6b7493f9c7e38c35a5bdd392aa8bd830acfa036b06f50fd71c213d8203dc13bdb9c42990d20825c22a2188f91b7e925efdf4db5ffa1d57eb723389cb1c041c2017e94842bec111ef01f6c49394cff824fa70cba889e4ffb187c39b0f546a3c52cb84b97d0f7c0ae5c896fd94d802a32fb96c688c097bf19bfe742569891a83cdd40348d08c80fcf4f28ff4698599d8e43a272bee7fe86b5879a63752c9bdc864dded28987b604ca43d1be9e0b8503da1000681f1a3e9df5d08925793345291f93c78f0e471484b75950a0a01d80abb0afdd74d0766e34e41d102d99bcb0c69140d23c896814dcdc0ccd06195c8dc601ea435493325d07645b6eadfa6232b4b8f432fe38d43df3fcb2bb1508f5c75db296bc9548e541f042f80e221e31babf723b8b0b2f851b9a47c8741ecaa1943e28a66f1f3b71529453b9f74f5159b1438c53b2c65d63fd834597f3333d761ba260e182b831d46f19c0e504d64caf4bb8918277abdcab18f84806b7ca501f0435d9e9e38d45d3b1672b908bc0cbd6063663dbeec9c409ced7508bf2f265934278f383b1bfd5636d690b7e9d9d296872df8b3d96b55a5b3802449755690c75f8b67aa08df2905766195b1b2e51fcc3c56de9079cb3b3eeab8dbb27b6fc7a9a6e1b1efcb1920548b81476bb72efbbf9d2ba26af087e8c10a2adf9abb289fb3fa90438433e3fc08c1022978dd2208ea8200552b032bc66a878c748f0601f56d75296dc46df4c3d367225d5f717c7bd77f6f6fbb93eccfcbd41143d2d8fc788ef4bab141ac82d8e15d8ad074d74538d49b4d06349f8fe276d7106aa7d72100917ca0961481888cdd38a0ec7c26913d8713faf2ae24203c2ecaf321306092118bf2c560bf0d469bad651f32a539afcff98b07c04b3258579adea9e90c08cf30ce333e2d265f122a09fec61f9e6e3343d83fce45a9b6d2869bdffe0e60107a1342e1874d713761bf72bef23b79a4c47655c1f3b256fb391f9293c1c53e35c586cef99efc6bbe2d2cc7e0a7b96c3ef9798d9ebc9265f94be7a449027af58c4786f6c884acac1d97dce0f0ca58242902a49571f542976e0cec912edbe0561951eed20dbcae0050c56eb4b6725f7c05f79f9808fcf2e7f4f386498e327a2160d82bd5f09183426b03fa6ced717e0b98a021777ba4ed5fd5544931dd0213e57236e6c8bd73f0339778f1b85ed8fec5477ca30370cee7eaefd4c8714aa124d6951dbaaecde351bd2f8908e8c4c433addb4a438d625225c7803b9ddd2b8100af37f0001949dde17ad7d57146e83d0b8854d6cad940131e1bb49ae7d1ff90df429c830457466ee5227a6c0d6f93057edd2c91979193b0a4eb7baf7af147bd23b60afb608c916b5b5877692c2380521ed97891f6f6a3763ad4abf28ef0c10c3487e7d8a21da8dba80caed3e6bad179af123983e8731b85a994494bdb8d693d363ac6a846e08622c7e0e1e116292d3e894fbf219c8e2b83fc6e973074736946e42cadbb1cd0a6276c4668100aad8592c4a26abb0d9d2b2a86d0e0ea9eea56a565dbe24f28785ce38aa8002a87917f7afcd43a283abe2870f7d9eea5467df1ffc6ac560cc2d3d6e04bd971008ec51ca3ae4c2b1079b78e71bf02e0598e06688f1b4b8826352b17e3a8c236508d97b77892fbe71d30a7937a93f9be8c5fe48299c48889bb57cffddd7d46be8d8d0784436221af79560513f874744b7f097f39cc8b9e72de51520c5654357407b02d52d28e7c9a3a41c6edc8dca30d1f8efff9e1997256c0dbed0167fb39f1e9b587b329560c032dd54260f8046ccb6a923c67a625ef848065f7d5b826d2ae188fd8db94e3e35614f1970e5e050b6af30d611acecab3ded5ab6925c1a0b4c267cfa7fbec633fbe9dbb052473788368dea44a8134fe04eb43ddeba4b8cf5b6184ab0bb4b0b250b0160a24aaed0a00c840e27c8ba48fa6c3fb3ca6edb1e5088e14c7e44e6ca8caf8c85d57a1bbb0854ab5ba18d50732ffa9fb132d9f3198f8b3a22a98494a07548c87ff83115239bf6611fab152250e8f7800deedca0d03d0dc6d69d950dcbad293d92173da9e45c0aef38f2f931d2e5e73a603dbca60bbf0f897f9fcbbb036f8bdf9a8a01fa6ef974d3974469a1afd8404549d362471331be4094b09b5a5e644181285a711e7a034bc180caf4003911cc88f08b8de0dd30be3500bef219e75b018f468df137c2f9db33cdc289c8291120e53854a66c304740635db3aceb38f3168f2b68909bb25481a8c51189748a555021244355a608153d0a91463e3e2ca9c276ee397de2daa610fea28865918991963047d5734ab0ace27c2a2048cb91e0317c6c63b4742bc0d4b12ce670fa3663aaec31f05eb5c0672e5c46fb8cbc8fd9ef0cbb9bdcc921ed9aa85f1fa9cafe4c7f57a094bf60ee98869a6fc37dff8e939819766911c96b2491656e23b77ddf1efbf1d37610c713c9453f3ecd468140ef75a8c2ab51aca80f0bbc0a5da8d0fb06a39934bed1620bbfd19e1dc3c6d2c8fa1512e533bee15436990ab8a4bee93c95d5869f3526b3170ab935cd191f7c71eab818556c72ad701a9134f7fa2b9d82c40686af8bc746946af139f910e4814bb274d0f2da9d6e59de5d571536c43f971388c3f6d51d4c5195beb1831def1c3d59f20a176b4c35af6a11b56c0a4059eec3eb13b7d9c2e1158f3a8e1f102cdec535d32ac1acb7d62b23ff17129146ef4310663e9e8e9f249576141e8d70bec3ae11b113a869a298c02365569fdde4cdee5e751b8e92e78632e729261130efaab877f0a0a503e6bceae50d081d1d84ef07307e04aaa6bbc53f8a7863a38058c9241542914ca0a1444190489d078171fec15453af46d27fbf432f783ba14291f0b4227882ca711b8130b6d09d9cc0a3ac90d477a96c5d6162cdbf18608ff9ebbf689ad4323cdc216e0f525840fbb839187e270aa7d75d202d8a3fd028d78e600f49f8ad4e3a24d64c723a753366a36d91ed2c1574ce9071940914101455f8b89daaa41ff12ff34deb141c3133efbbf80b1d178c33e0e2dd107da51810a6dd149fdb39982ab4841a0a9d176536598754535a3c4a16ef0d03b91d79ed0f094d85d735f1763e70dabb82d00a3bc4a1b7d0284d2e9c7c3415f87e593918b8bd3ac178106fb79042f38bb5576c488472e99476a13e1b130b19e71a703dd2a2e317d822855857e4f1f2ed258d8457b7bbfc4c92fda20641eac162b426ad6548b48e6596d01bea017a8806c3a8d86c7783cc53fdc306cc6a67b1f3280c70bc5825a978ecbbb5d10ab2736351f19b8b0c747d27c21cc0fb207f3b7250350542b495c45592423cd4adc1890314cffa99839a814745bb1b0b82fc91fef9c484151556a488bce9a7b4aace53ee617c53d0b17208b0b19f5a9aadb0a131091501e29558e13889591c1cb1a535164ff37b735aec8f93e816961068f5ed10630cbc9ab7234bd67807dde038e49ddfa0fbd65a254fd03569f83f14f55fca2ef86039beb7a4bb5ea250e46a0d20ceac67ba10c628d44e138f4355eea55d2a1b90914279b3d13180fcf908e80602cbfe88f3d311cf9a9b08c44c3907fced5b143dbcec9e50e6b0bb108fbc11730e77bf62ad02a5ac0cabb3217f7ae246f1c50f06018ec73789ccdaaf21e3f3b89e9ac1e9f97ae9641b4af81d0e5b0cb51650e5189d3447aad3639e7316d06c7ea7ca97c2a7f3af096ba6cdea63f07794bc672d7574ea6b04efb729c877dfba80f93e8d09aefbac12a608c176e53a3f61e04bb4a8c8bfcbc33a564205177680f77ede05783e4c312ae15c6b1d9a1d1cf4e2f9f53f0c492cc440ceebb488f57cb10b99dafe790716fdf4909d46d7b42bae0b0af428e28c64d78a6a0974c28df82fc37557cf69323c368a25a00362897203bac4fa3ace978668ef1a5a9fdff546c0a0da9f00653560f35788cce7da3aac34e01558ab8255469e6342459d80fc75d080729a4cae2a63c4bdff777e82e930da798e8101c54c4af4a736929b4a3d32b7efdd555ead194547abe48c2d9a0ec71c2d1ed0c6a41e780912650b20bb9310990c59dbcf844c5870e599a8745bd841a9a626384efb427ee1b66ab57aa65872259b032ecfa66408fd5fcae7c3e3166351e7564920fd521081570247cd01db2a8ce659c852be68b980d685306a9135d518e5c5234bc2f98bbd5efe6004e0f6d811fbcf580aa0dc2fbb91745eb028c5385be992da2cb628e5180f0a8621fb19e3779aebcf059289b630f399a8bcb2f106e56a1b9e0655e694ed1e2e92e34d2441557899909f7705768c29ec37d79af7114e9f42e18ad7f2051917dacf6776b3814e746ecaed00484a98997f2fbc56247ffdcce6bccb7f3be43a88b55c72c3dde674c94adf6337db16ef320f3a8eb20a6cba7c872d5af7a1aeced33b3f2489ebd49c016b970f560802cb4806023d0597b6292cecc9901c0b29420fe0f972859aee363b80d6eaf671692dae45cdc92f6ae35ecf4a1b7f8838d5722e96bc73ff86de1fb2754483ae681d5d4e2a6d0dd095c10a0fcb4b5afbbd87f901e3c9bc4558f90ed107cc7f89d6839fa03b61507cbed975eeeb3d1ccc3b70164d30f47bed85532974014bd723773dc061c0122717b189e47dd64d282ba07e0c4ab89562178354b1dc61d2e065171c9e9d85d85ce3d6fe1e8eeafe7b2ada3d143385a6c48a89908a9366edf18640f5a08a77a7eebf350fb88344b9358836ac7d8cfa79cd85b7034d429cd226b252d4b1c06b504e8da7abea85705b592742c332c32bca19f69ad5e141ff351c11770c1a493c19aeaebcd6f6de31124512ab2b031efeb93c776833cd176d828f563d71fdbc5afe8540fc8f41ba5786611681fda2513f9057bcc615d524d1cf35400b28b87925488b9ded1a55b5f18035679e4bb4550c2171733f05814d83d07777dc230b613c63119c43bc85fd077406deae6e8d307e1ff277677811a521f21ca8d8804bf39cf231c09d531e0015bdb45af81f7b56ab8cc68a03aa4e7a2968925437b948d8ae44c1fe5a7a7311bc18d62242b529d7ab8f1c5d918e53fb48d0a3a686b8c8db0a4c840c1b606620df025d8b8f6abb4afa113918385967f51ead5028d762261e328e1eff5857a020b698fb22848468e0c6e0574d53941f3027e06afe506333ab44ea84b1fdaf0aab1f15e20418998fad8eceaf300a6bd601e160c2c1d71ed5d9fec5724f34f5f0a405dc6f23237632a84508f890d55f6c5b6aac7f03a54734d549eaa5cacd2d0452872ca4784f184a9bacf45b7df7f315104c4446bb7508e52494646108aafe039fd0db701074b54f34738cb01b2a6374100a2f03a8e111f21c6f9743c03d11b4a30945d3658ae10cdc1b250971cce8aac50277c68b39ff89d069ea41b5b69493ceab416b75a6cc06242372b672a71be073b5f72ec4164a831baf4932bd7b17f7074c699711834ba9aed2100980ad5a849d550677c2d6325a300a46890dc151eb0eb6521dc2ab87da278602fdc2450c19bbc5f91c88590a0b4cdf6621c4d3dcae2e002bb8e2e15f7c640b6328fe83521ca86a469c4bfd6427b84ddb2fa0e919aa094e4e3a90b37d70ba35e9a61c8e346c47843937ce8e1000a3f7f75e5e4a1b25a9ec48f6f6d937d6a4cc92cdadf56b095e30b6f3a227cd5a9cbb0ded6e867be27b851647536eb03e55bb04d8158ea43c78f0e565256303dc23ceedb58f0aaa1ca29c43b62db5e13160024afc122db124f48dca99b081c14c7cd305943b98194aaaf4d4eb41361f7791db880bb00a96e6b229f2d2fcd3029fd1d41e5c2d8ddc1b536f06954fb1c4c93e3cda516bb81ef170735e10e8041fc2c6378f313a7b7aee6986434924817b8a0ad201f7b9ae11dab894bfd1311eda137c82fd19e7d1bcc017c9343cf2b2eb7657da227828a4d52cd82068f862c99c60941f8e56e17fb556093a0f6d896d0b4f4ae33d20575ecd6def679f384093a590b34cc5f964976d8d9560ea71c04ecd28666747fde006a985109d95db20f728f97e2ffae58e43324a6cb081a50b25065c13133f40fb5639e2ad24d82695bf19729d01d0e0fb2eca71daf760780fe1454dac2867b5c51f123378b6bf0ba1fac661866c3580361226ee8dd2a334bfeca267151f33d00b47c87edc640a20caad1f993d8ec45e243644f2374971376166e7dfd2c068cdd92a4aabf7372699e9d81436d811dfaa972eb8f096e0f42e455bea214c93459a5eadc5075220f9e6800ec99ecb9cb94f79007d4312e7d577a3bc252cc130dd13fb6548584d2fa44498a7a199df315e2b47aba7e7d4ff3df21b5373e24f7b3b25cf525c303302a27bdfbe0bcfff57e9e175bb45c09429fa6177902eb6ee941c038ccb29efe669ab15bf6f56eaa7f8a7ef025aff77c0c2b917f7f71ca7ec9e71a2d106ed12ea1ee65ad2d27750bcefb6c879cd4f3eb8096171d86061dbd93482158650909065bca199c5b4029fdc09f3d94bfb576ad2cd9067b5445aea8aede3b9b2c1ade55e427b05d8b309b641e0fa3ea3e423bee08c68f78a5d86aa343f4646b2157e4cf6e0596e9fbb35f931bcd1bbd1f924985a7ebbea02bb1c3b4b472f7705b2391731d0160de52c7a7310302b3d29ac4679e6766cef84566ae766d025596c40078d339ce9aa3f733d20f5954f4c465c99f3c0d0a29ee7e48af911d9455c0bf2062fb63bb34ce7313229aa4e620e232aa491ce41ae1f2338b28ddf6129a352d130cb75c3f826b80c12709d4b5b4f143fbb33a1f20442bfdbde8b49d1343257c86aa6408b618d2d61fa9b4d64d7ab7226487cfb630f84ff29198c463c618c63f6aa33937e3333744e058a381a32f1505d5d551ca8bdc0a32215d6d485976f2c124446d10f65124f2ad8b9a63aeddf98e4b6ed5e31f168b8df3d760dbb3713d4fc55c8bd72ce4ac0d57977147a578ba1d908daecb01389aba19c2ec7f23de2a19738005734f38dbbf1051eff4e48b99f82f2c46fcc1a7d288bf48ed11bb773e9603e69f6475992c5db54256001770273760ba7f16b5033fb98ad3c2b348092c76ec875e069f8a2fc572ce500e6490318c5dad12ffdce670652211dc3a6c37f9d8d5421cb2c071edb148db04295051ac86ab619a44591df41cd9a9085bdc421c277062d5b80440051b5d6470d0cbd54e6787f9b233a614b753213149298a14c70cd3aa50207e20076e25d13b54bf61389a384a12f1d34994d09621bed11fcf25ab50977eb1bba11bea62099c737d962cf793e40b196a8a899c25793f5e6169cdd7985d2ba0673ea8c2fa87b99fe9b5c16ee066fa211fc9df8b8ddf21cfc5f79b9d24270d691fccecae00ffb069c6debbcc8b3dde80f0cfd41447aca2c075426ccdafd98bc9ffde53751cc5df4bebe93a44e1161a286d2c24cacebb7ad960b297fa2b3c0bad6da3df9afd95f3ce862b3524e0ee88185cd26e9a771ab6166ddfe0404a7b861431b51ac1dc175758c7b8292f4b073df626ec032a4b0c83aafa6addaa4341717dc867a8c701d57e0492f2f90e7444a234f2593e682ddb5f1362f7ae80db5af1dd53211d02ed5d01325f713cf8b7a044f281e8efdcb264393caf156e328c99d1d88390000afa01f876e0978ea77c357c060c12d991e5890b1c67e1e9ac16a146da83f068e13250a5a759ce05d7e468e320532d4137cf23ce16412ba5f50b299068f6e0a6212f7e1f4e3c18e9b014767b39dad356bfd5e66534ea65e5023a468bc553c6bc33a2a58d702f61d45a6eabf3ba649462d01482bb3da17c7617deaec88ab445e5292365caf16c0ab221a34ed8f4ce85060ce3b003e52e5f9710abd12f7eb335c6effcb29f87deda08201dfda92c41c23278e8b5933d2cce6477b6e03c86f1594b1a13bb407f66900f3fef20c004e79ffdac4fb21c748b64200db8511fd882d98a75da92aad0840c7ffc3e4d54dd4f68c21ba0225a92ff17e491fbe6a35464a4ddf89797c7595a0d31fea44caa52b165d9ec1411a227a7df2bb019b8c4d7169bebba3e087677de096ad60f248646cc7f92c191fff40fb7cb5a7a59b99f3667d8a01dc9e1218dab34c7c8f2f24764703304f98d13f7d79a0329be45992d7633bf42be69900729cb25c2b730e34a3340df50c6ac75ecdd7b7e7856007174eec4059fda60a468f44700e8e573e4e9020b2237b904bdbcf3ffca185fbe743a39b1a20a0dc15d24593764fc5644c30955af7efc8c91bf92174642de16ea5258a470e5eba914bea8e607bc809bf418bc85bac06dcc7d47b297cfa93abcb8b3bc5ce94c63ea0d48b1e260e106d3602ac7150a0821709fb11fec51530bf46ef3de60f9052243d61cba28781717f2c963363d135b591bee26ebb4cbc241e8e5d61d805b83bbd9fb2a32dce77dcf5760519fe99d432eb00e18585c712b315ff993c6bbb07bae8b8ca2b0e5dde0467ecab2476be61de9b6fd2dd69640bc0c8c6ca3efc978468d047e2865bba81c5eb947ad7ad58ea70d928520b252df6e5c5ae2bb005636b949c82e915a734fc97f93eb9340997307c2f190702ec8354abff94057997dd24499e5a8da30ed80095a949742c17848a465d400060f680d1dc21a1d0b61d586d87df323c640edbb5b32f03e63d15ff76b90099fe8fe71813e602fa0b38d1d9ce268b19f9e0c1b41eedbccca94c52077f9854b0ea642faa531692d7a159421e30f6bb27f92fc1e1e2bd025674966c6031311d1631e5b2399b9fca29cc52245c424f5379ffa0f34444c040687270abdd5dd4bbc3624185f8604e88403e3b47e06e940b0e56d3963e91f65efe0eab09c91fdbb1d4d4ad6179e98113cde0a1dfc9c6308a558bdba6cb73d817a581fd23f05b1bf73f0cf9cbea7d0cc9a39e4a99bbd511dc4618ca748bcf61c5d263991bf10b0e248eff65122f1e90d3607dc40e2fe2f858203e5ab195aefdac19089d0b40ef58f4dfd17dbc8dd7cd8e3da6c41afd5936361de56779046587b9b8f2bcdc33ebcca31e908d5f95c59bd5361075e1e7e6cc1c5a0e680e5cee4bad1fe0066c8d9ca629694d4dd32bb75fb246873b41f04feb62be3025a2cedbe74200ce88e2ac8c739d0267f374d35bc35661ca2c4c9161df0baa052ae857f9356c7a07d2bcc2bd7ea677cf0db869d9ddb56c2f0db806ca228094f5545acd5029baf79eccff767f89eed35a9a89eb77c72c120515640e39aeaca92e3b8458799d45362d1aeef963f2248c084e14797a227ffedfbea69d21470fa1ba4c773a243193002940bb4c4e235e536aac19211ade05a25edb72691159c8e1b903e4b53b9d75f3e1fc49ba274f6f5646ff2740f394891b2767d6385617f012e31f301b4693940bdcc8b0342016900e0269e3f4c9e6333af8e17e877a516f9494b149a4a7a83d1f8952ab8b0063220ba22da5e8569e9aeb7897c02d540f29fbdf1878669729d1bd237dca149a41fbef30c1e54e226080df28d51a48a22ec1809002df3c392e8bcfc217d4dd85a12e33ea523706ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
