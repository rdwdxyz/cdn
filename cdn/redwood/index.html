<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"793311fd9eaeb333175a9ca2b3eda5174e21100aec5c40de06e8a3fc6e89b3f6cab7f3631e1a67b3b6478dd360964ce2b638e882942077acd595be1887b5fabc2d4d6e99c2e69ea12e0b58b86ee6282d46f1e26cac5877d8eec41b90dbaa1eed1a9becd0738f401ad0522b9d83489e7f76ff8f723810bac99b8fb26d5c8347369f3b2d7a23ab501214ad88f0947477166c544a6e4264a4dd3f5264a142fbc2058a1d4b5c0e2ee55060e4ccec62c94170a46575f11ab8c461104d50925b7478537117e9ab761ae2719feccfefa6d454335b50a957103ca3456f5ad50b91b2470f7feff5f27de76caa97e7a47ce85e2aedd8bb030f6a6a551a5e4ec2bde0c621a88ec7413fe1cfa19040e5b6b68fbe8c41c659ffb0f471b23b61beeab0b8adef44f2cae503beb839b21e92a46c648211d903042664b8e7bd9ef247b5e2c470392c458922a4d4a3cf3cea9c62c158002ec23cc1258503f8a7e51cb5832f700f56e55c41a7dcbb9732c3bdf98922d5e7d60d12fbf7e2256c20d2c94277621c06849306753135f96d53deab893f7de125761c766012fe748a45f6bc9bdbe50e05236f5bf9784cced76940a6e1fff7a871afc6503167bffad018d238b8f28f44a2330e82ca640c4a8d4900b5e7c2019b7542632b2e8ff213e1cde1fa81d394efa3c3fa16022c444fe08d5d9128680184fd77fdbb76c36bddcff42640a5e35824a2290230d66767c9afca3f30e387209fd9f0f1ce8982930a8087100f978781ad5117b03c7e21ced4c4617191442c01519aa48cf0e25990aa3adad6be384cefbc9d2160e7a8344d418d11f76d4ed34bbf17cb9ed7fdfc929c04e03842ffccf6b40a1fef3462c6dbaae18fd39b50e2733c1ce5685923a93cd4d8089c31b0377795d894d34759988d51e36f29a3f94afa3e82c57d56aad008de6630bf33ac5aae5c23d71b643d73ead200422a801aaf9396ac99f95dfeb8e12d24d6d3a8c64e6c1df78aa19dc5326c96707742cbdfe06be0af05463c6c1ec3e1c1e09782044412063a54d1cddef7f4ae016e8b970796996d8473846d59a38c5ff7cbcbae089e219fc67ced8d3ab222970ffd5601d198a020b0394d7b4fbf5924eb6bdc5dbbf224d851801b96b311ef6bd9bbff05feecfb878c499ff5a6395343a48c67888e8130ca52eb86e273baceefbed48f37eff0a9fe3ba816300f35f82f215d584e12f6b19ba5219da3c9afa8af57de7a4ca6db40ff3c24391f01661e4b52261f2446e477fd264aaa0d22f21e1266e430c701cf8f60d5304a99c05c1e2074e4adcb13ff924a491ec49ae61b5244e1246db43ecc5dad54eb0a56f1472bdc78b7f010698305ccab3a69220fe38d5d4f31f4adf457ec7bf3920c0f6fbbae5444e22322c7c5b90469e49b225c4198214e78bcf0b3a72d0716073e90e1a7a18bc9fba85615fbd7d59694e6ea7224ddb7ce4ab00643b092c452474f6ee84f35d138b4bdb044e1f466c1dfeb08d4bab0cb5d67a1ca48e9fabb548e89f830f81574afd8cf578ccadb90ce9003bc0357d3d075610492f1bad42b533fdb85bbb5942beeea0c58b12f8bab950732e2af8776b27dfa611545511ffd888252be83486d65677833dcd128eafb3bcf5f673bbde694e9fd900fcb31d843d359be68405542b60fd64a7710d3aa4379dcd58542c4c9f05f081bb61a5146463b5f404a1c5db553114fac8a9b39f42b9c384dccd3667851afb7d9926504092f085e170815e0d4cb943981abfbdc7b45564cc87d6380d058c03102d4b973f8de0520c42cd080c5bb4838a5b93c12a4f10b6441d514240f06f8a006a06c786425d763e7d6ecdb01a9d48e27cbd971382a1c505a4d5c9f0a969b1f02dc44cf8d18517b74199ea298d5a2d8148eb3a595e4a05979c704f1d36dd89dfd586b7bde849d71ebf3243d27901240b8e25f34f57bd81de52c4ccf278cd44fbca2667bb1553595555bef63ee50f5ea9ac3e152f7e413dd76c078200265e2aa05c48e67ed0d54ab4aeda4ea767c50d00e5938afa1623b375c5bec72f13f2d6f9d8a2e232de3047dd8a845c101e8bf735741afe9c324419ccbeb3bbfd4575ee916bccf0150841bab9d7e044f00eb24a5f06344d57724697f81c2b198a1d10c0dff370a509e10593c511dcad1e46de90a8176caa14c0a1c4fd6049d2cb2fb74e914262272f546fecc8d22dfe90dda1b37654aedf731ece9654c6d1e51eedcce511f3234c38f12225a9c640df39ce51000a695c018fd5fdbeaf5381c6e2dc835f20172d7470894d9c821dddb89a170889ade589be05133c80e2d0ef82e8d90cfd2a7f1125c236ad9611a598f355fa92a5af3181cd7d1ec102c1569772491c3d3490e564e1cc5f3b01a33f31adcc555caf6067be71349f2e593a9bea5af6e5896a5a89393ed48bd82d3bebcc44567605b56cf8bb9a88c1b4e78a8e0853f9fbbab453d47b8cd37da5084416939d1a6eae55b7931963d65590a58bf24ac7f72a94ff61ac70a161283209ef1db3abee6a9a5bbf1404ec6da6843f5f0bbbf2ffeda545321534948e3b69f33208e5ba1c9424175382734e32585fc6f1f63deeba4a3cbe728f558bc37a8bed6d6b8aa529063b3060d2096a69e3c1c4990cc6238665f01a2a251708247645a7ae2a844ce22009be89314b2ba0f0e84e21c98f8884bc530e218214c43fbcff13e5d3496d7efa987909dc163a8762c70f4afa784a37b4b3bdaf1b2a1845f73aaa02968cc460217d89a547ddb1b90af5b229f5500dd1b648ec8df15dd1bd10bc267e8021949261caf3ab63b05d4dba9139df9c9ee91a9f8a67c6c7769f1ef9d84aeae426d18b0870b637fd0dc20c47bc094bcafef29c47ea7372617ce238f8775b305f9cdd9d04056a11919cd6aac04ecaee43c61e22d137ba732e8f23236da3c3dd321bf28a39a270e8ccf064f0c5211f6af656147527b4f7f4fc24242d992b040e39f74bbb95c33fc40f1c8928718e70f4b44cffcdef2e59d3a5e0ac75c81de1180d8d483c6a40a48eea6d9cba54f65ca3000109ae145a882f333830d9c49186719ea7649564f30adc6b6633fd307af94737512176a0e81c7f44a424340b31d1bb7210d5210ba4b463238cb009b0cd2fbf66303e0b2b0cb9ad876a57a44713216ce8ade2707134032f4aa087fb51f37b781d59c7f55806e8b92820786e26658422a25cf4ad4a1160058ae6784a97e4952290144a3c0dfe41af5f74269a6adf963271b3beb728d6f1a7edf02cd6292272f79b6423375162a36a1b9f49f5d5daf8049614b16239c9d057e68828c1a4aa3082f05bb6dbd65330a912b2ddea2f3878727863d7dc729c7256b432a51bbf10f4a2dd82bff0a5b1e8430976b12df84e97f261aebaecf6433cfea0ba3bbf7e510b4d6d30cb8e197f576a10f4657c7719eb40a4d5ba27cc91752826a66a96ccd5ec1e3b3cbc95b425c1e81f3aa13dc8cb8c670db51f66d6e36efdc5beb9d15a2d30e9b71a347ea457806ed8242846d0fbd8b8a7ee7f376dfefa3039ab98fe87f44c99811418996909b4901db0ce7ba738e9d319aeb355f28b71116d2e78112345b7e2c7aa2a38b9e2e9ed5dfab3d7c5e6513a872ae1303cfed4784a6b5a9c2f3676cec72a110d3bc6059894a44c4b2b14897ed4913763ed68c3f048523cc90a12c9187a5c4161dc3b8c6d16511d297c1c4bc74835e8a849cee3f7ab5959147d4b12c61f92fd52849f86cc7a34fa2b3e305075b40739cf32815fabc87243c0eb75f1d9b2eb5f8016b68e5d573378bf2affa1eba576b2f1e48fb2068a648d71e8d8ad408340f4af2f8ebf38f27bdc1b95dc10d6a9855d3abe5e74a761981dceebb8ddd02e4074f71b2be31fa6397e941e6762a27a825f82d5667fd47e608a5f2efe0360fd397bc68770a4fc15b3903556fc77d64c80d4ff8c09558831ef406947fa32fd1e131ac8601af72b9c4aab58f10dfb347e319791078abb5a42f76aa1d91517cf811fbbff479b6ba4493994bff925939110548007aab82a06dd8080827a54a2a76a68e0685497f85e662d3af0788bf1283179572b482e0f47d94adf8b6e7176b37327cac9df053f90afbc9953d9cfa1ef80988c9467fc763b845ce4d08a2dff83521fcde5369df27bd033399e6ff0ebea9f6d38f807f7583e624aaf34ffc53377cd65686ddc4a5545e96b026a4977e560d49df2168cc878dc5d7ca57c8af1d0581bc6823c9f180614ce5c92f47df16d24c0b95df458e0f185ea72aab40b45183279b5d1ee8dc624922effda96ce5170226782a1ad68dd58f96d2f00b76eb5003c598a41948153b09e21e53ba9a71d6f508484b54c8a37d372a3fd5e2a1726b9efdfb95e7c7909dcf33bab9cddba03e02209367e369b738a54fe8b575d33b9d735ada232f140a5c2343db27e709cb635e12eea7507faa499ab519b5a402d0b399f696d1f86076c1d181eb05424f386a6f92039e4d92ad35f0cf2bb352dd181f7b417812da8ac05e24737184ec7c4ac55794406cf39366bb6aa50308664707be90ddc22ac20fa7cc29543fa68fc6e553de890983dec1668cc86f119738093dd6cb6d1f271d2b9984bc76f4691153c29ea565a56b8874056af3ceb32fa07a0a07da1a3851f152d7c162cd1d5c64545b481a6c9bb3474db92fab3d17652c310993ffad90b9d5dfb61bf909da0d0fd13413eae05d10538226941aa8bd5558fcd0685229c0272c242535062f51e1b7eb5afb0df413d58fbb76f0405537f25df1d5261019f98f41bbb32e7cefcac10785387818c3a34861e03546791f8b08ceca67b82bda3c208ffab135cb795c5e2df512d9b12234f72ccca4bbebc03ac0b29c8c16096e4b94d281f50793947d8432c8e0192f0a8464b5bfa8dc3805621cab85fce5b726e282c2b009e581150cabbb3789e06e12ad1fc1246e35599f0ec443a60e9966ab41770da6643c67cf07248a39f982d234b756133f37a7adb8dcc4a5933dc12ef3d135fb906f397ecbb0b06c439ef365ac4011e9811571e3f14f5c7c67b399fc0b8e2b3ba84fee5eb918e70f09fda4b7cd10137e47a384dc67eb7f35e36a20751c74b868ae364e90fe69a76774b95bfa1033a22e25f5b5c6ed7ef388827fe3c8f09e71c8aab4ff02cc57342c3cb71a862d54bed18fd9c4c3ec4f7701f4b7b43784552cdd7a3b06c803cbe2ea9b764d7bf529e50dc0677304023284cb19ec9eb542df754fdbbd1d7a748b5596b6c7526c3b80b96068509658a51394b8150e0ebadd5c5592fae4ca7ca47e2e2161df0a89272bff0f15126c3bf843a166ab558e20835f23a411e4b996df7d30322de3f0d6834e98fafac1ada625ce529b3ee79ad4abac22be00976a126682a85c3789afad9ea6a29dffde1732e82256ba27cd7815f5651f1edd1f721ba7352e86c2afca1930267cb630229ca7c5f6a3bf66f93169f37054ea6b1fe92a876851bf2213ea11e0010a3826ff53dae377d46f0d683b5222d17794ec8c8f0353a2019834f982f1e9bf6fa153887dec9b956c517790ea0bd2701e5d124c8c79b5d10a7472bf9e450937e6dbd8fc95d0feda4210b66bd34a4c7663d3b4b7f54e7a3da37c217ba60d50f4b6d5f603f04bdd383fa1e052fffd812116534dbc00a38a50c9268554e936cb7fd0353c2b3b5aae42bc485ea82232aca2c331199f3828c299d803fc59d7205df8ff6bd4afd6bdd3905b1aeb9f5a36edcf6de2503eb8ba38c407b84bb10c13e24b6151155cadba58fbefd6616c05e93418bbbafe87c8b1797fd6c7e1d0ea1810747d500aa70224994206faeec5ce367f1a3c819ee7252e04d3a63c1bd585d25805fc0decdf614b923385ee96ad122c2f9a2391621a4537c69d323649f568c79c12c570b3fadfbb3ca2a4dbe5e9135affabdc1903e6d05cd734ce4267d745d0cef15d91576dde67a200253f85566af6a504fb5b4d8f39637ffe68a4b2caec331d1f3fee6aefb5092083bdfae0458bef54895d3b8aeed6c9c53c2604a954ee89d572e921eafa641b2928b537dd9c720600e44742f73ceb6786716c39afabbc74168a01e1dad138c118e5a30669f8f86aac0883673960c6649e6f3d7b8da891366f372e35b5803d5152d1b33c7783752944fcfc0ec4a7a6aed0940102bf145b32a4a4ee8597383d9f025f516323a9dcf4e63055400fde72c63b5adeaeeb1b60664c2c84ed2b0422c6a47c2b39041f9e58e0269bb9a2d467a2f6432fe859b598c4437445facc3b5df94a66ad5044999647a634ec435288b2662406a46718dd83cfe74b691c516622736f7ba652682d8a93aa0ced63061588b7e0191fb9ba97a83e067a14e1c881218ab9b181cb10e75da7a968afd983cefb7063e9eb5abd4cc0344bf7a462f918e1ab04162cd36cd97ad63a64b854a87555f49683944c15050650e8b6e9f21fd0511653ed314d94be5137b98bf85ccf28361d97c311d5ef321916fad59471b09cb6d08968e97767ad27800336bd2c648e763c56099362905fd31696ea9ffed2c96709dcd7ea38eafbd371e8f64ad172204ff00a7fcf4d15dfef499542d82632ff6ee98e305c0d391f5f556c6a085503ae59aa510ddd76ac0efcb3337bf94dcbe6ea0685a4311fcadb5f2d549c493f1d446096447e44de35214dac024862b0a64ab79775d697d59aca03afd13f29501e9380eeac6a30bc676a1480f67e9844648bc73457572ddc51d6f242ca5262ac4c6845b3b8e19f98f55a13b315b103c050aa2b11210b486e11cc1920c32a3aacab639a416c5a5352c7b5816410a17b3b328fe2ceb7e0585aae7a308da9f26c3c84f79ed9df8f32b837949091d5d90d8c7aae770bfd254fc942fd43b403c47be82e5b8395a3faf59567e8b9e7145bb1318ff8b48470bd6fc4e0d06eb21e276f7e726087a36e027edce4b8645abad562fb524b987764812f89918662faf93057850f95431683f1dc3de791cbc48da04a1b5ae52f8e24a7cd8a7fc6d0e6c812c2048c18e084f05631288f89c288af54601a939171df76c3eeb1044ea8da725105a4803edface9a0048c2d80d9112f4424d3920c5011e47718946a570394ded4d962d6fbba0c8a1d44c536d7cf1092609e5f32b4b92794b58b1d1cf8a1c4b335e795dcb5fa83b8c4972a6d373fab754d922766f0eddad3938997dcc6f8cd1799705ae0be6edec90b15040d361af9701ae20d699fcd2dc05f15939c853cdb793de7aa73c1b5de366453025b7cb20184cfb31af6d7313536f92e081cdd45d3ce6b0f59f8f2c0f01d6e20f5579cb2c84436b8bcf0780c3fcb570918ed725932d33f7197c1c73be3ba1d7f88d95039844ffdebdea87c4c38cba9dc56ffb6d0aceb27ac939b565ff3a33817fae9455d15de5c08b1c13376067d367887fcf0135ee8a8e79396a20e97d81311219f3ad959715a662756cd0b3252bb599f8f0cfe8c19283bf6a1011918a946c8e3db7044569f73040c903dd9c5861a9df4ef6b41767322a17373bc99ce76c99ab1df68428d798d1be6bc9e8fc5d8a842cdb5215d34b8fd4e4de8b33f45d98a927148a0b9eb1d91326fbdc0e75f40ae87c01d9b33345102a4a6cfbad261898cf800e6393edbaca3b77c5d4c9e9d1d34cc97b791eaba7286231a594b978f8a702209d1d904f01768c6a151548e3aa2e47be0b5c5da213e536165e739918ae08f54823aa0dbe00478c017214b75b1ff9ef937c81e815e35470cc708f0d7e56548d7a65b8f425cb5702817ca38c408a00b96c5a5fb769917cd0bf25604eb6e3001a529b107e372e825bc54dd467100ae094c89979b45430585a6f76963939e89088ab159d9a3ca8ee85307145662d66562c65e8ed6084d954d8480077063c425682691fab4d8ddffdca2366749f7bc4f3eb5cdb6c4ba9d87407988ec0bb90e205b8b65acc23a426b4ba148a297a3acafb92239b31339966f9609a0c6a13f1d06bf252829dfbf66ef15599015ea0fcdb347b51d76859995b73a863a66eaaa6028081e801ee085231f3f7cd85f33db034a94bb52fbef6a35eab4cbdc05748f0c8dad745d72730ccda442eb71b1a5df67adf58bc0f6d3f74fa852e35df7dc64a64f1b43a4fec8c8a498c6b5c05bf56d5a2b436e5a98eae440b943267727075c8aae1a0a3e0b8ca694d16107859084d03b01b7ea13947010d56d9523d1aaf0b0c7fd294ed87946bfa898edee242d3a534b8b1ec2f726896a956fc1a20daaa4908057cd0cb90ffee47c3b41c7318b88e932077b02ad3dff5b92e2942d79d11e220a896f16bc868463db21f055b13bc62a5bc755b4a8cad93ac5efc3cbd6d716cdcb7c452cb4777ff58fbf40d053eef9e1c9b92eebd622463a4ec45ee6bf8c909354ae43340cbdafa164773bb936ecfddc4381e0ccdaf92b2b183f70475c69c1da3523a2ed8f44a9a2556acc5ecb76df8d8f1b7fb7d8c92bfe2a5f9888e7858d29fc5adcdec4d1bb3e11a16c4bf3e26c422c6bbf40be61e5a78494b504cb54323530fb3b9591cfd0c6dd547d9cff57827ded7a67b9bec179fc683d67b671bcbc75323a741de8e40e0e41103c85c011c89e104e78212a59b400f8613e03e9a4235b5d3256412d86f5b684f16b2186447958e9351d0bf73be460500164da8b6f344587bbe5c09c73f79724a559d8d1d787bfa28d6b28e3c1c19c336ba118bd059ccd88a8d00e4ecbc62baaffb945256188ed9b90851bb4a30b733ef6920b9ee15f8979935e4510d617e846f5666f1b1314c5ad15ddc358533fad9cce78772478d92e34a4e813b4a1fc8490631358a07e3e3657351122ad39e2380b1987283660f6a5262b934a2cebb28d284a0c2df59b3ce39c2cbc6577abe26df7aae06c421c6133ecbda769e71401918adf61e2f5d9a6f94b06bc949b2702791df8dfedac527c69064e25edffbc46dac4c43d9fba1f42ce75e809e5292f289abd69dc67f7638e7d978da3afe0a208324e731232a5d56653270b20a6ef5c82908949fd7fb8aacccd8d7c38138efa47a5bbdad7890a5a33ae9f70137120d5762a57a034d33009bc7bf2b71f0d88e60ee311941d317358c95e20f3cf8c39cc543622fc68a4dfef2e514de6027e358da5fd3b6d89615688f83713b9b5d4d6bc48d730efb0994008e9ea7aa3060cf8af43eaab508ad28f8a11c1d85245bca5dc8e655a4109a52487c7e1c3c90756ca330436d898dee45f46de23b5468f7315fddcb388671950222c5463f9b1015ec663ada257ff6b6e8447a6773a78dbf97de598ae15df86399a0918f54b702ac941cc6e75a075b09a51d838e7a3f5ac2262ce53a3df65b3cce2658423e851dafae674dbd00b57b2fb74eb1c7d3dada5a0b45a280aae342ca3551f9406b8488bb44aa1eeb951d1524dcae46b99846d767490b826a03f200f8e51198305432b79b80fde7da150b7ea0ac4dbc679d4a0856d0b9dccb1393247e1b729802b84e5b2bc39fc744cf5d207d185f180b5af48b03a04f4236eaaf398e5f51fa2724eca692cb6e8b42123d1f77f3f800387c91348a884427b650ac9f6b061f77dc646c5d981272ae7cbc021780aecc724e2c9b626e5efaea69f87bb1d8518229561deb8d8f6a799fb72b90e959eb747e812de8e7ab1c4044c433d8d5d503a929829cfaf00514c35a706af137fb5e9beb13e8fefd9bb64fef644f854260b18c32eeee0855fef9b8bb443b7204526be9c4a4f8258ba062a4c4e78b73871258e890e0a143610e57af47d5a49081db8107efb5355fbaf3373269d52f0bf9b976f7b3ff6e2ef890eb2927793bb22682d2d86c4242e268761e180d1f3e7cc419eb71e6282a1fd59d3ac405b77e87550c039a29e6333782006e6d12087ea593da613a1d0de748cc17f39f58649445f626bfb39b5cfbb2b4fa3a3ff108603c43f40c25244e925e2f3aa5351d52a01b0ea8598c1485405fb5d901b4f6143fc4b43a387c4da3db2459b060ab68abcf36c1dff1aae7dc6518d97b2c12f85b1c8b663fe6ff8bb9413dce4a6e853de94e1f092fbb9f5e1bd6d47cc4162d561a529f370f9f1a4d83c7307b82c7f5dcb34c8f26a26efaa563f8feba46674176eb1adfef2886a64a7b8cebf332df491c68c29e56588c3466ce81a9bec7cb6865a38dc300f46a71556f1c85ba79ec632f0c202a5ebd88aae067047494c395c50c05d9433a9bcd7e88b7e8ad017266126c88f447cd1a9a778d1b2b9abf2240ee3991ae1443f85af12bc1cb8da37f884c449cb4ea7881846f577f158f04f0803082369ba4f1974c53203958bd8e673ffc475acaaccbf824de87beff6021ac91da3f021891c1b745638952a68718de52504b0e40daba62642a6d01828603ace5bbe79a2c5f69c991d38c8b873d919aeb50ecb4bdc9e562fc005d6d3333d38697efa5491fe94176d6c574d1a2378c81e5ed4739a0e8aa7dd95c6ad8af670304cfc1bbff93cbb1b7e965c5cc94f11d6834e508549d9e86a9a3e6bd6ae6d548382b267efe8edb0b734b6420a669e7b8f294320e9c5414288aca1681b054fb4d6740e5f369a52f1a4d4b17c1cbde8a6776741926a243d9d110345d038e99b04e2dd5432faac87d34500cd36704896dfcf9af21f4bfe7c42952d12aa70cfaf70a0f540dc374c8803ec266097dacda4168649792be72de8be5b15ecd9dfcce6f0716a0c812562c594121561c1c44c92ad31504f3682fa204aca8832957cfcc5353ad0c194958dfd58b6c45709fe9ccf53f047590bd9e20ae205f84e8c9d8a4d4889eb677daba4d3e54f427fb47ef42dffe14fafdc9b5efe24dfed61fa429928dc5c83f8e64d5b1b5949a82ef183862515dc709dec1c95870613168738b582ac593347a49844c43154f060ef40f70721671d403942f040af1de1f33c100f52142173052d202f3bd4e4a518a42c409779bec6ff1bb33321274bb6d9f34e86a37dad1fd01b02df57ca8b950845dbe9b8416afba4223375a12ce935f5bdf1a26990b6fd7975797baf2c6c209a63062cbda70669fdc6e4b5059ee01211c85f12016bf7782215e2dcfa3516673dd8f8c00fd7e7283d630bc94a779e0c88fc197e59c1b575d01fba74d9e498047995efb23f3d0a9607ca01d123aef72ce626131917a0a0c97af6a87aa60b7f0624be34d313b7c5c51a9e1061117883371f2760ae22cc781b84d9517da68d77ae0d43c1ef6b3d3e34e3b8415d0e1cc5bcfd8dcc52be4857188ecb87f60f08fb7d5c13a1c55df92602ffa9c3e8377c02e5f5a79399e1aef37f9e4780df955c611a669a7681366fa3af78d7009e5e8e9a016e6e55d1375df50394a558d6b31b1c237fc2c22e40fdcc1248eda9e6260c6692b35ef18f0b51643e6e122160a3ed26c831bab048a5f40d327398fb7d7b813d9faa87b3243f69fe9926ff05268b7c290d361686eac4c96d0af5190b1176e45d12bda1b2a2d351fec6693aa92757bf2073976621821ba549d4b5a1ff3a38ded932625402bdb5fc6ac55999ee58498f0ccde2375ea363f240332d875368931284d75a308d102fff272d9c93ad8b533a048b71c40b0f8e93317e913d4df153de101bef6000a0b412441933ca688b84478d094f7a27c2ea629d9ce6ed976fcb51acc23f1340146e34e8e371b6f2c1ac4dcb29c23909038e7bd6657ae13328274a5c0f8d77609239d4a36d00dd158a2fd1409189a79679f179f7384b79b4df5e99279dbd6ed60f9a63439137c28ce456c0b05f080d2bf184362442b199928285fc62bc828a2af350678892528c98dfa0c4281795d3e7f38ad4fed74582412748d810abab840070f54f896ce4a8c987691ed8a44a74a02257e93dba4846f58eb615536b5d3cf3fd46193d109354262f77cc50623c8857262e4adca78a91181135ce548fdaf7fd2513f5999659717b88511e3782f90e4e04267788ffb42af4268136690d69bdb85c54eb667cd16e65536cba3a03351e6be0c45aa4e7afe0beb35dafce319bf35f4792d9754ecbbb2e9dceda0fea30aea856441966a2caca554c4547d605a32e76cc207acfae85c0dd9ef524df82513ba3911fb987cd0f033c6fa423620f58777616b1498689183ea78b25de1e47d1e6edb41698867ba5fe16ac6e835d87605e52dfaf9e307bb3d9101c80184e3527038a8498faf3e0082ae03d1974f151e564b115a517f1b7e76460e9bfe4bc48e1b38f0f88165898bc8e9490e1383b3232933f3e148c6118c0d2a5e581974b0b1a0821833c187537ec0f1060d620cd4cda0a7a06ddc0eceb0c790622db404742f524cb66b6b001b2382e997007405754b4b55597f7628ab45e9dc372be55bd11e176998f473f615d8bba37facdbb9b9ad9d8eb37d58a9037cb446f73d21f156d4cd01514eeeac3636b57b1eadc5b7f259d1014f62c48fae1281c2b55b84a7f57c4dc34875b62f3096b262f00ad4e8a3f2b217330d1aeffaa3754102b3716a04c4d2cf094b1397a7a44f24f05818128c059fdaf5bc0813d1a38cceaa41691823c526b495882be2b6c2b1c75f40286b60d1b0b3ac60a2deb41936ff6a2e94be60a5469b76b81ce2e012f0dbd5d3aab9ec29fd1d5ad566b3696230aa06a5d77d790ff5aa2ccb54898db9efd2a43705d8a2659e29c6ae4d0ddebdfc2599f4cda40cdfd96562f517b2a15a1fb09ad125424f1180b2bb7e903a06eb1cf2092a3366e378172df6e9f85e0a3697bf24865933cabd36ac48d81cc9e4b0b8a510a6895f357a93d389f03cb711a3d91bb8b4e23ef0fff0e116f5baf5f31a895b30a2ad33b0b9bdfda8a81d112fd715ee0d11ea694473af522d92709c6a7538467a1640f5d72e4502c58c309359fe785e68f48e425700135e258eec4e6de4453455cb617a10b6ff22138852c317467efc609f6a700351aece041e8a835c260bcca6ca79613f7198171914978cb1463bc152f4e084edf5fd1a296e3b0f6bf886388dc8a366c5946671d8bb796dfe20b0c317962e87e1a95dd603b30c06748ce86963e1432add159f50bb2839668669cb5c40ce297bf26b6c866a6a74f0d735244c395c217340828adcd84fd6346ff82bd23ffd808920157a68d605ac129e0375a3d5a1628f0d77761966ef6d005ae0d1138d908458118039c976282ca769d65dbacc7a2cb6fde4600795409ae336e90564cfa82906f11fa460c018d12c7c4460c7d671ec29c1eeb444f7a001b2c0cc8a3745659289554da8800022d1b6efa967b163a36c86597af22d7b2efa6ab09fa599ecab476a1f8fba7598be2ba265b383e343698449f972a1cbc343a5d1a3daa7d83053c6bdd28931e607fb86b5352a50cf07396e200e676d31cd0d6d645d91d78b2236f0cbf4c8260aa9ed97c8121cd67321797c1c7c81d33ddf4ca2b135165a4038f4ebd09d183a2bd539ccc3bea069f399c4a97ce6be473ffda193e4756027e4d2d780668598d772913ddce9b7f012500cf120754fd530ecd12ba0a92b60d7871f6de0e9aad0a24c2bd54ab5a100f809c6182e3b32598e816b38d69363b8a2934716668082e15ba7c03b645045a0dc5782cc0ea1227a4d676e5f66e9902b32d9071e54c12a7aec77eab16c65d97e75e0d6cf5ab996137b687328e60d43b1e2282e88dc5eb77c8de902b8a97a149f0eeb6061d1eaee211a49012836336eb3ff503f4a84d09f0b40b24b5fdd73d810079a7ef69b2bf8bed00edddcacbfac86d92c98b9722677e14fa7dccd49e951e465bec3f891ea302ed17b3a5bddf53cb655fd20311d0a03b342fc8c0e39bd828c9eb7fc8ccc3503165fb96d3a927615c9f2fecb4f27a50c9aab8eb510101140693ee6982a3dc1d976b0948337e4916bbf4c14493faec7fa0fae54ebc947fb26c11885ca740312b765f6ee24175a2448ed4b0eff2cb47711b3bf6d7028bb42baf542ba40f7daa23f5f4656c1d36a65382a83985b1eaf5ec680d0b2e9db988f1b5e56f2fcdb1147382b325d5c74b85d07c57aa0826349e0b70ce8652ba7e3406d25b5a9dd4858fec152d1f5de9462d0f2ff25238a6f3db6cdd77d2bc00bd1ed5974a6a7c6ddb9bb090d36db14c36fe24ee374519706bd29e208ee00ea4e4ad3c86c2697a25a3dcef582d8f1787e5d776d087e818f42e377d36233e92eb1096c2a3b3638eb4d49f904ed2fb5e43a6357a5fc9a6f67eb2b17b811726b633bcc4b3a27c8c77b888a5688535c426ce2f32d5c452ae5cc25b12e0375d4ece46cab0b41dcac1d154df7cc33f66ebdad6227d26b3f3e2010ae552eea40efa3f1ec5545c26dd6abce3c71350627379ca2582241d9e3fcb7be2af3dc686c771d79a9c587eac35678bd25b4f39c5e1d2d1fb7078e2d43fbccdf7e9d9ffd28d06d872c19399b5042be17202b22037666714245adac37053f82ce8c3880b626a8664087d15593a0b58d1c36d7c2032266e39175036c3060f8fd54b12e78c7390322b5098531c3c257b6064b279218d19a40138c4ac94c304f56c0f0f69b34def10e99043d8130c4a9fe3c8cf2c605d606cf302b90054e753bb5f979151d2bfd5eab4d151366a9793f7e72115db1904268fe87544a5b80c3663f33463c291f874a97455e5b0eefed80b75dc6f885fe4bcc0b556c722fff1afd4c48945423e960e7f509038a41529deca1c5bb058383df8039d1957abc3f548d0a776ec0a5de03058452bb247242df6bebe0829c6f5ed794246306e73c517f30b79553d803fe54df0575edf686b05c58fe341cdea3f4d289b20557925acdab7f74e35675ae67e3ee1c3dbcf7664c2fae24e9ed381ca745568b2c922bf7b3981b5064e3a92da7699de622107d921330ff057d3436d51d761ca4f5386731cb69af718cb4e0c2acf23b6a29e6d11de05741fa28abd8442b14aae7cf0bb567148a09d6b47956dc9e61c0b88edcfd1be8e9b1d17cf6fc1d211fe714d6dc39d29755ae35d09a3480b04b9c6317e680fcab2e3894d9a4f33d3a270a351b9fd9dfe33f07247f3890364495858138701cb2d2bee0a29bc09a434c222f03e110a85a7652b49c912f7adac5df2974ca4d0a42b715fe357ecd9aeec4d5b7ffbe71bc820ac194cf93524eb7e6f5a000a6dc14b858ba41b2ceb58bcc497d82281d89d030ad6ade95d888ed9e7cbbf3ed78b10b422549d9703ee38d82cac2eccecf7bdd62c4eb58d13430ed22170d9db46b6ab9cb170428f20afcddebccd41e9bf71603d8ee13f582034736dae8eee7fa3953e728a753f98c6c1748b18112774cc3174279ebabd621160edcbbead47e5965e8a0b67c4b0f5700ada34aa87d7f6a206ffaa896ea8a4d210a781479931e71258385c1632621338c32011c3aebf8fb821cc830417ecba4ad312cc3b40a36173e5e59ee0324119d5d31ab14ff435184d405732065e8816423e8f6bbb2ae82adf70ed6a732692f5bbe2686bc909d3329c61ebd4cd6a9e30a9238998dd76ea46c5525800408f0be1c99fc074eee46d563493cf6227b0cb163ff7b785698db582ed08cff194069521cb3f30712bd622fce14c5bc9c130846723b0bb06c392df1a0a86d391750f91ff5c902999475a1e6941fa3dd2f5a1ebe83cf1f45328e1e0e66b8837f8d152f68e3548c4a4fe3f6421a971aceb258e44399177ccbd948f9d098359193966d152365ea3b6b9ff29b62a96b036b47e01368666e61e30b24d1b3c77adf2f2eefb9f9c692e37719f5779e1374f78d437bb567e7e8661c629bb6b5fe24c9e09d0baa7a80b323dfc5bd5e05855555491332d0dbeebe7585177a8b55b795dd3e97c321406d5ade46dbff8e521382fce95b7f97c79811a4081bdfccccd90a3a32f9bdf989eae86ab5b33f74ddcd487ee760d6453167f9c2dd04835e3a2ce44861292662b342627487032c3082da20f9de90faa36affdd817d64b055f0b268d25057a92c662688699c750a25f706f6c78af1fd365233f911c7693198e2f13fabf715e2256146fd6f4b16bb6bc1027acdf18741d41f70e4ce3da8682aadc6687cb36ef64ed597f75988293abca191dd21618a1f38f897a40d8cfc54059da052f57dd452f28c8c761fac30515b61fb4c55938d6788fd09d1ac657e55694632b23ab5af0b3b1c596a49f1042038d82ce06ebb3a055dca336d67c8fbf23979f9e0100474e864bfe1a8ba11f9f787e75d1c67f130ea2979b5569698e5768d6d2b3b3d3fe3cf16786eefdb146dc887ef942f709daf0aecc9d7ccb09d57d4c115bd638024a113e00ffe791cf51c5fcadbb5bbb8334ef74d06d0f2d65f4a0cb3eaf55e681989e97584557c9003a0c2e19ff857bc75adb022977c3c8dc1d7ad65601b67cbe6f3d2b4b86b4712394efab2f37cf8637c387eb718cb63932652a66690f4d135e820a58a0eca14f0649e26c36572102beb708d03fe284a0b21dcd246bb67b06dae180bdbcc761113c7e4a060c7ae14ddebaebb648b53b67afa4738efcbacdfe63029fb07a30ab40935d948f39c8e8faddf464d21895f076f00db5568d86cd35763ce35fe13d6552c9017a4ccfdc689de2b2f829de153255a2eed6b528763de43848da9295d9cbf9a032e1532dc5eebf92ba023a2619e225b77623622b4e8c91753215e08db2af67603a53ec64e4faef942ada7b2714b0459f83fd8ec3f76d3f839cd69b1711de51f51e1b6ddce326770fcb8fbcf78e816a66fcfdd756d683eaa14cae4a0a4bc7267bf00a5ec6e8c970e8ab96b72cab9098ca36487e74ef8a27c80188e2b5c6ae058562664c04b7c3e66959f665dcbb21977a89a01cfb7db954317f64b66075356b70062a9f829b8d6b250b64b2a70cf2d132beaf12f7c40dde9211f39f79b10533406d8973dadf35b4993731dc3fbf7dad0ba5019030792f1e0629d4813ad6bb19d47aa90d42d63ee4b6bbbb59a8a0ceb1944b26a27b1ace6f5fd28a8e93e6665151fc39bac7f3a84b4ee54673cc847b6bd986cee8be4dd30f9a0f1681a0db437f6cc7ba5118982826b96bd63a2e9ea2a9101ae3d8592f0125f9edbb89f9f7dbba8ba933d60a4c89e28e785181f36bbb65f09509947fefde79c2001f3ddc11924ff59700c531625bd5395fefbc519d5fb86deaa3c472f913b49d530cd49e85fd9b63a80d1a0689c7af081e320e75cd237d5bcf636b872889955bb5bf865dfaf6eed80f92baade4fe6a5cfb9a4a6d199ba99fd93d81eb8d3d99b3a99b1cbd1ec80bfee3d0138dbf1a86edf7eb02cb06d00c36d274b851521a38986d19eb02b16820f15f802616a8e590c84546d5c2a1b51b7d37eb4c41d51e3cb94fce88540dbeed11de621987b8dd3541f8fcf977a9e56a58b780aa11a51ba6e547198c93a3f1b5e8400a3e18878758292f5537d7318defbf92c4350b44bcdd116f3bad2575bb0f40b7149bcfec2f16f83c9c99792f97e8545a777b978d69d554f2856a8c7222be303dfb938312a2b606252a3dd51fdce794dff31d913d7349786b932f36cfecf5056bb8e43f79c640ea0905908cbc384e272c4668268e49f76c4b4775e1cce0b950bed19b83d87dd241b2414cf0e859f720fd2632cff42206d12a0b612e41d8b7493eb9025d0d78ffe0cb3ecb043aa246735b257915ebb7e35d648ae1a3e9a1bde217213216da9f2dce06437a4a893d9bee92d78ca944776c4341b4b0cf6b7c78ec0abba4ca17c826bcb26a5a0cf6c21eecc2da5cf4466a99139dfd7a50884611bc600d5c9e25e405e98b19cef72cd9f1d88afd4b2a9cec9ac6f969943cac43765d38703d30e92d40fefb662b36bf6d43e925b905d9c90155a7850eba3125b69cce5580d85a7a82a84e56daab7fc0e902379cff8bc216bced478ea30c1ee04873cecc486de3bfde08abd30b8991b654726876d407f9f721169575733fb00df8526235ef0e02eb26b0bf33e7fb0017f8460d1a9890bb5083a1e521507f480bdabc022e4a4cdbfbb2f879721aee3a88ff04d71c725fc79a35047aa3aacd4d8409423f3b93d42ca7ea7cb9df9aa358e99182c94fbb9116eba26f47ebe3eb6c5838ac6216211d766cdfc7dcadde52012fee0c7cef45eb88c9d76e66844d46e19821c30b1fefeb5ebddc004e8492e03c8a16354bf3d28787e6ad0de22ac82c6ff3f88b21a96e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
