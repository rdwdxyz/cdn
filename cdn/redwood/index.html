<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb79764b1eba300be91de8f0e1cb8a214f071115e4f2f3ea3dcf57ff27d5499192afd47b6ea4660e657b8a5df6140c845fa0d3c76bfbf54943ea2b20c5b7b938ad484597965dc6a92d94b09654e874333d55074c7049166fbe14781417e358c936221612dec8345992447d213af34affc32ae750c89cf48c37aed11612f68d91148abd761c795978c9b9d956e7136a9e72c88e0011652ade5db1013d14e724ce6fcebc6a6409427629741481ea85b09e052d3dbb089f860998b260e1fa2b5c8124311d101f7ffb9349346aca8252565ccc8def9289f20c1136eecc70664f607ab7a503b3385ac2f52f1a8c3c51893edb5f103b2fe0db54779cb4e816f5875842e21dbd48d4cdc8d814bbf271890fcaece4f20fed6f2b0d8c975057d31ef26bdbf530fa2593323bd44c06a42e819b4df2bf9315d1ab99ac76cd546f7037087e22501ddd9ad4cd9c2392eaf6a058268cf3336c31c3e17b9b8be5d723c59f1dea799098d54c03023774081acdcdd61307e30d3fc9f3647e36ae17090ab0256f74bb52b97b252e6f83e61f2b8c8fa0b505b55d7b0c674a7f64acab8de046f04fa8655367014657741354c60b34e86151197a1a4a2d04e7b59e5e5d42a283638ca99b2cd77586db73572ffc4c3fd24bda2fa9689ed2ec3bba82fc1700a311088be3a921354731639e421c90f5a5a8a0a1ef91f6ef1b9be8f66f5d382fdd8046cd5dadf0b873af5a33a628977b9ef9e59ab942d691ae874ba642af907ac9197472dc97e0a5b9babc1224459cfd2ea5d9dd7c3fa14ba73120de4901a43e649763ce77f25f1672b8cd81675bc579582a8f9ab4a549e977ca99f7db9ef301d3e1dc7b7a00eabd50503e287ab9cd57d175021197661d5753250649556439944f51dd92dcfdb7933e0922bf2fed4ff9031d8299b4bc82e8a670904df8e51d34e36c375b8c5b61cbc099a874a24c64d4cb8e6ba2603a2dcd1e2b75b021fd822990da3aea6064ec9beb94372e5ace5993784e478e9a8774350fe06e3d8a9a5ece12c1694e46245166572872e744560bf0cfd2bc360ecb31b126b60fbafee3403a80bbb9a420fead6e53bb068275c2ff9f5a06e1ec673850c84c2685c1c483ce67ae077f4cf0d63eb78921fb9b4cd55dc9b933dda491f31b15bdc64999ead85efb58e1638122b4ac98400b263e0588b40f6bfdcebd4a7ec7cb11f8f8114603c4611888f9afc1221f6584a61fbdfb7bc09810116062bb4ae09871ce2c18b13cc234b23832da21042167dea648405aef56d8dc344b7c1662cf3dd2aa5d201e80ded71a8ff32d2b7a975d690a075428d9bc99ad2902d4e083ac1771f85207f6d539deaa3829b3d10d35b3a19575e0df7af851035ab1e6c135819f79186516ced6d9fadd0fff249b8e5d3253b25ea54008cd767386052f4d90556d7d3e940d0e076bfda8984d5c46a65d3acf7606589bc48685e91cbfa76afceb0cd143278ea4bd2e7ba4c33b0e92a32161c960192fc02f2ec52eba59506c32c1d068f20e62789e4b7fa09bfc0c401238708ea5dcdd3432a7320432b1b530c29506457f4de34906cdc8a038c4d7b29d04c19e5635db2abdb17bde8f9295dfeb71aa139a0dfa473900f10bdebfe196ac1bb2f95afbd88aab4c306e8a85eb07021c6ffdb7bb82378009be01688c40186f6df9741200e9b81b41d532361d34cc00526955540d825036fd35bbf6dbfd67e387b334bcca87884747c673c489b198fdcba9ccad923c0e90a220bf7b21aef4c284356d198fa35dc00d300ca50e0a39742cfe040d4b8031956d1900816542f37e7694286cd5214942e1c938674604bf3dafefed045520e713392faccf05542bf63e244aeb0506f3e4bdf58d6ff6df8c99df0ad66b9d6a0815b00dceb47db2ba1cf9a4e0a20c211cc3a1667cd249ee69b20583967b3013684537b89294da83b721a6ba44c3f10a6173fde2c6b2842862c806965d68034bddd8860fc59d852357ce7b9f67d9a38f91b603ffa53702f12014a9b5984c6426f6c22f20e6c5a27a2352b0023567a16f6bca5356f322ee06678d590ac2c4b95e12d54f7a7f4b660d413690e3fd01ed5eb991e1cefe48b5d95aaded027239941c54d856b19ca5d17bbb2901c5c4d113da600173e8e22e1ae702aa78695d6af646c6ae72204a771f7ae0e34a881c75a861c910e43450ecf7573075fed22946d270ef94fdc9e841f9bc01dcc7ab485c437bbd11978a1ebe7226937e17445d03783581505d38bd9e00ac55b7ddaef86e8d9c736d93d07891c5e964992fdb10862579e0c0f985aeacaa7a3097b65d8693d3377717ff355e499d17618bc9b087aaab829af5fb7ba672b42d3c93d07c4e07ca1e218cb1721015999d0cc8f3dea6fd651d8a90712564d113802c2c859221203a70525c91a369bdd394de878a50299bcc204e923df26fa51f8b370347efc126320010c8c107a6082fe388b90d429a787985adb4407fa480c313dc6d091c0bf9eb0c0cbc7e9978a26e0718c52804c5627472f8485e16cdd481035f1ed1d13ce6c6cbd9cb6a08076d1ebf440aa409ee8a0cb95ae07853d235c6569fa3ed77641e856fa4ae70e01d67b83875077fc2a61969cdabc6873f2a69c300cc0178b77015508ae7872e17d16c446305fe4d880898dc3089433053bec65236cbabffc8a085d858138c1dfa8958860cb6d5161466f44fe6ca7a05f4261113dd353d62fb805a56ca181fbd027d06fa386591b2ba0d9f6470ef8518959f390c385c9acdf069f5f0ee06fbd69bbe686228be7a8316aa69d18e6a90c613c2e2756732dd88bbcc3b335a4de5e9c3aa12930bcf76ec1036acc9c440fe95cea93823009f59e074a349ceb2707cce748e091544b543b8479311470fe568f16ee5103a7a30e2ac7b53458e84fd5fe3775c5daa9d575cfbed3a029a530698887e5d8ab00ce514fbbc2dc96d4698a632e812f918723bcd169688b3c187d77885634b86e47d2cf27c695239e64e0c80f4553c70989f31c3c8c68633bb6c0d9915e5aa1e752d79dec317857c7217f62a49512f66e92dca879ac3f36b88a0021d8741be4b818e099fc0cb5081b1bd1deca86c54efa70d7c0395e3e2d313ab821dbbbecfed0f9d4d09cb30dd3ed5557a4263e3045cec93019f81dae722afe12dc48619c36e2a773dde1df6831bd86849b061e7aa7dfc245176b6888847a18beb544fded70a3a0eec02dee546e77c7e7a80e645070aa95efcab94238774cf85bb62deb5773f35768beb345d54e42f080b5054d79dce4f3558b9d871fb0ce5caa1344415c3d541d463b91812dc3218c3dc5055a0002363d41c4351f1f6f78cdf4b73bd81abc274f8769d50b79a20030b6deb9f66bd40bf3ecf16c18210e4640bc99300737aafd69a2be672f08f24ff8d87ee9010ad47850b0c95c56b7ae3bce6517c9ffb3a52ca6b91d3c17b0f8bae47c50d1fe67d58eda90d557e6fa0ddbb362d596815b8177a2886d7b88646056210405522a1ec7bbe5e34f07e219c332a0897f259defa79b9c36b8b117ba7c949ff651abde9a8bd52208ec8bacab8490d77b878c51ebfbc692993a6a1440c69dd72de1fe12eb89544eeec62eb577d9346e7161ac59b354cf8f9fafa93d80a75defb46576f8a80efa2da03af9e3a5f8685903a422f965036009b87ac8e7a5ecdb13eaf29f74caf6e7d002c7df1a70863f46c627c708ef32f3a702b679c77bf745cf83315e0edafeed826923d504757374b7283d5424d1d711787912eecb54bf352cddf109bf4ca17d8ae589b08e4b948f147f22140f64c07e84b296c41c8edbdc1413e3ea99704afc5eaf3d78b71a9d3344a250a5f9a7aed124c400aa0a8b8da9ca3fa0d6e904fdf5b48b0f1949363ecc3224824cd007732f5d4fe1f529703bb0cc989281f5a789d06420d59ce102b2a33b6ee588c29e0f99e893d61056a7161960135e0e786b9ed10591c93ef1cf1dfc5ea144066ba49584c8bd79885145f9464ac6f2d042a3d92ca9adfec57c03907541090b739c7e6c26d0faa102614cba0d787e3af1a7dad7d862decacc331bb29835cb133520bda69c48dc83a34f7db36f2c1059de5f320c1c336732a9f239c815cb04c2318f75c1d84c2173a381487a1dd8f159bb9c758fba5c46c635c6ea84a26c21bf0b641b427b6be6f10dfd8bbe3a1810928147207100d7f412587fa6fe574355b3910206fa05a6382f16e3c28d6884dcf6de7363931b483766e9969eecaf087cfb32bea784fb15ce8247588d97905dc2f031aed785c6739d1dee04b1f4df12ca565e1dfa866b08d8aa63384decc1d1a95983e2f31b0fc0f6ac11faf5cc2ed057206ae65babeb119f32527cac4f465dc0e86849304452af744fe8037f4111a9f0849dd4fe5240c6682681f69cb8a342c6d8755ef21c909d27e0c735732f3f4d259cde649986dfc33b6c0888087f5605a5666f298f60543bf05406cfd848682ccd7d5a7a741963777c360e3fc2157c484b4ddd824caf053393f92e5d7a39a9c2d8cabbde544a8c25040bcf55a70c384d5040ed5fc4b4704624a81a431822698ee94effc3a92d940e363b3a039e45cdef660233d1cc79b2aea44a96121ef6fca388545c164dffb05e0df1a9c730f8cfef81a0dcbe62974b6b932fbf522e9817511cc54145213261e84d2e0661c5af6a90c27f141510fbb625f62a73adaf75264c3e9e203ccd70200cedc9bb52002587dd269b6dddb5c93c941a3abe14af880eaa9fc03df1bc7f251a227f361f7442bebe5a4f954c6fc0cb5dd6dec69dd6b815a0340fcfe1a4e87c22cb9aa716a916e1ecfabe813a555af64d7413838a019a20b3b4d338203145b9c5dcc2f57936df438ee63c1eb726c047193833c43dc933a8dfc2d6939e50fdb306bd2321f6961f79b068c7240f8f5d152862c3fd317c4fd704d99641b613f8792907d48e3bb0b09abee8c83f2323c7fc14cd61b60300458871d0bfae516891b711c5cbefa2cee6ddc6597d973103f4947a87fa8e51ac238813032f70d0c497eb1e9c797bd9509190283b441cd4df2d609d8022d664d154d42e33b1132f8ed5ffc21d0ca5c43adfff74be2d18226714123615a800be708d366036bc825ce0942597f8edba960b4139b58a7588fabd4258d81569758f346557a566ac9f454de2350e3374a0ecabdadafc3fd258ed3d12af621010e0b3cc573ac7bb6f0a9860153b4bc95a57920a33843420cf8ec98894033442fcd39b4f045721207a2b045a343c1d1f8481a244664a566e23fe0371c3ea8beccfb1db44f100eae10f28559074ffb39d6aa728f498e9f97610a2c15c213fb19b78eda9532dadf8ff254e16291ed0a8581133753d649c5b86ab0fc5a49c278440e02b74e96d8a96a38421ce5aa06cd4c49619d6464c92ec80542ed0ddc4a9cbc19da35a24ddb4f029bdd8a2eba89f6b849cfa711b5f8ad9db8bc9e5067774d60481c4afcea92f634e44fff0df2e7bdbcf7af9ee76a9302c9ba4f9ee7356207f791a7c647474ec60ac3ed64c42afec28c334de4a69a562ff63a8c08ff60160a41a3e2436ec567cfd91060a29a497cb71ddb8085405f23494a6f9459a8ddb00e980bd36c29b2d9a68f666cc2d58148687c57d2959f4307d6ff6323016da6304ff760bfc6c0b04b73fde65d752f7557bb882cf9c3d03b86ce73d3cf8c27e36c5d0e0a2440427f657d1dd3d670d720ec087028e2059c518da37c7b9af7580f244116b3c535a15c119a65ce4ce7ae845a0cc54cac811ddba82213cbfca2fe2b0eaaa1c0db4542bbc1313196ff0eaf766d14264d6868d344a948769bd9e199daa90bd3b5da3fffbaf2a039a3c8fddc19cca11ea0d19984e5d2ca69d845bd05ede78fcf6e78058f63caf321d12624d18cf170182d4f0270c78c59261f2923fed34f0c6821004f1b294dc9f97a50f01d13bf5a7f25315777fd4811c6556696f2ec604e8471741da03e61d6d39d5396d602c90dcde18d7a8bb28b2c91b2adeffbb5ebfd34eb78d2ba153743cd87c3f33a458bad49592c9d5638e4339d72d6db6fa4338c00f7e39f1872bbafb61a1c167703a7180824e0ffa65b867a442747c85ab254a0a88824a380bb066b2be46174309b312db3a702b6ca80ac8ee280ebae6b4f790be2e9cfa46f4858da2d3334357e3208fb92f640f47ff49f0e8d8498c483c449040efd7ed93a1c3570cad4bd258d8dc7c75b964858c8241b3699720af786f1632981c6517b86345b55207e155c9aad78cf64d97ece66516352f11ccb07b3f38cc0bbe36557fa952ff40ef8d17ef1c08de9952beda5ba29bcf07ae2de0263949348cabac98a36cc64a16653ac2b7421e05e9445e1ae2dadfae16001d6184659050e415632bc6545ae823e4008e595f4d85033a8508e908a329e96e2f3b938312aa3f8ad29d69736f29c9ae14d2cdac7721c81b308f882a58050ed8cb4c609563414be44f440054d301a4d98d29a7016d7cf17b4eae82075167d9db9484b426f50ff0806b9803207163a2982d72fc9b897536d8b65e71be8c35819e41614e9544baf15848f5e3363f6f2fdab0933cc707ebe863d58a18c9d6e1891283d2819c4dd7d721f7af265bbfb952039a08291c85b940fb5b480733d02138553c595c032ff30989136ed430f207f0c39c062871eca4379dade897ca9d23ce1313c5185e635c6e94a6b064f9707cfc7ee0b42e8578ab8fa5f5fecdc9d60cad628cb509353b57b7a05ecfdedbcb6183b377b1cd3cf7591f3ba8284db7663dc968b3d53792f5fef6e66fe10ed5a55293493eb54a91876b9005aa898c7e97cafbf67dfffc6602d2208bd1bcb8f09407ece7cae5ea3d1c215ac8f04351a284777c5d75ea462d912c760075985a3954941684818a89c8f00977d6822b89b2b1eb29049b698f9bc894175bac413939742c597072466917a3d72fdd0d9e170a760928838b5cd6442b1309577bb90c8e579aed009c699f2f8acc1832f94f7cab1c452141e01659659e4ec578b7d0686fbfb5cf3a96ff847fb227123c4ade08873c0f8a9567abd669c2b29918eb3fd56999272c1479615e9cb61895262b6b0e9aa75b5037a3617342a87e54ddd439bd935c4503637323a0d6120bedc765af90708ce6b040e735775735e025ffeecc4c980c969d38657dad6318104bc20c7ec0e6cc6634e7cd011a293be3a660470300217d57710bdc6b6ca3055b61d6ed6bf5af7fca3a3160aafe4211f690947a668ba0004cc9f0c03ab8f3c7ecc8c72d0b5f6f8a276c83d103772904585f5e477ea04e7d47a36120224aba2b3d987a716fb9d8650611edc33412bd054c2f63e4c730238491ac9c0389fdaaf22ed6daf154207fe92b0f5b76e37340d496de49e596f71e2f92cb7b9045ec127dd93651eec26cfd24f908761e51ca2f5ece0972636528973c3954827b3c9fd022db289a6c681bbe8625b02c7f49592b8f8167dd50c78378f454563429c0bd9a058182f67c51e92b8c0cd1b88bcfd8a453ce469773f72701305b61c77449c9ff251c8647dbe00bf746f8fdb7a2da6f6d5df43c585c6d3bdf4663f432950a4c0260977f69a5011b6031152eec41fd1f64e6f95d421c15cf9ec12fe57fe90a8971b10c94fb5a2fefb10a081a963bd05fe9d261f8b4d2c3bf885c4413531ee2125763a4765d125022cc1f14890a996bdf6ce0ba0ac2d927f87551af5855716acfcb0ca394955846060fa3c27c4b2bd79737b220bf8dcc9dd4ffcf3ad21359ed8b21d2a81fc9465aa57b5c6b3bbdbd749a0368735823f218cce1774c5253a2cd823482e576f7726be027ea09da3bcc4e12b7ba3171fba00d3ba582baab13bcae6f808bee821545eef2d6b7cb0eb0be51708234095c2ebe5e73cdb1793b9c11de884949d24e7a61068e10ffd77c4a149e473f25b50b63530d9c454cb2781195d65462e16c9697a2ed87faa92a102f36306efb03b62db7e16db03a0e1b6d042aff3b749f860dcfd61f2ad1f79d09e48895f0ca329f5072a127671c9fc9058a98f6d567cee10cc9812c2f6ac9c199d1f1427e01e069626ca8a949dd7b90725beb84e2c3351925b6109ed4bf3f4d6b12a0768b76d599a8f34678d8ba8366c59e46cec06b863833a7982a1e204a571eff181f400d75d6a30425d901a0e96036ddd17ae8d5f8aa1d483f67f8f98fcae43288952f2c9f094738bfa0c2a55b43e5d508d1ecd6e89c3b496ccedad1ba2cc37598b155867c6e25a3aca5bc49b7975676f4ba2ed0fb7f0c49c6e927d472373a11c025575b98b620f6a76652e6769578b8216cc9c7ddd5479c692812efc4cbf9d89ecf62fde9914632b21aee8a7d4ef15b8f0980b0c8173a75734135d89e795c9766c9527ce82b3984f8dac4e23e60bca5801694feb2f23b0eba61287197a18ca495c2c55da4bf00ef8215382193c0349e4ab6ad240056228326e85e7f4faeea948b2818fdd9074206b41c4c0d21987b063c97d4cc3a6864f465453c3f416e9bb315c7c330fea2ce8a267ca4f20aecbed5d6bb01f2f287cbe0cbcf541d4b7187dcd56d3015f74e5556de75a5015a40c0839d14ab2c289dd77149319fa7be3aaa6113d52cb746ae12b16400eec8a9f186e9b776aa843e3a46c5551cc864c11255d877aa956ac0c4142643b889cb5b7f5f33414dff705908d6abbacea197e200a886bcf372ec28f3dde3af0178e32eff7263ff8929d31574d040fb8d968f204661a5c4134dc60ae332c5e1dc20e024fcc3c0b8598843a870dce39d7910ac60c7d69e6e8184cb3192388df0336324adf672d2fa0007ba7d54bce85fc5bb6cfa27e55e76a8463fd8e799d0c2cde4c671be54a38db31017dc3b5331c3852a85cf70e9debe0a3bdff87ae1017704977e7856d2beaceb241ef6188ec13bf6674f052deebb63fd35994cf71aa99e1624fefc289a8be6ded3b6ba020e2bb6826a4a81eb449e7248953462135771dd4436bfb752825ef71ff5d46c0600e63fc39522d24e784d120413a126b52fa80954a70107717b7f206f6639f8f663fac326a25a63bdc18703a421bcb310f1506a060ed50a902e090812675e0b0379cd41eb1727029c458b97ebd986dd3f047d213aef7791f91701af198bf1b1f94a7220149bd2ef56f3da038a071e154fa8a4bad21fb71da26d90fdf1bb26f8525f9abe078e76fb5c57df0c0dd2d7aab85673a1509712f96d6033b0cffccace4f0bc37409f4eb2200f4ee609479a9b2c1eb7eb07b9a08ea47e93d4e06948fe1bac3c406cb71313debf45f6670b7c8215a858a12c7a0cbc00689ec73f2c3a1bb105f0e30f9740577ef5da9db674dc8dd2ac302ab3731d9ef2da726272a02828bda9db680f979b4dd5661ac647321a9aa690eb97e07ec601e33ca09fe048fd677e2d50c5381d21b50772008fe3ca7fa8dbd3c7a3c51b9cc580c18125eafeeb218c4e875787495aeacebc52b4683dd9c13e707d16fc06239f0ef75a0b9441051efdca1f3f7bcd1afc4c850bdca2eae95f684ead445adc04ab5195dc1aac303f9fcf0ff304f99d33b108def928600b61d39f305b518c0161bfac6d3c2e1509f81143ed08b171ad192dfffcaf45cb00f09e2f55e73b744d6540ebecf33f520ea75592cb2e4867c1ab2679cf45897e161ee4632458bf1d43cfe9446b0e6f8c6bfdf96bf170bba71adcbec877fdddac48d56c9eaac0a83bec60d9696db1a1d3788e91e0b020a8bafdea86b727fdf1fb9f085a269ff96b64af5594d4680af5e2c3bf4c9921a57b2d1e45e5bd032c2fd5137b9280441331b6bf2daf2b4794b7af2a62c0bd5eb04affd23dc7d50a49a4e44a4301d9835c2865176e9c8e8f1cbd502268e9734a8eb93390a4a23a85ddbf34ff63640fa7531682c8e1f35bb2bc82a1fd61502c9cf787e736b74062d910f982dc36dffb351bd768cf53f571af1b63d00042b2b1eefafa22ea3888f7ab6816ab16133e40f9988af038e5233156c68aeaa89e255cd21c44f7300ccacea1b6761063fa99799037f1fe37e189034bc811ed93eee848b56253b158f653c13ff1a68ecd25f8dc613760d5d3c52922c19d66f03bc8fa30893d21c1504298746aaa54d6f392074aa945707aa61d5d863d64a22e725c62c1c9806f2794e9cba3fd5a1a001c9bf05d901d9e9d0625adda65f77480e3a0fc61b671e4b62737e0895a5fbf2940d3ea5349dd14787008a280655f2bf041c96261cb7227b30b30e5a0a8f932baa41d34a99289a011569156b17dff9476bc19fefbb32603dc1c6a9ee7c89283e6943a6caf37e53828e238b012c217c914fbc00139ee2ca4e9c62be1bddba271f736b5c473be1e967ee1f65433b611811e0626d2f19813d3d82f6ad3816b338c3f93036117923288555212ad5c909ce4b799fdf6aed3b39b54782db7edd94c795cdcd1693d9ffd4310e26ee86a48251abbaae760599104252bf3cc80b5c33fec52980285d90990422f6e6ba1c033375f08c37dc6e2660337d8bf3c34bdd98214c4b5735d42aac8fa3cc71e65c6de39f0df96714f9aa3e9aec6b72213a5015ab3e898810df75c00c0104a050c548a70ee662fa67b2de106262c618886bfd1ea5f6bd7a46010d49165b71731f1b034ab195ce7b0978cba6653cfd85fbd86c155e083ea6cbfa5a092c1f9ce96324b6e34438f0968e80317a0db446b4df0d524b6f2a6968a49e14d78e0883a8b6cb826679ff4a73a83086e903134cef4b1a6b6d28457eb5564b57f68af23ce6fa4a1283bb43966acd4b2c5e6cfe3445d27e1ca1719db1b3f8ff19f2d57295e985aa650bf7a037ddc8200db4d0c1e38dca2a71923378b9b149a20bdd4a3e6e6a243ec843c761bb3eb5a5a84da291431a8a941b83b181bf1b237049eb300d6f6842a281b5e997f089dc6f3a5c582e6da34872c0726a3bd6f49ffa4c23d4d69fec11a58e7d9e0edbad20eca69754e6488c27ef3c8a1985164767a3cdaf74969eaa8a8c3508a3dda5e07fa2a5ec403722582b46d394b451033fcf15ec7f04a2e2ab2721e65682e419ba509e431d3f1d143eae20e0ad6efd2d6cbf036604375aa71977d0900c6fed6f42078ce2bd45f8e694ce8dbf5a3abe11580817c179ef81648c2dd29ca21d1ee96c62baa78a78284427c1bae1c503abb8ca1d8eccbd79fb5a9d0c4bbc77aa60c5fa5743b2f3e8126c94bb248a1b8ac29c886ef785b3b7bbf258c0590224a15a99fd88382689976eeb480fe4890576a40f4ffa5e4c4b0f6829f4ae087fc3385d50de42b39caac1935fc9bd9ca0899ce90d0fa2e8a7164d421c0a7495750fd65d54752c84d72086e86fb639fb3007014ba7e8c2ebbc73b37b47709bbf8881ac237d759ceabfc776432795ac40eb0647a364a01e0b217995afec8e985191d4792f30068c70dbf9dffa967ee9f2ff9a5776ebe10d8ab82926b384cb984d6e3313236bbb9b952a294dddd26665452ae56c6a6449b9677acb2a85c190f001a68aad0c8a7959fb475bb8516e1b25e1a872b3c07f0ba3a8aa186fc5514747e313d542ff34c0d2cce0c2ea07ed966c93db6d3d7eeb570c9d7158d171af412b95bbcdf98da7644ea60ed024fbad4754db01ab9e439956bb5ec804d7b77482ff613aa0a1124a21d0d4a7cb077e2f2ac98d4b01bf53d924dde96fa9ff8be136db554b58b76e61f2896f391d6a8155f5f2c628ccd4523ca00cd246358e7d1fbe5c0def6a1e3be2beab56de90a5bf00b4d2af9e76a82b6348b3109fc78043aec28fc23ccb831b2f56369e64cdc50efddc0050943bfc9c9e9e79ff245f430270825191c8ff2bea396e1d1ac86eb06d84f92908f0f44aaba778ba5c9eb92444ed82687ae801b0a32dca155479c1df2263a13ca7b8395f8bdfa1be60b4e6e7504091f02fc203dbcbc5d4192375d9bd6af40e7feddbbff5be03d9175dfb95e9abf06bf63f3753b3c66f368708a4cfca7028618d47a65d10901237343679f39548e317ed6a8e113871271fbb25677070699578e414c5504f9de47c8c88f56134e737b6e05b7307b732c5e9a756f4ce73db7fb9d90cc2aadd8480567e0df70c1eb066e91153277d215faf2c8bbc1706f8de383eb5ad54bb122f86ec2149b7450675b38ad3c1adbcc449c01b6d13b9133a576ad86cbe2e88e137b7e1d57b3de0184bbbaaf0cb86b0de1013ac88b32d2290ba76813d7549a1b951a1e3eba318a6a66f5fd70032d47516ad8cc6e109151a64899002f9d1575aaefbae66a493fda41db74206d78e1c362003c2e70c6179d28c86c3eba822a260088a300d3ee33cce51c466ee14c377041adc45f7aeda29ee19ceafcdebbc2f99e2697a899b723ef1924aacf2f1ef2b9538fd21489914899ed11cb96a73c46ec5c0c191ba27c93a5b9d712f28dc87d4027a696fcef4d5960a409c8f92e2d993523d77f7914fbe0e79ecedba5ddf72548f614e1747b1b0b259019fddf748eee2cc472b7afced67428a0a3785f46e36da7ea2fc6ec78b865cee8014fe62c3570a4127e5e2aebaae6d767a004e567c9bd6db64e1111394f1bef966c03fa7c7e46d496c05ba299e35ab782abb896eb13e8d551cba39e85ad2d67e4c115754a03a17be5d976d78182033ca5a22407c75ed1757c30f26ebe3b9c60561fb0068c6190ed86cfd9dae7dba4630461a3d941f84ceb118d926ffbb62fd306ce0333831ea3e8574bbbbb55dc8d104fadc6e42c5c53b6de0e67ed17a55320468d533efca4d43f679f207d6bfc1957df214a94f3cf60c9cb195c99e16b3e34ce6de3b7f68ade7b009171b4e9b592206e424f8662a51a40df92134fad07311151ad1b56fdda54ee9fae559c3e41b2ea7b0de14c8ad4f174a07bafa5fef8d4096a267db21aa4c4e65ae12935ba7ed994c7eb871f4e0d85074851bb378b06ff4a6d8948970e031ae21aad807b599c62c0f3afd9f1390759aa97af650955b7e2495182549e2f16d097cfbb5bbded03862364dc04f2c4e5fcfbd0695b81dfc1c21540a322fd9bb72a153a5f4f24bf8bc92cf7c6809ef13b7574f25d70e0a299f165e2621ffcd9879900d84ecfdcd3004b649ab5491a3c0d83acbb7d2a7b43ebff2ff082de3d446b5c9bce7816dc660338afc77b41142eaf032f4f5769d411665767a8e19657b9be48edf1986889ee7249615be49f163f1d80adbba9c1e54a0ed1ebc33fcc3e06fcff08ac300d1532676d76207997f92cc3195a6c6d1238c5528c6e5b7c167dcd5339c86f54237d382d28072674e206ca9bc422cdca5c86def5f372a6c35a9fc9fd385b43c09a2639c7301ffd400d50ac1e25ba06ae075dcdbe13343ccbc570da99c54097790d5f6fdf139a08d91556364488959e83f994ccd45f17fd81e1f8b4230df2810e2db9cd6a9c76326065cd8bf5e0aa3c8b0b5ddbc97d412e6a9fd9c3a1b1e80547c3dedd24e69105f464a059b2a3fdeab5ff2678b79542b079f41add5c8c926bc5acb030795c913f49aa24088b236320b061b73c238f8369b63c0887d9d5dcd2d88de7375ec7b658430a1c8a546960caf3e2376eae4f1a00e1dd91f7797893bf50e07af71a2c393eb5bbb2cf7d37d3843258fcc19fcc3f4425bf83f6a5ac6941ea9c8047a49112ac766181ddb30190454d890f87e3ff9bb8c597a01a613f18d181aed2766f6b0546938e796a535a8c6352686329060998e7ea0dc06ea39cbf6b3c378674269522d23500a58655d94a5df0ed56fd980b067c31961afaff7c8d3af07a3ccd0811233e4db14d4a232476c40589a953536b8f25d8a7caeccc0b570c28a0e2fec2e59121abcd10228d7319eb66df63d8641b147d1fb2074b41603c13f660a9e6fc629ef73f4169505eabb4bba22b5a2811c3172e7bf1988ac46dc450901fd9700aa645864271a012231550f877f7281b2fb89702ce670f2414d5538bbdeb3212cbdceeb2bdf6603ef8cd8a2f697a3a650bfd5ca5a6a11b563d6cd5abfc9d27149300bfc97eda80bd6c3bc5d57acaafaf837ef7be9efac3f0a143f0ed46c7d372ac3b8ab880ed35e3ba0040c3dacd90a7c0a99215cb20bc9e03910708bb0a9b6eb616a3beab08afd9ca6cb8e6fa6bcc8add1cd9a919a8e417149e9e9c9d656bbbaa25f0ccacb50963bcb5e994341761734cba0889e7af8b852f451232845cd2dbeb28ba44d649fd29e6ab3a24dd4d2c10df0e585ff42993509f2debf4581dd1089239b280609f699e4a8d15100b53672287c31274386135b35cd929bd807a5c0f0f8dfc07746cb2c7984cfb67e2625a7fe4cb5b5f80282b1de8b2894f1986a3474c3364eea98cbbd3db9583a6be980f14c70bf11fd8aa9697dee8173b44545b40e5ce2f9789c7783c8d37a010e32e0b7caf782dbd197112cdd406a88ec69df83ea3d36eb042f7da4c08eebadf215cc45d0b4f25e712dfd3e5f417fd72244bffb9e801043a4e1fb8b28d6f65f3ae23b5b64ac64c3ef87bec548f1e33baba8854a3a450e6d440337cd0743966d081c578947fc9be1e26988cb961ba31d1f0ca77373419466d3c6a34f73014cfc1c0e7cd3d64d370e582b1709d80c203f0b23d641f05ad377d1e039e2fc348f39031fb345372ec97a289a585c10414e55c6e5989288983390e92500966b063b0103b9eaf06d7a497b380ef7995a5a3fb19a615f99ecf5c467ccee48284c0b8031f6922924f27af1d5ce00908ed492ee0d09703860c763532d013d65d28cef80ebef3339c24823145635b291ff2c552200ae5f0eaf11a04b2cce680a82244a17d608299f2ff868eeba2cf002abf7c5d9c61eeee7b7afaea6af4bf13519546429d9ae88565a933b0ad13630435d840aa74d60c2f8208b3c9aa3c288481fa01f1b3080e26ecd8e9d3e2ee9e318b23256ff27ef1e5f47b745d03ef7075a7dd927008a806603fc73d6df30d3088a9acb6321a8345f739cef7688e5dc26f66340ad2095789d220cba48258b0f928dbaa47c713f35ff7ecc43b12ed0da76c97c4f54370f1336b633e1bf4db59215e73b3ce993ead8c4f2cbb2723431301ab8af09645bb66230519ae384d77cb64d21bc836a2efd9eb66bacd5a665486776ae2da3061cc7c68d39ca853f1b100cf1b48cdbb0edddd2164daea982c4e0819610481b4112be72d32d0b5bf2e4855a357e63ce3e327c63fb58f563db2e95f3f52d64f97ffd5b34f09236d67b99a14e295","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
