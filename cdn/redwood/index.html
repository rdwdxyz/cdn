<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07639c85cca373aee85f0e1ae4d60affa99f18956803795542e8f32b4921b04ba39b94ec87b9100d3285672c1c3b96914c1f4c09b8663ae90c40f4fa8cafedbb3b27cc1b6d585c98d9708011c0794c6a6b0d2523fc342a5b637860657a05826dabee2af6e62ae9e8d4fc3a20b720f4f4b2c57aa1c95ecb53965c23af40014685e3e2afdf4542f19ddc2e5b9cd5e85927ecc0e2f671899e8db888cef793f9f4935d2832e6a05eb7c787534cdd181930f8eeca2430d2766b8cf046b40def068b3087ec49bb248a01bd5175ed541143a0afc5f8b28769cda30d308be6bcba0373f56e3efb214b8b29ac5c8d4ad167afdf185fcce4ca37c4dedd4af6fe3f3ba632ce848334d1602578841f73992a8c1bcefe35b59caf7f23dae18dca43e4153749ddf85af6a491e34e7897accea18526cd8d0dc8038b947e954e90573fb01e279c4d11e9d73f9fd855338ede6c58c593acbf95c1bc160e794d73f5fc6dcdff2d09baa6c81254809e94ade2b980757b138c80dfa3e736ccd2987073ca6cdd24d1611bf082ada995b6ed0cfc10fdbfb1855d8ed1ad829ed0d6fdf7bd713b2ae0da4d7e06456e31fc58e4d83a51b6d90492d275ed47ce2250252aaba86a12829b891ab0b7f763fcb15843350a70d397118b23f0ec73f95d723dcd9fc17c430923c80460589d01b2fec2cc6fe50780f7e74bcb4e82bd4bff609c3a0cff2149b7a61c5ec22868c29f6de130eb344ff1cb7b1dc9c2f3c8b212ee8b89de8b0bbfc628acb80948bb1b6627ce78421160c3d065975b11c59a906e3822490f48bd9f873e62db84d08be0bed7b30d4dfc78d86dd153d434f294515dd9678aca9ce97c20e0f53ad1c7371e1c1ac08cffff805147aaa157fbb8fb845af8d656aeb73cf9d4ab7587aa331a1afd0b988dff650e666e0db64f1cb94d702229eaa49a4eacf8448db6c70211d0502a370992c1f6d966bb1e37c498b2108ebeca5e8e50dab976fefee497b5109c9a77771c6b846e5a1b5c2ecfd4ee524ea25fec7ecaed20a7a108aa4fee36e620466d663dbea06d58caefc1f3cc41c222715e462afd3c2d154d289c557c593b60e226976448a5aa8240f435537106e9287ff95cdc80250e0b13a849d8d29320d372057121a1c4d4c569b4d2f3c140bfbd10d654d8855545c9742afe7714d106f6aa4781cdf3cdfe7cc71116971108984663f68df77146444fcfee1d365a5ae4c903344263f39dff1b09ac5b0c42c934f8b541270aed0e537d9e7ad7443cbd0475ac713d74f1de98b0778c700594374a3f8a4c863ea7ea3cfc05e65b9be7be159c13fdecb467334e053b7b687ee2c7b221b8613d4a4993dcf5fbe2bc57d6311f96649ec69df841b0ef9b8ff8ce215c30f65eb27a4f64bd6fa5e5039afbd00caab32be8e28f9a7b0ce61189749afe95309113076d604079f405c399f173f3bb43f4a6915df3368df7cf5b2fbff885e0e52a56ed70ebfa5a4ebe4202231db88e3d8ab737065ced30dd280a4cf19af257e627c8ab93d3df277216d6a91abd1a7e1ddbcbe74e5521c564af95f96d7f884c39c6237f1fbba761d04ef06e13e58003c4367a3177d9a74abd783166cec98aa6f0f346df14b86e76ce7894be372defd35e9ce0ff06c0ef12a8d163dfea426fd6789873d5bd3c06b53f9b1fb5b1355b8f65cdcc5f92a94f4dff8f16582c9306ebd03f11999843cfd77f93740c09a271bfe0112a502431e9d535e7cd19706a3b07ab22af16b2732661049564b636254e90841583f3dcc81b983824af0db6c49357a005b9649b59b3ab5bc035f572ad15e91a2a92916ce188055ea316020300faad2ff322d8bf2ce5a592e259007d5eb44e906365c2e22b00dcc8721ad57addb4c393681b75227f201af706e691bc3fa14220b0b530f79156417c354de42956e94984670abfc5f6c0e0f710670a49a0a0285bfcac6bd85f2f16417c172d4b235a72849aec7d04ccbf6e9b7134270a56b359f24bf9e0f65870b33ff40456122f6cdbeb434992fa7a43c0e438b4439bbfd30429ebb5fad6080cf24223f7e00e4cd07e16c8ffa1ff1a089357d4a0a7f7c7c3247449e390e0af9b2d75719525b40a9d0a37221cec66ad42151f4c5910b0b3a4fe38bec5e3c185c0f35f2d30c002c14461c79ea42c474eaa5ea80aedc3d3458c5ba7178e527fbe13960e913864517a65fc3af8e92cc9546384ef75c836b1d8c45ec30b0e3db1abd2fe66ca3bc61dd2fde5c12fafc244911418b900cfee31ca8409cf62969b6080d131fdc07bbc9148cbebb89b5d6a3055f1ed8625b0b3626da59710cbee25127c57e3e92b204e15a39796941a267ebbea6498ab0bebaf7ef3dcbb721f07eb09ec41c77a01a1d6d7ed5d62fa22a0e45ce432f57f73019e77c7245c91caf09d8d39ef478dd9217d110eaf9c5380271bd29e05f168c765110a4f79de6a5668a9a6c0ae7e875e01e8ea99834cb36715700c59f31f9078ffeff14e191cc94a73327384e066d45cc7cc60e5e3b47404e6e6051d0f4bf6c3b550affe45138bdcfe6df9510e415bef157608e39b6a368c21d06ce678ae33103d00839457ee7b5fbdab72775ec5c9b378e6f687e290c1f362eb10245dc97b8d9d52e749aa8aa6a7177b67cfcef36ada43c195f50e694ef4e6b96d35e751574569db3aac4779ea3ead54176270cb9a6f927cf8836f9ec8870f3df10112114ea78f50bbe29032e8e048ebb92359e4b0e7885076c32f84887d0ffb806790ce2149acf5bc67306158c3e2d98799506cd1ee7014997a5cec436be174e7eb6f400a37e704e8f370fcb12155b9ebf62e1a70026ef37dd80ad333188f8c175bfbea323768a43341badf5d6cabe9f46c7a7b87dcc9345b92a4ada05287acaa2b51d3a8eb59f93277c97ed1e7527e8c58f236d15e096eb1a1769178e887ce1392427cb7f4ad24741b604999a27732488df45d5163faf411f99db14dc98883970642ee877e1c7e444d73617b62f1dabf65d6e148eec7d2ce0d2bca655af394d4815821b09d556ea8973a40400051812eec57b744819683ad8379d7ddbaa229137eeb8948c450a4a7464358d031fd911b4155b020ed0b842c6ab0e3a4b47f8016049501298a842346fcf01bfd68a4a8cea315cc4738c13b51a211e18085a5122017d4b462af6338a4e70683dfac80d783031db0fc3d1d670bcd671613acf08058770eb91cf087eae0d66edb134fb3dfb6db671b36dadbb048281884ab57c4c070f02b1bdacb1e76f62783d036c7e2b1b08297fcf5a84299587b781b7dd798d13fd825af9e210bda4415d2a6ebf5422ccbac519a9cd1babc57153decd60000efb0a38cfc43b99ce90e17556e63fd5a0faaf268e91e93b497622ea76ee9123e159302745a2e10750f4d93b27607172309da9597369db343368aa0a90b24394a8f572474b523ed0e3aab9d2e5638a06a89c7f22c55bab8edfcebc8bceafb0615593bff6bd5d7b3d7c1a4f9913814963b92c78617d78fc82021c7dd0899f134e7974627853d0e1ce83660d7ceab38cd60a97d0e63ccd8f3843fd79d9a25682374037103dbe672ea279f52c2c5fc4c0f01f90e4e7e08076bb11ba88df5804dd52aff05147faad3399310c5eb1adcdd92317a9e14c70ccdef8dae81a644e4319e3a12a93372a80c4930672e8f73e2cad7a29e8f284e34701fa19be97f1132850b18aa9ccbf1003d2dfd51dff31a037290a06c1040f24d42bdba3700b56e720d95f9385ca585fb4d4ecf7534db2dce0c174a3023507fff268f5cd851036cad6ac6e4ea81a64e1fd2f7f12da5c791a7fd16093fbb323a58b05c73b1bc6bf082e4982cf2045dd28dde230b71c6b0a8dcf85adf79b41bf20dacd060094afb65a1b311294592801cb18cd9fab91efec54c38e8d4f8ac329541500826360c87153413475855229a05660c6301cd49cc86a6a69dc3a57f4395337f788040d9a74fdfa3a672fd9ed4e584d718acba36883f56807a9e9e8617ba6e283863fa2f723e9262ad9f870d8902218708aa7d2a9f7b156830bcf269e8e6bacbc924605c038d1893e247f4405d20057a1e1930cbc13dcfaee3a110d3339bbfb1ae6206f4b9edf39d7870c18b66a322ced63c52bfba053849208aeba585a9d4f1a38aaac338807b05fedb1ec19793db5a8d679d5d26051d7f1dbe71021c36ff4cf9f895f4be3b2143acf035b11c7b60765b8bcf04ad520349f3b98c27d49a0554e975c54176ba94086a080f99533f612d273a828dd9399383f92ac0c0f9776bbd8622eefbe75d25551e92899f3f1ab4ecf13cb3d64a2394e8f7d83d2fdb8d0e86908ce5587cea57df2644bc3502da8cb01feca93f2da71a04760655e910d7e144fb03ac577865765fbbb0a46d8499807ab8026907439b9afbc91c3264ff59512dc89f0f9e5c4bad96cb14c790d6873b9daded515f27693f0788c309223a1d2c6de384a3e2459ecbb90fa3e399704e54828d71ec0160cb35145449a7cc01fc0e73f8fdda4f0d6697908a8e7f07e69b6b7ea83c72a5e629ff47febdc9c7b7bbf4707c1de9d25065c7164863999393755cbddfb93b00d3fd87b2835be6cdb395688e777f6f1d8f67d614b0afd2f0da8504ffd39a197015b99b06ee4e598e0a285b78278bca7b32c9638d34c7b2ac2b55f27bfb35bf596b01efaf64d18912dd94cee21ca7c498e356e396d34fe32da599b855fb33b193f2621c1b8944648f3fcad0416d1e8da68a881ed51421f3dc4df6dfbd527fdd03728f52284db22d39712ce3e8422cb11ab9fdb06152b4700a292781584438f54700395809b6d6f70f8176c5eb135400afd697832dcefc31f00ea3b9cfd45dc3b89ae71e5605cafc68695cb7543b4d16b69cd5f0926ec0954c32ece9cc51d299cc4fb6b9f0ab9dd79b92b11d213f1627d3e0abfc336e20290eaead39b39dbbce2480efce0a29eab60470f869e7cfccc288cd968b45af5120a0f2a5322b2aa28e49168ff0fc62c9b948aec5115159c3f409f7c3a6c992d282ebde1394699cdb4abc6b7a38c0d80299c05b1f5fb0dc4072b95610605a7910c687949bb2664dbc963f3f1be3b11f6e2f8bbc8e1dc8c0148aa1b7ee039cb2866b6c55880dd7b5f805bed2c07d424cfab115a03a937a0a5162540d63f4021cd61c02e95fd98d46f592e07fbec5e78beda8031cef7448b7a499721e27db556a89b9f401c9efca7e0762a55b15a15940e47297e70aa1b1a21ca81be9bb505aadcc24bd7f0dc06e30c05d9c0aeba3a3e76bbe1dd94ea19d01099d66b42258d58f759e99e1311e2deb68667c64b4c28b1b38190abb23cbb6341d40d10e97951cdf7038f77b6795dcb69397d67629f3285741cf196fb2aa608513bf3d4aee85e8896d57ec85a3a5355c60966c5ed350dcca8d0c787d1c9acc225dd4a9375fbd39d1d6cf956c46e158db3a2c96466705d5a8eca67a96a9ffc397a11d9f2c803398c1e33d669cab55608310b8fc4f26226665d17360017cf0dbfcf323abe92763b619e2b2f3cc5f5467f0046ad68cffbeb84e2ca9049b6dfb8b2b36ae19b0ec0b4b13541ac32e510456e2de58e2b3fa0e358eff67d4cc3be2ff42556bef10ff50658233a02e21aed663c681ab9bdc5188e9657e2e277b7bfcd37d05c9a87deaf1b5197fcd522af199f0891290930f2dba0c36ae3eddfce2d67a0271c4c5cb56f976f3f19e117a99d2051ea3a38814eb42c063954671f976c683e41c81c320cc044d60e87f9f98dc3c566f11a6f734471c920914a1769bb98eb79813cc6f98de144e7b5186fba6963ad4785e16da6eb3a270832fb02a4851f104cbfed37a2b546b5c6023425667f529152f7e6edf05e54e14533c73985ccb7c934df033d9d791a81b5ac4c473b025e7d35017b034153d44c2340ea4a6a60dcf453978518fe6df7406ec4483eef1c328352d6e70bdadd4afbeead6c8a01e453575687cc4189b5eebdefeb7598f11b55c379d27a0be7095d0b7649713779f30e891fff44159a862951faa01c13789cc3f5cef4d858c9feb6ed50baca7a7a889f184a8b0f91bce775b3bb93ca26b9ecfa81ca76bd92a6b24d415c62904753a0bc83efc03962f4363933635ca0abc3a4176fe7c2eb10f4816f13b7d57b18467dd3e6fa07afca98a3a42bb5a76ed470bdfa1595b8e268d36313b3395659e3e4682d121d4d18aedf16332bb4e7f77c30f92602e32c14af186d9ddd2d2852ad506979b6cb54c5fb284c59eec0226b2ecbad4ac596e11b7005c2cea63a993902493ca128cc876d9f6db1ac11ad13d489c275c10f5249b46f97f84d3fdde9a6b40f41f1484baf0313646b6c4c2e3c4fa6f9833f3493cf9529ac73124d27d4bb249237f7e39c70874c87a0a623390674258572071dd1d286fe5f5ea93fcf25ffe2e5d35a089272e60540c2ce776b8d1b473259f5067c32452cb52d60ab9eec2de1e84c1c0f45f60008cf33d7f378a390fb63676555970d83c5f83320a6165cb7b9a660267eedf5648b36d09b261ae20f204eb3804f1f0d159509e767423a3ee640d44f35f7f0915db30c96dcd3817c56c68c334443e28484dd60d206313d95c1f345dbfaa6675fef425d06e61080641937c34a28514676454b5a92777955ff9b85ce75deea2659e2db6675b5fa52aa271a164254c7c9d28d94083902a51cea65bee831493e1bad7e632af63a66cbd4003dcf47cd6ef0f72189cd38d75be253f7315fdf9ecb5ca7e1fdc144af134cedbf19311a5ac6af4ceb3c2dd47699d059ef029df9517ac50911a57f11414382b75b8d601b756dac5fcdd38b1960eec49d2366165eb98bd002308084f3edd5f9c38370ca7ab99294af4637df981978b2153c8d4d92b2de297a96b9f91d7e74df8b4634f5e66b30af17ab182b95960f6d7959eceb81bdddae4130d835477f10fe3235f290816fea9e6c3f192de5cad18f1e1ec61ec08d72c4d4b563d3e9bb19bd3d2d9cd6fd0f5fb3752e638fb044bf75717619b91b0e43dc3ca101f6d5807c77b8bfa0c443aa8da2289187ead2fdfeef69cc2e79954ab6d7f859aee6c82f0f3bdaaf65d9d32210c4e882345a7496dadf2c89a9759fd0544b3194a1f53a0508454bb006d5290a6f6148735a5c7bd135930f1661626429b617021d15c38698f8ca3f9e688a861bf5e4b78e36a5e1f289633ca63a5e59e567da43f2f289942eddaaa0319c12c8d907ed69abcdab40f0886f4123aaa34b8c15519963d2e7e925bb6c354d56a06a1484b5bcf8572e0d827e3b89882275e7f0eb548e4c453be238a7c43b82346596fb702d6702a41055302ec59dfa93de3e0803a4f9ba0032c1fb48f5ad974ceb538cce6b2b66703bb28f9929fb345e881e3ed8b11728f76a2e49ac0f73fe7b6c5c3237f0733b3b6953c5302722d9eafb1445d5bec00bff856f9091ad511f339e4833690446445dc5b545ee9659162c9e9a91e933f541a645cc8f50b195b1c4f331e56812fca4f40a4b9ec2247f00a846460e5b84123a58f08dbab8565622c6956df04546f5da9acab9b6a70fc72f1961c5c3ae8208d0183fdc66a6ed4b88bb8aeb2f17f43ddda176c6ff64d5cbafaab0d27c7b7a1a175e10a8fa7b0893e51074edf5c9d3a96dbd511d2e88f9f31cf2f8e7571d7824519776a573d914b3b6f7b18fd97180e479b0219683ee160d4db59615868e5e0d337e963880944ee5e9a229166b948c9d54cd89a85b5035d25bec36161e28491dc7546c70fe1f03c7a7ea8a4ee4cedbed8a140a88a18894787cb97d386902d4d9c466c3e282e8c8c31510aae495de673af869632a7ebcf515c91c496ed72ad3b6b67c31a3df24f1052eb628ef71c96ca6e1bfe2de30f7df2f24d959381c18303097462af21b9861bb4ce184a4a21575d1af1956325eb85d0d1e6251796e68dbf5272695d268a780f6e4c55d0529f90c3aae90c7680c3b523691a0739c3462c99f27a4328d8704f3e41e8530da79d2f712c05657ef4985cb8edc4f16cbd9c371b894067dcc32d1d33aa74e607258547538cf82cd6ff467e4e99c71fa332e3c7365cc3488c4e8b1f7e936839a5d30384879f64ce83d7b61385ec10fed5ae99e3eb8621c78622cae9a0d642cfd14246c9959c271619ce876ee349e963ddb4c58840eb201cb0da68c3df0ddb595271de1e9c16e76e676ac9f507c468c21af8222dccf5cb432de9025ee4a66c33e38f47b0f85ae147e404dd7cb3b197000186cfaef514adf2f3e541cc95f58df534a5df9f0db1b00dfb39cfb6867dcd454175e596ab94c28b85db26abdd4d8e0faf4a35483ca78906237ee4e90dbe01e082816bf11c401cba6cd8eeb7817e165db6da7acd3be88b5b5e5a706960f73d49434b570d29016c7b4d0192d8e016ab4be6aaf58222850d7411293c9045da86f3ebb6d878d7d2ed78fb255036e5d99836250955c0a8b48f93b76746c8dc4139e9d8d242dc0b3481b105695253c56064fd4cf8cf243274cbe2b7c3372d26858bf43e13a8642748a9f58890f2961cc8349f2bca5b6a0d04c1c01504fe5bf7e08617119db4ea424d6199e5974db4750f06620f74e2d9e663b001a59bdd2cfa3bec150974c4cde20cf013dedb3ff5aa2ef8d1236b1434438fcf24e756b730a5c42f235363bb2cc62ab81f7dd60a729c24afeeb516ac07108222a2b4d7f1ad207500b5843fecf6c77d0170166e7c55fe94ee07864ebc47abfcfdf1eae76989e6d874af45cead31a428e0702958314d4ab485513c276e4b949eccd1e927951bde70b344df714593454b98803e51cb7df893c68fac39955cde372fd6b6f9299f0caa2f1daf3f7cc1a72257072d6f4e6b50d80944ccc78d3021e964d3e82ba9b7d378176442d165d38adb54b4efe525e1adeaf737b4790b0c352bcbe04198450f2d9e42d998252e6d03934894f44029845e5875a5c03e3decbcf730181e85684d62ae6d45e80b26642335e9a164c3e3236c6ea683bca203e2f1b708a288deb12e2079487178aeb05f8c90dbac3be842fd400e30c846ed940fd64548e8fd1d70d88b911e4c9a9b7746046e6a94054524fe53c5d9a23a0c4b752896ee319e0831e0b760b1256557cfd2929a222e85826f13273620c44511e2e17d1375f5cc42c75053c3e6f8d2bd8958e33cc82db8cc2a85d5d33ef3ca44ebfea9d0f98caf29ecb6f6f6bc67fa53f6ceb0e2b7d6dd57a34160e4bd013f4b3067f9dc5405b848517df70e19bd085c09779c7d7919e76feae033a6b3d9edf9fed6a0b473946cf95ef916cb8746d4d96dc2d003373bb6186ec04b831efb45809d14336a7926f06fb9ceac50772f75df2cd60469c617fd505c3af307fc1114ee3d1e7663c6266a02e766954ead4327fcc1a5ef109c28efc44e68b964417e4883a45550a9d925a4ee3f35bd977a048f3c13f9b704dc1dcb5b98f8cefa8a281a92434b0ef66b080c62cd91f2fe9cd7dff83855250234960ae4ef9e1ec9ba0658ffa5b3dbca88e487413344722787aad3b16db441a200396658aebff004b9e24748cfeff08547782779fd75bb54f094cc93e7a9dcfa08c1f0f0dbaf3f28a499a8cd38e121dcf923fc01c1dca2696d07fb3ea35951825ed4e4cceebac990cbf782c5be876094fb040053750ca2cac55f624b85b0307fa843570cc079d029e7ab43292d67cfc3866da1a105d088b5b71c80eee6d446e848e0b462929d46babc733bd7f042d6c7c2f79290b9185df80cff9cf16481fe277c410c8cea027f8e1645a91dd415352a3448443f512eff04a85ebbbf7d513117408035e3bccf63c7f88368ce8da5869140144554b4968f724e1f669a3a5915bd185b489cc17b9920ce2ead56c8434c1bd3885b9dc465784e45996f2241ea918d50d3b89cd6d788a57386bc78f85e5a06947584b0e5036112480758cdf38841baf8aac2f55a624c0be0e117cd2f1056907c50b1bb291b4afef065bd9632a73032029b91dc881180913f6f1aa52f6f0350c94986c6f97200e7c8ac686080dab9b78168c65c090e1a560105c1b91f011811415294b5e764ddb4f2d36415e809666c64a2fe85c806e09206198faacb572e568f121951b51dacf67aa47da2370173c938f16d7b185f80b88e0272e1c90e69f23c7e30ed2e12c6ae54d7d8f218f53b37ea961d0cf368858ff68d4410d6e59abfd0374a144c882b57150dbce821b6b8698b0c1e1f96b48753ce37872c670ebf1ce40dbf10b723b6e7390dde4c17beb1d28e238a8cd08131a4a0b9561cb21d672c4564ea62afa236358eb44ccae3dfe1fd6e4ce01c4e0b2c68a2de7d738c8ee156365ca0c9b6509b14928227300d883213c6d00b662fc6704fb0887897a96bebc1b1c4935e9f4cf85a960948c1baabde133b67d32565935526c2677040ed772e5f3def3669e6e17e144c6203d343d8a3f52cbcf4853ba0e39fb5ebc17634dcc8a7792c23239d7e9a5a89e5fd5d2a60c7a709edaa7d417ead92ca53cca582b7f3765de21ec221d35b7a91754154381c03d383b29fba64d235963e4e71362409f2ab91d767b8247d4894d83ab1147f8d77b800d2aae204be39e03b56a4084c0803b02ca30443823b7996312c80c09f08cc14fb249955c50131feb855f18ec850916ddb373e092111e67518cb6d03cafe0c16c077077762733062e31978adab71756f904d0841b32a169256db95d7b567c4a2f0bc4341fb13078a624fa10aecdd49240d2b67899529544a79e6fe20e3d59d9d24dbc26ca36f09aca506f5a08022b3120490fb7377c4b17d66be7f2c3b5d876a76e03892c45ae20cd80d08c872cece2dcd6f7af68140dd6fc2643e6d3d8ed3678974d907a2173bf168f0e8873919de4ffa99586817006a31ee00e1d3233eeffc1137c6592d7cd32596e74e118e09e81260ced1abd5c18cb3ccfcf82bf8d83404dba5df1a938359fa3c56e0935f5734fa588cc408734f76d188fba2a4c97d103361f82306863dfcc383f541fe035289b8a00189a13c35a2a9b95294eece27feab5420ad0a4c59fbf265d496d89ba053b9f9d05b279faae00d9715ce50050edd9de6e22022fc529db0cec26b98cefcaefcd5b5c461e9ba2dac1ee553a2e6f328e46bcc3146b26efef04170a09a738d0769528dbe6ba1b9a2aef8492380f0825804d9505766297008960d3e7d5febf3a9be550f483b9f42c7b073147735d20227fcbb2af18cb4aa51eb70e3cf2d0aab99190eb7e1d1814b5c8657c07f2374222b43b08370fa4c703401470c1a36594e5cf4919e9668e87e013d2718b4f0c4627fb0acdb50fb03e11b494b23eb107ddcf9ebe74eff957aa0202ce30fd8815062f76a054a4b024e255059f1f778dbaad0a0ce2644074d9afff012f295ff80175a799eccd65143c5044f9909c77dc3d6816683b2e644ec6007aa63524c60fb9501dda5246ec26bdd7aec8c51aad66d99e9bac954c443ffd60c7d32d67f4baae86615864e306fef25ca2dbacd46be73e5a2521b37d996cb86487cebe39f8689c1cb52d37d9f75246fcda9e5e64bafce92dbc9e07e309eaec57cc97cf8e35bb9215e10fd75ea191889ab944c679893246ac7f9bcf0737cd2bb3511a9be0b4dc9d1c7ee7319aba2096650760e5c1cfd8b9fad9bf9739b97aac786c915650c777c07381c387201e458a97c072ddb72f03f611a6b424f8f95e71b1059f6e648d32c75f31044f93dd33b027aea7c671139ce8fb0060168322de51b281950d729a814a8696098d4cbff8171323f42655c022aeac6e0e1f3b3033c60a9a26b1605717cc9f36312e205187974f4a2a1be5ab04d9e7497a0fdac391935e09d0b576c8ff953b2e00818d1bc206c85e915cc519a1c1a3ce9e773a8f6f06c1949287090bb03bd05df4efbed45d4eefd041d5a17406304b08da4870cd97831a419a2130528a46cf56a841cc1565fb57828d2f2b098638b7a49030afb4ecfb512c3a7937a579d5ea1961faa775c445b60fa791e1d90c0514b26a992975ed2bd5c4b2418ee1df04c35eb5664a8c2fa5c73ab656c6c71db7e5572f603ca3a8a680d9b010a1dd462bb764ad413c91fc6073d1956ee2fc6abe4296cb7eed4983e6bf2c83a021bbeabf04121edcae115569ffd7ae4465a3d6be6a4d1a8eb44b4092d1f0d6f925ba49d1b8f1533301ac58050dbd542cade3d31278bbe597e1c07a2b90376b08d979ed002b23dde21ea6f0e756334ec70d946feb837a5f39ef78504e8955d0101a0881a59519846ec8084968cd4a80b9cb9375bab950e779b5ab3c8882f896607f32693fdca92bf51c59899197c902551d660828f967a446d4ce26937ad2c4238d16b8861431fb1c4b385fe7075f5db88c658bb67777fdc858adcf9d34abf43cebeb327de1357db20e1c8cf71960b044c8522661754a2e2e11ea519fbd2e0f37ea0066b6eb87543a8c20551a183adcca78bc88e026896f3021c090a878f1053d7b3ab9f78f8c187cd262aa85f6f7adfc155bd6d1ce0752daa4604f70ab409d3f51bb2d541dc59d5e5b6276cfddb001953c25af5c222a2835c1c2e3ededb54b7e4c78cdf37a3d77893ec7e985df9987e269efd252a1b4121345f74e897447dd8dba11e99295565053eff2be8faba01bc451ccbcd3773d77d81a01cbee7eafd4e4eccb22a0be95edbe16ec59ab148acfbcee3cd114ddf7dc57db0b1d482c0852b974274da2925a751bfdb2ce5a3841d79aa043313f9e1f76acd3133d2ce4cb5817b1b1b4c87f7cdc3a671abbd5022f2008b15bbae2c6470d1f3ff662a4c2875cb716225cffbe6352ef8dc221c5ce95c9ff47d5c33c64f4ab4d85f1952fce0ad1e4d0650562802ba886fd0e1dcef1fab3001906b3ccd222fcfbc5bb9f8c0af2023da5474d79dce2f29070ef40902b18456acf3dbba82282f2505aeaf35c421414b07e5142d266d4baa56b7161ceb590ed2f58cb4ca06099f8ba2d4cc5e74dd6e50ec5b5fc20c99b62636fc01b112ce64765be58ed44523f972a0bbfd3c1a2e6d4e744dadffc19f0dbdf53631aa29bf9d795fbec1407678494c659b2be79639f97923442338e3521b702b9afaa3c14d936d570b6399d9b237d720143c0393a395d5b98c3abd5fea142e520c2bd1aa76eec303dac9e4ff43e081e7ba55736a3f16500677c61c301eef792fef2a91858be9c1a8b29801104ec27177498068e9d0b95936f5123ff8d1c10bd9c9f7aaeea8eacadb2d3738970da71d712c9ec4a8c53344bbb024c5b2c1d17b3f4be9575be28d70c7ac0fc0740025c6e1878aeaf198ba722d3ce96df4765192fdb671e36aa221ad768057ee1f7e30ced4136072a25ac81b46f42704740b4f8b5a350b258b0f25b8b0ff53c82cfb01995b8547aa4b048740602526f50f722afd1232418e7851d5ebf363b490a69d2f79e4846c50c03887227cab55de415efdd33bd3af524adb954b321e378ce63484a6afada51af6f600fe9e4554a56bad76bb6af5e698a17b42e93c8dfdd095b900c58e0cf94d92bfd0180bf8af60d1a7486502aec8697e01a71c75b3e6de4c3704874cb690266ecfcc2fe9ed898b3b126919f7b67b67d0065dcd4026a3462a9700751faeed28685b925c9496de13c91e4d03559fa59186fc0705bad106843afbbdb6e98adfb4d74d45d9f7809aec75b37e190a55a8308ca03ce86bd44f54a223e97b00778a4607cb16d5aa2504ef52436bfd5952b60da9d0517814f0ecf239ef32a0f901e162c174a161d50df3fc45eb0997d60b276fe2c5a8863e5041a7203f628d996d62d12b10d02b363b0031263c2cf5b2cf7f0881c09c16abdf43e3f967b397bea7e8473376890b8ad580c4880a25c636fcf79b7342454516d80e8b7ce48bda8db8355c92e518f72a402513469f24bd30e953abe5f5ad4d02f95c0a7d35d28efa19ab0e93c78266a0c67c7496ec31527ddf6e3b67d5de60b1f3b5dcda105695bb2d60b04c856c116a5573afc55e17f1fd82e90cabd96d2cff7f6bc9c403d1f0488395e7b635aa1357fc794fd1314cb4ad1ebc7ac21eb928f91b2727a3d766358954a41592473814d80b1d6ef7b8b974376365697d131644eee7a5219dc9fcc726bcc7fcb832a36bb9d08a7334a239db052d12566ad5320b558787375eeacaba650151a634ad963292c52200f864ea60cc21543859b62718f8ce5944d45004f4bab4a899504ede2cdcd70810f9364d27f493a2ffc631587d6e7da5246b31351a6814b494d4017de2ef4ab918aa61a17da6327c9e0a05438aeda5bd0b134ca711ce1e42840b0099cfdc0bb882e0025e351b111db9121fe8424e197a26c80a105c66484e9545b191192c6ec46853315d0fedd43423e29875bc01b64a5cbb93e5235b1195410b3a35c5d443cccbf136f9619cea988b1086076250145b29b84798c8843fba446c74a07c502311e9f51327b2e3906f81659c0a71ee93e020447d5d99553fe716fc965ddab6e6b00b68dc2c8747323e185ac9962f34122990db64bf1685869f0cd0adf42b330432227dbe191e38b18480e6f2d5d5fe454e1cadd23ee9db1842161996c5ab69bbd8106dd208fcf6d1c6e1e61f275aa46219d23a9fea1ca3f4b384121e205a54dd0c298d732e16a31795eb2c5ab563434a7ca34260a77f53dc0bb5c8fabdd25c29696bf2098a168c0bfca36f4086461dec7aca9b2d04f89431af7f2a7409fdb7a5992d9fcd8ab254c72e27df263ae9f2c461088367f0d4baf9e3324cb6e64431aab7b762d4fba2f444a330a1448256b57fee7c552a80309e7a7ea7862261ea9ac2f60d0e0b7fda306134991f84b7d2fd2ea04c07267f4bffa82d55afbeac5d574f1d9536e39a625d4bfea1eb0df820d87bfb64966586bfb5c7ece498669e24fee76d71df598a817360edbb3904398ba791b8623c811516bbe1844140b1f82ec55f6eb9495a48ce188a2a79ea76cdbea90f4ef36dbc69e7bd3b6700fe4520a6c844c8c0cf12c6e81179b1edcf3b24b8563ad4599626fec0538a65c1e49037038b86d87124389eeef74d4a769840adc01cab3121a81c71ba77e24be36032e9545d18755a7a3fa88aec941214623762506654b751cff012080142255d9ee9783fad6da95187d7e91492ee0cd5527789e2ba6908b6576628c6e2a5f0a7ea37c0f2dfd0290f3219b26dd25dba7ed0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
