<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4cfe1fc9ea419c38c3d6da574e904d9cd9c2726dff677fc8196b78a51d4139a453090a6bcae139a4538e329dab86f71e21834ef332179e76c8165b99df6636d8e588771ca26eb497f0707bee096727889e8cde55ed6f6f78391fbcadb7d978c43c96d33f827b66d58c907f36f56af0bc82e196ba1dae8f3e04fdb3de9ee601ce20ecde1e9f7e0d8df34d9ab224eba51f562a78b21f7860bf320df8fa70d769ec473b4cd8cdc1ddd9e9436dab7a716434a302b3a380718d744393830cc850ae0a868a858c5282287a4edd04e00339c5f50c97478f5835b42be6edb8bf5a2f398f5902db49f0f39b05b1810bd88b4c2ee9b28b7783eb764c0dba79bcc8531e50d08956118a5881f240fb692fa17636cd0de49f6ed8b37cafb681a54d353c001557ef201a58c2e8eb5f897ccb2260a214e2bdb397a910d0d34bb2823147bcc215b28b3b449618f34c6cbac47471a1f6ed98dd314f77c6a1ac82c64b7a5b5fa5b97ba47186bbb2a35e127791965653dbb16537fbdb3eff8ed1ed30942df301ede446ac5fe1752af307848202eb2b6a7202ca37a147523bbb4d580937242d918a19108443e5ce94e167526674283c4b3daa01620db7c0ff6776d10d86a51360bb21ca1faabd1daf4310bac688fe5538e18ca99f4ffa0fc042aa36a0d653d60b28318af1db0f03717ba8f90ec3257f8462c8eea7ed86a527b61201dde50f1d327a1a0a28ed1cc75118e7e4e08352ce092b7fc475709020133063375625afe19a229ee36ec8ebaecf5e6525243e88258f16eb626ea459af6aa61322bb8c36a0c04993b786cde71870c0500be5a568176d60a3c7a40ad230fd1f979bbb6bb3dd8740b4e49d6fb2cc00eb8d6aa5da700a31cc41ad83aca46c58db91f855ac5e6319bffd100a2356280aa2c8b0fd87b09a4c3370165c8ac0a98cdf3f7d9ff29495ca9e0a5caea360b43291120de53965cde38af75c9c0349e6ebd912d1a4020b61397bdbbea605d3c50cc6bf4100d71504e9bc76f2663532d091d1eaed2ee79161f2d385ce0915c653f4f69efa359fe24aaff82a4df8948e6684a3ed3ade25fcef524e96768f0d6628507a402b3db514e7691c0ab1ee290dfe68b844e53c2edcdfd644a898f08def724b8d9d3e4b97baacc181ec84473713ec188f5af83596943de1468a79b93ac56a914fbe7fbce61dcf38a0b6c1823cd6489338d201cdd3013183b1537cf49762a40d42028a02e449d21b6bb46a9180fe2acc022e5f12e5fed832f07397c347ad35f81b561c07cd84d8c5392ea59e5322f0588121840bb4281350c9747f0498abd6eb60b1e75bc093179bcefb7d14ad3939745f8326ca680010f03640ea9f3ac4ce91bac18d583acfc26b01b037b8e4f6887e51844847a620440e82a9089043529af2d4c1dcbee845674297e1ae44d8c52e95f3ab437a6b03fcaf3654d818ac55494090775cf5c42e1a09d5e8aa3da0bef0d5015baea1299b875a06e3c9c9665b35d30b56c501c1fa3f83f735a12f72312ec18f6b3806ce02682ea63ffb174197a1f2577e931c3fd64cceb25aeca2251178429458ea0f5d2b7aa2dbd434f7b9dafbab19cb33e8dc0b3f496364ebc4df24834d62811a0492253aaabef210d0a23845307752323649a39625f9e015a5460a67a976ab9b00c8a7fd2d27b7dd68afcef4a3680e7d3f5b05ef72c8d742031dd99496b75e01ac2e42d7a7285e6f94df021da284ad5debc15c819e3c34ef5341c1fb0da5bc8dd4c2f5b184988ca5e5758e4b055ad25aaa0818d3c3d918bd3f241cdfc0fe548ce65d75d1fad09954fd91f102e814d46d583fa0cc3d846fffbd12247942d202dde59a54d77d00f5c5f6251637bd1c159f524d8adade96e845207948f586818a7b6c3dc31da151cd23199dd27505f838ea7bd6f4e8ab93718bb0fe7c83f9d486a3e7f5124773a9086d690dc8bfa95f5e8184c39ba96b96fc05547f1c9f51f6cd7233d9b4dda0f0c9ec098452a7bc88f4f51a06764b26c319f0ea1cd1ae7ee41ba41c531f308af03299a17e680bda2dd58f686f6a399852800cfadeba79aff9a6f233d6dfbf2badd7911f275d0924cc6a75c0f5472865d61501f5ddec30c318877e229c97c4cc57d6dac12aaa4e2974ea6529e3fabb778133b697ef2a56c64fcd8bb2a2fd6183745adbfb8f9bdbcc720de2ee758121ae7f3cc8a3f759552ef5f0d277c349336a5d6915ff7442d5bcca2a9ed1d93dbf31be7738c52010a902d7d10480dd3c7be0d0b599555608b1551d71c73d4594ba5e8d5611925cc4693274b69ef9018cc2c370a952e7f04418505727cd738857faf86999cff4d62274fb79243bce3fe81b9ac18ccf20b6128531b1016355202f2347a9049040b4005b5b68fc0a2c05bfa87da71e0701a77d123ec783bdbe6b1f993a232a526d69883ed41c62ae07411964d5b3a57c1d72b6bbb8cee6d5f4f32a6040f136ba889ac6813ab7d4a3d2c52afe0ab4af3caae68a4a6ce4ffea6d468de075a87d01ffc7d006507b4cdc7e8a84e3f83791e2024ce8e54288ec2438f91f22e7c0665a9f943e319230b2aedbb81c24deaacc3ae659a0762e56f3486d09a01320e009f8d98b1f8e306167e017f818e38c8317ac64671b824f8b7938af2d5aa273ccde439e31b30f490ddc1a8c6b491b6230ff0694473abc6c8b94d6f106485ef3fc8112c3228169aa8740dc9ea671332fc15ecaf4210bb353b1951cad8e42df74208ee3649ab5804580257167b5accd190e0058e6f07457680e61d5639361bb8549945f33ee9a20bb6b1a878d16fa185e6652ba8f137f8bfba28fa7c333285bb8cb3ca54cd73e7ed31baa13c25fc4b775237e585c3710c3ecdd1c157f874040394e5458fa1d84277c9c8fc9a61b18f14fbdeebc6557f059d1fdacdd8cbbf8d6cde48200fb8aa073d12a3f3952b224611ce4d1a12258891c2b1f76940647f7751c0adcc64448c8ca3b7c8a2c4622de69ce6b686c8db06154b37649fafcf775be804c54a1cb40361226c2248b7fc5ced1e86d66a24311d45ec75f252cfb01dbaf669e5052601a1b514cc195e236a3830cfae5a0ee14000d614157f659bef2392d7d4310045692f866a72d0d25b9cfa3eeb82cfe6d464fa68296220cfbe19c3932b823f5539d5de17c5516e8b285930a7d93c511ae2764d43b080a6a099de0c37356010e0894f7e6385b12bdf204c7a53e419e0c212e39efbd352152a4cbca03603e7ff2c206c3ef89b58236b5cb8412f07c06e410550e9768792060fca9698b2e06970bbdeddf490599b5a3088dcd541d5c0f35b32d28e3e904a31e067ed1ff7572a0613424ba30159e81c485c2839f637d29491fad2010797579227865418501964f6a68b00ee145a09d9ed2f29c1e7b48ab5004290eaee1e22fc1ab55cb0f2376a9f54950ade97bd68185d79031320792275af1f75c097b62d496545983ddb1ec595ab02c270154d6b0be19c84d9d37932ef7851e5c0e5a0331e8fb4548ee31b606e0fe7b1d2fca5c4500f6536725ea4f04a2602f14f1ba1833771b8bd50644d221399c778d52512c0a16ce4b62296b1f1e28e1a9495e6bc7636d0a154b5c5de8f908e8ed2d8839b755408827079238a955d9a0486250300567ea9d23ea05f87860893930fa3ecf7d6842b9ce282b91612756f06e30e23bb1b5cccaa16a168812cd024eca35287ab37be71a84836f5ceb2b8826a92ece2a4db93670c2e61b6f510fb9f77e5610fcdc825b8059b3d6daabd9ff7c15bbf071f385cf65e8fab6637c41abc64d6c45b16b8c64502f77dd5ac617f91209d366e459ba9a948f9676a2097c00ae77480bce5704be3fc7d1222e68e8b7177255df981ce8675c79cc1f07cd59087e2d9c4c517165436db71b63965f87620a08eddc9838ca3c9b8fe49102edafaaa4092be00719693036be7ae542e5b4f1a69254f371f638e3bc05555c0ebb2316eadb66b383fbb46b1c8cb0ad4aa5a6be2231215b6dcceaadb05ccb6e2ac24d3f292f5649d45e21cf2b30a90dded5536449eebab21bc2b69c8756df6e54915e70f461788548a4709642124bfc4285fc3f0059afc3044b1b6a0e185b285231e72a0e7ad065c4745098a0c7598adf19a4f59cee19cd853b1f4dc6cd64a271a344935bd3bdcbd9c67ba70eb5d088355a46bc1ec783ce693a5313578d79e49ee08ec8b92503716e9546fcc827a507d09046b96cb6c3fc6eba8e7364d46ceaa9d87ec893228e1c41bd34c5eea2593b83081cabb07c8bd2120e25105277060ec1913f4e363b8ea2cdda0065a90516957c7933687ed3b407615f31a332c7f51fde95e6c73a67dd72b1dce9ab39528c4f3e5c3fbac6134d239bcbaf00558304a60d6fe8c7419a73a5648bb41f960ec07cdfa668e0011857ae68dc286e5bc582029944d831c15ba00c84f21e653d1582b7d7d7e3bf4da000b061ac25b25e1a150130015e17e346f9335d00822212259c9731ea5a0ced93dd5441529b79450214bce3fc55199782cebef0bd81d23eafed5596becf5b79d3ecd34b8c03d7b7510ebc05c051d5b9dfe23e87ceff9d7aac1d91bf322463814ac0baae80e1e84cde17676def24ad790ed7ba5e111858a7eac648beadbe48b5cee2b9f3e88e1ae0fa0ebe81d4a8d78ade425fcf3dd814737b0bdca64ad110b2889881206b552be0ccb29dad804947a28f1b037e69181226b0466490353842e4bd9244758b30e9a7d5617fe2eb06a4a1df7cfc676c69634d040dcfa07bcead1e4b500ada3056b2835342ca9f21a8ac27a46dd4b800257d4e421dbe717c821b03c888e4a133b1561e52f1bab8e31a5ad15bbc51172abc2c2c16b97c1532ad24944ed3ae49dd78f5b66796dc9bfe42838e385ff45beae3fd8705d6c073b110bd94f1f35fcf3a536abf6d3d3f292d151874bbabbd8d0c7dd5100b4387d36ed9b89c8bd12452cc8c781bd1e61164b60df4f284614691e02ff4a24dc137ae4f08d58fcac7cb1bcffe33d11feedaa1c29034d6973f1760fb0b9bde1c2fee9d2ff3edb184f4df039a213d34351d48ab9879d75c14f3b5c54877d8f64b51b00f1ffd9f1f1373e048a2f30ee9c109129346835867a23ef3116c754a5dbabe12f192aaae5ed0e082cf8477babf0b0baec2e38f5a5dc5c307aa4cf75682290549c6c8dea1c33d569f18e8a436f514b44e9803a1b3ed5c910ed8345eba792d31dfe47c9135b23a96659cbbc679154f193abc6824fd3633731846735e19edda55e414df1c0231bcc43c1ac73adbc143d77a80b37b6f9c5c162d84ac17a39e5d6bf183d5e0bf7b4c85e1f911d0245fc746ba19bd75213ddb2b8ad58c253476ece6fe02004ff9163865188e65707e63fa1a4ab97d7584931f85c40c5daf05406da978c67a9b4a8c053fcfcc147c99fb37323ff9478afc4d78d6b11bbf78200e35e7fb60f8ae3be6955b067900c00eb087ba8a87e7e56a905ca2a7f52a95f1a4e8884aa35f1f199485ca3b5aab21521c8a14314845811b98a9be54209a89bf42dd6d55cceedfa7958ea187df8205021b21d15177c2d2d05206227534b4fea08864c5e1806ebeacfb0390c5748b129355c6afb6358081e5c03e52c90433f94923ba2054a6bf7ed15f3c4d960fe750873d076ff26ed1ea4fdde9558cccaf55dcca22045a354c618fdc9c68523ad992494cdc99e81565807c150f4040feee5e12f2e6adf21afcb9e5226880e30b591b269bdb4835486b94db6dc0b42760487a86aea4227ed29fc1acf7e20840c3029d5ea16bc1b8681c8d18798a51bb1d61edc8048856c87f6226ef163699b03c21d50a0cc4efb3f2e9879099ed5bb028982fe4b3d6135b86dfea8f28db42111d08d2ff0b3de0b445e95d085766e15ecedde4e7ae7d542342751289de13c4ddb4ff8c7cdb08b81caedf54d7ebe69e93977a4657a8cac01200e0357df2b6b0719f64b36ff708e26dccc3ec8c40d47a245141efdfd1971ab2b365e34df49f34bc2c58b90e306a1788c290294bcd2c2a940d15593f42c2ce89c34c9024acefa7e4c2b8e5aa1a668b4b4864dbf1b1df6c4f59ed21e2ac46816536c1f0fe81b69e1f1f1853d6e7b75bc918872955c1d1503220f50592b6fd4b576dbdd899998bfbc12119042fa46c46e203209ba98a18259c5092be51d3a1d8e7dc12b80e9ab5f9879661eacd3799934ed42deb55a6417f43044c9c470b746a903c35dd74c20c92ba1f946467673c3fdcf15b89a584516df31e798a4ff0f8755f209c513b96ac34cc5ca23c4154c27c7192547ec9d5c0290e9eaadcb2d6b31dc3c400c9eb9753592d5764b5db582c6ef3b4b04072b1771540d51bedf8aab543e5c0b5187b2bb2e7ecfb4d55ee88de7348f97d117ecca5f05a896ef6427c9a1b0da67ae0b65eca90b1062aa6583a8c3060b1b01ac9ef214f705e6a8cabbd6577364eae32a510498899c1986cee1761a30de90d3dd0d1199f519a41518017258dfba68c2994e41d08e3f898861792889a474559d66ad51c768189c8909c218944940947b488806592de595ecc8901b2758b8399c193bf14917b7a9b455bc70ff1f03140eeb8c3ead4f472e38479cf8715a0bebc7970bb3f584aebff3990a6f99ba31cd71300e37c6a6e3e5706beeec676441d1bbe4b8d03c4bfb3d46eaad257c1faeea9053d532fc49179d1d4a2e582be964f09a24935b08dcdd38fb20d118b12293240f9d4b1a6552db017e09134438cb289f36788371a25a14dd8862dc266b632138f6c50db173b90d8b8115bebff5b3b4174fd4a9300465a70db3694e4650ae1e30bbd9ae3e3061f3b6f3d3d02d385c8ed4e220b445ced281f2ac59bc20d0a3c35e7cb5cb2de9eb01b1c2e8259b57cb3f9282ba5527eeec9228fd67f1491e323b94ceb3812ab3d15b1a6b788a7eb34cc309f8fb5de3a42bdc406544d0be16e36c583cf854d68ea5ec0998a46f47e9c23a1aa337adde72955d7aa9487c8190680385dbb55c27fa7b03237e18001e049b3ef43e46d2cb2f7726400cf3a7997ac93c10a5140bd940429368d09381fb1bf670874be2a095dbee85939fae0cd437b72a0a2baa18d7540ca30c3124f17152eb15c5c154b45d681e37f7f437cbcc10f05455e2089c79685a3ab5447b3ff97e97f0e5b241f6d004b6e9ece2d36e8d4d03b3d124a9368953e4729296ba8970a812c23188264e1f1e8bc941de72a09c0a9bddfee44f24daf97d9c4a5e692ab45a8ab8bae73d26c26fcc7d9fc69c2e90a1d55acb6af14fdfc75ab467816ae2a2bf70373f22098e6f5515ab198e64e9daf2d1c0a4d5cdc24754c1665456fcbbf500a5abe546ed98bc8854aed2eac4b9e189ee85d34d30e50ab8ef55197d598ed79065e688387987482cebcfdfc914d273a620a871da8e85014266dfa16afb50baee83966108ec9d81cc3afb5a0b6884b2b77a08f493fa524fc70a1925fe77d00e6527fbd5123253bb6a734b2734a8bdfb2534f483e8c7043809b998a95e7da39e582be3dd8284a7857c55019af929b83108c2b453466fdfe621e013ed12c1f3f6d22399cc45127bef760f7950739267afa74f4bbba48f023c54081073f46921639bef78f839e434a943b32cd45f393aa6dd110d58257df3676a0b4db6c96a97114b18a48ce93c8af295e5dd283a43bf3fdd3e9d12e874687608572e31bdb89f730b90825d062d77cb6e0b690f8ad55e222987ce84bae9d4047199fd58a8dfa5b622f447b9843e82ddd9dbcf7ff2d2584d1c3a1ce5f3b1493d813a66c88cfe1d4a27bdd3884cf0a48ad00f6fd943fa820bb0f04792531ef3b0a8c3994fbfc0ec050cc7bc4f30a4939970db49d46da8d5c1770d0a6086b5edae336bbb32f67240017ade5c8855e6705a8d6134b434f556e4dbe73105deeb5fe7c071251d5a2e4f72675721a8e6da396353f86342cb76498382c82edd9190825cf705fbb7b905cbf4d40fddb9898337cf2d903d31e064ca9599c4bb76d021142beee5a433f6ef091530ed8deda9f8ea8c5e8966b9f465ef54a9a981ab4ff974ef7bbabfdf3e7d712c32390b8eea6b094c712193f35d733f43e0daed67c87706a40412aac2ba91955e896ddc49bc01804cc1f2a0db42e8140046608f47dc387f372c154bbc33a6c0ae43b76f683aa592755290ba42517aa8d4bc6a72633431d1e27af4d4c9dd76ede76558ad8f7ea23dfa0e1c3517ce84defd2afbba8e1587bd6b482096ccebbbb7f2e86e634e66225e0b3e9d6fbeac38a8e2f02a88e51244f6497e699a274c8292607f3a1030cf454f21da6adda0405010f3689e734f749691beff71ceaca482b6f7b0fb937bdb7c8231e3ed845c6f6d4cfabcab0e2ce671fcc48aa048fb64822d3b372e180e20aab5f9abf79acc418d589022d25735d6a104b17d12b366d3ea9acea4710de877946277c9a194f655b3e34cdcecb9c6d099aaeceda5f83faddd91eeca619562c25852e66cf1758bd9872c1b87a79affd9ac9b3dba4c43a9140e7ef04ff9e28e4f0c0206d84deaa2358e7b7240723f6a5d08aa006dbd2f7e4872e6331de0fbab0c1891f9cc7715291b9c353d04b1edc292c9f453071a118ce4e986602650534aaee51116906e3d5c5ebdef94035510e57378d38ccb9562e72ace318687587db0b9e5dcc7bb9acfe10de8cc65f9ece6e8959ef64c7b994c11ebebd8ea7b39f461dc2061874b82e61fd9a368bf4dbc52d0a259daef78af2c228d1239c220f562da17c3e13216c88558df66ea933a6ec29a5ed41a11e82f7fa9c5c22b4ec9a98917b8c57be306285e7c7f86791cd8a5faec6e85e560682581deab6dde8509b2612d771935cacdd608272a875a1d99f420cb12568162ff1ca8764e2b949cbe9f19132267c13a282b6a9d27c69e1d3b580b4223767f4b7a63419b75bb22a7cf11f48af6ddc9edbd3faa85d240e490adf631bd2f5a5e55640049f040cb42b06394de8e318aa281aa13a5d7abec1503cf5a8ef969cdb705cb2d247278dee58598e49f4d914a154d76f8e9a59379cddf07cfc42bd57c4abf3b9123793d965bbf20dbe3ebc02e9f9ff412ee308b8df7a8fc7e1b8a3bbe297fca8830f1289b812892f0be3f0627a014c0c32b8ce465cbedac546aacd5769218fa0676f4ad43c984de402ee86e8010fa6fc78fe8c340a8c98fdf117c82c170edfda756505684e8958afa16a5f925559d0f866c14d35dba0b9f03b4bdda9b8a2697e28632df2746cbe2ccbd284c735e83d0f2d7301ca79f9c83e839996a6b025aa3dd3bea3ac61a1419b88391ae3e7170f921fe437211de62d944226987b89f823b2d17a0adb1831de9989c8ea21f085d0bbf550d662caecef0bf930476a8daff530e36934978b8c5dfe27e718791ef8c23a1b4779afb77d22de546dd78d7eb4c32ef7f7dc004150328588dd36a0266cd271103a4c1f076fe07ce6d48976d748e387bd51b83b413ba7f01f2ebec6fb518d52f024febb45c302be61056ae62508f594964421c06acc6a49f61ec60dd5b1d1659ab133261b55478c53dfedcf0b11e68f309f0a1ab3556e1009c3bc81715aa0d8083bbbcb4486d19bc8e6d37d5bca0270f6c9db77c35534c8c6cd509186ca7d68af503d39fd88ba48f4ca83d332f941507ce8596869da0294c4a11bf615eff4b62de587e1617c225c0efcfc80897eef373d38a986dd02da4e524a9ed7eac90ff41b7329d2d84eaf4a75d842b4fdd6bec1e82c067c53ac457fd06c9e8532806e74ff7fdd21e77885bd9a1db05e11972814eaeaa8fa5dcd91fdc3802ea2134d0ce79845031611df13d5ea67e580b0860482f94a25adada2125e0d5c525ab5fcbce5aac0a9ac8b91ad6a64279fdb9591659d45f311bfe13fbab7c865e12320217f5cc5fa72182e56e42c4914aaad138de633bc7cdc505f3b84ea643314ec6dc340c82f0d9b699b87b18c395791acd7040346fb262c8a282218eab709575a9c8c6db57150f4be53b77c4b663f76d58cf918032159278efe43a12c1121a56d5a288966f3c8d65cb68434880281bfd18dddd96925afcb930175cf9d48ceb2a5a042318c351edd332ce7a61b26c1c9b1e3832550f21be007562577b82f44bec90e1b10574ed53c5f15ed08c50bb263f86e5641cbbc825873b5098c6ac2c0ced228c61ca891bb4b5e1b2e89d20a12f5d8ee3d53f253e2d94ccddaf1127faac428fc5748de22a8f23f96822b17c9eaec71771825f1f65491de2fe347a473d19b1b0529f248b751263f04a856a29b3be652fa5b2aba568431433b3665942dc11e50150598f99f994891566d6188a09cdccd436db7040ca8bfb7232d85f726b8eb93f5b354b5ea8f0376fa97de434c5f826a89dd94e30e50351fcf40e1d91ea477fbb96e911e5b6935d23141c2f724fb303ef73e10269ecff07a6c43b2efdd8c2158dbd761209c134906cb1fd844e3f9044657b594426890a34243cd51bbc7335967ea8bb1f05d7178cd0668bd676d727ceefdccf833348876b68d7d90637dede3385eca7d222d8244d112b4ece72c3e5b438cf8b0c232355afadd8de3f07d210278703dec47f27c9c90a00f9a6461dc60456cb0f3b23679680fca8943aa00a71c17c7a0005d5d0c2489e39f2b4e59ebfdc9bfdb90f8db32cc6e90dde8f1dec3ca30409c3e8641afdbd4820b9c63df6faea4d1751bcf66f0efd844449e6f3351d5bc7ce0bbc8fcd2212e283dd06e619d36ae8766778fddd4c8f6bb2f94573bf612ee1486a4537fe0db2bfa9e06ba1ce8e95ec51006f857ee51677c07cf79b9e5bb5fe430e1cdfa6e19fa3a64e08324ffa8d9ee18fa3bc3f68ccd2996d6d77c95412b966584519b4ae2ac41421a80f740b6c424920a2a01eb69fc48987806a922ca3a5142b95061205656b4aea10576473d7aeaac368dde556aeea8e03a5f6ee802e5cfacd920e3c386c9ef8e1cef745d797264010ee102d625b254a791289e16016ce50049684c664c64b16ad0dfafdab2719fcd94e97a89da01deda9563a5901dc268596435033fbaf0b15399c34cf61b28b374121c88f726a4b491463872da71526d2416a0f95990d4b94ab4780dc19d95a2f8820a1e2d9864e2fe72d682af7a9937e9599bf0cb054ffd97e2509b851db515770413a36c553905b307f94a074a80d18051b14b655d29c2e3d893583272088d681a63b19921b5c2a0ec06fd19110fb6fd929f8e7bc8135011cd9faa4c5380ef56c35316a4eb4e901354c44a60bf3ad654986733a376d236bb8b6fe029da7f9d26380d2b03a3f4cd37af76e0d1fc672c62eb65186ea4f258cfb73adfa10c006f45ea47a6012bb1bf83ac612fc03b30f7374de3c025c39283ff1483c782e4890c7972ca23199fc6f97ec6ed49e63b2ee6b9c29b2da604d09fb3d85e5ac0b60b7e15ba42f87fcfd5f4ebdbc0921fdc4b9de93a70bb6bc2661bc09624601f8f94b35692e03ffa4ccb6e75851c5f86138a2148dd6aa5effa1bef313c499e6c8873ea9143cd149173f0c140427c281452291a741a76080ad1de1e3aeed5f78edb8f531d7f5889f06a0108dc8dfc7e856ee3446656199078e7b729e6e42406f000ec2b35db9fa359b8bb90a06f451fefa0f10b5f9c0e2426a9e005e62bdf276c7c4d620e33811c02a34e7751753f5c5ed62f8c6b49b453e22050cc0d1db1316b426594adc6215de03d4743be23be25f437389c4265c0bf84c7eb030945128aee487e6749c4720fa4079ea3ebe09ea624898ffafa0d29ec025072d6be386c6535c0ffed1015362d27ba735cddceec2a311cee9500a8bfdb97d8eb9a416e91b6add20c0488d20cae545817d4f9c93ee76b02a2faf35867dbb0d46d4c8ae7760db8711a41e16a477ed1f1b5d7dda5b65ffa8c4f8ec3e91291a145773839303d872814613f78ec6d7b02a8fb43961952f5f8c1b6d96169228aa0060903b4da1afab2fdd680a3b3dfa95b7855f6d05a9c95e9b4e2692d6ee4e7be7a418822d3e4be04c2c03a7f5b70fef54c0b2479333346c93dabc3c25bbdae99326444fb748c67321b771bd7b9272ba556be3c537b7c80921bacdbe191b2cba163d661253c9c5be7b3e50caf4f04a11f4f4b51ebca2dd2f919b955999087c2ed2ef4f67ea18a8f8465982026d7f7d9e5d9e6d4ec2dd973f27483b6182ef69ecce7033626107c292ab5d950e549a97ef213bba3f69be01389d2143621ba60b9840241f6bc6c51adf5eb5278d4acc480831816fa9ec294f7ad05ed77043c5217a5f3eb9fb3abe1ab5551c1edaee738ede8b959191767612a31e282ff409cd165f22985f6a87ef3d45a8b5de81899d3a6e4038cb3d0d0cdcfda09e58d5a890a859b5da49bcceb169b0b1e4c304f2b0613a399db99cd3b9eb1c5d198957b494231efab9fa8c1fa2a4c5a209575aefb2b2cbbf7ea100396dfaf4c0d987a53760f2072b6c4394f551baee70ff66d6ce1e9e07193f31b68808f7949fc7cb982e2f5d2acdaa09d8ce0c5599b15b071019d5ec99994d8604c35b35e9c249ed000b03ba6752d2e296546f25b6c2a61530f8b762bad11e69b9701dbe2dc8ace17f28b4155a762945c2a405e9c7e8f18dda936a6531624cd944293402cece251a09709ede9a57bba6466933d1701f4fad886bd5c739f0dfab704daba32af3130f367b6a26c28b082e1492a639a2e3c4f4a3d32a3004562f4dd30631202b60c5887ff2e000983b74e5b25cfe258db04b6abeb540441df098fc319139a032f4a897d14bb35e2e48a61c4e67b619e15407ce7abd284044cffef0c7de3636611a5dee2106fdba34b2a948a2a60cac84a4cde10d7bb309d462751133d4c4a512ce3ddc4ba5a1a23a53740b2b03fd2b3e9af39348e20a534785b4f1eed7f9e9cf6ec65b26fc126af15c5a5d6c6ef85dd26acb595b85dee7b87f343d842e67f96298bd386494f7f1f33cc8cd6501afb5db806a47991f68021dee071cbbdf7011c53fc0bd8f2c8468a2c070e1d4b28cdb6215adb072ed2bd872c3c2130311032c487104bcfefe09e71ebc5150c80ab243c43b0400196ec2c0086f801f71dc837ff46fccc863759196a51263826e1ce35b60eee1b4ff947ecc950c06abc119f0e98b7b8b68220617ff1eb685ac659fa235411459ccf57852e94c66ae9bbc164b92cbda5109fef101f725c216a80cf14d6837ee3925ddc44e6adcc777d0954babc50bca74129d4e04b4d3aa572bcd29c6399e6eb8c657ee6e0018386e4dcb21f56ff225afeff828ff6b50e10506d1f2a43a474ad6ad90381fdf149852ddbc6bffecfd84dcbc93e1dc2cf91ff5d1ebaae151931f5e8b124016a44e5fc7992ada1581cce5dcf8588de700a31163e8e34e4a3df99f91b127f2bb59ae27853a0a7a9f23189c0e581168aeff3f5e5c89d189d5bac680065fc017ca5e7b1443efd3a982c61745f4659e2a3981ae6de207af99ab15d78994b747d7861fc86bd7c97f727489625e387f2dcc3af5dda1c655aa14017c0012876ec5c4367c2bfd3b64c8029a2bbec6b9dcc3d3ecca67c5fb3c35c405ccce4a2f6e6b9cef3ee3285f00dd7fc1178d61be8906cde09cf7756412485ee9ebfb0914947b00af8b90be1f3553f1c864b83f8029ccc1391951000c39fb2453d0b769326c0d074e3ed5b2f542933dfd445ec91c0a5b0cae0d619ba5e8f7e0307369abd4d1a15e5e9ada41b6d453818cd0256bd26927f3a74c5e25e78fe1c7b399891ccf03c436df7f9b8a2a23186be966712602aff3221e729430e510a1fca97ff00f62f1b23860cfba7d9eefcfc78a32b6eeb73e18f6cadd7390fc42a45f2e20b9843653b2a76e01b3874c77f5a02e07f02bb74458b2141fe723d3a8f39eee676f1e65e5712982b5acaa0abf3eede700125d264ab63aeb6412dbdd283a915be5d5ac685bc651b5448312b23492cbe67734bc017116e9f81263778ac73cdfd39b64ac640c48889ed053af273612171ce67d9c23d706bdec5578704043442d3d607286a03d0e831626768422cced82385fe1c203d1ca8952b86e53f546016d118a05648de48d1688d7d81d5d7e94277f5b5746757dd75ddc5a6166eeede037bf57580a6eb2e6ffd5ef6f4a56c97ba2d7b6d830f936ada9ef79502f08dda27708bfa3effd3d6fcf8740aa08b19ecdba28ecdbe65cbd4cdd82018324c39bd0d9210eb6dd5aea4e89fa1a9033d5ef69e206d9dd5764e3185e4028c36ef166aa8b6cbc49ee983604e17340e5a9b51efb0c03e3ec61c2dffb9e697a0e348203a2c219e03f9827228d310a3d4dc2972206b51958cffb4c85618acf9b89ff586206bbd7f0c25258765cd67e85003b6ef60c40d2da295a9b9230226e1ac18cb64f6e39973165304a9411697542a32c37f85a389978a374aba775f2efc14353ee941b8a3c03256056e6edb83dbd062122aac79493afbcc5f5d90330b1e32983bbfea3fc365a4cb8768c7bb1008e5a5f5a4bacc8a13a1356031e99be9ab53947caf9599861e3a7dd770acad3cbbbf60524343b2cc111c868a788f594281aa24b9e51cb810ddbe56df4a0a23b50c1bad5a75254b37fd0b253419b3a3304e9ed71b560e57b52aa6284811d90e7c7c076b6bf5eb6a29b45e8a03e8be44ae4c5f6de6b0b226dbc849b1cc10c6fd59398a518f28ecda8d2fa0f507a39c16bfd22b89fbc100d9948da59ea0674d32dfc72877e7e9e3fd1e5e66e2497089273c59baeae0051fee2d8ee1865568ddbf6c4e994f11cff0eb26091b8243b1166a1dd308a94b1627166f3212c2b6d230abe9afa133b7761bfedcdbf72b112e64f57e7be7b6f12b52c506383baf0563301f5cced3838cc5df36d0769d0fcbda0d0fa2bf4c99610e0efbbf566fdeeb373730adc23f09b66c954e26cdcb536eef0e414518d43b34e1eb93b98d84f821d60a6c1475223b54addcbf6dcfb174a1b77d2952a482fc14b0af26ff76c63880a2e15a99838fb456ab2e47fea2d040055ad2e76413f18e460a357c1913091cad77a616e6a42a022b8f75d0c28f5eabbb35e7dd3f4a04947baadcb58ab165c93842f33c372ae90ff486036495ef3e9c04d783219042e10f19b08f08f9a8802bf53bef2044fbe445aa0aeeb6791bf5815b1be12abb0541fb9eea0595cf7661318bf85f73b2612f42c15eb2574a8f186eb44306600bba9f2f71e37b4fe21cc9027b2a65d31393e2181f750991f33c196d8944cd56307a4a3bb86e8612168790a242b92570092cfdcfbe2cf77ead7e6ab7581eed44e4125ed1cff828a7ebcee481001402512e580c760e670ac4ba6d8cb4c044246b81ec1681821b613b998f1871113fffb863d1d7e68110d20a4f2295c6cd2f4c8e1c32aea67016e5d683ab588695c5c71fad45ba91291c92ff826d25aa410d1d3e164b165f0a1fd8b4b062f32035c00206115ef26acc5ac1dc0f76fc5b63adbce70922f52aed64acbc63e30c445cbbed90751b1d6366f39bd2aae9e946b63672526e8d87f94ed481f53f7dcf39b8dcb793389a13024ab5022fc384b00bb6fbd0ceda21b89cfcc3687a5cd5a5999d41359092dea30faee2f67e7c8b808d09571094278da5e28dd454d7eab1a605f197cf2f97e2b8a4700b1fc72011048d527de67b250acde951cc141dc532b353bc98f35bec8167418139a1fd408b342245150a36858b5a3f14a6ba9bb5b254dce4d9f70cc97768ce83960584754d19906e1eb1c10e82e552390c6f48ee226c143783cbab5807f6274974f15811c109e9e22d76de446ea086a8379e6be99b34b47ad831c8d10f83ae5a44ecaa2153cce00be8d6cb0e3bbae498c4e8b6bb2c2ede8b7430f19c4410ba201efb4163e2f9dbdbaa39f63625e149707b561b455bfeb14384c17726622b21f648f85b3eb37f67508edb7315f54be779b5e6ff72c42dcec8855622df000e15af9dca6c1c3d6298bf4f68da412458c428a589e0e604ee26174f5bbf74d74ce96bee7ab73b3902148508c7d21baa74984ca0eb585f650bb433085ce2af3b50c02e7bff5864fa4b3f59c02599dd952c2da71bb38138ec2662ecef3cfc3dc0954ca3c34efe3b2bebbdcb18d4ef2d32fe3d6b1441f774df2179c4af0c4dab886132ba50887ab8bba5a824def03109613ac7b362585812ac357bfeb6c3d2bbc0d24f46eb8b524ec28e1ac34ff51e0f8a457dc452fca8e56f65ab1ecf9589dd351fd1b31459a953d16ce100d133f0134eae11a482180bcfaa190a82d2fd61aa02e03a9bf27d90d7c49ed100db41a899034f63a9b51b30a08cf9a7c6006db284d5be49a53f65bc86aefff63b33261b4dd200a9089256ef9fe8a9e0ad52aa856568142605835a8abdd94fb56c3287cb1c29d329d62fd8d7563533cf375149889b3574cd496cf0858c17546043137ef218bc35c4d53aef773f18d6e156b21042679199095e1b1197e1d1656611158ec81fedbca9a9e9294bbe4b706616636d944ff48f5ccd7dec2ca6aaa2aac1288cadbf4363c64ea2f5d8d161e4a0757c9365066fd1dcc82e52a50d71dd2f3873a316cc4754863c83acc407f7740fc310ac0d32f83ab6304625958b19f55e8736d59b658b5406dcaf0dcf32167309ad3dce9d4bc940277283cb9c1fc5bd3beca3b6259e45caf796a7415c3c20725c0c8ba810ee09e31d4191bf77fa132e581586c662542ffd63cfdbfff927e8ea5c2751da047d862978a6bc65f4d2f5d796321ac0fc125934bd2debf39adfaca366731fddb517c3db1efb38a268777c55eaa7d6f5ca52d1c09747134830bb1294ea2f95901dcf9044281091decfa101572d9bc8955ec4361b4e499715d04fa524c56dc9b4f237125f47f67e881b3a054e7f116cb85560239f5b0312f35e221efa4ab243393f7dde40c765f313d500c174897f37dd9de7bebf3acfff2f0b7b996ffa39db5c96120d7fc9180f29a71c2c6a59398658cb7a547bb2bb3754ec4d23a12c0edc2829f4caa0ed18bd191cb8c48f0ff6d2a5feb9afcfc95036c4ac5ab642d94b46e9caed367100522e64bbd1ee802a627d550eb780c7ef3f7cc572beac860f72c57a02ff5a40056972661560f41d131ec574471bb00af9e6678c56e81664e25b983300663ce7c9144a9e4dc6a6e0c31d282487e61d6fc715e7d100734749bb0329a39278e6f5b001dee72193f3fcd215af52e69bc145b9c8cfed080c6c416a363d544e5df837ca29ec060c3fc3abb4da8c2edfa342d4dd58199f2810c2ac64a16aa9e8ee533504f6c024c55b71f6c51bc1da68f9a6b312028c8306da34fdc0e0bf92b2cac22e9e5a61e7564712fec64680b6ceb4ca2e9dca9c3a9f1cb0b7b14d6ec9c61d97eaac2a6abc1d56e1d52e87fe5d7b26989974a1d1aaa58108d04419dd48f0cff9dd40359bb20a6e93b511a8661023a01d241c52e52afb3149898469ee66fcb5b3f0dad6f333d7b2f2ea19c2c83fa8b26864513d50a97a7b9415284f0a2e7881934537d32e79477f574db61e770afb6279134575cfecaff5d79149bc44a757ca5535d85622ed7ae1cbbe9a5240a748ca8c9ba4d97f8285ce4ce8d8bf6f48d7d3f86c0b6b192a8696d96325661d88bae7a165ca9b0dfda5ea34bab47e61e813d45345cd169f303c375cafb9cbcb879d6f2ff0ebdca73fc859fb3536a22e056b8c9c9c603e01ad81cce599f2cbb6acfcc346d9bb4bcd606afad3362cbe28acb3345ffb60b5ae2ac1cc2ca3d6bc6e29a898aee5376b4459db44bb8ac610bf7190c9a376383a64e94abab4d96a7d9de4834941fd64a2f6408b909edd6fcd92d98c712dd4565c0d1a2e7615d9844622ae340425f8508e245ab436aa563ec9e11cd843535967b09cafd1b926ce9e8081151cbd50a174bf21734a86bd7a2265f82169f1652c685f8b03433c0a78e85278325ea2a41ee631df45f010dec659f444c14d471a9d20bee4ffdec1950f30ca480bc200764eb44b31f33576ae50637fd7db061e2018edb943123b2c91148c66b74995a76481a90740db522a6e56f7888c612fdb308633627cdbc98f5cde933c39e9a38be76bd6af245e48f8d5f62305cfbe733f1d61254a165088f85f7da229235c2dbc4388df71529b2654b25b2877dbc676","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
