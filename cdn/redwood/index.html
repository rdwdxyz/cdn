<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ce22855de9cffccfc6a2022d67dd37c682303535f76f654a87dceeae51d18929fa1a48c721c74081624f27bc21f0401495974d1a756506fbb13a528c2129fc1fd3b033de798b7db2beb0a9712029c8ccabcd67d51518311e426354698084510b9a9b1b84741cb64a99ec4794e5d57c57e729a4ccd3dd22cd5e14280ca5702afeb7d25347cfdb82a1b4f63242d5d8d2e4e268e7d3594afd3f517d2499ef45892516421b415190147c3cc26b7eb9a57ad6ed802df60b427d0cf8135b29cd4e3c47d73f903fe380e5a8edc44f9f28b9000be6fb99dd2f2f2a824de920bb796ca3469f69349c9423ed12d5c1c42300e75c18cc70e4749f54bd6766a31b19240204cd5cc9c47dee3a0c6f0d9077880bf3e12fe9d3dc978fbf1e77f2039e1ce525e5b5f7b44a2977797194cbfdff58d0092328f8ab5b11d85009cebda7c02115af92d40a94f23114a2b212741cde9609923c5661e804547de81283ef48a2cc39a86e9152636602cf404d3bd6e68df4118fba394d5f194c0d395fbc9bdcdcb9777b43a2815a9f698f55929200061da2a0ece6b053621cc0becefad03ff5e87d3edce3707fdb1b3a5a5b4a4d5592ec8dd2c94a1821c18f178c13fb20d3c0725e53e9a2dab019e7f9b72b79595883579906112a1ee1cb76841b7882229811a0fc9f5dca5fe7d97cfbde86aa33d1875977c4dc5bc7186b7af6b588736baf080ad0cb496c54822c9beed9a1b7631a03817a4a3d0d9c563afe47b0bccebef2b6ff02774644dcc05019dacbd5db70e4bf0aa6cea10499654d3b85d1d716f73060e259464f35cca5b2dc6d2d6c52a26767f1b88e18813a066c78458d2586d53f9f764eec36e3e61df02d314f297730b45f646d917a7dce1de9923cd617aedc4dbfb173e25526e49c7b239229e54fc8c2fffb900efc13f28561ab90337279907fd7384fc4ae05edd55f5bd9ed13f5ce49fcc735fc741a503ff561dbdaa3f6e4b51f05a699b239b1caf021ce0ec1fba81e7138d7d967cf02940e11b61f2a59bdaced21401242dbb737667e56753050ad1d57f61849f7aa762802d0debb1104bebc6fdebd90b9288df2650d67cf5ce1284cdf735035c5d512c51741c814d3956aa7f035a67077ae3a00d467e7ebf1457345d5a470c2d91152b25c6d2db2b2344fea1ce0b2120b9f9f7af1d94c589ec607e18321d565d6382e4cb7e9245457d5e2e9d8da0e822bb5036d6ac14290761bf7d1611970d523de51b8f1555d3bf6f108863f7f5cd1a3e583f526210186d1784b29b8775c16f4c237359d4ec428230370a2f617d415849c9c3b2dd5fae4fe2e9cd69889f09777bd0c40bd73685753038dc913449739b05eb0e0d5b70ed6c5048f60967686c8ffd9653639dc17ef97562b2a2c9afc78ea2af524cee6c934517f6995534cc3c9c67d7cf775b8c35ccb96dbc6e80117db682838b68e4e06b190614cc44177cea0fae5c13b67aa6fe6a70b0015c2e98b608833f982ab765b2cca16837544af656e3529e12811eaf71cc4506761067e99d60698f663a54e15a8da1a04db7d0d45b6f7a7d4f5212c2a4e61b73c3c103255df7a217090df088dfbbfde1ab3d8366d56f3574b4c8e28b1e65d292143245f7af3eb054dfe21f2a53cdf084d45255aed3f0a0e9c68b60a157d9776c73513e8e578639e17403501a9e42bcb8f5dd6f09085ad686e23ceb3823c209a84bc6e055b59c7be8f17f679b6d7a1b0425bce7a216a3a46a4f9b022dd4d6a78178066e5b41c369db553337c299257ad501a4612856986e78415b4447e3bad4eaaac6e2e37ab48f58674f35b8e43e982ca42e4acefd60fa1eb1f1c6a6bcc1dcd3c3657e4c92ca85c567835a1838ea47b3cf191ceacc37a737e778e0a39b7343d626865c7ab3ca0c1ebab28bebcea8eab066290403bcb356b7ea155363844da542325d6d3e8a4428541ffe5814e8580f82fbf982e201483a0158910a4a0e1b9f82dde2e6b21da8d0dc8cc3b9bbd8e9d81c5e25d62eebfe2c44b37682abf9345053c6e42708367c78144b26d952413853da1fe8f0f7003b0836e8f432241468a623d12571168bb57cd4e0c585a6667ae1de0bc192646859418707f84e9e3bf364bbb4b1ade3b232b6fa648fbca4126a9d8d3be0f665f0b1decfb18790e7107402ba1a6dd2a0c537f5f84401a2c11f4275a321dc24d4833ce7fada4e8dc690f83a200b8d9ac259c71fe9ad9b28a1caed98b0fae1eb68e1ca94b4a506a4f619c68183bfcdea69869ca2c50333f81a99ee694c32fa6e5428323b75074b2f16a44e0036e85bcf30bf1e4a285518089bb688d49fc1c8a3a0b4f492cf5c7da1719ab1181dfa263492d8012640f39d424b7aa627419f1725910107d10a401574f3ec31696533fff98976c1feee41ac4bbd421cfa49edf798f543a6aae499197f3760b823b2dc50d01a3e603591d543a3f9d31fabc6944303a18e59c59196d70da372b336446acdb733106cda2bc11bde719999fe1119d0f502faf16c61cf667894205e3731d288e022864ba264fb9e33285007287c8abcce6605a042824f25099e7c9920b5f4f93bbd2cd384041d436c7af5cd31798b0e58fbb1a3f0e4b32af6878058e69c518a5e6e00946c78918306a5bd268c439f610f3cea9a3d1e3cc86fbf38a1a8a8132a12e1ed2589fd2ef8e3c8dfc24708cf2cb894a3224a6c784535075de958c36e5b3a8e8b0de922a58f06e835b476f1dae4102c9773577079ecd2d9ccbec3f1c729d2db57c05a126d478d8a08e67e3df8883ea304cd719071c89a1c6241b21db6e6a197c1d861b30a989d8e40685ec6b3319eba8ac7e8abadd917ac570234c84eec662ecf9970ea3b60aa85a31cd0db21a4c2f7ea2d44e0da94bdba2a25b1922800509661817b676140b6c5b5014e961322bb23faaefedae412e9095e1bfe5340ae660cc982f54d72e93bd60f145b3d6099526bd35a74ca9938a08e697db3fa4ea96f37016d367a95e64f6a424228a1d4270e55029ab5bbc43cc25c36cc7d0c19535c19bf95a1d1d620c5aa6a430d04ec8bd6a42aff250a9245b51be2869baf06af522a22e498a47f5cc6598bad00c8408b79d92b5ee0de76ebf98a81e8ac74c078bb4a7c40f6e249c7f923b2b0071890a5753f44f68dfc5fd5c37482dfa1efd64b56094183fff5b0793c54005c78c5e1d90c6f1bb257f51ff55cd413738e9e75bbb26557e16ecc4640e3555ccefe5683a561ad9aad85490d676174d97fed82360dd3d10496ccd47b0cbd8dd2f6029e56a112db32a8efcc964d358b9707d67e29e709996b16ea5806f9455898fdd0117a0ae90700218e53c1b16ae953c041a89c6b4baf1bff15e66ac9cc8b0d4908dd3ecfedbd4673e4c34c6234d5ebe5cf3b79d7d989a334f01b43e6b79aff782bb9abaad4e5a68ed28fb8c6aadb572d9d5f92ac83167f8b4d63183320461f5d7d55c5cd2cd769c02fed8b92355133158be8c864a67f7528c48fd08b0f1e48748f030af8c4346903210a0bd8c84b36d3c0cca46ca185135e8cac1b63edc484d45928c8e83768609210014a2f07fb1049d19c39565961246dd3ce84067d2c86c5e93dbfbe5e71e57ddef0f65cf2d66f0f8ce1503d2e9a01739535de4e43185b23d31d3c56b081e02109ecccbe26e3c1d735cfeb9ee7b5dcfc3200553a4e14f260c2dad43e420278e7fdc7d9dae9d5ef65dca8e797cb307f92c718c19a2b7e4377d8e3993409336b878c14ed59befa7d14ff8614276455f9ceb0ed5ea2951ced2f512d2e0ebee6db0ce5ade0a372c549fc5af0df8a042ec8afb3c43e07ad2047efae1e3971654118818cd71cd49272ef3cf785dfacf578921089f17623326f406c113f3b3ad6df68385a07e3a0c2eb4c8261932b18d2a0c59264b68459e35ad0298f46b67135fbedc50a906a44d986d81f061c803f93c90deefc5ac65faa048188229bc2d89576144b01547cec32a16019cc9c7fc7307719fe467f31ca3b379ebf49515bee2ebab4d6ebdc1ed6b8ebd60311bf4762cd14051233c42eb0d97567e0fe037092d3aba742a59f9ff4088239bd647e71b043e1c74b4b289294e8da20050723db31ca33fc074f56c249d1964aa907fba317da18ac409467d8e35c6ee73bea98bb9d848d35df402fb1f739d9b7b04882b62ab21a35d120a18e209d0a9d19ff87932daaaa4147faadbd46ec027e3e1d83835d67b57e33db85857bdb4374e0533a56f48b0b9de467c4ca60f20f9fd02b53b4e4f6b3e246b3cca52bc2735095b47fa53c3f0736d095a9cfc91310a3f9cee092933f3082a406d9faf27fd27ac2afc6451f1874e29f5dd6deb63484cbe48a624cc8146d29796c8ce41ea0bd992a779ca2edcd181858259a2378271bb37624b4e4e0153cd380a47ffeacef0f8c860cd69afd30806f450259edc7e1cb4dbd9496a3dd4c5e0f574aedde0f888635c9987c64f06cd92aae14f107014d07099f566b374214e9aaf5bcf7ca53ca0f88e8c6f27a631ada87369a3a58f11a4f803ae82bdf025e7f3e67df554a72625bd25515f0893583cfcca8a36adb3e124978b83ec5bc2ee55c5496a07446873fd30ba370de4b3b7721ddbbadf6631c061e55792c819ee60b848f7a6997fa58ed8e2212968a235848a58ae09ed8f8bf050f8434f66bdc24995a2e69b04079017e977da65849c0cbceb8610bb2e1b959d525a61e414a4789ef18abdc4a413bedb45189d47282debc4ecdd5763e337f0453fce2be8391b9ca25176516f48b6964354491bbaa8bdfe924bbde65bd272b76f4aeaf06cbb6eb84316175f6c5d68bc2c49beca2ee57f9af68c7b6d6c2d0d5b10437677b110f92035bf18dec90cb320cf8cc9b75225dcc191b3535e2cba15f64dca22ec0705ff188ede61e6ff84d923ce2ea3e57544349ea3369defebf2cf3d5f67c71fd7315637e696c68b9f120ce48f86af7c2ec1fbad4532ba38afabc43901cf8b29761f0ddfce82dc17307983a05f365b22748e91d55515b6a37f6dfd67da77681af82bb6d9d396c463b0eeb1645d62c202a7d7657afe2b45b641b3d42f9929bc47ae3bf84284fba65ed236d6163656bf1598b81c6c65f0f41afa1b83aed42e4ed21a53aa4d67bee0e87a6f70ab4b7f0f691bfd5947a1f473fff21f06e8604357855003d70b065b5772854e242de7a3c36251b26a47133c0fe4e42f7e3bcd3afa81eb2c3360db9714412aab053f2a28cd02a14c1ac168baaee21c3674230eb0fda1e9e648196cb99abfbc6ae45a8a1a6881d34b538ee4f25b4d788ba51264675927e842a4dc1102458525e3030520a946e4c935dd1b5a8da419720db3920e4ae06072ea9244a38277501a54827975426ff97183a8f837859786919b5718108369fe50abb16e265b3d9f813160bbbd44481b362b2daefc08d58cc8f3f8cac1a344cf8e509aed85703106861d96287c416dcb1ffa7a89c02793b2646caa2db3c3a13df8b7926d60edb1e562f532f9c28ec59953c0dd12cf46655b28b51f638df302ce1aa85cb813ae185e5c9b9ac92d682f2e3679a40d7289ac4eaecf713cc7554cc591fd72caf627a0fe13694a02c9015f4f3db1d2dd07a078b7607aa8023a7293eba0f363b2949d9da6efce86822efd9dc7e0701b6facdbc540e0208569ff126a105de0b3090d7e05a64bcb61f1a2216b1ffe6a67605b9d302c9a470f5afab214507477376de0dce365c5049446d1d9244037b9b0e4835eaba4305d2751418681e380079f229c26e9bd42b85410a291a35546b000c71a80148c3e0cf8e952961cd3304ede3b867e0c1d24df138946c280af54b0e66008204dbbc6067e324d712b157ef50cd11b92604febe1a5060bcdd4ffd3ed8f46ce1542be4728d3c847e09080ee281daad910c04417eee813414b50b90f85582415aceaa6024eeae7ac260ff70b228d7638144f7720cfc43cd17ec009b618562dcf8892c33d13a9e63155e32e5a50c7fbf0daa17da75d3f983c51cea50f88017a7250aac7116ba2686016492b7a2a675da85e6f153d95dca711e6e6aba0f9d9e291b61ed57c384d30262d980fc79e6392c09ed1f75bea96f25fd2ce04424001c9d8c3e519371c717217aa9d2f8db922ef742e9afec24ff4ff993bf6d180085c721560c31503689735ce8b9eddae40ce6a37964ea84a8469d0b1de6fbdeb5b640781a4e7ea1c248ac5136d8d5dfc6f649e0842dae9d4cb39b61c0500112ca7f6f5565a63fc7a55096621d9d47ad900412392045281ac58d3a6b29167889eb6aae720bc07583c4d56290bf6defcdf5337abe42b687b2eb55055349728bede9fe94dd2060f8328c024b0907ed8d7b3a466f42d93974b7fafc8eb731e5deb7c9f4614ce955ad392a6eac74e963dba7b8d2ce3245d6bb35d8227e0dec957ceb8ee48998e8c0e3c181a5a7749e384dbfa7a65274661e5e962e1ab6d8a2a5166b0ac7c4b44ece2410b780cbe5d8faeeb7f1e4e7dfdcd669c37835f2a095593d595e822a6d6dd7c8d2582be540adcbce577d9736c8cab2de3015bf45011d15574ca4dd692fa2f831b261604a4fa6f3d591567e9479d6280a09126f7825ad710b9779b5f905b57f8470eaf7d80dad7c41c5750fd339cea070b843748e5e7ce75dc90ce0f7d763f3bc475f6be33d67b16bb44c4d227cbf02b1e3b5f45423c6eb5f96bea748af82162afc34614e7197a1daa9379aedc7fb2b41a42c1e8bedb93454498327be07a9c0f3e13ed682063a93bf68d559c774bf99651de4f5da404403e46d3d9d0a4730b5f35484ee05343aee4d174cec68869d3955e5916c358714e4963c4994e100fc8fb2da24a5f5e45e8de0689a53f1626230b6d559872cde8ded69c49121c905790bfb9ef8e30cddcf7812fc415363cb07a58f6c2eb8e3f40dea58784f71c7c426071b35b0dd57ee3f05071fee1295ff0f2721af612a936a583421ea072c856221d7e4a077b784941f673010d6736dc61ae36daf846ae385158b57c3eb633ab187bd53565d82cb7174506688510253c07994ee25d6ba9fb046f60971d642b5f8134624ba7ec27ca8214d0070895c47123e31fd201e862a3a9866754c7ddb79826f31d1f7175958c2b57482a4457dbb50f290b2c67dc0e368fa12e868ab2619409dd412916f8f6c411faaba50f605775f144bb08dac3c5386f2489cb29d389eebf40ac0ee5bc51b0f0c3eb0e5d2db81ed90cc8286e246ea4a5142efdc255a7f697303457e701792d51a0f93eecdd4dbdfb534eaa0f7c144765036114276b9bd71ed4cc1278b9996f38b4d7a0837f551b15fce9d21db41d20b2a4b3f73ef2a128d93c841e30981b4027ffe7497fd75ad99ab73317e67a011cfd2e50ab3cd762901678159c046178ef5ab8fafbd56ce89e999f90812ed90d316c5831fe1017c6132ec5a2f754a316ff4ac74082d148709e627c9c62fa868b37755803d7a815d3f5e143db60d09e9ec333942d90dd28171e1686fbaa67431238527c0f773d0fdf38224d92f51efa71b80b6b422367b81523f0f71c0acf3d62770d64118b6a95750d69a03739ea328c2ba0f93f859fa118a674ef9022eca8500890b521988c97de3618d9a8bcc5ab63c249688b6a38bf44ac54f54fa6cd1eb94dea6be8468ecd3ecdf9efacc72ceea02e675617e4184e838f3812f8c7033eca3a69bd7f963f9dab37c2868ca51243eb7d17db9f07b3f427d788d52ba5ffbcf3c00075dfbb73fb061171225951815d7727b014768c5fb4df96c8e815d87d692ee10f0f243177a459d85adf38f96057eba4676491e3b80e616e378c7c088736277604d25caf79864f2303b8eb27cd591a4c422dc1c7e564a81f862d511fa25303ff2be9abe958f4ae40d4f43376933d4b0d5cbb047831725fd853d264840b709691e0dc872b776af5aa0cb4135bd402a8192c1ae1154ade1792689c2dae79c4d9c1abfc8f5a1a542bca72ff64aa5e220b20df31b8d2f61a37700f29c8635246f3e8d7c4b5f5ca176f53218267ede3bb24e9a5d613584528c23c11eb6763f8565fe3fd328739a3255548e3f6f3c93bd2eefc0d84f54d7513cfc9fe612540a452a913edf6119da1e940bb291c201a948078334f1fa6a1bcabecbe901292b6e8ccfe79a8bcb595fb4e4c0e954618ec0b970ae271617b3bb5f4ad9ceeaa38e969f77815b5e5a2d7a00a7e33f91496e23b2770b2d679e42cd2dcdeccffe844ba3ef161dda5cf704585ba141a8f5a27e9f3c499356111b0636683bea5f0a4bb88b3e4e9b64dc7df04c596af9c73c90e517faffa43fef6c58a48d751125983394161f8c5588b15b12291802d9823ce23fc245d273822543b9501f6a6212c68ad9b9aac9df4bd0c12388f5db89d444dff4a6f093ae95f953b929354c604e0dc6a9ccefe072e9b3584c8d9622d84c27136f28624e8b717a5edea7403f436bc3c3516f8597999b7fbc1115be55ce0f5006821194ef5f6ba119d4cb04a0cf62db4c082aa87ef0c28a516b4ce05004e7429392b588f6cf9c0c2eb28eebd7aea649cc9e37ba1f50b48ffaa009a8b162dd35580cf596f9b3939f02df747a1bd8ca576b2bd14b377ead79a3dc2266381a0a0ae009aa3c8e8aa11d0276d0d71c7ece74b25a42b0e934b206827c3e7046ea29e23993c9356f5700f8a45ed9735f65a688de98abe8afc0d4c3456c4863c2b25b521612d773384bc22ea031e4579ef2072f69c04d32ff735287c2dae528b9910927c5bd12fce5b600cc31caab5b2b000f4bd64a49206f8c91df0851e696bfb5be65863deebb1ffecfb1ed05c17f8994534a2130e76c284f1a3636b9fa5fa18275b8ef086a87d97cd45d3a01e9d551aeda5cde36ea5917dd206f3723c824dedc1714db7d06e07045459bbe05b307b2390f4cd0c0fea336070e877d933095d3374789e833d08fac19ebb59e2a96e442f6ad7fdfce6b2d2f34a2224480cdd29bda186e7fe7a4167b25fba6597e4b130758c6fcadb258d60647355edc2d65d8694c4c71e8ec8c53e42ecec0e8d8fd40a54b99913564a99f847336954f8e05312c621f4ac019bccc5aed861712840aa867e1aedca6a9a1eb7380827fc4b79a358701741c2a19c3a3cd52d0733dadf33f66d662627a7eed4baaa69d50000b0f3671a27c1d14def1bff4a053eda5cb32772c6912f8ca6f5570295fb1bb6a4221a112e326ccf05c86695205d69cf4f6239a7feff253772f7b597917d879f8081276bccc4824cd77c8acb41b019d5e57f035081b79227385c378e8dfc15ecc736c6f065738bdfc8890acfa81d7661833269b373cb607cb4dfa75d2c9e60248f376ddcb6450aa7a789213523a1a760533e15d5fbb1e2096fd53bebb9ba69d7ffb1633c760d331513be9de00828cb7cabf172a52ac961acc16ceae9166d18cf0f0b6599c92c200279946a786956e9a7ab989ecee7f5ef166c7e294c228961a7cf37eb6b5df29b987bfb894ac42e3b9b867368e604cdd1e065d14e4e552e3ebb5ebffd38fa67c42f77cb1b8a202131d06e9e59aa364f1449fa2a8971af299ce96d73ed1790c4f99831f8f24ea619de0df93a969c3d7c6434f87a3c5c73f2162d38fd6c6d1b13f8425d366aaf90c4c296075ba5acc02cf99476a55a5aa05116c5c93f4d4fb20d413c95e542fc2bb37de4c2ef8c0fb5d159a37bd2cdc4ebbec283a680c9dd38ef8d9b350da243ac2ffcfd1b146697ecbe5619321999b9c356d782cd69bdf16bc8c3840f990e0b8a233bbcfc4fa4292e64c039a0e9e896a2fbf57dea09acd9cac0a673487240986ba57251b0d080b1d9113556fbf6646245f3097972946487ede0099c83baf5fc52c02b458e4aefa07f6484fcadfe50605dfc054903c1b05898d1d0cb88a1d1af9f7e6a0275f6a53d3e9a2f56e696b13ea4500812e1ea81efe8a7ddfcad7755bea9eccd41eb1940cd48f63208d0d191621ae7c1e16411255be24a25d6a632ba45f7325428b89b54f61d141a4fa279c2c495e73b92ff09dedc25ea23f17b1fbac305007492b2422b90a6699826e0615d4f6674f7aead64ca1b66b24b559dc189542ed10dca2252d56128a2ae4b674b2a99da76e5862da67b4a3a2101c0d708d7e4c261e58226d83123ec3d53ffcfb18d2c5652ac8dc546191a4dd68cb3fccdcd382a09cfa322f11007619421f5188ac31e929a22b057e8c13b2c948001f54fd9196b564577734b7d3815aba3dfb5abec583289dbd6b548c2f02fc056545a62e47288a461f0d77c89d776f976bfa0baa8159f19fd825f475fd057774fdd592c4059ad6862e0594ab2232f474315c7c09958cb7c7f1c0621e6d32d72d3636a81a2cce79d0f1418ba600e297ea68dd9a852634bb9e03af8493141bacc98e97370cc6b517cad2b0e67a35542e8e63119ff43b00e49462bedf0dc5d9cc8de4ef3d2d3bbb77bf8f0a9c13483a7cbdddf5880b3d6f09b85490975657d5091e74c767651317811ff4fb24f6407ccd7119316fccf4c5e9902fd267558d4dfa09bc9a96a6e8e3a71185f254fbcb256163fbc3b300c917e484412611f0b8169e24f4bfe4a266a732e60cba5395a6d4bd41705f0c66929e924e2a5204780f65caa5d56254303240c15333318d7e43f1e9f3cc4063a62ee3be38fa45ba15612acac0c7b87277bc7b455f4b5bc9fb4b7ede93eeecd5540e1c2f353ee612601cebe71c4988b66ee120ac3ce3287a89557dd5555dd849d80e1803a07f70e2baebb690e473717e115ec6b26fab8ed3826a7608350ec516f8b26dffaf834387da8477a323a1edadbb5e5e7f4f0d56ff8bf9d4eb8e388e6674d97f82c259435996bc11be040540f5723f495df79c5ecb9a7860e6259f13976fe11ffd1bfe6d2f32274b6218dd7c3802eadcc83e2b25a88d7698fabbd939aa95c3a265d78e15c9f67a368c9704be9d0364adf1195be2d167fc79278dc3682e85cc65c91793e698f008768073ab8a99744d86efa6a980b6fafd1927b0035a52e046331dd77b4b46d9826e7f10d96fa26990ba4d39b8ae68322735eface2c37fd7a399f9aea754d2d47c05b3d8059ffcf0814143e1d497dc824744ed266076eeac00cb7836a757d3f975dcd3202474a71446454989c6255bce7b5c1fd320673eb634b02b4cd225f9a7e1e42b7385582d14616a060c58c44f90b91b89534e287015f78ffb6d3e4c2bdbc1d7fb55755c94960141fcbe91972d7809c3d011ed16826179f5be72b0ca39c89f8cbd535cdd2f06e800f4ccc2a1ecf85719babe707408240a1e2d69f8cc2f9ab253db7c3c5993f0cb1d5d358489694472a9b3d7412c1e580e7dfc010ba00c4743a9ab998695b0dde6746b618ca422a9eef5191a04ad6682a4cd229f3317c193288a786da17010dab2f6dfcd51439c67528a6657025be385566373ac34a1b70869a027cff096ffa424f1511a2de8e5189d7397e311b3a3eed8b4dc8a161a304546280ba094bfedf4de988a3d95609bafc75c7c95cb16cf71fe229877712062ba3936204800ac9c04bebb7302140145190b866e5b99d84bd6eabfc0e61636ab35ebc81bcd7948f67535e7cb6ca9cfed268db81799a2ae72ca0ef5125e0e0c33b42f06879f92e46ae826d8170648ac69aebfe7bccc32caf1bf6eb19c41bc80f53326e0fc1c949bf35c35f90f53e2ec672b3486314c9ba27f43b8e38a796de2c029956901da6f0ddd3e441bb74c197098be29a5ba751b028f0241daf03aa1ee5fd8366cbe6217bd08e249d06558c81d879702f7d1c53bf34a31e53e9273f4068f684caf4439563cb58ce6bcce9e607897a9928542cb5332b887532046f39b00312a4e7516ea088d1aaa6ab1be393e60fd898ef0b2623cf1067048014c30feeea90cda9b9301a490639f725f89056d865f7c4568edeb88255078588e7a42ea6add3d669a3469f390bd0ea10ade1cedb3086899c564296b19cbfd5f92859e7550584089e93fbe82cea09bf4cc0d59fa017cf0ef12d5f6ba29149aee4da22c7169770cd9b057614510c2ba7105569d6d623ee1213623f6debff6cee26f9aa3bd7d51493e759b7a8f69c640a3ebe7e576c32e47d3937a89ae4b77cf6a4ccb60927e09dcd60deef49bfdcab331e265b9f1196074f4cafe638de364ed9c0f23f0200ec7fa1b50fbec76de8819805e6669661c06711a16da988ab1a000068e597b608f851f3db689d713f00a0f9d09764af14b8431b84fcc7e55b9988e8101ec380c6cf662fdf0b64bac0f7ff42a8e64903d1d769d1b0d905ceeb20b29d771a32d4ec2501b970006e09f7ce20f417184bb2def79b32cf512787860e03aad8ea7f2237da2f1af3b753590913d55f99d5dd724cfa9f6937320885d53d2dd3f6a8d481ed1ad528845ce3d317139dddba1454abb2f409b2eecbafa928367bf59bdb0fdacd4e2a5125d3d20378300c3d0e8debc2c1524133e5c42a3b30ef4e65af98d79f377e414aaec042556c4ec4dd990ca23c76a1a1d97fca1093a2c635cf6884b4bcb9d574e5f97ba7b2378114c4ff70a5478fe9d2a25c9dddff031ac498c34b66438fc37e852b9aa6dfc99cbe40f0b6680d2dc6c627652970a445a0a04877cdd7bc7c697631e7dcb198faeae38cb6bb0b578848aaad24d5661f2094ba5c7874d201f3d83eafb55aecd243f46c78397a9471a781373a81684bfd51c2fb9e638874ae4e7785f97de5fd58ff9f4e49e66e90e95e7e7f3030b2705e5bf146b789cd9b80ee42926c791ef9049ebbaff3cf0c948b28af62096ce351e3a9d5e255481bcf3c278149db588d45919db2b4977f7b8466e167fbbf3b4ccff3b0b98427b8275d88d39d3fc5b45e3b62a8b11b72e3d36f088eb7ab94d06f99cc8a909db21521fa49860c324faa8c21462a73e4d53b43e83eae26b42390a2cdb98c8b9bdbdda20cb36015b6b82671939c58349ec02e03c94d7da4f287775a48e7fa15bfecbcad416b0d850bebe00b6ae2188740819820c6e42e8ae799b7b06134198e4f93cff30a1de74c63798ed8b8f3c2e5ee2be54f593c77541a8dc64609f6dbf473af74893e4cb6f5f91c707faa7c001b85a824116c49e79665b587357c48f74c6256246287541637c7f7c0abb5861cb03634513b485a219f14f3558a4da95d8d3c264719ea81827845a5d1bbff8d704eb101aa09003e220f1fd0b85ab42685327383091994f05c54bd0289d064a50579d7515a0bcda91a7bbc6390a560da4ff7970cd2d06ffb31f1710bf4d57782db0038657f5026f4d4aebb3e60f8cc8ab1e6d4b8725646840f47dc6247cb7caa1c8ca757a92fc8cd16e3f31f1ec844e2300b894375593932d59e1b14c2824fcbc72c8cd5a01e78641f36671e23217a2611ee91a25c90098e9a04eff745996495449638aed8734522b613cec77ea29b62476d0679ece610fae53ebe7433c8c85fb1a2ef05cbd2dec7cf54da1e606e218de5ce4ad42b2b8db41118fdac6bc53c07be601b3f450764e7532bcb2c8413c5ea56ee96465d532cd2c1b48b88c9e2f745768964c0bbf5e5aa60768b5c4f986160857f342c286783debdcf1cf84d31397977a35b5d61a30990edab738c54d71d996bc331acc4bcd30c13e238c7915f36b55844358338df1c486c92c6a390c9a6aff7c6ddc35a9afdef81185ad9c4b64892417d2b6e228a9f9cd0b776f60564abfe54e4ca07a585e0bf30d68dea527ee0e2965f5ca9f5d99ae3697ac8c8c470466a48db46fce6910f1d128dca04405147a59168524905d3617d9b909a97c23c62705db09dfb04f566210105f3229257eaa34fffa7bd6b1b904295df750632a4fc81a960d8de35636dfefc4e14ef43cfa1bb9f93d6fc1340e1a94359fe4fffc2bb8f52794cb6bc990762c0392aff57a6f536e89b3ff2f0d5681fbeab10ffd66b9db5165784b6c254250dc871cc0db7eb065d553aa44e52b477ff7057c043483a5a0e1ee832ea05a9d1f1238694107c05a39dab32255bb8df6b571c28c788b422e22461660e3636d11f7994129a91b3f5d6e4710258f8ec6e50a6fd63659057769712373bd233d939756c6804297327144349474fc93ce7bf01da279d4cd0ea691425be8a08165cf6b1dc90f7f5bacc11972a93425c5cbad1ee906060c89071b423374521c11d3de4e05f562da0374d62ccc6dc05f8fbdafeee01cc133938cab785a2b99f0531daf33f8305de492c47383d02ad29b9edf9f3d91a6774616f4748aa043ed3a7726c796761ff384de2dd1460719f822010b6f988cc7f877c1831490b9d96c1976712db860812baec3630c31460d6c308060550d371ba9136e7f8a2a7cf9651dbc5c93d76dc472e2b960f9ce810d57572dce8ef7abe0e26cc170a465f5c69cb11b9e34720e59506f90ce903557b5363bc2bc26008b724a7f30002c6a71e0c0f1b1b1b89f9b3cd23e0d3cacbb63c5087cdc0c2fde05ee25fe326a88cbb486707299dc0248575ed91184a45ba25d59cb5843889c2ce6428b25bc3cb17adc5d7bdb0a54fbd503ccc8bb7b4f00be08a0e8a0d6500b2ec435cf3db44e3c90ab384a949ea59855f9bc89fe8569965a1b9c35f5135951fdf863c60c48abce34037ab76f1ee03aa42b3fa52eb77b9f5f70b4b7a137cbfced4f301341591cfe3103b11282cab7778c4a8c7be8ae9d08e54c0098028d5e9f1fe2adbf4f71fdfc5081285b8f5aa829ec03546372172815596758471006ad285916b80f992b5cb10182423296d8711143c8e1b22b87c0d085d4966b440eef1bf6fe2b13cbada59ac54a44c912e7d45d7dc7d26a7957ba783509334df5c92a8fb0e7689a981e5e1f1b0a0b79d1f2ec68cc561e380bee6c983efa48433494015f22da17554798c563e4f3f5224aeb041be98c0ad3ae89595b0ad2ef3d8884c8d3b7b7cd10498eba78f7b06f2ce4706c2113e7f7dd15592d61f2a5c0b05db225323a4079f2da794358a0215e408e6877c3e3cc6834a84cb99875288eaa512ac58918f78dcc34fc8cf299b7ed490b2e9512c5bd532e93675fccd589b7276bb51509875243a5463ccf6451ed6809dd27147076fc007e3f2d5882ecb907d717026ff552f80c45f44030d30c7401222013f1cbceef49216772cc4259a7a55edf393992c5e0b2f8c1bec064c093cb300a3a67ed1181b724585e9d0c7287d712bd0529bb1ec3d239d4eaa286e9b54f584093f2881b1eff0bc0f754bdea5a459e35d16fb71648774e28ef12b905c0ed2f9ccd178d48032463f642781284d478429cc11287c194e59ad5c907747314634863557930330f3ae4cbb81dc292c3d23c4dc3864685a04ae1a4fc4a9aca4085c73ab8c2a76b7f0cfd5a36d73812d439e6bb81ba9605a3c4b6229d636499ae684eae91e83989d0dfec3e6f3c8dd540c19b54ea853b1bb6fabd0dc882126ff714fb47fe309526a5f1319a2bbea5d7debd4476d61fe9417e4546c4d0225cc42f188d8e96424fc58b646e97f471cbb9c2486957b8d70e337a8e37486bb1dd5c715de53e9546e2a0530c0afbda41b68f0bc3037ab6c16abc7d3af897b2e9d546f8f0a8cb66c831e770c58493c00744c8a987e0dfef62962ded574597877619abcc95e3d28d07a17bcbc45c65129f732b5313becef9bc4f33f4062953ab2fda850df2af02cae0d63b5a86e3399f3be67fe8bce6a0ef8c201f8e71ee5f0f978b49446cdf277d4853fcd2763e81b235b8ba5ee5a02c1849b4af4228a6782361dfd7fa24a6d623ab7b35311e5aff93e3febc0e2eb0304f34928a60393d18e003ea386531e92a763fe033264a5ba16ccb7f04327ed276fae9c6d234f267d269dbf700b88e6016bf2a18ebcdbada7cb106dad604ed52051cb3c7650e920f044fd79f397d8c9b2051d39303864326194a7e1dbf0099fcfcea952def57fe4afbcfe84f65c4b394a9b6efe7011c773e91d52708926ea05c4940b80d7684261318d1421b19df14b8ffbb8a4363db74ef0715af99e2a3464454eb46ec7f2c61ccd5536f2fcc2252ec9490329b0756b1626e758eba6a472772bebcd95750f970d7968740c13f4c29c2a49eb06dad63d6485fcfd52ae52c03958826027cedd02c5eb57605ddb3b07276b2356eac4e5a6f1cd4091fdd7d931d20f36061b35b0014576dff803f3dc8d654299652e0e4f15ca3e624f900c408dd4dba9ca1ad134e04c5456e26ee96d5d70caf132a10f1deeceb9ca6b2092ddbdd77396877d960ee5a50137b812de1f5553b86398505c21097819821e0b2d9614e0ae707b116e83f454ffccfb46daf21c66cc806b0714481d9f5a0169983d1a651760aa587678a8a75831b7fb6223e980c00dd092f8f837dd648c11074d480a028d6d7014e2614c353237ea8e73776d48a1a449eaa384af28acc76e0637f52768e00ab18d14a31ff7a64b2c5af1c752a7471c43893cb9334ac3471062b84b9da1d9a5a8dda77d8d9d788e7cb730df2ae0c2b0f3cd3cdf3984b09b5eecfe283ee4c8951d6b2929b1a5d2c4f7db0a3f7b5a9c46718e6d2251f0eadc3617fbd2a2801433efda5ba558a81d67445ef23022f7a8f48fc06c7b7f1bdf54cb7b2b56a64a9cbcfbb070c1bd3b36188ab3c23eac2153515476afe854a485ed3f0322058481ee2dc302faf6018ca440b74333fec5b936eb128d625d436dff791b6414e59771be6a207b92b714ae5731cf448f783adc03d8331c32f100e526191c7b9b1cb84182d4fa30a28f60915c27f5ace348ada5678d67df23774b9c2e7fb121b9d9b9bf7f1c232483b94a517e01528cfd3bc87bd565dc4ec2b65b01a8ae4cf098e3a0f62ee7361c7ea1d44eb798b656f833a0fb2eb1d6ee147a4b51bd66df41be1baf314d74608f1a78456e5def77a609882f412f98200e9320c5359ce9c992d1fc5de405d6634d4b5c18f312560c8196faf17563cd771935b3181efc1d4c65b81a0b87a1fe08d002d459065f66cc7a0bce3749e2838eb4f16575467ea9437e9c78e5b64bdceed181c37d5890d6173b1a60a4f349841a7732345bc4fa72a3152370591a9212a0f84a6502c5dca3eb5267af0c700edc5bdc34be6573646d41a4d8f737919c5755b2f09d3531be22cc226fed2f03c16ef841742aeea695c8677c581e1a567c48f975ee3ea5662b60d54531d82c95444a7bab9c59c8355648441ba1e70376738f78aff464fa76bea9c6894619042812308f68495a2987786cb6cacc73844e70dd294cd535539cb26782bd725e9aa43294aaa422cdd25cf9dd89824f058148cddcbd672bfa74727c2d807bd0cef11553f9ad4c0f39692498d19006450ed9325f13ee166917f57fbcb5bdc221e5968e780f3ee6c7c7d31e065ca1ea8de351b8a319e4b736d9ab380475e2077721d7c2b2201752ee6c35182759dc752687cab0557ecfc3c7777d059c70e2b807cd4fd862da07f1c3b748b76e693a013896daa8b2168f4b364de3df8bc273928d44ff4e69a0d89fa0a1a7d984269cd595578251d7689746e8270b8ebae2600ac549a4c40a5cc0f33af40d6d4b8afa9f101294e9366871c6af2faf3a46bcb3296d1577fc75be718e27b86d950affc974316e386106e04efb85a7507e46fae51d6246cfa96fc327e85f0306fc04fc10bb3e1e36b6e03464ac33a556f8e8886ba7bec8348e9bd75c2bbb0d7febb7ab08dd688f1f363c05a66a452a019bdbce1b8aed725bff433873b9a8caab5b269409694412369c3931d14ca212e23d826c3202d08b868b7f5ae15003074c6fcebd4e062e23b6aba23d09578b60debd638545e041018259138cb74f7bf0be844960f9bf0509df78467b2961d9966f728ae283b6d5aa17464839763c7b79270efa6f893759232a5eeba222f2133741318267ec6195a06a25bd30799b3e256604d193e903c78d28a6ed43c3c8eef7d4d2f76ce9b1cb36665b9ccb20b8f1c53ef41160e071f9a4c5eb749c3a9b716aec17ce1af02eda509c16d3ac7f8094aa0562248261fdf0606a60813b3ad89a29cf924a0a0214820287687367970f87875ae822989ac52ec909f644b519992ad44a367c0e93c0ed7b1e80e788b9083d6e86e543ded1b9480df7c6e96d03bd4aa079a3587f8da51758cff6686cdc14342","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
