<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b0d72f6864fed20ae9a69865530751874f80c3a848f0b7164ec6fe679bbcdcc3224cbf42dc5aa158bed778ead93bd5a29f77f97d380508bbf688097590056ab16e8dd3163d2f186c95738263df331bf2279b8ee726c0326c07b26e1f9bf1e4bfb24f8751e01a89a25426bdc6fda71ac6e632c165fa48cffcb6d7e2e267a46acbaab849741a265adff6b7ed62b36544cf0ffe12a0368b91d91fe9fa77982c72658e9cb0357e10851981e1c4683350dc35becedd6c6d79454526f4e7d20c25937b6a1f9701ec7d3833bbc2e35f0a8c3d77432d723a2109c75656e1c2b2961c10fb6ca4f8c3de464c4da589f2c0e2597ae16fecc8ea3b16078718c17fa2e223068305a8c35e8807bccc8a005d5470a24d5605e2369b3fdf18191d320f8e127534cd65eec5f43db2b4960b115315cd3ccd39b182e62de144fc38e172b0f229df4485d27c186b55b1a2a0bff99c7284de4a7308da9cea7533b04729d2aa6c17a8defbb9e43333857e04aa2ec850659d05a8cdfeab56152b27c3723ef2ed68ae133cb18c10b09bd8edea8a8e72faeca05be21fc8c762e7226c7d09e22d77df22dfa29c3c41beb4bab6c820a76ca5597d951c4c330542652ad0ad623a42a6066f8d7327b45052c746097a974f115c28badc8194001556f55328e0535b343c203d8b4ad231f968c8a1ea8e1748a30cfff769a705e8be69ca8ecd1d83fcbc8ae30636e300b99b50dc18a69f89b94297f7181796a7fe18098c7fa085b5a8476dc569b048f571470f48d141f2b2c8a747a59eea3815545640e662cbd31498576fba1f2660f7dec9537875192f602e9af9dc7cd4e950ddfc262c3792f2e0a1669bc6f11c19f067966ce712dbfc8b8365da69699b0ce798820c00e1c2607552b6f4c19e960ae99ddb76f7f0c7be54aead78808e7afd74591c00b3a19817ee5b08d86b8d9e4cae6e7802d9060940b9d01d22a7e531417bd0fde959fce37bfe227545192672ebb7a6790d40df7ca6967fd258424dc85396a0355586550ba8f0b78da0cfb4849f1c8396be46319b6e430bdd63122efef42ae506a2a531a48ab089ab2f5e68a470a0d333e95c57f9042ee430d6cb3ca6a6b01b0ed6a91563b8a2fa40cf21c75d92e7f6b8f5f047909b20cad220867e470276ff70463f707fe3f7129e4647cd7ed266ce992ddd28e64956658202db9f95558b8482a7c350ebf4c6b70d8cbe862221314ef2229195e1a09ae0201871f5225bcd52eeb0600a01d143485ba740a4fc7ffe5043d78e0de86da1ca4ebf70e2441e8523494341f58bb8ed38b2af8eaea5c4e47ceb6f3c1c59ca81e16e4bc616481d582f70723d90e74cda4bb2e6240b59fdbe9f8bb02b093a9c6717aa662b4b4c70410af63f6a681533560c391dbceeadd5209f880fe3afec3d0fa598253b2dd9c309d3c85ca027606fa0eb20908d71307d82a0706775602a69aaba2ecee1400a651a99068d8381ac1172d9de3e11b1adc2f81a6abd4aecf1149eff30c8c04605d1bf962ac1394778c2657ae50bf1f7778a42454facc26c30091753cc14aca7bb504b6412d1213d4b265fc5f8f0e07f42bfcb1f9719f041511c4a9d2bc8745c8417e2b97203582030539b7385340e67baac6edabfd8cd8ad4acd99435fdcf198f58bd420fb59ec53af810593b72de704670cba49c0a2243dc0d7afde14c7f45b2a84908ad355bae8ac8a8ed3f1d32b065ef27e2945e20cdcddc4ed473fb5f1a13a801fe318a0d76be7e7f6ba9e692c64ffd2ce61eeae3afc555c8763a5a5ec92c3587003fcaf8c43522fdaa15e7df8da9469b29b7e2a5a05d1791ba723f4ac86c6a12baa72ab9d4e545c7837de5728968950dbcef1c80c389fac93288c797187217ee91b2e17ee8f247e376ea0f9a6061153e7201ba072ee71a74581c109ffcb3b8f86d3107fce466d387f78a92164142f37baf20feef2c86523b63f3b251deb30eb73bbeb3e62e08ce7f1a0cd8c1332ec87cf1afa7f97d77cc38dbc488ce999cdc383077ee04e646f9ca64b3091c372746340c87c53ecae0f31bfbec7da925d3b13d55bea32f479faee97bfb66d27d285d307a828729a7ac1abd7c18963823b7494bfcd36509ab88b7b2ecc26b3bb77169aa527f7382bd4aed506bcff4cef7468d4fda662656964883d0da0f7df369353d80c9d2bfb2e0bf591a3c544f52ee69cb9016993dc1e37e34fed1569cf1af6a46b34255350c62ff9e1946a299fd61a088b395777782243e948c6cfd1d0bc8d409e1eaf2c46dee59545c5ac044a11f8b83e00a7064898fd32720b4d1ea23b1fd3556f20ca3a8374d90247580fefa51995c97898b3053c808aeb7ce4f14ac2763457ce5841d10e70d4f65a0f6d6a5d4000e1b52a65a59e331e8d68c45199618dc423d36e89144b2469fe88bc4455b879ecd6052c36498fdf726771bc16f336d449f0780cb716ba26fca994d59bc77a69a03e9c8518e041240acff069c77eb6753ab0825dfa7bf257fa31966f9cb3001648de1a4aa09c43b102135412639b2a8e44a2f5a0e0541eda12733db74ba61a83d15fb79fee1b7ed9f953e156e4a9a7d2d61d7bbb47d0c8e18243baf097270e42219284f64a897da24e640229bbec6a5d2651ca16b1affb8acedd0b300426612ad039a918ae1d1e1981f3b3cd1f06f827a8de4f9d026d377629991ba6fba47344fd643c8b9d689b5459eda61c0c38941ab23ecdeb511a813f1d0f75315d208c757d4a450a390ef7ef041f0cd343dac42ed6a68f0ff59de975d9505ad19edb12533b2d8511e3f21707fafc8dc28c79b33732e7a250c7c512393f3c5a9cae4169e8016f860c2e7f493ac593e4d31bab79895129eb0cf5df16e3701b98b46865127e7996cdec76d4409557b8e386c1437ff1535c63d3edcca63a5e3b38d53e1962d727a00b32aef3a6af3f543f282f6660d28a98fb2ef1f27add68db971094644503179386c178c0c1c459fad6c75c4fd64cc6718fb7e1bee40557484f9c60105ffbe4f7d64f037155c08d4e405a9a898a821df2002cb2d855b2f1981f59640be0b52adb71cf00e0391fc08fa1f350b75b31bf719815a1c2466eca1bc942ee1be05c6a9a0afd0e7dd15db3f74524c9827624c5e2cb84dc67e793ed7a77b171cd1a386abf9703119831747017d31a5f63e507129ef229596b87c4adbf0b8b15279bd52077c05d74c2f77813d67f878a116901bc926f0e9dff755079068360b76f09e5699b59dfed6525f0c1e25009b21f50a86d7c89241df1a5a734971aae6e85d15ae5aeb3fa33de789e315d663bc1a4b0e4c6a6403840f6731a47af4bc8dcd1bf821dee070eaefab0db24599068e6c40a58790d1deaa3982cfb1dfd1a06d1f0b3a1106d4f3fe25044b3f4ca78b655f711d50c69ff1a3911795071346cc3bef6c80e5df5b1a6b48b4ae7f7dbad02edf61532fc9bd024e97fc80b5cd71621607fac0751b715f4e9ade74562d7b9bfc2e666fb9e5c3bcac6eb041e7cc01d154874e92502ce06f0eff7763bed61c20699a66bc616bff053b1de27541ad55e6c581eed1910213e633084ca30f024c14aa937c92c8d44c77e44bbcc3cb69b09fb0873024169642c2710b4a4d6363627f829d98e7d8f4ab960a00392af0975d878fcdccd5b7d32be9d77fd97275dd7825456cf7b2f772046ed7d0091d7cde53cf789fea14ba40a388c889c334b94a0c88a5e46af91923d58eb5ec6c4f8007ce978acb2ffe0b8ade70a5e09f83c9a1c91d98022cc2ce7040359ae0e9c9cd6182755bdd904af490ae9dafc40f7a45b67517189d6cd0ec4dc21ca6c814d503382d36aa1648b4edabf75fc2b3c9bf37f6e1b4b70d8ce7bbe8cb40e903dbc2fee1e394cc6fee800190c5c475d4ae7d056f87d0afc2b5a60dec86f96e5510b18fd345b833761662da00883a4f006a6a378e5718064dd4e958178ab20d774d241b2d6ea632241e6af230f0ffd350cbb12beddf025ddf38d838ee2a54f8e9047e9ad9536132d9d20f5656ebdeee3dd8b6af95cac5dcf0db05bcd7301a90369a4144b55d2562d9d2b24abafbb5623e30753c2712889d9d8e999830776246b5321016612afb6e4ed54d8950f0b7d763dfce460448816e7b2efce0f1d1258e0cca77397420de37deccee116058f2025cf5b9fbd8787861a4b232d537ed4fd09df427446a9c622906d276defd729596c3eb24de54b7aca3824dc9df3b114eba6092ca1ed670ff8f4965b0471364b2a46eaceebc7f7d8ec685f8d55b1935cb4f9594236061f67f9c111880520b954368c1186d3f8b6b3a074792ef9de6508d79c8bbb8460efa9da969928aa588bccf25e14397cdcb3383345f74ea7b3190516e0990ff71a7d9e1d98f7d12ec03f42cbc665f5959b7ec475f91227274bd9b05dc7d334711389c8f7835caec96cdb639cfa9f14de8cd4c70912522079b1473416d4d7c4c8a69c504bf7141daacc1c5b87b7a832e0124f2b916b90c46baed380ad5040034edf423700b93bd52ebcaa5b50c127e8bee43e5fe27bd506614af341e85cd8e29ec90dbc96a9b8cd2ce2b61a0a5aa36b268319d04a80575e435cce93cc4736f7b1eee9eabdab293d4ab1ec33b8aa6249a377b60e130d6d39fbbcacd936873017415dcb1ff9a5e26b25a7ea0ae714a7b014dba39985c38c0e959625a016940a35f1663931a220f04eadc42f1e2fd8bc39a53ee7b2b460e3bd7504b98ad590316425d4e3df6ebb5d55749340d3ce874a4258b79f8a73383a399ebd86e7627e855962104be170d91f5093e2c69de58a13992875999bc88ad1d2a9051758df30cb85f81870abea8b6fade84bbd02c4feee70c5e557f8fc9907981bdcb67310215ddc589882a1d6034e4907cb1dd2a7ce479ecb4b97a1132e4a9c35636ead52b9154150a76cb9ca768015c3a24ce05689a1489ece8cd6869e9ba34aa5d907e07a2b99555c1c83fb3c58161f4931f549285b8428cec7d520a6361b8c00196e740c0a1978166de1ffcd948e5dd2ea0218d4a869fa369d20fd3fedba088b33e7c1557fd8e4d919d380596f5b03e479d1bb9af9ba2e741c167c4f47ba6215d7f8cb3702d320dcc1c077e9890856e83c695fc31136ce389b243e59140847fe58da8062d4df8025dcb0f5c3084458c86675087acdec3b3a1cbe3581f48b57461e16d2f8032deabda14e08cf2d289d9d06f6f5e332e0aba92c4f2011913d8fa245c947d8f6fdb8b9bf710593aef18862b6e887653ee3d38be2a12e2fc6ab3b0075e0bc33ae1bbf19abf5ca2c33dbfe6588623d04b8b7dfa0c7da6800353c7c686a2ac3539e06ca4964dbb6cd51cc92e3e9f901c8469aae6628556bdc6098c13193bb7e5624ab7c34da802a8356e5ba1d7b7c6b5dc8034b8afd3877d65ec1169e2e358d771714c4516a56571ca41c937994cc3a2ebc9274772869e5d1082ddbe6b997d6d87c4676af5b848a28c25512db4b4e7269827b37f84af8d2fc8e2c191e1da141b71910ee9c2cdb4b543ba6c21fe52d755c33cd81258a64f5cc57a8a0b6830f6edc70db2ba3148d4200dda988a2e166ce6fa6cba3311442cf3696c0cbeac6a750829c5e4eb7b85f03966e82db56c86b57a25990e5b4a46e33da060959497d54024100f433adb4948bb7232ffe0397b8454f933e87d1959215cc0f132469722aa1a07838faf3c075ad5c5e925bb675a24c22cc76dcf7893d322d6c44b1d614437683b1bcedc689715f5565ef0104172fafa81cf4208416eb24a663a0daac956233c6c4da472ad4aee26136ee45c248edfdd87d781638c3378244430cb67738a7b378cb58c2af2d372132011b9b55df5bc1747cb04ed0f22726ae6d5ce486cf014ed8b1c8e0e7f50cb978211b9664d890dcfe2d13e5935bdfb981988da8fd4777b809967e95c205bf50a97cbcbdfcd6a9890f4cf90f22a59853eb2a7780c999c9a6527757aa44a56f75cf96e1b7718705bb7110c3f5abedc6ddaedf25197039f76031bd8d93ca12ca68ff48d9f950c051e4569fdaa945dfab351b7875967f106aa86130e90bca0766e672cb17e77033bdcf7b808c18ab28b09936475642a6078138c6c4337bb6fef5ca738f8a4ec31632b0fc656909fc4a01496d43497371eb48443c7bf2d647aef7005094ea55afb0774e3c15756474fafb7889c7d48bc3986102963a1b43162af45af693e257dec1b21e34d4374ff724b89f1262f0f9ee74b73e413bab9b3a57408856c5ca8002dd9f14a80f57f65d672c197dcf96fcc20995ba0179cd37af5e15ab10eeb3ef973c5b464b48403a7e23f74983bdefcb6f1733f4695e9cc661b2495c4b65b0e047c165f584e36f74f6a482b7574a0046cc8b69e5bb932d27e373030677a67f6ebc3cd4abbfb8ad266143f076d95b924a6176cd5657c4903a31f0fcb79cf8fb14bcb1e28461534f88581d361e537f36343ff435a19d5f9048ea969f18616f784293679f11bc4874c62c688fdf36c4318b2cf92f708f964cb6ab5e8e8c7ee93092210a4599d3b6acbcd7d5923383537439d54bb25640571146ecdce5f342ee6793b106a55a623def5c7d7aca51131d3b385d1d943928f309340c6eed5d2e6dd5d863ab4090e11ca84cf08c4de0cb43cedbd954df5eb64f2abc30b51d68c401b5b03eb3b491cd5bddb8a71b1c1bdd4aba51f4df3aee999c836daf4504016160b5419bf5dc86fca29beead65598a327846d332f09cba947afd56d6c0fbdbd749ad37fe656df81c834927c687da086e588031571cac68104f5aceca00023e05f8578900007a0dcc6d36167e71cbbaf766bd2bb0a85f29ec404dacdce177bfaf80ea16a522aac5a0b19c246cfb0fdac041517c658158eab89fb5ccfd2291f6283fc6f181d7928e8ffd7d2f7fbc5569b86fbe5c8d05871339242d074f85391fd43a23a6802350585bb4c793cb02c9c458cd7f7accce589f64ced2ce4e92a371a355f1dd62ee6f82a46c584ebfc74b765df5419cf69faeac5f01f9397b79187efe1440c4bdfc48e8cc6d3496d753b94be823ba6f13d906280f645d5911064dad02f92d359f8cc12564fc05b9abeeb2200367636936eab0b7684dee53f160edfa390083b0b55efee36ba361f752aae7323598cb94bd706eaafdf32442ec48717fb8b2c753299eef97dfa4a172c99eaf468790da19706aeb659864f0857cf794ee0fcb6b6ec02ff548a16f0103b8e429d9c69fb710cf0027b31573d88400d90cdc8c2f6582608c79a804e51c4fe195bbba3b0cec6b40057420ea5e5b5199c10cd4ea720c4910c3bacf93e6c4cb0bca49a1a09804b75e96a1b7a6459a5cf63a28e7c6e6cf31a92622d03c5d97c6162a2e505083914b38a833df59fb78974e625472ca77ac255a7e94b342db02ee9dc09cf24ca84abcabc7b2349337ad711c4fd04456c5bef159da49d235b3c6032924258a24fc756d21b575b67f5bfdcd17f88e4b01ee47525ef9f77cec3e7d6a38fe4d1df8c241d573f5eec1c683ea2864cd7839447b9189d9d4f58d8f602654541dd8f3ae7a17becefedeadc24f0f812c56af4ee1bcb8a6f9addc31645d8bba19fd66b6587c4ef2abea1542e056a6a0b6a4bd3b473afe290a64302a58d687ac8c89046aa25f2b579fab9f21fe1f7161aad241d86d5ad9cbddadd9ffda642ce1b9e1a63633874f6cdfc785a40bd60c6d4d93a4ccda515889bf56a907f51da4b2590dc6e02cb3922c1d1a9648e1765b6dd227f18da4130ec78998240b8be03efee45fc8d0a364b4dfe2496bac53f866511614c8061494185d1974b627feb59b242940737faa6a5954bc7af9d7fcf81f5258053c755a7b1725ffd86819e74741ec2696cbb58c2eccbceea5927d42abd68e3b09345257ee32740511011570e6ee71b8736352fd560d4bc4383aa6da0bc3d10b9d3b732f11510be8f4c7d1cacd91ea5921a12a4de9a724dc206a1e24ba6a24e44d4af7177e6c022fce26aa08a86397956da120bf09f4a16bfb89e9e3ee034cc6274143fd9da1fd0978ef88954c1337f015a226a1f91cc2ccb9fee7812d41be57dd96602a0127620022c73804469974b357203650de7bf66061f8a93cfda27d825e91dcabb0891c9862d12cf48e9a1d4025ee07115b6b873ddc7401ef4e41e25165131f357f32a170d9f43afe508940f9b734c8e4bc76067519620154be7b95b837910deb1ad7bd8db1186991634acecff4603055f85d283876f170250c7f30fec84e7881bb1f069e2166b3286d0ce9c6a49f227a868f515ba38f074608b9a33e49d26ee3c8c0b8a947998d353c3b1e9ee8bdcb88c7ef5d8286707982d391039024258400c4682f44d07de85a7b07e2dcacce829a22bd9cb4c66ea315480f80582828616f9e720fb1e59a388261d8f5ebdb8bd4938f9ea653947470af2722d8308b8986030a8ace12e026f7f9671ea329b5bfb0a14ff7690a6d24fce20d1315663a21122c118e638579995a8de9e7a9cf76aac50b0e4b2ffcb4e1a73ad84c0e2885a07c61f541edc3e0ecb578c1211acf84d11e2169da6e948498f398cb74757f78a184dc1e41b1664e785eaf053e8ec2075d1373fdb3f3bc63c7568249c8e3373c2f7fef3ffcce7e1f99def38b02c87d681b752bcf880bad32a1eabb57d157b889db5a9c34ca00085aef772f56e38d114ba84b1e8e1bfb279add27598bf3728fb41cd6b23a5c07d0a55bb26e12cd72b2cf03a882b6c2417727ba250d9e8bb07cf9dafec28b22b962767d8f622d2dbe3bd5175f454ee49d66ff0d71e4b7feefea989f4821afb413749da0f622f691349f1386c21209fdfc102cfce15eb3c105d19f4aa7b2eb41e0a62b41666fc15198ed266585ce38043362aa778fb967e7a38a28604e8b2a531ebedf4998a55699370c4c13643c8a81c1a67ee15f5d67f1e08171831f273a12daee53fb171c4624bab94877bac75179d8b8e3476685ee241ecf224b205009e7d9e11c64f8aa0c44d8f1158123631b3bbbbcfc4c54e0bf1e8baba5feb2fed3888d94cc5b82231bfa161bdce27ed0d679b3e2f7cb4cfdf7773d7b253b75f6bcb6c6b39a89df8b4d04b47300263d1d2ad94e7f557770aa6e3f0a557e6dc652b1ae8e01e5456e095b89f9a9041b3ed06d18b709cb97d5c45a5f590eaefd65ff0b29c4a44b61bad2a9744ed50ec183cc07a68066498182934ebe30454ee9392e2e7b1103be006062bad1821325923c70d10fc055025f5196033e055a2451385bca83c5c0c0223ff1fa321631511707afd133ae6050026837b2c7d68fb4f6bc7760eabb08245dcd01469dd15fc734586d6b2e03ec13a1e704668cc3998c49dc256d971958563cccaaefbc8e0d2a31290a3729afdbcff76740fa352f5a1e165c91c293f74206e4c0cd9295860d367ea9d2938cb56daa2dcc6910332c5330d228553ebf2e9a5d32aa7462719d420831814314c3c95911fdefae058c15af12dc0abd28bb33a0cd672b41381e7915cf9b48318c7f1f74edcd3d078b4cb66ac228bcad5fac0e7a66702ed5127d79cc61ba8cd9ef96aed33041e9a2f9ddbea09270b1c705ed54eb54d018132fd2140cc15565a883289756858c1374f3bce1f3b8fd62cd9a29c2fe5672ca35297976cb71c0ec2f2da62d2947bfc78d8a80dcfed61639ec0782e2aa18c98fe0e838b628dbcbb6938d83ca9000ec712b43c9980d7dab85804ae064e932cd4a125b479573fc823b08f823b63d5094a619a114fcee8d1f98e797f85a17bb3181a4e32a2dd515d427a91a443588e43f9f33dfedc8866df6a1fc70e05bf01b7b4a78ef54ebe5a75f92bf7f4e62714cc4a5720c6c568f8ddc6386a1873ce97bf14ca62619901ad611758c8bcfb9665b25a370088fa90cf7a0f902a1997f3d16ad6a735b326e9a8cf51de96960d73137abbd9be38afd99a0d6a58fd9753d836948ceb5001da66d1e1411415a2bfe156935bd05edd75a4074100da2a88a864e8c51dc8f74974750c96dcd2d802293dd77a9301ff46a78d4a2b1ca184547320ef38097d2ec508dd4f3c8a1c9ac4834477a7edddc0ad078bfba36aa989eda62de78b4995511729f1cb308532c71bd11a155657c72d47a951b5c0e41c6f6ab9bce176a30108afb1e46455906d86d718500e17a681ec26710096d42f21a5c9d7fb711f9a74a3b06ebd796057ec2808f240e58429cc0558b6f9c6141225e4c15c53fe828e5dd6c97671edda3c22f79a320ebb5428fdad480df6d4428b45983db330412eba09791bf77c60ff6ea8e40ca9db15446ea66ec13f1b8cf933d9fa4f61b9165f4ae821c15acc4e29f1494d83fcb39d0f560742fe56268ee021fa9a70ea70204c20418303e353df07dc2d82a912a1a79b7438dceb6cac8d2a9f7fbab3ef1376015c9aae663fc1326dfa9a06ec16b1f9189c434fa309148943857d6603607af486ea7d0b9ee630031b14f0ae6f0bc7c5b327168a48d56c6b48267079f96a8914fa01f9ce67c95d67db9b44379ce6fb524543c99179dc9404424e8ee7ae927b97035ff0a9937916854cb82b28bcabd4b4ba9eddf6dbde336d26cc766ee3f071cb2a1ba8a650ba5b7ac69aa0c4e89542572fa347d85620f5b961a147efc1e37b795a5a7a30375f299916797496c0b1d016b8cdaf73b25afa587d3e438e1619056251afc450b63cd86f920e84915d93f049118856469688a7c35f9c53ba4f10979446a8217d5c1ff1f6a9b56cb7ac438901158ec3165ef271da924c05f2c5cf56d39d3a4a187e20ca99f7ba01c1d3baf54f11dfac5adf02c53ce1c3981053bc7ddb663164280ca79762f94b7621a2c1b188d589e6426bc56e27f333db4b48c85211fa0c96d623e6c2e9ff6b9f67c3e165765f7cd49202e69f3655687053c5a95fadc38354a0facd68012408c4e1e53ded429b722b220ba5fd894bb85e8d46265b21790893562c209b93013911529ce6b57bcce331918f895c7898a6dcee46a94d3c3dc0bd54ca6f748ae191d54810492a69cd613c01b854f21e19f1da71b123538c73bead98be7095997cd619a514a2abe6d9ad1bcde4e89d6adf2f84585142cfe42515358aac5793aea5321a8a45df982b04813308de9e0b2d1166182293da93ddfa84d476b599dd123ede7ba9a8aa2c63887de0dce2c7fbfc6b78d69b765eff6bb875469ad2e8ba818ffdd41b3cf19f1fdf33b8d6c58a220bb4df4fda82adb141789d271152cb709cd3780ef80520238043f231c46bce22ea1ce4f46e5086550a85b1330b7ac17e2f1b4cff2e1c304a0230843ddd4c2b99d15d0e25d015386a20388e9d98aed202c8ce5dafcd64b9b634b2e3815415f9b366ea5e3f6a0dbc8f5c2ee8d608419d63de7fbf7d59f6e9e16146ff4b07dda4f6f81b72a8ece16fbf5b02c8508d65d180afe050b4bbfe45d7d1e6c4e8e9f5674d0744250512bf7fbfaaa69e73f3414a1f32aad3f19f4014e6153643243669cb7dcc40adb5142c5157113ace870b6c5d9966090024fcf8b70f866010a7a76440854750e38e2cf21d224a6a94265e18023cfbf7ff20303d2a7f1658b5e2c8e9fdbaa6e6c41b1aa401e8f15d5e54dd7c07b59c687242cd799a6bf20bb4b6023f7956c8bf9f54daffe77cda41e22272a9366ac00a2e3a6afaf735206c44983023bc409c6d143cb391a2a75df69ed5aff89e70d218fac213bb9358ba498eba90f58d34334faa4eb708f9e2b997ef552fe3e3460d59a0b8c161c4b82bdce486719f94433576cbf68eac4197fc352093926839d984e2c5b9faf9b7763bdd69cc50917ff50ab30c028928c2202e8baf7e84db1d72c901a404fd9b4532d3e08a00c9fa7cdfdf5d10cdacc612b9c6bd1620c1d9a97609c928235b7c1e686fdeae974681fad716125e8de035e66ac21a1b9d17b2162e73c1ad7c6e31ed499c9b7912a110c309494294d5f3e28ba3331f92f8fd9f6d1beb2c49332a6bce5cec0ec01fa39af19917b7bb11a59086ef5b5cbc5fccfe3bbf2ddcc4c34a7ac44293b2c893ea01cf3759927813c248b5a1dea2e66195d30e04dfed1dd55c80dfaf23ef7447b5e848c6181496ed361647193725577729274d9ee850b5b4fc6cd52d1c33118b8bc3e85e4bf9343b1f42bdbc68c7bd06b60468fdd4cff0997455f2227a26def81f0f8b4b35c39528ba2e79ab692e1884d36ea69892e731ee3e1a612245379a3badbd5fb25b958289112f5258cdebad817c89b63868f3ded32d62beb3e15b6a1c63c3ccb35ff9445a770af5972470201d23b9a3630027a932b3a5d67b583146a5dc39047c319c007ec61a7cc74699548f84ef59839da9749aaf4f6c594185fe99729a6592bd57b61b1d77659b663d56366552fc2e0a46a89582490ab109720816ed444b7ea911d5139bf233530db92cf045fcbfc250f3abc1aa32df4af2cfd3baa3aea87828c1ec932bcd69d401dc5da3294116961898030b5b9e95ab127c082c2c4e71d9e1898e989b77aa17f649284f23d25e2b798a4c24ad521afb5f87d1c0e7a22930f7a040d5351c24e7276dbe420ecb890043f54a88d9bcfa912e8c97ed27c917f72fd5b492aa325afc4ad0bd8974280c4cd58939081529191be614d37f8c646c7c4b35e3e4d002a19a53a58577fd5e0fbe8e5473c381631022b1a4e15121517a4c96562a6bf66e0b7e13a6906c95a668945c29850aa1af8a64efe96320369a77b390e7b9ae76fad0fc27813ba3908429fb541e0badb36ea71f2c33f5f7f602b8afe09b30141e816d8fa8c068e674d5e87f8e0ca52a54296295db4c0e35215721e79389fc74b97747d408cb925623c9201b529ce12d4243c09bbf547b43d69888c71ef57b36dff44ef0dfa256afe82e326a0d71c4090fa735ff69843975b12b22cd2f283d8556e24d6544f0883efac7b253f5126e382f8ca4c70a05d815e4ed10189e347483bfaa21108c28bf3f926babca572d828b979037ba14efc96074201cbe1fbbca9a5fcead2a07367ab31824d25612ec1686a1fc6fc999293239eca004411f31f0e85246018863c32ff1889c047a779c41851178214a68c51c8613e5942fd6438df07bd97c4663b796c91ed0aaf24c61cad591337cd6e9235873f5f6e4a573f80a5b475b59758feb81ce33501bfd8b304684a3ab343ce5861630e44a3bf32868d589cbe428c068ad5790f6ab581a91bb73abef379581a3155f5d4fdd3309aa778c5c7c40f0a1b0f744d72eac72b58861441e5918e0dc2ca2aaab661028af06a7c7deec0d18b4458efab06ece5f5dcf1d1972fef1b6d922a059b1597ceb07dcaf6c471fd1b959addca229de6b52202bceb8f67566a34005ea86899f2746f9c433a06062af44df44fab91b97cb927574650c8641efbe30fe5359a26d910992b9f4b86ee6facfa8ce41f478b2f40d429ee25ff8f0f246ffec746d0da9e46a9a8b7e4bd304dd515bee543bfff7fc2cebe671c8fcc9dd870d65fa248b30e5676242e8f43845828fbba30fdda9c97f3f4f5934d80c61e0a9338787a530a58e51b1fc3cb64baff85d29ca72ff30f77938f6f2948ce42eb6c8a15bfebd30251119a1c581d18d359dca15ec07cf6aa6880a80dfddd18477f14c2b0da250096fae38f2284419453d6310de1f8b5e906290a8ec9103e0ede6d02ecd757f2828a55c452910df3783ac7922408b241d8cb5fbf24f9d4c9a66a0efab0908b2752d8ece34d85438a62fa8e1d0bc1393b7fed5e995e36a799e58a87467596606705e6ac758c47a0c5aefbe8ad3d63a06eb0efb661aa77d936adfbbfc873f8029568e32ed6a9465eb5f6bda5db2b384741e80975f17a318af329b86a5388cffbdc0af938e6666d88c17312c815ff153bf0ebe9f26279deef255d86f39b33dffd9b917147ecf1ffb487966e78cf7f29830588a4d4c4d6847e9bd70cfee053e76cf30f5e361199abf5378b6470030a29e0fea65e4204677393d1b0df2c2a1ce68499a4c85e3890b25c7205f5ff7fee2c32e60b507992ab6ef95fa5d734132fb1f959e75e65703cad514025271c904b59c761ad40670a8057ff6da9ff0a1a28c381deee6f6087faa0008f8c55198e241ce126664b19b8d886297b65b267a98e735b4e1371db06e8641b85b394cdcfdd41e5cc9f2dc90cf7ea39e4db42dda71caeeba125cf8fff4d557962eb648f729a39cdc46c92437c5a38d95641ab1436488e7e3335335766d97c0a072785cf86d34c8f66e4f6ea882336c5be1be4287f945c3d905bf7a79d519387b12e1d756a5dce5fded5dd8ebe8c93da16d2d9e50b80fbf047f238f9b82f6c3afed5018541ec82ddda63b447c9cceafead1c7dc2961de4d460ef40f3cd3c4c04c172302bcfe19b06c252c7206eb11792019091ec599210d5800830b74c39c626ce05160c893ae62999e8f2dbcec04e928a477c5b99f9a371fcca77ee53be983072ed0cf698bbf1891006bbe2d7e988fd6e03b8615ec7bb08ff93712cdb0fbb11938519d45a3cd5d7065bb1dc4cdcde2a365f4ddda52f1d2796ad9e6a77d412719d48d48d403769522524b8db1ee5e10feb6d86a42dd57bf6eb48645ea8c0a970efa1a5e6e0df03dd7af96c413e30b86402c4ff84ff0180da76d7f868e5d249c63648f3cec2bdf47863c1a8766ea386861caf09b2b5c4263cf3ed7528850599ecaaa983e58ed70381aa42d1ac1b20b89dd4c816ca85e5c3fdd0a176e1fd8bcce66989848195e2eb2ce1729d99a5670bb46ae733546dbdf3659dc245584e9b564032dd52aa020bc5d7abcb957f87751415667167c2b656dfbe97b1bf583ae096a9dad2ded7839a766da4328f8c62253795c3e0bbd399b2cb39caa97955ea0e071b218878f1bf521ea2ac9ab0d181c56fd33e0f7ab8873c2f74948de74a9669784f6bff491e9a5407cc316fb68e48f36d8cef3fa8b4bd36a1eb65aab066e974d196bd769b1bc46c77acce84902acacd26f16432158b5b6efe88041f54bffc1b0e69a1e7af06bb755deb13f81bd0b1476e5c200730b6314ec5426f96fe1f59d349f246b92aae2bfb553b8bfad2573317a106aa474fe67f1c673327db88c1ef90f40463eaa2d4b89d018199bbb981185de9f87b4b5c7147d9b3e4a280324e8b06e2a88b61f2041ae6dd7572f7ddc16da5279ad32857c34c1fd135d6ee6156484caafeb600fd7139f133a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
