<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6292b2bf33ef85b6eaf2b6348eadc2173ec48c9bc3dd39fae45a8b788650319aa9e13dc4f07f6778c6f45ea0437a1fcbb078aa15f422e9c016cbca0bc04df72256c70469ce05177ed643e72168ba353d79e9c4f69451a96848f760c644ef201c29b32307cbe78cf58aa57aebba63bde8c2fc0ae99a5cc5e220476f654b98804c44426df46b5613b3ee280e7bbdd4becd63d7291ba31fa0e2c7ca8184a66320e45a2f60175dbdb997dca3a202d64c0c4275aaa8671ffbe55f3c760ee73e4b56c7e36a56f5f213464cad05ca3b97b7ef3b61a87bb9c95366c75f40d16f21a3d130639c73549a8b50c5323256580416c056d01b26859e6205673c16d7f1d85e3ba514be5f75aca986e3f33fa7f473609097fce448295ecde62d4152327341d4afd6c8039d0ade5dc631b3429a9fcebab62217db6922b6d513ab827dc48e19ee53ebd1fafd90f37592965351cb97b90d037cc16b02d6302bbc343373e8f7d42e067c85c075577d07771c317fd0490036c9a62036a935c7084cd087572095275e0b408ff8f36525db94a626c42836dc651bc401a3e162dca70dcb8e9bec47b91876526753c396fbfa39c19adf076ba7efbb2e52543cc03e3dab448b2e7869aa6901831371e2607adef6cb24eab4752cbdad2cb7c7c6fcca2d78249769bf10ede4527db28824fe07dd326d35d945533b5b2e56859c0acfb94c31b183820dd8e568e0c198036fd29ac46f1ee00205d601133a10ac7550c3b85857ac70e46315d4c346799320b55a9ebdf7120a17b2ae22b65bece373b87c24fa88ade0b90a6230fc7ba4e6ba54a4885ce219e236eda38bdda460a9acd791eff007fc4f60937462ae8755f2702bc0edc40b0b8741e3d2898bc581416957034ef7a393225c698e95507dfcc4b055b0f3334ff4a9b36dfbdcd36ff9dd85a8d63867672d580c9864a2f0053960cc0b559055c8ee5767af507a5ec34ea06dbc618fecb4e30182a4c6d8df7439826e257387fbe01e9a02a048b5ecac6f2244848e43b30c42168ea7fc5b012e14ba568ed0dc125da7fa3f4558e5a45f9d1613edffb631348c30e847c20c5d517f67941a9676471cbb64e8d8be4700ec9ca859c62fb5814c41b9ba1ec273da5ac0e3030f95c2b550ea6267180b231626c58fcccd96eb46bf1729f721b5f7a1d99a881ec75774382986d60736ae9325feca08205adde03cc9369e989c9b646cd2c598bc2e592f2e5a984c9485c366468f6c39d3f9f0c3b621f6ef09d193b59b7249247aa5e5c34f0dd15e6b60ee5914d675159b86c9eaae040e8665a66b38f2735f8598ecb60238d942645630e1d326a66ab200293b113ea1c13dfe878487481a34e01f600b43b21f23808d86b0431e18ebb5d5e18bc181d937912310cfc65d041797a26ef525cacd5ea9587d3513981ea58accd3718d0694372cfce791b818d7bb7c69ce2611490fbcd4a88b86b83ee09c6334d55200623579f37beed0dcde8fcb9d0f9aceda28bf660c1719bb1148a5fd427062befde304c164b1a587c09852a2e0263f85b26223eebbd8af2d3f77c1b2b91b7390adc4283cbf1fe437b3fffa6ec7d9055e5729ae385fb28a227a8ca735a7ab5309de3549812bb028034b12a65e99e41e0a944d5eb3cf0cdec13fb997bbda3b6f15ab7708598147c525b76e3b754ec40945089973913dca4a4946335017eb649b8b24b228dc0ba611d97b215c7c31cee749f128506af98c814d9344f2058722ab59cdc39bc28d358cf59c67ac892637b47134d3cca361af5e48c57f2d695a1c922796613fa2729f74c990ef5d9dc04160382560625293aad063b3a491aa86cb53e8a0e2a4750c5c246d35acdf03ce549254166df0f1297c487509d508e81da9113960144677dbb2175ab75fffef1b2e36bf62776a6c3353404aae92d8e957e93109ac3b7f7beb7719a7c8b999c0d9a7857241a321e1792cbd495aa1fadc1ec3f9aa1453ef8b6b6e634c98f8ee494277ca65e4e84e067866117f9448bd9d9f76f13ee6369737bf604c1a5371aaaad9f7eea88e3f07245f7a53c52c48770c75945ac19ce08387228fda5c00e22252a983c0547aca2a4b24ae0ee8eeb286262d1c64702ecc480ab7d46e48e029d33db4a09c4e8ae44fb505558e71a95e2ba1eea3b8e91d265ab61bcfd1847ae9bc0a21356a5e4e66be785d34d3a1e5278c8a18286c95a47d5a371f6725105bcea14987749a1b086410cab2ed0f183cdb507e7d4b2b58d6fc03b0b2f43e3c86529a206c779948f601fd2ec811e9792a05a1cce7b9e81822e1eac9cfda36b8bb5cef0614c4212d14348b414030053351234359b0e4a6a7657b9986785fcc01880f8afc853fcaae3a0f05a9a985033f81f99647497b0cbc4d6110d152afb90ea9bc281741429047e9852c7919d4ab615931bfe0bef7447e4a2834e59369af6ef86c1a5d6e9629762abd064f792652de69d2daff707c4bbe9f8043092078582e6c81859e716143d1760ab3b09d38b0909bd4a2ccbd5770f9ce4c3970360293d2b207d09adecff4c9f3f98c9a90aee4a189cb378de247b8c1ac6eada0db4b585ba25707b07831370e00605c32668923da0296b2a13216c79afd3d78dcc12c7eec7373bd060fee7a53d0425a9e57e753160e1f86c66d1032ec321765288a88ac46803dea021abee70988c6e271bc6cc6c6ef1971a786c16aaf65d11d4c50bb68ecd0b0b774ce2a3bea0ef899aa502474213bc78ee63667f0db39776cbb819365d0384de0e3ded2be724fab479cdf059eed38b9e1360c6da2b2538c6e3ec7db27842a0dc9a6043783bc05ce671fe07f0f2e19815e07741dbfd8d16873ac6a2c0779e5b26cf6bc4fe92434e4121e063957270e1cd2556c01be3239cb2fc845b6e85645dc2784d0039768da084ebb29dc7dac97418fa9f8c865c09315b0796d08ac0f63d2a3eafea673cdc48cd68d99664e8a220c1f59b061d5e840218ba4af8b930888cfd4e2e6d03cd3332e38322b7d7de8f20fa470991b756f5688ec9ab79f60a3e95e11dd63b163c6507f902a2a5c533d06bbcfda2fd6decb0037f5cad161df288f014c98a447353b752c6174482dec62f7bf4bfe9507aeb8972c43c7da3c0dbc0226f8a6467d5efd8b0dbb198d887f7bf77a22398f46eba032a78192290d9edd7fa8d6310b3ca1f16513cfe92bf74383119aff9727cde45f82a8378288cc657329c2e2aecceaa337ca2f82738a793ac01e04a1cbe6d4a32adfa7f9a9fc531e2efe6fac35573c1d620c6eb699534ffd7310b9a9efedf4e2735b541faa509960a6fb8b8d9e6b62bc466f278dd615b2849af5e3dd71a5f80b512ac3dd11d9d85859be7fcb1f0b909ca6978fd6c7b6557715bf202557aa0e134ceeed73635dabe563e5807d2cf1cf724e6e10d362873a9aa154b27a81334a20f8dd20ced5d1078cf580c4bf3b8432195a5193d4ebdc74425fe90a8841fa5b119a6c73e185651d4ae1ffe1b52e76e716757f7dd6abbfb29b064c2c9058530ef3bf057d402c678846d959f52938c2919b687c2517148f6976f8c1e65a9ae2f14129b2b7824301120f859679b5ce209c987dba9e4a4ba2eda7c302599819d5aef541ea80f16cadac1ef077d7e23da71548bcdc9ecdfc6f6a3dbd2803f8e2ee4864d57352782ce2f3cda955a71cee70a2acdf97ef94734735bf600f759e1285d309c1478b567a6f93779545c7e4f18ff5000511f7b62749558114d644332804a0f45737b9c188054297fd55900a0e8d1021ae5ce7269e27c8a7cd2261fadd7cb647f52e6536cd113667ec541716058c18cd1cdfafe73a50cb49ecc6b89bcbad7a05915b9083f7f0e95a70fcaa26e83587106d8efb9a0e9c92e89b125198141fbdc6be3072c2f528bcad4b9bd0f696b9e080d61fb6b1b266cfcd29610bd6476c528ec5efcb9679faf95419fc62f1dd67ccf78842bf0ae0efbd8c312dc99314a781cd7065b41c43d62a36b4dfd7c3c4d40fae46d0ff2ba85d1d632b1f2951ef5a5b000ee0797204467baf48afa114d4ac0f08ca98a12817140ff7c05609d883cbab5131d28c6816f42be1c49925af44e61f4eaddc16845a92baacf097414db37d71d34ace037c11e451b2214b67e18f30bea3bb8a794bc965c5be452a85c21ffb185d1e7935abb8d3bfcfcb9fdec9a9f0e5df0daf84afdb2f5e530b23c4dec3ad2e3ac470bc2f5d01674ba2dca084be514496a45b24c3b2eec923e16118b67390bfd11f40870cd053cf4b23135c46f676c48b1647a486581cd8ca999b4f0d6b2af16c5ada4f2c91511dbe9cf7c8e9b6323247c8e6a4cba261861a148de2daba0fdd512134c53a80bfbc8799f4e0593b6bb926905f2d6246df8fc0668e3cad7c8a5a9e2a1ca67a5663961d47b13da19a27344149b3d063d89f3ca4641ee5a644b63ea2fe13109475e0f4b3e8710e45eee34f7f5e986c45d93ff4d639e77c0428778a57baaaff001b0c283141f8bd56d51f511fec8c97eec447eaecf9c9464fa25cc8f9c8ca7f5ac0a52dbe6a944b24a414989aaa02079cb80a56b3f6df42015f5b82b3c312806dafe1dded17d98f5df7acc515ae09b0e50d85ec334c91fb066d570e6b1fb249b5d7b7feac53b317bbda71fb7dc161e263d6cf7c2098d8be290d8aeb79a5ce05e2fbfcf975d9ef7b71a0b05e7ce1df1bf82ef16e1218eec936e1cb4fded510731f1e2f39f38ea7a3d4d03365c5629a60ed48de5fb526042ca7c8e6052bef10a2eb2d4b129dbdacd95642a3fa4b1508b40bc4fcb132926af009b9fa450679a25b29fbf225169fdc23c185d5e90fdfa4c840607566375e7ff3ac31dce1507caa7a18bd9b66f5165c13a8b354a9bba2208af8a7d7bdfb9b28a0173f75cb88e7dc1206eae134f0fffa240d92a50a352375627b2ad23fd02bd77ee374664ccc89680ad0d459745b67967af3b76c6af257ef7f3cfa5a5ed5544f2da0f372ff7a8ef445a830d4f37e3cb74fabb1b0a6b6eb6213e4411546d3cb2bf2f103c85929bdf3bbdf9167d00f5724b09932163997e814aaa5991743e92b6d5cd0df5374fd088bc1ae9c7f197d5abb0b6e6f24e1ccbe0d0cf4c8b29f6f7bd0c48bdaa7c60513bd1219d7c41de0013a169687b65c56da7c7cc98c738c3bf41c2927e7531b80de465711e16c02fe6bd704c311b8e8e93dcf78969d082c58fd18b2182ccee2809061373903e3cbf8b07f7fc8c4ead913c586e396f1aa02f6a087f6b560ac3ad771eb1c736967372daf9935d4c7d222f57f8514281418266ea9eca1af22e5efe6773e0418cc1e2379b8a5e12c652228b3d5bb5e90d7fc0b440d644c20667d3a53af80aabcb20b748accbd406c8784ecdb8ad02a1f8fccb1342866c7bc8dc5fb24044a9bb4c8ad6de6d8962a421cb0eea2cf1a425387216af6c8adb2cdb3eae78e6c6df75e1d7a5400de68ebf4035c8768e0bb5a8ebf25cbbda0993f3475271673c4ca27c29c62e6c2a340c2e55bcfbd8ce23220561eaadf94240bae04498ddf5a8fa0750bcd9d13567612f368298f577cc28e793163e40702c6bbf262cfa8fadab72c0a026d6248e6c172704edd2b343922e264a5c6ae66358b7dfb3685c0e9bb8ac7bc11abf00ee80c83649f10c4a32583fad97b084ae27f0971c04090ca2cb76bc60281bb546cb6794c403a24a01ff79419526d82fbba84f203c2ab2f538f081347923a6f196a8af271662087f8ac43504334b73f3053f08be420cfcc49ab78069875fcdff127cc52356ee7ea16af1163f779c0a3a362cddb9544dfae4a2018e76ed7baed275d04795b3fe73945cbe26d2f7316e63227b98b23625dd135ef7ec83e9cfcf3d82d95c8a6dcae13ccadb6f3eaf6cde643852c219c2e3e537fadfe421be134e09633618d978ec7190fdc929a6aeb8540689150b6081ca9e9dc8b6e3aa5f84a4a4680b5ea25ff67ee0f40aac9546f8e71ebaff8d31995e6813e826d122ae424b9419849439abba2eb1217fb8b45481b777a9078d723987a6a7aba8452f7f5fc66edbebecd311804de67bb8d0694d925d460f0a67810eebbd3a728be5df558ee7849aa58097c26410fa13cadb10b9818a905b183a4cdfa8c2557f48ae93ff6c61e68aa090775bc0bf814055d332e610cee5c4a093c1ec6fe7335f72e3ae86d1f2f9c7a1a0f13ff3d59d6db1ef7ca5c4e0c1373f7ff03bc0d9b728a5eba60c7ac5ab25ad1efaef68bf0b002431041902aa98c03b1f70626c2c19535a792121c11e423342214e8ee94c225221a75f7fc1c4c55f44442c5b33b56634d19e5173b98c6c58c444ebb2d50bf91111ad5806b30d4dcd6a59f19f728101323e308abe6f63e4ac4c836fdd7cb1d1f2d520195f50c2236b7dc61065221358f7659bc4e1a3631120514773168efe8d42bf0b08a04f4f7e09303c34056147346df01c71c96cd7a31e4b42a9d36e507b1584cd92e39ef9cd48de37e3002c90e64026013a4f0ee4e9a9838c9650c3d2e0f161f66473236f3d4638e482a4407c9e766f47827eb850f726af63a064a1aa6d04859b0d28a4229b2e9e8d15fe85ee1dbbb55e62e93032a62486c88bfa5bdc9fbbcfde8b4091cdfc89fe4e34e0b3da2846011c3581706151a784ac9ad13475e3ba621fcee86cefda3b152624f11448cec72ade02c77243c43fee09fc0899e980d07a5471a497014b0526f4de0381f865ec81efcc2e33a67d5db4f14710ef74d03bff59f4d0b44ea56aea0c4c4e138a2e0a8e04923d2e230ce43e6ede5fd3ebad8ab4da4a2fd1ce40ea2dd4388bf72e665270981eaeca49d7243cf516a7b4222dedf5cdd6bd2995f66be7e3b4f8508aec7c9a2df1fb6bae03bfcf3609b9954e7c9f4402a00ca69fc8d1aec93e44c1b5b680fc4e23f62b85da3a5368058dd604f4371e0916c73806e21230a1902673eb3d88841223659866ec940300ddc6d122a8d7fcb3464a598c5f89fe48eb0f5833daa7f3c6d62ad24e00eef0ff198270bca0b1c3d37d6b31a90c4ede347819536a37fcee07bcc2a2b798ec7ee80ee5eed1533e9b17b58bffdafacd605dfe793afdaabd4b1ddfb35fc43327f8cea0de76615191d43b5ccd083155d6675d74ec8ffc2c52d004711d7b8d06637f08ad589def3a4717cb9747879de32ed0862426773d55b0c4d8082e4718a0f22da29343762ed1921936c992785637b5179793eb2765b9a0ae545bec37244b3d2ec23fe0f820e5af38082f8e8924e449a5b87c9247cc33a4f32f5ae4c0092b03d1af08c25da33317b3ea21af8329658f6fa5d720e10634ffb555d30111ac4321b4f65c58d7744f2f6721d5cbffeca0ba4ee96a825284cad7004ebe4f8765404bf60d2aac125ab744fc34ca61924912d8a68858dd0bb8789f353667b5d9425a205c343637f0309a61d5cd8c399ab90cfb8cea73568bd43efb311e0f18407232c8f8e89c3675695a4ee5b72448fcecdd3e3e1cdbb01cc89d202d228a56525392098bebb61735b31731d8ce9c12fddb33cc9066ee41c69a2b34c2eb2757c4a78d0a1c38543242360e0049f40172adc4beaa3fc19f3ac633bbe8f3149472ce6caa8a92f624a804bbb314080ca22eed23b81ea355b9bcf568435401127b74241b2f5bdd1898943043da83391447ea508a6d42f21c59c74fbd37cc9e2b3a4a04bc4c7693ffc7d9b10bbde3a5d74fb27ddeae5a0b908b5b1f566aa46a1f5d30d045739bacead195545950cc1cd8455888277b0f4333dd6644efb03bc4ad78a2d3d2bd93bb55d8b2bd697f822b6252c2915b9ecc21b5cdf84fbde158e20f8c85cda974611f0a2473e24aeb02ff5e810c70240bb3d634fc99c11f6ea66fd014e07270c3c65fcc52e0b0598645731a27f1c4618edadc99ac42bcc25e0fb4ab5637a1fadf0a84841d00ad6987a55df6b341ad9f3cfd3999c8cab5fda4c4cf3194f7b04880c53d1da72ae1088d6505f972f18916a399e52a39636b6c588d7b22da623c0501ba9ca0464d140cd9a9efcb89b854211b27510eb14505a0f93d1806c932afa6415e5578c47367460a19c90de64902246ba98d3eb897ba7a21fb4eff16014ba7901ba5d59ac464161f60f2fa654ad9a8440ee942e54b357e9abfbaad88562520e533f4d7769340ffbff24139796b295cf91b5b002e1ea188df32aa9457c5b29fc7200f297510a566d740bb820b5e3dd8e0edbab2625134d42bd546aaeadc31a5d699f4f430f500b1adae05035e0d54d478a959ab6c1293a9894b49422238703e8eac5a35af54790c9947d8ac4714ee068c39e9754674c4efd87a656252d1be597aa0807c45c380dc634473616c80c0fcd5b5a51d9619dd769f3c558c45cc3bfb39ef344b4e8f8ada27d312df464314314cc6350ddad5ce3d871e957b8dce6a0f4267321029beb89af59f4c454bbab9009022baa008419c77bd98c4dbc94e82ad604323e7c369e2649d38eb04118d5152a7b58ffbcc893f487b721dea407bf95cd20d852a40ab37efa9df181a5b6ca32326465264323c6f86ef62735234330adef869500ff8af4bcf8f77799810134334dcf23df733847b7353fd943235992fc7ee4b9e329df1b1250a7794d13d2a381a6203be446090ab45c0e11bc24ffc176a89b390829582573a72aefc8b1d95e807c2d3c47a395988c085db3863c9c82c740f3784ffecf34b5bc5817b19abf9b52ee8b9a31bcd0c4fe00401efdef93377ca395487f158af453de6255337d883d5e19034d68127a430ca80268b1202da78bc100f1e8865265ff2379c61a8495fa8b581ca68ebaf2ff53e3f778f91f90e95f226f062bdc2345ba9a9034d79968c2da1f3a6ff58d26a9cd6634452db4259d88ea556c0b54141dad57c2d99b32b113a84c82cb896525a2e139ff03de5fd42dd4bf93aab92088640df9f26048ea35a02255383bdec84a0c4fb1d3c19b087951b97e3e9098aa688b87c4c01f0dc755aa9bafd8684276f4ec0c471b62b08c510b16e3017fe7cf8d56ee4fd99c4a8b8e1979c5005cf4a25517be5162c081c9f1f8a7eb0129370c9bdb52824b1d6de08c358da58311b4274c05fced94f68e9dc5c30d12fc1ecc4cbf0840bcbbf800a19381898da3c23324038d6449471d5a567b2afe66e7468253e15610ff6151be59093fb8af15cb4476b08dfc34e7ef45fbfed5f1ce07c5ad796e69715477ecc616fbe8d1b62c482f351a4e36980c9af4df540cc903601942f229ba18331d23354d4efb8bad2d21e25e23febae372dd29aa15fa80cc2e4029958d5fabb2a50c5b525b04c6f3469ecaaf223e989cd7490a2195be7d39bd3a4b12892f56e63637291032e33abbb56d3534918d044bc5ff870de1de05a15a12c03a01e4722190561c74f9255147c2be77b59c52438c34debb49273e80ab2b8c2608616266eaca83761cb44aa41717bb5432339e283b37c279f117101d81fd82d855f4df66a61840dac6ae0540032b57643f79ca3c9d898a6b4400bf6da0f7886c3c656e7ddbf9ca36c1ff4156748e345baa64c57704911d66d27feebe7ac126b9405b9d12a7bb2e05768a5820d495102aaed95dc291a6a73fe7f114adee17ccdca6d5d7646b615e0fc42c2fbc094b2a90c70a7e12e5da66d42ab4742e9d1830621a21ac015d13484d57a1fd0afb9acfa90d3dcf6c63439ae4093a70f61100abef7447e4568254899a6e3befd86914494e0a54b7fd5e0366ffd5f0d8314478db112f706763ec837dc5ee38b4030279f7359fd051f77f24a4d06185322eef353f88483baf20e09a9e8e0c09d79a526dbed8f913968e4d0c4f1d7c59593bc65976e8047254f882758db0bcdbf84097ace451c4da5f2dd77f7d831e6e9ae4de5d69fb077465d33a67575669085d16d748aa352d5fc1fbd7b33a0468ae25fdde723100e534f4c42313fc265e09f9950f308616e58646a7edbe89e2012f5232b9b4e506d0e240c88adbdeb72ec25872aea5983c25ad8af5b0d795273c262815e1c4104c44d848d8208598d0a22c0d70431160a878002dbd2f72f765a76aab4276290258836c047251bb7a4803f46eb1e1404e78c5b2a4b6bd8be6d2598c772a586e79e2982a1569da61f120daa2b580df27a39ab5ce5d6fc2bbd8871180798239d2a7c2ae2cf04655649893b38cfb82c73a2badf5dbef768316662afc70ad7ff287231915c1c94854a07afcccacaf6a1d5068444f61084d38cc5a70fd51eea0887be1a98e10c3c9d522e349842c9ce6a8db531a9f3dc2820f3a15cf880e18afb30bb9fb5590369b058d238df7e3a67ac8ce2666dedf4c6dda95b67bc317e7a2567e5347163f258e44840ecb4882668b37b86647fb392362fecb9b8bf0ea2ad34dc9ca74fe1a8d128b8059429b4f9aef12768645acb4b2257cdfd00c20d4e15c8a1549141ea3995a431bbc700bc7a97fd5cf756c77be0002cee4c0bd5fa60484b506cd4ce4ef4e187656e243036283f18be513fd5aec3dd54c9915a2762a4744e2ce0684c401fd170eb095d78c053f61d6051fa1dfe99a5a47eb2e25b00644c217cacb614c27b92bca97480e39ee899a9f2b69569730e8f9576530834dc962a0869d865473f76cd6fca5cdda3969127e02122446faf5d2c163dc416a953b4a500bbb5b9952cd6aab667a2cbd7eb11e7308b479907f59d05f3905778729e5a30addd743ccd9b69a03a76769481aa9fd3ef16444e28860c9b4d99bb94bbe7cc702af5a7ff4d5dda897b327519e6e0a5c8674e6ec2595340e2c7bac1376a3ad38a556b3d840a42baf8e6d14207ff7b9eb31e949aadd707227294d3e9633633d3999df8bd156802ee344631b8c23409aa7c0671a8189317b1ea2070f295a62d3a48bbacbc962bd43ca25ef8dc5fbdee036daf8203a95492b1f58e1b339ef43887ad5382b7306904af161108a4b760da6176db2adfcb548e9ea32480dd3c0a0c17b52ae02289c5bb64f0f0823018c72baaba75e9719e0602ea1f97cf881df1413f9d56a3d0bfd386ab30b29a0a621e83e5d587be8067369624d8338bbf4017af449e18831aa32a97c1761cf25634b74761dfa0dd8bf8cfb4c186dd54ccac223a06303ea19e65d53ed271a15ec795219230bf47316fe8d4f0d0ac294bb8512f0e677d57d4a74fb74d7a72add1e0c41bf7446bde11063c92cd39954d70c39b1307ebecb0cf13887dfff471ed9715e79b224124897789548cfb8005f031228466294b226428a0938966bc0a6c5008d754692c3aa66e02ffc77d4a82026e2c13b64ae9e56ef3888707924dd7b093628a10bc5a147b3d9125d08434638555e138f50a5a5c0d08d84f8121f7db7491eb39b1427b63658c445602e109e2eab234cd18cbbab262472b20fa15c3abd690dad578b9f753532ac593fb346afd43e0deded0195821b2ee937e0fdc81e6b2ae5281e663000fb0c07ec8c33ea1bbdd01e99600cf3604e86ed17e022127dd37edfd835f2573b5c2780ab6a60c347bd897d3663659fb407eead77b2e6698da68acc255584dd313486dc8d01667a07ace124041dbc5f156490ae3e068343e271290fd8d027febf22bd0a732bdef8010f1c8abb8c8f0c171f0d08aef746edbedaf7e0b6d22b7d9be0eb0b902ba9735f58ee0068d65170c4b3d766e938d5edddb86aa2573ab60b10c9ee4987361860444a9a105b674762f1f2207f0ecc0d67636fa5d216939e0cc7730bbc30ba04343a80a686bb2b18ebcc14a128e67023d10ccf85d3d502e8a24800cff83b5dd622c01ac45e60b8801e6336f32b36ef23754eea8a6dc306c4d3c7e6a88b864f0f6bd2dffdf88a3850d76e8af82cfc31b3322896d27fad21f3f3be2f408f70385fba622975625b724756959e39a0cbe10481679ecdd40f16f0ff0fefb9848729952c8da777c91d2478215a1cafff42ef098a1b132d713ee6df7faec2e9c77bf77c26533b1cb11114a5b84d24a4adccdb15e71894e3c03213c7afcd7ca2b9d8f4f88540356ea8455f6cfbf3788aacdeaf4a3c6687843492c071909820386aacf2445da469170d42b74be85c4cc80a0bff7a141f48d8bab0ac34f74d914cc48446fb8fa413d365534197ae701b404d972bcab3ad3f6052440a385d621fe02fd77e283c71ebf83f6766c78c5182e2c6243c2ab250ecebaa0b8b3ac03a4b70a9abadeb7ebabc4d110194f0eb4e7ce2e6baada18dae203528afdb6a9fce647db26ff162c18ebeef900de2df87dc8b7d0e24868b813ae8808ac7576154c04a1ce4723abe86fb6db72ebc4997cb50a5fca52cc0582f05862af72ccbdc00fd4368e233f645f10453913d7d65f856eef15c57389e1c76b4d9025255abd8fad4237be22ec72feb984aed3f4cd6669e935373637aac1b8ecc117b13c958be5cd011b4edd5cca7e1caf5562c7a5eed4ff587cf85429790e3a11982d6d8a7eaab10dd3d7e193003c4e43a5e06ef0fae53bb7f60b6fa606ef1ddb88e84f08afab32d39ce68e69f77658a8cb5de99b3fd47fb0c07cce5390960d3edafe5c4bd1c25f929c8351ab63f5eaa181c0fe4ba868e3acf4350f39b5e8cba0524a8157cadb2f42e39acd502a2c0e1464ca27353de978744712a5d7615e812fa481e45a409fab091206ae84a27ba31fdb1bf6aa0b3b6dc4d619e7eff0a459bc215726f5feaf023316dc76a277cc19464ed7cfd861ab2797a6bee42e87dbd3b33dff3334edef25ea79376a8c0edd373c9a7095b46c063610136e4f686dd4731342e569199af15b838d99e71f7509d9ecbd87f5eed643cd96427b3bb9293721c9084f598ba37f2ab645f87345176e44ff0f13ef14a2184b3739fb911f950cb828fad06d8210ccfc7cb36e0873f566b21fbd5eee3b3a156324eeddde1330edf025331aedbe9026cda35147b29892164f2deff4d05bffeaed9dd01efd776abee744dae47e0b118acd783caa0ee74a239456ecfe533f9d983a2c3cad18b6141ee43b1f44e7cd9bf7519791cf515228cf5ef23c3893f739b06298f0e50f07b04e3a4cdeb85c8bd84949051bc59b09830c8a9f89e309735bcce1e02bf3ebcdd61450b21dfc6897c499dd9c9e29bda84553b5e61288e3f810b0f607f85d08519df6c9175e3e75e63c4d7f48d8471a9d0de731530118616e24a3edcccf61fd18c408ae61a3564c5c556c0b87094eef0c582f7e428f44853da44f7c7eba1dcfcf9588776b9a681f1f420490f880a3927071850b9ba07aafb44f99454def4440b154f804f7e735a7b85e8f6831cd58e11a84e154e8621931aa96ffad250ec3db92d91eccffd64a9531b7198e1eec5ee2e0b1f8be99ad787686e38da285dbf46d79eb90f1e205e1b62579d344cb1571ae16b7de129240c6481e8d9631a43ff97db236691d2f368a2a20eb4d3be73cfe05cf5fafb9dea621a92dfb9cf9aa31322db936eccf1f111f231d41f674e9d9359b68bddbe0ddb385701ae34255d3f665c9fc990f00635d486d48473cddc2ff853274d42aade50840cce82175149dc473448c43885b937f40b2f522a37ef535942518b397228d963f5272ba381160deb242a2045dbdebb31ad7f73e7403f5bedad10037d469797cc3a8a23961accc231e78f55af685e4100d6d0142090da4ff4c5baa540b2f3982602599a373a8a78580e66e0f981e543cfa0326d2e38c8b8554c00d6aa294f4f6bc67549503206e9be03255fdf9e86e148a6c31c0b8a82926fa868db7b123a7b509f35bb5bf89ee512d7f688adada05f8854a164b5bdbebdb3c4ab296e9707eefdbe9fee74f8608ff653ce95ad23b6b63ea0dbd998a01f9a8a53a6372b2ec6d7a4c275296cf0ffa53e2798c098e232e3da0458073c1c05abf2ba74afca11f5a8474bbe7cfa54c95b680b772e37719d682e3c0d0e4eae248dbe56e4a5282058b0e5b3343a7e976d486ccc4005aeb0d1316168a56b7177373326d57a69c52c269d56416d6ad2a1b63a9137f086ce28ef337825017b1cef0c14fe69b23947c6f8a9aedec9c62992f30c1a8decbf197e5ce7a5ac64c08d448111198a7a858ebf9cbb9adfcf857b55715a81a1fcd1b3a58f5cbfd775272e3a1b436cf87cc38b0625f841a1e0fa2ff9e86a990b001ea14906e9070fe07d92949e2160d3795606524c01cb286645c60f4b2295745b6f401a9a5e8fb3f40d4a1c9f554491f96b9e0287738a0481f9bb94fc90abb0f33299221e9e5b790dcd36d54ec04a733f16e7e0a84082505264ad487ae2cd8457ac27aafa1b8851ad1b0f24e854f4f0f7ec566b71e697d80571e99d1f6eedb95a669984d2669ebd83f4a79e2628b3e7fef89619fee4e2445da136f2d37bdf2d346e0588eb48672eab3749b7ada7646940652ec4ebabc8578e710bf26cf7d210a95b8987368e59fa8e311f76f4f12aa68f852bfddb63cfe68d6ea37de75e5db572ee373331184c2024d8e00ff824a72f74a88b9e935fd228b8ca0e6444470c629355f2ef676a475a36648a63878b0300999d024f84b1bd7bf3f6f13679984401909d3a13748f95ea4f397999f20518dc524ad649a806f6a66765d84eaaf76683e1b358f099acdb00c940d90f0e2894939ac2418e76d8410fd766bc027054c575fee859f592c0c57b8a45a13431b97198b1593c06dacfce22bb3154ab048e17a9fadf4ee5c67d25c0408a97496cf7075a77fc518a1557987e724a42d204cce15a068ba85c37ded33249d9bc8e3b0dbd24cda10c48f2c291a63fd3bb916d81bac3e3b66c52df147538a2aa8bd6c9dfda3cde0ac9b967d518cbd4e5bbf8197b8621ee99f0351dc669c621bc97c2be480cf53f9b3e51303658147ad14d1616ec0aff9b7f4025446239cc8d34d92843da5a89d2fba4ac06bc5bd108f4fbe20e9b285406c50b2d9d27f0c7d5698104fb3ec036460d1d98c1bed2226421fa7e4341de3b560250a4be2301f498a6ba3937f300c0e83582024e61cd121c86dcf13bfb182efc1a97ca74486a70a57ad2cffbaf86ba08d99a51e38eed783ad1967998849af2551580f010e53b886fe0cc425fb2d0ddf7f56e9e8a12dd70fc04bd1f041dddc191ef8a8d2971508728ebd141e39b604c35e304c623d880a6c26a995c083b6cedfadd004a782e12a18a53c18df011ff2457e06a2f0e3da533bcd1dc88fb6144040bb86e049aaf834c239e871537c4f0a11aee8fcae7e7f4a9e6a2ee40dcf2c5e78bd4bdfeea1d56dd8a5b8718c04ff72676189ae18f521cba8b6b8dde827ec03dd4e2053a6d085101a88c3760317a655dd346ed1505d67e15801e7afb6a9f61bfc9430090cd02c7fede89f0d83216acc5c91c8b8b30fcf2b9a194065de2e957a43989dd15389445e14f5784315b9dfba3b7ad67f429e8cab90e2085dce2ef066209f021c6653ddfdcf20793c024c674d1a779b5079b7db89bab547eefab33f6233593f54bef06ea6e4b8f19921b02646dfc49d9ac0e5d6578bb4610759a0a14ffa359e7b6d24339682dc67a33b788fe35f035747f117864e8163c42e2a48c6552d2d378e6e170ef9fae5e63382cd32e2d613d771e6915df89123878c241b4f0f91bf1ab3f98b8ba429cc6de5bcdc9290bf9f87a5de0a8a81af6f6fe1510bd124521b54ad49f75e2ad1502f0f3ee4118f728cc9dac03245f7e911fe4489f0b439362aac23234edd4f92da50a448cfaec7e0c11b3a4af265742fa4b0d419dcc97acd341bdfe8032ebdea41aefd3fda39b1ea95e3f6fc1470b81f7667ec6b5e39f2684cf7798d4efa472f67ae4d36800b49219158b626b1dd1d8e04937355cdacac40837de6abeeab13e417ac43c5fe2182b4878d1b835eb4d28a1c0639a6aab9363f9ddf81b57be67e7aa2c0dc9cc67d342d2271c73234384626f0a6d6dbcb7c6fe6d8d2b4408d6dab3814b8255d552a253dd55670b495127064408081cfb22aa40f91a12970ec4d84f97eb06f96125afec5032b0a451d760a1ea72cd5902218d865f365c7c424d2bf2499ce28e2ac81f4eb56f8764654e58aa963c2b4e1bd86cae573b029478f0ce822948f90902f9fc28506318c91017b9e90eb186ad6c8b39d3fa33db6eec76b38431d0fed45d865ae25dc9a86e40ab8ac74290e68ec96db61c8cf6a55478f569f3f669a9bf902b6ea719a53165c696ff68dd3af50eae8bbb8c9958575a0113ca02b813ac226fedcd465d0b46fd8babf4394386215478e4183ba0b28ec983881d8d06035dccc94817951d7c2c4133cadff0a8b3db808489026e32c8861131b63cde709c7e175dff038ad8018d601d387d4e5de24b2454a5889b61f6f317c34d8476a662488816d3447eb2ff25b9508b2015180952987528372b00f664a302051d144e648904e39832f0c974d8f551fe551d60ff2b22b8fa81be12c08ba113e5f999230658bbf8d714de27482b949f77d725afb134f43c57d7b6b60303da55fb2c60bfcc890ed4d8518d62c7acfa91d6d360fed2de9f0c2b3d1b3028cd25545c27501ff0c42803764896bef3bfa366df6635f84b226469e50745b3274e853b696f8f1ead8166e4b13e289ebf8fd2198eba4f0b7b6a15e507b6f833506dccacc85d96d3aa905ce619b7769bb0eefe54a9b369ac7973bdd4ad75d635f047c0b19a28e0f64cfb971b084883a8cc52a71848bb3f1d79148d695bd2503926a65c8164532d4793ce16d352d75ae6be2b90fe0d4f773213839cf13185811ad6db1f95e47cf3b322a807729c9fa97369f07d093c23de98e81f66ef2562a276ac5a267d6624d238bf07ba6883d02642c98518e2838723a597ea5d894f0ae38ef01c94835b3f9629184ca1b6f3c0ea1fe1b1b908b44e2707630c508f5b5ddbd627c79584906f676c8697c2ecebf1eb7f87d856aa4267bfe81d2f4354f1c9f003d87a7838838bb55a729021e1f3f8366db67926f738336196ce6579d2855eb38574a3f9afd6d6c4fbb06c145a5329f398dd2cd6154db787df439de78f68ebd2af73c54780ca2050a330239df7d52b740a4a60ef2d295ddf8db35baed040d3fb1f87215d56ec00cd2add1881598e0a9ea14efb8e1e1b7fd7f80b09e2bc26de3e351d1c0675bd9e4b0e57a18f10605adac9e567e4436cb64c04fb3881024c8032ad4f6bd9f6b935f018dfed3db2d0af6931f6809e32dee34b77f1a8cb4559b68defbe4b4bb58be3e3f662a7241fb896c5bf26e3f752818486a317abd622a734beaf3c2809ca223f821872b10cd4039d9654cdbafabe6b1904e1c962009604ad3ebe8df6a75e04b1d6deb7e91730f2f51c4639bf0a50c7535e17490643e77e55ab0b29c06cb5a070495574bdee449a86a9e46775a2f25273f4c313765b3a212a19ddd785d65806a09028c17359f5ee3e009aa9e22ab3fa3a4c22fd8fb4420ff1c81ca2b3434d7e244e8af97b21418b418441bda7bc33c8ba1e33052c3df5b44812f1a62227b88016d6b311f541891428568703bee1287cc2d3fccb7856f3dd0bbef1ac34abbcea3ef6ee93b19a42630d4c63cde32f3b9ec0e3c6289fbc9c59d37780f6d95059215d252f89c4573ca62d7afda01f6c0d2ea72f3bc93075b4a3c0a7f49dfe68459f7c55910f5e2a3791f4ed02589848f46d2c0e335f39b040892a635943ca256ed8375e695f4013d0b48230fdd5bdbc74a86fcc2a1e3070ccf6750db997c0381b0d8060eca99518cc8e299eeac03ad302a635026522004c03183256357b567712e57b1e8d486577a98349ff74aed8bf65f90cb1d9d87c09231d52d24699775c3ea160676709dce9ffcd85c004934f067d45cdff4abbb666669df34a3b8a3926f61ba89ef09ea33bf5afdf72659850a681a20c331b8e79fab465e7d15b716f7f70824baaa071ef6139b5f8ac88c0341206dcc05ef5ddfc0377ff480d3c19a2383261ea7b49f48853bbb707c5297133eb8b1a33d31a64becc1fab6a261e1c4d965edcded4f2da483a8aa971dc27d47a85476ad306dcb703a638d71bf9cd37c8ca4e41bd1de8f86e36b2417b10f8cec490b0a3404f23d24e9d1a0ee9401acfb181fdf5f75ede95cd97aa115c3e3c68de1695267036190cd486b90b2c1a51a2e3ebb3de52a9a65af2e14a652efd0569f858769e2012c5bf757895d84f392f8932710c621","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
