<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36cd4ed545642edf15958f7fdb6693072e7a5245c2faf0a7951f232a27ac1b0ee99d8442c65068fe3a7e40f2b998114778caf56502adbd16ee0c0fbf6107386768a9c5e8be0a98c1a699a85922fe0fcc0eb6de17423be2653aac38c793d155ce8850fc274f9bca839bf598d8951eb70329ff83ce5d7424c2986928c65485e6ddbf44d46d2aa1b0705e8af80584a2ad12e42e7017ff6a82da119c2128b14b4eb756a1b81070d49566981dc272a07d98fd0079c49d13f5cd592674ffde5205e08ffbbf849caa77ecf39a7c483e8f9c30ff33d2359be2442d04cff4189a328814d1eb910470a92e7c7a97c8d8bcfdfbc19f98cbc7d9d316af19de724cef4d30329162050c6cf15bdd9516fe729f94888d5c8e1a379f3f2c7649fc347085ecd6c81cd904bc26b7fa20d2ab5d5593863a150cd10cb6b94645d252a7ccaa2086487c504b2974b1713810a60f8d4d75be2a0a86a5510eac29a71c4d9e8a556c248668a24f6eb3fd6015d8fc3ce429b10746d4a0bf8fbb777580983e69b34813af4b06fce5bcc99e6435be68f9e5b714eb2f651c434f5706fe03e1272886a6c6324851cc718523a73790b89554d1505da432f0ba10d7141cf48e441c20f5a2067ff65ed64ab03a957b7e2574f5b53018cd2344ad1d0a0d18776fd4b4a5e62d156602f5a0e3ddac7ee718b224a92effd00f04c65e638ffadd6f9298b38295baf7744944812301fbfef38d984ecf42cd313808718e31c7842624939232ac8c7aa543640619a5ea1b5485db04c0ec634abc5d2c07178404fc79065a249722e1423cff76ef3166549c905fa86100a144a60099096b4f538cc5b3dc6bea977196e3c3da9de1578c875c9b11c6301b66b1c2a19655e1696f417aa2f329f9a41052d2f699acb0ffe3a074c6896d6791888a336d8076924587789737011576a9ea7d4257562a81c784987eaed10dc584cf35aab214bbff8a9e65800a3ada575bdb5e44f87a85572cc5a9692547f16171da536f7b3f2dbbe19bf8fd7af62105399d51715cc7aaf6ab1b7029320603380bc710a069c7843ba5840f87550b2f11befde831ae75ce9c6b0ecc9856dbcc22b9fd74ee1b78e21e6a148a4e75871f4219a3d193d51fba34bbca8138d8070e1ea5b3430b548827b4ad1b4a65bdca609630c7fd4cb6b1717740185ff5d2fd1bebdd42aae47e0d8b79754b10d435322448789fd1b520ad9cca9132b540c04086e64f4a029b3c1e5d345becf2a2eee9c10de1e088b22df9828f5bc7d26eb98f73187659f042c0f699c6dcd5cb9e6a35d7c6d4c79a5b02d1eeb31f64c21e35c700f6dbd507c7e9b8b4f661c287efbcbb5a5705fe5e083ec6ba416eec0e25fabb647a46e1391580c1ef6063a96720523124f84ffa176406b2115e5ce8a81b74a408cd4981c3b331ef0830a1662e4825c800090bd0e813b52ac2277e0e6c65eda7ab206363a5e07fb38f41cdc1edd08155b65c24e1eb1d3e9165aef54f6705bf6932ee3f8cdc35f4f39d176274098b21b9f77e6315866c9af0e0e517f7308c36394ffe43ab1bb32b41c7e9e4b5d9e0922e16221ac0fb7b6818047c1f789889ca0574b19925f90977af13466f14f86e9a4b7fccc031f79391ee7b092cfd3955907d6c7b35e2460cf2e53d1a90cb2e9873dc991c1cd4851b6863260010fb896b7009ba2e237f185691937bca54a066d92f44af1ef63ad548fb6265c2920a09d040e1a15e2e36d432f32e6d8e8040c43efdc1e9b0861890efc1109f161e48a473e3c0d4a8f57328041276ef7ef24388bcaca731be30b00ce6b2a2a82d3be11a8cc64c2251e4d40f67ac9941f66ab7c68eb45ac01d62b2a54277335468e1d2711fa4a8a847b82abacac020840cd14a4918e262f27d94cf306f91a9f81c9486a2e2ca250907940bdcb01ec3a72be1d19cbd2fa10652d8b85ba604c3259c2a05cda02f56e8d23e5c41a0c87da20ec65638a88d8cd39843dda45af8414684df878ecf99481e51029e864d3f26a3600458106803cd966686197a9331ed0b8d64bdb5b009c687ff627db57054cc110748b3f64e3bacefc222d5c577081838f790ea33032f60388741e927429870f4ffb439b091e43347ec4df5fbd2c69cdefba5bab14e432ca7467562a2e4e75584d05ee63cc22afaa435545f4a19c314ecf784f24a8b0349a050a390f66100e0cf8d8958ce480f877beebab2056eeb05bd332e279a16ac6663b96fae4d9c1e70edb12add29151904f01b34240943db9095905ebb80c537e49c8142bd6fcb2f7be651ee45089c5e22cd9597bbf91de3b7693751d4561721ed79ccd39cf01f3a959252af5a4c3c25b6ad5c049887c80af784f61099303ee63ee3f6d095685b6bf40416e394516fada5823de926dd66c8a776950cc93eaf0670f7a0038a6c5a4b739fc52964e45d00a083d9a2cac4d55e2ba47791ab0845abd5b59ccc57fca69dbafa1f9590e4f1c3637a3c0ad75efdb2f39f0c0bb8d6cc8d1a42982d376ad8bb8d6abf912a2c7545e39f1b0c4d0afc222293b562a80b4843fb306d50f3ba983b5be2b53b467992beba3a507e5febd730de20fd56263e0ecc360eaf488f9f9704c7a8b9e740616ece2322171689341f709639896ea83383d20ed0a8219292fddd3af167c4b82b19b553af93441204585416ee44608887042162ab388d127c8e19dfe63f88dbf5eaedb77930a1be7c73d224324713c8537762cad65971495ec5a399a08f7d2500bc49172c0caf0c8d439093785f0eb345f60aa51c6e06d59a112ce308545e4b07d889f2fa37ba14ee019d3e1692320c75cd9ca649d98439d34184ea24339b6c5a97e7305d367afe53891af8c9ca2f00d48a0b49caca1b30f9dcb6653883386c46a9f2e496ec0363b634a00e79ebbf54e2ac8deb00aff0148c7a871e7c4ae58944d7e834308e325ce8d976f659b48bf8de224d0f6218f1ce777d1381aa9fd876a316b39268462c346e06743a78d89aabd84cfaa9b92571914f15c546874accc7767fe31c808f1c491ded43708f5e608b13b1a0b4c264fb73ead052c88825fe4a7a499919b94302cf75470f960454ff26a0480c19903c0ff133e35145bcdbe6b7ee745d3be8cebf06c6a53ebdd94f23b8d6301204447320add893ef17c15f1b68f2d5e5a8c355b5aa7186a0549ec9533e7c11243b0c01d9381bd8cddd3053bc2dd69421f2d6b9ee619ea143ebe47feec527645f8fa5fec87899fe0b4f5964d82d2db522c86dbce840ab47039327c15951896be77007b060945c9b58012a1df30ee11fb97c2bd64753cdbbad25343977ee6e94e6e2246639a4e944aec3fc30d9410ae3298fe762dd937d5a07d9b4e56677388c40635e2ff0054354fda01b068386bd2c2a44abb1d74f5775138493ac85249e25aab947bbd1f60698131f0b837df5e20f748e652d23909f6788bfa9afdb2b80d489c121fe11d2ded2422920ed3a61e91765f80a9ed8b4bd07dafba84d1e44a2e0f4d377e3749c12335a16d9278f92626b66a23514919cbd77c36c7e081dfb22eba5b0b5202e5a3a245d45ffcef64340f55ec87cd05bb3a6ca4bd62260ced4e3ee99665bbbb8724a5a7a8e3de98ecf32d5ed6dd86e2c26c689ed2538d53bc6179676023605de532a0d8913e5d3d4a6a20ea796ba47959885119ea7669f8c854659be172a460ab69219e259f3e93c1358dd0910b2e971b539d523e006612b2e1be1da42857d22bf7bf6a45e0b50bc922de2b12ee23ded7d617ec9c238bfc67edec42a4accd8ff26fa6d527fe5311059fcacf8e24cde8258a749870ed94cbf5667f26a7b8bf3f8e9c1722da0afd43fa342d2c8354b43378fe410058359bf51171cb1729de55e311ebb4b7baa49f72bf2a795b336fe614e12f81819c3962bf713daf9deedf8da2a90e9df8f86e2dd0f7af99c3f783b56785c216e8805c2605ad819c02adf74181f59fb79dab894e76d8e6c7eea142c4c73930cabeb935508dbeaeb89e4289e44964217123198513ddb7f1dfeeff86902763dd4ec76ee928ef883d3d485d760ddced5bfff46b98632ac797965fbd7b3058ad98196c1e649bd798b405dff7be76d90cee11e2ffb3fa05a2ccb3460310097a737129d1976c20e92907d290e84e480866c6d5b2318891b7d1f10d97639f88560ab41647f708ad00c2e9f9c16d61ea784cce252659846212358aab8834c47dfcfe6825d27d45e40108eaa38ff72feb9e27b0066f14691ed25311413d6b7ffc77e8018e885dccc1b5be413a08bb97ff84da6d2bc0f69681c72bfee9bc867ed47fca87823d87fd12da4a365e71895991acef04eb2e476cef42ed18bbebda32e0d96ae11efe89f974bb88d934099df82be1ed5e850a2318b5fd249c404508b037c28569967354ebfa686aba9cf41cb8525181009bfb425d80cc409c6ee851b473eaf163b601d1fc2feec5604b53ebc551af9ffd23285ae29fb39a7c7c26c0eafc0558bed60d378694b2674920b73680e2d0c49f7a4cf68fe7e380149e5035c0c8809b0be823589469fdd6daca3d2eb8315028b34537053a37e5c205dad8db5b829faf36e78728ac3275ba2213892859af5e1d3d29fcf3e196215cfe4560731a09e2831dfdb57faa28eef24e13e5194c6fae4a4a643df951b8952a9a2f6da2e53fae96c8be86b99ee3984bd52a4155d00f5083764f992b10a9d7e9547b96b4ab634961ac11d62662ce96cbc1e604cf8f5d3f32deda1eac3d547dc655c29b3fd08630a07556389efb6cd6ac539d30b2f0129e8c492258077fa66319c111a26eed0bb33d23f3ccbb482b5bb520ccd3f252fd8b84e7f49880977c9541389a9705d3c854d9d6138571a9f3e645c640653a7e4e66a231525b24017b32c00ca031ccfaf7e835b4648d7ebd5f173ad472bdbc196a6c60e476d41595757df2a3b05e4f54b49df8de3c258b52b1be1648390dc1a51d0ce11ba2ae14baf50e1ea57c504cc47e81c311502d9bda1173b37ce6100d9e06ea8c156756d6234f679d817c22aff9cb0f35d1af5850e8d0bcca27e54ff9d415ef45327c81bd91de61bc1f22807338b0877bd23a6783dc2887c15086be638c50c8c340ec986a82468181cf1a72dd87929bb6426ea01720a649e58786a2ec5fc6c7af3f258fa00941ef2a9872c056b710c42ee9919b2028c03aab28e58fa1f1f9889d49895fc909de5557b150fe73893bfbddc366e41f6cda500d69e21e037eea451aa38af6f9a8f8fcd1c5c72c1e7fea71ae316821437a0867047266ce89a2ef5a3804bcf20da33af9f3a5492ef47e74f5c162630b3a2d6a7cf64f3f500826f3578f658dc93999702e38b1264ba440261731bed5eb1ae00a9800b322c005844cadf85824816ed7e61311494cffa04d725e6a031c2ff6dc7bc09bb9bdd2c76a465e4c5bc6d8c7bf7c87717d7eaa0a1f37055962990b359f1fa84442bccc46aade135dfaaff3511525cc59164759e0f138a52f4c9991e5a2fd34dfee02caaff7d8f7ea32f5946c86dc94e9cb49737b8f19db1ca00f11634f1c72bb3777340fcf021118d645ad9af62f6f0fb4b1f8212f926542a30412b832464fc4aad28e72fc756a9ffb406c4fe2994ba05e1c63e3e0c03bf50b6c89254b42b148cd1102a95f7dda6a666d2ce763e9e40443012c07b997d7832b3206b0773aace002ccbffb1647a1581fdcc9543aff42c040a59e688db19c2096c21af839fc7f4a8dc10bc967eb5b1083ff80b19bf109ba19c73ba72abd6009978574bd2fc4ba64f33de769b1e44fdd441188125f035aa413024f7c78c3a6cbd572acabaf6569f546673d358a39bdc56a27cc674fd1b0fe6cc454c1ef2c0cff93f134050574bff9a53304462c4bc7cb35fef4401e8f453f42d58e91e871bff7e2dc322906f747c95a535c96d7c0efb8c4996ae8d576724c9ba90c1d141949667ed35fafa76d9165871038e69561140ad833480e05e6a965059e81d197fd1af39f326df511cfae5ab7365d664ccb84dfa1968dc2291298fa11c154f96be53af2ebb48a99b13db2bf4dc3e8cf15eefa3854eefa3265f9981170304cf836cff9db3ad58489f8b06e261c0707fa9fa8b884a65caee6e45d104ff899e1c84d5f3c6931925d822c3ed75c5b85417ca969e9e506824ba95404ac0a6b17eed4167af04efd21e3b2947a8b4123156b87ca72df18b9492e074a88b6c9831c59011760ae32b91b50962b4b38aae900b4aec4219252004efd14b9e0803363d740c81a32aded00870afc59efef1d8d260cd80306f57ebd6362a68f3ee51c4d7582e0ef613622244dcea72147942da4c18692c95c312605d842cd426f7d9931b9068b54f0c1df689abd67e992be0938612a0fd625b9f66a232346da374db16836bbf9083729d8e2f436814b32f3b339817498811a5830cf312c363d54413d291a71011049f613b706466aef4fe8d793a2a1e526b04c4802aa8a69716c60d721c4eadadf1f49a8a1ddca7b4151ecb6b4fd2ab40d5106f7eafdfb992730265d6e402b8ead6d52afd1a87e099950993e1521ca486da9ced49eee626abc96b91481926f5aaf9ba5901360dd1b696780bd41bc486649d2dcb06c52ee2d1b3ba946f5fae0cfff5a2066b8ee280b73cb64cf879e0ec1c674bc7f649de865ba32c6d6cd445cc62ff00d6685f6843affc597b36f5249a875505d2daf407cbe4ca9e48e2f300f3fe43a769e1c8ab321bf8294ffcd5db3a0d90f8ee76cf6a7f33021b302d3eea89957783e5c93968834f811e6c187cedea0c3272c0de1284b03e8a95d205caf7fafc950be61f133581a3c501a0bb87a1a21fce92967a2efd9425efc8b88748ec9ea75c823161b01d5470fcbb878ff2ad8c8088f6dc510ef9f89f71e509176511ef42e81cfad5d4b530c97f102b8ad4457edb2545f81a069b16fbb3b5f28e6589e3ffba6d76d3df46bde7210b07a20890dc3cb83ae54074805f87b8ec06325deca92b64ce16b70998514b1cccfc6f0fabf96335d90cfb7b26cf8354bcd90e1c7fd4e1117cb6ed9447e45ed099ebc2a2c5d8923574f356d02d8bc8864fd90be9d5b64a2f159cf7dea27ec91d90a2f1a37210781cf61b0f6ec84ca1d7096216a16d50a03e7641390aff275223e2b103ffb338246f1ed2a61cd6047261c855fd214ecdbed812580935f0c25c1524037c247ffc197fd362101283f369539e4d079f36e781f6ea36e8294e4296a93649b9c839bab8fa222d3ca54f64be2637311d18472f0e92d892e02642e398952d6700f90fe313ee415cf8f03f5c4c4ab22b65ed8837da222732a1913ba4e9dd620e44c08e542f1cae850d8532edb07756eed0a5f195b5c87a0d844d1ee91a5df2dd2062befc9a01cd65c911cce4c12da5013fcaad8eadd9874f16462d77a46ef0384e0792e58e6e2bff8a75dfe2d9cd2e00902732af79aee9a3b7fdb6732db0431869b5a2ade5052ee389343fab735baabcd275bdc3397a6ebdf398e2ea1abb5d24d64fe2682dc1ea1c1590ecc82e6f90535926b42e1a2ea06a9cfbfa68d255a2aa7658f6cc07a1cce629007d0277a86b090588a7449ce8401587d24e054863ded517ad27c3cfbd4e1e9b45c91b32048cc91bb1d344ac599c98c325caeeb757bdd49b0c2d5a45a9be8f6053f4b7b8c0508d0f597e78555bac9ea6cba74e96fad8a4e68264be7754b324a423872308091864d4ccac20e0c5b9b06c79fbadc01303b1548799ac6d4c9d1accbc6edebcd3c0bcaf138e8be3d40f9561087447f005b86b7a28d612e390504d97e621b759988882a27890781e442e7ef14793e1e93b9e2c85ce3b0cd149d3d7c4efb66e350a2918f8ef5a502afc96aae5dfa8eb2a33859018843807842f9a44b5e6c8ba52e9da8db38ac118db6ff24901ae825f5d5022392c0f6a1085f1e3e8b131d4f424170e98664227146eb4770a95f17c501cc19d01c7b6d6a625e75aa7e419088968137fc35b3e3cfd24f062e218ccb413c614c64e47d38fec13d90d2ba73e2993abf72ece398210e62a2141ebd39fca3afce8ade88bb40c58ead4ebad9be5cbc0e3fc09621404f3b6bd043fc9194f5c1f1e7dc421dc5abc77e58af747e16efb58cc154cfee6bc38b9c40e0577ab875a4fc61d86dfd9be0d34bb70b90579e751d52806f4a953e0a008be8d065a7ed8b4cdea83d263edc91f49d3255eb4eb8b2da3f7da565db679dcae221d23c5fdb0b2842bd270513f7366a7bea79f90aea2112c91c0d1d87c3a849cbb09f093b589d0f8b686a83298237caa86b93fdc045080593e6fadbe89fab0f9ff1704735e5707445ec0f8fd871ce3f0e6f846366765da8a8a5bb6127eafd42e8b2a4ebf03e0d5eb0a7e40dc8d3140699141a390049d30167a6c524a15a46dc221bc9a86503736e47b7c987a9e11f04f37b717379b0574942a7781f569fbb6f77818a4908f57b5167ec81e45292eb6dcbd68b1d8b32a35b5a73a1f1eedfa9f51ea8ea7fc329f50a396234817cfdc60b51b4c152afa6ee11b2f2af1cf993a096c2000b093aa87f0e85fa93af40e48e3e518932f9396ea2a0b63b0c3174d2ef75cd902e8b0d6206b9ada6fad1809d43e73f82804ef6cbf09871c67b53fbc2ffeb4f9af852d1faaa71ea0c7223cd15d8deaa943dde7c10756afa2f6c9edd1be0e8fd58248212d73cfaf0c84ed29e85cdc5c1ddded53f847b752f99be2238ed9bfad95138d2dd76419f09d4702095cff1381678fabf4f3b742d66e33a7065326fcad372bf0af868243c9723e97738ee3f04917e98ae555999a5947b4f9237f05b072230dcb4c1e3cc2980d5211d2981d31dbec99bb0a36ad42d8c7748d42f9e70d81452fe1253fd77fb7f8003a60317d37d801310123087740692476788b8ca32a2f4be0a51aaec424f94d6f1c823a231324641f02ab0a8a1d6fbca569f405d2e6f036b2f14cf0232bd092660a016f7eddded1b456447de399232974852168b7bdf64460980e94994c3b023d06eff1038ffcde9757a59ad6bdf2dd532716f5d0c7e82dc941c9fa3140fcc1379c2b30d24358ac98927529ff1b394eed5179980831eb7994e1ba9cbadc36576098be5eafe96bc467765765d7a9e67704745ce1cf92da0eb2a0206f05cbe13ced81714c057b3ac88dd3b65887b1277abb2b11620397ba0bfacf2f591607349824fbc3ff12284b03e003cf8290281b2bd0e453bec2ec2c30b1312509c0a9f70bd68f5cdbab24480f6cf21020e508a2762748859f6da1258d66b5a41809844dba224516abbfdf5843f0ea6dca8914c03d1711786cc9e05a83b38beaba2549dc6bea2f172be6c700eb9c61cc9d0d43a6f7b6b08aec261fff7c064feb975577452797312e6fc07cb100880376f5d8fe6bca1c62573dd378938220678fc322bc3b99ad58fc87ffc7685b428faeaeb1a520b98bfd4191fa84aacdc8111d721a5dc4d7291e7a7906d620eb06adc16b5b6759f3b6ba5484807a38fa1a6f512ccd3df164c5fa42eeeb9eb8f4bf92bc0222c5ec530adaf1a634e2f541f5321330dba01275c0a6d8894903e02b4151407cda1efe9012382270fb646cbd5eafb2678d9f814a48505b62d9764743c7f8407676db81e504fc7b0f5dff92fb150e508348e68e1d590aebcd70208b50fe82123425a6f28b4ceb961bf34a3108a6a84055e41acc65a0f033e1de3f4c5ea8ad63d156bf8253106f0e2710dbb3a9f7dae6db7fe80d869799590ae11768a040c18c9343638007245e9f231884fed8a3caefa46f7671a9328b08de3dc5fc33dbdb23715237ed0754cbfe333c6d11ada6c9aee02c4b6e22664126d3c1f050cd0a89de3e17d11a5d41e64236eac86db4f64e63a9660230aa5a3780ad88f1f99ba772655253b51fdb7d2f96e42aebc012de8b208454b558fe9ddef242711c5e59ee7b419d9262fdbdc26bd7c3b049d8bd9bb507954249443e9b29e297f3812ec22618e96b0e0dcaf17009a11bd6839bb1d89762da5080d6933f4bc7f25d3183e564576cef845bb01dbd863f78f306ed262853c5a3b3bfa6708b96f7a978da5c20c0393ac9d855582a6d80c557d4ae1324f6f41cdb91b4b2a751c20a5b4a66135e5cfe8ee5b82853eb531892beba599d923b51fb7c05599ccc2ca2dbda41cab0b891080b744f8a2b8ca04d3ec8be0d97e56deb3cf56bf35b3b1ca2f318812c2143be00721d2b9ddad4079b6854d6aaa12b411901bf41e7e3708b07e1a051e343ee1a134336094a1d7754b030c71f20c5e6a428d8823d87b04b5e319492e5ad0bb166f38540517994ca6c67a01739345e8e011b174e6bee68c0b3da48c8f6b9a555237bad368261f0ed3fa111ed968125504833dac869eadd660faf5c6884d9e4ca2d55a4f6707d6b927f5e203a59b531d40fef6ee44303c8db8b34674c78878bc88fd0e01f40379d322f75276c739fdd6f199a5627c78b1c0292542c06379db8db232c35df617cb76383dd715eeda49c63d017022b9ee3d0bb155ff9738f84720d2e6173ecfb6985d5c161305762f8b865c4f9698782b6acaba3cffe1f0cb7f10702aef7a3fe4a64e9cc634ffe9b7cd69920cde6999d4e794ac670f5ca8d3a58dd84720a7e67ee2f62c40300d19d976961afc4d2d6f4808a17da5a73dd5d6d6bbfbe4d5de2f542731692a47ed0f795d783646dc2cc53033b4b8de40157f97b4606bec8137c017c9bbad6afcc8af459893323718a78b157971b2fc9c78141f5a03f41a0006b3b77e7eaad9d1b45b8c733501ed469c0ebd60ce9e1b23b23ca39674c9b50f5f614ad383524cf1f796d6979fb5b21d09e93b182968772985903a60aa36657206ce4535ae4c3d2a76a2bfbe802f5e01b5617abb86560344927afd94c2217d80d45fcf1b2d6aeec48df879b38f68e666b88b01b4e938fa44923d9c8efa13d0a3b7f60ea32eb91bc466c21934370ea2d454238878d36e1b23a96aea6e80e8f86caca8324b4359509cc843042a33f0e128e97e7336df43478fc587f4fb0c53a480c8c96e1e76b6d3fda9a3aea4c186e62ec258e58c80fad16958eec70ab2522c1cc19bab30055d25c9427ef135cc3c3a9bac59893a3313b3ed45eecea314ebf7c5f94e7d74b0687d806a2ad20fc3dd9399ad728b67155ef7355e0341033b14ea8bb8d54ad5feb3f22e163e0a4c3a075b7484d1b30477d24d6d16474c826f36df77486658eb6e046a058e1cb0801d229b5b3c6412537a505122ddfa8f956d93d2c42a83c7f41ddfb29aecbd3d9ddf555477a2aaccfe5b2854a96e8bc1e6ed6df83d125344ab4aa1e7da268f98db31dc49c53e803d244afc8385691a3488d042abf90bbd665b2b5ce58898cb847fcb7435724ba1db7d5b3f80cf8d3ec1386888ee34b2f6198faac37148189060329bb0abab0a08d8cf267c2d2e65577fc34945a1f340231a4fd915cabd42cfe0ad70eca19bfa9f752f9a47b5522c1600c70d57f1cada78aa83bd8fbc4e5a554214e692289e6853125f745c9f91b2c3950b6292a6b74a33a33eafce8cc3b6cd3dccef08d6bacaff22bcf3674ecf27ca9094ba0c6198f1e349d3ad73fc06f74a345ce614dfa150164e077fabea10ea1e62e3041237806a48046da34029cbbdad314bfd65af94717106750835c4a64fabf87d33e7c27857331e6db9c6239329ccbe873e7c8b6da569e8c150e5b537c4767d59e7efb67be84b67eeb14747dd97c9e90c05fa4d88e9f96e21ef6aec3e826dde81fdb6202670bee1d501c094454fd2eee22fd4151936119b9956cb16f92a538aadb132f9d3282a6fad8a8edcbf8008bba13c97c329584e0ed1ac756c438a895f45340a704a9e5f036f39564ba1cef6442bf5621876b7b8a3cab96d935e1aabae104fc9346c3aa020a963b0b0cca0795ac68872f950854f4139db86ff93f74339b1546d147ac11805952d77a2a51dd21e16f80fec4df58a8bdc65d4277ca245f50ffde7e393e23e594eeb96149bd474f047ac93c3e5be807e4010350f649baccc23323c2907f895059a7c2f82cc82c724c6ac14c176c67082c49a5ba3ad770aba3da95952d0d5f29a922c56d682d9059cf6ab7188bb7b6afcf8015667d6c1bede06b4fb4d40b85363b68146319fc3c987cc3ce8fbb7f909e59c11ddf152b5426b069b5fbd70762056958519b8e4d0c4e673552b925008e14ae7b1c730fadfa84cd348ae9d9ac3447535a7ce901d2344a1a2c048074b67e769a2dc568ab4eb204c7fa2417526ffec3c9e95799a939e5c74b1a814d693d966f35e45a45d7f044a5ddc989f75357bcc0e955836d2baa7f484d9a398281dca384ba88e462152c5813bf266e9b21228449e531e576373ac1f37f8810d903bc4563d3202bc6084addbd1aa5696e64a71edbf41ef0281486174bc5f911853a660d73fc3b80d26352976b7d28f001a4c4692dc0047b82a3cf881515426742f66ff8f8eb786f02e3a777e3bc33edaf28ed23628019d9feee6beb79c70c3116cac9f1958502686070eba8f1b74f122d4483f07e3724ef6851302e8ba481652fe8f191caad409045994b35a9b6db66ba0367e44b3f488a67aa8619c7d477f8efcc9869593a8299bf469a9bd9f8558284e1b9a710c64ad155ec9d050a1991f1794b671b62693981e21eb28d16c86dc4019da3756148ff11dc9967b441d296b305aad9f4cbfe51209a662609f755ca67e8d8f2241a364f0a58a412abd26637b59ee398b838c87da879448c90a31c493ab598784cb08eb374425c6ea5ba2bfdee55958dbfbda714a5e7a35830d78818c512bbba22327edc369e2191a576bbac3f0546a3875ef1f56d01831470adf877ad1edf553bbdc26ef1c49ac986e1ad07f136e14f7644688529f3754c1a7e2a0d5da65772828e69e49cdf852552bb279216c1618814ff91ddde3e35919774d8a36f9e1fb8b1065d676a21d6a818e6962c52290e1922af7221df7ce4c5bde12318afe8e12132641b8e050dadc2b66e5ae36d2b46e9979f8d9fdb6443cac077a853b43e76dd2e8e52499669db88e45326723c4c7975ab80bdd9d4b991a719244d59000c0c997a1f6277a513c8379179dabdf3a23441bf0cab2e3e2e8feec122ff222bcbf24ff253e353b7e8fd38964e3faeb8fed5fa7e123d6c3902c3c2ee60835461745c2bb8c694167e36ed25a0b22f800bb5602bec6eb2f6a59ffb0d41198b70c4c3bdfc020f354e92a391497f9333a83d404bdf35c992e150b76560ff7f5913da43d6bfa68a402b4cb5e2ab757f4ee21098cba8112da7fec3b51b5388a9fcb7fc7fc56f33f87a033452a56bd72fdce3935c54ac5a689884b6b54927f13972fbae9b542ebad768b931adbe72567f54ae90426ad4eb59dfe68067cdccbc9450ce3e7ad9559577b15a249dc2c63c4aa2348f03096497ea81521877e13e31a870485d478279e4427f53370c6df31d9fde006043228fc5333a6b0a0787483c79ffba3f51f0518c03f93d1a2db22dca66d99aceae85cd8c8543ff18d19f0ef7d883c5abe1b4dacffb91529df0000776dc45d17e0f908d09bbf8fd624522ad2fb12980680e9bd8be047f45d2da300144fb35b329a895f81624df4c17716f847e038c87a28c0df97db9dc58a657434a291c22b302adc3ce773a2a90989a64f260872d53ffc7381c43a422c120747d866c49d98337695178e7bd9cc41fa4fcbf80eb8ebb75e40a03c0140540dd3ee980912c875160acd3b91c8918a64c2cec5acc8641dc535df3d3b20e3619d7a22ce8e22d10c98cf5eac3251898a34cb9fbbc3a71e22c74a194c6198f6b7cfb2d2df8a4a09dbed0a4a0449c8f27f1db8dc30bd4b5f452af0329ce9f8125c429856fb0a0d1c5b86505f83e5ce7bfa87d9591e8b2c85e1d24153a6bfd6b872bcfd13230bce9e39c7006753d0b5804c3dfb8c5f5de3dcd850b591092ccfaf7c901b8fc91c9d21dacd0e77207f30f031d340a37618fc1be38a508c0b509db4c7752eb8d0473ccc47adbe7b575875dc8304ba63d340236e928378e404d8522884cc18befca294524f833957a3c17b116e25e4d82a57199d794d614e971e45226a34a30dab0b9436f3f9ef78dfd17394e9d85a869ca422dfe5b4719d75a7e2968bdb1f393e920314687194db62fc9c01c469df484dfd2019b23689b58406c682f5972b8841715a29c97e15476277cbae087ade651fc7b9aa505b76a3e606ab1f62d63c34bcf4b2efb3ed2098f27cf459fbff6ac30309739d9a32d6f1b67a7917c59d6c36fd7cf2c4277ce69bc198477a603e1edeabde548319a6053e6852ff47bb6e4b15a8252f2be368901b27f4b5133696f54d949a290520d2d7f81383cfd6062e03629c3cc6a219347a97919b78e04062ee53ad420e7f11156794e6ded2c77f19d37bec3c731dce438497435c668cb5d9a67384fb6ba20685535c8021d2c22c9604222fb741aefe63298f7781914429b20118bccd932bbe529ff6d26933b64a78b77aac4c014537eb671c9c40b9eb3e044b3aece5e5beed0545b8f3065f83a53a6046c19ca143e01cae03953dadd7b9026a37fbc0802f7ec8bbbc66defb4f2a24767429a58f3cf1f0ed0013f00a3fa78e1f611211302ffc0df27e878b4285a82323434879991842dc5f3e5aa4bae363ba50c3655936167707565b0b9debbbbebe6f401d2654693aac01d2bb472c0c217e339b7c7498c3b992c5d9c184a26df7e72255084379d7f644e94df116d8cd2c41f6cbe203644ec13da7287f48135c8f5360e453c1f957cc26b057c43b9e29de5699c805ecebbf1957754010d0edfb197f406568a27cb5a3dd9dfa99b7b25cd7d9f216da2503ce520895496ebb8d64badc613ed6bc12e3706a40868b7b96b252d3d54582060fc31b48315e1bab4b183a2d0f6f7facaa5718acdd0a790f9d741c1f2554c41b71fac78df25547945f550bff35112793737b4f2f5752e9560e9cc9bbd09a67871fa1674cb9ca7be3d8bc6526168863f532d2c5b8e4f6aa7472e6616fdfef9341802652ffba963b7c3e862a678f2de8135648a219d51dbc6f169129d8e0543d3286aa79a4e1ec907f8f68177b8ce58820f909e2bd3cfbf8dd035d0894b084eeb1c5c17d3f5b97489eb667d360534739ce9f2fb6ed87de1444303b7d9079977eacb1cfe85a3dc5febff7bfb9b55d5e0809a152778d243ee18f5f7b81285286621a5f572d0befa4a27089e92f76d9395f83f3f5aa64ceae814e5b2c45b024a1b43c6ab92058d6f3f38451dc9ae403c18544b5f68e0e1bec1f99ea1574892b5cc279dac6f803753740c2cb4166211707f4d1bf8fa7295b041439dd44a3ebb30075d94cd147a4b680ef93d7338699c681be4060b88a8dbcf3a159196d8f860f267c2417681c7efff5f397503786d90d615dda0aea7e10936914fc97b83a4acd784816710e416fab82852d47d6b532d80b05191b9cb2b6bf88ab678d52d7c1056f1fc2d7cae602ed6a537b91a6bad1fbcb0f97a60ed570d6073a62d41d44b636b13dc9e095494647a0b2367c766e03e0603053c5f311fcdfd89997a653e6170f4766cca9fc80220130c9cb3c8066baa53de168968e9eea9f18b6b9a871472d484e30ff109809a14ef078ecbe13bcab5e45ffe299a87e681a7a3e30be3ffa547cf85c337e5154711cfe23dcd28b12a9eb7d2be4fe587f6ff456817f2bfc1b3661a0c676e6aac41e43767256f1fa619454ceaa020eb0ecb82f601e7d35d9dbf8c97691dafa0f281b2f2ca13db4362ec6bb2072282d66857b6681afa9a914fb5cb139eca63dd52a9a13a657b134a75d678d0d6d914bc4ee628f84accee54a671645a828e7f99cf25e129a7916185d84992c7411ffd4c7f948c91590e8ee2771741c01e31dfa54849e57f501bdfdadd00cf7d6a39a918be58766a3a376a031bb5eefe3a9e9d56d2650b16f377814388b29b147669fbb1116c1cf4aebb737aebea2b1d7b3aa55831eb2e94c6ed26b5024dc104ada99a9f440e1ec1938f7f466f6d92027429751c1b8ef7c0afd119c4c1b8eb9e4b2cba89536d708e42d98fc0f9cdad52a012509975b68ca9dc5f56e5fbd3c6ffa4eda671c59c778ca00084c69b30e9d3ee250bbdaffeec950c06a1dae3178bd41b6497b3d668f0da077818899fbef078f19eb6d01dd252bf118796711ab84242d6a9d86bd006a79f82ddce224bae3a61f199405888f8bd834556bfc59ab35c1d38d49b09be2177d088ca29170d14835ebba5cce764bb23db26624d02174669e8ecf4211584dd1113ffe4c4415797614e3f2c60923746e73a6d2088a07442911957d9a82fb354a9ef07c9834a551dd63aca8cad234cfcd63ca0a4a73eb371ddf4b7ec3a25713233a01c112ded4b603ddccd3f998573cdb0546a2b6ebf9bfe88a5e167b73b3268d440ce747e6cb13f0b2bfd289a03537d1f900fa8f2bfe26571a70c7899fad9e06601bc0b5e59b854a87ef144ec5d60411ba4f973fb2284df5d7f5bba474ef250011e969a636fe2637f20b4bcb3580903b2f0fe9673c2c0fa749f5f4dc194ae6338f3bb9fcbc8766ac6db36e225c857bd745e16ea8588afcf5129242e38c55b19eaa4819cab1dbe787cf6a8c484f557fd2a4bfbd6ebd94dbd1482fe50552fb3c1bc9ee4599003c5416ecbd3aebccc22ec424c8b615ed2c40d8b2e45014f458a8b6713891652e418e9dc0c466989bf8150412b5cea5e851fb5e9551d627f6518e8279f729b15cc48d3c066e7ac53186fea0e260788b6087f7814536ad94f8c44aa01537301f0f3d82d9d179bff591738d462c419a901991f865367f1b99bdb01b3d71f0984ca1345bb5d623f202fd0a45ef3541d06681ea2d12938c101ad1f19add37bd9864fbb6a5123136ee072a1a26861e576baa616fee4b16e18956458ea425cd0e04c685644b7ed6ff711163329028387ea743788ab23c4a861b27577db2a5bc08ef401e95d9aa458fad0c302879220361d14deccdf57e41de60da8f6b389971c52b214289889743aa3689ac1d2461b6ac6585d6a25cf89d7717c76184f57901c13c51bb375a733b91834792e0cf9b68466833e0cc6c9292d3907825e5356ff2ea2b53c72d75fcbeac5e25ffdd8d7aae19df583e090f16b06ec870160d9ee8dc75f1fd899764f31db9304812bde23d941ef10bfa1b52ddcffb63e521d1f36252fa93fcc4fd541f6786b3fa5eac16e760ad7776bb49206a6cd0d67f44e3806293beda22e20087ec9a216511bec225d659a61cb5aeeba842e5213897e90dbed96b125347daff73f56a2a17f9a73871b1cddcf75379fe5945fd78531a82e06c4e13d41382bc0347e00008c0702ac66afc8a7b6ef9ad086efe3cb9f24fc7b1bec6ee90675ef0683af8a149329e44a64c077eefe68decefe4662075962e8b5c6dd5651ee9b7d2620b4792049aff704c816fa5da4152a440f27f1cc15eff6e8f4e61869588c0ae136fcbfb0cd30344640478c01b810a3b0491b3046a3bf3623897452ff28da8d9b598350b0918a68f92bca35fd786247ebb5185da680c008bf0f0a25d9eda471769c1429097fc425d84b00cb3e083a2ddec3848fcc4813944a69e4898ce384ee2d92032389bf1f58c9febc9b7aa3f024e76dcdbc258e77f81be6820a1ad1d2553d49b8965f2adf530368133ceabe772d720e0e594b1a4569c9b85a640b2ba6edcb6be8c00131eb831ff27e56eb533a9b8d6765e64e561f291c22a633963bed0c1fe508ed0029fcaa4c9a85f1ba06bc6681591ecb6022638279cae34511ce71342f21512fb3a43d14eae4bb67ced14f4fae022fa9cdb7499e2dd52115df418ac0565449d25804a51e065ff20b284e538824ebda607ea71b0e020f30ddd6c38b819cf48f281ab12ff4fccd73c09fbaddd87c89e35f3a677854f63d9e230511d50b9e418a65f8a023d37b0c5b34d86de67ea881476424cdc68a214e264e941adfcd0795e2275217c4c7318d28c7823d13953e67bdf2f9d3270bf379b4b10c1e7681389827c05ca54e09b4749778211d279000d4eae096936ba160652ec97e4392f669455e5643d8d6c2f7718eeb0aa70bc13411be6d037a445c99a982fc87bb8c2a7177cd872d6f5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
